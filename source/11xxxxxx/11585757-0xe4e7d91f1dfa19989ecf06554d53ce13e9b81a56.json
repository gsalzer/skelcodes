{"status":"1","message":"OK","result":[{"SourceCode":"{\"Declaration.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./Global.sol\\\";\\n\\ninterface IUniswapV2Factory {\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (\\n        address pair\\n    );\\n}\\n\\ninterface IUniswapRouterV2 {\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (\\n        uint[] memory amounts\\n    );\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (\\n        uint[] memory amounts\\n    );\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadlin\\n    ) external payable returns (\\n        uint[] memory amounts\\n    );\\n}\\n\\ninterface IUniswapV2Pair {\\n\\n    function getReserves() external view returns (\\n        uint112 reserve0,\\n        uint112 reserve1,\\n        uint32 blockTimestampLast\\n    );\\n\\n    function transfer(\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function balanceOf(\\n        address owner\\n    ) external view returns (uint256);\\n\\n    function token1() external view returns (address);\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface ILiquidityGuard {\\n    function getInflation(uint32 _amount) external view returns (uint256);\\n}\\n\\ninterface ERC20TokenI {\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )  external returns (\\n        bool success\\n    );\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )  external returns (\\n        bool success\\n    );\\n}\\n\\nabstract contract Declaration is Global {\\n    uint256 constant _decimals = 18;\\n    uint256 constant CROP_PER_TF = 10 ** _decimals;\\n\\n    uint32 constant SECONDS_IN_DAY = 86400 seconds;\\n    // uint16 constant SECONDS_IN_DAY = 30 seconds;\\n    // uint16 constant SECONDS_IN_DAY = 1 minutes;\\n    uint16 constant MIN_LOCK_DAYS = 1;\\n    uint16 constant FORMULA_DAY = 65;\\n    uint16 constant MAX_LOCK_DAYS = 15330;\\n    uint16 constant MAX_BONUS_DAYS_A = 1825;\\n    uint16 constant MAX_BONUS_DAYS_B = 13505;\\n    uint16 constant MIN_REFERRAL_DAYS = 365;\\n\\n    uint32 constant MIN_STAKE_AMOUNT = 1000000;\\n    uint32 constant REFERRALS_RATE = 366816973; // 1.000% (direct value, can be used right away)\\n    uint32 constant INFLATION_RATE_MAX = 103000; // 3.000% (indirect -\\u003e checks throgh LiquidityGuard)\\n\\n    uint32 public INFLATION_RATE = 103000; // 3.000% (indirect -\\u003e checks throgh LiquidityGuard)\\n    uint32 public LIQUIDITY_RATE = 100006; // 0.006% (indirect -\\u003e checks throgh LiquidityGuard)\\n\\n    uint64 constant PRECISION_RATE = 1E18;\\n    uint96 constant THRESHOLD_LIMIT = 10000E18; // $10,000 DAI\\n\\n    uint96 constant DAILY_BONUS_A = 13698630136986302; // 25%:1825 = 0.01369863013 per day;\\n    uint96 constant DAILY_BONUS_B = 370233246945575;   // 5%:13505 = 0.00037023324 per day;\\n\\n    uint256 immutable LAUNCH_TIME;\\n\\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // mainnet\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\\n    // address constant WETH = 0xc778417E063141139Fce010982780140Aa0cD5Ab; // rinkeby\\n\\n    IUniswapRouterV2 public constant UNISWAP_ROUTER = IUniswapRouterV2(\\n        // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D // mainnet\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n    );\\n\\n    IUniswapV2Factory public constant UNISWAP_FACTORY = IUniswapV2Factory(\\n        // 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f // mainnet\\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\\n    );\\n\\n    ILiquidityGuard public constant LIQUIDITY_GUARD = ILiquidityGuard(\\n        // 0x25Fed8E81026C686BA20Aa340e536Cd45C9d7e7A // mainnet\\n        0xAD43745eA0A7DCB071047a07f704C983Ce2761E5\\n    );\\n\\n    IUniswapV2Pair public UNISWAP_PAIR;\\n    bool public isLiquidityGuardActive;\\n\\n    uint256 public latestDaiEquivalent;\\n    address[] internal _path = [address(this), WETH, DAI];\\n\\n    constructor() {\\n        // LAUNCH_TIME = block.timestamp;\\n        // LAUNCH_TIME = 1608681600;\\n        LAUNCH_TIME = 1607040000;\\n    }\\n\\n    function createPair() external {\\n        UNISWAP_PAIR = IUniswapV2Pair(\\n            UNISWAP_FACTORY.createPair(\\n                WETH, address(this)\\n            )\\n        );\\n    }\\n\\n    struct Stake {\\n        uint256 stakesShares;\\n        uint256 stakedAmount;\\n        uint256 rewardAmount;\\n        uint64 startDay;\\n        uint64 lockDays;\\n        uint64 finalDay;\\n        uint64 closeDay;\\n        uint256 scrapeDay;\\n        uint256 daiEquivalent;\\n        uint256 referrerShares;\\n        address referrer;\\n        bool isActive;\\n    }\\n\\n    struct ReferrerLink {\\n        address staker;\\n        bytes16 stakeID;\\n        uint256 rewardAmount;\\n        uint256 processedDays;\\n        bool isActive;\\n    }\\n\\n    struct LiquidityStake {\\n        uint256 stakedAmount;\\n        uint256 rewardAmount;\\n        uint64 startDay;\\n        uint64 closeDay;\\n        bool isActive;\\n    }\\n\\n    struct CriticalMass {\\n        uint256 totalAmount;\\n        uint256 activationDay;\\n    }\\n\\n    // My Staked total\\n    mapping(address =\\u003e uint256) public stakeCount;\\n    mapping(address =\\u003e uint256) public referralCount;\\n    mapping(address =\\u003e uint256) public liquidityStakeCount;\\n\\n    mapping(address =\\u003e CriticalMass) public criticalMass;\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e Stake)) public stakes;\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e ReferrerLink)) public referrerLinks;\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e LiquidityStake)) public liquidityStakes;\\n\\n    mapping(uint256 =\\u003e uint256) public scheduledToEnd;\\n    mapping(uint256 =\\u003e uint256) public referralSharesToEnd;\\n    mapping(uint256 =\\u003e uint256) public totalPenalties;\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\ncontract Context {\\n\\n    /**\\n     * @dev returns address executing the method\\n     */\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev returns data passed into the method\\n     */\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\ncontract ERC20 is Context {\\n\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    /**\\n     * @dev initial private\\n     */\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev ðŸ‘» ghost supply - unclaimable\\n     */\\n    uint256 private _totalSupply = 0.404 ether;\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    constructor (string memory tokenName, string memory tokenSymbol) {\\n        _name = tokenName;\\n        _symbol = tokenSymbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the total supply of the token.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the token balance of specific address.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    )\\n        public\\n        returns (bool)\\n    {\\n        _transfer(\\n            _msgSender(),\\n            recipient,\\n            amount\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns approved balance to be spent by another address\\n     * by using transferFrom method\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Sets the token allowance to another spender\\n     */\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    )\\n        public\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            amount\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Allows to transfer tokens on senders behalf\\n     * based on allowance approved for the executer\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    )\\n        public\\n        returns (bool)\\n    {\\n        _transfer(\\n            sender,\\n            recipient,\\n            amount\\n        );\\n        _approve(sender,\\n            _msgSender(), _allowances[sender][_msgSender()].sub(\\n                amount\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * Emits a {Transfer} event.\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    )\\n        internal\\n        virtual\\n    {\\n        require(\\n            sender != address(0x0),\\n            \\u0027ERC20: transfer from the zero address\\u0027\\n        );\\n\\n        require(\\n            recipient != address(0x0),\\n            \\u0027ERC20: transfer to the zero address\\u0027\\n        );\\n\\n        _balances[sender] =\\n        _balances[sender].sub(amount);\\n\\n        _balances[recipient] =\\n        _balances[recipient].add(amount);\\n\\n        emit Transfer(\\n            sender,\\n            recipient,\\n            amount\\n        );\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount\\n    )\\n        internal\\n        virtual\\n    {\\n        require(\\n            account != address(0x0),\\n            \\u0027ERC20: mint to the zero address\\u0027\\n        );\\n\\n        _totalSupply =\\n        _totalSupply.add(amount);\\n\\n        _balances[account] =\\n        _balances[account].add(amount);\\n\\n        emit Transfer(\\n            address(0x0),\\n            account,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 amount\\n    )\\n        internal\\n        virtual\\n    {\\n        require(\\n            account != address(0x0),\\n            \\u0027ERC20: burn from the zero address\\u0027\\n        );\\n\\n        _balances[account] =\\n        _balances[account].sub(amount);\\n\\n        _totalSupply =\\n        _totalSupply.sub(amount);\\n\\n        emit Transfer(\\n            account,\\n            address(0x0),\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        virtual\\n    {\\n        require(\\n            owner != address(0x0)\\n        );\\n\\n        require(\\n            spender != address(0x0)\\n        );\\n\\n        _allowances[owner][spender] = amount;\\n\\n        emit Approval(\\n            owner,\\n            spender,\\n            amount\\n        );\\n    }\\n}\\n\\nimport \\\"./SafeMath.sol\\\";\\n\"},\"Events.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\ncontract Events {\\n\\n    event StakeStart(\\n        bytes16 indexed stakeID,\\n        address indexed stakerAddress,\\n        address indexed referralAddress,\\n        uint256 stakedAmount,\\n        uint256 stakesShares,\\n        uint256 referralShares,\\n        uint256 startDay,\\n        uint256 lockDays,\\n        uint256 daiEquivalent\\n    );\\n\\n    event StakeEnd(\\n        bytes16 indexed stakeID,\\n        address indexed stakerAddress,\\n        address indexed referralAddress,\\n        uint256 stakedAmount,\\n        uint256 stakesShares,\\n        uint256 referralShares,\\n        uint256 rewardAmount,\\n        uint256 closeDay,\\n        uint256 penaltyAmount\\n    );\\n\\n    event InterestScraped(\\n        bytes16 indexed stakeID,\\n        address indexed stakerAddress,\\n        uint256 scrapeAmount,\\n        uint256 scrapeDay,\\n        uint256 stakersPenalty,\\n        uint256 referrerPenalty,\\n        uint256 currentTFDay\\n    );\\n\\n    event ReferralCollected(\\n        address indexed staker,\\n        bytes16 indexed stakeID,\\n        address indexed referrer,\\n        bytes16 referrerID,\\n        uint256 rewardAmount\\n    );\\n\\n    event NewGlobals(\\n        uint256 totalShares,\\n        uint256 totalStaked,\\n        uint256 shareRate,\\n        uint256 referrerShares,\\n        uint256 indexed currentTFDay\\n    );\\n\\n    event NewSharePrice(\\n        uint256 newSharePrice,\\n        bytes32 stakeID\\n    );\\n\\n    event UniswapReserves(\\n        uint112 reserveA,\\n        uint112 reserveB,\\n        uint32 blockTimestampLast\\n    );\\n\\n    event LiquidityGuardStatus(\\n        bool isActive\\n    );\\n}\"},\"Global.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Events.sol\\\";\\n\\nabstract contract Global is ERC20, Events {\\n\\n    using SafeMath for uint256;\\n\\n    struct Globals {\\n        uint256 totalStaked;\\n        uint256 totalShares;\\n        uint256 sharePrice;\\n        uint256 currentTFDay;\\n        uint256 referralShares;\\n    }\\n\\n    Globals public globals;\\n\\n    constructor() {\\n        globals.sharePrice = 100E15;\\n    }\\n\\n    function _increaseGlobals(\\n        uint256 _staked,\\n        uint256 _shares,\\n        uint256 _rshares\\n    )\\n        internal\\n    {\\n        globals.totalStaked =\\n        globals.totalStaked.add(_staked);\\n\\n        globals.totalShares =\\n        globals.totalShares.add(_shares);\\n\\n        if (_rshares \\u003e 0) {\\n\\n            globals.referralShares =\\n            globals.referralShares.add(_rshares);\\n        }\\n\\n        _logGlobals();\\n    }\\n\\n    function _decreaseGlobals(\\n        uint256 _staked,\\n        uint256 _shares,\\n        uint256 _rshares\\n    )\\n        internal\\n    {\\n        globals.totalStaked =\\n        globals.totalStaked \\u003e _staked ?\\n        globals.totalStaked - _staked : 0;\\n\\n        globals.totalShares =\\n        globals.totalShares \\u003e _shares ?\\n        globals.totalShares - _shares : 0;\\n\\n        if (_rshares \\u003e 0) {\\n\\n            globals.referralShares =\\n            globals.referralShares \\u003e _rshares ?\\n            globals.referralShares - _rshares : 0;\\n\\n        }\\n\\n        _logGlobals();\\n    }\\n\\n    function _logGlobals()\\n        private\\n    {\\n        emit NewGlobals(\\n            globals.totalShares,\\n            globals.totalStaked,\\n            globals.sharePrice,\\n            globals.currentTFDay,\\n            globals.referralShares\\n        );\\n    }\\n}\"},\"Helper.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./Timing.sol\\\";\\n\\nabstract contract Helper is Timing {\\n\\n    using SafeMath for uint256;\\n\\n    function notContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size == 0);\\n    }\\n\\n    function toBytes16(uint256 x) internal pure returns (bytes16 b) {\\n       return bytes16(bytes32(x));\\n    }\\n\\n    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\\n        b = toBytes16(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(x, y, z)\\n                )\\n            )\\n        );\\n    }\\n\\n    function generateStakeID(address _staker) internal view returns (bytes16 stakeID) {\\n        return generateID(_staker, stakeCount[_staker], 0x01);\\n    }\\n\\n    function generateReferralID(address _referrer) internal view returns (bytes16 referralID) {\\n        return generateID(_referrer, referralCount[_referrer], 0x02);\\n    }\\n\\n    function generateLiquidityStakeID(address _staker) internal view returns (bytes16 liquidityStakeID) {\\n        return generateID(_staker, liquidityStakeCount[_staker], 0x03);\\n    }\\n\\n    function activeStakesCount(\\n        address _staker\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 activeCount\\n        )\\n    {\\n        for (uint256 _stakeIndex = 0; _stakeIndex \\u003c= stakeCount[_staker]; _stakeIndex++) {\\n            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\\n            if (stakes[_staker][_stakeID].isActive) {\\n                activeCount++;\\n            }\\n        }\\n    }\\n\\n    function activeReferralCount(\\n        address _referrer\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 activeCount\\n        )\\n    {\\n        for (uint256 _rIndex = 0; _rIndex \\u003c= referralCount[_referrer]; _rIndex++) {\\n            bytes16 _rID = generateID(_referrer, _rIndex - 1, 0x02);\\n            if (referrerLinks[_referrer][_rID].isActive) {\\n                activeCount++;\\n            }\\n        }\\n    }\\n\\n    // Get my stakes items\\n    // params _staker = selectedAddress, _offset = currentPage * perPage, _length = perPage\\n    function stakesPagination(\\n        address _staker,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        external\\n        view\\n        returns (bytes16[] memory _stakes)\\n    {\\n        uint256 start = _offset \\u003e 0 \\u0026\\u0026\\n            stakeCount[_staker] \\u003e _offset ?\\n            stakeCount[_staker] - _offset : stakeCount[_staker];\\n\\n        uint256 finish = _length \\u003e 0 \\u0026\\u0026\\n            start \\u003e _length ?\\n            start - _length : 0;\\n\\n        uint256 i;\\n\\n        _stakes = new bytes16[](start - finish);\\n\\n        for (uint256 _stakeIndex = start; _stakeIndex \\u003e finish; _stakeIndex--) {\\n            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\\n            if (stakes[_staker][_stakeID].stakedAmount \\u003e 0) {\\n                _stakes[i] = _stakeID; i++;\\n            }\\n        }\\n    }\\n\\n    function referralsPagination(\\n        address _referrer,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        external\\n        view\\n        returns (bytes16[] memory _referrals)\\n    {\\n        uint256 start = _offset \\u003e 0 \\u0026\\u0026\\n            referralCount[_referrer] \\u003e _offset ?\\n            referralCount[_referrer] - _offset : referralCount[_referrer];\\n\\n        uint256 finish = _length \\u003e 0 \\u0026\\u0026\\n            start \\u003e _length ?\\n            start - _length : 0;\\n\\n        uint256 i;\\n\\n        _referrals = new bytes16[](start - finish);\\n\\n        for (uint256 _rIndex = start; _rIndex \\u003e finish; _rIndex--) {\\n            bytes16 _rID = generateID(_referrer, _rIndex - 1, 0x02);\\n            if (_nonZeroAddress(referrerLinks[_referrer][_rID].staker)) {\\n                _referrals[i] = _rID; i++;\\n            }\\n        }\\n    }\\n\\n    function latestStakeID(address _staker) external view returns (bytes16) {\\n        return stakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, stakeCount[_staker].sub(1), 0x01);\\n    }\\n\\n    function latestReferralID(address _referrer) external view returns (bytes16) {\\n        return referralCount[_referrer] == 0 ? bytes16(0) : generateID(_referrer, referralCount[_referrer].sub(1), 0x02);\\n    }\\n\\n    function latestLiquidityStakeID(address _staker) external view returns (bytes16) {\\n        return liquidityStakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, liquidityStakeCount[_staker].sub(1), 0x03);\\n    }\\n\\n    function _increaseStakeCount(address _staker) internal {\\n        stakeCount[_staker] = stakeCount[_staker] + 1;\\n    }\\n\\n    function _increaseReferralCount(address _referrer) internal {\\n        referralCount[_referrer] = referralCount[_referrer] + 1;\\n    }\\n\\n    function _increaseLiquidityStakeCount(address _staker) internal {\\n        liquidityStakeCount[_staker] = liquidityStakeCount[_staker] + 1;\\n    }\\n\\n    function _isMatureStake(Stake memory _stake) internal view returns (bool) {\\n        return _stake.finalDay \\u003c= globals.currentTFDay;\\n    }\\n\\n    function _notCriticalMassReferrer(address _referrer) internal view returns (bool) {\\n        return criticalMass[_referrer].activationDay == 0;\\n    }\\n\\n    function _stakeNotStarted(Stake memory _stake) internal view returns (bool) {\\n        return _stake.startDay \\u003e globals.currentTFDay;\\n    }\\n\\n    function _stakeEnded(Stake memory _stake) internal view returns (bool) {\\n        return _stake.isActive == false || _isMatureStake(_stake);\\n    }\\n\\n    function _daysLeft(Stake memory _stake) internal view returns (uint256) {\\n        return _stakeEnded(_stake) ? 0 : _daysDiff(_currentTFDay(), _stake.finalDay);\\n    }\\n\\n    function _daysDiff(uint256 _startDate, uint256 _endDate) internal pure returns (uint256) {\\n        return _startDate \\u003e _endDate ? 0 : _endDate.sub(_startDate);\\n    }\\n\\n    function _calculationDay(Stake memory _stake) internal view returns (uint256) {\\n        return _stake.finalDay \\u003e globals.currentTFDay ? globals.currentTFDay : _stake.finalDay;\\n    }\\n\\n    function _startingDay(Stake memory _stake) internal pure returns (uint256) {\\n        return _stake.scrapeDay == 0 ? _stake.startDay : _stake.scrapeDay;\\n    }\\n\\n    function _notFuture(uint256 _day) internal view returns (bool) {\\n        return _day \\u003c= _currentTFDay();\\n    }\\n\\n    function _notPast(uint256 _day) internal view returns (bool) {\\n        return _day \\u003e= _currentTFDay();\\n    }\\n\\n    function _nonZeroAddress(address _address) internal pure returns (bool) {\\n        return _address != address(0x0);\\n    }\\n\\n    function _getLockDays(Stake memory _stake) internal pure returns (uint256) {\\n        return\\n            _stake.lockDays \\u003e 1 ?\\n            _stake.lockDays - 1 : 1;\\n    }\\n\\n    function _preparePath(\\n        address _tokenAddress,\\n        address _tfAddress\\n    )\\n        internal\\n        pure\\n        returns (address[] memory _path)\\n    {\\n        _path = new address[](3);\\n        _path[0] = _tokenAddress;\\n        _path[1] = WETH;\\n        _path[2] = _tfAddress;\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                0xa9059cbb,\\n                to,\\n                value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool)))\\n            // \\u0027transfer failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                0x23b872dd,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool)))\\n            // \\u0027transferFrom failed\\u0027\\n        );\\n    }\\n}\"},\"LiquidityToken.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./StakingToken.sol\\\";\\n\\nabstract contract LiquidityToken is StakingToken {\\n\\n    /**\\n     * @notice A method for a staker to create a liquidity stake\\n     * @param _liquidityTokens amount of UNI-TF staked.\\n     */\\n    function createLiquidityStake(\\n        uint256 _liquidityTokens\\n    )\\n        snapshotTrigger\\n        external\\n        returns (bytes16 liquidityStakeID)\\n    {\\n        safeTransferFrom(\\n            address(UNISWAP_PAIR),\\n            msg.sender,\\n            address(this),\\n            _liquidityTokens\\n        );\\n\\n        LiquidityStake memory newLiquidityStake;\\n\\n        liquidityStakeID = generateLiquidityStakeID(\\n            msg.sender\\n        );\\n\\n        newLiquidityStake.startDay = _nextTFDay();\\n        newLiquidityStake.stakedAmount = _liquidityTokens;\\n        newLiquidityStake.isActive = true;\\n\\n        liquidityStakes[msg.sender][liquidityStakeID] = newLiquidityStake;\\n\\n        _increaseLiquidityStakeCount(\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice A method for a staker to end a liquidity stake\\n     * @param _liquidityStakeID - identification number\\n     */\\n    function endLiquidityStake(\\n        bytes16 _liquidityStakeID\\n    )\\n        snapshotTrigger\\n        external\\n        returns (uint256)\\n    {\\n        LiquidityStake memory liquidityStake =\\n        liquidityStakes[msg.sender][_liquidityStakeID];\\n\\n        require(\\n            liquidityStake.isActive\\n            // \\u0027not an active stake\\u0027\\n        );\\n\\n        liquidityStake.isActive = false;\\n        liquidityStake.closeDay = _currentTFDay();\\n\\n        liquidityStake.rewardAmount = _calculateRewardAmount(\\n            liquidityStake\\n        );\\n\\n        _mint(\\n            msg.sender,\\n            liquidityStake.rewardAmount\\n        );\\n\\n        safeTransfer(\\n            address(UNISWAP_PAIR),\\n            msg.sender,\\n            liquidityStake.stakedAmount\\n        );\\n\\n        liquidityStakes[msg.sender][_liquidityStakeID] = liquidityStake;\\n\\n        return liquidityStake.rewardAmount;\\n    }\\n\\n    /**\\n     * @notice returns full view and details of\\n     * a liquidity stake belonging to caller\\n     * @param _liquidityStakeID - stakeID\\n     */\\n    function checkLiquidityStakeByID(\\n        address _staker,\\n        bytes16 _liquidityStakeID\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startDay,\\n            uint256 stakedAmount,\\n            uint256 rewardAmount,\\n            uint256 closeDay,\\n            bool isActive\\n        )\\n    {\\n        LiquidityStake memory stake = liquidityStakes[_staker][_liquidityStakeID];\\n        startDay = stake.startDay;\\n        stakedAmount = stake.stakedAmount;\\n        rewardAmount = _calculateRewardAmount(stake);\\n        closeDay = stake.closeDay;\\n        isActive = stake.isActive;\\n    }\\n\\n    /**\\n     * @notice calculates reward when closing liquidity stake\\n     * @param _liquidityStake - stake instance\\n     */\\n    function _calculateRewardAmount(\\n        LiquidityStake memory _liquidityStake\\n    )\\n        private\\n        view\\n        returns (uint256 _rewardAmount)\\n    {\\n        uint256 maxCalculationDay = _liquidityStake.startDay + MAX_BONUS_DAYS_A;\\n\\n        uint256 calculationDay =\\n            globals.currentTFDay \\u003c maxCalculationDay ?\\n            globals.currentTFDay : maxCalculationDay;\\n\\n        for (uint256 _day = _liquidityStake.startDay; _day \\u003c calculationDay; _day++) {\\n            _rewardAmount += _liquidityStake.stakedAmount * PRECISION_RATE / lsnapshots[_day].inflationAmount;\\n        }\\n    }\\n}\"},\"ReferralToken.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./Snapshot.sol\\\";\\n\\nabstract contract ReferralToken is Snapshot {\\n\\n    using SafeMath for uint256;\\n\\n    function _addReferrerSharesToEnd(\\n        uint256 _finalDay,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        referralSharesToEnd[_finalDay] =\\n        referralSharesToEnd[_finalDay].add(_shares);\\n    }\\n\\n    function _removeReferrerSharesToEnd(\\n        uint256 _finalDay,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        if (_notPast(_finalDay)) {\\n\\n            referralSharesToEnd[_finalDay] =\\n            referralSharesToEnd[_finalDay] \\u003e _shares ?\\n            referralSharesToEnd[_finalDay] - _shares : 0;\\n\\n        } else {\\n\\n            uint256 _day = _previousTFDay();\\n            rsnapshots[_day].scheduledToEnd =\\n            rsnapshots[_day].scheduledToEnd \\u003e _shares ?\\n            rsnapshots[_day].scheduledToEnd - _shares : 0;\\n        }\\n    }\\n\\n    function _belowThresholdLevel(\\n        address _referrer\\n    )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return criticalMass[_referrer].totalAmount \\u003c THRESHOLD_LIMIT;\\n    }\\n\\n    function _addCriticalMass(\\n        address _referrer,\\n        uint256 _daiEquivalent\\n    )\\n        internal\\n    {\\n        criticalMass[_referrer].totalAmount =\\n        criticalMass[_referrer].totalAmount.add(_daiEquivalent);\\n        criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\\n    }\\n\\n    function _removeCriticalMass(\\n        address _referrer,\\n        uint256 _daiEquivalent,\\n        uint256 _startDay\\n    )\\n        internal\\n    {\\n        if (\\n            _notFuture(_startDay) == false \\u0026\\u0026\\n            _nonZeroAddress(_referrer)\\n        ) {\\n            criticalMass[_referrer].totalAmount =\\n            criticalMass[_referrer].totalAmount \\u003e _daiEquivalent ?\\n            criticalMass[_referrer].totalAmount - _daiEquivalent : 0;\\n            criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\\n        }\\n    }\\n\\n    function _determineActivationDay(\\n        address _referrer\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return _belowThresholdLevel(_referrer) ? 0 : _activationDay(_referrer);\\n    }\\n\\n    function _activationDay(\\n        address _referrer\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            criticalMass[_referrer].activationDay \\u003e 0 ?\\n            criticalMass[_referrer].activationDay : _currentTFDay();\\n    }\\n\\n    function _updateDaiEquivalent()\\n        internal\\n        returns (uint256)\\n    {\\n        try UNISWAP_ROUTER.getAmountsOut(\\n            CROP_PER_TF, _path\\n        ) returns (uint256[] memory results) {\\n            latestDaiEquivalent = results[2];\\n            return latestDaiEquivalent;\\n        } catch Error(string memory) {\\n            return latestDaiEquivalent;\\n        } catch (bytes memory) {\\n            return latestDaiEquivalent;\\n        }\\n    }\\n\\n    function referrerInterest(\\n        bytes16 _referralID,\\n        uint256 _scrapeDays\\n    )\\n        external\\n        snapshotTrigger\\n    {\\n        _referrerInterest(\\n            msg.sender,\\n            _referralID,\\n            _scrapeDays\\n        );\\n    }\\n\\n    function referrerInterestBulk(\\n        bytes16[] memory _referralIDs,\\n        uint256[] memory _scrapeDays\\n    )\\n        external\\n        snapshotTrigger\\n    {\\n        for(uint256 i = 0; i \\u003c _referralIDs.length; i++) {\\n            _referrerInterest(\\n                msg.sender,\\n                _referralIDs[i],\\n                _scrapeDays[i]\\n            );\\n        }\\n    }\\n\\n    function _referrerInterest(\\n        address _referrer,\\n        bytes16 _referralID,\\n        uint256 _processDays\\n    )\\n        internal\\n    {\\n        ReferrerLink memory link =\\n        referrerLinks[_referrer][_referralID];\\n\\n        require(\\n            link.isActive == true\\n        );\\n\\n        address staker = link.staker;\\n        bytes16 stakeID = link.stakeID;\\n\\n        Stake memory stake = stakes[staker][stakeID];\\n\\n        uint256 startDay = _determineStartDay(stake, link);\\n        uint256 finalDay = _determineFinalDay(stake);\\n\\n        if (_stakeEnded(stake)) {\\n\\n            if (\\n                _processDays \\u003e 0 \\u0026\\u0026\\n                _processDays \\u003c _daysDiff(startDay, finalDay)\\n                )\\n            {\\n\\n                link.processedDays =\\n                link.processedDays.add(_processDays);\\n\\n                finalDay =\\n                startDay.add(_processDays);\\n\\n            } else {\\n\\n                link.isActive = false;\\n            }\\n\\n        } else {\\n\\n            _processDays = _daysDiff(startDay, _currentTFDay());\\n\\n            link.processedDays =\\n            link.processedDays.add(_processDays);\\n\\n            finalDay =\\n            startDay.add(_processDays);\\n        }\\n\\n        uint256 referralInterest = _checkReferralInterest(\\n            stake,\\n            startDay,\\n            finalDay\\n        );\\n\\n        link.rewardAmount =\\n        link.rewardAmount.add(referralInterest);\\n\\n        referrerLinks[_referrer][_referralID] = link;\\n\\n        _mint(\\n            _referrer,\\n            referralInterest\\n        );\\n\\n        emit ReferralCollected(\\n            staker,\\n            stakeID,\\n            _referrer,\\n            _referralID,\\n            referralInterest\\n        );\\n    }\\n\\n    function checkReferralsByID(\\n        address _referrer,\\n        bytes16 _referralID\\n    )\\n        external\\n        view\\n        returns (\\n            address staker,\\n            bytes16 stakeID,\\n            uint256 referrerShares,\\n            uint256 referralInterest,\\n            bool isActiveReferral,\\n            bool isActiveStake,\\n            bool isMatureStake,\\n            bool isEndedStake\\n        )\\n    {\\n        ReferrerLink memory link = referrerLinks[_referrer][_referralID];\\n\\n        staker = link.staker;\\n        stakeID = link.stakeID;\\n        isActiveReferral = link.isActive;\\n\\n        Stake memory stake = stakes[staker][stakeID];\\n        referrerShares = stake.referrerShares;\\n\\n        referralInterest = _checkReferralInterest(\\n            stake,\\n            _determineStartDay(stake, link),\\n            _determineFinalDay(stake)\\n        );\\n\\n        isActiveStake = stake.isActive;\\n        isEndedStake = _stakeEnded(stake);\\n        isMatureStake = _isMatureStake(stake);\\n    }\\n\\n    function _checkReferralInterest(Stake memory _stake, uint256 _startDay, uint256 _finalDay) internal view returns (uint256 _referralInterest) {\\n        return _notCriticalMassReferrer(_stake.referrer) ? 0 : _getReferralInterest(_stake, _startDay, _finalDay);\\n    }\\n\\n    function _getReferralInterest(Stake memory _stake, uint256 _startDay, uint256 _finalDay) private view returns (uint256 _referralInterest) {\\n        for (uint256 _day = _startDay; _day \\u003c _finalDay; _day++) {\\n            _referralInterest += _stake.stakesShares * PRECISION_RATE / rsnapshots[_day].inflationAmount;\\n        }\\n    }\\n\\n    function _determineStartDay(Stake memory _stake, ReferrerLink memory _link) internal view returns (uint256) {\\n        return (\\n            criticalMass[_stake.referrer].activationDay \\u003e _stake.startDay ?\\n            criticalMass[_stake.referrer].activationDay : _stake.startDay\\n        ).add(_link.processedDays);\\n    }\\n\\n    function _determineFinalDay(\\n        Stake memory _stake\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            _stake.closeDay \\u003e 0 ?\\n            _stake.closeDay : _calculationDay(_stake);\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"},\"Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./Helper.sol\\\";\\n\\nabstract contract Snapshot is Helper {\\n\\n    using SafeMath for uint;\\n\\n    // regular shares\\n    struct SnapShot {\\n        uint256 totalShares;\\n        uint256 inflationAmount;\\n        uint256 scheduledToEnd;\\n    }\\n\\n    // referral shares\\n    struct rSnapShot {\\n        uint256 totalShares;\\n        uint256 inflationAmount;\\n        uint256 scheduledToEnd;\\n    }\\n\\n    // liquidity shares\\n    struct lSnapShot {\\n        uint256 totalShares;\\n        uint256 inflationAmount;\\n    }\\n\\n    mapping(uint256 =\\u003e SnapShot) public snapshots;\\n    mapping(uint256 =\\u003e rSnapShot) public rsnapshots;\\n    mapping(uint256 =\\u003e lSnapShot) public lsnapshots;\\n\\n    modifier snapshotTrigger() {\\n        _dailySnapshotPoint(_currentTFDay());\\n        _;\\n    }\\n\\n    /**\\n     * @notice allows to activate/deactivate\\n     * liquidity guard manually based on the\\n     * liquidity in UNISWAP pair contract\\n     */\\n    function liquidityGuardTrigger() public {\\n\\n        (\\n            uint112 reserveA,\\n            uint112 reserveB,\\n            uint32 blockTimestampLast\\n        ) = UNISWAP_PAIR.getReserves();\\n\\n        emit UniswapReserves(\\n            reserveA,\\n            reserveB,\\n            blockTimestampLast\\n        );\\n\\n        uint256 onUniswap = UNISWAP_PAIR.token1() == WETH\\n            ? reserveA\\n            : reserveB;\\n\\n        uint256 ratio = totalSupply() == 0\\n            ? 0\\n            : onUniswap\\n                .mul(200)\\n                .div(totalSupply());\\n\\n        if (ratio \\u003c 40 \\u0026\\u0026 isLiquidityGuardActive == false) enableLiquidityGuard();\\n        if (ratio \\u003e 60 \\u0026\\u0026 isLiquidityGuardActive == true) disableLiquidityGuard();\\n\\n        emit LiquidityGuardStatus(\\n            isLiquidityGuardActive\\n        );\\n    }\\n\\n    function enableLiquidityGuard() private {\\n        isLiquidityGuardActive = true;\\n    }\\n\\n    function disableLiquidityGuard() private {\\n        isLiquidityGuardActive = false;\\n    }\\n\\n    /**\\n     * @notice allows volunteer to offload snapshots\\n     * to save on gas during next start/end stake\\n     */\\n    function manualDailySnapshot()\\n        external\\n    {\\n        _dailySnapshotPoint(_currentTFDay());\\n    }\\n\\n    /**\\n     * @notice allows volunteer to offload snapshots\\n     * to save on gas during next start/end stake\\n     * in case manualDailySnapshot reach block limit\\n     */\\n    function manualDailySnapshotPoint(\\n        uint64 _updateDay\\n    )\\n        external\\n    {\\n        require(\\n            _updateDay \\u003e 0 \\u0026\\u0026\\n            _updateDay \\u003c _currentTFDay()\\n            // \\u0027snapshot day does not exist yet\\u0027\\n        );\\n\\n        require(\\n            _updateDay \\u003e globals.currentTFDay\\n            // \\u0027snapshot already taken for that day\\u0027\\n        );\\n\\n        _dailySnapshotPoint(_updateDay);\\n    }\\n\\n    /**\\n     * @notice internal function that offloads\\n     * global values to daily snapshots\\n     * updates globals.currentTFDay\\n     */\\n    function _dailySnapshotPoint(\\n        uint64 _updateDay\\n    )\\n        private\\n    {\\n        liquidityGuardTrigger();\\n\\n        uint256 scheduledToEndToday;\\n        uint256 totalStakedToday = globals.totalStaked;\\n\\n        for (uint256 _day = globals.currentTFDay; _day \\u003c _updateDay; _day++) {\\n\\n            // ------------------------------------\\n            // prepare snapshot for regular shares\\n            // reusing scheduledToEndToday variable\\n\\n            scheduledToEndToday = scheduledToEnd[_day] + snapshots[_day - 1].scheduledToEnd;\\n\\n            SnapShot memory snapshot = snapshots[_day];\\n            snapshot.scheduledToEnd = scheduledToEndToday;\\n\\n            snapshot.totalShares =\\n                globals.totalShares \\u003e scheduledToEndToday ?\\n                globals.totalShares - scheduledToEndToday : 0;\\n\\n            snapshot.inflationAmount =  snapshot.totalShares\\n                .mul(PRECISION_RATE)\\n                .div(\\n                    _inflationAmount(\\n                        totalStakedToday,\\n                        totalSupply(),\\n                        totalPenalties[_day],\\n                        LIQUIDITY_GUARD.getInflation(\\n                            INFLATION_RATE\\n                        )\\n                    )\\n                );\\n\\n            // store regular snapshot\\n            snapshots[_day] = snapshot;\\n\\n\\n            // ------------------------------------\\n            // prepare snapshot for referrer shares\\n            // reusing scheduledToEndToday variable\\n\\n            scheduledToEndToday = referralSharesToEnd[_day] + rsnapshots[_day - 1].scheduledToEnd;\\n\\n            rSnapShot memory rsnapshot = rsnapshots[_day];\\n            rsnapshot.scheduledToEnd = scheduledToEndToday;\\n\\n            rsnapshot.totalShares =\\n                globals.referralShares \\u003e scheduledToEndToday ?\\n                globals.referralShares - scheduledToEndToday : 0;\\n\\n            rsnapshot.inflationAmount = rsnapshot.totalShares\\n                .mul(PRECISION_RATE)\\n                .div(\\n                    _referralInflation(\\n                        totalStakedToday,\\n                        totalSupply()\\n                    )\\n                );\\n\\n            // store referral snapshot\\n            rsnapshots[_day] = rsnapshot;\\n\\n\\n            // ------------------------------------\\n            // prepare snapshot for liquidity shares\\n            // reusing scheduledToEndToday variable\\n\\n            lSnapShot memory lsnapshot = lsnapshots[_day];\\n\\n            lsnapshot.totalShares = UNISWAP_PAIR.balanceOf(\\n                address(this)\\n            );\\n\\n            lsnapshot.inflationAmount = lsnapshot.totalShares\\n                .mul(PRECISION_RATE).div(\\n                    _liquidityInflation(\\n                        totalStakedToday,\\n                        totalSupply(),\\n                        LIQUIDITY_GUARD.getInflation(\\n                            LIQUIDITY_RATE\\n                        )\\n                    )\\n                );\\n\\n            // store liquidity snapshot\\n            lsnapshots[_day] = lsnapshot;\\n\\n            adjustLiquidityRates();\\n            globals.currentTFDay++;\\n        }\\n    }\\n\\n    /**\\n     * @notice moves inflation up and down by 0.006%\\n     * from regular shares to liquidity shares\\n     * if the liquidityGuard is active (visa-versa)\\n     */\\n    function adjustLiquidityRates() private {\\n        if (\\n            isLiquidityGuardActive ==  true \\u0026\\u0026\\n            LIQUIDITY_RATE \\u003c INFLATION_RATE_MAX\\n            )\\n        {\\n            LIQUIDITY_RATE = LIQUIDITY_RATE + 6;\\n            INFLATION_RATE = INFLATION_RATE - 6;\\n            return;\\n        }\\n        if (\\n            isLiquidityGuardActive == false \\u0026\\u0026\\n            INFLATION_RATE \\u003c INFLATION_RATE_MAX\\n            )\\n        {\\n            INFLATION_RATE = INFLATION_RATE + 6;\\n            LIQUIDITY_RATE = LIQUIDITY_RATE - 6;\\n            return;\\n        }\\n    }\\n\\n    function _inflationAmount(uint256 _totalStaked, uint256 _totalSupply, uint256 _totalPenalties, uint256 _INFLATION_RATE) private pure returns (uint256) {\\n        return (_totalStaked + _totalSupply) * 10000 / _INFLATION_RATE + _totalPenalties;\\n    }\\n\\n    function _referralInflation(uint256 _totalStaked, uint256 _totalSupply) private pure returns (uint256) {\\n        return (_totalStaked + _totalSupply) * 10000 / REFERRALS_RATE;\\n    }\\n\\n    function _liquidityInflation(uint256 _totalStaked, uint256 _totalSupply, uint256 _LIQUIDITY_RATE) private pure returns (uint256) {\\n        return (_totalStaked + _totalSupply) * 10000 / _LIQUIDITY_RATE;\\n    }\\n}\"},\"StakingToken.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./ReferralToken.sol\\\";\\n\\nabstract contract StakingToken is ReferralToken {\\n\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @notice A method for a staker to create a stake\\n     * @param _stakedAmount amount of TF staked.\\n     * @param _lockDays amount of days it is locked for.\\n     */\\n    function createStake(\\n        uint256 _stakedAmount,\\n        uint64 _lockDays,\\n        address _referrer\\n    )\\n        snapshotTrigger\\n        public\\n        returns (bytes16, uint256, bytes16 referralID)\\n    {\\n        require(\\n            msg.sender != _referrer \\u0026\\u0026\\n            notContract(_referrer)\\n            // \\u0027invalid referrer\\u0027\\n        );\\n\\n        require(\\n            _lockDays \\u003e= MIN_LOCK_DAYS \\u0026\\u0026\\n            _lockDays \\u003c= MAX_LOCK_DAYS\\n            // \\u0027stake is not in range\\u0027\\n        );\\n\\n        (\\n            Stake memory newStake,\\n            bytes16 stakeID,\\n            uint256 _startDay\\n        ) =\\n\\n        _createStake(msg.sender, _stakedAmount, _lockDays, _referrer);\\n\\n        if (newStake.referrerShares \\u003e 0) {\\n\\n            ReferrerLink memory referrerLink;\\n\\n            referrerLink.staker = msg.sender;\\n            referrerLink.stakeID = stakeID;\\n            referrerLink.isActive = true;\\n\\n            referralID = generateReferralID(_referrer);\\n            referrerLinks[_referrer][referralID] = referrerLink;\\n\\n            _increaseReferralCount(\\n                _referrer\\n            );\\n\\n            _addReferrerSharesToEnd(\\n                newStake.finalDay,\\n                newStake.referrerShares\\n            );\\n        }\\n\\n        stakes[msg.sender][stakeID] = newStake;\\n\\n        _increaseStakeCount(\\n            msg.sender\\n        );\\n\\n        _increaseGlobals(\\n            newStake.stakedAmount,\\n            newStake.stakesShares,\\n            newStake.referrerShares\\n        );\\n\\n        _addScheduledShares(\\n            newStake.finalDay,\\n            newStake.stakesShares\\n        );\\n\\n        emit StakeStart(\\n            stakeID,\\n            msg.sender,\\n            _referrer,\\n            newStake.stakedAmount,\\n            newStake.stakesShares,\\n            newStake.referrerShares,\\n            newStake.startDay,\\n            newStake.lockDays,\\n            newStake.daiEquivalent\\n        );\\n\\n        return (stakeID, _startDay, referralID);\\n    }\\n\\n    /**\\n    * @notice A method for a staker to start a stake\\n    * @param _staker ...\\n    * @param _stakedAmount ...\\n    * @param _lockDays ...\\n    */\\n    function _createStake(\\n        address _staker,\\n        uint256 _stakedAmount,\\n        uint64 _lockDays,\\n        address _referrer\\n    )\\n        private\\n        returns (\\n            Stake memory _newStake,\\n            bytes16 _stakeID,\\n            uint64 _startDay\\n        )\\n    {\\n        _burn(\\n            _staker,\\n            _stakedAmount\\n        );\\n\\n        _startDay = _nextTFDay();\\n        _stakeID = generateStakeID(_staker);\\n\\n        _newStake.lockDays = _lockDays;\\n        _newStake.startDay = _startDay;\\n        _newStake.finalDay = _startDay + _lockDays;\\n        _newStake.isActive = true;\\n\\n        _newStake.stakedAmount = _stakedAmount;\\n        _newStake.stakesShares = _stakesShares(\\n            _stakedAmount,\\n            _lockDays,\\n            _referrer,\\n            globals.sharePrice\\n        );\\n\\n        _updateDaiEquivalent();\\n\\n        _newStake.daiEquivalent = latestDaiEquivalent\\n            .mul(_newStake.stakedAmount)\\n            .div(CROP_PER_TF);\\n\\n        if (_nonZeroAddress(_referrer)) {\\n\\n            _newStake.referrer = _referrer;\\n\\n            _addCriticalMass(\\n                _newStake.referrer,\\n                _newStake.daiEquivalent\\n            );\\n\\n            _newStake.referrerShares = _referrerShares(\\n                _stakedAmount,\\n                _lockDays,\\n                _referrer\\n            );\\n        }\\n    }\\n\\n    /**\\n    * @notice A method for a staker to remove a stake\\n    * belonging to his address by providing ID of a stake.\\n    * @param _stakeID unique bytes sequence reference to the stake\\n    */\\n    function endStake(\\n        bytes16 _stakeID\\n    )\\n        snapshotTrigger\\n        external\\n        returns (uint256)\\n    {\\n        (\\n            Stake memory endedStake,\\n            uint256 penaltyAmount\\n        ) =\\n\\n        _endStake(\\n            msg.sender,\\n            _stakeID\\n        );\\n\\n        _decreaseGlobals(\\n            endedStake.stakedAmount,\\n            endedStake.stakesShares,\\n            endedStake.referrerShares\\n        );\\n\\n        _removeScheduledShares(\\n            endedStake.finalDay,\\n            endedStake.stakesShares\\n        );\\n\\n        _removeReferrerSharesToEnd(\\n            endedStake.finalDay,\\n            endedStake.referrerShares\\n        );\\n\\n        _removeCriticalMass(\\n            endedStake.referrer,\\n            endedStake.daiEquivalent,\\n            endedStake.startDay\\n        );\\n\\n        _storePenalty(\\n            endedStake.closeDay,\\n            penaltyAmount\\n        );\\n\\n        _sharePriceUpdate(\\n            endedStake.stakedAmount \\u003e penaltyAmount ?\\n            endedStake.stakedAmount - penaltyAmount : 0,\\n            endedStake.rewardAmount,\\n            endedStake.referrer,\\n            endedStake.lockDays,\\n            endedStake.stakesShares\\n        );\\n\\n        emit StakeEnd(\\n            _stakeID,\\n            msg.sender,\\n            endedStake.referrer,\\n            endedStake.stakedAmount,\\n            endedStake.stakesShares,\\n            endedStake.referrerShares,\\n            endedStake.rewardAmount,\\n            endedStake.closeDay,\\n            penaltyAmount\\n        );\\n\\n        return endedStake.rewardAmount;\\n    }\\n\\n    function _endStake(\\n        address _staker,\\n        bytes16 _stakeID\\n    )\\n        private\\n        returns (\\n            Stake storage _stake,\\n            uint256 _penalty\\n        )\\n    {\\n        require(\\n            stakes[_staker][_stakeID].isActive\\n            // \\u0027not an active stake\\u0027\\n        );\\n\\n        _stake = stakes[_staker][_stakeID];\\n        _stake.closeDay = _currentTFDay();\\n        _stake.rewardAmount = _calculateRewardAmount(_stake);\\n        _stake.isActive = false;\\n\\n        _penalty = _detectPenalty(_stake);\\n\\n        _mint(\\n            _staker,\\n            _stake.stakedAmount \\u003e _penalty ?\\n            _stake.stakedAmount - _penalty : 0\\n        );\\n\\n        _mint(\\n            _staker,\\n            _stake.rewardAmount\\n        );\\n    }\\n\\n    /**\\n    * @notice alloes to scrape interest from active stake\\n    * @param _stakeID unique bytes sequence reference to the stake\\n    * @param _scrapeDays amount of days to proccess, 0 = all\\n    */\\n    function scrapeInterest(\\n        bytes16 _stakeID,\\n        uint64 _scrapeDays\\n    )\\n        external\\n        snapshotTrigger\\n        returns (\\n            uint256 scrapeDay,\\n            uint256 scrapeAmount,\\n            uint256 remainingDays,\\n            uint256 stakersPenalty,\\n            uint256 referrerPenalty\\n        )\\n    {\\n        require(\\n            stakes[msg.sender][_stakeID].isActive\\n            // \\u0027not an active stake\\u0027\\n        );\\n\\n        Stake memory stake = stakes[msg.sender][_stakeID];\\n\\n        scrapeDay = _scrapeDays \\u003e 0\\n            ? _startingDay(stake).add(_scrapeDays)\\n            : _calculationDay(stake);\\n\\n        scrapeDay = scrapeDay \\u003e stake.finalDay\\n            ? _calculationDay(stake)\\n            : scrapeDay;\\n\\n        scrapeAmount = _loopRewardAmount(\\n            stake.stakesShares,\\n            _startingDay(stake),\\n            scrapeDay\\n        );\\n\\n        if (_isMatureStake(stake) == false) {\\n\\n            remainingDays = _daysLeft(stake);\\n\\n            stakersPenalty = _stakesShares(\\n                scrapeAmount,\\n                remainingDays,\\n                msg.sender,\\n                globals.sharePrice\\n            );\\n\\n            stake.stakesShares =\\n            stake.stakesShares.sub(stakersPenalty);\\n\\n            _removeScheduledShares(\\n                stake.finalDay,\\n                stakersPenalty\\n            );\\n\\n            if (stake.referrerShares \\u003e 0) {\\n\\n                referrerPenalty = _stakesShares(\\n                    scrapeAmount,\\n                    remainingDays,\\n                    address(0x0),\\n                    globals.sharePrice\\n                );\\n\\n                stake.referrerShares =\\n                stake.referrerShares.sub(referrerPenalty);\\n\\n                _removeReferrerSharesToEnd(\\n                    stake.finalDay,\\n                    referrerPenalty\\n                );\\n            }\\n\\n            _decreaseGlobals(\\n                0,\\n                stakersPenalty,\\n                referrerPenalty\\n            );\\n        }\\n\\n        _sharePriceUpdate(\\n            stake.stakedAmount,\\n            scrapeAmount,\\n            stake.referrer,\\n            stake.lockDays,\\n            stake.stakesShares\\n        );\\n\\n        stake.scrapeDay = scrapeDay;\\n        stakes[msg.sender][_stakeID] = stake;\\n\\n        _mint(\\n            msg.sender,\\n            scrapeAmount\\n        );\\n\\n        emit InterestScraped(\\n            _stakeID,\\n            msg.sender,\\n            scrapeAmount,\\n            scrapeDay,\\n            stakersPenalty,\\n            referrerPenalty,\\n            _currentTFDay()\\n        );\\n    }\\n\\n    function _addScheduledShares(\\n        uint256 _finalDay,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        scheduledToEnd[_finalDay] =\\n        scheduledToEnd[_finalDay].add(_shares);\\n    }\\n\\n    function _removeScheduledShares(\\n        uint256 _finalDay,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        if (_notPast(_finalDay)) {\\n\\n            scheduledToEnd[_finalDay] =\\n            scheduledToEnd[_finalDay] \\u003e _shares ?\\n            scheduledToEnd[_finalDay] - _shares : 0;\\n\\n        } else {\\n\\n            uint256 _day = _previousTFDay();\\n            snapshots[_day].scheduledToEnd =\\n            snapshots[_day].scheduledToEnd \\u003e _shares ?\\n            snapshots[_day].scheduledToEnd - _shares : 0;\\n        }\\n    }\\n\\n    function _sharePriceUpdate(\\n        uint256 _stakedAmount,\\n        uint256 _rewardAmount,\\n        address _referrer,\\n        uint256 _lockDays,\\n        uint256 _stakeShares\\n    )\\n        private\\n    {\\n        if (_stakeShares \\u003e 0 \\u0026\\u0026 _currentTFDay() \\u003e FORMULA_DAY) {\\n\\n            uint256 newSharePrice = _getNewSharePrice(\\n                _stakedAmount,\\n                _rewardAmount,\\n                _stakeShares,\\n                _lockDays,\\n                _referrer\\n            );\\n\\n            if (newSharePrice \\u003e globals.sharePrice) {\\n                globals.sharePrice =\\n                    newSharePrice \\u003c globals.sharePrice.mul(110).div(100) ?\\n                    newSharePrice : globals.sharePrice.mul(110).div(100);\\n            }\\n\\n            return;\\n        }\\n\\n        if (_currentTFDay() == FORMULA_DAY) {\\n            globals.sharePrice = 110E15;\\n        }\\n    }\\n\\n    function _getNewSharePrice(\\n        uint256 _stakedAmount,\\n        uint256 _rewardAmount,\\n        uint256 _stakeShares,\\n        uint256 _lockDays,\\n        address _referrer\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n\\n        uint256 _bonusAmount = _getBonus(\\n            _lockDays, _nonZeroAddress(_referrer) ? 11E9 : 10E9\\n        );\\n\\n        return\\n            _stakedAmount\\n                .add(_rewardAmount)\\n                .mul(_bonusAmount)\\n                .mul(1E8)\\n                .div(_stakeShares);\\n    }\\n\\n    function checkMatureStake(\\n        address _staker,\\n        bytes16 _stakeID\\n    )\\n        external\\n        view\\n        returns (bool isMature)\\n    {\\n        Stake memory stake = stakes[_staker][_stakeID];\\n        isMature = _isMatureStake(stake);\\n    }\\n\\n    // get single user stake information\\n    function checkStakeByID(\\n        address _staker,\\n        bytes16 _stakeID\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 startDay,\\n            uint256 lockDays,\\n            uint256 finalDay,\\n            uint256 daysLeft,\\n            uint256 scrapeDay,\\n            uint256 stakedAmount,\\n            uint256 stakesShares,\\n            uint256 rewardAmount,\\n            uint256 penaltyAmount,\\n            bool isActive,\\n            bool isMature\\n        )\\n    {\\n        Stake memory stake = stakes[_staker][_stakeID];\\n        startDay = stake.startDay;\\n        lockDays = stake.lockDays;\\n        finalDay = stake.finalDay;\\n        scrapeDay = stake.scrapeDay;\\n        daysLeft = _daysLeft(stake);\\n        stakedAmount = stake.stakedAmount;\\n        stakesShares = stake.stakesShares;\\n        rewardAmount = _checkRewardAmount(stake);\\n        penaltyAmount = _detectPenalty(stake);\\n        isActive = stake.isActive;\\n        isMature = _isMatureStake(stake);\\n    }\\n\\n    function _stakesShares(\\n        uint256 _stakedAmount,\\n        uint256 _lockDays,\\n        address _referrer,\\n        uint256 _sharePrice\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return _nonZeroAddress(_referrer)\\n            ? _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 11E9)\\n            : _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 10E9);\\n    }\\n\\n    function _sharesAmount(\\n        uint256 _stakedAmount,\\n        uint256 _lockDays,\\n        uint256 _sharePrice,\\n        uint256 _extraBonus\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return _baseAmount(_stakedAmount, _sharePrice)\\n            .mul(_getBonus(_lockDays, _extraBonus))\\n            .div(10E9);\\n    }\\n\\n    function _getBonus(\\n        uint256 _lockDays,\\n        uint256 _extraBonus\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            _regularBonus(_lockDays, DAILY_BONUS_A, MAX_BONUS_DAYS_A) +\\n            _regularBonus(\\n                _lockDays \\u003e MAX_BONUS_DAYS_A ?\\n                _lockDays - MAX_BONUS_DAYS_A : 0, DAILY_BONUS_B, MAX_BONUS_DAYS_B\\n            ) + _extraBonus;\\n    }\\n\\n    function _regularBonus(\\n        uint256 _lockDays,\\n        uint256 _daily,\\n        uint256 _maxDays\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return (\\n            _lockDays \\u003e _maxDays\\n                ? _maxDays.mul(_daily)\\n                : _lockDays.mul(_daily)\\n            ).div(10E9);\\n    }\\n\\n    function _baseAmount(\\n        uint256 _stakedAmount,\\n        uint256 _sharePrice\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            _stakedAmount\\n                .mul(PRECISION_RATE)\\n                .div(_sharePrice);\\n    }\\n\\n    function _referrerShares(\\n        uint256 _stakedAmount,\\n        uint256 _lockDays,\\n        address _referrer\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            _notCriticalMassReferrer(_referrer) ||\\n            _lockDays \\u003c MIN_REFERRAL_DAYS\\n                ? 0\\n                : _sharesAmount(\\n                    _stakedAmount,\\n                    _lockDays,\\n                    globals.sharePrice,\\n                    10E9\\n                );\\n    }\\n\\n    function _checkRewardAmount(Stake memory _stake) private view returns (uint256) {\\n        return _stake.rewardAmount == 0 ? _detectReward(_stake) : _stake.rewardAmount;\\n    }\\n\\n    function _detectReward(Stake memory _stake) private view returns (uint256) {\\n        return _stakeNotStarted(_stake) ? 0 : _calculateRewardAmount(_stake);\\n    }\\n\\n    function _detectPenalty(Stake memory _stake) private view returns (uint256) {\\n        return _stakeEnded(_stake) ? 0 : _calculatePenaltyAmount(_stake);\\n    }\\n\\n    function _storePenalty(\\n        uint64 _storeDay,\\n        uint256 _penalty\\n    )\\n        private\\n    {\\n        if (_penalty \\u003e 0) {\\n            totalPenalties[_storeDay] =\\n            totalPenalties[_storeDay].add(_penalty);\\n        }\\n    }\\n\\n    function _calculatePenaltyAmount(\\n        Stake memory _stake\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return _stakeNotStarted(_stake) ? 0 : _getPenalties(_stake);\\n    }\\n\\n    // å–æ¶ˆè´¨æŠ¼æƒ©ç½šè®¡ç®—\\n    function _getPenalties(Stake memory _stake)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return _stake.stakedAmount * (100 + (800 * (_daysLeft(_stake) - 1) / (_getLockDays(_stake)))) / 1000;\\n    }\\n\\n    function _calculateRewardAmount(\\n        Stake memory _stake\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return _loopRewardAmount(\\n            _stake.stakesShares,\\n            _startingDay(_stake), \\n            _calculationDay(_stake)\\n        );\\n    }\\n\\n    function _loopRewardAmount(\\n        uint256 _stakeShares,\\n        uint256 _startDay,\\n        uint256 _finalDay\\n    )\\n        private\\n        view\\n        returns (uint256 _rewardAmount)\\n    {\\n        for (uint256 _day = _startDay; _day \\u003c _finalDay; _day++) {\\n            _rewardAmount += _stakeShares * PRECISION_RATE / snapshots[_day].inflationAmount;\\n        }\\n    }\\n}\"},\"Timing.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./Declaration.sol\\\";\\n\\nabstract contract Timing is Declaration {\\n\\n    function currentTFDay() public view returns (uint64) {\\n        return _getNow() \\u003e= LAUNCH_TIME ? _currentTFDay() : 0;\\n    }\\n\\n    function _currentTFDay() internal view returns (uint64) {\\n        return _tfDayFromStamp(_getNow());\\n    }\\n\\n    function _nextTFDay() internal view returns (uint64) {\\n        return _currentTFDay() + 1;\\n    }\\n\\n    function _previousTFDay() internal view returns (uint64) {\\n        return _currentTFDay() - 1;\\n    }\\n\\n    function _tfDayFromStamp(uint256 _timestamp) internal view returns (uint64) {\\n        return uint64((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\\n    }\\n\\n    function _getNow() internal view returns (uint256) {\\n        return block.timestamp;\\n    }\\n}\"},\"TokenFieldToken.sol\":{\"content\":\"// SPDX-License-Identifier: --ðŸ¥º--\\n\\npragma solidity =0.7.0;\\n\\nimport \\\"./LiquidityToken.sol\\\";\\n\\ncontract TokenFieldToken is LiquidityToken {\\n    address public LIQUIDITY_TRANSFORMER;\\n    address public transformerGateKeeper;\\n    address payable public savingAddress;\\n\\n    constructor() ERC20(\\\"TokenField Token\\\", \\\"TF\\\") {\\n        transformerGateKeeper = msg.sender;\\n        savingAddress = msg.sender;\\n    }\\n\\n    /**\\n     * @notice donations are welcomed\\n     * @dev goes to developers address\\n     */\\n    receive() external payable {\\n        savingAddress.transfer(msg.value);\\n    }\\n\\n    /**\\n     * @notice ability to define liquidity transformer contract\\n     * @dev this method renounce transformerGateKeeper access\\n     * @param _immutableTransformer contract address\\n     */\\n    function setLiquidityTransfomer(\\n        address _immutableTransformer\\n    )\\n        external\\n    {\\n        require(\\n            transformerGateKeeper == msg.sender,\\n            \\u0027transformer defined\\u0027\\n        );\\n        LIQUIDITY_TRANSFORMER = _immutableTransformer;\\n        // transformerGateKeeper = address(0x0);\\n    }\\n\\n    /**\\n     * @notice allows liquidityTransformer to mint supply\\n     * @dev executed from liquidityTransformer upon UNISWAP transfer\\n     * and during reservation payout to contributors and referrers\\n     * @param _investorAddress address for minting TF tokens\\n     * @param _amount of tokens to mint for _investorAddress\\n     */\\n    function mintSupply(\\n        address _investorAddress,\\n        uint256 _amount\\n    )\\n        external\\n    {\\n        require(\\n            msg.sender == LIQUIDITY_TRANSFORMER,\\n            \\u0027wrong transformer\\u0027\\n        );\\n\\n        _mint(\\n            _investorAddress,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @notice allows to grant permission to CM referrer status\\n     * @dev called from liquidityTransformer if user referred 50 ETH\\n     * @param _referrer - address that becomes a CM reffer\\n     */\\n    function giveStatus(\\n        address _referrer\\n    )\\n        external\\n    {\\n        require(\\n            msg.sender == LIQUIDITY_TRANSFORMER,\\n            \\u0027wrong transformer\\u0027\\n        );\\n        criticalMass[_referrer].totalAmount = THRESHOLD_LIMIT;\\n        criticalMass[_referrer].activationDay = _nextTFDay();\\n    }\\n\\n    /**\\n     * @notice allows to create stake directly with ETH\\n     * if you don\\u0027t have TF tokens method will convert\\n     * and use amount returned from UNISWAP to open a stake\\n     * @param _lockDays amount of days it is locked for.\\n     * @param _referrer referrer address for +10% bonus\\n     */\\n    function createStakeWithETH(\\n        uint64 _lockDays,\\n        address _referrer\\n    )\\n        external\\n        payable\\n        returns (bytes16, uint256, bytes16 referralID)\\n    {\\n        address[] memory path = new address[](2);\\n            path[0] = WETH;\\n            path[1] = address(this);\\n\\n        uint256[] memory amounts =\\n        UNISWAP_ROUTER.swapExactETHForTokens{value: msg.value}(\\n            1,\\n            path,\\n            msg.sender,\\n            block.timestamp + 2 hours\\n        );\\n\\n        return createStake(\\n            amounts[1],\\n            _lockDays,\\n            _referrer\\n        );\\n    }\\n\\n    /**\\n     * @notice allows to create stake with another token\\n     * if you don\\u0027t have TF tokens method will convert\\n     * and use amount returned from UNISWAP to open a stake\\n     * @dev the token must have WETH pair on UNISWAP\\n     * @param _tokenAddress any ERC20 token address\\n     * @param _tokenAmount amount to be converted to TF\\n     * @param _lockDays amount of days it is locked for.\\n     * @param _referrer referrer address for +10% bonus\\n     */\\n    function createStakeWithToken(\\n        address _tokenAddress,\\n        uint256 _tokenAmount,\\n        uint64 _lockDays,\\n        address _referrer\\n    )\\n        external\\n        returns (bytes16, uint256, bytes16 referralID)\\n    {\\n        ERC20TokenI token = ERC20TokenI(\\n            _tokenAddress\\n        );\\n\\n        token.transferFrom(\\n            msg.sender,\\n            address(this),\\n            _tokenAmount\\n        );\\n\\n        token.approve(\\n            address(UNISWAP_ROUTER),\\n            _tokenAmount\\n        );\\n\\n        address[] memory path = _preparePath(\\n            _tokenAddress,\\n            address(this)\\n        );\\n\\n        uint256[] memory amounts =\\n        UNISWAP_ROUTER.swapExactTokensForTokens(\\n            _tokenAmount,\\n            1,\\n            path,\\n            msg.sender,\\n            block.timestamp + 2 hours\\n        );\\n\\n        return createStake(\\n            amounts[2],\\n            _lockDays,\\n            _referrer\\n        );\\n    }\\n\\n    /**\\n     * @notice allows to save any stuck ERC20 from contract\\n     * @dev if someone sends tokens into contract accidentally\\n     * @param _tokenAddress any ERC20 token address\\n     */\\n    function saveTokens(\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    )\\n        external\\n    {\\n        safeTransfer(\\n            _tokenAddress,\\n            savingAddress,\\n            _tokenAmount\\n        );\\n    }\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentTFDay\",\"type\":\"uint256\"}],\"name\":\"InterestScraped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"LiquidityGuardStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentTFDay\",\"type\":\"uint256\"}],\"name\":\"NewGlobals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"stakeID\",\"type\":\"bytes32\"}],\"name\":\"NewSharePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"referrerID\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiEquivalent\",\"type\":\"uint256\"}],\"name\":\"StakeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserveA\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserveB\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blockTimestampLast\",\"type\":\"uint32\"}],\"name\":\"UniswapReserves\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INFLATION_RATE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_GUARD\",\"outputs\":[{\"internalType\":\"contract ILiquidityGuard\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_RATE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_TRANSFORMER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FACTORY\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_PAIR\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"activeReferralCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activeCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"activeStakesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activeCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_liquidityStakeID\",\"type\":\"bytes16\"}],\"name\":\"checkLiquidityStakeByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkMatureStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_referralID\",\"type\":\"bytes16\"}],\"name\":\"checkReferralsByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralInterest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActiveReferral\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActiveStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMatureStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEndedStake\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkStakeByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daysLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityTokens\",\"type\":\"uint256\"}],\"name\":\"createLiquidityStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"liquidityStakeID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStakeWithETH\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"createStakeWithToken\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"referralID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"criticalMass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationDay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTFDay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_liquidityStakeID\",\"type\":\"bytes16\"}],\"name\":\"endLiquidityStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"z\",\"type\":\"bytes1\"}],\"name\":\"generateID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"b\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"giveStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTFDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLiquidityGuardActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDaiEquivalent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestLiquidityStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"latestReferralID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGuardTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityStakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"liquidityStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"closeDay\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lsnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailySnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_updateDay\",\"type\":\"uint64\"}],\"name\":\"manualDailySnapshotPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralSharesToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"referralsPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_referrals\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_referralID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"_scrapeDays\",\"type\":\"uint256\"}],\"name\":\"referrerInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_referralIDs\",\"type\":\"bytes16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_scrapeDays\",\"type\":\"uint256[]\"}],\"name\":\"referrerInterestBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"referrerLinks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processedDays\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rsnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"saveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"savingAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scheduledToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint64\",\"name\":\"_scrapeDays\",\"type\":\"uint64\"}],\"name\":\"scrapeInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerPenalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableTransformer\",\"type\":\"address\"}],\"name\":\"setLiquidityTransfomer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockDays\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finalDay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"closeDay\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiEquivalent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"stakesPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_stakes\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transformerGateKeeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TokenFieldToken","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7c4c73b8caef89efcd867f5314784ede0aaff1f3f1fe0b5c0ec18c5a4c6d76a0"}]}