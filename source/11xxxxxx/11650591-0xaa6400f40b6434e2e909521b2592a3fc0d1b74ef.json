{"status":"1","message":"OK","result":[{"SourceCode":"{\"BaseBNUStoreClient.sol\":{\"content\":\"pragma solidity ^0.7.1;\\r\\n\\r\\nimport \\u0027./Context.sol\\u0027;\\r\\nimport \\u0027./IBNUStore.sol\\u0027;\\r\\n\\r\\ninterface IERC20Token{\\r\\n    function burnTokenSale(address account, uint amount) external returns(bool);\\r\\n    function balanceOf(address account) external view returns (uint);\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n@title Base contract for contract to interact with BNU Store contract\\r\\n */\\r\\ncontract BaseBNUStoreClient is Context{\\r\\n    IBNUStore internal _bnuStoreContract;\\r\\n\\r\\n    function setBNUStoreContract(address contractAddress) external onlyOwner contractActive{\\r\\n        _setBNUStoreContract(contractAddress);\\r\\n    }\\r\\n\\r\\n    function _setBNUStoreContract(address contractAddress) internal{\\r\\n        _bnuStoreContract = IBNUStore(contractAddress);\\r\\n    }\\r\\n}\\r\\n\\r\\n// SPDX-License-Identifier: MIT\"},\"BNUVesting.sol\":{\"content\":\"pragma solidity ^0.7.1;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\u0027./BaseBNUStoreClient.sol\\u0027;\\r\\n\\r\\n/**\\r\\n* @title Contract to store locked BNU tokens\\r\\n* @dev Process to initialize locked tokens of accounts and times to be unlocked\\r\\n*/\\r\\ncontract BNUVesting is BaseBNUStoreClient{\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    uint public _startTime;\\r\\n\\r\\n    address public _teamAddress;\\r\\n    address public _advisorAddress;\\r\\n\\r\\n    struct LockedToken {\\r\\n        address account;\\r\\n        uint amount;\\r\\n        uint unlockedTime;\\r\\n        bool unlocked;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Stores all locked tokens\\r\\n    */\\r\\n    LockedToken[] internal _lockedTokens;\\r\\n\\r\\n    constructor(){\\r\\n        _teamAddress = 0x830db936ad911D545388F2Bf736C9d05a9eA6753;\\r\\n        _advisorAddress = 0xB2eB9c15bC077813736B36b7a00287c43dd9d732;\\r\\n        \\r\\n        _startTime = 1610518359;\\r\\n\\r\\n        //Add locked histories\\r\\n        _addLockedToken(_teamAddress, 30000000000000000000000000, 730 days);\\r\\n        _addLockedToken(_advisorAddress, 16500000000000000000000000, 365 days);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Release locked token\\r\\n     */\\r\\n    function release() external onlyOwner contractActive returns(bool){\\r\\n        return _release();\\r\\n    }\\r\\n\\r\\n    /** INTERNAL METHODS */\\r\\n\\r\\n    /**\\r\\n    * @dev Add locked token history \\r\\n    */\\r\\n    function _addLockedToken(address account, uint amount, uint unlockedAfter) internal {\\r\\n        _lockedTokens.push(LockedToken({\\r\\n            account: account,\\r\\n            amount: amount,\\r\\n            unlockedTime: _startTime.add(unlockedAfter),\\r\\n            unlocked: false\\r\\n        }));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev  Calculate to release unlocked token\\r\\n    * \\r\\n    * Implementations:\\r\\n    *   1. Get current time\\r\\n    *   2. Get all locked histories that has not been unlocked and unlocked time less than current time\\r\\n    *   3. Foreach validated histories, transfer tokens to beneficiary and update histories to unlocked\\r\\n    */\\r\\n    function _release() internal returns(bool){\\r\\n        require(_startTime \\u003e 0, \\\"Start time has not been initialized\\\");\\r\\n        bool isSuccess = false;\\r\\n        uint currentTime = _now();\\r\\n        if(_lockedTokens.length \\u003e 0){\\r\\n            for(uint index = 0; index \\u003c _lockedTokens.length; index++){\\r\\n               LockedToken storage lockedToken = _lockedTokens[index];\\r\\n               if(!lockedToken.unlocked){\\r\\n                   if(lockedToken.unlockedTime \\u003c= currentTime){\\r\\n                       lockedToken.unlocked = true;\\r\\n                       require(_bnuStoreContract.transfer(lockedToken.account, lockedToken.amount), \\\"BNUVesting: Can not transfer token\\\");\\r\\n                       emit TokenReleased(lockedToken.account, lockedToken.amount, currentTime);\\r\\n                       isSuccess = true;\\r\\n                   }\\r\\n               }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return isSuccess;\\r\\n    }\\r\\n\\r\\n    /** EVENTS */\\r\\n    /**\\r\\n    * @dev Event to notify `amount` of token of `account` has been released at `time` \\r\\n    */\\r\\n    event TokenReleased(address account, uint amount, uint time);\\r\\n}\\r\\n\\r\\n//SPDX-License-Identifier: MIT\"},\"Context.sol\":{\"content\":\"pragma solidity ^0.7.1;\\r\\n\\r\\n/**\\r\\n * @title Context\\r\\n * @dev Provide context functions\\r\\n */\\r\\nabstract contract Context {\\r\\n    address public owner;            //Contract owner address\\r\\n    bool public isContractActive;           //Make sure this contract can be used or not\\r\\n    \\r\\n    /**\\r\\n     * Make sure the sender is the owner of contract\\r\\n     */ \\r\\n    modifier onlyOwner{\\r\\n        require(_msgSender() == owner, \\\"Only owner can process\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Make sure the contract is active to execute\\r\\n    */ \\r\\n    modifier contractActive{\\r\\n        require(isContractActive, \\\"This contract is deactived\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Constructor\\r\\n    * \\r\\n    * Implementations:\\r\\n    *   1. Set the owner of contract\\r\\n    *   2. Set contract is active\\r\\n    */\\r\\n    constructor(){\\r\\n       owner = _msgSender();           //Set owner address when contract is created\\r\\n       isContractActive = true;        //Contract is active when it is created\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get sender address\\r\\n     */ \\r\\n    function _msgSender() internal view returns(address){\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get current time in unix timestamp\\r\\n     */\\r\\n    function _now() internal view returns(uint){\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * Update contract status to make sure this contract can be executed or not\\r\\n     */\\r\\n    function setContractStatus(bool status) external onlyOwner{\\r\\n        require(isContractActive != status,\\\"The current contract\\u0027s status is the same with updating status\\\");\\r\\n        isContractActive = status;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Change contract\\u0027s owner\\r\\n    * @return If success return true; else return false\\r\\n    * \\r\\n    * Requirements:\\r\\n    *   1. Only current owner can execute\\r\\n    *   2. `newOwner` is not zero address\\r\\n    *   3. `newOwner` is not current owner\\r\\n    * \\r\\n    * Implementations:\\r\\n    *   1. Validate requirements\\r\\n    *   2. Set current owner is newOwner\\r\\n    *   3. Emit Events\\r\\n    *   4. Return result\\r\\n    */\\r\\n    function setOwner(address newOwner) external onlyOwner returns(bool){\\r\\n        require(newOwner != address(0), \\\"New owner is zero address\\\");\\r\\n        require(newOwner != owner, \\\"New owner is current owner\\\");\\r\\n\\r\\n        owner = newOwner;\\r\\n\\r\\n        emit OwnerChanged(owner);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Event that notifies contract\\u0027s owner has been changed to `newOwner` \\r\\n    */\\r\\n    event OwnerChanged(address newOwner);\\r\\n}\\r\\n\\r\\n//SPDX-License-Identifier: MIT\"},\"IBNUStore.sol\":{\"content\":\"pragma solidity ^0.7.1;\\r\\n\\r\\n/**\\r\\n@title Share token sale BNU interface\\r\\n */\\r\\ninterface IBNUStore{\\r\\n    /**\\r\\n    * @dev Transfer BNU token from contract to `recipient`\\r\\n    */\\r\\n    function transfer(address recipient, uint amount) external returns(bool);\\r\\n}\\r\\n\\r\\n// SPDX-License-Identifier: MIT\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.7.1;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint a, uint b) internal pure returns (uint) {\\r\\n        uint c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint a, uint b) internal pure returns (uint) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint a, uint b) internal pure returns (uint) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint a, uint b) internal pure returns (uint) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint a, uint b) internal pure returns (uint) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n//SPDX-License-Identifier: MIT\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TokenReleased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_advisorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isContractActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setBNUStoreContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setContractStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BNUVesting","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://85fde3fc6465bbf1ca131a1dd857b7adc3e6924caf9d1c8a282ff9977fe65a61"}]}