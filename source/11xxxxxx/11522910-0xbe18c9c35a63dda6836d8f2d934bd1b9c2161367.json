{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/5/UniswapOrbitConfig.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\nimport \\\"openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\\\";\\nimport \\\"openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./OrbitConfig.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./SafeToken.sol\\\";\\n\\ninterface IUniswapOrbit {\\n    function lpToken() external view returns (IUniswapV2Pair);\\n}\\n\\ncontract UniswapOrbitConfig is Ownable, OrbitConfig {\\n    using SafeToken for address;\\n    using SafeMath for uint256;\\n\\n    struct Config {\\n        bool acceptDebt;\\n        uint64 launcher;\\n        uint64 terminator;\\n        uint64 maxPriceDiff;\\n    }\\n\\n    PriceOracle public oracle;\\n    mapping (address => Config) public orbits;\\n\\n    constructor(PriceOracle _oracle) public {\\n        oracle = _oracle;\\n    }\\n\\n    /// @dev Set oracle address. Must be called by owner.\\n    function setOracle(PriceOracle _oracle) external onlyOwner {\\n        oracle = _oracle;\\n    }\\n\\n    /// @dev Set orbit configurations. Must be called by owner.\\n    function setConfigs(address[] calldata addrs, Config[] calldata configs) external onlyOwner {\\n        uint256 len = addrs.length;\\n        require(configs.length == len, \\\"bad len\\\");\\n        for (uint256 idx = 0; idx < len; idx++) {\\n            orbits[addrs[idx]] = Config({\\n                acceptDebt: configs[idx].acceptDebt,\\n                launcher: configs[idx].launcher,\\n                terminator: configs[idx].terminator,\\n                maxPriceDiff: configs[idx].maxPriceDiff\\n            });\\n        }\\n    }\\n\\n    /// @dev Return whether the given orbit is stable, presumably not under manipulation.\\n    function isStable(address orbit) public view returns (bool) {\\n        IUniswapV2Pair lp = IUniswapOrbit(orbit).lpToken();\\n        address token0 = lp.token0();\\n        address token1 = lp.token1();\\n        // 1. Check that reserves and balances are consistent (within 1%)\\n        (uint256 r0, uint256 r1,) = lp.getReserves();\\n        uint256 t0bal = token0.balanceOf(address(lp));\\n        uint256 t1bal = token1.balanceOf(address(lp));\\n        require(t0bal.mul(100) <= r0.mul(101), \\\"bad t0 balance\\\");\\n        require(t1bal.mul(100) <= r1.mul(101), \\\"bad t1 balance\\\");\\n        // 2. Check that price is in the acceptable range\\n        (uint256 price, uint256 lastUpdate) = oracle.getPrice(token0, token1);\\n        require(lastUpdate >= now - 7 days, \\\"price too stale\\\");\\n        uint256 lpPrice = r1.mul(1e18).div(r0);\\n        uint256 maxPriceDiff = orbits[orbit].maxPriceDiff;\\n        require(lpPrice <= price.mul(maxPriceDiff).div(10000), \\\"price too high\\\");\\n        require(lpPrice >= price.mul(10000).div(maxPriceDiff), \\\"price too low\\\");\\n        // 3. Done\\n        return true;\\n    }\\n\\n    /// @dev Return whether the given orbit accepts more debt.\\n    function acceptDebt(address orbit) external view returns (bool) {\\n        require(isStable(orbit), \\\"!stable\\\");\\n        return orbits[orbit].acceptDebt;\\n    }\\n\\n    /// @dev Return the work factor for the orbit + ETH debt, using 1e4 as denom.\\n    function launcher(address orbit, uint256 /* debt */) external view returns (uint256) {\\n        require(isStable(orbit), \\\"!stable\\\");\\n        return uint256(orbits[orbit].launcher);\\n    }\\n\\n    /// @dev Return the kill factor for the orbit + ETH debt, using 1e4 as denom.\\n    function terminator(address orbit, uint256 /* debt */) external view returns (uint256) {\\n        require(isStable(orbit), \\\"!stable\\\");\\n        return uint256(orbits[orbit].terminator);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/5/OrbitConfig.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\ninterface OrbitConfig {\\n    /// @dev Return whether the given orbit accepts more debt.\\n    function acceptDebt(address orbit) external view returns (bool);\\n    /// @dev Return the work factor for the orbit + ETH debt, using 1e4 as denom.\\n    function launcher(address orbit, uint256 debt) external view returns (uint256);\\n    /// @dev Return the kill factor for the orbit + ETH debt, using 1e4 as denom.\\n    function terminator(address orbit, uint256 debt) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/5/PriceOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\ninterface PriceOracle {\\n    /// @dev Return the wad price of token0/token1, multiplied by 1e18\\n    /// NOTE: (if you have 1 token0 how much you can sell it for token1)\\n    function getPrice(address token0, address token1)\\n        external view\\n        returns (uint256 price, uint256 lastUpdate);\\n}\\n\"\r\n    },\r\n    \"contracts/5/SafeToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\ninterface ERC20Interface {\\n    function balanceOf(address user) external view returns (uint256);\\n}\\n\\nlibrary SafeToken {\\n    function myBalance(address token) internal view returns (uint256) {\\n        return ERC20Interface(token).balanceOf(address(this));\\n    }\\n\\n    function balanceOf(address token, address user) internal view returns (uint256) {\\n        return ERC20Interface(token).balanceOf(user);\\n    }\\n\\n    function safeApprove(address token, address to, uint256 value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeApprove\\\");\\n    }\\n\\n    function safeTransfer(address token, address to, uint256 value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransfer\\\");\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransferFrom\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call.value(value)(new bytes(0));\\n        require(success, \\\"!safeTransferETH\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"_oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"orbit\",\"type\":\"address\"}],\"name\":\"acceptDebt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"orbit\",\"type\":\"address\"}],\"name\":\"isStable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"orbit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"launcher\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"orbits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"acceptDebt\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"launcher\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"terminator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPriceDiff\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"acceptDebt\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"launcher\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"terminator\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPriceDiff\",\"type\":\"uint64\"}],\"internalType\":\"struct UniswapOrbitConfig.Config[]\",\"name\":\"configs\",\"type\":\"tuple[]\"}],\"name\":\"setConfigs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"orbit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"terminator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapOrbitConfig","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005d480f5579cb20473e86cc8c72cbaf70d5448bef","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}