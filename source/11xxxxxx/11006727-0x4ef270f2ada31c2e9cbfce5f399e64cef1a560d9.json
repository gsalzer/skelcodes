{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-10-05\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract ERC20Basic {\r\n    uint public _totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals;\r\n    function totalSupply() public view  returns (uint){}\r\n    function balanceOf(address who) public view returns (uint){}\r\n    function transfer(address to, uint value) public {}\r\n    function transferFrom(address _from, address _to, uint _value) public{}\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {}\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract TetherToken {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals;\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function transfer(address _to, uint _value) public {  }\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function transferFrom(address _from, address _to, uint _value) public  {   }\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {    }\r\n\r\n}\r\n\r\ncontract PhoenixTiger {\r\n    \r\n    /*-----------Public Variables---------------\r\n    -----------------------------------*/\r\n    address public owner;\r\n    uint public totalGpv;\r\n    uint public lastuid;\r\n    /*-----------Mapping---------------\r\n    -----------------------------------*/\r\n    mapping(address => bool) public nonEcoUser;\r\n    mapping(address => User) public users;\r\n    mapping(address => bool) public userExist;\r\n    mapping(uint => uint) public totalCountryGpv;\r\n    mapping(address => uint[]) private userPackages;\r\n    mapping(address => bool) public orgpool;\r\n    mapping(address=> bool) public millpool;\r\n    mapping(address => bool) public globalpool;\r\n    mapping(address=>address[]) public userDownlink;\r\n    mapping(address => bool) public isRegistrar;\r\n    mapping(address=> uint) public userLockTime;\r\n    mapping(address =>bool) public isCountryEli;    \r\n    mapping(uint => address) public useridmap;\r\n    \r\n    uint[12] public Packs;\r\n    enum Status {CREATED, ACTIVE}\r\n    struct User {\r\n        uint userid;\r\n        uint countrycode;\r\n        uint pbalance;\r\n        uint rbalance;\r\n        uint rank;\r\n        uint gHeight;\r\n        uint gpv;\r\n        uint[2] lastBuy;   //0- time ; 1- pack;\r\n        uint[7] earnings;  // 0 - team earnings; 1 - family earnings; 2 - match earnings; 3 - country earnings, 4- organisation, 5 - global, 6 - millionaire\r\n        bool isbonus;\r\n        bool isKyc;\r\n        address teamaddress;\r\n        address familyaddress;\r\n        Status status;\r\n        uint traininglevel;\r\n        mapping(uint=>TrainingLevel) trainingpackage;\r\n    }\r\n    struct TrainingLevel {\r\n        uint package;\r\n        bool purchased;\r\n\r\n    }\r\n    function getLastBuyPack(address) public view returns(uint[2] memory ){  }\r\n    function getCountryUsersCount(uint) public view returns (uint){    }\r\n    function getTrainingLevel(address useraddress, uint pack) public view returns (uint tlevel, uint upack) {    }\r\n    function getAllPacksofUsers(address useraddress) public view returns(uint[] memory pck) {    }\r\n    function getidfromaddress(address useraddress) public view returns(uint userID){    }\r\n    function getAllLevelsofUsers(address useraddress,uint pack) public view returns(uint lvl) {    }\r\n    function isUserExists(address user) public view returns (bool) {    }\r\n    function checkPackPurchased(address useraddress, uint pack) public view returns (uint userpack, uint usertraininglevel, bool packpurchased){}\r\n}\r\ncontract IAbacusOracle{\r\n    uint public callFee;\r\n    function getJobResponse(uint64 _jobId) public view returns(uint64[] memory _values){    }\r\n    function scheduleFunc(address to ,uint callTime, bytes memory data , uint fee , uint gaslimit ,uint gasprice)public payable{}\r\n}\r\n\r\n\r\n\r\ncontract bridgeContract{\r\n    \r\n    TetherToken tether;\r\n    address payable owner;\r\n    address public master;\r\n    address private holdingAddress;\r\n    ERC20Basic Eco;\r\n    IAbacusOracle abacus; \r\n    PhoenixTiger phoenix;\r\n    uint public totalECOBalance;\r\n    uint64 public ecoFetchId;\r\n    uint64 public usdtFetchId;\r\n    uint lastweek;\r\n    mapping(address =>User) public users;\r\n    struct User{\r\n        uint trainingLevel;\r\n        uint extraPrinciple;\r\n        uint[3] earnings;  //0 - Rebate ; 1 - Reward ; 2 - Options\r\n        uint dueReward;\r\n        uint week;\r\n        bool options;\r\n        bool ecoPauser;\r\n        uint ecoBalance;\r\n    }\r\n    \r\n    event RedeemEarning (\r\n                address useraddress,\r\n                uint ecoBalance\r\n            );\r\n    \r\n    constructor(address _EcoAddress,address AbacusAddress,address PhoenixTigerAddress,address payable _owner,uint64 _fetchId,uint64 _usdtfetchid, address _holdingAddress) public{\r\n        owner = _owner;\r\n        Eco = ERC20Basic(_EcoAddress);\r\n        abacus = IAbacusOracle(AbacusAddress);\r\n        phoenix = PhoenixTiger(PhoenixTigerAddress);\r\n        ecoFetchId = _fetchId;\r\n        usdtFetchId = _usdtfetchid;\r\n        tether = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n        holdingAddress = _holdingAddress;\r\n        lastweek = now;\r\n    }\r\n    \r\n    function updateOptionsBWAPI(address _useraddress, bool _status) external {\r\n        require(msg.sender==owner);\r\n        users[_useraddress].options = _status;\r\n    }\r\n    \r\n    function updatePhoenixAddress(address _phoenixAddress) external {\r\n        require(msg.sender==owner);\r\n        phoenix = PhoenixTiger(_phoenixAddress);\r\n    }\r\n    \r\n    function updateEcoFetchID(uint64 _ecoFetchID) external {\r\n        require(msg.sender==owner);\r\n        ecoFetchId = _ecoFetchID;\r\n    }\r\n    \r\n    function updateUSDTID(uint64 _usdtID) external {\r\n        require(msg.sender==owner);\r\n        usdtFetchId = _usdtID;\r\n    }\r\n    \r\n    function updatetotalECO(uint _totalECO) external {\r\n        require(msg.sender==owner);\r\n        totalECOBalance = _totalECO;\r\n    }\r\n    \r\n    function updatetrainingLevel(address  []memory _users,uint  []memory _values) public {\r\n        require(msg.sender==owner);\r\n        require(_users.length == _values.length,\"check lengths\");\r\n        for(uint i=0;i<_users.length;i++){\r\n            users[_users[i]].trainingLevel = _values[i];\r\n        }\r\n    }\r\n    \r\n    function buyOptions(address _useraddress, uint _amount) public {\r\n        require(phoenix.isUserExists(_useraddress), \"You are not a Phoenix User\");\r\n        require(tether.allowance(msg.sender, address(this)) >= _amount,\"set allowance\");\r\n        require(phoenix.Packs(phoenix.getLastBuyPack(_useraddress)[1]) <= _amount, \"invalid amount of wholesale package purchase\");\r\n        tether.transferFrom(msg.sender, holdingAddress, _amount);\r\n        users[_useraddress].options = true;\r\n    }\r\n    \r\n    function updateExtraPrinciple(address  []memory _users,uint  []memory _values) public {\r\n        require(msg.sender == owner);\r\n        require(_users.length == _values.length,\"check lengths\");\r\n        for(uint i=0;i<_users.length;i++){\r\n                users[_users[i]].extraPrinciple = _values[i];\r\n        }\r\n    }\r\n    \r\n    function initSOS(address[] memory _users,uint[] memory _values) public {\r\n        require(msg.sender == owner);\r\n        require(_users.length == _values.length,\"check lengths\");\r\n        for(uint i=0;i<_users.length;i++){\r\n                users[_users[i]].ecoBalance = _values[i];\r\n        }\r\n    }\r\n\r\n    function redeemEcoBalance(address _useraddress) public{ //called weekly\r\n        require(phoenix.isUserExists(_useraddress), \"user not exists\");\r\n        require(users[_useraddress].ecoBalance>0, \"insufficient balance\");\r\n        Eco.transfer(_useraddress, users[_useraddress].ecoBalance);\r\n        users[_useraddress].ecoBalance = 0;\r\n        totalECOBalance = totalECOBalance - users[_useraddress].ecoBalance;\r\n        \r\n        emit RedeemEarning(\r\n            _useraddress,\r\n            users[_useraddress].ecoBalance\r\n        );\r\n    }\r\n\r\n    function disburseRebate(address _useraddress) public {   //called weekly\r\n        require(msg.sender == owner);\r\n        uint reward;\r\n        if(users[_useraddress].trainingLevel > users[_useraddress].week  && getLocktime(_useraddress) >= now){\r\n            reward = ((phoenix.Packs(phoenix.getLastBuyPack(_useraddress)[1])*fetchPrice(usdtFetchId) + users[_useraddress].extraPrinciple )*25*(10**8))/1000/fetchPrice(ecoFetchId);\r\n            users[_useraddress].earnings[0] += reward;\r\n            users[_useraddress].ecoBalance += reward;\r\n            totalECOBalance += reward;\r\n            users[_useraddress].week += 1;\r\n        }\r\n    }\r\n    \r\n    function disburseReward(address _useraddress) public {  //called monthly\r\n        require(msg.sender == owner);\r\n        uint reward;   \r\n        reward = (((phoenix.Packs(phoenix.getLastBuyPack(_useraddress)[1])*fetchPrice(usdtFetchId) + users[_useraddress].extraPrinciple)*10*(10**8))/100)/fetchPrice(ecoFetchId);\r\n        users[_useraddress].dueReward += reward;\r\n        if(users[_useraddress].trainingLevel > 5 && getLocktime(_useraddress)>now){\r\n            users[_useraddress].earnings[1] += users[_useraddress].dueReward;\r\n            users[_useraddress].ecoBalance += users[_useraddress].dueReward;\r\n            totalECOBalance += users[_useraddress].dueReward;\r\n            users[_useraddress].dueReward = 0;\r\n        }\r\n    }\r\n    \r\n    function disburseOptions(address _useraddress) public {   //called monthly\r\n        require(msg.sender == owner);\r\n        uint reward;\r\n        if(users[_useraddress].options == true && getLocktime(_useraddress)>now){\r\n            reward = (((phoenix.Packs(phoenix.getLastBuyPack(_useraddress)[1])*fetchPrice(usdtFetchId) + users[_useraddress].extraPrinciple)*20*(10**8))/100)/fetchPrice(ecoFetchId);\r\n            users[_useraddress].earnings[2] += reward;\r\n            users[_useraddress].ecoBalance += reward;\r\n            totalECOBalance += reward;\r\n        }\r\n    }\r\n    \r\n    function disbursePrinciple(address _useraddress) public {   //called weekly\r\n        require(msg.sender == owner);\r\n        uint reward;\r\n        if(now>getLocktime(_useraddress)) {\r\n            reward = ((phoenix.Packs(phoenix.getLastBuyPack(_useraddress)[1])*fetchPrice(usdtFetchId) + users[_useraddress].extraPrinciple)*(10**8))/fetchPrice(ecoFetchId);\r\n            users[_useraddress].earnings[1] += reward;\r\n            users[_useraddress].ecoBalance += reward;\r\n            totalECOBalance += reward;\r\n            users[_useraddress].ecoPauser = true;\r\n        }\r\n    }\r\n    \r\n    function weektrigger() public { // called weekly from outside\r\n        require(msg.sender == owner);\r\n        for( uint i= 1000001; i < phoenix.lastuid() ; i++) {\r\n            address _address = phoenix.useridmap(i);\r\n            uint _lastbuy = phoenix.getLastBuyPack(_address)[1];\r\n            if(!users[_address].ecoPauser && _lastbuy > 0) {\r\n                if(_lastbuy > lastweek) {\r\n                    users[_address].week = 0;\r\n                }\r\n                disburseRebate(_address);\r\n                disbursePrinciple(_address);\r\n            }\r\n        }\r\n        lastweek = now;\r\n    }\r\n    \r\n    function monthTrigger() public { // called monthly from outside\r\n        require(msg.sender == owner);\r\n        for( uint i= 1000001; i < phoenix.lastuid(); i++) {\r\n            if(!users[phoenix.useridmap(i)].ecoPauser) {\r\n                disburseReward(phoenix.useridmap(i));\r\n                disburseOptions(phoenix.useridmap(i));\r\n            }\r\n        }\r\n    }\r\n    \r\n    function addEco(uint _amount) public{\r\n        require(Eco.allowance(msg.sender,address(this)) >= _amount);\r\n        Eco.transferFrom(msg.sender,address(this),_amount);\r\n    }\r\n    \r\n    function getLocktime(address _useraddress) private view returns(uint){\r\n\treturn phoenix.getLastBuyPack(_useraddress)[0] + (phoenix.userLockTime(_useraddress)*30 days);\r\n    }\r\n    \r\n    function getECODue() public view returns(uint _ecoDue) {\r\n        if(totalECOBalance > Eco.balanceOf(address(this))) {\r\n            return (totalECOBalance-Eco.balanceOf(address(this)));\r\n        }\r\n    }\r\n    \r\n    function fetchPrice(uint64 _fetchId) private view returns(uint){\r\n        return abacus.getJobResponse(_fetchId)[0];\r\n    }\r\n    \r\n    function getEarnings(address _useraddress) public view returns(uint[3] memory _earnings){\r\n        return users[_useraddress].earnings;\r\n        \r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_EcoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AbacusAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"PhoenixTigerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_fetchId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_usdtfetchid\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_holdingAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ecoBalance\",\"type\":\"uint256\"}],\"name\":\"RedeemEarning\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addEco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"disburseOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"disbursePrinciple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"disburseRebate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"disburseReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecoFetchId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getECODue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ecoDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getEarnings\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"_earnings\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"initSOS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"redeemEcoBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalECOBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_ecoFetchID\",\"type\":\"uint64\"}],\"name\":\"updateEcoFetchID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateExtraPrinciple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateOptionsBWAPI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_phoenixAddress\",\"type\":\"address\"}],\"name\":\"updatePhoenixAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_usdtID\",\"type\":\"uint64\"}],\"name\":\"updateUSDTID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalECO\",\"type\":\"uint256\"}],\"name\":\"updatetotalECO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updatetrainingLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtFetchId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"trainingLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraPrinciple\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dueReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"options\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ecoPauser\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ecoBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weektrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"bridgeContract","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000191557728e4d8caa4ac94f86af842148c0fa8f7e0000000000000000000000006bfb5eb3526518000e5c1e00c7a0a376c2e31dcb00000000000000000000000085fd74beec59a9899c5fdcdb95b4fc9717d0b6a5000000000000000000000000756018b28ac84029630a89f65d275518e79e81900000000000000000000000000000000000000000000000001b97ea41f5c1d16f0000000000000000000000000000000000000000000000008ffefc437b6e2202000000000000000000000000865ced03955296d4489782ef7393f1364e28dec6","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://68e8236a42826eb697684aafaeb1ae661f659eaa1cf9ba718fc1b10479ce68d8"}]}