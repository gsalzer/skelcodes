{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.0.11 https://hardhat.org\r\n\r\n// File @animoca/ethereum-contracts-assets_inventory/contracts/token/ERC721/IERC721.sol@v8.0.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.8;\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard, basic interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n * Note: The ERC-165 identifier for this interface is 0x80ac58cd.\r\n */\r\ninterface IERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return balance uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * Gets the owner of the specified ID\r\n     * @param tokenId uint256 ID to query the owner of\r\n     * @return owner address currently marked as the owner of the given ID\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * Approves another address to transfer the given token ID\r\n     * @dev The zero address indicates there is no approved address.\r\n     * @dev There can only be one approved address per token at a given time.\r\n     * @dev Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * Gets the approved address for a token ID, or zero if no address set\r\n     * @dev Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return operator address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * Sets or unsets the approval of a given operator\r\n     * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param operator operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * Transfers the ownership of a given token ID to another address\r\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * Safely transfers the ownership of a given token ID to another address\r\n     *\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * Safely transfers the ownership of a given token ID to another address\r\n     *\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/introspection/IERC165.sol@v3.3.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets_inventory/contracts/token/ERC721/IERC721Receiver.sol@v8.0.0\r\n\r\npragma solidity 0.6.8;\r\n\r\n/**\r\n    @title ERC721 Non-Fungible Token Standard, token receiver\r\n    @dev See https://eips.ethereum.org/EIPS/eip-721\r\n    Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.\r\n    Note: The ERC-165 identifier for this interface is 0x150b7a02.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n        @notice Handle the receipt of an NFT\r\n        @dev The ERC721 smart contract calls this function on the recipient\r\n        after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n        otherwise the caller will revert the transaction. The selector to be\r\n        returned can be obtained as `this.onERC721Received.selector`. This\r\n        function MAY throw to revert and reject the transfer.\r\n        Note: the ERC721 contract address is always the message sender.\r\n        @param operator The address which called `safeTransferFrom` function\r\n        @param from The address which previously owned the token\r\n        @param tokenId The NFT identifier which is being transferred\r\n        @param data Additional data with no specified format\r\n        @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets_inventory/contracts/token/ERC721/ERC721Receiver.sol@v8.0.0\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\nabstract contract ERC721Receiver is IERC721Receiver, IERC165 {\r\n    bytes4 private constant _ERC165_INTERFACE_ID = type(IERC165).interfaceId;\r\n    bytes4 private constant _ERC721_RECEIVER_INTERFACE_ID = type(IERC721Receiver).interfaceId;\r\n\r\n    bytes4 internal constant _ERC721_RECEIVED = type(IERC721Receiver).interfaceId;\r\n    bytes4 internal constant _ERC721_REJECTED = 0xffffffff;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == _ERC165_INTERFACE_ID || interfaceId == _ERC721_RECEIVER_INTERFACE_ID;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/ERC1155721/BlackHoleBoredElonTweeter.sol\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\ncontract BlackHoleBoredElonTweeter is ERC721Receiver {\r\n\r\n    address public constant RARIBLE_NFT_CONTRACT = 0x60F80121C31A0d46B5279700f9DF786054aa5eE5;\r\n    uint256 public constant BOREDELON_TWEET_NFT_ID = 182768;\r\n\r\n    // some place with no way back\r\n    address public constant BLACK_HOLE = 0xDeAD0deAD0DeAd0DEaD0dEAd0DeaD0dEAd0DEaD1;\r\n\r\n    string public daImmortalText;\r\n    string public daImmortalAuthor;\r\n    address public daImmortalOwner;\r\n\r\n    function onERC721Received(\r\n        address /*operator*/,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        // Door to hell, no trespassers\r\n        require(msg.sender == RARIBLE_NFT_CONTRACT, \"Wrong contract\");\r\n        require(tokenId == BOREDELON_TWEET_NFT_ID, \"Wrong token\");\r\n\r\n        // Mark this moment forever on-chain\r\n        daImmortalOwner = from;\r\n        (daImmortalText, daImmortalAuthor) = abi.decode(data, (string, string));\r\n\r\n        // NFT destruction\r\n        IERC721(RARIBLE_NFT_CONTRACT).transferFrom(address(this), BLACK_HOLE, BOREDELON_TWEET_NFT_ID);\r\n\r\n        // All went well :)\r\n        return _ERC721_RECEIVED;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"BLACK_HOLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOREDELON_TWEET_NFT_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RARIBLE_NFT_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daImmortalAuthor\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daImmortalOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daImmortalText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BlackHoleBoredElonTweeter","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1bbd4acd2e130365baef946dfc41f065b3a3312d8e91652211e31e29320c84b4"}]}