{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: none\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    \r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    \r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    \r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    \r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from,address indexed to,uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract YFDOTFarm is Context {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    struct periodList{\r\n        uint256 periodTime;\r\n        uint256 cooldownTime;\r\n        uint256 formulaParam1;\r\n        uint256 formulaParam2;\r\n        uint256 formulaPenalty1;\r\n        uint256 formulaPenalty2;\r\n    }\r\n    \r\n    struct userFarming{\r\n        bool activeFarm;\r\n        uint periodChoosed;\r\n        address tokenWantFarm;\r\n        uint256 amountFarmd;\r\n        uint256 startFarm;\r\n        uint256 claimFarm;\r\n        uint256 endFarm;\r\n        uint256 cooldownDate;\r\n        uint256 claimed;\r\n    }\r\n    \r\n    struct rewardDetail{\r\n        string symboltoken;\r\n        uint256 equalReward;\r\n        uint256 minimalFarm;\r\n        uint256 maximalFarm;\r\n        uint decimaltoken;\r\n    }\r\n    \r\n    mapping (uint => periodList) private period;\r\n    mapping (address => rewardDetail) private ERC20perYFDOT;\r\n    mapping (address => userFarming) private FarmDetail;\r\n    mapping (address => uint256) private devBalance;\r\n    \r\n    address private _owner;\r\n    address private _YFDOTtoken;\r\n    address[] private _tokenFarmList;\r\n    address[] private _FarmerList;\r\n    uint[] private _periodList;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Farm(address indexed Farmr, address indexed tokenFarmTarget, uint256 indexed amountTokenFarmd);\r\n    event UnFarm(address indexed Farmr, address indexed tokenFarmTarget, uint256 indexed amountTokenFarmd);\r\n    event Claim(address indexed Farmr, address indexed tokenFarmTarget, uint256 indexed amountReward);\r\n    \r\n    constructor(address YFDOTAddress){\r\n        rewardDetail storage est = ERC20perYFDOT[YFDOTAddress];\r\n        rewardDetail storage nul = ERC20perYFDOT[address(0)];\r\n        require(YFDOTAddress.isContract() == true,\"This address is not Smartcontract\");\r\n        require(IERC20(YFDOTAddress).totalSupply() != 0, \"This address is not ERC20 Token\");\r\n        address msgSender = _msgSender();\r\n        _YFDOTtoken = YFDOTAddress;\r\n        _owner = msgSender;\r\n        _tokenFarmList.push(address(0));\r\n        est.symboltoken = \"YFDOT\";\r\n        est.decimaltoken = 18;\r\n        nul.symboltoken = \"ETH\";\r\n        nul.minimalFarm = 10**16;\r\n        nul.equalReward = 10**18;\r\n        nul.maximalFarm = 5 * (10**18);\r\n        nul.decimaltoken = 18;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    \r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    \r\n    function addTokenReward(address erc20Token, uint256 amountEqual, uint256 minFarm, uint256 maxFarm, uint decimall, string memory symboltokens) public virtual onlyOwner{\r\n        if(erc20Token != address(0)){\r\n            require(erc20Token.isContract() == true,\"This address is not Smartcontract\");\r\n            require(IERC20(erc20Token).totalSupply() != 0, \"This address is not ERC20 Token\");\r\n        }\r\n        \r\n        rewardDetail storage est = ERC20perYFDOT[erc20Token];\r\n        est.equalReward = amountEqual;\r\n        est.symboltoken = symboltokens;\r\n        est.minimalFarm = minFarm;\r\n        est.maximalFarm = maxFarm;\r\n        est.decimaltoken = decimall;\r\n        \r\n        _tokenFarmList.push(erc20Token);\r\n    }\r\n    \r\n    function editTokenReward(address erc20Token, uint256 amountEqual, uint256 minFarm, uint256 maxFarm, uint decimall, string memory symboltokens) public virtual onlyOwner{\r\n        if(erc20Token != address(0)){\r\n            require(erc20Token.isContract() == true,\"This address is not Smartcontract\");\r\n            require(IERC20(erc20Token).totalSupply() != 0, \"This address is not ERC20 Token\");\r\n        }\r\n        \r\n        rewardDetail storage est = ERC20perYFDOT[erc20Token];\r\n        est.equalReward = amountEqual;\r\n        est.symboltoken = symboltokens;\r\n        est.minimalFarm = minFarm;\r\n        est.maximalFarm = maxFarm;\r\n        est.decimaltoken = decimall;\r\n    }\r\n    \r\n    function addPeriod(uint256 timePeriodFarm, uint256 timeCooldownUnFarm, uint256 formula1, uint256 formula2, uint256 fpel1, uint256 fpel2) public virtual onlyOwner{\r\n        uint newPeriod = _periodList.length;\r\n        if(newPeriod == 0){\r\n            newPeriod = 1;\r\n        }else{\r\n            newPeriod = newPeriod + 1;\r\n        }\r\n        \r\n        periodList storage sys = period[newPeriod];\r\n        sys.periodTime = timePeriodFarm;\r\n        sys.cooldownTime = timeCooldownUnFarm;\r\n        sys.formulaParam1 = formula1;\r\n        sys.formulaParam2 = formula2;\r\n        sys.formulaPenalty1 = fpel1;\r\n        sys.formulaPenalty2 = fpel2;\r\n        \r\n        _periodList.push(newPeriod);\r\n    }\r\n    \r\n    function editPeriod(uint periodEdit, uint256 timePeriodFarm, uint256 timeCooldownUnFarm, uint256 formula1, uint256 formula2, uint256 fpel1, uint256 fpel2) public virtual onlyOwner{\r\n        periodList storage sys = period[periodEdit];\r\n        sys.periodTime = timePeriodFarm;\r\n        sys.cooldownTime = timeCooldownUnFarm;\r\n        sys.formulaParam1 = formula1;\r\n        sys.formulaParam2 = formula2;\r\n        sys.formulaPenalty1 = fpel1;\r\n        sys.formulaPenalty2 = fpel2;\r\n    }\r\n    \r\n    function claimDevBalance(address target) public virtual onlyOwner{\r\n        if(target == address(0)){\r\n            payable(_owner).transfer(devBalance[target]);\r\n        }else{\r\n            IERC20(target).safeTransfer(_owner, devBalance[target]);\r\n        }\r\n        \r\n        devBalance[target] = 0;\r\n    }\r\n    \r\n    function claimReward() public virtual{\r\n        address msgSender = _msgSender();\r\n        userFarming storage usr = FarmDetail[msgSender];\r\n        uint256 getrewardbalance = IERC20(_YFDOTtoken).balanceOf(address(this));\r\n        uint256 getReward = getRewardClaimable(msgSender);\r\n        uint256 today = block.timestamp;\r\n        \r\n        require(getrewardbalance >= getReward, \"Please wait until reward pool filled, try again later.\");\r\n        require(usr.claimFarm < block.timestamp, \"Please wait until wait time reached.\");\r\n        \r\n        usr.claimed = usr.claimed.add(getReward);\r\n        usr.claimFarm = today.add(7 days);\r\n        IERC20(_YFDOTtoken).safeTransfer(msgSender, getReward);\r\n        emit Claim(msgSender, _YFDOTtoken, getReward);\r\n    }\r\n    \r\n    function FarmNow(address tokenTargetFarm, uint256 amountWantFarm, uint periodwant) public payable virtual{\r\n        address msgSender = _msgSender();\r\n        uint256 getallowance;\r\n        if(tokenTargetFarm != address(0)){\r\n            getallowance = IERC20(tokenTargetFarm).allowance(msgSender, address(this));\r\n        }\r\n        \r\n        if(getRewardClaimable(msgSender) > 0){\r\n            revert(\"Please claim your reward from previous Farming\");\r\n        }\r\n        \r\n        uint256 today = block.timestamp;\r\n        userFarming storage usr = FarmDetail[msgSender];\r\n        periodList storage sys = period[periodwant];\r\n        rewardDetail storage est = ERC20perYFDOT[tokenTargetFarm];\r\n        \r\n        if(tokenTargetFarm == address(0)){\r\n            require(msg.value >= est.minimalFarm, \"Minimum Farming value required\");\r\n            require(msg.value <= est.maximalFarm, \"Maximum Farming value is reached\");\r\n        }else{\r\n            require(amountWantFarm >= est.minimalFarm, \"Minimum Farming value required\");\r\n            require(amountWantFarm <= est.maximalFarm, \"Maximum Farming value is reached\");\r\n            require(getallowance >= amountWantFarm, \"Insufficient token approval balance, you must increase your allowance\" );\r\n        }\r\n        \r\n        usr.activeFarm = true;\r\n        usr.periodChoosed = periodwant;\r\n        usr.tokenWantFarm = tokenTargetFarm;\r\n        usr.amountFarmd = amountWantFarm;\r\n        usr.startFarm = today;\r\n        usr.claimFarm = today.add(7 days);\r\n        usr.cooldownDate = today.add(sys.cooldownTime);\r\n        usr.endFarm = today.add(sys.periodTime);\r\n        usr.claimed = 0;\r\n        \r\n        bool checkregis = false;\r\n        for(uint i = 0; i < _FarmerList.length; i++){\r\n            if(_FarmerList[i] == msgSender){\r\n                checkregis = true;\r\n            }\r\n        }\r\n        \r\n        if(checkregis == false){\r\n            _FarmerList.push(msgSender);\r\n        }\r\n        \r\n        if(tokenTargetFarm != address(0)){\r\n            IERC20(tokenTargetFarm).safeTransferFrom(msgSender, address(this), amountWantFarm);\r\n        }\r\n        \r\n        emit Farm(msgSender, tokenTargetFarm, amountWantFarm);\r\n    }\r\n    \r\n    function unFarmNow() public virtual{\r\n        address msgSender = _msgSender();\r\n        userFarming storage usr = FarmDetail[msgSender];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        \r\n        require(usr.activeFarm == true, \"Farm not active yet\" );\r\n        \r\n        uint256 tokenUnFarm;\r\n        if(block.timestamp < usr.cooldownDate){\r\n            uint256 penfee = usr.amountFarmd.mul(sys.formulaPenalty1);\r\n            penfee = penfee.div(sys.formulaPenalty2);\r\n            penfee = penfee.div(100);\r\n            tokenUnFarm = usr.amountFarmd.sub(penfee);\r\n            devBalance[usr.tokenWantFarm] = devBalance[usr.tokenWantFarm].add(penfee);\r\n        }else{\r\n            tokenUnFarm = usr.amountFarmd;\r\n        }\r\n        \r\n        usr.activeFarm = false;\r\n        if(block.timestamp < usr.endFarm){\r\n            usr.endFarm = block.timestamp;\r\n        }\r\n        \r\n        if(usr.tokenWantFarm == address(0)){\r\n            payable(msgSender).transfer(tokenUnFarm);\r\n        }else{\r\n            IERC20(usr.tokenWantFarm).safeTransfer(msgSender, tokenUnFarm);\r\n        }\r\n        \r\n        uint256 getCLaimableRwt = getRewardClaimable(msgSender);\r\n        \r\n        if(getCLaimableRwt > 0){\r\n            IERC20(_YFDOTtoken).safeTransfer(msgSender, getCLaimableRwt);\r\n            usr.claimed = usr.claimed.add(getCLaimableRwt);\r\n        }\r\n        \r\n        emit UnFarm(msgSender, usr.tokenWantFarm, usr.amountFarmd);\r\n        emit Claim(msgSender, _YFDOTtoken, getCLaimableRwt);\r\n    }\r\n    \r\n    function getDevBalance(address target) public view returns(uint256){\r\n        return devBalance[target];\r\n    }\r\n    \r\n    function getEqualReward(address erc20Token) public view returns(uint256, string memory, uint256, uint256, uint){\r\n        rewardDetail storage est = ERC20perYFDOT[erc20Token];\r\n        return(\r\n            est.equalReward,\r\n            est.symboltoken,\r\n            est.minimalFarm,\r\n            est.maximalFarm,\r\n            est.decimaltoken\r\n        );\r\n    }\r\n    \r\n    function getTotalFarmer() public view returns(uint256){\r\n        return _FarmerList.length;\r\n    }\r\n    \r\n    function getActiveFarmer() view public returns(uint256){\r\n        uint256 activeFarm;\r\n        for(uint i = 0; i < _FarmerList.length; i++){\r\n            userFarming memory l = FarmDetail[_FarmerList[i]];\r\n            if(l.activeFarm == true){\r\n                activeFarm = activeFarm + 1;\r\n            }\r\n        }\r\n        return activeFarm;\r\n    }\r\n    \r\n    function getTokenList() public view returns(address[] memory){\r\n        return _tokenFarmList;\r\n    }\r\n    \r\n    function getPeriodList() public view returns(uint[] memory){\r\n        return _periodList;\r\n    }\r\n    \r\n    function getPeriodDetail(uint periodwant) public view returns(uint256, uint256, uint256, uint256, uint256, uint256){\r\n        periodList storage sys = period[periodwant];\r\n        return(\r\n            sys.periodTime,\r\n            sys.cooldownTime,\r\n            sys.formulaParam1,\r\n            sys.formulaParam2,\r\n            sys.formulaPenalty1,\r\n            sys.formulaPenalty2\r\n        );\r\n    }\r\n    \r\n    function getUserInfo(address FarmrAddress) public view returns(bool, uint, address, string memory, uint256, uint256, uint256, uint256, uint256, uint256){\r\n        userFarming storage usr = FarmDetail[FarmrAddress];\r\n        rewardDetail storage est = ERC20perYFDOT[usr.tokenWantFarm];\r\n        \r\n        uint256 amountTotalFarmd;\r\n        if(usr.activeFarm == false){\r\n            amountTotalFarmd = 0;\r\n        }else{\r\n            amountTotalFarmd = usr.amountFarmd;\r\n        }\r\n        return(\r\n            usr.activeFarm,\r\n            usr.periodChoosed,\r\n            usr.tokenWantFarm,\r\n            est.symboltoken,\r\n            amountTotalFarmd,\r\n            usr.startFarm,\r\n            usr.claimFarm.add(1 minutes),\r\n            usr.endFarm,\r\n            usr.cooldownDate,\r\n            usr.claimed\r\n        );\r\n    }\r\n    \r\n    function getRewardClaimable(address FarmrAddress) public view returns(uint256){\r\n        userFarming storage usr = FarmDetail[FarmrAddress];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        rewardDetail storage est = ERC20perYFDOT[usr.tokenWantFarm];\r\n        \r\n        uint256 rewards;\r\n        \r\n        if(usr.amountFarmd == 0 && usr.tokenWantFarm == address(0)){\r\n            rewards = 0;\r\n        }else{\r\n            uint256 today = block.timestamp;\r\n            uint256 diffTime;\r\n            if(today > usr.endFarm){\r\n                diffTime = usr.endFarm.sub(usr.startFarm);\r\n            }else{\r\n                diffTime = today.sub(usr.startFarm);\r\n            }\r\n            rewards = usr.amountFarmd.mul(diffTime);\r\n            uint256 getTokenEqual = est.equalReward;\r\n            rewards = rewards.mul(getTokenEqual);\r\n            rewards = rewards.mul(sys.formulaParam1);\r\n            rewards = rewards.div(10**est.decimaltoken);\r\n            rewards = rewards.div(sys.formulaParam2);\r\n            rewards = rewards.div(100);\r\n            rewards = rewards.sub(usr.claimed);\r\n        }\r\n        return rewards;\r\n    }\r\n    \r\n    function getRewardObtained(address FarmrAddress) public view returns(uint256){\r\n        userFarming storage usr = FarmDetail[FarmrAddress];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        rewardDetail storage est = ERC20perYFDOT[usr.tokenWantFarm];\r\n        uint256 rewards;\r\n        \r\n        if(usr.amountFarmd == 0 && usr.tokenWantFarm == address(0)){\r\n            rewards = 0;\r\n        }else{\r\n            uint256 today = block.timestamp;\r\n            uint256 diffTime;\r\n            if(today > usr.endFarm){\r\n                diffTime = usr.endFarm.sub(usr.startFarm);\r\n            }else{\r\n                diffTime = today.sub(usr.startFarm);\r\n            }\r\n            rewards = usr.amountFarmd.mul(diffTime);\r\n            uint256 getTokenEqual = est.equalReward;\r\n            rewards = rewards.mul(getTokenEqual);\r\n            rewards = rewards.mul(sys.formulaParam1);\r\n            rewards = rewards.div(10**est.decimaltoken);\r\n            rewards = rewards.div(sys.formulaParam2);\r\n            rewards = rewards.div(100);\r\n        }\r\n        return rewards;\r\n    }\r\n    \r\n    function getRewardEstimator(address FarmrAddress) public view returns(uint256,uint256,uint256,uint256,uint256,uint256){\r\n        userFarming storage usr = FarmDetail[FarmrAddress];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        rewardDetail storage est = ERC20perYFDOT[usr.tokenWantFarm];\r\n        uint256 amountFarmdNow;\r\n        \r\n        if(usr.activeFarm == true){\r\n            amountFarmdNow = usr.amountFarmd;\r\n            uint256 perSec = amountFarmdNow.mul(sys.formulaParam1);\r\n            uint256 getTokenEqual = est.equalReward;\r\n            perSec = perSec.mul(getTokenEqual);\r\n            perSec = perSec.div(sys.formulaParam2);\r\n            perSec = perSec.div(100);\r\n            perSec = perSec.div(10**est.decimaltoken);\r\n            \r\n            return(\r\n                perSec,\r\n                perSec.mul(60),\r\n                perSec.mul(3600),\r\n                perSec.mul(86400),\r\n                perSec.mul(604800),\r\n                perSec.mul(2592000)\r\n            );\r\n        }else{\r\n            return(0,0,0,0,0,0);\r\n        }\r\n        \r\n    }\r\n    \r\n    function getRewardCalculator(address tokenWantFarm, uint256 amountWantFarm, uint periodwant) public view returns(uint256){\r\n        periodList storage sys = period[periodwant];\r\n        rewardDetail storage est = ERC20perYFDOT[tokenWantFarm];\r\n        \r\n        uint256 startDate = block.timestamp;\r\n        uint256 endDate = startDate.add(sys.periodTime);\r\n        uint256 diffTime = endDate.sub(startDate);\r\n        uint256 rewards = amountWantFarm.mul(diffTime);\r\n        uint256 getTokenEqual = est.equalReward;\r\n        rewards = rewards.mul(getTokenEqual);\r\n        rewards = rewards.mul(sys.formulaParam1);\r\n        rewards = rewards.div(10**est.decimaltoken);\r\n        rewards = rewards.div(sys.formulaParam2);\r\n        rewards = rewards.div(100);\r\n        return rewards;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"YFDOTAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Farmr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenFarmTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountReward\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Farmr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenFarmTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountTokenFarmd\",\"type\":\"uint256\"}],\"name\":\"Farm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Farmr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenFarmTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountTokenFarmd\",\"type\":\"uint256\"}],\"name\":\"UnFarm\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenTargetFarm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWantFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodwant\",\"type\":\"uint256\"}],\"name\":\"FarmNow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timePeriodFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCooldownUnFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel2\",\"type\":\"uint256\"}],\"name\":\"addPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountEqual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimall\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symboltokens\",\"type\":\"string\"}],\"name\":\"addTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"claimDevBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodEdit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePeriodFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCooldownUnFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel2\",\"type\":\"uint256\"}],\"name\":\"editPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountEqual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimall\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symboltokens\",\"type\":\"string\"}],\"name\":\"editTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveFarmer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getDevBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"getEqualReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodwant\",\"type\":\"uint256\"}],\"name\":\"getPeriodDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPeriodList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenWantFarm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWantFarm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodwant\",\"type\":\"uint256\"}],\"name\":\"getRewardCalculator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"FarmrAddress\",\"type\":\"address\"}],\"name\":\"getRewardClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"FarmrAddress\",\"type\":\"address\"}],\"name\":\"getRewardEstimator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"FarmrAddress\",\"type\":\"address\"}],\"name\":\"getRewardObtained\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalFarmer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"FarmrAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unFarmNow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"YFDOTFarm","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002e6539edc3b76f1e21b71d214527faba875f70f3","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c582c031845b8ecf41c54b6d5346aab421f413b1101201f0e832c5fb1e400308"}]}