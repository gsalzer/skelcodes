{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Math.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/* @dev A safe math lib for Rho data types. \\n   Note: always returns type of left side param */\\ncontract Math is Types {\\n\\n\\tuint constant EXP_SCALE = 1e18;\\n    Exp ONE_EXP = Exp({mantissa: EXP_SCALE});\\n\\n    function toExp_(uint num) pure internal returns (Exp memory) {\\n    \\treturn Exp({mantissa: num});\\n    }\\n\\n    function toUint_(int a) pure internal returns (uint) {\\n        return a > 0 ? uint(a) : 0;\\n    }\\n\\n    function lt_(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val < b.val;\\n    }\\n\\n    function lte_(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (bool) {\\n        return a.val <= b.val;\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: add_(a.val, b.val)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function subToZero_(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        if (b.val >= a.val) {\\n            return CTokenAmount({val: 0});\\n        } else {\\n            return sub_(a,b);\\n        }\\n    }\\n\\n    function subToZero_(uint a, uint b) pure internal returns (uint) {\\n        if (b >= a) {\\n            return 0;\\n        } else {\\n            return sub_(a,b);\\n        }\\n    }\\n\\n    function subToZero_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        if (b.mantissa >= a.mantissa) {\\n            return Exp({mantissa: 0});\\n        } else {\\n            return sub_(a,b);\\n        }\\n    }\\n\\n    function sub_(CTokenAmount memory a, CTokenAmount memory b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: sub_(a.val, b.val)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function sub_(int a, uint b) pure internal returns (int) {\\n        int c = a - int(b);\\n        require(a >= c, \\\"int - uint underflow\\\");\\n        return c;\\n    }\\n\\n    function add_(int a, uint b) pure internal returns (int) {\\n        int c = a + int(b);\\n        require(a <= c, \\\"int + uint overflow\\\");\\n        return c;\\n    }\\n\\n    function mul_(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return mul_(a, b.val);\\n    }\\n\\n    function mul_(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: mul_(a.val, b)});\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / EXP_SCALE});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div_(uint a, CTokenAmount memory b) pure internal returns (uint) {\\n        return div_(a, b.val);\\n    }\\n\\n    function div_(CTokenAmount memory a, uint b) pure internal returns (CTokenAmount memory) {\\n        return CTokenAmount({val: div_(a.val, b)});\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, EXP_SCALE), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        require(b > 0, \\\"divide by zero\\\");\\n        return a / b;\\n    }\\n\\n}\\n\",\r\n      \"keccak256\": \"0xc0b1a8d56c317dfe345f900dfb3a43add1c88edd3440b550c16a164f42eb7db7\"\r\n    },\r\n    \"contracts/Rho.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport {RhoInterface, CTokenInterface, CompInterface, InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\n/* @dev:\\n * CTokens are used as collateral. \\\"Underlying\\\" in Rho refers to the collateral CToken's underlying token.\\n * An Exp is a data type with 18 decimals, used for scaling up and precise calculations */\\ncontract Rho is RhoInterface, Math {\\n\\n\\tCTokenInterface public immutable cToken;\\n\\tCompInterface public immutable comp;\\n\\n\\tuint public immutable SWAP_MIN_DURATION;\\n\\tuint public immutable SUPPLY_MIN_DURATION;\\n\\tuint public immutable MIN_SWAP_NOTIONAL = 1e18;\\n\\tuint public immutable CLOSE_GRACE_PERIOD_BLOCKS = 3000; // ~12.5 hrs\\n\\tuint public immutable CLOSE_PENALTY_PER_BLOCK_MANTISSA = 1e14;// 1% (1e16) every 25 min (100 blocks)\\n\\n\\tconstructor (\\n\\t\\tInterestRateModelInterface interestRateModel_,\\n\\t\\tCTokenInterface cToken_,\\n\\t\\tCompInterface comp_,\\n\\t\\tuint minFloatRateMantissa_,\\n\\t\\tuint maxFloatRateMantissa_,\\n\\t\\tuint swapMinDuration_,\\n\\t\\tuint supplyMinDuration_,\\n\\t\\taddress admin_,\\n\\t\\tuint liquidityLimitCTokens_\\n\\t) public {\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\tinterestRateModel = interestRateModel_;\\n\\t\\tcToken = cToken_;\\n\\t\\tcomp = comp_;\\n\\t\\tminFloatRate = toExp_(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = toExp_(maxFloatRateMantissa_);\\n\\t\\tSWAP_MIN_DURATION = swapMinDuration_;\\n\\t\\tSUPPLY_MIN_DURATION = supplyMinDuration_;\\n\\t\\tadmin = admin_;\\n\\n\\t\\tsupplyIndex = ONE_EXP.mantissa;\\n\\t\\tisPaused = false;\\n\\t\\tliquidityLimit = CTokenAmount({val:liquidityLimitCTokens_});\\n\\t}\\n\\n\\t/* @dev Supplies liquidity to the protocol. Become the counterparty for all swap traders, in return for fees.\\n\\t * @param cTokenSupplyAmount Amount to supply, in CTokens.\\n\\t */\\n\\tfunction supply(uint cTokenSupplyAmount) public override {\\n\\t\\tCTokenAmount memory supplyAmount = CTokenAmount({val: cTokenSupplyAmount});\\n\\t\\tCTokenAmount memory supplierLiquidityNew = add_(supplierLiquidity, supplyAmount);\\n\\t\\t\\n\\t\\trequire(lt_(supplierLiquidityNew, liquidityLimit), \\\"Supply paused, above liquidity limit\\\");\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory prevSupply = supplyAccounts[msg.sender].amount;\\n\\n\\t\\tCTokenAmount memory truedUpPrevSupply;\\n\\t\\tif (prevSupply.val == 0) {\\n\\t\\t\\ttruedUpPrevSupply = CTokenAmount({val: 0});\\n\\t\\t} else {\\n\\t\\t\\tuint prevIndex = supplyAccounts[msg.sender].index;\\n\\t\\t\\ttruedUpPrevSupply = div_(mul_(prevSupply, supplyIndex), prevIndex);\\n\\t\\t}\\n\\n\\t\\tCTokenAmount memory newSupplyAmount = add_(truedUpPrevSupply, supplyAmount);\\n\\n\\t\\temit Supply(msg.sender, cTokenSupplyAmount, newSupplyAmount.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].amount = newSupplyAmount;\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\n\\t\\ttransferIn(msg.sender, supplyAmount);\\n\\t}\\n\\n\\t/* @dev Remove liquidity from protocol. Can only perform after a waiting period from supplying, to prevent interest rate manipulation\\n\\t * @param removeCTokenAmount Amount of CTokens to remove. 0 removes all CTokens.\\n\\t */\\n\\tfunction remove(uint removeCTokenAmount) public override {\\n\\t\\tCTokenAmount memory removeAmount = CTokenAmount({val: removeCTokenAmount});\\n\\t\\tSupplyAccount memory account = supplyAccounts[msg.sender];\\n\\t\\trequire(account.amount.val > 0, \\\"Must withdraw from active account\\\");\\n\\t\\trequire(getBlockNumber() - account.lastBlock >= SUPPLY_MIN_DURATION, \\\"Liquidity must be supplied a minimum duration\\\");\\n\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\t\\tCTokenAmount memory truedUpAccountValue = div_(mul_(account.amount, supplyIndex), account.index);\\n\\n\\t\\t// Remove all liquidity\\n\\t\\tif (removeAmount.val == 0) {\\n\\t\\t\\tremoveAmount = truedUpAccountValue;\\n\\t\\t}\\n\\t\\trequire(lte_(removeAmount, truedUpAccountValue), \\\"Trying to remove more than account value\\\");\\n\\t\\tCTokenAmount memory unlockedCollateral = sub_(supplierLiquidity, lockedCollateral);\\n\\t\\t\\n\\t\\trequire(lte_(removeAmount, unlockedCollateral), \\\"Removing more liquidity than is unlocked\\\");\\n\\t\\trequire(lte_(removeAmount, supplierLiquidity), \\\"Removing more than total supplier liquidity\\\");\\n\\n\\t\\tCTokenAmount memory newAccountValue = sub_(truedUpAccountValue, removeAmount);\\n\\n\\t\\temit Remove(msg.sender, removeCTokenAmount, newAccountValue.val);\\n\\n\\t\\tsupplyAccounts[msg.sender].lastBlock = getBlockNumber();\\n\\t\\tsupplyAccounts[msg.sender].index = supplyIndex;\\n\\t\\tsupplyAccounts[msg.sender].amount = newAccountValue;\\n\\n\\t\\tsupplierLiquidity = sub_(supplierLiquidity, removeAmount);\\n\\n\\t\\ttransferOut(msg.sender, removeAmount);\\n\\t}\\n\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(true, notionalAmount, maximumFixedRateMantissa);\\n\\t}\\n\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) public override returns(bytes32 swapHash) {\\n\\t\\treturn openInternal(false, notionalAmount, minFixedRateMantissa);\\n\\t}\\n\\n\\t/* @dev Opens a new interest rate swap\\n\\t * @param userPayingFixed : The user can choose if they want to receive fixed or pay fixed (the protocol will take the opposite side)\\n\\t * @param notionalAmount : The principal that interest rate payments will be based on\\n\\t * @param fixedRateLimitMantissa : The maximum (if payingFixed) or minimum (if receivingFixed) rate the swap should succeed at. Prevents frontrunning attacks.\\n\\t \\t* The amount of interest to pay over 2,102,400 blocks (~1 year), with 18 decimals of precision. Eg: 5% per block-year => 0.5e18.\\n\\t*/\\n\\tfunction openInternal(bool userPayingFixed, uint notionalAmount, uint fixedRateLimitMantissa) internal returns (bytes32 swapHash) {\\n\\t\\trequire(isPaused == false, \\\"Market paused\\\");\\n\\t\\trequire(notionalAmount >= MIN_SWAP_NOTIONAL, \\\"Swap notional amount must exceed minimum\\\");\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\n\\t\\tCTokenAmount memory lockedCollateral = accrue(cTokenExchangeRate);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityTemp = supplierLiquidity; // copy to memory for gas\\n\\t\\trequire(lt_(supplierLiquidityTemp, liquidityLimit), \\\"Open paused, above liquidity limit\\\");\\n\\t\\t\\n\\t\\t(Exp memory swapFixedRate, int rateFactorNew) = getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidityTemp, cTokenExchangeRate);\\n\\t\\tCTokenAmount memory userCollateralCTokens;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trequire(swapFixedRate.mantissa <= fixedRateLimitMantissa, \\\"The fixed rate Rho would receive is above user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = add_(lockedCollateral, getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(lte_(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openPayFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\trequire(swapFixedRate.mantissa >= fixedRateLimitMantissa, \\\"The fixed rate Rho would pay is below user's limit\\\");\\n\\t\\t\\tCTokenAmount memory lockedCollateralHypothetical = add_(lockedCollateral, getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t\\trequire(lte_(lockedCollateralHypothetical, supplierLiquidityTemp), \\\"Insufficient protocol collateral\\\");\\n\\t\\t\\tuserCollateralCTokens = openReceiveFixedSwapInternal(notionalAmount, swapFixedRate, cTokenExchangeRate);\\n\\t\\t}\\n\\n\\t\\tswapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t));\\n\\n\\t\\trequire(swaps[swapHash] == false, \\\"Duplicate swap\\\");\\n\\n\\t\\temit OpenSwap(\\n\\t\\t\\tswapHash,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexStored.mantissa,\\n\\t\\t\\tgetBlockNumber(),\\n\\t\\t\\tswapFixedRate.mantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens.val,\\n\\t\\t\\tmsg.sender\\n\\t\\t);\\n\\n\\t\\tswaps[swapHash] = true;\\n\\t\\trateFactor = rateFactorNew;\\n\\t\\ttransferIn(msg.sender, userCollateralCTokens);\\n\\t}\\n\\n\\n\\t// @dev User is paying fixed, protocol is receiving fixed\\n\\tfunction openPayFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalReceivingFixedNew = add_(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = add_(notionalPayingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksReceivingFixedNew = add_(parBlocksReceivingFixed, mul_(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRateReceivingNew = (avgFixedRateReceiving * notionalReceivingFixed + notionalAmount * swapFixedRate) / (notionalReceivingFixed + notionalAmount);*/\\n\\t\\tExp memory priorFixedReceivingRate = mul_(avgFixedRateReceiving, notionalReceivingFixed);\\n\\t\\tExp memory orderFixedReceivingRate = mul_(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRateReceivingNew = div_(add_(priorFixedReceivingRate, orderFixedReceivingRate), notionalReceivingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t// @dev User is receiving fixed, protocol is paying fixed\\n\\tfunction openReceiveFixedSwapInternal(uint notionalAmount, Exp memory swapFixedRate, Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory userCollateralCTokens) {\\n\\t\\tuint notionalPayingFixedNew = add_(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = add_(notionalReceivingFloat, notionalAmount);\\n\\n\\t\\tint parBlocksPayingFixedNew = add_(parBlocksPayingFixed, mul_(SWAP_MIN_DURATION, notionalAmount));\\n\\n\\t\\t/* avgFixedRatePayingNew = (avgFixedRatePaying * notionalPayingFixed + notionalAmount * swapFixedRate) / (notionalPayingFixed + notionalAmount) */\\n\\t\\tExp memory priorFixedPayingRate = mul_(avgFixedRatePaying, notionalPayingFixed);\\n\\t\\tExp memory orderFixedPayingRate = mul_(swapFixedRate, notionalAmount);\\n\\t\\tExp memory avgFixedRatePayingNew = div_(add_(priorFixedPayingRate, orderFixedPayingRate), notionalPayingFixedNew);\\n\\n\\t\\tuserCollateralCTokens = getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\n\\t\\treturn userCollateralCTokens;\\n\\t}\\n\\n\\t/* @dev Closes an existing swap, after the min swap duration. Float payment continues even if closed late.\\n\\t * Takes params from Open event.\\n\\t * Take caution not to unecessarily revert due to underflow / overflow, as uncloseable swaps are very dangerous.\\n\\t */\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) public override {\\n\\t\\tExp memory cTokenExchangeRate = getExchangeRate();\\n\\t\\taccrue(cTokenExchangeRate);\\n\\t\\tbytes32 swapHash = keccak256(abi.encode(\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\tbenchmarkIndexInit,\\n\\t\\t\\tinitBlock,\\n\\t\\t\\tswapFixedRateMantissa,\\n\\t\\t\\tnotionalAmount,\\n\\t\\t\\tuserCollateralCTokens,\\n\\t\\t\\towner\\n\\t\\t));\\n\\t\\trequire(swaps[swapHash] == true, \\\"No active swap found\\\");\\n\\t\\tuint swapDuration = sub_(getBlockNumber(), initBlock);\\n\\t\\trequire(swapDuration >= SWAP_MIN_DURATION, \\\"Premature close swap\\\");\\n\\t\\tExp memory benchmarkIndexRatio = div_(benchmarkIndexStored, toExp_(benchmarkIndexInit));\\n\\n\\t\\tCTokenAmount memory userCollateral = CTokenAmount({val: userCollateralCTokens});\\n\\t\\tExp memory swapFixedRate = toExp_(swapFixedRateMantissa);\\n\\n\\t\\tCTokenAmount memory userPayout;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserPayout = closePayFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tuserPayout = closeReceiveFixedSwapInternal(\\n\\t\\t\\t\\tswapDuration,\\n\\t\\t\\t\\tbenchmarkIndexRatio,\\n\\t\\t\\t\\tswapFixedRate,\\n\\t\\t\\t\\tnotionalAmount,\\n\\t\\t\\t\\tuserCollateral,\\n\\t\\t\\t\\tcTokenExchangeRate\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tuint bal = cToken.balanceOf(address(this));\\n\\n\\t\\t// Payout is capped by total balance\\n\\t\\tif (userPayout.val > bal) userPayout = CTokenAmount({val: bal});\\n\\n\\t\\tuint lateBlocks = sub_(swapDuration, SWAP_MIN_DURATION);\\n\\t\\tCTokenAmount memory penalty = CTokenAmount(0);\\n\\n\\t\\tif (lateBlocks > CLOSE_GRACE_PERIOD_BLOCKS) {\\n\\t\\t\\tuint penaltyBlocks = lateBlocks - CLOSE_GRACE_PERIOD_BLOCKS;\\n\\t\\t\\tExp memory penaltyPercent = mul_(toExp_(CLOSE_PENALTY_PER_BLOCK_MANTISSA), penaltyBlocks);\\n\\t\\t\\tpenaltyPercent = ONE_EXP.mantissa > penaltyPercent.mantissa ? penaltyPercent : ONE_EXP; // maximum of 100% penalty\\n\\t\\t\\tpenalty = CTokenAmount(mul_(userPayout.val, penaltyPercent));\\n\\t\\t\\tuserPayout = sub_(userPayout, penalty);\\n\\t\\t}\\n\\n\\t\\temit CloseSwap(swapHash, owner, userPayout.val, penalty.val, benchmarkIndexStored.mantissa);\\n\\n\\t\\tswaps[swapHash] = false;\\n\\t\\ttransferOut(owner, userPayout);\\n\\t\\ttransferOut(msg.sender, penalty);\\n\\t}\\n\\n\\t// @dev User paid fixed, protocol paid fixed\\n\\tfunction closePayFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalReceivingFixedNew = subToZero_(notionalReceivingFixed, notionalAmount);\\n\\t\\tuint notionalPayingFloatNew = subToZero_(notionalPayingFloat, mul_(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRateReceiving = avgFixedRateReceiving * notionalReceivingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRateReceivingNew;\\n\\t\\tif (notionalReceivingFixedNew == 0){\\n\\t\\t\\tavgFixedRateReceivingNew = toExp_(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = subToZero_(mul_(avgFixedRateReceiving, notionalReceivingFixed), mul_(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRateReceivingNew = div_(numerator, notionalReceivingFixedNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksReceivingFixedNew = add_(parBlocksReceivingFixed, mul_(notionalAmount, sub_(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(mul_(mul_(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(mul_(notionalAmount, sub_(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = subToZero_(add_(userCollateral, floatLeg), fixedLeg); // no underflows\\n\\n\\t\\tnotionalReceivingFixed = notionalReceivingFixedNew;\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\t\\tavgFixedRateReceiving = avgFixedRateReceivingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t// @dev User received fixed, protocol paid fixed\\n\\tfunction closeReceiveFixedSwapInternal(\\n\\t\\tuint swapDuration,\\n\\t\\tExp memory benchmarkIndexRatio,\\n\\t\\tExp memory swapFixedRate,\\n\\t\\tuint notionalAmount,\\n\\t\\tCTokenAmount memory userCollateral,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) internal returns (CTokenAmount memory userPayout) {\\n\\t\\tuint notionalPayingFixedNew = subToZero_(notionalPayingFixed, notionalAmount);\\n\\t\\tuint notionalReceivingFloatNew = subToZero_(notionalReceivingFloat, mul_(notionalAmount, benchmarkIndexRatio));\\n\\n\\t\\t/* avgFixedRatePaying = avgFixedRatePaying * notionalPayingFixed - swapFixedRate * notionalAmount / notionalReceivingFixedNew */\\n\\t\\tExp memory avgFixedRatePayingNew;\\n\\t\\tif (notionalPayingFixedNew == 0) {\\n\\t\\t\\tavgFixedRatePayingNew = toExp_(0);\\n\\t\\t} else {\\n\\t\\t\\tExp memory numerator = subToZero_(mul_(avgFixedRatePaying, notionalPayingFixed), mul_(swapFixedRate, notionalAmount));\\n\\t\\t\\tavgFixedRatePayingNew = div_(numerator, notionalReceivingFloatNew);\\n\\t\\t}\\n\\n\\t\\t/* The protocol reserved enough collateral for this swap for SWAP_MIN_DURATION, but its has been longer.\\n\\t\\t * We have decreased lockedCollateral in `accrue` for the late blocks, meaning we decreased it by more than the \\\"open\\\" tx added to it in the first place.\\n\\t\\t */\\n\\t\\tint parBlocksPayingFixedNew = add_(parBlocksPayingFixed, mul_(notionalAmount, sub_(swapDuration, SWAP_MIN_DURATION)));\\n\\n\\t\\tCTokenAmount memory fixedLeg = toCTokens(mul_(mul_(notionalAmount, swapDuration), swapFixedRate), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory floatLeg = toCTokens(mul_(notionalAmount, sub_(benchmarkIndexRatio, ONE_EXP)), cTokenExchangeRate);\\n\\t\\tuserPayout = subToZero_(add_(userCollateral, fixedLeg), floatLeg);\\n\\n\\t\\tnotionalPayingFixed = notionalPayingFixedNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tavgFixedRatePaying = avgFixedRatePayingNew;\\n\\n\\t\\treturn userPayout;\\n\\t}\\n\\n\\t/* @dev Called internally at the beginning of external swap and liquidity provider functions.\\n\\t * WRITES TO STORAGE\\n\\t * Accounts for interest rate payments and adjust collateral requirements with the passage of time.\\n\\t * @return lockedCollateralNew : The amount of collateral the protocol needs to keep locked.\\n\\t */\\n\\tfunction accrue(Exp memory cTokenExchangeRate) internal returns (CTokenAmount memory) {\\n\\t\\trequire(getBlockNumber() >= lastAccrualBlock, \\\"Block number decreasing\\\");\\n\\t\\tuint accruedBlocks = getBlockNumber() - lastAccrualBlock;\\n\\t\\t(CTokenAmount memory lockedCollateralNew, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) = getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tif (accruedBlocks == 0) {\\n\\t\\t\\treturn lockedCollateralNew;\\n\\t\\t}\\n\\n\\t\\tExp memory benchmarkIndexNew = getBenchmarkIndex();\\n\\t\\tExp memory benchmarkIndexRatio;\\n\\t\\t\\n\\t\\t// if first tx\\n\\t\\tif (benchmarkIndexStored.mantissa == 0) {\\n\\t\\t\\tbenchmarkIndexRatio = ONE_EXP;\\n\\t\\t} else {\\n\\t\\t\\tbenchmarkIndexRatio = div_(benchmarkIndexNew, benchmarkIndexStored);\\n\\t\\t}\\n\\t\\tExp memory floatRate = sub_(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tCTokenAmount memory supplierLiquidityNew = getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\n\\t\\t// supplyIndex *= supplierLiquidityNew / supplierLiquidity\\n\\t\\tuint supplyIndexNew = supplyIndex;\\n\\t\\tif (supplierLiquidityNew.val != 0) {\\n\\t\\t\\tsupplyIndexNew = div_(mul_(supplyIndex, supplierLiquidityNew), supplierLiquidity);\\n\\t\\t}\\n\\n\\t\\tuint notionalPayingFloatNew = mul_(notionalPayingFloat, benchmarkIndexRatio);\\n\\t\\tuint notionalReceivingFloatNew = mul_(notionalReceivingFloat, benchmarkIndexRatio);\\n\\n\\t\\t/** Apply Effects **/\\n\\n\\t\\tparBlocksPayingFixed = parBlocksPayingFixedNew;\\n\\t\\tparBlocksReceivingFixed = parBlocksReceivingFixedNew;\\n\\n\\t\\tsupplierLiquidity = supplierLiquidityNew;\\n\\t\\tsupplyIndex = supplyIndexNew;\\n\\n\\t\\tnotionalPayingFloat = notionalPayingFloatNew;\\n\\t\\tnotionalReceivingFloat = notionalReceivingFloatNew;\\n\\n\\t\\tbenchmarkIndexStored = benchmarkIndexNew;\\n\\t\\tlastAccrualBlock = getBlockNumber();\\n\\n\\t\\temit Accrue(supplierLiquidityNew.val, lockedCollateralNew.val);\\n\\t\\treturn lockedCollateralNew;\\n\\t}\\n\\n\\tfunction transferIn(address from, CTokenAmount memory cTokenAmount) internal {\\n\\t\\trequire(cToken.transferFrom(from, address(this), cTokenAmount.val) == true, \\\"Transfer In Failed\\\");\\n\\t}\\n\\n\\tfunction transferOut(address to, CTokenAmount memory cTokenAmount) internal {\\n\\t\\tif (cTokenAmount.val > 0) {\\n\\t\\t\\trequire(cToken.transfer(to, cTokenAmount.val), \\\"Transfer Out failed\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t// ** PUBLIC PURE HELPERS ** //\\n\\n\\tfunction toCTokens(uint amount, Exp memory cTokenExchangeRate) public pure returns (CTokenAmount memory) {\\n\\t\\tuint cTokenAmount = div_(amount, cTokenExchangeRate);\\n\\t\\treturn CTokenAmount({val: cTokenAmount});\\n\\t}\\n\\n\\tfunction toUnderlying(CTokenAmount memory amount, Exp memory cTokenExchangeRate) public pure returns (uint) {\\n\\t\\treturn mul_(amount.val, cTokenExchangeRate);\\n\\t}\\n\\n\\t// *** PUBLIC VIEW GETTERS *** //\\n\\n\\t// @dev Calculate protocol locked collateral and parBlocks, which is a measure of the fixed rate credit/debt.\\n\\t// * Uses int to keep negatives, for correct late blocks calc when a single swap is outstanding\\n\\tfunction getLockedCollateral(uint accruedBlocks, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory lockedCollateral, int parBlocksReceivingFixedNew, int parBlocksPayingFixedNew) {\\n\\t\\tparBlocksReceivingFixedNew = sub_(parBlocksReceivingFixed, mul_(accruedBlocks, notionalReceivingFixed));\\n\\t\\tparBlocksPayingFixedNew = sub_(parBlocksPayingFixed, mul_(accruedBlocks, notionalPayingFixed));\\n\\n\\t\\t// Par blocks can be negative during the first or last ever swap, so floor them to 0\\n\\t\\tuint minFloatToReceive = mul_(toUint_(parBlocksPayingFixedNew), minFloatRate);\\n\\t\\tuint maxFloatToPay = mul_(toUint_(parBlocksReceivingFixedNew), maxFloatRate);\\n\\n\\t\\tuint fixedToReceive = mul_(toUint_(parBlocksReceivingFixedNew), avgFixedRateReceiving);\\n\\t\\tuint fixedToPay = mul_(toUint_(parBlocksPayingFixedNew), avgFixedRatePaying);\\n\\n\\t\\tuint minCredit = add_(fixedToReceive, minFloatToReceive);\\n\\t\\tuint maxDebt = add_(fixedToPay, maxFloatToPay);\\n\\n\\t\\tif (maxDebt > minCredit) {\\n\\t\\t\\tlockedCollateral = toCTokens(sub_(maxDebt, minCredit), cTokenExchangeRate);\\n\\t\\t} else {\\n\\t\\t\\tlockedCollateral = CTokenAmount({val:0});\\n\\t\\t}\\n\\t}\\n\\n\\t/* @dev Calculate protocol P/L by adding the cashflows since last accrual.\\n\\t * \\t\\tsupplierLiquidity += fixedReceived + floatReceived - fixedPaid - floatPaid\\n\\t */\\n\\tfunction getSupplierLiquidity(uint accruedBlocks, Exp memory floatRate, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory supplierLiquidityNew) {\\n\\t\\tuint floatPaid = mul_(notionalPayingFloat, floatRate);\\n\\t\\tuint floatReceived = mul_(notionalReceivingFloat, floatRate);\\n\\t\\tuint fixedPaid = mul_(accruedBlocks, mul_(notionalPayingFixed, avgFixedRatePaying));\\n\\t\\tuint fixedReceived = mul_(accruedBlocks, mul_(notionalReceivingFixed, avgFixedRateReceiving));\\n\\n\\t\\tCTokenAmount memory rec = toCTokens(add_(fixedReceived, floatReceived), cTokenExchangeRate);\\n\\t\\tCTokenAmount memory paid = toCTokens(add_(fixedPaid, floatPaid), cTokenExchangeRate);\\n\\t\\tsupplierLiquidityNew = subToZero_(add_(supplierLiquidity, rec), paid);\\n\\t}\\n\\n\\t// @dev Get the rate for incoming swaps\\n\\tfunction getSwapRate(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tCTokenAmount memory lockedCollateral,\\n\\t\\tCTokenAmount memory supplierLiquidity_,\\n\\t\\tExp memory cTokenExchangeRate\\n\\t) public view returns (Exp memory, int) {\\n\\t\\t(uint ratePerBlockMantissa, int rateFactorNew) = interestRateModel.getSwapRate(\\n\\t\\t\\trateFactor,\\n\\t\\t\\tuserPayingFixed,\\n\\t\\t\\torderNotional,\\n\\t\\t\\ttoUnderlying(lockedCollateral, cTokenExchangeRate),\\n\\t\\t\\ttoUnderlying(supplierLiquidity_, cTokenExchangeRate)\\n\\t\\t);\\n\\t\\treturn (toExp_(ratePerBlockMantissa), rateFactorNew);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the payFixed leg of a swap paying fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (swapFixedRate - minFloatRate)\\n\\tfunction getPayFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = sub_(fixedRate, minFloatRate);\\n\\t\\tuint amt = mul_(mul_(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev The amount that must be locked up for the receiveFixed leg of a swap receiving fixed. Used to calculate both the protocol and user's collateral.\\n\\t// = notionalAmount * SWAP_MIN_DURATION * (maxFloatRate - swapFixedRate)\\n\\tfunction getReceiveFixedInitCollateral(Exp memory fixedRate, uint notionalAmount, Exp memory cTokenExchangeRate) public view returns (CTokenAmount memory) {\\n\\t\\tExp memory rateDelta = sub_(maxFloatRate, fixedRate);\\n\\t\\tuint amt = mul_(mul_(SWAP_MIN_DURATION, notionalAmount), rateDelta);\\n\\t\\treturn toCTokens(amt, cTokenExchangeRate);\\n\\t}\\n\\n\\t// @dev Interpolates to get the current borrow index from a compound CToken (or some other similar interface)\\n\\tfunction getBenchmarkIndex() public view returns (Exp memory) {\\n\\t\\tExp memory borrowIndex = toExp_(cToken.borrowIndex());\\n\\t\\trequire(borrowIndex.mantissa != 0, \\\"Benchmark index is zero\\\");\\n\\t\\tuint accrualBlockNumber = cToken.accrualBlockNumber();\\n\\t\\trequire(getBlockNumber() >= accrualBlockNumber, \\\"Bn decreasing\\\");\\n\\t\\tuint blockDelta = sub_(getBlockNumber(), accrualBlockNumber);\\n\\n\\t\\tif (blockDelta == 0) {\\n\\t\\t\\treturn borrowIndex;\\n\\t\\t} else {\\n\\t\\t\\tExp memory borrowRateMantissa = toExp_(cToken.borrowRatePerBlock());\\n\\t\\t\\tExp memory simpleInterestFactor = mul_(borrowRateMantissa, blockDelta);\\n\\t\\t\\treturn mul_(borrowIndex, add_(simpleInterestFactor, ONE_EXP));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getExchangeRate() public view returns (Exp memory) {\\n\\t\\treturn toExp_(cToken.exchangeRateStored());\\n\\t}\\n\\n\\tfunction getBlockNumber() public view virtual returns (uint) {\\n\\t\\treturn block.number;\\n\\t}\\n\\n\\t/** ADMIN FUNCTIONS **/\\n\\n\\tfunction _setInterestRateModel(InterestRateModelInterface newModel) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set interest rate model\\\");\\n\\t\\trequire(newModel != interestRateModel, \\\"Resetting to same model\\\");\\n\\t\\temit SetInterestRateModel(address(newModel), address(interestRateModel));\\n\\t\\tinterestRateModel = newModel;\\n\\t}\\n\\n\\tfunction _setCollateralRequirements(uint minFloatRateMantissa_, uint maxFloatRateMantissa_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set collateral requirements\\\");\\n\\t\\trequire(minFloatRateMantissa_ < maxFloatRateMantissa_, \\\"Min float rate must be below max float rate\\\");\\n\\n\\t\\temit SetCollateralRequirements(minFloatRateMantissa_, maxFloatRateMantissa_);\\n\\t\\tminFloatRate = toExp_(minFloatRateMantissa_);\\n\\t\\tmaxFloatRate = toExp_(maxFloatRateMantissa_);\\n\\t}\\n\\n\\tfunction _setLiquidityLimit(uint limit_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to set liqiudity limit\\\");\\n\\t\\temit SetLiquidityLimit(limit_);\\n\\t\\tliquidityLimit = CTokenAmount({val: limit_});\\n\\t}\\n\\n\\tfunction _pause(bool isPaused_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to pause\\\");\\n\\t\\trequire(isPaused_ != isPaused, \\\"Must change isPaused\\\");\\n\\t\\temit SetPause(isPaused_);\\n\\t\\tisPaused = isPaused_;\\n\\t}\\n\\n\\tfunction _transferComp(address dest, uint amount) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to transfer comp\\\");\\n\\t\\temit CompTransferred(dest, amount);\\n\\t\\tcomp.transfer(dest, amount);\\n\\t}\\n\\n\\tfunction _delegateComp(address delegatee) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to delegate comp\\\");\\n\\t\\temit CompDelegated(delegatee);\\n\\t\\tcomp.delegate(delegatee);\\n\\t}\\n\\n\\tfunction _changeAdmin(address admin_) external {\\n\\t\\trequire(msg.sender == admin, \\\"Must be admin to change admin\\\");\\n\\t\\temit AdminChanged(admin, admin_);\\n\\t\\tadmin = admin_;\\n\\t}\\n\\n}\\n\",\r\n      \"keccak256\": \"0x0ea5f91eaeb14017a41a931be2bc76f29c60963f43f66c3fbbc432318127ae9b\"\r\n    },\r\n    \"contracts/RhoInterfaces.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\r\n      \"keccak256\": \"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"\r\n    },\r\n    \"contracts/RhoLens.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Rho.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/* @dev A utility view contract for front-ends to use. Not part of the protocol. */\\ncontract RhoLensV1 is Math {\\n\\n\\tRho public immutable rho;\\n\\n\\tconstructor(Rho rho_) public {\\n\\t\\trho = rho_;\\n\\t}\\n\\n\\tfunction getHypotheticalOrderInfo(bool userPayingFixed, uint notionalAmount) \\n\\t\\texternal \\n\\t\\tview \\n\\t\\treturns (\\n\\t\\t\\tuint swapFixedRateMantissa, \\n\\t\\t\\tuint userCollateralCTokens, \\n\\t\\t\\tuint userCollateralUnderlying, \\n\\t\\t\\tbool protocolIsCollateralized\\n\\t\\t)\\n\\t{\\n\\t\\t(CTokenAmount memory lockedCollateral, CTokenAmount memory supplierLiquidity, Exp memory cTokenExchangeRate) = getSupplyCollateralState();\\n\\t\\t(Exp memory swapFixedRate,) = rho.getSwapRate(userPayingFixed, notionalAmount, lockedCollateral, supplierLiquidity, cTokenExchangeRate);\\n\\t\\tprotocolIsCollateralized = true;\\n\\t\\tCTokenAmount memory userCollateral;\\n\\t\\tCTokenAmount memory lockedCollateralHypothetical;\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\tuserCollateral = rho.getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\t\\t\\tlockedCollateralHypothetical = add_(lockedCollateral, rho.getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t} else {\\n\\t\\t\\tuserCollateral = rho.getReceiveFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate);\\n\\t\\t\\tlockedCollateralHypothetical = add_(lockedCollateral, rho.getPayFixedInitCollateral(swapFixedRate, notionalAmount, cTokenExchangeRate));\\n\\t\\t}\\n\\t\\tif (supplierLiquidity.val < lockedCollateralHypothetical.val) {\\n\\t\\t\\tprotocolIsCollateralized = false;\\n\\t\\t}\\n\\t\\treturn (swapFixedRate.mantissa, userCollateral.val, toUnderlying(userCollateral.val), protocolIsCollateralized);\\n\\t}\\n\\n\\tfunction getSupplyCollateralState() \\n\\t\\tpublic \\n\\t\\tview \\n\\t\\treturns (\\n\\t\\t\\tCTokenAmount memory lockedCollateral, \\n\\t\\t\\tCTokenAmount memory supplierLiquidity, \\n\\t\\t\\tExp memory cTokenExchangeRate\\n\\t\\t) \\n\\t{\\n\\t\\tcTokenExchangeRate = rho.getExchangeRate();\\n\\n\\t\\tuint accruedBlocks = rho.getBlockNumber() - rho.lastAccrualBlock();\\n\\t\\t(lockedCollateral,,) = rho.getLockedCollateral(accruedBlocks, cTokenExchangeRate);\\n\\n\\t\\tExp memory benchmarkIndexRatio = div_(rho.getBenchmarkIndex(), toExp_(rho.benchmarkIndexStored()));\\n\\t\\tExp memory floatRate = sub_(benchmarkIndexRatio, ONE_EXP);\\n\\n\\t\\tsupplierLiquidity = rho.getSupplierLiquidity(accruedBlocks, floatRate, cTokenExchangeRate);\\n\\t}\\n\\n\\tfunction getMarkets() \\n\\t\\tpublic \\n\\t\\tview \\n\\t\\treturns (\\n\\t\\t\\tuint notionalReceivingFixed,\\n\\t\\t\\tuint notionalPayingFixed,\\n\\t\\t\\tuint avgFixedRateReceiving,\\n\\t\\t\\tuint avgFixedRatePaying\\n\\t\\t) \\n\\t{\\n\\t\\treturn (rho.notionalReceivingFixed(), rho.notionalPayingFixed(), rho.avgFixedRateReceiving(), rho.avgFixedRatePaying());\\n\\t}\\n\\n\\tfunction toUnderlying(uint cTokenAmt) public view returns (uint underlyingAmount) {\\n\\t\\tExp memory rate = rho.getExchangeRate();\\n\\t\\tCTokenAmount memory amount = CTokenAmount({val: cTokenAmt});\\n\\t\\treturn rho.toUnderlying(amount, rate);\\n\\t}\\n\\n\\tfunction toCTokens(uint underlyingAmount) public view returns (uint cTokenAmount) {\\n\\t\\tExp memory rate = rho.getExchangeRate();\\n\\t\\tCTokenAmount memory amount = rho.toCTokens(underlyingAmount, rate);\\n\\t\\treturn amount.val;\\n\\t}\\n\\n}\\n\",\r\n      \"keccak256\": \"0x097d0c61d1c6e18fe7f21aeca22349f2eec77f94a17bd13e2412fd30467429c6\"\r\n    },\r\n    \"contracts/Types.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Rho\",\"name\":\"rho_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"notionalAmount\",\"type\":\"uint256\"}],\"name\":\"getHypotheticalOrderInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFixedRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralCTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"protocolIsCollateralized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarkets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalReceivingFixed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notionalPayingFixed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgFixedRateReceiving\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgFixedRatePaying\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupplyCollateralState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.CTokenAmount\",\"name\":\"supplierLiquidity\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Exp\",\"name\":\"cTokenExchangeRate\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rho\",\"outputs\":[{\"internalType\":\"contract Rho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"toCTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmt\",\"type\":\"uint256\"}],\"name\":\"toUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RhoLensV1","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000645bea4134c5e4294eb6b5278ce27ac4c47f3b77","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}