{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"temp-contracts/meta/MetaGovernorCOMP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @title MetaGovernorCOMP\\n * @dev Meta-governance contract for Compound's GovernorAlpha.\\n *\\n * This contract enables NDX holders to vote, by simple majority, on how to cast\\n * votes for Compound governance proposals.\\n *\\n * Each Compound proposal is wrapped as a meta proposal, which has an endBlock which\\n * ends some number of blocks prior to the end of the real proposal in order to give\\n * NDX holders time to cast meta votes prior to casting votes for the entire dao.\\n *\\n * This contract counts voting power from users the same way as the typical GovernorAlpha,\\n * which is to call getPriorVotes to check the delegation a voting account held at the time\\n * the external proposal began.\\n *\\n * Once a meta proposal has ended, it may be executed to cast votes on Compound. If the proposal\\n * has more votes in favor than against, it will cast votes supporting the proposal. Otherwise,\\n * it will cast votes against the proposal.\\n *\\n * This contract may not be used to submit proposals to Compound, only to vote on them.\\n */\\ncontract MetaGovernorCOMP {\\n  /** @dev The name of this contract */\\n  string public constant name = \\\"Indexed COMP Meta Governor\\\";\\n\\n  /**\\n   * @dev The number of blocks subtracted from the endBlock of an external\\n   * proposal to set the end block of a meta proposal.\\n   */\\n  uint32 public immutable votingGracePeriod;\\n\\n  /** @dev The address of the Indexed governance token */\\n  NdxInterface public immutable ndx;\\n\\n\\n  /** @dev The address of the COMP GovernorAlpha */\\n  IGovernorAlpha public immutable compGovernor;\\n\\n  /**\\n   * @param startBlock The block at which voting begins: holders must delegate their votes prior to this block\\n   * @param endBlock The block at which voting ends: votes must be cast prior to this block\\n   * @param forVotes Current number of votes in favor of this proposal\\n   * @param againstVotes Current number of votes in opposition to this proposal\\n   * @param voteSubmitted Flag marking whether the vote has been cast on the external governor\\n   * @param receipts Receipts of ballots for the entire set of voters\\n   */\\n  struct MetaProposal {\\n    uint32 startBlock;\\n    uint32 endBlock;\\n    uint96 forVotes;\\n    uint96 againstVotes;\\n    bool voteSubmitted;\\n    mapping(address => Receipt) receipts;\\n  }\\n\\n  /**\\n   * @dev Possible states that a meta proposal may be in\\n   */\\n  enum MetaProposalState {\\n    Active,\\n    Defeated,\\n    Succeeded,\\n    Executed\\n  }\\n\\n  mapping(uint256 => MetaProposal) public proposals;\\n\\n  /**\\n   * @dev Ballot receipt record for a voter\\n   * @param hasVoted Whether or not a vote has been cast\\n   * @param support Whether or not the voter supports the proposal\\n   * @param votes The number of votes the voter had, which were cast\\n   */\\n  struct Receipt {\\n    bool hasVoted;\\n    bool support;\\n    uint96 votes;\\n  }\\n\\n  /**\\n   * @dev An event emitted when a vote has been cast on a proposal\\n   */\\n  event MetaVoteCast(\\n    address voter,\\n    uint256 proposalId,\\n    bool support,\\n    uint256 votes\\n  );\\n\\n  event ExternalVoteSubmitted(\\n    uint256 proposalId,\\n    bool support\\n  );\\n\\n  constructor(address ndx_, address compGovernor_, uint32 votingGracePeriod_) public {\\n    ndx = NdxInterface(ndx_);\\n    compGovernor = IGovernorAlpha(compGovernor_);\\n    votingGracePeriod = votingGracePeriod_;\\n  }\\n\\n  function getReceipt(uint256 proposalId, address voter)\\n    external\\n    view\\n    returns (Receipt memory)\\n  {\\n    return proposals[proposalId].receipts[voter];\\n  }\\n\\n  function submitExternalVote(uint256 proposalId) external {\\n    MetaProposal storage proposal = proposals[proposalId];\\n    MetaProposalState state = _state(proposal);\\n    require(\\n      state == MetaProposalState.Succeeded || state == MetaProposalState.Defeated,\\n      \\\"MetaGovernorCOMP::submitExternalVote: proposal must be in Succeeded or Defeated state to execute\\\"\\n    );\\n    proposal.voteSubmitted = true;\\n    bool support = state == MetaProposalState.Succeeded;\\n    compGovernor.castVote(proposalId, support);\\n    emit ExternalVoteSubmitted(proposalId, support);\\n  }\\n\\n  function _getMetaProposal(uint256 proposalId) internal returns (MetaProposal storage) {\\n    // Get the meta proposal if it exists, else initialize the block fields using the external proposal.\\n    MetaProposal storage proposal = proposals[proposalId];\\n    if (proposal.startBlock == 0) {\\n      IGovernorAlpha.Proposal memory externalProposal = compGovernor.proposals(proposalId);\\n      proposal.startBlock = safe32(externalProposal.startBlock);\\n      proposal.endBlock = sub32(safe32(externalProposal.endBlock), votingGracePeriod);\\n    }\\n    return proposal;\\n  }\\n\\n  function castVote(uint256 proposalId, bool support) external {\\n    MetaProposal storage proposal = _getMetaProposal(proposalId);\\n    require(\\n      _state(proposal) == MetaProposalState.Active,\\n      \\\"MetaGovernorCOMP::_castVote: meta proposal not active\\\"\\n    );\\n    Receipt storage receipt = proposal.receipts[msg.sender];\\n    require(\\n      receipt.hasVoted == false,\\n      \\\"MetaGovernorCOMP::_castVote: voter already voted\\\"\\n    );\\n    uint96 votes = ndx.getPriorVotes(msg.sender, proposal.startBlock);\\n    require(\\n      votes > 0,\\n      \\\"MetaGovernorCOMP::_castVote: caller has no delegated NDX\\\"\\n    );\\n\\n    if (support) {\\n      proposal.forVotes = add96(proposal.forVotes, votes);\\n    } else {\\n      proposal.againstVotes = add96(proposal.againstVotes, votes);\\n    }\\n\\n    receipt.hasVoted = true;\\n    receipt.support = support;\\n    receipt.votes = votes;\\n\\n    emit MetaVoteCast(msg.sender, proposalId, support, votes);\\n  }\\n\\n  function state(uint256 proposalId) external view returns (MetaProposalState) {\\n    MetaProposal storage proposal = proposals[proposalId];\\n    return _state(proposal);\\n  }\\n\\n  function _state(MetaProposal storage proposal) internal view returns (MetaProposalState) {\\n    require(\\n      proposal.startBlock != 0 && block.number > proposal.startBlock,\\n      \\\"MetaGovernorCOMP::_state: meta proposal does not exist or is not ready\\\"\\n    );\\n    if (block.number <= proposal.endBlock) {\\n      return MetaProposalState.Active;\\n    } else if (proposal.voteSubmitted) {\\n      return MetaProposalState.Executed;\\n    } else if (proposal.forVotes > proposal.againstVotes) {\\n      return MetaProposalState.Succeeded;\\n    }\\n    return MetaProposalState.Defeated;\\n  }\\n\\n  function add96(uint96 a, uint96 b) internal pure returns (uint96) {\\n    uint96 c = a + b;\\n    require(c >= a, \\\"addition overflow\\\");\\n    return c;\\n  }\\n\\n  function safe32(uint256 a) internal pure returns (uint32) {\\n    require(a <= uint32(-1), \\\"uint32 overflow\\\");\\n    return uint32(a);\\n  }\\n\\n  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\\n    require(b <= a, \\\"subtraction underflow\\\");\\n    return a - b;\\n  }\\n}\\n\\n\\ninterface IGovernorAlpha {\\n  struct Proposal {\\n    uint256 id;\\n    address proposer;\\n    uint256 eta;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool canceled;\\n    bool executed;\\n  }\\n\\n  function proposals(uint256 proposalId) external view returns (Proposal memory);\\n\\n  function castVote(uint256 proposalId, bool support) external;\\n}\\n\\n\\ninterface NdxInterface {\\n  function getPriorVotes(address account, uint256 blockNumber)\\n    external\\n    view\\n    returns (uint96);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ndx_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compGovernor_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"votingGracePeriod_\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"ExternalVoteSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"MetaVoteCast\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compGovernor\",\"outputs\":[{\"internalType\":\"contract IGovernorAlpha\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"internalType\":\"struct MetaGovernorCOMP.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ndx\",\"outputs\":[{\"internalType\":\"contract NdxInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"forVotes\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"againstVotes\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"voteSubmitted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum MetaGovernorCOMP.MetaProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"submitExternalVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingGracePeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MetaGovernorCOMP","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000086772b1409b61c639eaac9ba0acfbb6e238e5f83000000000000000000000000c0da01a04c3f3e0be433606045bb7017a7323e3800000000000000000000000000000000000000000000000000000000000005a0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}