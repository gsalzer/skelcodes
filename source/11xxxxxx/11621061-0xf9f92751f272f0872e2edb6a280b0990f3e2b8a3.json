{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: MIT\\r\\n*\\r\\n* Copyright (c) 2016-2019 zOS Global Limited\\r\\n*\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see `ERC20Detailed`.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    // Optional functions\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when `approve` or `transferFrom` are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to `approve`. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Offer.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Acquisition Attempt\\r\\n * @author Luzius Meisser, luzius@aktionariat.com\\r\\n */\\r\\n\\r\\ncontract Offer {\\r\\n\\r\\n    uint256 public quorum;                              // Percentage of votes needed to start drag-along process\\r\\n\\r\\n    address public token;\\r\\n    address public buyer;                               // who made the offer\\r\\n    \\r\\n    address public currency;\\r\\n    uint256 public price;                               // the price offered per share\\r\\n\\r\\n    enum Vote { NONE, YES, NO }                         // Used internally, represents not voted yet or yes/no vote.\\r\\n    mapping (address =\\u003e Vote) private votes;            // Who votes what\\r\\n    uint256 public noVotes;                             // number of tokens voting for no\\r\\n    uint256 public yesVotes;                            // number of tokens voting for yes\\r\\n    uint256 public voteEnd;\\r\\n\\r\\n    event VotesChanged(uint256 newYesVotes, uint256 newNoVotes);\\r\\n    event OfferCreated(address indexed buyer, address token, uint256 pricePerShare, address currency);\\r\\n    event OfferEnded(address indexed buyer, bool success, string message);\\r\\n\\r\\n    constructor (address buyer_, address token_, uint256 price_, address currency_, uint256 quorum_, uint256 votePeriod) payable {\\r\\n        buyer = buyer_;\\r\\n        token = token_;\\r\\n        currency = currency_;\\r\\n        price = price_;\\r\\n        quorum = quorum_;\\r\\n        voteEnd = block.timestamp + votePeriod;\\r\\n        // License Fee to Aktionariat AG, also ensures that offer is serious.\\r\\n        // Any circumvention of this license fee payment is a violation of the copyright terms.\\r\\n        payable(0x29Fe8914e76da5cE2d90De98a64d0055f199d06D).transfer(3 ether);\\r\\n        emit OfferCreated(buyer, token, price, currency);\\r\\n    }\\r\\n\\r\\n    function contest(address betterOffer) public {\\r\\n        require(msg.sender == token);\\r\\n        Offer better = Offer(betterOffer);\\r\\n        require(currency == better.currency() \\u0026\\u0026 better.price() \\u003e price, \\\"New offer must be better\\\");\\r\\n        kill(false, \\\"replaced\\\");\\r\\n    }\\r\\n\\r\\n    function hasExpired() internal view returns (bool) {\\r\\n        return block.timestamp \\u003e voteEnd + 3 days; // buyer has three days to complete acquisition after voting ends\\r\\n    }\\r\\n\\r\\n    function contest() public {\\r\\n        if (hasExpired()) {\\r\\n            kill(false, \\\"expired\\\");\\r\\n        } else if (isDeclined()) {\\r\\n            kill(false, \\\"declined\\\");\\r\\n        } else if (!isWellFunded()) {\\r\\n            kill(false, \\\"lack of funds\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function cancel() public {\\r\\n        require(msg.sender == buyer);\\r\\n        kill(false, \\\"cancelled\\\");\\r\\n    }\\r\\n\\r\\n    function execute() public {\\r\\n        require(isAccepted(), \\\"not accepted\\\");\\r\\n        uint256 totalPrice = getTotalPrice();\\r\\n        require(IERC20(currency).transferFrom(buyer, token, totalPrice));\\r\\n        IDraggable(token).drag(buyer, currency);\\r\\n        kill(true, \\\"success\\\");\\r\\n    }\\r\\n\\r\\n    function getTotalPrice() internal view returns (uint256) {\\r\\n        IERC20 tok = IERC20(token);\\r\\n        return (tok.totalSupply() - tok.balanceOf(buyer)) * price;\\r\\n    }\\r\\n\\r\\n    function isWellFunded() public view returns (bool) {\\r\\n        IERC20 cur = IERC20(currency);\\r\\n        uint256 buyerBalance = cur.balanceOf(buyer);\\r\\n        uint256 buyerAllowance = cur.allowance(buyer, address(this));\\r\\n        uint256 totalPrice = getTotalPrice();\\r\\n        return totalPrice \\u003c= buyerBalance \\u0026\\u0026 totalPrice \\u003c= buyerAllowance;\\r\\n    }\\r\\n\\r\\n    function isAccepted() public view returns (bool) {\\r\\n        if (isVotingOpen()) {\\r\\n            // is it already clear that 75% will vote yes even though the vote is not over yet?\\r\\n            return yesVotes * 10000  \\u003e= quorum * IERC20(token).totalSupply();\\r\\n        } else {\\r\\n            // did 75% of all cast votes say \\u0027yes\\u0027?\\r\\n            return yesVotes * 10000 \\u003e= quorum * (yesVotes + noVotes);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isDeclined() public view returns (bool) {\\r\\n        if (isVotingOpen()) {\\r\\n            // is it already clear that 25% will vote no even though the vote is not over yet?\\r\\n            return (IERC20(token).totalSupply() - noVotes) * 10000 \\u003c quorum * IERC20(token).totalSupply();\\r\\n        } else {\\r\\n            // did quorum% of all cast votes say \\u0027no\\u0027?\\r\\n            return 10000 * yesVotes \\u003c quorum * (yesVotes + noVotes);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyMoved(address from, address to, uint256 value) public {\\r\\n        require(msg.sender == token);\\r\\n        if (isVotingOpen()) {\\r\\n            Vote fromVoting = votes[from];\\r\\n            Vote toVoting = votes[to];\\r\\n            update(fromVoting, toVoting, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function update(Vote previousVote, Vote newVote, uint256 votes_) internal {\\r\\n        if (previousVote != newVote) {\\r\\n            if (previousVote == Vote.NO) {\\r\\n                noVotes = noVotes - votes_;\\r\\n            } else if (previousVote == Vote.YES) {\\r\\n                yesVotes = yesVotes - votes_;\\r\\n            }\\r\\n            if (newVote == Vote.NO) {\\r\\n                noVotes = noVotes + votes_;\\r\\n            } else if (newVote == Vote.YES) {\\r\\n                yesVotes = yesVotes + votes_;\\r\\n            }\\r\\n            emit VotesChanged(yesVotes, noVotes);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isVotingOpen() public view returns (bool) {\\r\\n        return block.timestamp \\u003c= voteEnd;\\r\\n    }\\r\\n\\r\\n    modifier votingOpen() {\\r\\n        require(isVotingOpen(), \\\"vote ended\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function voteYes() public {\\r\\n        vote(Vote.YES);\\r\\n    }\\r\\n\\r\\n    function voteNo() public { \\r\\n        vote(Vote.NO);\\r\\n    }\\r\\n\\r\\n    function vote(Vote newVote) internal votingOpen() {\\r\\n        Vote previousVote = votes[msg.sender];\\r\\n        votes[msg.sender] = newVote;\\r\\n        update(previousVote, newVote, IERC20(token).balanceOf(msg.sender));\\r\\n    }\\r\\n\\r\\n    function hasVotedYes(address voter) public view returns (bool) {\\r\\n        return votes[voter] == Vote.YES;\\r\\n    }\\r\\n\\r\\n    function hasVotedNo(address voter) public view returns (bool) {\\r\\n        return votes[voter] == Vote.NO;\\r\\n    }\\r\\n\\r\\n    function kill(bool success, string memory message) internal {\\r\\n        IDraggable(token).notifyOfferEnded();\\r\\n        emit OfferEnded(buyer, success, message);\\r\\n        selfdestruct(payable(buyer));\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nabstract contract IDraggable {\\r\\n\\r\\n    function drag(address buyer, address currency) public virtual;\\r\\n    function notifyOfferEnded() public virtual;\\r\\n\\r\\n}\"},\"OfferFactory.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./Offer.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title CompanyName Shareholder Agreement\\r\\n * @author Luzius Meisser, luzius@aktionariat.com\\r\\n * @dev These tokens are based on the ERC20 standard and the open-zeppelin library.\\r\\n *\\r\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\r\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027\\r\\n * of the \\u0027DraggableCompanyNameShares\\u0027 contract. The agreement is partially enforced\\r\\n * through the Swiss legal system, and partially enforced through this smart contract.\\r\\n * In particular, this smart contract implements a drag-along clause which allows the\\r\\n * majority of token holders to force the minority sell their shares along with them in\\r\\n * case of an acquisition. That\\u0027s why the tokens are called \\\"Draggable CompanyName AG Shares.\\\"\\r\\n */\\r\\n\\r\\ncontract OfferFactory {\\r\\n\\r\\n    function predict(bytes32 salt, address buyer, address token, uint256 pricePerShare, address currency, uint256 quorum, uint256 votePeriod) public view returns (address) {\\r\\n        bytes32 initCodeHash = keccak256(abi.encodePacked(type(Offer).creationCode, abi.encode(buyer, token, pricePerShare, currency, quorum, votePeriod)));\\r\\n        bytes32 hashResult = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash));\\r\\n        return address(uint160(uint256(hashResult)));\\r\\n    }\\r\\n\\r\\n    // Do not call directly, msg.sender must be the token to be acquired\\r\\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, address currency, uint256 quorum, uint256 votePeriod) public payable returns (address) {\\r\\n        Offer offer = new Offer{value: msg.value, salt: salt}(buyer, msg.sender, pricePerShare, currency, quorum, votePeriod);\\r\\n        return address(offer);\\r\\n    }\\r\\n\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votePeriod\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votePeriod\",\"type\":\"uint256\"}],\"name\":\"predict\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OfferFactory","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://91abb0d70ecde949f455e14f0aee688a5dbb4cecc70d7e1d8d0e7ca5a85daf92"}]}