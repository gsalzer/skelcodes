{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.23 <0.6.0;\r\n\r\n\r\ninterface UmiTokenInterface{\r\n    function putIntoBlacklist(address _addr) external ;\r\n    function removeFromBlacklist(address _addr) external ;\r\n    function inBlacklist(address _addr)external view returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool) ;\r\n    function mint(address account, uint256 amount) external  returns (bool) ;\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ncontract UniSage {\r\n    \r\n    struct User {\r\n        address referrer;\r\n        uint partnersCount;\r\n        \r\n        mapping(uint8 => bool) activeLevels;\r\n        \r\n        mapping(uint8 => MA) matrix;\r\n      \r\n    }\r\n    \r\n    struct MA {\r\n        address currentReferrer;\r\n        address[] x3referrals;\r\n        address[] x2referrals;\r\n        bool blocked;\r\n        uint x2ReinvestCount;\r\n        uint x3ReinvestCount;\r\n    }\r\n    \r\n    \r\n    uint8 public constant LAST_LEVEL = 10;\r\n    \r\n    mapping(address => User) public users;\r\n\r\n    mapping(address=>bool) public addrRegisted;\r\n    address public starNode;\r\n    \r\n    address owner;\r\n    \r\n    address truncateNode;\r\n    \r\n    bool public airdropPhase=true;\r\n    bool public openAirdrop=true;\r\n    \r\n    mapping(uint8 => uint) public levelPrice;\r\n    \r\n    address public umiTokenAddr=0x5284d793542815354b9604f06Df14f157BE90462;\r\n    UmiTokenInterface public umiToken = UmiTokenInterface(umiTokenAddr);\r\n    \r\n    bool public open=true;\r\n    uint256 public maxAirdropAmount=500000000000000000000000;\r\n    uint256 public hasAirdropAmount=0;\r\n    uint256 public perAirdrop=50000000000000000000;\r\n    uint256 public perAirdropForReferrer=5000000000000000000;\r\n    uint256 public startLiquiRate=100;\r\n    uint256 public mineRate=1000;\r\n    bool public openAMM=true;\r\n    \r\n    \r\n    address payable uniswapToAddr;\r\n    address payable public uniswapAddr;\r\n    IUniswapV2Router01 public uniswap;    \r\n    \r\n    \r\n    mapping(address=>mapping(uint=>mapping(uint=>uint256))) public matrixLevelReward;\r\n    \r\n    mapping(address=>mapping(uint=>uint256)) public matrixReward;\r\n    \r\n    mapping(address=>mapping(uint=>uint256)) public addressLevelMine;\r\n    mapping(address=>uint256) public addressMine;\r\n    \r\n    uint256 public globalMine=0;\r\n    uint256 public globalInvest=0;\r\n    \r\n    event Registration(address indexed user, address indexed referrer, address indexed userAddr, address referrerAddr);\r\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\r\n    event BurnOut(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\r\n    \r\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);\r\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place);\r\n    event MissedEthReceive(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\r\n    event SentExtraEthDividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\r\n    \r\n    \r\n    constructor(address starNodeAddress) public {\r\n        \r\n        levelPrice[1] = 0.05 ether;\r\n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\r\n            levelPrice[i] = levelPrice[i-1] * 2;\r\n        }\r\n        starNode = starNodeAddress;\r\n        truncateNode = starNodeAddress;\r\n        owner=msg.sender;\r\n        \r\n        User memory user = User({\r\n            // id: 1,\r\n            referrer: address(0),\r\n            partnersCount: uint(0)\r\n        });\r\n        \r\n        users[starNodeAddress] = user;\r\n        \r\n        // idToAddress[1] = starNodeAddress;\r\n        \r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[starNodeAddress].activeLevels[i] = true;\r\n        }\r\n        \r\n        // userIds[1] = starNodeAddress;\r\n        addrRegisted[starNodeAddress]=true;\r\n        uniswapAddr=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        uniswap = IUniswapV2Router01(uniswapAddr);\r\n        uniswapToAddr = 0xcD3f2DB9551e83161a0031F8A9272a0b4795E40E;  \r\n        \r\n        \r\n        //approve enough umi to uniswap\r\n        _increaseApprove(999999999999000000000000000000);        \r\n    }\r\n    \r\n    function() external payable {\r\n        \r\n        // require(!airdropPhase,\"can not regist in airdropPhase!\");\r\n        // require(msg.value == 0.1 ether, \"registration cost 0.1\");\r\n        // if(msg.data.length == 0) {\r\n        //     return registration(msg.sender, starNode,false);\r\n        // }\r\n        \r\n        // registration(msg.sender, bytesToAddress(msg.data),false);\r\n    }\r\n\r\n    function registrationExt(address referrerAddress) external payable {\r\n        require(!airdropPhase,\"can not regist in airdropPhase!\");\r\n        require(msg.value == 0.05 ether, \"registration cost 0.05\");\r\n        registration(msg.sender, referrerAddress,false);\r\n    }\r\n    \r\n\r\n    function registrationForAirdrop(address referrerAddress) external{\r\n        require(airdropPhase,\"can not get airdrop in not airdropPhase!\");\r\n        require(hasAirdropAmount+perAirdrop+perAirdropForReferrer<=maxAirdropAmount,\"hasAirdropAmount+perAirdrop+perAirdropForReferrer>maxAirdropAmount\");\r\n        registration(msg.sender, referrerAddress,true);\r\n        hasAirdropAmount=hasAirdropAmount+perAirdrop+perAirdropForReferrer;\r\n    }\r\n    \r\n    function registration(address userAddress, address referrerAddress,bool fromAirdrop) private {\r\n        require(open,\"has not open!\");\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        require(size == 0, \"cannot be a contract\");\r\n        \r\n        User memory user = User({\r\n            // id: lastUserId,\r\n            referrer: referrerAddress,\r\n            partnersCount: 0\r\n        });\r\n        \r\n        users[userAddress] = user;\r\n        // idToAddress[lastUserId] = userAddress;\r\n        \r\n        users[userAddress].referrer = referrerAddress;\r\n        \r\n        \r\n        \r\n        // userIds[lastUserId] = userAddress;\r\n        // lastUserId++;\r\n        \r\n        users[referrerAddress].partnersCount++;        \r\n        if(fromAirdrop){\r\n            if(openAirdrop){\r\n                umiToken.mint(userAddress,perAirdrop);\r\n                umiToken.putIntoBlacklist(userAddress);\r\n                umiToken.mint(referrerAddress,perAirdropForReferrer);               \r\n            }\r\n        } else{\r\n            address activedReferrer = findActivedReferrer(userAddress, 1);\r\n            users[userAddress].matrix[1].currentReferrer = activedReferrer;\r\n            users[userAddress].activeLevels[1] = true;\r\n            updateMatrixReferrer(userAddress, activedReferrer, 1);\r\n            \r\n        }\r\n        addrRegisted[userAddress]=true;\r\n        globalInvest=globalInvest+msg.value;\r\n        emit Registration(userAddress, referrerAddress, userAddress, referrerAddress);\r\n    }\r\n    \r\n    function updateMatrixReferrer(address userAddress, address referrerAddress, uint8 level) private {\r\n        users[referrerAddress].matrix[level].x3referrals.push(userAddress);\r\n\r\n        if (users[referrerAddress].matrix[level].x3referrals.length == 1||referrerAddress == starNode) {\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, 1);\r\n            return sendETHDividends(referrerAddress, userAddress, 1, level,levelPrice[level]);\r\n        }else if(users[referrerAddress].matrix[level].x3referrals.length == 2){\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, 2);\r\n            //1/2 ether to x2\r\n            uint256 x3Reward=levelPrice[level]/2;\r\n            sendETHDividends(referrerAddress, userAddress, 1, level,x3Reward);\r\n            address activedReferrerAddress = findActivedReferrer(referrerAddress, level);           \r\n            updateMatrixM2Referrer(referrerAddress,activedReferrerAddress,level,(levelPrice[level]-x3Reward));  \r\n            \r\n        }else if(users[referrerAddress].matrix[level].x3referrals.length == 3){\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, 3);\r\n               //close matrix\r\n            users[referrerAddress].matrix[level].x3referrals = new address[](0);\r\n\r\n            \r\n            uint256 x3Reward=levelPrice[level]/2;\r\n            sendETHDividends(referrerAddress, userAddress, 1, level,x3Reward);\r\n            \r\n            if (!users[referrerAddress].activeLevels[level+1] && level != LAST_LEVEL) {\r\n                users[referrerAddress].matrix[level].blocked = true;\r\n            }            \r\n            \r\n            uint256 restETH=(levelPrice[level]-x3Reward);\r\n            //1/2 ether to uniswap\r\n            if(openAMM){\r\n                uint256 liquidETH=restETH/2;\r\n                uint256 liquidToken=liquidETH*startLiquiRate;\r\n                _addLiquid(liquidETH,liquidToken);\r\n                _swap(restETH-liquidETH);\r\n            }else{\r\n                if(!address(uint160(owner)).send(restETH)){\r\n                    address(uint160(owner)).transfer(address(this).balance);\r\n                }\r\n            }\r\n\r\n            //mine\r\n            uint256 mineToken=restETH*currentMineRate();\r\n            umiToken.mint(referrerAddress,mineToken);\r\n            addressLevelMine[referrerAddress][level]=addressLevelMine[referrerAddress][level]+mineToken;\r\n            addressMine[referrerAddress]=addressMine[referrerAddress]+mineToken;\r\n            globalMine=globalMine+mineToken;\r\n            // updateMatrixM2Referrer(userAddress,referrerAddress,level,(levelPrice[level]-x3Reward));\r\n        }\r\n      \r\n    }  \r\n    \r\n    \r\n    function updateMatrixM2Referrer(address userAddress, address referrerAddress, uint8 level,uint256 x2Reward) private {\r\n        users[referrerAddress].matrix[level].x2referrals.push(userAddress);\r\n        \r\n        if(referrerAddress == starNode){\r\n            sendETHDividends(referrerAddress, userAddress, 2, level,x2Reward);\r\n        }else if(users[referrerAddress].matrix[level].x2referrals.length == 1&&!burnOut(referrerAddress,level)){\r\n            sendETHDividends(referrerAddress, userAddress, 2, level,x2Reward);\r\n        }else if(users[referrerAddress].matrix[level].x2referrals.length == 1&&users[referrerAddress].matrix[level].x2ReinvestCount==0){\r\n            sendETHDividends(referrerAddress, userAddress, 2, level,x2Reward);\r\n        }else{\r\n            address activedReferrerAddress = findActivedReferrer(referrerAddress, level);           \r\n\r\n            updateMatrixM2Referrer(referrerAddress,activedReferrerAddress,level,x2Reward);\r\n        }\r\n        \r\n        if(users[referrerAddress].matrix[level].x2referrals.length == 1&&users[referrerAddress].matrix[level].x2ReinvestCount!=0&&burnOut(referrerAddress,level)){\r\n            emit BurnOut(referrerAddress, userAddress, userAddress, 2, level);\r\n        }\r\n        \r\n        if(users[referrerAddress].matrix[level].x2referrals.length == 2){\r\n            users[referrerAddress].matrix[level].x2ReinvestCount++;\r\n            users[referrerAddress].matrix[level].x2referrals=new address[](0);\r\n        }        \r\n    }\r\n    \r\n    function burnOut(address addr,uint8 level) public view returns(bool){\r\n        uint256 tokenBalance=umiToken.balanceOf(addr);\r\n        return tokenBalance<levelPrice[level]*1000;\r\n    }\r\n    \r\n    function buyNewLevel(uint8 level) external payable {\r\n        require(open,\"has not open!\");\r\n        require(!airdropPhase,\"can not regist in airdropPhase!\");\r\n        require(isUserExists(msg.sender), \"user is not exists. Register first.\");\r\n        require(msg.value == levelPrice[level], \"invalid price\");\r\n        require(level >= 1 && level <= LAST_LEVEL, \"invalid level\");\r\n\r\n        require(!users[msg.sender].activeLevels[level], \"level already activated\");\r\n\r\n        if (users[msg.sender].matrix[level-1].blocked) {\r\n            users[msg.sender].matrix[level-1].blocked = false;\r\n        }\r\n        //if in blacklist remove it\r\n        if(umiToken.inBlacklist(msg.sender)){\r\n            umiToken.removeFromBlacklist(msg.sender);    \r\n        }\r\n        \r\n        address activedReferrerAddress = findActivedReferrer(msg.sender, level);\r\n        users[msg.sender].matrix[level].currentReferrer = activedReferrerAddress;\r\n        users[msg.sender].activeLevels[level] = true;\r\n        updateMatrixReferrer(msg.sender, activedReferrerAddress, level);\r\n        globalInvest=globalInvest+msg.value;            \r\n        emit Upgrade(msg.sender, activedReferrerAddress, 1, level);\r\n    }     \r\n\r\n    function activeAllLevels(address _addr,address _referrer) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[_addr].activeLevels[i] = true;\r\n            users[_addr].matrix[i].currentReferrer = _referrer;   \r\n            globalInvest=globalInvest+levelPrice[i];  \r\n              \r\n        }\r\n        if(umiToken.inBlacklist(_addr)){\r\n            umiToken.removeFromBlacklist(_addr);    \r\n        }\r\n    }    \r\n\r\n    \r\n    function findActivedReferrer(address userAddress, uint8 level) public view returns(address) {\r\n        uint8 findCount=0;\r\n        while(true){\r\n            if(findCount>2){\r\n                return truncateNode;\r\n            }\r\n            findCount++;\r\n            if (users[users[userAddress].referrer].activeLevels[level]) {\r\n                return users[userAddress].referrer;\r\n            }else{\r\n                userAddress=users[userAddress].referrer;\r\n            }            \r\n        }\r\n    }\r\n    \r\n\r\n        \r\n    function usersActiveLevels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeLevels[level];\r\n    }\r\n\r\n\r\n    function usersMatrix(address userAddress, uint8 level) public view returns(address, address[] memory,address[] memory, bool,uint256,uint256) {\r\n        return (users[userAddress].matrix[level].currentReferrer,\r\n                users[userAddress].matrix[level].x3referrals,\r\n                users[userAddress].matrix[level].x2referrals,\r\n                users[userAddress].matrix[level].blocked,\r\n                users[userAddress].matrix[level].x2ReinvestCount,\r\n                users[userAddress].matrix[level].x3ReinvestCount);\r\n    }\r\n\r\n\r\n    \r\n    function refreshTruncateNode(address _truncateNode) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        truncateNode=_truncateNode;\r\n    }    \r\n    \r\n    function isUserExists(address user) public view returns (bool) {\r\n        return addrRegisted[user];\r\n    }\r\n    \r\n\r\n    \r\n    function findEthReceiver(address userAddress, address _from, uint8 level) private returns(address, bool) {\r\n        address receiver = userAddress;\r\n        bool isExtraDividends;\r\n     \r\n        if (users[receiver].matrix[level].blocked) {\r\n            emit MissedEthReceive(receiver, _from, 1, level);\r\n            isExtraDividends = true;\r\n            return (owner, isExtraDividends);\r\n        } else {\r\n            return (receiver, isExtraDividends);\r\n        }\r\n           \r\n    \r\n    }\r\n    \r\n\r\n    function sendETHDividends(address userAddress, address _from, uint8 matrix, uint8 level,uint256 ethValue) private {\r\n        (address receiver, bool isExtraDividends) = findEthReceiver(userAddress, _from, level);\r\n\r\n        matrixLevelReward[receiver][matrix][level]=matrixLevelReward[receiver][matrix][level]+ethValue;\r\n        matrixReward[receiver][matrix]=matrixReward[receiver][matrix]+ethValue;\r\n        if (!address(uint160(receiver)).send(ethValue)) {\r\n             address(uint160(receiver)).transfer(address(this).balance);\r\n             return;\r\n        }\r\n        if (isExtraDividends) {\r\n            emit SentExtraEthDividends(_from, receiver, matrix, level);\r\n        }\r\n        \r\n        \r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    function refreshOpen(bool _open) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        open=_open;\r\n    }\r\n\r\n    function refreshOwner(address _owner) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        owner=_owner;\r\n    }\r\n    function refreshAirdropPhase(bool _airdropPhase) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        airdropPhase=_airdropPhase;\r\n    }\r\n    function refreshOpenAMM(bool _openAMM) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        openAMM=_openAMM;\r\n    }    \r\n    \r\n    \r\n    function _addLiquid(uint256 liquidETH, uint256 liquidToken ) internal{\r\n\r\n        umiToken.mint(address(this),liquidToken);\r\n\r\n        bool addLiquidityETHResult;\r\n        (addLiquidityETHResult,) = uniswapAddr.call.value(liquidETH)(abi.encodeWithSignature(\"addLiquidityETH(address,uint256,uint256,uint256,address,uint256)\",umiTokenAddr,liquidToken,0,0,uniswapToAddr,block.timestamp));\r\n        require(addLiquidityETHResult,\"addLiquidity failed!\");\r\n    }\r\n    \r\n    function removeLiquidityETHWrapper(\r\n        address _token,\r\n        uint _liquidity,\r\n        uint _amountTokenMin,\r\n        uint _amountETHMin,\r\n        address _to,\r\n        uint _deadline\r\n    ) external returns (uint _amountToken, uint _amountETH){\r\n        require(msg.sender==owner, \"require owner\");\r\n        (_amountToken,_amountETH) = uniswap.removeLiquidityETH(_token,_liquidity,_amountTokenMin,_amountETHMin,_to,_deadline);\r\n    }\r\n    \r\n\r\n\r\n    function _swap(uint256 swapEth) internal{\r\n        // function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        bool swapResult;\r\n        address[] memory paths = new address[](2);\r\n        paths[0]=uniswap.WETH();\r\n        paths[1]=umiTokenAddr;\r\n        \r\n        (swapResult,) = uniswapAddr.call.value(swapEth)(abi.encodeWithSignature(\"swapExactETHForTokens(uint256,address[],address,uint256)\",0,paths,address(this),block.timestamp));\r\n        require(swapResult,\"swap failed!\");\r\n    }    \r\n    \r\n\tfunction etherProceeds() external{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n\t\tif(!msg.sender.send(address(this).balance)) revert();\r\n\t}\r\n\t\r\n\tfunction refreshTokenAddr(address _addr) external\r\n\t{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n        umiTokenAddr=_addr;\r\n        umiToken = UmiTokenInterface(umiTokenAddr);\t    \r\n\t}\t\t\r\n\tfunction refreshUniswapToAddr(address payable _addr) external\r\n\t{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n        uniswapToAddr=_addr;\r\n\t}\t\t\r\n\t\r\n\tfunction refreshOpenAirdrop(bool _openAirdrop) external{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n\t    openAirdrop=_openAirdrop;\r\n\t}\r\n\t   \r\n\tfunction queryGlobalMine() public view returns(uint256){\r\n\t    return globalMine;\r\n\t}\r\n\tfunction queryGlobalInvest()public view returns(uint256){\r\n\t    return globalInvest;\r\n\t}\r\n\t\r\n\tfunction queryUserTotalMine(address _addr) public view returns(uint256){\r\n\t    return addressMine[_addr];\r\n\t}\r\n\tfunction queryUserTotalReward(address _addr)public view returns(uint256){\r\n\t    return matrixReward[_addr][1]+matrixReward[_addr][2];\r\n\t}\r\n\tfunction queryUserX3LevelReward(address _addr ,uint8 level) public view returns(uint256){\r\n\t    return matrixLevelReward[_addr][1][level];\r\n\t}\r\n\tfunction queryUserX2LevelReward(address _addr ,uint8 level) public view returns(uint256){\r\n\t    return matrixLevelReward[_addr][2][level];\r\n\t}   \r\n\tfunction queryUserX3LevelMine(address _addr ,uint8 level) public view returns(uint256){\r\n\t    return addressLevelMine[_addr][level];\r\n\t}\r\n\t\r\n\t\r\n\tfunction increaseApprove(uint256 amount) external{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n\t    _increaseApprove(amount);\r\n\t}\r\n\t\r\n    function _increaseApprove(uint256 amount) internal{\r\n        bool approveResult;\r\n        (approveResult,)=umiTokenAddr.call(abi.encodeWithSignature(\"approve(address,uint256)\",uniswapAddr,amount));\r\n        require(approveResult,\"approve failed!\");\r\n    }\r\n    \r\n    function currentMineRate() public view returns (uint256){\r\n        if(globalMine<10000000000000000000000000 ){\r\n            return 1000;\r\n        }else if(globalMine>=10000000000000000000000000&&globalMine<15000000000000000000000000){\r\n            return 500;\r\n        }else if(globalMine>=15000000000000000000000000&&globalMine<17500000000000000000000000){\r\n            return 250;\r\n        }else if(globalMine>=17500000000000000000000000&&globalMine<27500000000000000000000000){\r\n            return 125;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"starNodeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentReferrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"BurnOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"MissedEthReceive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"place\",\"type\":\"uint8\"}],\"name\":\"NewUserPlace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentReferrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SentExtraEthDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAST_LEVEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"activeAllLevels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addrRegisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressLevelMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"burnOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"buyNewLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMineRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"etherProceeds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"findActivedReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasAirdropAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matrixLevelReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matrixReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAirdropAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mineRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openAMM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"perAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"perAirdropForReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryGlobalInvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryGlobalMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"queryUserTotalMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"queryUserTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"queryUserX2LevelReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"queryUserX3LevelMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"queryUserX3LevelReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_airdropPhase\",\"type\":\"bool\"}],\"name\":\"refreshAirdropPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_open\",\"type\":\"bool\"}],\"name\":\"refreshOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_openAMM\",\"type\":\"bool\"}],\"name\":\"refreshOpenAMM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_openAirdrop\",\"type\":\"bool\"}],\"name\":\"refreshOpenAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"refreshOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"refreshTokenAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_truncateNode\",\"type\":\"address\"}],\"name\":\"refreshTruncateNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"refreshUniswapToAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registrationExt\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registrationForAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHWrapper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starNode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startLiquiRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"umiToken\",\"outputs\":[{\"internalType\":\"contract UmiTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"umiTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router01\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapAddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partnersCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersActiveLevels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersMatrix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniSage","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b4ddb836bde4165e60b72f72bfb2630a25b607c8","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d34878f79fbef641e1c29102b1532bf9e7fa5cd151566b48adab025c8facfc71"}]}