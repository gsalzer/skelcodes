{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/governance/BaseGovernanceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../interfaces/IGovernanceModule.sol\\\";\\n\\n\\nabstract contract BaseGovernanceModule is IGovernanceModule {\\n    address public immutable mothership;\\n\\n    modifier onlyMothership {\\n        require(msg.sender == mothership, \\\"Access restricted to mothership\\\");\\n\\n        _;\\n    }\\n\\n    constructor(address _mothership) public {\\n        mothership = _mothership;\\n    }\\n\\n    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external override onlyMothership {\\n        require(accounts.length == newBalances.length, \\\"Arrays length should be equal\\\");\\n\\n        for(uint256 i = 0; i < accounts.length; ++i) {\\n            _notifyStakeChanged(accounts[i], newBalances[i]);\\n        }\\n    }\\n\\n    function notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {\\n        _notifyStakeChanged(account, newBalance);\\n    }\\n\\n    function _notifyStakeChanged(address account, uint256 newBalance) internal virtual;\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/governance/ExchangeGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../interfaces/IExchangeGovernance.sol\\\";\\nimport \\\"../libraries/ExchangeConstants.sol\\\";\\nimport \\\"../libraries/LiquidVoting.sol\\\";\\nimport \\\"../libraries/SafeCast.sol\\\";\\nimport \\\"../utils/BalanceAccounting.sol\\\";\\nimport \\\"./BaseGovernanceModule.sol\\\";\\n\\n\\ncontract ExchangeGovernance is IExchangeGovernance, BaseGovernanceModule, BalanceAccounting {\\n    using Vote for Vote.Data;\\n    using LiquidVoting for LiquidVoting.Data;\\n    using VirtualVote for VirtualVote.Data;\\n    using SafeCast for uint256;\\n\\n    event LeftoverGovernanceShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\\n    event LeftoverReferralShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\\n    event LeftoverTeamShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\\n\\n    LiquidVoting.Data private _leftoverGovernanceShare;\\n    LiquidVoting.Data private _leftoverReferralShare;\\n\\n    constructor(address _mothership) public BaseGovernanceModule(_mothership) {\\n        _leftoverGovernanceShare.data.result = ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE.toUint104();\\n        _leftoverReferralShare.data.result = ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE.toUint104();\\n    }\\n\\n    function parameters() external view override returns(uint256 govShare, uint256 refShare, uint256 teamShare) {\\n        govShare = _leftoverGovernanceShare.data.current();\\n        refShare = _leftoverReferralShare.data.current();\\n        teamShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShare).sub(refShare);\\n    }\\n\\n    function leftoverGovernanceShare() external view override returns(uint256) {\\n        return _leftoverGovernanceShare.data.current();\\n    }\\n\\n    function leftoverGovernanceShareVotes(address user) external view returns(uint256) {\\n        return _leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE);\\n    }\\n\\n    function virtualLeftoverGovernanceShare() external view returns(uint104, uint104, uint48) {\\n        return (_leftoverGovernanceShare.data.oldResult, _leftoverGovernanceShare.data.result, _leftoverGovernanceShare.data.time);\\n    }\\n\\n    //\\n\\n    function leftoverReferralShare() external view override returns(uint256) {\\n        return _leftoverReferralShare.data.current();\\n    }\\n\\n    function leftoverReferralShareVotes(address user) external view returns(uint256) {\\n        return _leftoverReferralShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE);\\n    }\\n\\n    function virtualLeftoverReferralShare() external view returns(uint104, uint104, uint48) {\\n        return (_leftoverReferralShare.data.oldResult, _leftoverReferralShare.data.result, _leftoverReferralShare.data.time);\\n    }\\n\\n    //\\n\\n    function leftoverTeamShare() external view override returns(uint256) {\\n        return ExchangeConstants._LEFTOVER_TOTAL_SHARE\\n            .sub(_leftoverGovernanceShare.data.current())\\n            .sub(_leftoverReferralShare.data.current());\\n    }\\n\\n    function leftoverTeamShareVotes(address user) external view returns(uint256) {\\n        return ExchangeConstants._LEFTOVER_TOTAL_SHARE\\n            .sub(_leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE))\\n            .sub(_leftoverReferralShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE));\\n    }\\n\\n    function virtualLeftoverTeamShare() external view returns(uint104, uint104, uint48) {\\n        return (\\n            ExchangeConstants._LEFTOVER_TOTAL_SHARE\\n                .sub(_leftoverGovernanceShare.data.oldResult)\\n                .sub(_leftoverReferralShare.data.oldResult).toUint104(),\\n            ExchangeConstants._LEFTOVER_TOTAL_SHARE\\n                .sub(_leftoverGovernanceShare.data.result)\\n                .sub(_leftoverReferralShare.data.result).toUint104(),\\n            _leftoverGovernanceShare.data.time\\n        );\\n    }\\n\\n    ///\\n\\n    function leftoverShareVote(uint256 govShare, uint256 refShare) external {\\n        uint256 teamShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE\\n            .sub(govShare.add(refShare), \\\"Leftover shares are too high\\\");\\n\\n        uint256 balance = balanceOf(msg.sender);\\n        uint256 supply = totalSupply();\\n\\n        _leftoverGovernanceShare.updateVote(\\n            msg.sender,\\n            _leftoverGovernanceShare.votes[msg.sender],\\n            Vote.init(govShare),\\n            balance,\\n            supply,\\n            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\\n            _emitLeftoverGovernanceShareVoteUpdate\\n        );\\n\\n        _leftoverReferralShare.updateVote(\\n            msg.sender,\\n            _leftoverReferralShare.votes[msg.sender],\\n            Vote.init(refShare),\\n            balance,\\n            supply,\\n            ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE,\\n            _emitLeftoverReferralShareVoteUpdate\\n        );\\n\\n        _emitLeftoverTeamShareVoteUpdate(msg.sender, teamShare, false, balance);\\n    }\\n\\n    function discardLeftoverShareVote() external {\\n        uint256 balance = balanceOf(msg.sender);\\n        uint256 supply = totalSupply();\\n\\n        _leftoverGovernanceShare.updateVote(\\n           msg.sender,\\n           _leftoverGovernanceShare.votes[msg.sender],\\n           Vote.init(),\\n           balance,\\n           supply,\\n           ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\\n           _emitLeftoverGovernanceShareVoteUpdate\\n        );\\n\\n        _leftoverReferralShare.updateVote(\\n           msg.sender,\\n           _leftoverReferralShare.votes[msg.sender],\\n           Vote.init(),\\n           balance,\\n           supply,\\n           ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE,\\n           _emitLeftoverReferralShareVoteUpdate\\n        );\\n\\n        _emitLeftoverTeamShareVoteUpdate(msg.sender, ExchangeConstants._DEFAULT_LEFTOVER_TEAM_SHARE, true, balance);\\n    }\\n\\n    function _notifyStakeChanged(address account, uint256 newBalance) internal override {\\n        uint256 balance = _set(account, newBalance);\\n        if (newBalance == balance) {\\n            return;\\n        }\\n\\n        Vote.Data memory govShareVote = _leftoverGovernanceShare.votes[account];\\n        Vote.Data memory refShareVote = _leftoverReferralShare.votes[account];\\n        uint256 teamShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE\\n            .sub(govShareVote.get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE))\\n            .sub(refShareVote.get(ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE));\\n        uint256 supply = totalSupply();\\n\\n        _leftoverGovernanceShare.updateBalance(\\n            account,\\n            govShareVote,\\n            balance,\\n            newBalance,\\n            supply,\\n            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\\n            _emitLeftoverGovernanceShareVoteUpdate\\n        );\\n\\n        _leftoverReferralShare.updateBalance(\\n            account,\\n            refShareVote,\\n            balance,\\n            newBalance,\\n            supply,\\n            ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE,\\n            _emitLeftoverReferralShareVoteUpdate\\n        );\\n\\n        _emitLeftoverTeamShareVoteUpdate(\\n            account,\\n            teamShare,\\n            govShareVote.isDefault(),\\n            newBalance\\n        );\\n    }\\n\\n    function _emitLeftoverGovernanceShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\\n        emit LeftoverGovernanceShareUpdate(user, newDefaultShare, isDefault, balance);\\n    }\\n\\n    function _emitLeftoverReferralShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\\n        emit LeftoverReferralShareUpdate(user, newDefaultShare, isDefault, balance);\\n    }\\n\\n    function _emitLeftoverTeamShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\\n        emit LeftoverTeamShareUpdate(user, newDefaultShare, isDefault, balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/interfaces/IExchangeGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\ninterface IExchangeGovernance {\\n    function parameters() external view returns(uint256, uint256, uint256);\\n\\n    function leftoverReferralShare() external view returns(uint256);\\n    function leftoverGovernanceShare() external view returns(uint256);\\n    function leftoverTeamShare() external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/interfaces/IGovernanceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\ninterface IGovernanceModule {\\n    function notifyStakeChanged(address account, uint256 newBalance) external;\\n    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external;\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/ExchangeConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\nlibrary ExchangeConstants {\\n    uint256 internal constant _LEFTOVER_TOTAL_SHARE = 1e18;           // 100%\\n    uint256 internal constant _DEFAULT_LEFTOVER_GOV_SHARE = 0.34e18;  // 34%\\n    uint256 internal constant _DEFAULT_LEFTOVER_REF_SHARE = 0.33e18;  // 33%\\n    uint256 internal constant _DEFAULT_LEFTOVER_TEAM_SHARE = 0.33e18; // 33%\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/LiquidVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./VirtualVote.sol\\\";\\nimport \\\"./Vote.sol\\\";\\n\\n\\nlibrary LiquidVoting {\\n    using SafeMath for uint256;\\n    using SafeCast for uint256;\\n    using Vote for Vote.Data;\\n    using VirtualVote for VirtualVote.Data;\\n\\n    struct Data {\\n        VirtualVote.Data data;\\n        uint256 _weightedSum;\\n        uint256 _defaultVotes;\\n        mapping(address => Vote.Data) votes;\\n    }\\n\\n    function updateVote(\\n        LiquidVoting.Data storage self,\\n        address user,\\n        Vote.Data memory oldVote,\\n        Vote.Data memory newVote,\\n        uint256 balance,\\n        uint256 totalSupply,\\n        uint256 defaultVote,\\n        function(address, uint256, bool, uint256) emitEvent\\n    ) internal {\\n        return _update(self, user, oldVote, newVote, balance, balance, totalSupply, defaultVote, emitEvent);\\n    }\\n\\n    function updateBalance(\\n        LiquidVoting.Data storage self,\\n        address user,\\n        Vote.Data memory oldVote,\\n        uint256 oldBalance,\\n        uint256 newBalance,\\n        uint256 newTotalSupply,\\n        uint256 defaultVote,\\n        function(address, uint256, bool, uint256) emitEvent\\n    ) internal {\\n        return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, newTotalSupply, defaultVote, emitEvent);\\n    }\\n\\n    function _update(\\n        LiquidVoting.Data storage self,\\n        address user,\\n        Vote.Data memory oldVote,\\n        Vote.Data memory newVote,\\n        uint256 oldBalance,\\n        uint256 newBalance,\\n        uint256 newTotalSupply,\\n        uint256 defaultVote,\\n        function(address, uint256, bool, uint256) emitEvent\\n    ) private {\\n        uint256 oldWeightedSum = self._weightedSum;\\n        uint256 newWeightedSum = oldWeightedSum;\\n        uint256 oldDefaultVotes = self._defaultVotes;\\n        uint256 newDefaultVotes = oldDefaultVotes;\\n\\n        if (oldVote.isDefault()) {\\n            newDefaultVotes = newDefaultVotes.sub(oldBalance);\\n        } else {\\n            newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\\n        }\\n\\n        if (newVote.isDefault()) {\\n            newDefaultVotes = newDefaultVotes.add(newBalance);\\n        } else {\\n            newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\\n        }\\n\\n        if (newWeightedSum != oldWeightedSum) {\\n            self._weightedSum = newWeightedSum;\\n        }\\n\\n        if (newDefaultVotes != oldDefaultVotes) {\\n            self._defaultVotes = newDefaultVotes;\\n        }\\n\\n        {\\n            uint256 newResult = newTotalSupply == 0 ? defaultVote : newWeightedSum.add(newDefaultVotes.mul(defaultVote)).div(newTotalSupply);\\n            VirtualVote.Data memory data = self.data;\\n            if (newResult != data.result) {\\n                self.data.oldResult = data.current().toUint104();\\n                self.data.result = newResult.toUint104();\\n                self.data.time = block.timestamp.toUint48();\\n            }\\n        }\\n\\n        if (!newVote.eq(oldVote)) {\\n            self.votes[user] = newVote;\\n        }\\n\\n        emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nlibrary SafeCast {\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value < 2**216, \\\"value does not fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value < 2**104, \\\"value does not fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value < 2**48, \\\"value does not fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value < 2**40, \\\"value does not fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/VirtualVote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n\\nlibrary VirtualVote {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant _VOTE_DECAY_PERIOD = 1 days;\\n\\n    struct Data {\\n        uint104 oldResult;\\n        uint104 result;\\n        uint48 time;\\n    }\\n\\n    function current(VirtualVote.Data memory self) internal view returns(uint256) {\\n        uint256 timePassed = Math.min(_VOTE_DECAY_PERIOD, block.timestamp.sub(self.time));\\n        uint256 timeRemain = _VOTE_DECAY_PERIOD.sub(timePassed);\\n        return uint256(self.oldResult).mul(timeRemain).add(\\n            uint256(self.result).mul(timePassed)\\n        ).div(_VOTE_DECAY_PERIOD);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/libraries/Vote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\n\\nlibrary Vote {\\n    struct Data {\\n        uint256 value;\\n    }\\n\\n    function eq(Vote.Data memory self, Vote.Data memory vote) internal pure returns(bool) {\\n        return self.value == vote.value;\\n    }\\n\\n    function init() internal pure returns(Vote.Data memory data) {\\n        return Vote.Data({\\n            value: 0\\n        });\\n    }\\n\\n    function init(uint256 vote) internal pure returns(Vote.Data memory data) {\\n        return Vote.Data({\\n            value: vote + 1\\n        });\\n    }\\n\\n    function isDefault(Data memory self) internal pure returns(bool) {\\n        return self.value == 0;\\n    }\\n\\n    function get(Data memory self, uint256 defaultVote) internal pure returns(uint256) {\\n        if (self.value > 0) {\\n            return self.value - 1;\\n        }\\n        return defaultVote;\\n    }\\n\\n    function get(Data memory self, function() external view returns(uint256) defaultVoteFn) internal view returns(uint256) {\\n        if (self.value > 0) {\\n            return self.value - 1;\\n        }\\n        return defaultVoteFn();\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/zumzoom/Projects/1inch/mooniswap-v2/contracts/utils/BalanceAccounting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n\\ncontract BalanceAccounting {\\n    using SafeMath for uint256;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _balances[account] = _balances[account].sub(amount, \\\"Burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n    }\\n\\n    function _set(address account, uint256 amount) internal virtual returns(uint256 oldAmount) {\\n        oldAmount = _balances[account];\\n        if (oldAmount != amount) {\\n            _balances[account] = amount;\\n            _totalSupply = _totalSupply.add(amount).sub(oldAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mothership\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDefault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LeftoverGovernanceShareUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDefault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LeftoverReferralShareUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDefault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LeftoverTeamShareUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discardLeftoverShareVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leftoverGovernanceShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"leftoverGovernanceShareVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leftoverReferralShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"leftoverReferralShareVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"govShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refShare\",\"type\":\"uint256\"}],\"name\":\"leftoverShareVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leftoverTeamShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"leftoverTeamShareVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mothership\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"notifyStakeChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newBalances\",\"type\":\"uint256[]\"}],\"name\":\"notifyStakesChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"govShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualLeftoverGovernanceShare\",\"outputs\":[{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualLeftoverReferralShare\",\"outputs\":[{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualLeftoverTeamShare\",\"outputs\":[{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ExchangeGovernance","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000a0446d8804611944f1b527ecd37d7dcbe442caba","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}