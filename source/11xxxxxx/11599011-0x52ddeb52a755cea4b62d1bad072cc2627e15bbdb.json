{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/Booty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { GovernanceInterface } from \\\"./interfaces/GovernanceInterface.sol\\\";\\n\\n/** \\n * @title Keeps balance of players in ETH for specific lottery round.\\n *\\n * @dev This contract is a simplified fork of openzeppelin's PaymentSplitter\\n * and RefundEscrow contracts.\\n *\\n * At the event of win it nullifies the loser side shares.\\n */\\ncontract Booty {\\n    using SafeMath for uint256;\\n\\n    GovernanceInterface public TrustedGovernance;\\n\\n    enum State { Free, Active, GreenWon, BlueWon, Draw }\\n\\n    event RoundResolved(uint32 round, State state, uint256 total, uint256 winners);\\n    event BootyClaimed(address indexed player, uint256 amount);\\n    event Bet(address indexed player, uint256 amount, uint8 indexed side, uint32 indexed round);\\n\\n    address public immutable lottery;\\n    uint32 public currentRound;\\n    uint32[] public rounds;\\n    uint public killableAfter;\\n\\n    State public state = State.Free;\\n    \\n    uint256 public totalShares;\\n    uint256 public totalReleased;\\n    uint256 public totalGreen;\\n    uint256 public totalBlue;\\n\\n    mapping(address => uint256) public greenShares;\\n    mapping(address => uint256) public blueShares;\\n    mapping(address => uint256) public released;\\n\\n    address payable[] public bluePayees;\\n    address payable[] public greenPayees;\\n\\n    modifier onlyDAO() {\\n        require(msg.sender == TrustedGovernance.owner(), \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyLottery() {\\n        require(msg.sender == lottery, \\\"Only lottery\\\");\\n        _;\\n    }\\n\\n    modifier onlyActive() {\\n        require(state == State.Active, \\\"Already resolved\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev We don't know the future shareholders at contract deployment time\\n     * we'll know their total number at the end of the lottery.\\n     *\\n     * @param _governance Orchestration contract.\\n     * @param _lottery Lottery contract for which we hold balances.\\n     */\\n    constructor (address _governance, address _lottery) public {\\n        TrustedGovernance = GovernanceInterface(_governance);\\n\\n        lottery = _lottery;\\n        killableAfter = now + TrustedGovernance.timeToClaimBooty();\\n    }\\n\\n    /**\\n     * @dev Check how much wei user has lost in that round.\\n     *\\n     * @param _payee Address of user whose balance we are checking.\\n     */\\n    function losesOf(address _payee) public view returns (uint256) {\\n        State _state = state;\\n        if (_state == State.GreenWon) {\\n            return blueShares[_payee];\\n        } else if (_state == State.BlueWon) {\\n            return greenShares[_payee];\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Check current balance of the user which he can withdraw.\\n     *\\n     * @param _payee Address of user whose balance we are checking.\\n     */\\n    function unlockedBalanceOf(address _payee) public view returns (uint256) {\\n        State _state = state;\\n        if (_state == State.GreenWon) {\\n            return balanceByShares(_payee, greenShares[_payee]);\\n        } else if (_state == State.BlueWon) {\\n            return balanceByShares(_payee, blueShares[_payee]);\\n        } else if (_state == State.Draw) {\\n            return sharesByState(_payee, _state);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Check current balance of the user which he can't withdraw.\\n     *\\n     * @param _payee Address of user whose balance we are checking.\\n     */\\n    function lockedBalanceOf(address _payee) public view returns (uint256) {\\n        State _state = state;\\n        if (_state == State.Active) {\\n            return blueShares[_payee].add(greenShares[_payee]);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to check balance based on shares ownership.\\n     *\\n     * @param _payee Address of user whose balance we are checking.\\n     * @param _shares Eligible shares of user.\\n     */\\n    function balanceByShares(address _payee, uint256 _shares) public view returns (uint256) {\\n        return address(this).balance.add(totalReleased).mul(_shares).div(totalShares).sub(released[_payee]);\\n    }\\n\\n    /**\\n     * @dev Helper to check shares of user based on current state.\\n     *\\n     * @param _payee Address of user whose balance we are checking.\\n     * @param _state Cached current game state.\\n     */\\n    function sharesByState(address _payee, State _state) public view returns (uint256) {\\n        if (_state == State.BlueWon) {\\n            return blueShares[_payee];\\n        } else if (_state == State.GreenWon) {\\n            return greenShares[_payee];\\n        } else if (_state == State.Draw) {\\n            return blueShares[_payee].add(greenShares[_payee]);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Register bet for Green.\\n     *\\n     * @param _sender Address on behalf of which the payment was done.\\n     */\\n    function greenBet(address payable _sender) external payable onlyActive onlyLottery {\\n        uint256 currentShares = greenShares[_sender];\\n        if (currentShares == 0) greenPayees.push(_sender);\\n\\n        emit Bet(_sender, msg.value, 1, currentRound);\\n        totalGreen = totalGreen.add(msg.value);\\n        greenShares[_sender] = currentShares.add(msg.value);\\n        totalShares = totalShares.add(msg.value);\\n    }\\n\\n    /**\\n     * @dev Register bet for Blue.\\n     *\\n     * @param _sender Address on behalf of which the payment was done.\\n     */\\n    function blueBet(address payable _sender) external payable onlyActive onlyLottery {\\n        uint256 currentShares = blueShares[_sender];\\n        if (currentShares == 0) bluePayees.push(_sender);\\n\\n        emit Bet(_sender, msg.value, 0, currentRound);\\n        totalBlue = totalBlue.add(msg.value);\\n        blueShares[_sender] = currentShares.add(msg.value);\\n        totalShares = totalShares.add(msg.value);\\n    }\\n\\n    /**\\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\\n     * total shares and their previous withdrawals.\\n     *\\n     * @param account Address which withdraws it's booty.\\n     */\\n    function release(address payable account) public {\\n        State _state = state;\\n        require(_state != State.Active, \\\"not ready\\\");\\n\\n        address _payee = address(account);\\n        uint256 _shares = sharesByState(_payee, _state);\\n        require(_shares > 0, \\\"account has no shares\\\");\\n        \\n        uint256 _payment = balanceByShares(_payee, _shares);\\n        require(_payment != 0, \\\"account is not due payment\\\");\\n\\n        released[_payee] = released[_payee].add(_payment);\\n        totalReleased = totalReleased.add(_payment);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = account.call{value: _payment}(\\\"\\\");\\n        require(success, \\\"unable to send value\\\");\\n\\n        emit BootyClaimed(_payee, _payment);\\n    }\\n\\n    /**\\n     * @dev Blue won, nullify Green bets, allow releasing of funds.\\n     */\\n    function declareBlueWin() external onlyActive onlyLottery {\\n        totalShares = totalShares.sub(totalGreen);\\n        state = State.BlueWon;\\n        emit RoundResolved(rounds[rounds.length - 1], State.BlueWon, address(this).balance, totalBlue);\\n    }\\n\\n    /**\\n     * @dev Green won, nullify Blue bets, allow releasing of funds.\\n     */\\n    function declareGreenWin() external onlyActive onlyLottery {\\n        totalShares = totalShares.sub(totalBlue);\\n        state = State.GreenWon;\\n        emit RoundResolved(rounds[rounds.length - 1], State.GreenWon, address(this).balance, totalGreen);\\n    }\\n\\n    /**\\n     * @dev Game canceled, users can freely release their funds.\\n     */\\n    function declareDraw() external onlyActive {\\n        require(TrustedGovernance.isManagement(msg.sender) || msg.sender == lottery, \\\"Only management or lottery\\\");\\n        state = State.Draw;\\n        emit RoundResolved(rounds[rounds.length - 1], State.Draw, 0, 0);\\n    }\\n\\n    /**\\n     * @dev Use new or recycled Booty contract for a new round.\\n     *\\n     * @param _round New round for the Booty.\\n     */\\n    function useForRound(uint32 _round) external onlyLottery {\\n        require(state == State.Free, \\\"already used\\\");\\n        newRound(_round);\\n    }\\n\\n    /**\\n     * @dev Lottery can recycle empty Booty contract to save on gas fees.\\n     * In case Booty had singe market maker - generate relevant bet events.\\n     *\\n     * @param _round New round for the Booty.\\n     */\\n    function recycleForRound(uint32 _round) external onlyLottery returns (address, uint256, address, uint256) {\\n        require(readiness() == 0, \\\"not empty, non recyclable\\\");\\n        emit RoundResolved(rounds[rounds.length - 1], State.Draw, 0, 0);\\n        newRound(_round);\\n\\n        address payable mmBlue;\\n        uint256 amBlue;\\n        if (bluePayees.length != 0) {\\n            mmBlue = bluePayees[0];\\n            amBlue = blueShares[mmBlue];\\n            emit Bet(mmBlue, amBlue, 0, _round);\\n        }\\n\\n        address payable mmGreen;\\n        uint256 amGreen;\\n        if (greenPayees.length != 0) {\\n            mmGreen = greenPayees[0];\\n            amGreen = greenShares[mmGreen];\\n            emit Bet(mmGreen, amGreen, 1, _round);\\n        }\\n\\n        return (mmBlue, amBlue, mmGreen, amGreen);\\n    }\\n\\n    /**\\n     * @dev Set new round state.\\n     *\\n     * @param _round New round for the Booty.\\n     */\\n    function newRound(uint32 _round) private {\\n        currentRound = _round;\\n        rounds.push(_round);\\n        killableAfter = now + TrustedGovernance.timeToClaimBooty();\\n        state = State.Active;\\n    }\\n\\n    /**\\n     * @dev Checks one of 3 possible booty states.\\n     *\\n     * 2 - ready for resolution;\\n     * 1 - not empty, undecided;\\n     * 0 - no bets or single participant, can be recycled.\\n     */\\n    function readiness() public view returns (uint8) {\\n        uint256 _tg = totalGreen;\\n        uint256 _tb = totalBlue;\\n        \\n        if (bluePayees.length == 1 && greenPayees.length == 1 && bluePayees[0] == greenPayees[0]) {\\n            return 0;\\n        } else if (_tg == 0 && _tb == 0) {\\n            return 0;\\n        } else if (_tg > 0 && _tb > 0) {\\n            return 2;\\n        } else {\\n            return 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Management can pay fee for recycle if it's cheaper to recycle\\n     * Booty contract instead of making a new one which is ~2,6m gas.\\n     *\\n     * For manual payouts you can cycle over winner's party known by state \\n     * (greenPayees or bluePayeers). Check pending payouts with combination \\n     * of sharesByState and balanceByShares, then call release for the relevant addresses.\\n     */\\n    function forceRecycle() external onlyLottery {\\n        require(address(this).balance < 0.09 ether, \\\"clear payouts first\\\");\\n\\n        for (uint32 i = 0; i < greenPayees.length; i++) {\\n            address _addr = address(greenPayees[i]);\\n            delete greenShares[_addr];\\n            if (released[_addr] > 0) delete released[_addr];\\n        }\\n        for (uint32 i = 0; i < bluePayees.length; i++) {\\n            address _addr = address(bluePayees[i]);\\n            delete blueShares[_addr];\\n            if (released[_addr] > 0) delete released[_addr];\\n        }\\n\\n        delete totalShares;\\n        delete totalReleased;\\n        delete totalGreen;\\n        delete totalBlue;\\n\\n        delete bluePayees;\\n        delete greenPayees;\\n\\n        state = State.Free;\\n    }\\n\\n    /** \\n     * @dev Used for cleanup, players have 30 days to withdraw their holding.\\n     * empty booties can be killed at once.\\n     */\\n    function daoDie() external onlyDAO {\\n        if (address(this).balance > 0.09 ether) require(killableAfter < now, \\\"yet to expire\\\");\\n        \\n        selfdestruct(TrustedGovernance.beneficiary());\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { Booty } from \\\"./Booty.sol\\\";\\n\\nimport { GovernanceInterface } from \\\"./interfaces/GovernanceInterface.sol\\\";\\nimport { BootyInterface } from \\\"./interfaces/BootyInterface.sol\\\";\\nimport { L7lLedgerInterface } from \\\"./interfaces/L7lLedgerInterface.sol\\\";\\n\\n/** \\n * @title Keeps withdrawable balances of players in ETH and tokens.\\n *\\n * @dev ETH funds are kept in standard openzeppelin Escrow contract to \\n * protect funds against re-entrancy attacks.\\n *\\n * Balances in other tokens, including L7L are kept in a separate ledger \\n * escrow-like contracts.\\n */\\ncontract Treasury {\\n    using SafeMath for uint256;\\n\\n    bytes32 public constant NO_SHARES = keccak256(abi.encode(\\\"account has no shares\\\"));\\n    bytes32 public constant NO_PAYMENT = keccak256(abi.encode(\\\"account is not due payment\\\"));\\n\\n    GovernanceInterface public immutable TrustedGovernance;\\n    L7lLedgerInterface public TrustedL7lLedger;\\n    BootyBuilder private TrustedBootyBuilder;\\n\\n    address[] public allBooties;\\n    mapping(address => BootyInterface[]) public TrustedBooties;\\n\\n    modifier onlyLotteries() {\\n        require(TrustedGovernance.lotteryContracts(msg.sender), \\\"Only lottery\\\");\\n        _;\\n    }\\n\\n    modifier onlyLotteriesOrManager() {\\n        require(TrustedGovernance.lotteryContracts(msg.sender) || msg.sender == TrustedGovernance.manager(), \\\"Only management\\\");\\n        _;\\n    }\\n\\n    modifier onlyDAO() {\\n        require(msg.sender == TrustedGovernance.owner(), \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    event L7lRewarded(\\n        address indexed player,\\n        uint256 reward\\n    );\\n\\n    event AllL7lClaimed(\\n        address indexed player\\n    );\\n\\n    event EthClaimed(\\n        address indexed player,\\n        uint256 unclaimedBooties\\n    );\\n\\n    event EthClaimFailure(\\n        address indexed player,\\n        address booty,\\n        string error\\n    );\\n\\n    /** \\n     * @dev L7L DAO should be in charge of treasury smart-contract.\\n     *\\n     * @param _governance - orchestration contract\\n     * @param _ledger - L7L token ledger\\n     */\\n    constructor(address _governance, address _ledger) public {\\n        TrustedGovernance = GovernanceInterface(_governance);\\n        TrustedBootyBuilder = new BootyBuilder(address(this));\\n        TrustedL7lLedger = L7lLedgerInterface(_ledger);\\n    }\\n\\n    /**\\n     * @dev Create new booty contract for lottery, free for assigment to any round.\\n     */\\n    function createBooty() external onlyLotteries returns(address) {\\n        address bootyAddr = TrustedBootyBuilder.createBooty(address(TrustedGovernance), msg.sender);\\n        allBooties.push(bootyAddr);\\n        return bootyAddr;\\n    }\\n\\n    /**\\n     * @dev New booty contract was published.\\n     *\\n     * @param dest The creditor's address.\\n     * @param bootyContract Contract address where player has participated.\\n     */\\n    function registerPlayerBooty(address payable dest, address bootyContract) external onlyLotteries {\\n        TrustedBooties[address(dest)].push(BootyInterface(bootyContract));\\n    }\\n\\n    /**\\n     * @dev Consolidate creditor's claimable ETH from all booties.\\n     *\\n     * @param dest The creditor's address.\\n     */\\n    function payments(address dest) external view returns(uint256) {\\n        BootyInterface[] memory booties = TrustedBooties[dest];\\n        uint256 len = booties.length;\\n        uint256 total;\\n\\n        if (len == 0) return 0;\\n\\n        for (uint32 i = 0; i <= len - 1; i++) {\\n            total = total.add(booties[i].unlockedBalanceOf(dest));\\n        }\\n        return total;\\n    }\\n\\n    /**\\n     * @dev Withdraw all player's balance in ETH.\\n     *\\n     * Can potentially require several batches if players were not withdrawing for too many rounds.\\n     *\\n     * We use low-level call, because both contracts are trusted and we save gas on elimintation\\n     * of protective coding.\\n     *\\n     * We use 2 local counters to keep track of index and not to overflow 0 in while decrement.\\n     *\\n     * @param dest The creditor's address.\\n     */\\n    function withdrawPayments(address payable dest) public onlyLotteriesOrManager {\\n        address destAddr = address(dest);\\n        BootyInterface[] storage booties = TrustedBooties[destAddr]; \\n\\n        uint256 i = booties.length;\\n        require(i > 0, \\\"nothing to withdraw\\\");\\n\\n        bool cleanupAllowed = true;\\n\\n        while (i > 0 && gasleft() > 70000) {\\n            BootyInterface booty = booties[i - 1];\\n            address bootyAddr = address(booty);\\n\\n            try booty.release(dest) {\\n                if (cleanupAllowed) booties.pop();\\n            } catch Error(string memory error) {\\n                bytes32 hashedError = keccak256(abi.encode(error));\\n                emit EthClaimFailure(destAddr, bootyAddr, error);\\n\\n                if (cleanupAllowed && (hashedError == NO_SHARES || hashedError == NO_PAYMENT)) {\\n                    booties.pop();\\n                } else {\\n                    cleanupAllowed = false;\\n                }\\n            }\\n\\n            i--;\\n        }\\n\\n        emit EthClaimed(destAddr, i);\\n    }\\n\\n    /**\\n     * @dev Player's balance in L7L.\\n     *\\n     * @param dest The creditor's address.\\n     */\\n    function balanceOfL7l(address dest) public view returns (uint256) {\\n        return TrustedL7lLedger.depositsOf(dest);\\n    }\\n\\n    /**\\n     * @dev Credit player's balance in L7L.\\n     *\\n     * @param dest The creditor's address.\\n     * @param amount Credit amount in L7L.\\n     */\\n    function rewardL7l(address dest, uint256 amount) external onlyLotteries {\\n        TrustedL7lLedger.depositFor(dest, amount);\\n        emit L7lRewarded(dest, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw all player's balance in L7L.\\n     *\\n     * @param dest The creditor's address.\\n     */\\n    function withdrawL7l(address dest) external {\\n        require(msg.sender == dest || msg.sender == TrustedGovernance.manager(), \\\"Access denied\\\");\\n        TrustedL7lLedger.withdraw(dest);\\n        emit AllL7lClaimed(dest);\\n    }\\n\\n    /**\\n     * @dev Returns total amount of Booty contracts in Treasury.\\n     */\\n    function totalBooties() public view returns(uint) {\\n        return allBooties.length;\\n    }\\n}\\n\\n/** \\n * @title Factory for Booty contacts.\\n *\\n * @dev We use this technical wrapper contract to reduce size of Treasury contract.\\n */\\ncontract BootyBuilder {\\n    address private immutable publisher;\\n\\n    /** \\n     * @dev Internal Treasury helper contract.\\n     */\\n    constructor(address _publisher) public {\\n        publisher = _publisher;\\n    }\\n\\n    /**\\n     * @dev Create new booty contract for lottery.\\n     *\\n     * @param _governance Orchestration contract.\\n     * @param _lottery Lottery address for which the Booty is created.\\n     */\\n    function createBooty(address _governance, address _lottery) external returns(address) {\\n        require(msg.sender == publisher, \\\"Unauthorized\\\");\\n        Booty TrustedBooty = new Booty(_governance, _lottery);\\n        return address(TrustedBooty);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/BootyInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface BootyInterface {\\n    function greenBet(address payable sender) external payable;\\n    function blueBet(address payable sender) external payable;\\n\\n    function declareBlueWin() external;\\n    function declareGreenWin() external;\\n    function declareDraw() external;\\n    function useForRound(uint32) external;\\n    function recycleForRound(uint32) external returns (address, uint256, address, uint256);\\n    function forceRecycle() external;\\n\\n    function readiness() external view returns(uint8);\\n    function totalShares() external view returns(uint256);\\n    function totalBlue() external view returns(uint256);\\n    function totalGreen() external view returns(uint256);\\n\\n    function losesOf(address) external view returns(uint256);\\n    function lockedBalanceOf(address) external view returns(uint256);\\n    function unlockedBalanceOf(address) external view returns(uint256);\\n\\n    function release(address payable) external;\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/GovernanceInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface GovernanceInterface {\\n    function owner() external view returns (address);\\n    function manager() external view returns (address);\\n    function isManagement(address) external view returns (bool);\\n    function beneficiary() external view returns (address payable);\\n    function treasuryContract() external view returns (address);\\n    function lotteryContracts(address) external view returns (bool);\\n    function timeToClaimBooty() external view returns (uint);\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/L7lLedgerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface L7lLedgerInterface {\\n    function depositsOf(address payee) external view returns(uint256);\\n    function depositFor(address dest, uint256 amount) external;\\n    function withdraw(address payee) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"AllL7lClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"booty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"error\",\"type\":\"string\"}],\"name\":\"EthClaimFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedBooties\",\"type\":\"uint256\"}],\"name\":\"EthClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"L7lRewarded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NO_PAYMENT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NO_SHARES\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TrustedBooties\",\"outputs\":[{\"internalType\":\"contract BootyInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TrustedGovernance\",\"outputs\":[{\"internalType\":\"contract GovernanceInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TrustedL7lLedger\",\"outputs\":[{\"internalType\":\"contract L7lLedgerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBooties\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"balanceOfL7l\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createBooty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bootyContract\",\"type\":\"address\"}],\"name\":\"registerPlayerBooty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardL7l\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBooties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"withdrawL7l\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"withdrawPayments\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Treasury","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e60fb30a5988495789281dafd8ab47f62af0fee30000000000000000000000000d4178497456fb77937b0a6c5d0283e5f11f63ad","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}