{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.7\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\nstruct List:\r\n    prev: uint256\r\n    next: uint256\r\n\r\n\r\nstruct Urn:\r\n    ink: uint256\r\n    art: uint256\r\n\r\n\r\nstruct ProtectedLiquidity:\r\n    provider: address\r\n    poolToken: address\r\n    reserveToken: address\r\n    poolAmount: uint256\r\n    reserveAmount: uint256\r\n    reserveRateN: uint256\r\n    reserveRateD: uint256\r\n    time: uint256\r\n\r\n\r\ninterface Vault:\r\n    def balanceOf(user: address) -> uint256: view\r\n    def getPricePerFullShare() -> uint256: view\r\n    def activation() -> uint256: view\r\n\r\n\r\ninterface DSProxyRegistry:\r\n    def proxies(user: address) -> address: view\r\n\r\n\r\ninterface DssCdpManager:\r\n    def count(user: address) -> uint256: view\r\n    def first(user: address) -> uint256: view\r\n    def list(cdp: uint256) -> List: view\r\n    def ilks(cdp: uint256) -> bytes32: view\r\n    def urns(cdp: uint256) -> address: view\r\n\r\n\r\ninterface Vat:\r\n    def urns(ilk: bytes32, user: address) -> Urn: view\r\n\r\n\r\ninterface Bancor:\r\n    def protectedLiquidityCount(provider: address) -> uint256: view\r\n    def protectedLiquidityId(provider: address, index: uint256) -> uint256: view\r\n    def protectedLiquidity(_id: uint256) -> ProtectedLiquidity: view\r\n\r\n\r\nevent GuestInvited:\r\n    guest: address\r\n\r\n\r\nevent BouncerAdded:\r\n    bouncer: address\r\n\r\n\r\nMIN_BAG: constant(uint256) = 10 ** 18\r\nAPE_OUT: constant(uint256) = 30 * 86400\r\nbouncers: public(HashMap[address, bool])\r\nguests: public(HashMap[address, bool])\r\nbribe_cost: public(uint256)\r\nyfi: ERC20\r\nygov: ERC20\r\nyyfi: Vault\r\nproxy_registry: DSProxyRegistry\r\ncdp_manager: DssCdpManager\r\nvat: Vat\r\nilk: bytes32\r\nuni_pairs: address[3]\r\nbancor: Bancor\r\n\r\n\r\n@external\r\ndef __init__():\r\n    self.bouncers[msg.sender] = True\r\n    # tokens\r\n    self.yfi = ERC20(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e)\r\n    self.ygov = ERC20(0xBa37B002AbaFDd8E89a1995dA52740bbC013D992)\r\n    self.yyfi = Vault(0xBA2E7Fed597fd0E3e70f5130BcDbbFE06bB94fe1)\r\n    # makerdao\r\n    self.proxy_registry = DSProxyRegistry(0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4)\r\n    self.cdp_manager = DssCdpManager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39)\r\n    self.vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B)\r\n    yfi_a: Bytes[32] = b\"YFI-A\"\r\n    self.ilk = convert(yfi_a, bytes32)\r\n    # liquidity providers\r\n    self.uni_pairs = [\r\n        0x2fDbAdf3C4D5A8666Bc06645B8358ab803996E28,  # Uniswap YFI/WETH\r\n        0x088ee5007C98a9677165D78dD2109AE4a3D04d0C,  # Sushiswap YFI/WETH\r\n        0x41284a88D970D3552A26FaE680692ED40B34010C,  # Balancer YFI/WETH 50/50\r\n    ]\r\n    self.bancor = Bancor(0xf5FAB5DBD2f3bf675dE4cB76517d4767013cfB55)\r\n\r\n    log BouncerAdded(msg.sender)\r\n\r\n\r\n@view\r\n@internal\r\ndef yfi_in_vault(user: address) -> uint256:\r\n    return self.yyfi.balanceOf(user) * self.yyfi.getPricePerFullShare() / 10 ** 18\r\n\r\n\r\n@view\r\n@internal\r\ndef yfi_in_makerdao(user: address) -> uint256:\r\n    proxy: address = self.proxy_registry.proxies(user)\r\n    if proxy == ZERO_ADDRESS:\r\n        return 0\r\n    cdp: uint256 = self.cdp_manager.first(proxy)\r\n    urn: address = ZERO_ADDRESS\r\n    total: uint256 = 0\r\n    for i in range(100):\r\n        if cdp == 0:\r\n            break\r\n        if self.cdp_manager.ilks(cdp) == self.ilk:\r\n            urn = self.cdp_manager.urns(cdp)\r\n            total += self.vat.urns(self.ilk, urn).ink        \r\n        cdp = self.cdp_manager.list(cdp).next\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef yfi_in_liquidity_pools(user: address) -> uint256:\r\n    total: uint256 = 0\r\n    for pair in self.uni_pairs:\r\n        total += self.yfi.balanceOf(pair) * ERC20(pair).balanceOf(user) / ERC20(pair).totalSupply()\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef yfi_in_bancor(user: address) -> uint256:\r\n    total: uint256 = 0\r\n    id: uint256 = 0\r\n    count: uint256 = self.bancor.protectedLiquidityCount(user)\r\n    liquidity: ProtectedLiquidity = empty(ProtectedLiquidity)\r\n    for i in range(100):\r\n        if i == count:\r\n            break\r\n        id = self.bancor.protectedLiquidityId(user, i)\r\n        liquidity = self.bancor.protectedLiquidity(id)\r\n        if liquidity.reserveToken == self.yfi.address:\r\n            total += liquidity.reserveAmount\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef _entrance_cost(start: uint256) -> uint256:\r\n    elapsed: uint256 = min(block.timestamp - start, APE_OUT)\r\n    return MIN_BAG - MIN_BAG * elapsed / APE_OUT\r\n\r\n\r\n@view\r\n@internal\r\ndef enough_yfi(user: address, threshold: uint256) -> bool:\r\n    # gas-optimized, exits as soon as threshold is reached\r\n    total: uint256 = 0\r\n    total += self.yfi.balanceOf(user)\r\n    if total >= threshold:\r\n        return True\r\n    total += self.ygov.balanceOf(user)\r\n    if total >= threshold:\r\n        return True\r\n    total += self.yfi_in_vault(user)\r\n    if total >= threshold:\r\n        return True\r\n    total += self.yfi_in_liquidity_pools(user)\r\n    if total >= threshold:\r\n        return True\r\n    total += self.yfi_in_makerdao(user)\r\n    if total >= threshold:\r\n        return True\r\n    total += self.yfi_in_bancor(user)\r\n    if total >= threshold:\r\n        return True\r\n    return False\r\n\r\n# EXTERNAL FUNCTIONS\r\n\r\n@view\r\n@external\r\ndef min_bag() -> uint256:\r\n    return MIN_BAG\r\n\r\n\r\n@view\r\n@external\r\ndef ape_out() -> uint256:\r\n    return APE_OUT\r\n\r\n\r\n@external\r\ndef invite_guest(guest: address):\r\n    \"\"\"\r\n    Invite a guest to the party.\r\n    \"\"\"\r\n    assert self.bouncers[msg.sender]  # dev: unauthorized\r\n    assert not self.guests[guest]  # dev: already invited\r\n    self.guests[guest] = True\r\n    log GuestInvited(guest)\r\n\r\n\r\n@external\r\ndef add_bouncer(bouncer: address):\r\n    \"\"\"\r\n    Hire an additional bouncer.\r\n    \"\"\"\r\n    assert self.bouncers[msg.sender]  # dev: unauthorized\r\n    assert not self.bouncers[bouncer]  # dev: already a bouncer\r\n    self.bouncers[bouncer] = True\r\n    log BouncerAdded(bouncer)\r\n\r\n\r\n@view\r\n@external\r\ndef total_yfi(user: address) -> uint256:\r\n    \"\"\"\r\n    Total YFI in wallet, yGov, yYFI Vault, MakerDAO, Uniswap, Sushiswap, Balancer, Bancor.\r\n    \"\"\"\r\n    return (\r\n        self.yfi.balanceOf(user)\r\n        + self.ygov.balanceOf(user)\r\n        + self.yfi_in_vault(user)\r\n        + self.yfi_in_makerdao(user)\r\n        + self.yfi_in_liquidity_pools(user)\r\n        + self.yfi_in_bancor(user)\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef entrance_cost(start: uint256) -> uint256:\r\n    \"\"\"\r\n    How much productive YFI is currently needed to enter.\r\n    \"\"\"\r\n    return self._entrance_cost(start)\r\n\r\n\r\n@view\r\n@external\r\ndef authorized(guest: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    Check if a user with a bag of certain size is allowed to the party.\r\n    \"\"\"\r\n    if self.guests[guest]:\r\n        return True\r\n    # NOTE: msg.sender must implement `activation()`\r\n    start: uint256 = Vault(msg.sender).activation()\r\n    if block.timestamp >= start + APE_OUT:\r\n        return True\r\n    threshold: uint256 = self._entrance_cost(start)\r\n    return self.enough_yfi(guest, threshold)","ABI":"[{\"name\":\"GuestInvited\",\"inputs\":[{\"type\":\"address\",\"name\":\"guest\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BouncerAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"bouncer\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"min_bag\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":441},{\"name\":\"ape_out\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":471},{\"name\":\"invite_guest\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"guest\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39032},{\"name\":\"add_bouncer\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"bouncer\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39062},{\"name\":\"total_yfi\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"user\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1209670},{\"name\":\"entrance_cost\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"start\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1928},{\"name\":\"authorized\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"guest\"},{\"type\":\"uint256\",\"name\":\"amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2418876},{\"name\":\"bouncers\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1666},{\"name\":\"guests\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1696},{\"name\":\"bribe_cost\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1511}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}