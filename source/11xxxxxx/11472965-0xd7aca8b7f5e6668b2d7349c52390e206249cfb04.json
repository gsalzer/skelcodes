{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/ILido.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title Liquid staking pool\\n  *\\n  * For the high-level description of the pool operation please refer to the paper.\\n  * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side\\n  * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,\\n  * only a small portion (buffer) of it.\\n  * It also mints new tokens for rewards generated at the ETH 2.0 side.\\n  */\\ninterface ILido {\\n    /**\\n      * @notice Stop pool routine operations\\n      */\\n    function stop() external;\\n\\n    /**\\n      * @notice Resume pool routine operations\\n      */\\n    function resume() external;\\n\\n    event Stopped();\\n    event Resumed();\\n\\n\\n    /**\\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\\n      * @param _feeBasisPoints Fee rate, in basis points\\n      */\\n    function setFee(uint16 _feeBasisPoints) external;\\n\\n    /**\\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\\n      */\\n    function setFeeDistribution(\\n        uint16 _treasuryFeeBasisPoints,\\n        uint16 _insuranceFeeBasisPoints,\\n        uint16 _operatorsFeeBasisPoints)\\n        external;\\n\\n    /**\\n      * @notice Returns staking rewards fee rate\\n      */\\n    function getFee() external view returns (uint16 feeBasisPoints);\\n\\n    /**\\n      * @notice Returns fee distribution proportion\\n      */\\n    function getFeeDistribution() external view returns (uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints,\\n                                                         uint16 operatorsFeeBasisPoints);\\n\\n    event FeeSet(uint16 feeBasisPoints);\\n\\n    event FeeDistributionSet(uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints);\\n\\n\\n    /**\\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\\n      *        the deposit_contract.deposit function\\n      */\\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;\\n\\n    /**\\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\\n      */\\n    function getWithdrawalCredentials() external view returns (bytes);\\n\\n\\n    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);\\n\\n\\n    /**\\n      * @notice Ether on the ETH 2.0 side reported by the oracle\\n      * @param _epoch Epoch id\\n      * @param _eth2balance Balance in wei on the ETH 2.0 side\\n      */\\n    function pushBeacon(uint256 _epoch, uint256 _eth2balance) external;\\n\\n\\n    // User functions\\n\\n    /**\\n      * @notice Adds eth to the pool\\n      * @return StETH Amount of StETH generated\\n      */\\n    function submit(address _referral) external payable returns (uint256 StETH);\\n\\n    // Records a deposit made by a user\\n    event Submitted(address indexed sender, uint256 amount, address referral);\\n\\n    // The `_amount` of ether was sent to the deposit_contract.deposit function.\\n    event Unbuffered(uint256 amount);\\n\\n    /**\\n      * @notice Issues withdrawal request. Large withdrawals will be processed only after the phase 2 launch.\\n      * @param _amount Amount of StETH to burn\\n      * @param _pubkeyHash Receiving address\\n      */\\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external;\\n\\n    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,\\n    // `sentFromBuffer` was sent on the current Ethereum side.\\n    event Withdrawal(address indexed sender, uint256 tokenAmount, uint256 sentFromBuffer,\\n                     bytes32 indexed pubkeyHash, uint256 etherAmount);\\n\\n\\n    // Info functions\\n\\n    /**\\n      * @notice Gets the amount of Ether controlled by the system\\n      */\\n    function getTotalPooledEther() external view returns (uint256);\\n\\n    /**\\n      * @notice Gets the amount of Ether temporary buffered on this contract balance\\n      */\\n    function getBufferedEther() external view returns (uint256);\\n\\n    /**\\n      * @notice Returns the key values related to Beacon-side\\n      * @return depositedValidators - number of deposited validators\\n      * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\\n      * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\\n      */\\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/LidoOracle.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.4.24;\\n\\nimport \\\"@aragon/os/contracts/apps/AragonApp.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath64.sol\\\";\\n\\nimport \\\"../interfaces/ILidoOracle.sol\\\";\\nimport \\\"../interfaces/ILido.sol\\\";\\n\\nimport \\\"./Algorithm.sol\\\";\\nimport \\\"./BitOps.sol\\\";\\n\\n\\n/**\\n  * @title Implementation of an ETH 2.0 -> ETH oracle\\n  *\\n  * The goal of the oracle is to inform other parts of the system about balances controlled\\n  * by the DAO on the ETH 2.0 side. The balances can go up because of reward accumulation\\n  * and can go down because of slashing.\\n  *\\n  * The timeline is divided into consecutive reportIntervals. At most one data point is produced per reportInterval.\\n  * A data point is considered finalized (produced) as soon as `quorum` oracle committee members\\n  * send data.\\n  * There can be gaps in data points if for some point `quorum` is not reached.\\n  * It's prohibited to add data to non-current data points whatever finalized or not.\\n  * It's prohibited to add data to the current finalized data point.\\n  */\\ncontract LidoOracle is ILidoOracle, AragonApp {\\n    using SafeMath for uint256;\\n    using SafeMath64 for uint64;\\n    using BitOps for uint256;\\n\\n    struct BeaconSpec {\\n        uint64 epochsPerFrame;\\n        uint64 slotsPerEpoch;\\n        uint64 secondsPerSlot;\\n        uint64 genesisTime;\\n    }\\n\\n    struct Report {\\n        uint128 beaconBalance;\\n        uint128 beaconValidators;\\n    }\\n\\n    struct EpochData {\\n        uint256 reportsBitMask;\\n        mapping (uint256 => Report) reports;\\n    }\\n\\n    /// ACL\\n    bytes32 constant public MANAGE_MEMBERS = keccak256(\\\"MANAGE_MEMBERS\\\");\\n    bytes32 constant public MANAGE_QUORUM = keccak256(\\\"MANAGE_QUORUM\\\");\\n    bytes32 constant public SET_BEACON_SPEC = keccak256(\\\"SET_BEACON_SPEC\\\");\\n\\n    /// @dev Maximum number of oracle committee members\\n    uint256 public constant MAX_MEMBERS = 256;\\n\\n    uint256 internal constant MEMBER_NOT_FOUND = uint256(-1);\\n\\n    /// @dev oracle committee members\\n    address[] private members;\\n    /// @dev number of the committee members required to finalize a data point\\n    bytes32 internal constant QUORUM_POSITION = keccak256(\\\"lido.LidoOracle.quorum\\\");\\n\\n    /// @dev link to the Lido contract\\n    bytes32 internal constant LIDO_POSITION = keccak256(\\\"lido.LidoOracle.lido\\\");\\n\\n    /// @dev storage for actual beacon chain specs\\n    bytes32 internal constant BEACON_SPEC_POSITION = keccak256(\\\"lido.LidoOracle.beaconSpec\\\");\\n\\n    /// @dev the most early epoch that can be reported\\n    bytes32 internal constant MIN_REPORTABLE_EPOCH_ID_POSITION = keccak256(\\\"lido.LidoOracle.minReportableEpochId\\\");\\n    /// @dev the last reported epoch\\n    bytes32 internal constant LAST_REPORTED_EPOCH_ID_POSITION = keccak256(\\\"lido.LidoOracle.lastReportedEpochId\\\");\\n    /// @dev storage for all gathered from reports data\\n    mapping(uint256 => EpochData) private gatheredEpochData;\\n\\n    event Completed(\\n        uint256 epochId,\\n        uint128 beaconBalance,\\n        uint128 beaconValidators\\n    );\\n\\n    function initialize(\\n        address _lido,\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime\\n    )\\n        public onlyInit\\n    {\\n        assert(1 == ((1 << (MAX_MEMBERS - 1)) >> (MAX_MEMBERS - 1)));  // static assert\\n\\n        require(_epochsPerFrame > 0, \\\"BAD_EPOCHS_PER_FRAME\\\");\\n        require(_slotsPerEpoch > 0, \\\"BAD_SLOTS_PER_EPOCH\\\");\\n        require(_secondsPerSlot > 0, \\\"BAD_SECONDS_PER_SLOT\\\");\\n        require(_genesisTime > 0, \\\"BAD_GENESIS_TIME\\\");\\n\\n        LIDO_POSITION.setStorageAddress(_lido);\\n\\n        _setBeaconSpec(\\n            _epochsPerFrame,\\n            _slotsPerEpoch,\\n            _secondsPerSlot,\\n            _genesisTime\\n        );\\n\\n        initialized();\\n    }\\n\\n    /**\\n      * @notice Add `_member` to the oracle member committee\\n      * @param _member Address of a member to add\\n      */\\n    function addOracleMember(address _member) external auth(MANAGE_MEMBERS) {\\n        require(members.length < MAX_MEMBERS, \\\"TOO_MANY_MEMBERS\\\");\\n        require(address(0) != _member, \\\"BAD_ARGUMENT\\\");\\n        require(MEMBER_NOT_FOUND == _getMemberId(_member), \\\"MEMBER_EXISTS\\\");\\n\\n        members.push(_member);\\n\\n        // set quorum to 1 when first member added\\n        if (1 == members.length) {\\n            QUORUM_POSITION.setStorageUint256(1);\\n        }\\n\\n        emit MemberAdded(_member);\\n        _assertInvariants();\\n    }\\n\\n    /**\\n     * @notice Remove `_member` from the oracle member committee\\n     * @param _member Address of a member to remove\\n     */\\n    function removeOracleMember(address _member) external auth(MANAGE_MEMBERS) {\\n        require(members.length > getQuorum(), \\\"QUORUM_WONT_BE_MADE\\\");\\n\\n        uint256 index = _getMemberId(_member);\\n        require(index != MEMBER_NOT_FOUND, \\\"MEMBER_NOT_FOUND\\\");\\n\\n        uint256 lastReportedEpochId = (\\n            LAST_REPORTED_EPOCH_ID_POSITION.getStorageUint256()\\n        );\\n\\n        MIN_REPORTABLE_EPOCH_ID_POSITION.setStorageUint256(lastReportedEpochId);\\n        uint256 last = members.length.sub(1);\\n\\n        uint256 bitMask = gatheredEpochData[lastReportedEpochId].reportsBitMask;\\n        if (index != last) {\\n            members[index] = members[last];\\n            bitMask = bitMask.setBit(index, bitMask.getBit(last));\\n        }\\n        bitMask = bitMask.setBit(last, false);\\n        gatheredEpochData[lastReportedEpochId].reportsBitMask = bitMask;\\n\\n        members.length--;\\n\\n        emit MemberRemoved(_member);\\n        _assertInvariants();\\n    }\\n\\n    /**\\n     * @notice Set the number of oracle members required to form a data point to `_quorum`\\n     */\\n    function setQuorum(uint256 _quorum) external auth(MANAGE_QUORUM) {\\n        require(members.length >= _quorum && 0 != _quorum, \\\"QUORUM_WONT_BE_MADE\\\");\\n\\n        QUORUM_POSITION.setStorageUint256(_quorum);\\n        emit QuorumChanged(_quorum);\\n\\n        uint256 minReportableEpochId = (\\n            MIN_REPORTABLE_EPOCH_ID_POSITION.getStorageUint256()\\n        );\\n        uint256 lastReportedEpochId = (\\n            LAST_REPORTED_EPOCH_ID_POSITION.getStorageUint256()\\n        );\\n\\n        assert(lastReportedEpochId <= getCurrentEpochId());\\n\\n        if (lastReportedEpochId > minReportableEpochId) {\\n            minReportableEpochId = lastReportedEpochId;\\n            _tryPush(lastReportedEpochId);\\n        }\\n\\n        _assertInvariants();\\n    }\\n\\n    /**\\n     * @notice An oracle committee member reports data from the ETH 2.0 side\\n     * @param _epochId BeaconChain epoch id\\n     * @param _beaconBalance Balance in wei on the ETH 2.0 side\\n     * @param _beaconValidators Number of validators visible on this epoch\\n     */\\n    function reportBeacon(uint256 _epochId, uint128 _beaconBalance, uint128 _beaconValidators) external {\\n        (uint256 startEpoch, uint256 endEpoch) = getCurrentReportableEpochs();\\n        require(_epochId >= startEpoch, \\\"EPOCH_IS_TOO_OLD\\\");\\n        require(_epochId <= endEpoch, \\\"EPOCH_HAS_NOT_YET_BEGUN\\\");\\n\\n        address member = msg.sender;\\n        uint256 index = _getMemberId(member);\\n        require(index != MEMBER_NOT_FOUND, \\\"MEMBER_NOT_FOUND\\\");\\n\\n        // check & set contribution flag\\n        uint256 bitMask = gatheredEpochData[_epochId].reportsBitMask;\\n        require(!bitMask.getBit(index), \\\"ALREADY_SUBMITTED\\\");\\n\\n        LAST_REPORTED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\\n\\n        gatheredEpochData[_epochId].reportsBitMask = bitMask.setBit(index, true);\\n\\n        Report memory currentReport = Report(_beaconBalance, _beaconValidators);\\n        gatheredEpochData[_epochId].reports[index] = currentReport;\\n\\n        _tryPush(_epochId);\\n    }\\n\\n    /**\\n     * @notice Returns all needed to oracle daemons data\\n     */\\n    function getCurrentFrame()\\n        external view\\n        returns (\\n            uint256 frameEpochId,\\n            uint256 frameStartTime,\\n            uint256 frameEndTime\\n        )\\n    {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        uint64 genesisTime = beaconSpec.genesisTime;\\n        uint64 epochsPerFrame = beaconSpec.epochsPerFrame;\\n        uint64 secondsPerEpoch = beaconSpec.secondsPerSlot.mul(beaconSpec.slotsPerEpoch);\\n\\n        frameEpochId = getCurrentEpochId().div(epochsPerFrame).mul(epochsPerFrame);\\n        frameStartTime = frameEpochId.mul(secondsPerEpoch).add(genesisTime);\\n\\n        uint256 nextFrameEpochId = frameEpochId.div(epochsPerFrame).add(1).mul(epochsPerFrame);\\n        frameEndTime = nextFrameEpochId.mul(secondsPerEpoch).add(genesisTime).sub(1);\\n    }\\n\\n    /**\\n     * @notice Returns the current oracle member committee\\n     */\\n    function getOracleMembers() external view returns (address[]) {\\n        return members;\\n    }\\n\\n    /**\\n     * @notice Returns the Lido contract address\\n     */\\n    function getLido() public view returns (ILido) {\\n        return ILido(LIDO_POSITION.getStorageAddress());\\n    }\\n\\n    /**\\n     * @notice Set beacon specs\\n     */\\n    function setBeaconSpec(\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime\\n    )\\n        public auth(SET_BEACON_SPEC)\\n    {\\n        require(_epochsPerFrame > 0, \\\"BAD_EPOCHS_PER_FRAME\\\");\\n        require(_slotsPerEpoch > 0, \\\"BAD_SLOTS_PER_EPOCH\\\");\\n        require(_secondsPerSlot > 0, \\\"BAD_SECONDS_PER_SLOT\\\");\\n        require(_genesisTime > 0, \\\"BAD_GENESIS_TIME\\\");\\n\\n        _setBeaconSpec(\\n            _epochsPerFrame,\\n            _slotsPerEpoch,\\n            _secondsPerSlot,\\n            _genesisTime\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns beacon specs\\n     */\\n    function getBeaconSpec()\\n        public\\n        view\\n        returns (\\n            uint64 epochsPerFrame,\\n            uint64 slotsPerEpoch,\\n            uint64 secondsPerSlot,\\n            uint64 genesisTime\\n        )\\n    {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        return (\\n            beaconSpec.epochsPerFrame,\\n            beaconSpec.slotsPerEpoch,\\n            beaconSpec.secondsPerSlot,\\n            beaconSpec.genesisTime\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the number of oracle members required to form a data point\\n     */\\n    function getQuorum() public view returns (uint256) {\\n        return QUORUM_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Returns the epochId calculated from current timestamp\\n     */\\n    function getCurrentEpochId() public view returns (uint256) {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        return (\\n            _getTime()\\n            .sub(beaconSpec.genesisTime)\\n            .div(beaconSpec.slotsPerEpoch)\\n            .div(beaconSpec.secondsPerSlot)\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the fisrt and last epochs that can be reported\\n     */\\n    function getCurrentReportableEpochs()\\n        public view\\n        returns (\\n            uint256 minReportableEpochId,\\n            uint256 maxReportableEpochId\\n        )\\n    {\\n        minReportableEpochId = (\\n            MIN_REPORTABLE_EPOCH_ID_POSITION.getStorageUint256()\\n        );\\n        return (minReportableEpochId, getCurrentEpochId());\\n    }\\n\\n    /**\\n     * @dev Sets beacon spec\\n     */\\n    function _setBeaconSpec(\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime\\n    )\\n        internal\\n    {\\n        uint256 data = (\\n            uint256(_epochsPerFrame) << 192 |\\n            uint256(_slotsPerEpoch) << 128 |\\n            uint256(_secondsPerSlot) << 64 |\\n            uint256(_genesisTime)\\n        );\\n        BEACON_SPEC_POSITION.setStorageUint256(data);\\n    }\\n\\n    /**\\n     * @dev Returns beaconSpec struct\\n     */\\n    function _getBeaconSpec()\\n        internal\\n        view\\n        returns (BeaconSpec memory beaconSpec)\\n    {\\n        uint256 data = BEACON_SPEC_POSITION.getStorageUint256();\\n        beaconSpec.epochsPerFrame = uint64(data >> 192);\\n        beaconSpec.slotsPerEpoch = uint64(data >> 128);\\n        beaconSpec.secondsPerSlot = uint64(data >> 64);\\n        beaconSpec.genesisTime = uint64(data);\\n        return beaconSpec;\\n    }\\n\\n    /**\\n     * @dev Returns if quorum reached and mode-value report\\n     * @return isQuorum - true, when quorum is reached, false otherwise\\n     * @return modeReport - valid mode-value report when quorum is reached, 0-data otherwise\\n     */\\n    function _getQuorumReport(uint256 _epochId) internal view returns (bool isQuorum, Report memory modeReport) {\\n        uint256 mask = gatheredEpochData[_epochId].reportsBitMask;\\n        uint256 popcnt = mask.popcnt();\\n        if (popcnt < getQuorum())\\n            return (false, Report({beaconBalance: 0, beaconValidators: 0}));\\n\\n        assert(0 != popcnt && popcnt <= members.length);\\n\\n        // pack current gatheredEpochData mapping to uint256 array\\n        uint256[] memory data = new uint256[](popcnt);\\n        uint256 i = 0;\\n        uint256 membersLength = members.length;\\n        for (uint256 index = 0; index < membersLength; ++index) {\\n            if (mask.getBit(index)) {\\n                data[i++] = reportToUint256(gatheredEpochData[_epochId].reports[index]);\\n            }\\n        }\\n\\n        assert(i == data.length);\\n\\n        // find mode value of this array\\n        (bool isUnimodal, uint256 mode) = Algorithm.mode(data);\\n        if (!isUnimodal)\\n            return (false, Report({beaconBalance: 0, beaconValidators: 0}));\\n\\n        // unpack Report struct from uint256\\n        modeReport = uint256ToReport(mode);\\n\\n        return (true, modeReport);\\n    }\\n\\n    /**\\n     * @dev Pushes the current data point if quorum is reached\\n     */\\n    function _tryPush(uint256 _epochId) internal {\\n        (bool isQuorum, Report memory modeReport) = _getQuorumReport(_epochId);\\n        if (!isQuorum)\\n            return;\\n\\n        // data for this frame is collected, now this frame is completed, so\\n        // minReportableEpochId should be changed to first epoch from next frame\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        MIN_REPORTABLE_EPOCH_ID_POSITION.setStorageUint256(\\n            _epochId\\n            .div(beaconSpec.epochsPerFrame)\\n            .add(1)\\n            .mul(beaconSpec.epochsPerFrame)\\n        );\\n\\n        emit Completed(_epochId, modeReport.beaconBalance, modeReport.beaconValidators);\\n\\n        ILido lido = getLido();\\n        if (address(0) != address(lido))\\n            lido.pushBeacon(modeReport.beaconValidators, modeReport.beaconBalance);\\n    }\\n\\n    function reportToUint256(Report _report) internal pure returns (uint256) {\\n        return uint256(_report.beaconBalance) << 128 | uint256(_report.beaconValidators);\\n    }\\n\\n    function uint256ToReport(uint256 _report) internal pure returns (Report) {\\n        Report memory report;\\n        report.beaconBalance = uint128(_report >> 128);\\n        report.beaconValidators = uint128(_report);\\n        return report;\\n    }\\n\\n    /**\\n     * @dev Returns member's index in the members array or MEMBER_NOT_FOUND\\n     */\\n    function _getMemberId(address _member) internal view returns (uint256) {\\n        uint256 length = members.length;\\n        for (uint256 i = 0; i < length; ++i) {\\n            if (members[i] == _member) {\\n                return i;\\n            }\\n        }\\n        return MEMBER_NOT_FOUND;\\n    }\\n\\n    /**\\n     * @dev Returns current timestamp\\n     */\\n    function _getTime() internal view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Checks code self-consistency\\n     */\\n    function _assertInvariants() private view {\\n        uint256 quorum = getQuorum();\\n        assert(quorum != 0 && members.length >= quorum);\\n        assert(members.length <= MAX_MEMBERS);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/apps/AragonApp.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./AppStorage.sol\\\";\\nimport \\\"../acl/ACLSyntaxSugar.sol\\\";\\nimport \\\"../common/Autopetrified.sol\\\";\\nimport \\\"../common/ConversionHelpers.sol\\\";\\nimport \\\"../common/ReentrancyGuard.sol\\\";\\nimport \\\"../common/VaultRecoverable.sol\\\";\\nimport \\\"../evmscript/EVMScriptRunner.sol\\\";\\n\\n\\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\\n// that they can never be initialized.\\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\\n// are included so that they are automatically usable by subclassing contracts\\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\\n    string private constant ERROR_AUTH_FAILED = \\\"APP_AUTH_FAILED\\\";\\n\\n    modifier auth(bytes32 _role) {\\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    modifier authP(bytes32 _role, uint256[] _params) {\\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\\n    * @param _sender Sender of the call\\n    * @param _role Role on this app\\n    * @param _params Permission params for the role\\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\\n    *         Always returns false if the app hasn't been initialized yet.\\n    */\\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\\n        if (!hasInitialized()) {\\n            return false;\\n        }\\n\\n        IKernel linkedKernel = kernel();\\n        if (address(linkedKernel) == address(0)) {\\n            return false;\\n        }\\n\\n        return linkedKernel.hasPermission(\\n            _sender,\\n            address(this),\\n            _role,\\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\\n        );\\n    }\\n\\n    /**\\n    * @dev Get the recovery vault for the app\\n    * @return Recovery vault address for the app\\n    */\\n    function getRecoveryVault() public view returns (address) {\\n        // Funds recovery via a vault is only available when used with a kernel\\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = _a * _b;\\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint256 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        uint256 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath64.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted for uint64, pragma ^0.4.24, and satisfying our linter rules\\n// Also optimized the mul() implementation, see https://github.com/aragon/aragonOS/pull/417\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath64\\n * @dev Math operations for uint64 with safety checks that revert on error\\n */\\nlibrary SafeMath64 {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH64_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH64_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH64_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH64_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint256 c = uint256(_a) * uint256(_b);\\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\\n\\n        return uint64(c);\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint64 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint64 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint64 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILidoOracle.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title ETH 2.0 -> ETH oracle\\n  *\\n  * The goal of the oracle is to inform other parts of the system about balances controlled\\n  * by the DAO on the ETH 2.0 side. The balances can go up because of reward accumulation\\n  * and can go down because of slashing.\\n  */\\ninterface ILidoOracle {\\n    /**\\n      * @notice Add `_member` to the oracle member committee\\n      * @param _member Address of a member to add\\n      */\\n    function addOracleMember(address _member) external;\\n\\n    /**\\n      * @notice Remove `_member` from the oracle member committee\\n      * @param _member Address of a member to remove\\n      */\\n    function removeOracleMember(address _member) external;\\n\\n    /**\\n      * @notice Returns the current oracle member committee\\n      */\\n    function getOracleMembers() external view returns (address[]);\\n\\n    /**\\n      * @notice Set the number of oracle members required to form a data point to `_quorum`\\n      */\\n    function setQuorum(uint256 _quorum) external;\\n\\n    /**\\n      * @notice Returns the number of oracle members required to form a data point\\n      */\\n    function getQuorum() external view returns (uint256);\\n\\n    event MemberAdded(address member);\\n    event MemberRemoved(address member);\\n    event QuorumChanged(uint256 quorum);\\n\\n    /**\\n      * @notice An oracle committee member reports data from the ETH 2.0 side\\n      * @param _epochId BeaconChain epoch id\\n      * @param _beaconBalance Balance in wei on the ETH 2.0 side\\n      * @param _beaconValidators Number of validators visible on this epoch\\n      */\\n    function reportBeacon(uint256 _epochId, uint128 _beaconBalance, uint128 _beaconValidators) external;\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/Algorithm.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\n\\n\\nlibrary Algorithm {\\n    using SafeMath for uint256;\\n\\n    /**\\n      * Computes mode of a non-empty array, if array is unimodal.\\n      * Low gas cost.\\n      */\\n    function mode(uint256[] data) internal pure returns (bool, uint256) {\\n\\n        assert(0 != data.length);\\n\\n        // allocate arrays\\n        uint256[] memory dataValues = new uint256[](data.length);\\n        uint256[] memory dataValuesCounts = new uint256[](data.length);\\n\\n        // initialize first element\\n        dataValues[0] = data[0];\\n        dataValuesCounts[0] = 1;\\n        uint256 dataValuesLength = 1;\\n\\n        // process data\\n        uint256 i = 0;\\n        uint256 j = 0;\\n        bool complete;\\n        for (i = 1; i < data.length; i++) {\\n            complete = true;\\n            for (j = 0; j < dataValuesLength; j++) {\\n                if (data[i] == dataValues[j]) {\\n                    dataValuesCounts[j]++;\\n                    complete = false;\\n                    break;\\n                }\\n            }\\n            if (complete) {\\n                dataValues[dataValuesLength] = data[i];\\n                dataValuesCounts[dataValuesLength]++;\\n                dataValuesLength++;\\n            }\\n        }\\n\\n        // find mode value index\\n        uint256 mostFrequentValueIndex = 0;\\n        for (i = 1; i < dataValuesLength; i++) {\\n            if (dataValuesCounts[i] > dataValuesCounts[mostFrequentValueIndex])\\n                mostFrequentValueIndex = i;\\n        }\\n\\n        // check if data is unimodal\\n        for (i = 0; i < dataValuesLength; i++) {\\n            if ((i != mostFrequentValueIndex) && (dataValuesCounts[i] == dataValuesCounts[mostFrequentValueIndex]))\\n                return (false, 0);\\n        }\\n\\n        return (true, dataValues[mostFrequentValueIndex]);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/BitOps.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\nlibrary BitOps {\\n    /**\\n      * @dev Gets n-th bit in a bitmask\\n      */\\n    function getBit(uint256 _mask, uint256 _bitIndex) internal pure returns (bool) {\\n        require(_bitIndex < 256);\\n        return 0 != (_mask & (1 << _bitIndex));\\n    }\\n\\n    /**\\n      * @dev Sets n-th bit in a bitmask\\n      */\\n    function setBit(uint256 _mask, uint256 _bitIndex, bool bit) internal pure returns (uint256) {\\n        require(_bitIndex < 256);\\n        if (bit) {\\n            return _mask | (1 << _bitIndex);\\n        } else {\\n            return _mask & (~(1 << _bitIndex));\\n        }\\n    }\\n\\n    /**\\n      * @dev Returns a population count - number of bits set in a number\\n      */\\n    function popcnt(uint256 _mask) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        uint256 tmp_mask = _mask;\\n        for (uint256 i = 0; i < 256; ++i) {\\n            if (1 == tmp_mask & 1) {\\n                result++;\\n            }\\n            tmp_mask >>= 1;\\n        }\\n\\n        assert(0 == tmp_mask);\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/apps/AppStorage.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\nimport \\\"../kernel/IKernel.sol\\\";\\n\\n\\ncontract AppStorage {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_POSITION = keccak256(\\\"aragonOS.appStorage.kernel\\\");\\n    bytes32 internal constant APP_ID_POSITION = keccak256(\\\"aragonOS.appStorage.appId\\\");\\n    */\\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\\n\\n    function kernel() public view returns (IKernel) {\\n        return IKernel(KERNEL_POSITION.getStorageAddress());\\n    }\\n\\n    function appId() public view returns (bytes32) {\\n        return APP_ID_POSITION.getStorageBytes32();\\n    }\\n\\n    function setKernel(IKernel _kernel) internal {\\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\\n    }\\n\\n    function setAppId(bytes32 _appId) internal {\\n        APP_ID_POSITION.setStorageBytes32(_appId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/acl/ACLSyntaxSugar.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract ACLSyntaxSugar {\\n    function arr() internal pure returns (uint256[]) {\\n        return new uint256[](0);\\n    }\\n\\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c);\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c, _d);\\n    }\\n\\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\\n    }\\n\\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\\n        r = new uint256[](1);\\n        r[0] = _a;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\\n        r = new uint256[](2);\\n        r[0] = _a;\\n        r[1] = _b;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        r = new uint256[](3);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        r = new uint256[](4);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        r = new uint256[](5);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n        r[4] = _e;\\n    }\\n}\\n\\n\\ncontract ACLHelpers {\\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 30));\\n    }\\n\\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 31));\\n    }\\n\\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\\n        a = uint32(_x);\\n        b = uint32(_x >> (8 * 4));\\n        c = uint32(_x >> (8 * 8));\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Autopetrified.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Petrifiable.sol\\\";\\n\\n\\ncontract Autopetrified is Petrifiable {\\n    constructor() public {\\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\\n        // This renders them uninitializable (and unusable without a proxy).\\n        petrify();\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/ConversionHelpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n\\nlibrary ConversionHelpers {\\n    string private constant ERROR_IMPROPER_LENGTH = \\\"CONVERSION_IMPROPER_LENGTH\\\";\\n\\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\\n        // Force cast the uint256[] into a bytes array, by overwriting its length\\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 byteLength = _input.length * 32;\\n        assembly {\\n            output := _input\\n            mstore(output, byteLength)\\n        }\\n    }\\n\\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\\n        // Force cast the bytes array into a uint256[], by overwriting its length\\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 intsLength = _input.length / 32;\\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\\n\\n        assembly {\\n            output := _input\\n            mstore(output, intsLength)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/ReentrancyGuard.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\n\\n\\ncontract ReentrancyGuard {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\\\"aragonOS.reentrancyGuard.mutex\\\");\\n    */\\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\\n\\n    string private constant ERROR_REENTRANT = \\\"REENTRANCY_REENTRANT_CALL\\\";\\n\\n    modifier nonReentrant() {\\n        // Ensure mutex is unlocked\\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\\n\\n        // Lock mutex before function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\\n\\n        // Perform function call\\n        _;\\n\\n        // Unlock mutex after function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/VaultRecoverable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\nimport \\\"./EtherTokenConstant.sol\\\";\\nimport \\\"./IsContract.sol\\\";\\nimport \\\"./IVaultRecoverable.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\\n    using SafeERC20 for ERC20;\\n\\n    string private constant ERROR_DISALLOWED = \\\"RECOVER_DISALLOWED\\\";\\n    string private constant ERROR_VAULT_NOT_CONTRACT = \\\"RECOVER_VAULT_NOT_CONTRACT\\\";\\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \\\"RECOVER_TOKEN_TRANSFER_FAILED\\\";\\n\\n    /**\\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\\n     *         but in case it does, this function allows one to recover them.\\n     * @param _token Token balance to be sent to recovery vault.\\n     */\\n    function transferToVault(address _token) external {\\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\\n        address vault = getRecoveryVault();\\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\\n\\n        uint256 balance;\\n        if (_token == ETH) {\\n            balance = address(this).balance;\\n            vault.transfer(balance);\\n        } else {\\n            ERC20 token = ERC20(_token);\\n            balance = token.staticBalanceOf(this);\\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\\n        }\\n\\n        emit RecoverToVault(vault, _token, balance);\\n    }\\n\\n    /**\\n    * @dev By default deriving from AragonApp makes it recoverable\\n    * @param token Token address that would be recovered\\n    * @return bool whether the app allows the recovery\\n    */\\n    function allowRecoverability(address token) public view returns (bool) {\\n        return true;\\n    }\\n\\n    // Cast non-implemented interface to be public so we can use it internally\\n    function getRecoveryVault() public view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/EVMScriptRunner.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\nimport \\\"./IEVMScriptRegistry.sol\\\";\\n\\nimport \\\"../apps/AppStorage.sol\\\";\\nimport \\\"../kernel/KernelConstants.sol\\\";\\nimport \\\"../common/Initializable.sol\\\";\\n\\n\\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \\\"EVMRUN_EXECUTOR_UNAVAILABLE\\\";\\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \\\"EVMRUN_PROTECTED_STATE_MODIFIED\\\";\\n\\n    /* This is manually crafted in assembly\\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\";\\n    */\\n\\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\\n\\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\\n    }\\n\\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\\n        return IEVMScriptRegistry(registryAddr);\\n    }\\n\\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\\n        internal\\n        isInitialized\\n        protectState\\n        returns (bytes)\\n    {\\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\\n\\n        bytes4 sig = executor.execScript.selector;\\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\\n\\n        bytes memory output;\\n        assembly {\\n            let success := delegatecall(\\n                gas,                // forward all gas\\n                executor,           // address\\n                add(data, 0x20),    // calldata start\\n                mload(data),        // calldata length\\n                0,                  // don't write output (we'll handle this ourselves)\\n                0                   // don't write output\\n            )\\n\\n            output := mload(0x40) // free mem ptr get\\n\\n            switch success\\n            case 0 {\\n                // If the call errored, forward its full error data\\n                returndatacopy(output, 0, returndatasize)\\n                revert(output, returndatasize)\\n            }\\n            default {\\n                switch gt(returndatasize, 0x3f)\\n                case 0 {\\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\\n                    // revert with \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\"\\n                    // See remix: doing a `revert(\\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\")` always results in\\n                    // this memory layout\\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\\n\\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\\n                }\\n                default {\\n                    // Copy result\\n                    //\\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\\n                    //    [ output length (32 bytes) ]\\n                    //    [ output content (N bytes) ]\\n                    //\\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\\n                    let copysize := sub(returndatasize, 0x20)\\n                    returndatacopy(output, 0x20, copysize)\\n\\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\\n                }\\n            }\\n        }\\n\\n        emit ScriptResult(address(executor), _script, _input, output);\\n\\n        return output;\\n    }\\n\\n    modifier protectState {\\n        address preKernel = address(kernel());\\n        bytes32 preAppId = appId();\\n        _; // exec\\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/UnstructuredStorage.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\nlibrary UnstructuredStorage {\\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function setStorageBool(bytes32 position, bool data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageAddress(bytes32 position, address data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageUint256(bytes32 position, uint256 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/kernel/IKernel.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../acl/IACL.sol\\\";\\nimport \\\"../common/IVaultRecoverable.sol\\\";\\n\\n\\ninterface IKernelEvents {\\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\\n}\\n\\n\\n// This should be an interface, but interfaces can't inherit yet :(\\ncontract IKernel is IKernelEvents, IVaultRecoverable {\\n    function acl() public view returns (IACL);\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n\\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/acl/IACL.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IACL {\\n    function initialize(address permissionsCreator) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/IVaultRecoverable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IVaultRecoverable {\\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\\n\\n    function transferToVault(address token) external;\\n\\n    function allowRecoverability(address token) external view returns (bool);\\n    function getRecoveryVault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Petrifiable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\n\\n\\ncontract Petrifiable is Initializable {\\n    // Use block UINT256_MAX (which should be never) as the initializable date\\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\\n\\n    function isPetrified() public view returns (bool) {\\n        return getInitializationBlock() == PETRIFIED_BLOCK;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract to prevent being initialized.\\n    *      Useful for freezing base contracts when they're used behind proxies.\\n    */\\n    function petrify() internal onlyInit {\\n        initializedAt(PETRIFIED_BLOCK);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Initializable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./TimeHelpers.sol\\\";\\nimport \\\"./UnstructuredStorage.sol\\\";\\n\\n\\ncontract Initializable is TimeHelpers {\\n    using UnstructuredStorage for bytes32;\\n\\n    // keccak256(\\\"aragonOS.initializable.initializationBlock\\\")\\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\\n\\n    string private constant ERROR_ALREADY_INITIALIZED = \\\"INIT_ALREADY_INITIALIZED\\\";\\n    string private constant ERROR_NOT_INITIALIZED = \\\"INIT_NOT_INITIALIZED\\\";\\n\\n    modifier onlyInit {\\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\\n        _;\\n    }\\n\\n    modifier isInitialized {\\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\\n        _;\\n    }\\n\\n    /**\\n    * @return Block number in which the contract was initialized\\n    */\\n    function getInitializationBlock() public view returns (uint256) {\\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n    * @return Whether the contract has been initialized by the time of the current block\\n    */\\n    function hasInitialized() public view returns (bool) {\\n        uint256 initializationBlock = getInitializationBlock();\\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization has finished.\\n    */\\n    function initialized() internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization to enable the contract\\n    *      at a future block number rather than immediately.\\n    */\\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/TimeHelpers.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Uint256Helpers.sol\\\";\\n\\n\\ncontract TimeHelpers {\\n    using Uint256Helpers for uint256;\\n\\n    /**\\n    * @dev Returns the current block number.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber() internal view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n    * @dev Returns the current block number, converted to uint64.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber64() internal view returns (uint64) {\\n        return getBlockNumber().toUint64();\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp() internal view returns (uint256) {\\n        return block.timestamp; // solium-disable-line security/no-block-members\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp, converted to uint64.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp64() internal view returns (uint64) {\\n        return getTimestamp().toUint64();\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Uint256Helpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n\\nlibrary Uint256Helpers {\\n    uint256 private constant MAX_UINT64 = uint64(-1);\\n\\n    string private constant ERROR_NUMBER_TOO_BIG = \\\"UINT64_NUMBER_TOO_BIG\\\";\\n\\n    function toUint64(uint256 a) internal pure returns (uint64) {\\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\\n        return uint64(a);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/token/ERC20.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n    function totalSupply() public view returns (uint256);\\n\\n    function balanceOf(address _who) public view returns (uint256);\\n\\n    function allowance(address _owner, address _spender)\\n        public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n\\n    function approve(address _spender, uint256 _value)\\n        public returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        public returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/EtherTokenConstant.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\\n// contracts where both tokens and ETH are accepted\\ncontract EtherTokenConstant {\\n    address internal constant ETH = address(0);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/IsContract.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract IsContract {\\n    /*\\n    * NOTE: this should NEVER be used for authentication\\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\\n    *\\n    * This is only intended to be used as a sanity check that an address is actually a contract,\\n    * RATHER THAN an address not being a contract.\\n    */\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly { size := extcodesize(_target) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/SafeERC20.sol\": {\r\n      \"content\": \"// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\n\\n\\nlibrary SafeERC20 {\\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\\n    // https://github.com/ethereum/solidity/issues/3544\\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\\n\\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \\\"SAFE_ERC_20_BALANCE_REVERTED\\\";\\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \\\"SAFE_ERC_20_ALLOWANCE_REVERTED\\\";\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool)\\n    {\\n        bool ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := eq(mload(ptr), 1)\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    function staticInvoke(address _addr, bytes memory _calldata)\\n        private\\n        view\\n        returns (bool, uint256)\\n    {\\n        bool success;\\n        uint256 ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            success := staticcall(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                ret := mload(ptr)\\n            }\\n        }\\n        return (success, ret);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            TRANSFER_SELECTOR,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, approveCallData);\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.balanceOf().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\\n            _token.balanceOf.selector,\\n            _owner\\n        );\\n\\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\\n\\n        return tokenBalance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.allowance().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\\n        bytes memory allowanceCallData = abi.encodeWithSelector(\\n            _token.allowance.selector,\\n            _owner,\\n            _spender\\n        );\\n\\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return allowance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.totalSupply().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\\n\\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return totalSupply;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IEVMScriptExecutor {\\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\\n    function executorType() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\n\\n\\ncontract EVMScriptRegistryConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\\\"evmreg\\\");\\n    */\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\\n}\\n\\n\\ninterface IEVMScriptRegistry {\\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\\n    function disableScriptExecutor(uint256 executorId) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/kernel/KernelConstants.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract KernelAppIds {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\\\"kernel\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\\\"acl\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\\\"vault\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\\n}\\n\\n\\ncontract KernelNamespaceConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\\\"core\\\");\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\\\"base\\\");\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\\\"app\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hasInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lido\",\"type\":\"address\"},{\"name\":\"_epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"_slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"_secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"_genesisTime\",\"type\":\"uint64\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_script\",\"type\":\"bytes\"}],\"name\":\"getEVMScriptExecutor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_QUORUM\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecoveryVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_epochId\",\"type\":\"uint256\"},{\"name\":\"_beaconBalance\",\"type\":\"uint128\"},{\"name\":\"_beaconValidators\",\"type\":\"uint128\"}],\"name\":\"reportBeacon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLido\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_MEMBERS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFrame\",\"outputs\":[{\"name\":\"frameEpochId\",\"type\":\"uint256\"},{\"name\":\"frameStartTime\",\"type\":\"uint256\"},{\"name\":\"frameEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowRecoverability\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"transferToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_BEACON_SPEC\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"},{\"name\":\"_params\",\"type\":\"uint256[]\"}],\"name\":\"canPerform\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEVMScriptRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addOracleMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quorum\",\"type\":\"uint256\"}],\"name\":\"setQuorum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPetrified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconSpec\",\"outputs\":[{\"name\":\"epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"genesisTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"_slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"_secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"_genesisTime\",\"type\":\"uint64\"}],\"name\":\"setBeaconSpec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MEMBERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentReportableEpochs\",\"outputs\":[{\"name\":\"minReportableEpochId\",\"type\":\"uint256\"},{\"name\":\"maxReportableEpochId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeOracleMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beaconBalance\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"beaconValidators\",\"type\":\"uint128\"}],\"name\":\"Completed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"script\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"ScriptResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"QuorumChanged\",\"type\":\"event\"}]","ContractName":"LidoOracle","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}