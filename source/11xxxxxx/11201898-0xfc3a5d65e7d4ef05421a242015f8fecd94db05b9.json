{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/PCToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Imports\\n\\nimport \\\"../libraries/BalancerSafeMath.sol\\\";\\nimport \\\"../libraries/BalancerConstants.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// Contracts\\n\\n/* solhint-disable func-order */\\n\\n/**\\n * @author Balancer Labs\\n * @title Highly opinionated token implementation\\n*/\\ncontract PCToken is IERC20 {\\n    using BalancerSafeMath for uint;\\n\\n    // State variables\\n    string public constant NAME = \\\"AlpacaSwap OmniPool\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    // No leading underscore per naming convention (non-private)\\n    // Cannot call totalSupply (name conflict)\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    uint internal varTotalSupply;\\n\\n    mapping(address => uint) private _balance;\\n    mapping(address => mapping(address => uint)) private _allowance;\\n\\n    string private _symbol;\\n    string private _name;\\n\\n    // Event declarations\\n\\n    // See definitions above; must be redeclared to be emitted from this contract\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // Function declarations\\n\\n    /**\\n     * @notice Base token constructor\\n     * @param tokenSymbol - the token symbol\\n     */\\n    constructor (string memory tokenSymbol, string memory tokenName) public {\\n        _symbol = tokenSymbol;\\n        _name = tokenName;\\n    }\\n\\n    // External functions\\n\\n    /**\\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\\n     * @param owner - owner of the tokens\\n     * @param spender - entity allowed to spend the tokens\\n     * @return uint - remaining amount spender is allowed to transfer\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Getter for current account balance\\n     * @param account - address we're checking the balance of\\n     * @return uint - token balance in the account\\n     */\\n    function balanceOf(address account) external view override returns (uint) {\\n        return _balance[account];\\n    }\\n\\n    /**\\n     * @notice Approve owner (sender) to spend a certain amount\\n     * @dev emits an Approval event\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        /* In addition to the increase/decreaseApproval functions, could\\n           avoid the \\\"approval race condition\\\" by only allowing calls to approve\\n           when the current approval amount is 0\\n        \\n           require(_allowance[msg.sender][spender] == 0, \\\"ERR_RACE_CONDITION\\\");\\n\\n           Some token contracts (e.g., KNC), already revert if you call approve \\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\\n           and safeApprove function when adding tokens to the pool.\\n        */\\n\\n        _allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\\n     * @dev emits an Approval event\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function increaseApproval(address spender, uint amount) external returns (bool) {\\n        _allowance[msg.sender][spender] = BalancerSafeMath.badd(_allowance[msg.sender][spender], amount);\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\\n     * @dev emits an Approval event\\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function decreaseApproval(address spender, uint amount) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][spender];\\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\\n        if (amount >= oldValue) {\\n            _allowance[msg.sender][spender] = 0;\\n        } else {\\n            _allowance[msg.sender][spender] = BalancerSafeMath.bsub(oldValue, amount);\\n        }\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer the given amount from sender (caller) to recipient\\n     * @dev _move emits a Transfer event if successful\\n     * @param recipient - entity receiving the tokens\\n     * @param amount - number of tokens being transferred\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\n     */\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n\\n        _move(msg.sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer the given amount from sender to recipient\\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\\n     * @param recipient - recipient of the tokens\\n     * @param amount - number of tokens being transferred\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\n     */\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \\\"ERR_PCTOKEN_BAD_CALLER\\\");\\n\\n        _move(sender, recipient, amount);\\n\\n        // memoize for gas optimization\\n        uint oldAllowance = _allowance[sender][msg.sender];\\n\\n        // If the sender is not the caller, adjust the allowance by the amount transferred\\n        if (msg.sender != sender && oldAllowance != uint(-1)) {\\n            _allowance[sender][msg.sender] = BalancerSafeMath.bsub(oldAllowance, amount);\\n\\n            emit Approval(msg.sender, recipient, _allowance[sender][msg.sender]);\\n        }\\n\\n        return true;\\n    }\\n\\n    // public functions\\n\\n    /**\\n     * @notice Getter for the total supply\\n     * @dev declared external for gas optimization\\n     * @return uint - total number of tokens in existence\\n     */\\n    function totalSupply() external view override returns (uint) {\\n        return varTotalSupply;\\n    }\\n\\n    // Public functions\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     *      We allow the user to set this name (as well as the symbol).\\n     *      Alternatives are 1) A fixed string (original design)\\n     *                       2) A fixed string plus the user-defined symbol\\n     *                          return string(abi.encodePacked(NAME, \\\"-\\\", _symbol));\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external pure returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // internal functions\\n\\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\\n    // Emit a transfer amount from the null address to this contract\\n    function _mint(uint amount) internal virtual {\\n        _balance[address(this)] = BalancerSafeMath.badd(_balance[address(this)], amount);\\n        varTotalSupply = BalancerSafeMath.badd(varTotalSupply, amount);\\n\\n        emit Transfer(address(0), address(this), amount);\\n    }\\n\\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\\n    // Emit a transfer amount from this contract to the null address\\n    function _burn(uint amount) internal virtual {\\n        // Can't burn more than we have\\n        // Remove require for gas optimization - bsub will revert on underflow\\n        // require(_balance[address(this)] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n\\n        _balance[address(this)] = BalancerSafeMath.bsub(_balance[address(this)], amount);\\n        varTotalSupply = BalancerSafeMath.bsub(varTotalSupply, amount);\\n\\n        emit Transfer(address(this), address(0), amount);\\n    }\\n\\n    // Transfer tokens from sender to recipient\\n    // Adjust balances, and emit a Transfer event\\n    function _move(address sender, address recipient, uint amount) internal virtual {\\n        // Can't send more than sender has\\n        // Remove require for gas optimization - bsub will revert on underflow\\n        // require(_balance[sender] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n\\n        _balance[sender] = BalancerSafeMath.bsub(_balance[sender], amount);\\n        _balance[recipient] = BalancerSafeMath.badd(_balance[recipient], amount);\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // Transfer from this contract to recipient\\n    // Emits a transfer event if successful\\n    function _push(address recipient, uint amount) internal {\\n        _move(address(this), recipient, amount);\\n    }\\n\\n    // Transfer from recipient to this contract\\n    // Emits a transfer event if successful\\n    function _pull(address sender, uint amount) internal {\\n        _move(sender, address(this), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BColor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\n// abstract contract BColor {\\n//     function getColor()\\n//         external view virtual\\n//         returns (bytes32);\\n// }\\n\\ncontract BBronze {\\n    function getColor()\\n        external pure\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\nimport \\\"./BColor.sol\\\";\\n\\ncontract BConst is BBronze {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    // uint public constant MAX_BOUND_TOKENS  = 8;              // not included - determined implicitly by governance\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    // uint public constant EXIT_FEE          = 0;              // moved to configurable param\\n\\n    uint public constant MIN_WEIGHT        = BONE;              // Future: make configurable to allow more weight granularity\\n    uint public constant MAX_WEIGHT        = BONE * 1000;       // Future: make configurable to allow more weight granularity\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 1000;       // Future: make configurable to allow more weight granularity\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\\n\\nimport \\\"./BPool.sol\\\";\\n\\n// Core contract; can't be changed. So disable solhint (reminder for v2)\\n\\n/* solhint-disable func-order */\\n/* solhint-disable event-name-camelcase */\\n\\ncontract BFactory is BBronze {\\n    event LOG_NEW_POOL(\\n        address indexed caller,\\n        address indexed pool\\n    );\\n\\n    event LOG_BLABS(\\n        address indexed caller,\\n        address indexed blabs\\n    );\\n\\n    mapping(address=>bool) private _isBPool;\\n\\n    function isBPool(address b)\\n        external view returns (bool)\\n    {\\n        return _isBPool[b];\\n    }\\n\\n    function newBPool()\\n        external\\n        returns (BPool)\\n    {\\n        BPool bpool = new BPool();\\n        _isBPool[address(bpool)] = true;\\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\\n        bpool.setController(msg.sender);\\n        return bpool;\\n    }\\n\\n    address private _blabs;\\n\\n    constructor() public {\\n        _blabs = msg.sender;\\n    }\\n\\n    function getBLabs()\\n        external view\\n        returns (address)\\n    {\\n        return _blabs;\\n    }\\n\\n    function setBLabs(address b)\\n        external\\n    {\\n        require(msg.sender == _blabs, \\\"ERR_NOT_BLABS\\\");\\n        emit LOG_BLABS(msg.sender, b);\\n        _blabs = b;\\n    }\\n\\n    function collect(BPool pool)\\n        external \\n    {\\n        require(msg.sender == _blabs, \\\"ERR_NOT_BLABS\\\");\\n        uint collected = IERC20(pool).balanceOf(address(this));\\n        bool xfer = pool.transfer(_blabs, collected);\\n        require(xfer, \\\"ERR_ERC20_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BMath is BBronze, BConst, BNum {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        //  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n      \\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight); \\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee,\\n        uint exitFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        // uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, exitFee));\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n     \\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side \\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee,\\n        uint exitFee\\n    )\\n        public pure\\n        returns (uint poolAmountIn)\\n    {\\n\\n        // charge swap fee on the output token side \\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee); \\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        // poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, exitFee));\\n        return poolAmountIn;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\nimport \\\"./BConst.sol\\\";\\n\\n// Core contract; can't be changed. So disable solhint (reminder for v2)\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\n// Core contract; can't be changed. So disable solhint (reminder for v2)\\n\\n/* solhint-disable func-order */\\n/* solhint-disable event-name-camelcase */\\n\\ncontract BPool is BBronze, BToken, BMath {\\n\\n    struct Record {\\n        bool bound;   // is token bound to pool\\n        uint index;   // private\\n        uint denorm;  // denormalized weight\\n        uint balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _factory;    // BFactory address to push token exitFee to\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    uint private _swapFee;\\n    uint private _exitFee;\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address=>Record) private  _records;\\n    uint private _totalWeight;\\n\\n    // fraction of the pool that has accrued due to fees since last fee harvest\\n    uint private _fracPoolFees;\\n\\n    constructor() public {\\n        _controller = msg.sender;\\n        _factory = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap()\\n        external view\\n        returns (bool)\\n    {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized()\\n        external view\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t)\\n        external view\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens()\\n        external view\\n        returns (uint) \\n    {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens()\\n        external view _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens()\\n        external view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function getNormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n    function getBalance(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _swapFee;\\n    }\\n\\n    function getFracPoolFees()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _fracPoolFees;\\n    }\\n\\n    function getController()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    function setSwapFee(uint swapFee)\\n        external\\n        _logs_\\n        _lock_\\n    { \\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n    }\\n\\n    function setExitFee(uint exitFee)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(exitFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _exitFee = exitFee;\\n    }\\n\\n    function getExitFee()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _exitFee;\\n    }\\n\\n    function setController(address manager)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _publicSwap = public_;\\n    }\\n\\n    // Not needed for ConfigurableRightsPool\\n    // function finalize()\\n    //     external\\n    //     _logs_\\n    //     _lock_\\n    // {\\n    //     require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    //     require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n    //     require(_tokens.length >= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n\\n    //     _finalized = true;\\n    //     _publicSwap = true;\\n\\n    //     _mintPoolShare(INIT_POOL_SUPPLY);\\n    //     _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    // }\\n\\n\\n    function bind(address token, uint balance, uint denorm)\\n        external\\n        _logs_\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        // No bound on max tokens in Alpaca\\n        // Governance determines how many and which tokens are included\\n        // require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0,    // balance and denorm will be validated\\n            balance: 0   // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(address token, uint balance, uint denorm)\\n        public\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm < oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }        \\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            // uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\n            // uint tokenExitFee = bmul(tokenBalanceWithdrawn, _exitFee);\\n            uint tokenExitFee = 0;\\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\n            // _pushUnderlying(token, _factory, tokenExitFee);\\n            // _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn);\\n        }\\n    }\\n\\n    function unbind(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        uint tokenBalance = _records[token].balance;\\n        // uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\n        // uint tokenExitFee = bmul(tokenBalance, _exitFee);\\n        uint tokenExitFee = 0;\\n\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            index: 0,\\n            denorm: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\n        _pushUnderlying(token, _factory, tokenExitFee);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    // function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n    //     external\\n    //     _logs_\\n    //     _lock_\\n    // {\\n    //     require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n    //     uint poolTotal = totalSupply();\\n    //     // uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    //     uint exitFee = bmul(poolAmountIn, _exitFee);\\n    //     uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n    //     uint ratio = bdiv(pAiAfterExitFee, poolTotal);\\n    //     require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    //     _pullPoolShare(msg.sender, poolAmountIn);\\n    //     _pushPoolShare(_factory, exitFee);\\n    //     _burnPoolShare(pAiAfterExitFee);\\n\\n    //     for (uint i = 0; i < _tokens.length; i++) {\\n    //         address t = _tokens[i];\\n    //         uint bal = _records[t].balance;\\n    //         uint tokenAmountOut = bmul(ratio, bal);\\n    //         require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n    //         require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n    //         _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n    //         emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n    //         _pushUnderlying(t, msg.sender, tokenAmountOut);\\n    //     }\\n    // }\\n\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");     \\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        uint fracPoolFeesTrade = calcFracPoolFeesFromSwap(tokenIn, tokenAmountIn);\\n        _updateFracPoolFees(fracPoolFeesTrade);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_ \\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        // Update the running fraction of the pool attributable to accumulated fees\\n        uint fracPoolFeesTrade = calcFracPoolFeesFromSwap(tokenIn, tokenAmountIn);\\n        _updateFracPoolFees(fracPoolFeesTrade);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n\\n    /* \\n        Unused functions in CRP - disable to keep size of BFactory down\\n    */\\n\\n    // function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\n    //     external\\n    //     _logs_\\n    //     _lock_\\n    //     returns (uint poolAmountOut)\\n\\n    // {\\n    //     require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n    //     require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n    //     require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n    //     Record storage inRecord = _records[tokenIn];\\n\\n    //     poolAmountOut = calcPoolOutGivenSingleIn(\\n    //                         inRecord.balance,\\n    //                         inRecord.denorm,\\n    //                         _totalSupply,\\n    //                         _totalWeight,\\n    //                         tokenAmountIn,\\n    //                         _swapFee\\n    //                     );\\n\\n    //     require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    //     inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n    //     emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n    //     _mintPoolShare(poolAmountOut);\\n    //     _pushPoolShare(msg.sender, poolAmountOut);\\n    //     _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n    //     // Update the running fraction of the pool attributable to accumulated fees\\n    //     uint fracPoolFeesTrade = calcFracPoolFeesFromPoolJoin(tokenIn, tokenAmountIn);\\n    //     _updateFracPoolFees(fracPoolFeesTrade);\\n        \\n    //     return poolAmountOut;\\n    // }\\n\\n    // function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\n    //     external\\n    //     _logs_\\n    //     _lock_\\n    //     returns (uint tokenAmountIn)\\n    // {\\n    //     require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n    //     require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n    //     Record storage inRecord = _records[tokenIn];\\n\\n    //     tokenAmountIn = calcSingleInGivenPoolOut(\\n    //                         inRecord.balance,\\n    //                         inRecord.denorm,\\n    //                         _totalSupply,\\n    //                         _totalWeight,\\n    //                         poolAmountOut,\\n    //                         _swapFee\\n    //                     );\\n\\n    //     require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    //     require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n        \\n    //     require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n    //     inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n    //     emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n    //     _mintPoolShare(poolAmountOut);\\n    //     _pushPoolShare(msg.sender, poolAmountOut);\\n    //     _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n    //     // Update the running fraction of the pool attributable to accumulated fees\\n    //     uint fracPoolFeesTrade = calcFracPoolFeesFromPoolJoin(tokenIn, tokenAmountIn);\\n    //     _updateFracPoolFees(fracPoolFeesTrade);\\n\\n    //     return tokenAmountIn;\\n    // }\\n\\n    // function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\n    //     external\\n    //     _logs_\\n    //     _lock_\\n    //     returns (uint tokenAmountOut)\\n    // {\\n    //     require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n    //     require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n    //     Record storage outRecord = _records[tokenOut];\\n\\n    //     tokenAmountOut = calcSingleOutGivenPoolIn(\\n    //                         outRecord.balance,\\n    //                         outRecord.denorm,\\n    //                         _totalSupply,\\n    //                         _totalWeight,\\n    //                         poolAmountIn,\\n    //                         _swapFee,\\n    //                         _exitFee\\n    //                     );\\n\\n    //     require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n        \\n    //     require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n    //     outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n    //     // uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    //     uint exitFee = bmul(poolAmountIn, _exitFee);\\n\\n    //     emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n    //     _pullPoolShare(msg.sender, poolAmountIn);\\n    //     _burnPoolShare(bsub(poolAmountIn, exitFee));\\n    //     _pushPoolShare(_factory, exitFee);\\n    //     _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    //     // Update the running fraction of the pool attributable to accumulated fees\\n    //     uint fracPoolFeesTrade = calcFracPoolFeesFromPoolExit(tokenOut, tokenAmountOut);\\n    //     _updateFracPoolFees(fracPoolFeesTrade);\\n\\n    //     return tokenAmountOut;\\n    // }\\n\\n    // function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\n    //     external\\n    //     _logs_\\n    //     _lock_\\n    //     returns (uint poolAmountIn)\\n    // {\\n    //     require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n    //     require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n    //     require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n    //     Record storage outRecord = _records[tokenOut];\\n\\n    //     poolAmountIn = calcPoolInGivenSingleOut(\\n    //                         outRecord.balance,\\n    //                         outRecord.denorm,\\n    //                         _totalSupply,\\n    //                         _totalWeight,\\n    //                         tokenAmountOut,\\n    //                         _swapFee,\\n    //                         _exitFee\\n    //                     );\\n\\n    //     require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    //     require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    //     outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n    //     // uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    //     uint exitFee = bmul(poolAmountIn, _exitFee);\\n\\n    //     emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n    //     _pullPoolShare(msg.sender, poolAmountIn);\\n    //     _burnPoolShare(bsub(poolAmountIn, exitFee));\\n    //     _pushPoolShare(_factory, exitFee);\\n    //     _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);        \\n\\n    //     // Update the running fraction of the pool attributable to accumulated fees\\n    //     uint fracPoolFeesTrade = calcFracPoolFeesFromPoolExit(tokenOut, tokenAmountOut);\\n    //     _updateFracPoolFees(fracPoolFeesTrade);\\n        \\n    //     return poolAmountIn;\\n    // }\\n\\n\\n    /*\\n        Internal function to upate the running fraction of the pool attributable to accumulated fees\\n\\n        Fee value as a percentage of the portfolio value at after trade t \\n        (that is, the one that brings us from state T=t-1 to T=t) \\n        if the input asset is i is:\\n\\n        F_{t,t} = w_i * (f * D_{i,t}) / B_{i,t}\\n\\n        where\\n\\n        f = fee\\n        D_{i,t} = amount of the input asset traded in to the pool for trade t\\n        f * D_{i,t} = the value of the fee for trade t in terms of asset i\\n        B_{i,t} = amount of input asset in the pool after trade t\\n        w_i = weight of input asset\\n        and V_t = B_{i,t} / w_i = the value of the poot after trade t in terms of asset i\\n\\n        For the total fee earned between T=0 and T=t, \\n        we need to dilute the previous total amount by the new fee ownership\\n\\n        That is, let G_{t} be the total accumulated fees between T=0 and T=t.  \\n        \\n        Then \\n\\n        G_{t+1} = G_{t} * (1 - F_{t+1,t+1}) + F_{t+1,t+1}\\n\\n        So after each trade t, we need to:\\n\\n        1. Retrieve G_{t-1} from global storage\\n        2. Calculate F_{t,t}\\n        3. Calculate G_{t}\\n        4. Store G_{t} in global storage\\n    */\\n    function calcFracPoolFeesFromSwap(\\n        address tokenIn,\\n        uint tokenAmountIn\\n    )\\n        public\\n        view\\n        returns (uint fracPoolFeesTrade)\\n    {\\n        uint balT = _records[tokenIn].balance;\\n        uint denorm = _records[tokenIn].denorm;\\n        uint weight = bdiv(denorm, _totalWeight);       // norm weight for tokenIn\\n\\n        uint feeAmt = bmul(_swapFee, tokenAmountIn);    // fee size in terms of tokenIn\\n        fracPoolFeesTrade = bmul(weight, bdiv(feeAmt, balT));\\n        \\n        // uint fracPoolFeesPrev = _fracPoolFees;\\n        // uint dilutionFactor = bsub(BONE, fracPoolFeesTrade);\\n        // uint fracPoolFeesCurr = badd(bmul(fracPoolFeesPrev, dilutionFactor), fracPoolFeesTrade);\\n        // _fracPoolFees = fracPoolFeesCurr;\\n        \\n        return fracPoolFeesTrade;\\n    }\\n\\n    /*\\n        Same as above, but for single-token pool joins (i.e. token in => pool shares out)\\n        Fees are only assessed on the fraction of the input token that is traded, i.e. (1-weight)\\n        See BMath.sol for more detail\\n    */\\n    function calcFracPoolFeesFromPoolJoin(\\n        address tokenIn,\\n        uint tokenAmountIn\\n    )\\n        public\\n        view\\n        returns (uint fracPoolFeesTrade)\\n    {\\n        uint balT = _records[tokenIn].balance;\\n        uint denorm = _records[tokenIn].denorm;\\n        uint weight = bdiv(denorm, _totalWeight);       // norm weight for tokenIn\\n        uint tokenAmountInTraded = bmul(tokenAmountIn, bsub(BONE, weight));\\n\\n        uint feeAmt = bmul(_swapFee, tokenAmountInTraded);    // fee size in terms of tokenIn\\n        fracPoolFeesTrade = bmul(weight, bdiv(feeAmt, balT));\\n        \\n        // uint fracPoolFeesPrev = _fracPoolFees;\\n        // uint dilutionFactor = bsub(BONE, fracPoolFeesTrade);\\n        // uint fracPoolFeesCurr = badd(bmul(fracPoolFeesPrev, dilutionFactor), fracPoolFeesTrade);\\n        // _fracPoolFees = fracPoolFeesCurr;\\n        \\n        return fracPoolFeesTrade;\\n    }\\n\\n    /*\\n        Same as above, but for single-token pool exits (i.e. pool shares in => token out)\\n        Swap fees are charged on the output token side\\n        See BMath.sol for more detail\\n        Note: Disregards exit fees\\n        \\n        Math:\\n        tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee)\\n        feeAmt = tAoBeforeSwapFee - tAo\\n               = tAo * [1 / (1 - (1-weightTo) * swapFee) - 1]\\n               = tAo * ((1-weightTo) * swapFee) / (1 - (1-weightTo) * swapFee)\\n    */\\n    function calcFracPoolFeesFromPoolExit(\\n        address tokenOut,\\n        uint tokenAmountOutAfterFees\\n    )\\n        public\\n        view\\n        returns (uint fracPoolFeesTrade)\\n    {\\n        uint balT = _records[tokenOut].balance;\\n        uint denorm = _records[tokenOut].denorm;\\n        uint weight = bdiv(denorm, _totalWeight);       // norm weight for tokenOut\\n        \\n        // fee size in terms of tokenOut\\n        uint fracTokenOutTradedTimesFee = bmul(bsub(BONE, weight), _swapFee);   // gas savings\\n        uint feeAmt = bmul(tokenAmountOutAfterFees, bdiv(fracTokenOutTradedTimesFee, bsub(BONE, fracTokenOutTradedTimesFee)));\\n        \\n        fracPoolFeesTrade = bmul(weight, bdiv(feeAmt, balT));\\n        \\n        // uint fracPoolFeesPrev = _fracPoolFees;\\n        // uint dilutionFactor = bsub(BONE, fracPoolFeesTrade);\\n        // uint fracPoolFeesCurr = badd(bmul(fracPoolFeesPrev, dilutionFactor), fracPoolFeesTrade);\\n        // _fracPoolFees = fracPoolFeesCurr;\\n\\n        return fracPoolFeesTrade;\\n    }\\n\\n\\n    /* \\n        Update the fraction of pool fees based on previous trade\\n        See above function comment for explanation\\n    */\\n    function _updateFracPoolFees(\\n        uint fracPoolFeesTrade\\n    )\\n        internal\\n    {\\n        uint fracPoolFeesPrev = _fracPoolFees;\\n        uint dilutionFactor = bsub(BONE, fracPoolFeesTrade);\\n        uint fracPoolFeesCurr = badd(bmul(fracPoolFeesPrev, dilutionFactor), fracPoolFeesTrade);\\n        _fracPoolFees = fracPoolFeesCurr;\\n    }\\n    \\n    // External wrapper function to be called by ConfigurableRightsPool owner\\n    function updateFracPoolFees(\\n        uint fracPoolFeesTrade\\n    )\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _updateFracPoolFees(fracPoolFeesTrade);\\n    }\\n\\n\\n    /* \\n        Reset the running fraction of the pool attributable to accumulated fees\\n        Must be called any time fees are distributed externally\\n    */\\n    function resetFracPoolFees()\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _fracPoolFees = 0;\\n    }\\n\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/test/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.6.6;\\n\\nimport \\\"./BNum.sol\\\";\\nimport \\\"../PCToken.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\n/*\\ninterface IERC20 {\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n*/\\n\\n// Core contract; can't be changed. So disable solhint (reminder for v2)\\n\\n/* solhint-disable func-order */\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    string  private _name     = \\\"Balancer Pool Token\\\";\\n    string  private _symbol   = \\\"BPT\\\";\\n    uint8   private _decimals = 18;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view override returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view override returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/BalancerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @author Balancer Labs\\n * @title Put all the constants in one place\\n */\\n\\nlibrary BalancerConstants {\\n    // State variables (must be constant in a library)\\n    // Note: any changes need to also be reflected in BConst.sol\\n\\n    // B \\\"ONE\\\" - all math is in the \\\"realm\\\" of 10 ** 18;\\n    // where numeric 1 = 10 ** 18\\n    uint public constant BONE = 10**18;\\n    uint public constant MIN_WEIGHT = BONE;                 // Future: make configurable to allow more weight granularity\\n    uint public constant MAX_WEIGHT = BONE * 1000;          // Future: make configurable to allow more weight granularity\\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 1000;    // Future: make configurable to allow more weight granularity\\n    uint public constant MIN_BALANCE = BONE / 10**6;\\n    uint public constant MAX_BALANCE = BONE * 10**12;\\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\\n    uint public constant MIN_FEE = BONE / 10**6;\\n    uint public constant MAX_FEE = BONE / 10;\\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n    // uint public constant EXIT_FEE = 0;                   // moved to configurable param\\n    uint public constant MAX_IN_RATIO = BONE / 2;\\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\\n    uint public constant MIN_ASSET_LIMIT = 2;\\n    // uint public constant MAX_ASSET_LIMIT = 8;            // not included - determined implicitly by governance\\n    uint public constant MAX_UINT = uint(-1);\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/BalancerSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n\\n// Imports\\n\\nimport \\\"./BalancerConstants.sol\\\";\\n\\n/**\\n * @author Balancer Labs\\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\\n */\\nlibrary BalancerSafeMath {\\n    /**\\n     * @notice Safe addition\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev if we are adding b to a, the resulting sum must be greater than a\\n     * @return - sum of operands; throws if overflow\\n     */\\n    function badd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction, and check that it produces a positive value\\n     *      (i.e., a - b is valid if b <= a)\\n     * @return - a - b; throws if underflow\\n     */\\n    function bsub(uint a, uint b) internal pure returns (uint) {\\n        (uint c, bool negativeResult) = bsubSign(a, b);\\n        require(!negativeResult, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe signed subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction\\n     * @return - difference between a and b, and a flag indicating a negative result\\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\\n     */\\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\n        if (b <= a) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Safe multiplication\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Multiply safely (and efficiently), rounding down\\n     * @return - product of operands; throws if overflow or rounding error\\n     */\\n    function bmul(uint a, uint b) internal pure returns (uint) {\\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // Standard overflow check: a/a*b=b\\n        uint c0 = a * b;\\n        require(c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n\\n        // Round to 0 if x*y < BONE/2?\\n        uint c1 = c0 + (BalancerConstants.BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BalancerConstants.BONE;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe division\\n     * @param dividend - first operand\\n     * @param divisor - second operand\\n     * @dev Divide safely (and efficiently), rounding down\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_DIV_ZERO\\\");\\n\\n        // Gas optimization\\n        if (dividend == 0){\\n            return 0;\\n        }\\n\\n        uint c0 = dividend * BalancerConstants.BONE;\\n        require(c0 / dividend == BalancerConstants.BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n\\n        uint c1 = c0 + (divisor / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n\\n        uint c2 = c1 / divisor;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer modulo\\n     * @dev Returns the remainder of dividing two unsigned integers.\\n     *      Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * @param dividend - first operand\\n     * @param divisor - second operand -- cannot be zero\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_MODULO_BY_ZERO\\\");\\n\\n        return dividend % divisor;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer max\\n     * @dev Returns the greater of the two input values\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the maximum of a and b\\n     */\\n    function bmax(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer min\\n     * @dev returns b, if b < a; otherwise returns a\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the lesser of the two input values\\n     */\\n    function bmin(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer average\\n     * @dev Guard against (a+b) overflow by dividing each operand separately\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the average of the two values\\n     */\\n    function baverage(uint a, uint b) internal pure returns (uint) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n\\n    /**\\n     * @notice Babylonian square root implementation\\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n     * @param y - operand\\n     * @return z - the square root result\\n     */\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        }\\n        else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blabs\",\"type\":\"address\"}],\"name\":\"LOG_BLABS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"LOG_NEW_POOL\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract BPool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"collect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBLabs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"b\",\"type\":\"address\"}],\"name\":\"isBPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newBPool\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"b\",\"type\":\"address\"}],\"name\":\"setBLabs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}