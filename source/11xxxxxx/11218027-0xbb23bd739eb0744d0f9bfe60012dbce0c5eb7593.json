{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-11-06\r\n*/\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract UniversalFinance {\r\n   \r\n   /**\r\n   * using safemath for uint256\r\n    */\r\n     using SafeMath for uint256;\r\n\r\n   \r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n   \r\n    /**\r\n    events for transfer\r\n     */\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n    /**\r\n    * Approved Events\r\n     */\r\n\r\n    event Approved(\r\n        address indexed spender,\r\n        address indexed recipient,\r\n        uint256 tokens\r\n    );\r\n\r\n    /**\r\n    * buy Event\r\n     */\r\n\r\n     event Buy(\r\n         address buyer,\r\n         uint256 tokensTransfered\r\n     );\r\n   \r\n   /**\r\n    * sell Event\r\n     */\r\n\r\n     event Sell(\r\n         address seller,\r\n         uint256 calculatedEtherTransfer\r\n     );\r\n     \r\n     event Reward(\r\n       address indexed to,\r\n       uint256 rewardAmount,\r\n       uint256 level\r\n    );\r\n\r\n   /** configurable variables\r\n   *  name it should be decided on constructor\r\n    */\r\n    string public tokenName;\r\n\r\n    /** configurable variables\r\n   *  symbol it should be decided on constructor\r\n    */\r\n\r\n    string public tokenSymbol;\r\n   \r\n    /** configurable variables\r\n   *  decimal it should be decided on constructor\r\n    */\r\n\r\n    uint8 internal decimal;\r\n\r\n    /** configurable variables\r\n \r\n   \r\n    /**\r\n    * owner address\r\n     */\r\n\r\n     address public owner;\r\n\r\n     /**\r\n     current price\r\n      */\r\n    uint256 internal ethDecimal = 1000000000000000000;\r\n    uint256 public currentPrice;\r\n    uint256 public initialPrice = 10000000000000;\r\n    uint256 public initialPriceIncrement = 0;\r\n    uint256 public basePrice = 400;\r\n    /**\r\n    totalSupply\r\n     */\r\n\r\n    uint256 public _totalSupply;\r\n   \r\n    uint256 public _circulatedSupply = 0;\r\n    uint256 public basePrice1 = 10000000000000;\r\n    uint256 public basePrice2 = 250000000000000;\r\n    uint256 public basePrice3 = 450000000000000;\r\n    uint256 public basePrice4 = 800000000000000;\r\n    uint256 public basePrice5 = 1375000000000000;\r\n    uint256 public basePrice6 = 2750000000000000;\r\n    uint256 public basePrice7 = 4500000000000000;\r\n    uint256 public basePrice8 = 8250000000000000;\r\n    uint256 public basePrice9 = 13250000000000000;\r\n    uint256 public basePrice10 = 20500000000000000;\r\n    uint256 public basePrice11 = 32750000000000000;\r\n    uint256 public basePrice12 = 56250000000000000;\r\n    uint256 public basePrice13 = 103750000000000000;\r\n    uint256 public basePrice14 = 179750000000000000;\r\n    uint256 public basePrice15 = 298350000000000000;\r\n    uint256 public basePrice16 = 533350000000000000;\r\n    uint256 public basePrice17 = 996250000000000000;\r\n    uint256 public basePrice18 = 1780750000000000000;\r\n    uint256 public basePrice19 = 2983350000000000000;\r\n    uint256 public basePrice20 = 5108000000000000000;\r\n    uint256 public basePrice21 = 8930500000000000000;\r\n    uint256 public basePrice22 = 15136500000000000000;\r\n   \r\n   \r\n       \r\n         \r\n\r\n   mapping(address => uint256) private tokenBalances;\r\n   mapping(address => uint256) private allTimeTokenBal;\r\n\r\n//   mapping (address => mapping (address => uint256 )) private _allowances;\r\n   mapping(address => address) public genTree;\r\n//   mapping(address => uint256) internal rewardBalanceLedger_;\r\n//   mapping (address => mapping (uint256 => uint256 )) private levelCommission;\r\n\r\n    /**\r\n    modifier for checking onlyOwner\r\n     */\r\n\r\n     modifier onlyOwner() {\r\n         require(msg.sender == owner,\"Caller is not the owner\");\r\n         _;\r\n     }\r\n\r\n    constructor(string memory _tokenName, string  memory _tokenSymbol, uint256 totalSupply) public\r\n    {\r\n        //sonk = msg.sender;\r\n       \r\n        /**\r\n        * set owner value msg.sender\r\n         */\r\n        owner = msg.sender;\r\n\r\n        /**\r\n        * set name for contract\r\n         */\r\n\r\n         tokenName = _tokenName;\r\n\r\n         /**\r\n        * set symbol for contract\r\n         */\r\n\r\n        /**\r\n        * set decimals\r\n         */\r\n\r\n         decimal = 0;\r\n\r\n         /**\r\n         set tokenSymbol\r\n          */\r\n\r\n        tokenSymbol =  _tokenSymbol;\r\n\r\n         /**\r\n         set Current Price\r\n          */\r\n\r\n          currentPrice = initialPrice + initialPriceIncrement;\r\n\r\n         \r\n          _totalSupply = totalSupply;\r\n          //_mint(owner,_totalSupply);\r\n\r\n       \r\n    }\r\n   \r\n    function geAllTimeTokenBalane(address _hodl) external view returns(uint256) {\r\n            return allTimeTokenBal[_hodl];\r\n     }\r\n   \r\n    /*function getRewardBalane(address _hodl) external view returns(uint256) {\r\n            return rewardBalanceLedger_[_hodl];\r\n     }*/\r\n   \r\n   function taxDeduction(uint256 incomingEther) public pure returns(uint256)  {\r\n         \r\n        uint256 deduction = incomingEther * 22500/100000;\r\n        return deduction;\r\n         \r\n    }\r\n   \r\n    function getTaxedEther(uint256 incomingEther) public pure returns(uint256)  {\r\n         \r\n        uint256 deduction = incomingEther * 22500/100000;\r\n        uint256 taxedEther = incomingEther - deduction;\r\n        return taxedEther;\r\n         \r\n    }\r\n   \r\n   function etherToToken(uint256 incomingEther) public view returns(uint256)  {\r\n         \r\n        uint256 deduction = incomingEther * 22500/100000;\r\n        uint256 taxedEther = incomingEther - deduction;\r\n        uint256 tokenToTransfer = taxedEther.div(currentPrice);\r\n        return tokenToTransfer;\r\n         \r\n    }\r\n   \r\n   \r\n    function tokenToEther(uint256 tokenToSell) public view returns(uint256)  {\r\n         \r\n        uint256 convertedEther = tokenToSell * (currentPrice - (currentPrice/100));\r\n        return convertedEther;\r\n         \r\n    }\r\n   \r\n   \r\n    function transferEther(address payable receiver,uint256 _value) external onlyOwner returns (bool) {\r\n        require(msg.sender == owner, 'You are not owner');\r\n        receiver.transfer(_value);\r\n        return true;\r\n     }\r\n     \r\n     \r\n    /**\r\n    get TokenName\r\n     */\r\n    function name() public view returns(string memory) {\r\n        return tokenName;\r\n    }\r\n\r\n    /**\r\n    get symbol\r\n     */\r\n\r\n     function symbol() public view returns(string memory) {\r\n         return tokenSymbol;\r\n     }\r\n\r\n     /**\r\n     get decimals\r\n      */\r\n\r\n      function decimals() public view returns(uint8){\r\n            return decimal;\r\n      }\r\n     \r\n      /**\r\n      getTotalsupply of contract\r\n       */\r\n\r\n    function totalSupply() external view returns(uint256) {\r\n            return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * balance of of token hodl.\r\n     */\r\n\r\n     function balanceOf(address _hodl) external view returns(uint256) {\r\n            return tokenBalances[_hodl];\r\n     }\r\n\r\n    /**\r\n    get current price\r\n     */\r\n\r\n     function getCurrentPrice() external view returns(uint256) {\r\n         return currentPrice;\r\n     }\r\n\r\n     /**\r\n     * update current price\r\n     * notice this is only done by owner  \r\n      */\r\n\r\n      function updateCurrentPrice(uint256 _newPrice) external onlyOwner returns (bool) {\r\n          currentPrice = _newPrice;\r\n          return true;\r\n      }\r\n      \r\n     \r\n     \r\n     /*function contractAddress() public view returns(address) {\r\n         return address(this);\r\n     }*/\r\n\r\n     /* function levelWiseBalance(address _hodl, uint256 level) external view returns (uint256) {\r\n        return levelCommission[_hodl][level];\r\n      }*/\r\n      /**\r\n      buy Tokens from Ethereum.\r\n       */\r\n\r\n     function buy(address _referredBy) external payable returns (bool) {\r\n         require(_referredBy != msg.sender, \"Self reference not allowed\");\r\n        /* if(_referredBy == msg.sender){\r\n             return false;\r\n         }else{\r\n         if(tokenBalances[msg.sender] > 5000){\r\n             return false;\r\n         }\r\n         else{*/\r\n         address buyer = msg.sender;\r\n         uint256 etherValue = msg.value;\r\n         uint256 circulation = etherValue.div(currentPrice);\r\n         uint256 taxedTokenAmount = taxedTokenTransfer(etherValue);\r\n         require(taxedTokenAmount > 0, \"Can not buy 0 tokens.\");\r\n         require(taxedTokenAmount <= 5000, \"Maximum Buying Reached.\");\r\n         require(taxedTokenAmount.add(allTimeTokenBal[msg.sender]) <= 5000, \"Maximum Buying Reached.\");\r\n         genTree[msg.sender] = _referredBy;\r\n         _mint(buyer,taxedTokenAmount,circulation);\r\n         emit Buy(buyer,taxedTokenAmount);\r\n         return true;\r\n         /*}\r\n         }*/\r\n     }\r\n     \r\n     receive() external payable {\r\n         require((allTimeTokenBal[msg.sender] + msg.value) <= 5000, \"Maximum Buying Reached.\");\r\n         genTree[msg.sender] = address(0);\r\n         address buyer = msg.sender;\r\n         uint256 etherValue = msg.value;\r\n         uint256 actualTokenQty = etherValue.div(currentPrice);\r\n         uint256 calculatedTokens = taxedTokenTransfer(etherValue);\r\n         require(calculatedTokens <= 5000, \"Maximum Buying Reached.\");\r\n         _mint(buyer,calculatedTokens,actualTokenQty);\r\n         emit Buy(buyer,calculatedTokens);\r\n         \r\n     }\r\n     \r\n     function priceAlgoBuy(uint256 tokenQty) internal{\r\n         if(_circulatedSupply >= 0 && _circulatedSupply <= 600000){\r\n             currentPrice = basePrice1;\r\n             basePrice1 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 600000 && _circulatedSupply <= 1100000){\r\n             initialPriceIncrement = tokenQty*300000000;\r\n             currentPrice = basePrice2 + initialPriceIncrement;\r\n             basePrice2 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 1100000 && _circulatedSupply <= 1550000){\r\n             initialPriceIncrement = tokenQty*450000000;\r\n             currentPrice = basePrice3 + initialPriceIncrement;\r\n             basePrice3 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 1550000 && _circulatedSupply <= 1960000){\r\n             initialPriceIncrement = tokenQty*675000000;\r\n             currentPrice = basePrice4 + initialPriceIncrement;\r\n             basePrice4 = currentPrice;\r\n         }if(_circulatedSupply > 1960000 && _circulatedSupply <= 2310000){\r\n             initialPriceIncrement = tokenQty*2350000000;\r\n             currentPrice = basePrice5 + initialPriceIncrement;\r\n             basePrice5 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 2310000 && _circulatedSupply <= 2640000){\r\n             initialPriceIncrement = tokenQty*3025000000;\r\n             currentPrice = basePrice6 + initialPriceIncrement;\r\n             basePrice6 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 2640000 && _circulatedSupply <= 2950000){\r\n             initialPriceIncrement = tokenQty*5725000000;\r\n             currentPrice = basePrice7 + initialPriceIncrement;\r\n             basePrice7 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 2950000 && _circulatedSupply <= 3240000){\r\n             initialPriceIncrement = tokenQty*8525000000;\r\n             currentPrice = basePrice8 + initialPriceIncrement;\r\n             basePrice8 = currentPrice;\r\n         }\r\n         \r\n         if(_circulatedSupply > 3240000 && _circulatedSupply <= 3510000){\r\n             initialPriceIncrement = tokenQty*13900000000;\r\n             currentPrice = basePrice9 + initialPriceIncrement;\r\n             basePrice9 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 3510000 && _circulatedSupply <= 3770000){\r\n             initialPriceIncrement = tokenQty*20200000000;\r\n             currentPrice = basePrice10 + initialPriceIncrement;\r\n             basePrice10 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 3770000 && _circulatedSupply <= 4020000){\r\n             initialPriceIncrement = tokenQty*50000000000;\r\n             currentPrice = basePrice11 + initialPriceIncrement;\r\n             basePrice11 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 4020000 && _circulatedSupply <= 4260000){\r\n             initialPriceIncrement = tokenQty*133325000000;\r\n             currentPrice = basePrice12 + initialPriceIncrement;\r\n             basePrice12 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 4260000 && _circulatedSupply <= 4490000){\r\n             initialPriceIncrement = tokenQty*239125000000;\r\n             currentPrice = basePrice13 + initialPriceIncrement;\r\n             basePrice13 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 4490000 && _circulatedSupply <= 4700000){\r\n             initialPriceIncrement = tokenQty*394050000000;\r\n             currentPrice = basePrice14 + initialPriceIncrement;\r\n             basePrice14 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 4700000 && _circulatedSupply <= 4900000){\r\n             initialPriceIncrement = tokenQty*689500000000;\r\n             currentPrice = basePrice15 + initialPriceIncrement;\r\n             basePrice15 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 4900000 && _circulatedSupply <= 5080000){\r\n             initialPriceIncrement = tokenQty*1465275000000;\r\n             currentPrice = basePrice16 + initialPriceIncrement;\r\n             basePrice16 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5080000 && _circulatedSupply <= 5220000){\r\n             initialPriceIncrement = tokenQty*3158925000000;\r\n             currentPrice = basePrice17 + initialPriceIncrement;\r\n             basePrice17 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5220000 && _circulatedSupply <= 5350000){\r\n             initialPriceIncrement = tokenQty*5726925000000;\r\n             currentPrice = basePrice18 + initialPriceIncrement;\r\n             basePrice18 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5350000 && _circulatedSupply <= 5460000){\r\n             initialPriceIncrement = tokenQty*13108175000000;\r\n             currentPrice = basePrice19 + initialPriceIncrement;\r\n             basePrice19 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5460000 && _circulatedSupply <= 5540000){\r\n             initialPriceIncrement = tokenQty*34687500000000;\r\n             currentPrice = basePrice20 + initialPriceIncrement;\r\n             basePrice20 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 5540000 && _circulatedSupply <= 5580000){\r\n             initialPriceIncrement = tokenQty*120043750000000;\r\n             currentPrice = basePrice21 + initialPriceIncrement;\r\n             basePrice21 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 5580000 && _circulatedSupply <= 5600000){\r\n             initialPriceIncrement = tokenQty*404100000000000;\r\n             currentPrice = basePrice22 + initialPriceIncrement;\r\n             basePrice22 = currentPrice;\r\n         }\r\n     }\r\n     \r\n     \r\n      function priceAlgoSell(uint256 tokenQty) internal{\r\n         if(_circulatedSupply >= 0 && _circulatedSupply < 600000){\r\n             initialPriceIncrement = tokenQty*300000;\r\n             currentPrice = basePrice1 - initialPriceIncrement;\r\n             basePrice1 = currentPrice;\r\n         }\r\n         if(_circulatedSupply >= 600000 && _circulatedSupply <= 1100000){\r\n             initialPriceIncrement = tokenQty*300000000;\r\n             currentPrice = basePrice2 - initialPriceIncrement;\r\n             basePrice2 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 1100000 && _circulatedSupply <= 1550000){\r\n             initialPriceIncrement = tokenQty*450000000;\r\n             currentPrice = basePrice3 - initialPriceIncrement;\r\n             basePrice3 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 1550000 && _circulatedSupply <= 1960000){\r\n             initialPriceIncrement = tokenQty*675000000;\r\n             currentPrice = basePrice4 - initialPriceIncrement;\r\n             basePrice4 = currentPrice;\r\n         }if(_circulatedSupply > 1960000 && _circulatedSupply <= 2310000){\r\n             initialPriceIncrement = tokenQty*2350000000;\r\n             currentPrice = basePrice5 - initialPriceIncrement;\r\n             basePrice5 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 2310000 && _circulatedSupply <= 2640000){\r\n             initialPriceIncrement = tokenQty*3025000000;\r\n             currentPrice = basePrice6 - initialPriceIncrement;\r\n             basePrice6 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 2640000 && _circulatedSupply <= 2950000){\r\n             initialPriceIncrement = tokenQty*5725000000;\r\n             currentPrice = basePrice7 - initialPriceIncrement;\r\n             basePrice7 = currentPrice;\r\n         }\r\n         if(_circulatedSupply > 2950000 && _circulatedSupply <= 3240000){\r\n             initialPriceIncrement = tokenQty*8525000000;\r\n             currentPrice = basePrice8 - initialPriceIncrement;\r\n             basePrice8 = currentPrice;\r\n         }\r\n         \r\n         if(_circulatedSupply > 3240000 && _circulatedSupply <= 3510000){\r\n             initialPriceIncrement = tokenQty*13900000000;\r\n             currentPrice = basePrice9 - initialPriceIncrement;\r\n             basePrice9 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 3510000 && _circulatedSupply <= 3770000){\r\n             initialPriceIncrement = tokenQty*20200000000;\r\n             currentPrice = basePrice10 - initialPriceIncrement;\r\n             basePrice10 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 3770000 && _circulatedSupply <= 4020000){\r\n             initialPriceIncrement = tokenQty*50000000000;\r\n             currentPrice = basePrice11 - initialPriceIncrement;\r\n             basePrice11 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 4020000 && _circulatedSupply <= 4260000){\r\n             initialPriceIncrement = tokenQty*133325000000;\r\n             currentPrice = basePrice12 - initialPriceIncrement;\r\n             basePrice12 = currentPrice;\r\n             \r\n         }if(_circulatedSupply > 4260000 && _circulatedSupply <= 4490000){\r\n             initialPriceIncrement = tokenQty*239125000000;\r\n             currentPrice = basePrice13 - initialPriceIncrement;\r\n             basePrice13 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 4490000 && _circulatedSupply <= 4700000){\r\n             initialPriceIncrement = tokenQty*394050000000;\r\n             currentPrice = basePrice14 - initialPriceIncrement;\r\n             basePrice14 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 4700000 && _circulatedSupply <= 4900000){\r\n             initialPriceIncrement = tokenQty*689500000000;\r\n             currentPrice = basePrice15 - initialPriceIncrement;\r\n             basePrice15 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 4900000 && _circulatedSupply <= 5080000){\r\n             initialPriceIncrement = tokenQty*1465275000000;\r\n             currentPrice = basePrice16 - initialPriceIncrement;\r\n             basePrice16 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5080000 && _circulatedSupply <= 5220000){\r\n             initialPriceIncrement = tokenQty*3158925000000;\r\n             currentPrice = basePrice17 - initialPriceIncrement;\r\n             basePrice17 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5220000 && _circulatedSupply <= 5350000){\r\n             initialPriceIncrement = tokenQty*5726925000000;\r\n             currentPrice = basePrice18 - initialPriceIncrement;\r\n             basePrice18 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5350000 && _circulatedSupply <= 5460000){\r\n             initialPriceIncrement = tokenQty*13108175000000;\r\n             currentPrice = basePrice19 - initialPriceIncrement;\r\n             basePrice19 = currentPrice;\r\n             \r\n         }\r\n         \r\n          if(_circulatedSupply > 5460000 && _circulatedSupply <= 5540000){\r\n             initialPriceIncrement = tokenQty*34687500000000;\r\n             currentPrice = basePrice20 - initialPriceIncrement;\r\n             basePrice20 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 5540000 && _circulatedSupply <= 5580000){\r\n             initialPriceIncrement = tokenQty*120043750000000;\r\n             currentPrice = basePrice21 - initialPriceIncrement;\r\n             basePrice21 = currentPrice;\r\n             \r\n         }\r\n         if(_circulatedSupply > 5580000 && _circulatedSupply <= 5600000){\r\n             initialPriceIncrement = tokenQty*404100000000000;\r\n             currentPrice = basePrice22 - initialPriceIncrement;\r\n             basePrice22 = currentPrice;\r\n         }\r\n     }\r\n     \r\n     \r\n   /* function distributeRewards(uint256 _amountToDistribute, address _idToDistribute)\r\n    internal\r\n    {\r\n       \r\n        for(uint256 i=0; i<15; i++)\r\n        {\r\n            address referrer = genTree[_idToDistribute];\r\n            uint256 holdingAmount = ((currentPrice/ethDecimal) * basePrice) *tokenBalances[referrer];\r\n            if(referrer != address(0))\r\n            {\r\n                if(i == 0 && holdingAmount>=100){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[0]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[0]/10000);\r\n                }else if((i == 1) && holdingAmount>=200){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[1]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[1]/10000);\r\n                }else if((i == 2) && holdingAmount>=200){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[2]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[2]/10000);\r\n                }else if((i == 3) && holdingAmount>=300){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[3]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[3]/10000);\r\n                }else if((i >= 4 && i<= 9) && holdingAmount>=300){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[4]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[4]/10000);\r\n                }else if((i >= 10 && i<= 12) && holdingAmount>=400){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[5]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[5]/10000);\r\n                }else if((i >= 13 && i<15) && holdingAmount>=500){\r\n                    rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[6]/10000);\r\n                    levelCommission[referrer][i+1].add(_amountToDistribute*percent_[6]/10000);\r\n                }else{\r\n                   \r\n                }\r\n               \r\n                _idToDistribute = referrer;\r\n                //emit Reward(referrer,(_amountToDistribute*_amountToDistribute[i]*100)/10,i);\r\n            }else{\r\n               \r\n            }\r\n        }\r\n       \r\n    }*/\r\n\r\n    /**\r\n    calculation logic for buy function\r\n     */\r\n\r\n     function taxedTokenTransfer(uint256 incomingEther) internal view returns(uint256) {\r\n            uint256 deduction = incomingEther * 22500/100000;\r\n            uint256 taxedEther = incomingEther - deduction;\r\n            uint256 tokenToTransfer = taxedEther.div(currentPrice);\r\n            return tokenToTransfer;\r\n     }\r\n\r\n     /**\r\n     * sell method for ether.\r\n      */\r\n\r\n     function sell(uint256 tokenToSell) external returns(bool){\r\n          require(_circulatedSupply > 0, \"no circulated tokens\");\r\n          require(tokenToSell > 0, \"can not sell 0 token\");\r\n          require(tokenToSell <= tokenBalances[msg.sender], \"not enough tokens to transact\");\r\n          require(tokenToSell.add(_circulatedSupply) <= _totalSupply, \"exceeded total supply\");\r\n          uint256 convertedEthers = etherValueTransfer(tokenToSell);\r\n          msg.sender.transfer(convertedEthers);\r\n          _burn(msg.sender,tokenToSell);\r\n          emit Sell(msg.sender,convertedEthers);\r\n          return true;\r\n     }\r\n     \r\n     \r\n     \r\n\r\n     function etherValueTransfer(uint256 tokenToSell) internal view returns(uint256) {\r\n         uint256 convertedEther = tokenToSell * (currentPrice - currentPrice/100);\r\n        return convertedEther;\r\n     }\r\n\r\n\r\n    function accumulatedEther() external onlyOwner view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n   \r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        emit Transfer(sender, recipient, amount);\r\n        tokenBalances[sender] = tokenBalances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        tokenBalances[recipient] = tokenBalances[recipient].add(amount);\r\n    }\r\n\r\n   \r\n     /*function _approve(address spender, address recipient, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[spender][recipient] = amount;\r\n        emit Approved(spender, recipient, amount);\r\n    }*/\r\n\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n\r\n    function _mint(address account, uint256 amount, uint256 circulation) internal  {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n       /* if(account == owner){\r\n            emit Transfer(address(0), account, amount);\r\n            tokenBalances[owner] = tokenBalances[owner].add(amount);\r\n        }else{*/\r\n            emit Transfer(address(this), account, amount);\r\n            tokenBalances[account] = tokenBalances[account].add(amount);\r\n            allTimeTokenBal[account] = allTimeTokenBal[account].add(amount);\r\n            _circulatedSupply = _circulatedSupply.add(circulation);\r\n            priceAlgoBuy(circulation);\r\n        /*}*/\r\n       \r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        emit Transfer(account, address(this), amount);\r\n        tokenBalances[account] = tokenBalances[account].sub(amount);\r\n        //tokenBalances[owner] = tokenBalances[owner].add(amount);\r\n        _circulatedSupply = _circulatedSupply.sub(amount);\r\n        allTimeTokenBal[account] = allTimeTokenBal[account].sub(amount);\r\n        priceAlgoSell(amount);\r\n    }\r\n\r\n    function _msgSender() internal view returns (address ){\r\n        return msg.sender;\r\n    }\r\n \r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensTransfered\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"calculatedEtherTransfer\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_circulatedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulatedEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hodl\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice11\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice12\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice13\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice14\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice15\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice16\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice17\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice19\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice21\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice22\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice4\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice7\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice8\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice9\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"incomingEther\",\"type\":\"uint256\"}],\"name\":\"etherToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hodl\",\"type\":\"address\"}],\"name\":\"geAllTimeTokenBalane\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"genTree\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"incomingEther\",\"type\":\"uint256\"}],\"name\":\"getTaxedEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialPriceIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenToSell\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"incomingEther\",\"type\":\"uint256\"}],\"name\":\"taxDeduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenToSell\",\"type\":\"uint256\"}],\"name\":\"tokenToEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updateCurrentPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"UniversalFinance","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000005573000000000000000000000000000000000000000000000000000000000000000010556e6976657273652046696e616e63650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035546430000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://92237360f3de7686b676a858f3f02642d674fcc0ac39125ec6a34e1a6c4b696f"}]}