{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract KTimeController {\r\n\r\n    uint public offsetTime;\r\n\r\n    function timestemp() external view returns (uint) {\r\n        return now + offsetTime;\r\n    }\r\n\r\n    function increaseTime(uint t) external {\r\n        offsetTime += t;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\ncontract KOwnerable {\r\n\r\n    address[] internal _authAddress = [\r\n        address(0x013a0Fe4a79afFF253Fd0ACBDC891384EBbD0630)\r\n    ];\r\n\r\n    address[] public KContractOwners;\r\n\r\n    bool private _call_locked;\r\n\r\n    constructor() public {\r\n        KContractOwners.push(msg.sender);\r\n        _authAddress.push(msg.sender);\r\n    }\r\n\r\n    function KAuthAddresses() external view returns (address[] memory) {\r\n        return _authAddress;\r\n    }\r\n\r\n    function KAddAuthAddress(address auther) external KOwnerOnly {\r\n        _authAddress.push(auther);\r\n    }\r\n\r\n    function KDelAuthAddress(address auther) external KOwnerOnly {\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if (_authAddress[i] == auther) {\r\n                for (uint j = 0; j < _authAddress.length - 1; j++) {\r\n                    _authAddress[j] = _authAddress[j+1];\r\n                }\r\n                delete _authAddress[_authAddress.length - 1];\r\n                _authAddress.pop();\r\n                return ;\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier KOwnerOnly() {\r\n        bool exist = false;\r\n        for ( uint i = 0; i < KContractOwners.length; i++ ) {\r\n            if ( KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exist, 'NotAuther'); _;\r\n    }\r\n\r\n    modifier KOwnerOnlyAPI() {\r\n        bool exist = false;\r\n        for ( uint i = 0; i < KContractOwners.length; i++ ) {\r\n            if ( KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exist, 'NotAuther'); _;\r\n    }\r\n\r\n    modifier KRejectContractCall() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"Sender Is Contract\" );\r\n        _;\r\n    }\r\n\r\n    modifier KDAODefense() {\r\n        require(!_call_locked, \"DAO_Warning\");\r\n        _call_locked = true;\r\n        _;\r\n        _call_locked = false;\r\n    }\r\n\r\n    modifier KDelegateMethod() {\r\n        bool exist = false;\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if ( _authAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exist, \"PermissionDeny\"); _;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n}\r\n\r\n\r\ncontract KPausable is KOwnerable {\r\n\r\n    event Paused(address account);\r\n\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool public paused;\r\n\r\n\r\n    constructor () internal {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    modifier KWhenNotPaused() {\r\n        require(!paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    modifier KWhenPaused() {\r\n        require(paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    function Pause() public KOwnerOnly {\r\n        paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n\r\n    function Unpause() public KOwnerOnly {\r\n        paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\ncontract KDebug is KPausable {\r\n\r\n    KTimeController internal debugTimeController;\r\n\r\n    function timestempZero() internal view returns (uint) {\r\n        return timestemp() / 1 days * 1 days;\r\n    }\r\n\r\n    function timestemp() internal view returns (uint) {\r\n        if ( debugTimeController != KTimeController(0) ) {\r\n            return debugTimeController.timestemp();\r\n        } else {\r\n            return now;\r\n        }\r\n    }\r\n\r\n    function KSetDebugTimeController(address tc) external KOwnerOnly {\r\n        debugTimeController = KTimeController(tc);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\ncontract KStorage is KDebug {\r\n\r\n    address public KImplementAddress;\r\n\r\n    function SetKImplementAddress(address impl) external KOwnerOnly {\r\n        KImplementAddress = impl;\r\n    }\r\n\r\n    function () external {\r\n        address impl_address = KImplementAddress;\r\n        assembly {\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(sub(gas(), 10000), impl_address, 0x0, calldatasize(), 0, 0)\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n            case 0 {\r\n                revert(0, retSz)\r\n            }\r\n            default {\r\n                return(0, retSz)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract KStoragePayable is KDebug {\r\n\r\n    address public KImplementAddress;\r\n\r\n    function SetKImplementAddress(address impl) external KOwnerOnly {\r\n        KImplementAddress = impl;\r\n    }\r\n\r\n    function () external payable {\r\n        address impl_address = KImplementAddress;\r\n        assembly {\r\n\r\n            if eq(calldatasize(), 0) {\r\n                return(0, 0)\r\n            }\r\n\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(gas(), impl_address, 0x0, calldatasize(), 0, 0)\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n            case 0 {\r\n                revert(0, retSz)\r\n            }\r\n            default {\r\n                return(0, retSz)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\ncontract KState {\r\n\r\n    address private _KDeveloper;\r\n    address internal _KIMPLAddress;\r\n\r\n    address[] _KAuthAddress;\r\n\r\n    address payable public _KDefaultReciver = address(0x2E5600376D4F07F13Ea69Caf416FB2F7B6659897);\r\n\r\n    address payable[] public _KContractOwners = [\r\n        address(0xc99D13544297d5baD9e0b0Ca0E94A4E614312F33)\r\n    ];\r\n\r\n    bool public _KContractBroken;\r\n    mapping (address => bool) _KWithdrawabledAddress;\r\n\r\n    constructor() public {\r\n        _KDeveloper = msg.sender;\r\n        _KContractOwners.push(msg.sender);\r\n    }\r\n\r\n    modifier KWhenBroken() {\r\n        require(_KContractBroken); _;\r\n    }\r\n\r\n    modifier KWhenNotBroken() {\r\n        require(!_KContractBroken); _;\r\n    }\r\n\r\n    modifier KOwnerOnly() {\r\n\r\n        bool exist = false;\r\n\r\n        for ( uint i = 0; i < _KContractOwners.length; i++ ) {\r\n            if ( _KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KSetContractBroken(bool broken) external KOwnerOnly {\r\n        _KContractBroken = broken;\r\n    }\r\n\r\n    modifier KDAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    modifier KAPIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i < _KAuthAddress.length; i++) {\r\n            if ( _KAuthAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KAuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _KAuthAddress;\r\n    }\r\n\r\n    function KAddAuthAddress(address _addr) external KOwnerOnly {\r\n        _KAuthAddress.push(_addr);\r\n    }\r\n\r\n    modifier KDeveloperOnly {\r\n        require(msg.sender == _KDeveloper); _;\r\n    }\r\n\r\n    function KSetImplAddress(address impl) external KDeveloperOnly {\r\n        _KIMPLAddress = impl;\r\n    }\r\n\r\n    function KGetImplAddress() external view KDeveloperOnly returns (address) {\r\n        return _KIMPLAddress;\r\n    }\r\n\r\n}\r\n\r\ncontract KDoctor is KState {\r\n    modifier write {_;}\r\n}\r\n\r\ncontract KContract is KState {\r\n\r\n    modifier write {\r\n\r\n        if ( _KIMPLAddress != address(0x0) ) {\r\n\r\n            (, bytes memory ret) = address(_KIMPLAddress).delegatecall(msg.data);\r\n\r\n            assembly {\r\n                return( add(ret, 0x20), mload(ret) )\r\n            }\r\n\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary UserRelation {\r\n\r\n    struct MainDB {\r\n\r\n        uint totalAddresses;\r\n        mapping ( address => address ) _recommerMapping;\r\n        mapping ( address => address[] ) _recommerList;\r\n        mapping ( address => uint256 ) _recommerCountMapping;\r\n        mapping ( bytes6 => address ) _shortCodeMapping;\r\n        mapping ( address => bytes6 ) _addressShotCodeMapping;\r\n    }\r\n\r\n    function Init(MainDB storage self) internal {\r\n\r\n        address rootAddr = address(0xdead);\r\n        bytes6 rootCode = 0x303030303030;\r\n\r\n        self._recommerMapping[rootAddr] = address(0xdeaddead);\r\n        self._shortCodeMapping[rootCode] = rootAddr;\r\n        self._addressShotCodeMapping[rootAddr] = rootCode;\r\n    }\r\n\r\n    function GetIntroducer( MainDB storage self, address _owner ) internal view returns (address) {\r\n        return self._recommerMapping[_owner];\r\n    }\r\n\r\n    function RecommendList( MainDB storage self, address _owner ) internal view returns ( address[] memory list, uint256 len ) {\r\n        return (self._recommerList[_owner], self._recommerList[_owner].length );\r\n    }\r\n\r\n    function RegisterShortCode( MainDB storage self, address _owner, bytes6 shortCode ) internal returns (bool) {\r\n\r\n        if ( self._shortCodeMapping[shortCode] != address(0x0) ) {\r\n            return false;\r\n        }\r\n\r\n        if ( self._addressShotCodeMapping[_owner] != bytes6(0x0) ) {\r\n            return false;\r\n        }\r\n\r\n        self._shortCodeMapping[shortCode] = _owner;\r\n        self._addressShotCodeMapping[_owner] = shortCode;\r\n\r\n        return true;\r\n    }\r\n\r\n    function ShortCodeToAddress( MainDB storage self, bytes6 shortCode ) internal view returns (address) {\r\n        return self._shortCodeMapping[shortCode];\r\n    }\r\n\r\n    function AddressToShortCode( MainDB storage self, address addr ) internal view returns (bytes6) {\r\n        return self._addressShotCodeMapping[addr];\r\n    }\r\n\r\n    function AddRelation( MainDB storage self, address owner, address recommer ) internal returns (int) {\r\n\r\n\r\n        if ( recommer == owner )  {\r\n            require(false, \"-1\");\r\n            return -1;\r\n        }\r\n\r\n        require( recommer != owner, \"-1\" );\r\n\r\n        require( self._recommerMapping[owner] == address(0x0), \"-2\");\r\n\r\n        if ( recommer != address(0xdead) ) {\r\n            require( self._recommerMapping[recommer] != address(0x0), \"-3\");\r\n        }\r\n\r\n        self._recommerMapping[owner] = recommer;\r\n\r\n        self._recommerList[recommer].push(owner);\r\n\r\n        self._recommerCountMapping[recommer] ++;\r\n\r\n        self.totalAddresses++;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function AddRelationEx( MainDB storage self, address owner, address recommer, bytes6 regShoutCode ) internal returns (int) {\r\n\r\n        if ( !RegisterShortCode(self, owner, regShoutCode) ) {\r\n            return -4;\r\n        }\r\n\r\n        return AddRelation(self, owner, recommer);\r\n    }\r\n\r\n    function TeamMemberTotal( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._recommerCountMapping[_addr];\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\nlibrary Achievement {\r\n\r\n    using UserRelation for UserRelation.MainDB;\r\n\r\n    struct MainDB {\r\n\r\n        uint latestVersion;\r\n\r\n        uint currVersion;\r\n\r\n        mapping(uint => mapping(address => uint) ) achievementMapping;\r\n\r\n        mapping ( address => uint256 ) _vaildMemberCountMapping;\r\n\r\n        mapping ( address => bool ) _vaildMembersMapping;\r\n\r\n        mapping ( address => uint256 ) _despositTotalMapping;\r\n    }\r\n\r\n    function AppendAchievement( MainDB storage self, UserRelation.MainDB storage userRelation, address owner, uint value )\r\n    internal {\r\n\r\n        require(value > 0, \"ValueIsZero\");\r\n\r\n        for (\r\n            address parent = owner;\r\n            parent != address(0x0) && parent != address(0xdead);\r\n            parent = userRelation.GetIntroducer(parent)\r\n        ) {\r\n            self.achievementMapping[self.currVersion][parent] += value;\r\n        }\r\n\r\n    }\r\n\r\n    function DivestmentAchievement( MainDB storage self, UserRelation.MainDB storage userRelation, address owner, uint value)\r\n    internal {\r\n\r\n        for (\r\n            address parent = owner;\r\n            parent != address(0x0) && parent != address(0xdaed);\r\n            parent = userRelation.GetIntroducer(parent)\r\n        ) {\r\n            if ( self.achievementMapping[self.currVersion][parent] < value ) {\r\n                self.achievementMapping[self.currVersion][parent] = 0;\r\n            } else {\r\n                self.achievementMapping[self.currVersion][parent] -= value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function AchievementValueOfOwner( MainDB storage self, address owner )\r\n    internal view\r\n    returns (uint) {\r\n        return self.achievementMapping[self.currVersion][owner];\r\n    }\r\n\r\n    function AchievementDistribution( MainDB storage self, UserRelation.MainDB storage userRelation, address owner)\r\n    internal view\r\n    returns (\r\n        uint totalSum,\r\n        uint large,\r\n        uint len,\r\n        address[] memory addrs,\r\n        uint[] memory values\r\n    ) {\r\n        totalSum = self.achievementMapping[self.currVersion][owner];\r\n\r\n        (addrs, len) = userRelation.RecommendList(owner);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            values[i] = self.achievementMapping[self.currVersion][addrs[i]];\r\n\r\n            if ( self.achievementMapping[self.currVersion][addrs[i]] > large ) {\r\n                large = self.achievementMapping[self.currVersion][addrs[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    function AchievementDynamicValue( MainDB storage self, UserRelation.MainDB storage userRelation, address owner)\r\n    internal view\r\n    returns (\r\n        uint v\r\n    ) {\r\n        uint large;\r\n        uint largeId;\r\n        (address[] memory addrs, uint len) = userRelation.RecommendList(owner);\r\n        uint[] memory values = new uint[](len);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            values[i] = self.achievementMapping[self.currVersion][addrs[i]];\r\n\r\n            if ( self.achievementMapping[self.currVersion][addrs[i]] > large ) {\r\n                large = self.achievementMapping[self.currVersion][addrs[i]];\r\n                largeId = i;\r\n            }\r\n        }\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            if ( i != largeId ) {\r\n                if ( values[i] > 10000 ether ) {\r\n\r\n                    v += ((values[i]) / 1 ether) + 90000;\r\n\r\n                } else {\r\n\r\n                    v += (values[i] / 1 ether) * 10;\r\n                }\r\n\r\n            } else {\r\n\r\n                v += (values[i] / 1 ether) / 1000;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function ValidMembersCountOf( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._vaildMemberCountMapping[_addr];\r\n    }\r\n\r\n    function InvestTotalEtherOf( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._despositTotalMapping[_addr];\r\n    }\r\n\r\n    function DirectValidMembersCount( MainDB storage self, UserRelation.MainDB storage userRelation, address _addr ) internal view returns (uint256) {\r\n\r\n        uint256 count = 0;\r\n        address[] storage rlist = userRelation._recommerList[_addr];\r\n        for ( uint i = 0; i < rlist.length; i++ ) {\r\n            if ( self._vaildMembersMapping[rlist[i]] ) {\r\n                count ++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    function IsValidMember( MainDB storage self, address _addr ) internal view returns (bool) {\r\n        return self._vaildMembersMapping[_addr];\r\n    }\r\n\r\n    function MarkValidAddress( MainDB storage self, UserRelation.MainDB storage userRelation, address _addr, uint256 _evalue ) external {\r\n\r\n        if ( self._vaildMembersMapping[_addr] == false ) {\r\n\r\n            address parent = userRelation._recommerMapping[_addr];\r\n\r\n            for ( uint i = 0; i < 15; i++ ) {\r\n\r\n                self._vaildMemberCountMapping[parent] ++;\r\n\r\n                parent = userRelation._recommerMapping[parent];\r\n\r\n                if ( parent == address(0x0) ) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            self._vaildMembersMapping[_addr] = true;\r\n        }\r\n\r\n        self._despositTotalMapping[_addr] += _evalue;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.6.0;\r\n\r\n\r\n\r\ncontract Recommend is KContract {\r\n\r\n    UserRelation.MainDB _userRelation;\r\n    using UserRelation for UserRelation.MainDB;\r\n\r\n    constructor() public {\r\n        _userRelation.Init();\r\n    }\r\n\r\n    function GetIntroducer( address _owner ) external view returns (address) {\r\n        return _userRelation.GetIntroducer(_owner);\r\n    }\r\n\r\n    function RecommendList( address _owner) external view returns ( address[] memory list, uint256 len ) {\r\n        return _userRelation.RecommendList(_owner);\r\n    }\r\n\r\n    function ShortCodeToAddress( bytes6 shortCode ) external view returns (address) {\r\n        return _userRelation.ShortCodeToAddress(shortCode);\r\n    }\r\n\r\n    function AddressToShortCode( address _addr ) external view returns (bytes6) {\r\n        return _userRelation.AddressToShortCode(_addr);\r\n    }\r\n\r\n    function TeamMemberTotal( address _addr ) external view returns (uint256) {\r\n        return _userRelation.TeamMemberTotal(_addr);\r\n    }\r\n\r\n    function RegisterShortCode( bytes6 shortCode ) external write {\r\n        require(_userRelation.RegisterShortCode(msg.sender, shortCode));\r\n    }\r\n\r\n    function BindRelation( address _recommer ) external write {\r\n        require( _userRelation.AddRelation(msg.sender, _recommer) >= 0, \"-1\" );\r\n    }\r\n\r\n    function BindRelationEx( address _recommer, bytes6 shortCode ) external write{\r\n        require( _userRelation.AddRelationEx(msg.sender, _recommer, shortCode) >= 0, \"-1\" );\r\n    }\r\n\r\n    function AddressesCount() external view returns (uint) {\r\n        return _userRelation.totalAddresses;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.6.0;\r\n\r\n\r\n\r\n\r\ncontract Relations is Recommend {\r\n\r\n    Achievement.MainDB _achievementer;\r\n    using Achievement for Achievement.MainDB;\r\n\r\n    function API_AppendAchievement( address owner, uint value )\r\n    external write KAPIMethod {\r\n        _achievementer.AppendAchievement( _userRelation, owner, value );\r\n    }\r\n\r\n    function API_DivestmentAchievement( address owner, uint value)\r\n    external write KAPIMethod {\r\n        _achievementer.DivestmentAchievement( _userRelation, owner, value );\r\n    }\r\n\r\n    function AchievementValueOf( address owner )\r\n    external view\r\n    returns (uint) {\r\n        return _achievementer.AchievementValueOfOwner(owner);\r\n    }\r\n\r\n    function AchievementDistributionOf( address owner)\r\n    external view\r\n    returns (\r\n        uint totalSum,\r\n        uint large,\r\n        uint len,\r\n        address[] memory addrs,\r\n        uint[] memory values\r\n    ) {\r\n        return _achievementer.AchievementDistribution(_userRelation, owner );\r\n    }\r\n\r\n    function AchievementDynamicValue( address owner)\r\n    external view\r\n    returns ( uint ) {\r\n        return _achievementer.AchievementDynamicValue(_userRelation, owner);\r\n    }\r\n\r\n    function ValidMembersCountOf( address _addr ) external view returns (uint256) {\r\n        return _achievementer.ValidMembersCountOf(_addr);\r\n    }\r\n\r\n    function InvestTotalEtherOf( address _addr ) external view returns (uint256) {\r\n        return _achievementer.InvestTotalEtherOf(_addr);\r\n    }\r\n\r\n    function DirectValidMembersCount( address _addr ) external view returns (uint256) {\r\n        return _achievementer.DirectValidMembersCount(_userRelation, _addr);\r\n    }\r\n\r\n    function IsValidMember( address _addr ) external view returns (bool) {\r\n        return _achievementer.IsValidMember(_addr);\r\n    }\r\n\r\n    function TotalAddresses() external view returns (uint) {\r\n        return _userRelation.totalAddresses;\r\n    }\r\n\r\n    function API_MarkValid( address _addr, uint256 _evalue ) external KAPIMethod {\r\n        return _achievementer.MarkValidAddress(_userRelation, _addr, _evalue);\r\n    }\r\n\r\n    function Developer_VersionInfo() external view returns (uint latest, uint curr) {\r\n        return (_achievementer.latestVersion, _achievementer.currVersion);\r\n    }\r\n\r\n    function Developer_PushNewDataVersion() external write KDeveloperOnly {\r\n        _achievementer.latestVersion++;\r\n    }\r\n\r\n    function Developer_SetDataVersion(uint v) external write KDeveloperOnly {\r\n        _achievementer.currVersion = v;\r\n    }\r\n\r\n    function Developer_WriteRelation( address _parent, address[] calldata _children, bytes6[] calldata _shortCode, bool force ) external write KDeveloperOnly {\r\n\r\n        for ( uint i = 0; i < _children.length; i++ ) {\r\n\r\n            _userRelation._recommerMapping[_children[i]] = _parent;\r\n\r\n            _userRelation._shortCodeMapping[_shortCode[i]] = _children[i];\r\n            _userRelation._addressShotCodeMapping[_children[i]] = _shortCode[i];\r\n        }\r\n\r\n        if ( force ) {\r\n\r\n            for ( uint i = 0; i < _children.length; i++ ) {\r\n                _userRelation._recommerList[_parent].push(_children[i]);\r\n            }\r\n\r\n            _userRelation._recommerCountMapping[_parent] += _children.length;\r\n\r\n        } else {\r\n\r\n            _userRelation._recommerList[_parent] = _children;\r\n\r\n            _userRelation._recommerCountMapping[_parent] = _children.length;\r\n        }\r\n\r\n        _userRelation.totalAddresses += _children.length;\r\n\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n\r\ninterface ConditionDelegate {\r\n    function conditionLevelOneFinished(address owner) external view returns (bool);\r\n    function totalInOut(address owner) external view returns (uint totalIn, uint totalOut);\r\n}\r\n\r\ninterface LevelSubInterfaceV1 {\r\n    function LevelOf( address _owner ) external view returns (uint256 lv);\r\n}\r\n\r\ncontract ManagerStorage is KStoragePayable {\r\n\r\n    uint public dlvDepthMaxLimit = 512;\r\n\r\n    uint[] public dlevelAwarProp = [\r\n        0.00e12,\r\n        0.05e12,\r\n        0.05e12,\r\n        0.05e12,\r\n        0.05e12,\r\n        0.05e12\r\n    ];\r\n\r\n    Relations internal _rlsInterface;\r\n    ConditionDelegate internal _mrgInterface;\r\n    LevelSubInterfaceV1 internal _levelSubInterface;\r\n\r\n    address payable internal _receiver;\r\n\r\n    mapping(address => uint8) public levelOf;\r\n\r\n    mapping(address => uint8) internal _chilrenLevelMaxMapping;\r\n\r\n    constructor(\r\n        Relations rltInc,\r\n        address payable _rcv,\r\n        LevelSubInterfaceV1 lvInc\r\n    ) public {\r\n        _levelSubInterface = lvInc;\r\n        _rlsInterface = rltInc;\r\n        _receiver = _rcv;\r\n    }\r\n}\r\n\r\ncontract Manager is ManagerStorage {\r\n\r\n    constructor() public ManagerStorage(\r\n        Relations(0),\r\n        address(0),\r\n        LevelSubInterfaceV1(0)\r\n    ) {}\r\n\r\n    function migrateOriginLevel() external returns (bool) {\r\n\r\n        uint old = _levelSubInterface.LevelOf(msg.sender);\r\n\r\n        if ( levelOf[msg.sender] < old ) {\r\n            _upgradeLevel(msg.sender, uint8(old));\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _upgradeLevel(address owner, uint8 lv) internal {\r\n\r\n        require( levelOf[owner] < lv, \"LevelLess\" );\r\n\r\n        levelOf[owner] = lv;\r\n\r\n        for (\r\n            (uint i, address parent) = (0, owner);\r\n            i < 32 && parent != address(0x0) && parent != address(0xdead);\r\n            (parent = _rlsInterface.GetIntroducer(parent), i++)\r\n        ) {\r\n            if ( _chilrenLevelMaxMapping[parent] < lv ) {\r\n                _chilrenLevelMaxMapping[parent] = uint8(lv);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _levelDistribution(address owner, uint maxLimit) internal view returns (uint[] memory distribution) {\r\n\r\n        (address[] memory directAddresses, ) = _rlsInterface.RecommendList(owner);\r\n\r\n        distribution = new uint[](maxLimit + 1);\r\n\r\n        for ( uint i = 0; i < directAddresses.length; i++) {\r\n            uint lv = _chilrenLevelMaxMapping[directAddresses[i]];\r\n            if ( lv <= maxLimit ) {\r\n                distribution[lv]++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getForefathers(address owner, uint depth, uint endLevel) public view returns (uint[] memory seq, address[] memory fathers) {\r\n\r\n        seq = new uint[](endLevel + 1);\r\n        fathers = new address[](endLevel + 1);\r\n        uint seqOffset = 0;\r\n        address parent = _rlsInterface.GetIntroducer(owner);\r\n\r\n        for (\r\n            uint i = 0;\r\n            ( i < depth && parent != address(0x0) && parent != address(0xdead) );\r\n            ( i++, parent = _rlsInterface.GetIntroducer(parent) )\r\n        ) {\r\n            uint lv = uint(levelOf[parent]);\r\n\r\n            if ( fathers[lv] == address(0) ) {\r\n                fathers[lv] = parent;\r\n                seq[seqOffset++] = uint(lv);\r\n            }\r\n\r\n            if ( lv >= endLevel + 1 ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getForefathers(address owner, uint depth) public view returns (address[] memory, uint8[] memory) {\r\n\r\n        address[] memory forefathers = new address[](depth);\r\n        uint8[] memory levels = new uint8[](depth);\r\n\r\n        for (\r\n            (address parent, uint i) = (_rlsInterface.GetIntroducer(owner), 0);\r\n            i < depth && parent != address(0) && parent != address(0xdead);\r\n            (i++, parent = _rlsInterface.GetIntroducer(parent))\r\n        ) {\r\n            forefathers[i] = parent;\r\n            levels[i] = levelOf[parent];\r\n        }\r\n\r\n        return (forefathers, levels);\r\n    }\r\n\r\n    function setConditionDelegateInc(address inc) external KOwnerOnly {\r\n        _mrgInterface = ConditionDelegate(inc);\r\n    }\r\n\r\n    function upgradeDLevel() external returns (uint origin, uint current) {\r\n\r\n        origin = levelOf[msg.sender];\r\n        current = origin;\r\n\r\n        if ( origin == dlevelAwarProp.length - 1 ) {\r\n            return (origin, current);\r\n        }\r\n\r\n        uint[] memory childrenDLVSCount = _levelDistribution(msg.sender, dlevelAwarProp.length - 1);\r\n        (uint totalIn, ) = _mrgInterface.totalInOut(msg.sender);\r\n\r\n        if ( current == 0 ) {\r\n            if ( _mrgInterface.conditionLevelOneFinished(msg.sender) ) {\r\n                current = 1;\r\n            }\r\n        }\r\n\r\n        if ( current == 1 ) {\r\n            uint effCount = 0;\r\n            for (uint i = current; i < dlevelAwarProp.length; i++ ) {\r\n                effCount += childrenDLVSCount[i];\r\n            }\r\n            if ( effCount >= 3 && totalIn >= 20 ether) {\r\n                current = 2;\r\n            }\r\n        }\r\n\r\n        if ( current == 2 ) {\r\n            uint effCount = 0;\r\n            for (uint i = current; i < dlevelAwarProp.length; i++ ) {\r\n                effCount += childrenDLVSCount[i];\r\n            }\r\n            if ( effCount >= 3 && totalIn >= 30 ether) {\r\n                current = 3;\r\n            }\r\n        }\r\n\r\n        if ( current == 3 ) {\r\n            uint effCount = 0;\r\n            for (uint i = current; i < dlevelAwarProp.length; i++ ) {\r\n                effCount += childrenDLVSCount[i];\r\n            }\r\n            if ( effCount >= 4 && totalIn >= 400 ether) {\r\n                current = 4;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        if ( current > origin ) {\r\n            _upgradeLevel(msg.sender, uint8(current));\r\n        }\r\n\r\n        return (origin, current);\r\n    }\r\n\r\n    function paymentDLevel() external payable {\r\n\r\n        require( msg.value >= 5 ether);\r\n\r\n        require( _rlsInterface.GetIntroducer(msg.sender) != address(0x0), \"NoIntroducer\" );\r\n\r\n        require( levelOf[msg.sender] == 0, \"CurrentLvGreatThanTarget\" );\r\n\r\n        _upgradeLevel(msg.sender, uint8(1));\r\n\r\n        _receiver.transfer( address(this).balance );\r\n    }\r\n\r\n    function setDLevelAwardProp(uint dl, uint p) external KOwnerOnly {\r\n        require( dl >= 1 && dl < dlevelAwarProp.length );\r\n        dlevelAwarProp[dl] = p;\r\n    }\r\n\r\n    function setDLevelSearchDepth(uint depth) external KOwnerOnly {\r\n        dlvDepthMaxLimit = depth;\r\n    }\r\n\r\n    function calculationAwards(address owner, uint value) external view returns (\r\n        address[] memory addresses,\r\n        uint[] memory awards\r\n    ) {\r\n\r\n        uint len = dlevelAwarProp.length;\r\n        addresses = new address[](len);\r\n        awards = new uint[](len);\r\n\r\n        uint[] memory awarProps = dlevelAwarProp;\r\n\r\n        (\r\n            uint[] memory seq,\r\n            address[] memory fathers\r\n        ) = getForefathers(\r\n            owner,\r\n            dlvDepthMaxLimit,\r\n            dlevelAwarProp.length - 1\r\n        );\r\n\r\n        for ( uint i = 0; i < seq.length; i++ ) {\r\n\r\n            uint dlv = seq[i];\r\n\r\n            uint psum = 0;\r\n            for ( uint x = dlv; x > 0; x-- ) {\r\n                psum += awarProps[x];\r\n                awarProps[x] = 0;\r\n            }\r\n\r\n            if ( psum > 0 ) {\r\n                addresses[dlv] = fathers[dlv];\r\n                awards[dlv] = value * psum / 1e12;\r\n            }\r\n\r\n            if ( dlv >= dlevelAwarProp.length - 1 ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Relations\",\"name\":\"rltInc\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_rcv\",\"type\":\"address\"},{\"internalType\":\"contract LevelSubInterfaceV1\",\"name\":\"lvInc\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"auther\",\"type\":\"address\"}],\"name\":\"KAddAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KAuthAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"KContractOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"auther\",\"type\":\"address\"}],\"name\":\"KDelAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KImplementAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tc\",\"type\":\"address\"}],\"name\":\"KSetDebugTimeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"SetKImplementAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dlevelAwarProp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dlvDepthMaxLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"levelOf\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ManagerStorage","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000003fe5eb14a8e99d7ba8b421c5285b5c0d8292cd13000000000000000000000000013a0fe4a79afff253fd0acbdc891384ebbd06300000000000000000000000002655e4b1957ff8fa6536f705f3f7feb7d910ff76","EVMVersion":"byzantium","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d4c4b4c6769be5bca080891890e12e186a533f692a6e244e726e39f559e848c8"}]}