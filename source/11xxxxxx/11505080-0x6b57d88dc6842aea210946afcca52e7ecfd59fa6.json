{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache-2.0\r\npragma solidity 0.7.5;\r\n\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\ncontract CloneFactory {\r\n  function createClone(address target, bytes32 salt)\r\n    internal\r\n    returns (address payable result)\r\n  {\r\n    bytes20 targetBytes = bytes20(target);\r\n    assembly {\r\n      // load the next free memory slot as a place to store the clone contract data\r\n      let clone := mload(0x40)\r\n\r\n      // The bytecode block below is responsible for contract initialization\r\n      // during deployment, it is worth noting the proxied contract constructor will not be called during\r\n      // the cloning procedure and that is why an initialization function needs to be called after the\r\n      // clone is created\r\n      mstore(\r\n        clone,\r\n        0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n      )\r\n\r\n      // This stores the address location of the implementation contract\r\n      // so that the proxy knows where to delegate call logic to\r\n      mstore(add(clone, 0x14), targetBytes)\r\n\r\n      // The bytecode block is the actual code that is deployed for each clone created.\r\n      // It forwards all calls to the already deployed implementation via a delegatecall\r\n      mstore(\r\n        add(clone, 0x28),\r\n        0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n      )\r\n\r\n      // deploy the contract using the CREATE2 opcode\r\n      // this deploys the minimal proxy defined above, which will proxy all\r\n      // calls to use the logic defined in the implementation contract `target`\r\n      result := create2(0, clone, 0x37, salt)\r\n    }\r\n  }\r\n\r\n  function isClone(address target, address query)\r\n    internal\r\n    view\r\n    returns (bool result)\r\n  {\r\n    bytes20 targetBytes = bytes20(target);\r\n    assembly {\r\n      // load the next free memory slot as a place to store the comparison clone\r\n      let clone := mload(0x40)\r\n\r\n      // The next three lines store the expected bytecode for a miniml proxy\r\n      // that targets `target` as its implementation contract\r\n      mstore(\r\n        clone,\r\n        0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\r\n      )\r\n      mstore(add(clone, 0xa), targetBytes)\r\n      mstore(\r\n        add(clone, 0x1e),\r\n        0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n      )\r\n\r\n      // the next two lines store the bytecode of the contract that we are checking in memory\r\n      let other := add(clone, 0x40)\r\n      extcodecopy(query, other, 0, 0x2d)\r\n\r\n      // Check if the expected bytecode equals the actual bytecode and return the result\r\n      result := and(\r\n        eq(mload(clone), mload(other)),\r\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Contract that exposes the needed erc20 token functions\r\n */\r\n\r\nabstract contract ERC20Interface {\r\n  // Send _value amount of tokens to address _to\r\n  function transfer(address _to, uint256 _value)\r\n    public\r\n    virtual\r\n    returns (bool success);\r\n\r\n  // Get the account balance of another account with address _owner\r\n  function balanceOf(address _owner)\r\n    public\r\n    virtual\r\n    view\r\n    returns (uint256 balance);\r\n}\r\n\r\n/**\r\n * Contract that will forward any incoming Ether to the creator of the contract\r\n *\r\n */\r\ncontract Forwarder {\r\n  // Address to which any funds sent to this contract will be forwarded\r\n  address public parentAddress;\r\n  event ForwarderDeposited(address from, uint256 value, bytes data);\r\n\r\n  /**\r\n   * Initialize the contract, and sets the destination address to that of the creator\r\n   */\r\n  function init(address _parentAddress) external onlyUninitialized {\r\n    parentAddress = _parentAddress;\r\n    this.flush();\r\n  }\r\n\r\n  /**\r\n   * Modifier that will execute internal code block only if the sender is the parent address\r\n   */\r\n  modifier onlyParent {\r\n    require(msg.sender == parentAddress, \"Only Parent\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Modifier that will execute internal code block only if the contract has not been initialized yet\r\n   */\r\n  modifier onlyUninitialized {\r\n    require(parentAddress == address(0x0), \"Already initialized\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Default function; Gets called when data is sent but does not match any other function\r\n   */\r\n  fallback() external payable {\r\n    this.flush();\r\n  }\r\n\r\n  /**\r\n   * Default function; Gets called when Ether is deposited with no data, and forwards it to the parent address\r\n   */\r\n  receive() external payable {\r\n    this.flush();\r\n  }\r\n\r\n  /**\r\n   * Execute a token transfer of the full balance from the forwarder token to the parent address\r\n   * @param tokenContractAddress the address of the erc20 token contract\r\n   */\r\n  function flushTokens(address tokenContractAddress) external onlyParent {\r\n    ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n    address forwarderAddress = address(this);\r\n    uint256 forwarderBalance = instance.balanceOf(forwarderAddress);\r\n    if (forwarderBalance == 0) {\r\n      return;\r\n    }\r\n\r\n    require(\r\n      instance.transfer(parentAddress, forwarderBalance),\r\n      \"Token flush failed\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Flush the entire balance of the contract to the parent address.\r\n   */\r\n  function flush() external {\r\n    uint256 value = address(this).balance;\r\n\r\n    if (value == 0) {\r\n      return;\r\n    }\r\n\r\n    (bool success, ) = parentAddress.call{ value: value }(\"\");\r\n    require(success, \"Flush failed\");\r\n    emit ForwarderDeposited(msg.sender, value, msg.data);\r\n  }\r\n}\r\n\r\n\r\ncontract ForwarderFactory is CloneFactory {\r\n  address public implementationAddress;\r\n\r\n  event ForwarderCreated(address newForwarderAddress, address parentAddress);\r\n\r\n  constructor(address _implementationAddress) {\r\n    implementationAddress = _implementationAddress;\r\n  }\r\n\r\n  function createForwarder(address parent, bytes32 salt) external {\r\n    // include the signers in the salt so any contract deployed to a given address must have the same signers\r\n    bytes32 finalSalt = keccak256(abi.encodePacked(parent, salt));\r\n\r\n    address payable clone = createClone(implementationAddress, finalSalt);\r\n    Forwarder(clone).init(parent);\r\n    emit ForwarderCreated(clone, parent);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementationAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newForwarderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"}],\"name\":\"ForwarderCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ForwarderFactory","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000085e0e3464bbb9a75d6b3dd4db241e49721fda555","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6c51323d5bfc49f95d195ebd20608f3ef528476730558060821b120f9ff859a7"}]}