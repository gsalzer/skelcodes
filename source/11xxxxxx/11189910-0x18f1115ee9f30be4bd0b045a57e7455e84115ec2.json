{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/upgradeable_contracts/Sacrifice.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract Sacrifice {\r\n    constructor(address _recipient) public payable {\r\n        selfdestruct(_recipient);\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Address.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Address\r\n * @dev Helper methods for Address type.\r\n */\r\nlibrary Address {\r\n    /**\r\n    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract\r\n    * @param _receiver address that will receive the native tokens\r\n    * @param _value the amount of native tokens to send\r\n    */\r\n    function safeSendValue(address _receiver, uint256 _value) internal {\r\n        if (!_receiver.send(_value)) {\r\n            (new Sacrifice).value(_value)(_receiver);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/BaseMediatorFeeManager.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n* @title BaseMediatorFeeManager\r\n* @dev Base fee manager to handle fees for AMB mediators.\r\n*/\r\ncontract BaseMediatorFeeManager is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event FeeUpdated(uint256 fee);\r\n\r\n    // This is not a real fee value but a relative value used to calculate the fee percentage.\r\n    // 1 ether = 100% of the value.\r\n    uint256 internal constant MAX_FEE = 1 ether;\r\n    uint256 internal constant MAX_REWARD_ACCOUNTS = 50;\r\n\r\n    uint256 public fee;\r\n    address[] internal rewardAccounts;\r\n    address internal mediatorContract;\r\n\r\n    modifier validFee(uint256 _fee) {\r\n        require(_fee < MAX_FEE);\r\n        /* solcov ignore next */\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the initial parameters of the fee manager.\r\n    * @param _owner address of the owner of the fee manager contract.\r\n    * @param _fee the fee percentage amount.\r\n    * @param _rewardAccountList list of addresses that will receive the fee rewards.\r\n    */\r\n    constructor(address _owner, uint256 _fee, address[] _rewardAccountList, address _mediatorContract) public {\r\n        require(_rewardAccountList.length > 0 && _rewardAccountList.length <= MAX_REWARD_ACCOUNTS);\r\n        _transferOwnership(_owner);\r\n        _setFee(_fee);\r\n        mediatorContract = _mediatorContract;\r\n\r\n        for (uint256 i = 0; i < _rewardAccountList.length; i++) {\r\n            require(isValidAccount(_rewardAccountList[i]));\r\n        }\r\n        rewardAccounts = _rewardAccountList;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the fee amount to be subtracted from the value.\r\n    * @param _value the base value from which fees are calculated\r\n    */\r\n    function calculateFee(uint256 _value) external view returns (uint256) {\r\n        return _value.mul(fee).div(MAX_FEE);\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the fee percentage amount for the mediator operations.\r\n    * @param _fee the fee percentage\r\n    */\r\n    function _setFee(uint256 _fee) internal validFee(_fee) {\r\n        fee = _fee;\r\n        emit FeeUpdated(_fee);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the fee percentage amount for the mediator operations. Only the owner can call this method.\r\n    * @param _fee the fee percentage\r\n    */\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        _setFee(_fee);\r\n    }\r\n\r\n    function isValidAccount(address _account) internal returns (bool) {\r\n        return _account != address(0) && _account != mediatorContract;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds a new account to the list of accounts to receive rewards for the operations.\r\n    * Only the owner can call this method.\r\n    * @param _account new reward account\r\n    */\r\n    function addRewardAccount(address _account) external onlyOwner {\r\n        require(isValidAccount(_account));\r\n        require(!isRewardAccount(_account));\r\n        require(rewardAccounts.length.add(1) < MAX_REWARD_ACCOUNTS);\r\n        rewardAccounts.push(_account);\r\n    }\r\n\r\n    /**\r\n    * @dev Removes an account from the list of accounts to receive rewards for the operations.\r\n    * Only the owner can call this method.\r\n    * finds the element, swaps it with the last element, and then deletes it;\r\n    * @param _account to be removed\r\n    * return boolean whether the element was found and deleted\r\n    */\r\n    function removeRewardAccount(address _account) external onlyOwner returns (bool) {\r\n        uint256 numOfAccounts = rewardAccountsCount();\r\n        for (uint256 i = 0; i < numOfAccounts; i++) {\r\n            if (rewardAccounts[i] == _account) {\r\n                rewardAccounts[i] = rewardAccounts[numOfAccounts - 1];\r\n                delete rewardAccounts[numOfAccounts - 1];\r\n                rewardAccounts.length--;\r\n                return true;\r\n            }\r\n        }\r\n        // If account is not found and removed, the transactions is reverted\r\n        revert();\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the amount of accounts in the list of reward accounts.\r\n    * @return amount of accounts.\r\n    */\r\n    function rewardAccountsCount() public view returns (uint256) {\r\n        return rewardAccounts.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells if the account is part of the list of reward accounts.\r\n    * @param _account to check if is part of the list.\r\n    * @return true if the account is in the list\r\n    */\r\n    function isRewardAccount(address _account) internal view returns (bool) {\r\n        for (uint256 i = 0; i < rewardAccountsCount(); i++) {\r\n            if (rewardAccounts[i] == _account) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the list of accounts that receives rewards for the operations.\r\n    * @return the list of reward accounts\r\n    */\r\n    function rewardAccountsList() public view returns (address[]) {\r\n        return rewardAccounts;\r\n    }\r\n\r\n    /**\r\n    * @dev ERC677 transfer callback function, received fee is distributed.\r\n    * @param _value amount of transferred tokens\r\n    */\r\n    function onTokenTransfer(address, uint256 _value, bytes) external returns (bool) {\r\n        distributeFee(_value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Distributes the provided amount of fees proportionally to the list of reward accounts.\r\n    * In case the fees cannot be equally distributed, the remaining difference will be distributed to an account\r\n    * in a semi-random way.\r\n    * @param _fee total amount to be distributed to the list of reward accounts.\r\n    */\r\n    function distributeFee(uint256 _fee) internal {\r\n        uint256 numOfAccounts = rewardAccountsCount();\r\n        uint256 feePerAccount = _fee.div(numOfAccounts);\r\n        uint256 randomAccountIndex;\r\n        uint256 diff = _fee.sub(feePerAccount.mul(numOfAccounts));\r\n        if (diff > 0) {\r\n            randomAccountIndex = random(numOfAccounts);\r\n        }\r\n\r\n        for (uint256 i = 0; i < numOfAccounts; i++) {\r\n            uint256 feeToDistribute = feePerAccount;\r\n            if (diff > 0 && randomAccountIndex == i) {\r\n                feeToDistribute = feeToDistribute.add(diff);\r\n            }\r\n            onFeeDistribution(rewardAccounts[i], feeToDistribute);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates a random number based on the block number.\r\n    * @param _count the max value for the random number.\r\n    * @return a number between 0 and _count.\r\n    */\r\n    function random(uint256 _count) internal view returns (uint256) {\r\n        return uint256(blockhash(block.number.sub(1))) % _count;\r\n    }\r\n\r\n    /* solcov ignore next */\r\n    function onFeeDistribution(address _rewardAddress, uint256 _fee) internal;\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/amb_native_to_erc20/HomeFeeManagerAMBNativeToErc20.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n* @title HomeFeeManagerAMBNativeToErc20\r\n* @dev Implements the logic to distribute fees from the native to erc20 mediator contract operations.\r\n* The fees are distributed in the form of native tokens to the list of reward accounts.\r\n*/\r\ncontract HomeFeeManagerAMBNativeToErc20 is BaseMediatorFeeManager {\r\n    /**\r\n    * @dev Stores the initial parameters of the fee manager.\r\n    * @param _owner address of the owner of the fee manager contract.\r\n    * @param _fee the fee percentage amount.\r\n    * @param _rewardAccountList list of addresses that will receive the fee rewards.\r\n    */\r\n    constructor(address _owner, uint256 _fee, address[] _rewardAccountList, address _mediatorContract)\r\n        public\r\n        BaseMediatorFeeManager(_owner, _fee, _rewardAccountList, _mediatorContract)\r\n    {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback method to receive the fees.\r\n    */\r\n    function() public payable {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the fee as native tokens to the reward account.\r\n    * @param _rewardAddress address that will receive the native tokens.\r\n    * @param _fee amount of native tokens to be distribute.\r\n    */\r\n    function onFeeDistribution(address _rewardAddress, uint256 _fee) internal {\r\n        Address.safeSendValue(_rewardAddress, _fee);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeRewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAccountsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addRewardAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAccountsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_rewardAccountList\",\"type\":\"address[]\"},{\"name\":\"_mediatorContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HomeFeeManagerAMBNativeToErc20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b7a42ba759ad21bdf543749f8c1b15e9c7a2a5c700000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000f127003ea39878efeee89aa4e22248cc6cb7728e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000004779eab5d63dd156ec51b842e7f43cb821fc8716","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://14ea18c036bbaae21aa24efb038a5e48c718524cd08b802268c5a1137ef95ae8"}]}