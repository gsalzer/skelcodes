{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/*\\n  Interface of the ERC20 standard as defined in the EIP. Does not include\\n  the optional functions.\\n*/\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount)\\n        external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IFactRegistry.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/*\\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\\n  business logic of the contract flow.\\n\\n  A fact registry holds a hash table of verified \\\"facts\\\" which are represented by a hash of claims\\n  that the registry hash check and found valid. This table may be queried by accessing the\\n  isValid() function of the registry with a given hash.\\n\\n  In addition, each fact registry exposes a registry specific function for submitting new claims\\n  together with their proofs. The information submitted varies from one registry to the other\\n  depending of the type of fact requiring verification.\\n\\n  For further reading on the Fact Registry design pattern see this\\n  `StarkWare blog post \\u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\\u003e`_.\\n*/\\ncontract IFactRegistry {\\n    /*\\n      Returns true if the given fact was previously registered in the contract.\\n    */\\n    function isValid(bytes32 fact)\\n        external view\\n        returns(bool);\\n}\\n\"},\"PublicInputOffsets.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\ncontract PublicInputOffsets {\\n    // The following constants are offsets of data expected in the public input.\\n    uint256 internal constant OFFSET_LOG_TRACE_LENGTH = 0;\\n    uint256 internal constant OFFSET_VDF_OUTPUT_X = 1;\\n    uint256 internal constant OFFSET_VDF_OUTPUT_Y = 2;\\n    uint256 internal constant OFFSET_VDF_INPUT_X = 3;\\n    uint256 internal constant OFFSET_VDF_INPUT_Y = 4;\\n    // The Verifier derives the number of iterations from the log of the trace length.\\n    // The Vending contract uses the number of iterations.\\n    uint256 internal constant OFFSET_N_ITER = 0;\\n}\\n\"},\"VendingMachineERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./IFactRegistry.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./PublicInputOffsets.sol\\\";\\n/**\\n  VeeDo is a STARK-based Verifiable Delay Function (VDF) service. VeeDo works in the \\\"Vending\\n  Machine model\\\" - users can pay in advance for a randomness request, knowing that either the\\n  request will be served, or they will be able to get their payment back.\\n  User make a request by calling `addPayment(seed, n_iter)` where seed is used to generate the\\n  VDF input and n_iter is the number of iterations.\\n  An off-chain service picks up the request, computes the randomness and generates a proof\\n  attesting to the validity of the computation. The proof is then sent to the STARK prover. If the\\n  Verifier accepts the corresponding proof, `registerAndCollect()` allows the off-chain service to\\n  register the randomness and receive the payment.\\n  In case a request was not served, the user can reclaim their payment through `reclaimPayment()`\\n  after RECLAIM_DELAY has passed.\\n*/\\ncontract VendingMachineERC20 is PublicInputOffsets {\\n\\n\\n    // Emitted by addPayment() when a user makes a payment for a randomness.\\n    event LogNewPayment(uint256 seed, uint256 n_iter, uint256 paymentAmount);\\n    // Emitted by reclaimPayment() when a user reclaims a payment they made.\\n    event LogPaymentReclaimed(\\n        address sender,\\n        uint256 seed,\\n        uint256 n_iter,\\n        uint256 tag,\\n        uint256 reclaimedAmount\\n    );\\n    // Emitted by registerAndCollect() when a new randomness is registered.\\n    event LogNewRandomness(uint256 seed, uint256 n_iter, bytes32 randomness);\\n\\n    struct Payment {\\n        // The last time a user sent a payment for given (sender, seed, n_iter, tag).\\n        uint256 timeSent;\\n        // The sum of those payments.\\n        uint256 amount;\\n    }\\n\\n    // Mapping: (seed, n_iters) -\\u003e total_amount.\\n    // Represents prize amount for VDF(seed, n_iter) solver.\\n    // prizes(seed, n_iter) is always equal to the sum of\\n    // payments(sender, seed, n_iters, tag) over all \\u0027sender\\u0027 and \\u0027tag\\u0027.\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256)) public prizes;\\n    // Mapping: (sender, seed, n_iters, tag) -\\u003e Payment.\\n    // Information to support reclaiming of payments.\\n    // \\u0027tag\\u0027 is used to allow a wrapper contract to distinguish between different users.\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e mapping(uint256 =\\u003e Payment))))\\n        public payments;\\n    // Mapping: (seed, n_iters) -\\u003e randomness.\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e bytes32)) public registeredRandomness;\\n    // Mapping: address -\\u003e isOwner.\\n    mapping(address =\\u003e bool) owners;\\n\\n    // The Verifier contracts verifies the proof of the VDF.\\n    IFactRegistry public verifierContract;\\n    // The address of ERC20 tokens being accepted as payments.\\n    address public tokenAddress;\\n    uint256 internal constant PRIME = 0x30000003000000010000000000000001;\\n    uint256 internal constant PUBLIC_INPUT_SIZE = 5;\\n    uint256 internal constant RECLAIM_DELAY = 1 days;\\n\\n    // Modifiers.\\n    modifier onlyOwner {\\n        require(owners[msg.sender], \\\"ONLY_OWNER\\\");\\n        _;\\n    }\\n\\n    modifier randomnessNotRegistered(uint256 seed, uint256 n_iter) {\\n        require(\\n            registeredRandomness[seed][n_iter] == 0,\\n            \\\"REGSITERED_RANDOMNESS\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address verifierAddress, address token) public {\\n        owners[msg.sender] = true;\\n        verifierContract = IFactRegistry(verifierAddress);\\n        tokenAddress = token;\\n    }\\n\\n    function addOwner(address newOwner) external onlyOwner {\\n        owners[newOwner] = true;\\n    }\\n\\n    function removeOwner(address removedOwner) external onlyOwner {\\n        require(msg.sender != removedOwner, \\\"CANT_REMOVE_SELF\\\");\\n        owners[removedOwner] = false;\\n    }\\n\\n    /*\\n      Adds a payment from msg.sender, and updates timeSent to \\u0027now\\u0027.\\n      Note - the sender must make an allowance first.\\n    */\\n    function addPayment(\\n        uint256 seed,\\n        uint256 n_iter,\\n        uint256 tag,\\n        uint256 paymentAmount\\n    ) external randomnessNotRegistered(seed, n_iter) {\\n        // Sends the payment from the user to the contract.\\n        transferIn(paymentAmount);\\n\\n        // Updates mapping.\\n        payments[msg.sender][seed][n_iter][tag].amount += paymentAmount;\\n        payments[msg.sender][seed][n_iter][tag].timeSent = now;\\n        prizes[seed][n_iter] += paymentAmount;\\n\\n        emit LogNewPayment(seed, n_iter, paymentAmount);\\n    }\\n\\n    /*\\n      Allows a user to reclaim their payment if it was not already served and RECLAIM_DELAY has\\n      passed since the last payment.\\n    */\\n    function reclaimPayment(\\n        uint256 seed,\\n        uint256 n_iter,\\n        uint256 tag\\n    ) external randomnessNotRegistered(seed, n_iter) {\\n        Payment memory userPayment = payments[msg.sender][seed][n_iter][tag];\\n\\n        // Make sure a payment is available to reclaim.\\n        require(userPayment.amount \\u003e 0, \\\"NO_PAYMENT\\\");\\n\\n        // Make sure enough time has passed.\\n        uint256 lastPaymentTime = userPayment.timeSent;\\n        uint256 releaseTime = lastPaymentTime + RECLAIM_DELAY;\\n        assert(releaseTime \\u003e= RECLAIM_DELAY);\\n        // solium-disable-next-line security/no-block-members\\n        require(now \\u003e= releaseTime, \\\"PAYMENT_LOCKED\\\");\\n\\n        // Deduct reclaimed payment from mappings.\\n        prizes[seed][n_iter] -= userPayment.amount;\\n        payments[msg.sender][seed][n_iter][tag].amount = 0;\\n\\n        // Send the payment back to the user.\\n        transferOut(userPayment.amount);\\n\\n        emit LogPaymentReclaimed(\\n            msg.sender,\\n            seed,\\n            n_iter,\\n            tag,\\n            userPayment.amount\\n        );\\n    }\\n\\n    function registerAndCollect(\\n        uint256 seed,\\n        uint256 n_iter,\\n        uint256 vdfOutputX,\\n        uint256 vdfOutputY\\n    ) external onlyOwner randomnessNotRegistered(seed, n_iter) {\\n        registerNewRandomness(seed, n_iter, vdfOutputX, vdfOutputY);\\n        transferOut(prizes[seed][n_iter]);\\n    }\\n\\n    /*\\n      Registers a new randomness if vdfOutputX and vdfOutputY are valid field elements and the\\n      fact (n_iter, vdfInputX, vdfInputY, vdfOutputX, vdfOutputY) is valid fact in the Verifier.\\n    */\\n    function registerNewRandomness(\\n        uint256 seed,\\n        uint256 n_iter,\\n        uint256 vdfOutputX,\\n        uint256 vdfOutputY\\n    ) internal {\\n        require(vdfOutputX \\u003c PRIME \\u0026\\u0026 vdfOutputY \\u003c PRIME, \\\"INVALID_VDF_OUTPUT\\\");\\n\\n        (uint256 vdfInputX, uint256 vdfInputY) = seed2vdfInput(seed);\\n\\n        uint256[PUBLIC_INPUT_SIZE] memory proofPublicInput;\\n        proofPublicInput[OFFSET_N_ITER] = n_iter;\\n        proofPublicInput[OFFSET_VDF_INPUT_X] = vdfInputX;\\n        proofPublicInput[OFFSET_VDF_INPUT_Y] = vdfInputY;\\n        proofPublicInput[OFFSET_VDF_OUTPUT_X] = vdfOutputX;\\n        proofPublicInput[OFFSET_VDF_OUTPUT_Y] = vdfOutputY;\\n\\n        require(\\n            verifierContract.isValid(\\n                keccak256(abi.encodePacked(proofPublicInput))\\n            ),\\n            \\\"FACT_NOT_REGISTERED\\\"\\n        );\\n\\n        // The randomness is the hash of the VDF output and the string \\\"veedo\\\".\\n        bytes32 randomness = keccak256(\\n            abi.encodePacked(\\n                proofPublicInput[OFFSET_VDF_OUTPUT_X],\\n                proofPublicInput[OFFSET_VDF_OUTPUT_Y],\\n                \\\"veedo\\\"\\n            )\\n        );\\n        registeredRandomness[seed][n_iter] = randomness;\\n\\n        emit LogNewRandomness(seed, n_iter, randomness);\\n    }\\n\\n    /*\\n      Transfers funds from the contract to msg.sender.\\n    */\\n    function transferOut(uint256 amount) internal {\\n        safeERC20Call(\\n            address(tokenAddress),\\n            abi.encodeWithSelector(\\n                IERC20(0).transfer.selector,\\n                msg.sender,\\n                amount\\n            )\\n        );\\n    }\\n\\n    /*\\n      Transfers funds from msg.sender to the contract.\\n    */\\n    function transferIn(uint256 amount) internal {\\n        safeERC20Call(\\n            address(tokenAddress),\\n            abi.encodeWithSelector(\\n                IERC20(0).transferFrom.selector,\\n                msg.sender,\\n                address(this),\\n                amount\\n            )\\n        );\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20 calls.\\n      This is required because many deployed ERC20 contracts don\\u0027t return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeERC20Call(address tokenAddress, bytes memory callData)\\n        internal\\n    {\\n        // solium-disable-next-line security/no-low-level-calls\\n        (bool success, bytes memory returndata) = address(tokenAddress).call(\\n            callData\\n        );\\n        require(success, string(returndata));\\n\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"ERC20_OPERATION_FAILED\\\");\\n        }\\n    }\\n\\n    /*\\n      Generates VDF inputs from seed.\\n    */\\n    function seed2vdfInput(uint256 seed)\\n        public\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        uint256 vdfInput = uint256(keccak256(abi.encodePacked(seed, \\\"veedo\\\")));\\n        uint256 vdfInputX = vdfInput \\u0026 ((1 \\u003c\\u003c 125) - 1);\\n        uint256 vdfInputY = ((vdfInput \\u003e\\u003e 125) \\u0026 ((1 \\u003c\\u003c 125) - 1));\\n        return (vdfInputX, vdfInputY);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifierAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"n_iter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"LogNewPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"n_iter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"randomness\",\"type\":\"bytes32\"}],\"name\":\"LogNewRandomness\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"n_iter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tag\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reclaimedAmount\",\"type\":\"uint256\"}],\"name\":\"LogPaymentReclaimed\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n_iter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tag\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"addPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n_iter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tag\",\"type\":\"uint256\"}],\"name\":\"reclaimPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n_iter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vdfOutputX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vdfOutputY\",\"type\":\"uint256\"}],\"name\":\"registerAndCollect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredRandomness\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removedOwner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"seed2vdfInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifierContract\",\"outputs\":[{\"internalType\":\"contract IFactRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VendingMachineERC20","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000295f9825e9c7fdbec8803cd8f40f06661dd0fc2b0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e7f1cff2b4a856758703615a23489c09ee9ae814fed91e85e471016c53cd8a01"}]}