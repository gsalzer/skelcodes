{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\n// \n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nenum OptionType {Invalid, Put, Call}\n\nenum PurchaseMethod {Invalid, Contract, ZeroEx}\n\nstruct OptionTerms {\n    address underlying;\n    address strikeAsset;\n    address collateralAsset;\n    uint256 expiry;\n    uint256 strikePrice;\n    OptionType optionType;\n    address paymentToken;\n}\n\ninterface IProtocolAdapter {\n    /**\n     * @notice Emitted when a new option contract is purchased\n     */\n    event Purchased(\n        address indexed caller,\n        string indexed protocolName,\n        address indexed underlying,\n        uint256 amount,\n        uint256 optionID\n    );\n\n    /**\n     * @notice Emitted when an option contract is exercised\n     */\n    event Exercised(\n        address indexed caller,\n        address indexed options,\n        uint256 indexed optionID,\n        uint256 amount,\n        uint256 exerciseProfit\n    );\n\n    /**\n     * @notice Name of the adapter. E.g. \"HEGIC\", \"OPYN_V1\". Used as index key for adapter addresses\n     */\n    function protocolName() external pure returns (string memory);\n\n    /**\n     * @notice Boolean flag to indicate whether to use option IDs or not.\n     * Fungible protocols normally use tokens to represent option contracts.\n     */\n    function nonFungible() external pure returns (bool);\n\n    /**\n     * @notice Returns the purchase method used to purchase options\n     */\n    function purchaseMethod() external pure returns (PurchaseMethod);\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(OptionTerms calldata optionTerms)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(OptionTerms calldata optionTerms)\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     * @param optionTerms is the terms of the option contract\n     * @param purchaseAmount is the number of options purchased\n     */\n    function premium(OptionTerms calldata optionTerms, uint256 purchaseAmount)\n        external\n        view\n        returns (uint256 cost);\n\n    /**\n     * @notice Amount of profit made from exercising an option contract (current price - strike price). 0 if exercising out-the-money.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     */\n    function exerciseProfit(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256 profit);\n\n    function canExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (bool);\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     */\n    function purchase(\n        OptionTerms calldata optionTerms,\n        uint256 amount,\n        uint256 maxCost\n    ) external payable returns (uint256 optionID);\n\n    /**\n     * @notice Exercises the options contract.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     * @param recipient is the account that receives the exercised profits. This is needed since the adapter holds all the positions and the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external payable;\n\n    function createShort(OptionTerms calldata optionTerms, uint256 amount)\n        external\n        returns (uint256);\n\n    function closeShort() external returns (uint256);\n}\n\nenum HegicOptionType {Invalid, Put, Call}\n\nenum State {Inactive, Active, Exercised, Expired}\n\ninterface IHegicOptions {\n    event Create(\n        uint256 indexed id,\n        address indexed account,\n        uint256 settlementFee,\n        uint256 totalFee\n    );\n\n    event Exercise(uint256 indexed id, uint256 profit);\n    event Expire(uint256 indexed id, uint256 premium);\n\n    function options(uint256)\n        external\n        view\n        returns (\n            State state,\n            address payable holder,\n            uint256 strike,\n            uint256 amount,\n            uint256 lockedAmount,\n            uint256 premium,\n            uint256 expiration,\n            HegicOptionType optionType\n        );\n\n    function create(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        HegicOptionType optionType\n    ) external payable returns (uint256 optionID);\n\n    function exercise(uint256 optionID) external;\n\n    function priceProvider() external view returns (address);\n}\n\ninterface IHegicETHOptions is IHegicOptions {\n    function fees(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        HegicOptionType optionType\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 strikeFee,\n            uint256 periodFee\n        );\n}\n\ninterface IHegicBTCOptions is IHegicOptions {\n    function fees(\n        uint256 period,\n        uint256 amount,\n        uint256 strike,\n        HegicOptionType optionType\n    )\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 totalETH,\n            uint256 settlementFee,\n            uint256 strikeFee,\n            uint256 periodFee\n        );\n}\n\ninterface IHegicRewards {\n  function hegic() external view returns (IERC20);\n  function hegicOptions() external view returns (IHegicOptions);\n  function rewardsRate() external view returns (uint256);\n  function rewardedOptions(uint optionId) external view returns(bool);\n  function getReward(uint optionId) external;\n}\n\ninterface ISwapPair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// \ncontract HegicAdapter is IProtocolAdapter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string private constant _name = \"HEGIC\";\n    bool private constant _nonFungible = true;\n    address public immutable ethAddress;\n    address public constant wethAddress =\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address public immutable wbtcAddress;\n    IHegicETHOptions public immutable ethOptions;\n    IHegicBTCOptions public immutable wbtcOptions;\n    ISwapPair public immutable ethWbtcPair;\n\n    /**\n     * @notice constructor for the HegicAdapter\n     * @param _ethOptions is the contract address for the mainnet HegicETHOptions\n     * @param _wbtcOptions is the contract address for the mainnet HegicWBTCOptions\n     * @param _ethAddress is the contract address for Ethereum, defaults to zero address\n     * @param _wbtcOptions is the contract address for mainnet WBTC\n     */\n    constructor(\n        address _ethOptions,\n        address _wbtcOptions,\n        address _ethAddress,\n        address _wbtcAddress,\n        address _ethWbtcPair\n    ) {\n        ethOptions = IHegicETHOptions(_ethOptions);\n        wbtcOptions = IHegicBTCOptions(_wbtcOptions);\n        ethAddress = _ethAddress;\n        wbtcAddress = _wbtcAddress;\n        // add check of correct Pair OR use token addresses to calc the pair address\n        ethWbtcPair = ISwapPair(_ethWbtcPair);\n    }\n\n    receive() external payable {}\n\n    function protocolName() public pure override returns (string memory) {\n        return _name;\n    }\n\n    function nonFungible() external pure override returns (bool) {\n        return _nonFungible;\n    }\n\n    function purchaseMethod() external pure override returns (PurchaseMethod) {\n        return PurchaseMethod.Contract;\n    }\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(OptionTerms calldata optionTerms)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return\n            optionTerms.underlying == ethAddress ||\n            optionTerms.underlying == wbtcAddress;\n    }\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(OptionTerms calldata optionTerms)\n        external\n        view\n        override\n        returns (address)\n    {\n        if (optionTerms.underlying == ethAddress) {\n            return address(ethOptions);\n        } else if (optionTerms.underlying == wbtcAddress) {\n            return address(wbtcOptions);\n        }\n        require(false, \"No options found\");\n    }\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     * @param optionTerms is the terms of the option contract\n     * @param purchaseAmount is the purchase amount in Wad units (10**18)\n     */\n    function premium(OptionTerms memory optionTerms, uint256 purchaseAmount)\n        public\n        view\n        override\n        returns (uint256 cost)\n    {\n        require(\n            block.timestamp < optionTerms.expiry,\n            \"Cannot purchase after expiry\"\n        );\n\n        uint256 period = optionTerms.expiry.sub(block.timestamp);\n        uint256 scaledStrikePrice =\n            scaleDownStrikePrice(optionTerms.strikePrice);\n\n        if (optionTerms.underlying == ethAddress) {\n            require(\n                optionTerms.underlying == optionTerms.paymentToken,\n                \"!invalid paymentToken\"\n            );\n            (cost, , , ) = ethOptions.fees(\n                period,\n                purchaseAmount,\n                scaledStrikePrice,\n                HegicOptionType(uint8(optionTerms.optionType))\n            );\n        } else if (optionTerms.underlying == wbtcAddress) {\n            uint256 costWBTC;\n            (costWBTC, cost, , , ) = wbtcOptions.fees(\n                period,\n                purchaseAmount,\n                scaledStrikePrice,\n                HegicOptionType(uint8(optionTerms.optionType))\n            );\n            if (optionTerms.paymentToken == wbtcAddress) {\n                cost = costWBTC;\n            }\n        } else {\n            revert(\"No matching underlying\");\n        }\n    }\n\n    /**\n     * @notice Amount of profit made from exercising an option contract (current price - strike price). 0 if exercising out-the-money.\n     * @param optionsAddress is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     */\n    function exerciseProfit(\n        address optionsAddress,\n        uint256 optionID,\n        uint256\n    ) public view override returns (uint256 profit) {\n        require(\n            optionsAddress == address(ethOptions) ||\n                optionsAddress == address(wbtcOptions),\n            \"optionsAddress must match either ETH or WBTC options\"\n        );\n        IHegicOptions options = IHegicOptions(optionsAddress);\n\n        AggregatorV3Interface priceProvider =\n            AggregatorV3Interface(options.priceProvider());\n        (, int256 latestPrice, , , ) = priceProvider.latestRoundData();\n        uint256 currentPrice = uint256(latestPrice);\n\n        (\n            ,\n            ,\n            uint256 strike,\n            uint256 amount,\n            uint256 lockedAmount,\n            ,\n            ,\n            HegicOptionType optionType\n        ) = options.options(optionID);\n\n        if (optionType == HegicOptionType.Call) {\n            if (currentPrice >= strike) {\n                profit = currentPrice.sub(strike).mul(amount).div(currentPrice);\n            } else {\n                profit = 0;\n            }\n        } else {\n            if (currentPrice <= strike) {\n                profit = strike.sub(currentPrice).mul(amount).div(currentPrice);\n            } else {\n                profit = 0;\n            }\n        }\n        if (profit > lockedAmount) profit = lockedAmount;\n    }\n\n    function canExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) public view override returns (bool) {\n        bool matchOptionsAddress =\n            options == address(ethOptions) || options == address(wbtcOptions);\n\n        (State state, , , , , , uint256 expiration, ) =\n            IHegicOptions(options).options(optionID);\n        amount = 0;\n\n        uint256 profit = exerciseProfit(options, optionID, amount);\n\n        return\n            matchOptionsAddress &&\n            expiration >= block.timestamp &&\n            state == State.Active &&\n            profit > 0;\n    }\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     * @param maxCost is the max amount of paymentToken to be paid for the option (to avoid sandwich attacks, ...)\n     */\n    function purchase(\n        OptionTerms calldata optionTerms,\n        uint256 amount,\n        uint256 maxCost\n    ) external payable override returns (uint256 optionID) {\n        require(\n            block.timestamp < optionTerms.expiry,\n            \"Cannot purchase after expiry\"\n        );\n\n        uint256 scaledStrikePrice =\n            scaleDownStrikePrice(optionTerms.strikePrice);\n        uint256 period = optionTerms.expiry.sub(block.timestamp);\n        IHegicOptions options = getHegicOptions(optionTerms.underlying);\n\n        // swap for ETH if ETH has not been provided as paymentToken\n        if (msg.value == 0) {\n            OptionTerms memory optionTermsWithETH = optionTerms;\n            optionTermsWithETH.paymentToken = ethAddress;\n            uint256 cost = premium(optionTermsWithETH, amount);\n\n            require(\n                optionTerms.paymentToken == wbtcAddress,\n                \"Invalid paymentToken or msg.value\"\n            );\n            uint256 costWBTC = _getAmountsIn(cost);\n            require(maxCost >= costWBTC, \"MaxCost is too low\");\n            _swapWBTCToETH(costWBTC, cost);\n        }\n\n        // Gas optimization to avoid double counting premium()\n        // This will revert if the address(this).balance is not sufficient\n        // Any extras will be refunded to the address(this)\n        // This could potentially be a large security vuln. if the Options contract\n        // does not refund the change\n        optionID = options.create{value: address(this).balance}(\n            period,\n            amount,\n            scaledStrikePrice,\n            HegicOptionType(uint8(optionTerms.optionType))\n        );\n\n        emit Purchased(\n            msg.sender,\n            _name,\n            optionTerms.underlying,\n            msg.value,\n            optionID\n        );\n    }\n\n    /**\n     * @notice Exercises the options contract.\n     * @param optionsAddress is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     * @param account is the account that receives the exercised profits. This is needed since the adapter holds all the positions and the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address optionsAddress,\n        uint256 optionID,\n        uint256 amount,\n        address account\n    ) external payable override {\n        require(\n            optionsAddress == address(ethOptions) ||\n                optionsAddress == address(wbtcOptions),\n            \"optionsAddress must match either ETH or WBTC options\"\n        );\n\n        IHegicOptions options = IHegicOptions(optionsAddress);\n\n        uint256 profit = exerciseProfit(optionsAddress, optionID, amount);\n\n        options.exercise(optionID);\n\n        if (optionsAddress == address(ethOptions)) {\n            (bool success, ) = account.call{value: profit}(\"\");\n            require(success, \"Failed transfer\");\n        } else {\n            IERC20 wbtc = IERC20(wbtcAddress);\n            wbtc.safeTransfer(account, profit);\n        }\n\n        emit Exercised(account, optionsAddress, optionID, amount, profit);\n    }\n\n    function _swapWBTCToETH(uint256 costWBTC, uint256 costETH) internal {\n        IERC20(wbtcAddress).safeTransferFrom(\n            msg.sender,\n            address(ethWbtcPair),\n            costWBTC\n        ); // send WBTC directly to the Uniswap Pair (requires approval of WBTC)\n        uint256 amount0Out;\n        uint256 amount1Out;\n        (amount0Out, amount1Out) = (uint256(0), costETH); // in case we change tokens (currently using WETH<>WBTC pair) this should be reviewed\n        ethWbtcPair.swap(amount0Out, amount1Out, address(this), \"\");\n        IWETH(wethAddress).withdraw(costETH); // unwrapping ETH. It would not be required if options are paid using WETH\n    }\n\n    // from UniswapV2Library\n    function _getAmountsIn(uint256 amountOut)\n        internal\n        view\n        returns (uint256 amountIn)\n    {\n        uint256 reserveIn;\n        uint256 reserveOut;\n        (uint256 reserve0, uint256 reserve1, ) = ethWbtcPair.getReserves();\n        (reserveIn, reserveOut) = (reserve0, reserve1);\n        // getAmountIn\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    /**\n     * @notice Function to get rHEGIC2 rewards claimable from liquidity utilization\n     * @param rewardsAddress is the address of the rewards contract (either for eth or wbtc)\n     * @param optionIDs is an array of all the option ids we want to claim rewards for\n     */\n    function rewardsClaimable(\n        address rewardsAddress,\n        uint256[] calldata optionIDs\n    ) external view returns (uint256 rewardsAmount) {\n        IHegicRewards rewardsContract = IHegicRewards(rewardsAddress);\n        IHegicOptions hegicOptions = rewardsContract.hegicOptions();\n        uint256 rewardsRate = rewardsContract.rewardsRate();\n\n        uint256 i = 0;\n\n        while (i < optionIDs.length && optionIDs[i] > 0) {\n            (, , , uint256 _amount, , uint256 _premium, , ) =\n                hegicOptions.options(optionIDs[i]);\n            if (!rewardsContract.rewardedOptions(optionIDs[i])) {\n                rewardsAmount = rewardsAmount.add(\n                    _amount.div(100).add(_premium).mul(rewardsRate).div(1e8)\n                );\n            }\n            i += 1;\n        }\n    }\n\n    /**\n     * @notice Function to get rHEGIC2 rewards claimable from liquidity utilization\n     * @param rewardsAddress is the address of the rewards contract (either for eth or wbtc)\n     * @param optionIDs is an array of all the option ids we want to claim rewards for\n     */\n    function claimRewards(address rewardsAddress, uint256[] calldata optionIDs)\n        external\n        returns (uint256 rewardsAmount)\n    {\n        IHegicRewards rewardsContract = IHegicRewards(rewardsAddress);\n        IERC20 hegicToken = rewardsContract.hegic();\n\n        uint256 i = 0;\n\n        uint256 balanceBefore = hegicToken.balanceOf(address(this));\n\n        while (i < optionIDs.length && optionIDs[i] > 0) {\n            try rewardsContract.getReward(optionIDs[i]) {} catch {}\n            i += 1;\n        }\n\n        uint256 balanceAfter = hegicToken.balanceOf(address(this));\n\n        rewardsAmount = balanceAfter.sub(balanceBefore);\n        require(rewardsAmount > 0, \"No rewards to claim\");\n        hegicToken.safeTransfer(msg.sender, rewardsAmount);\n    }\n\n    function createShort(OptionTerms memory, uint256)\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function closeShort() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @notice Helper function to get the options address based on the underlying asset\n     * @param underlying is the underlying asset for the options\n     */\n    function getHegicOptions(address underlying)\n        private\n        view\n        returns (IHegicOptions)\n    {\n        if (underlying == ethAddress) {\n            return ethOptions;\n        } else if (underlying == wbtcAddress) {\n            return wbtcOptions;\n        }\n        require(false, \"No matching options contract\");\n    }\n\n    /**\n     * @notice Helper function to scale down strike prices from 10**18 to 10**8\n     * @param strikePrice is the strikePrice in 10**18\n     */\n    function scaleDownStrikePrice(uint256 strikePrice)\n        private\n        pure\n        returns (uint256)\n    {\n        // converts strike price in 10**18 to 10**8\n        return strikePrice.div(10**10);\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ethOptions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbtcOptions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbtcAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethWbtcPair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"options\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exerciseProfit\",\"type\":\"uint256\"}],\"name\":\"Exercised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"protocolName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"options\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canExercise\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"optionIDs\",\"type\":\"uint256[]\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeShort\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct OptionTerms\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createShort\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethOptions\",\"outputs\":[{\"internalType\":\"contract IHegicETHOptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethWbtcPair\",\"outputs\":[{\"internalType\":\"contract ISwapPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"optionsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"exercise\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"optionsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exerciseProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"}],\"name\":\"getOptionsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonFungible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"}],\"name\":\"optionsExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"purchaseAmount\",\"type\":\"uint256\"}],\"name\":\"premium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCost\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseMethod\",\"outputs\":[{\"internalType\":\"enum PurchaseMethod\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"optionIDs\",\"type\":\"uint256[]\"}],\"name\":\"rewardsClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbtcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbtcOptions\",\"outputs\":[{\"internalType\":\"contract IHegicBTCOptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"HegicAdapter","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000efc0eeadc1132a12c9487d800112693bf49ecfa20000000000000000000000003961245db602ed7c03eeccda33ea3846bd8723bd00000000000000000000000000000000000000000000000000000000000000000000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000bb2b8038a1640196fbe3e38816f3e67cba72d940","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}