{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.12;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IAward {\r\n    function addFreeAward(address _user, uint256 _amount) external;\r\n    function addAward(address _user, uint256 _amount) external;\r\n    function withdraw(uint256 _amount) external;\r\n    function destroy(uint256 amount) external;\r\n}\r\n\r\ninterface IERC20Token is IERC20 {\r\n    function maxSupply() external view returns (uint256);\r\n    function issue(address account, uint256 amount) external returns (bool);\r\n    function burn(uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface ILPMining {\r\n    function add(address pool, uint256 index, uint256 allocP) external;\r\n    function set(uint256 pid, uint256 allocPoint) external;\r\n    function updateReferenceToken(uint256 pid, uint256 rIndex) external;\r\n    function batchSharePools() external;\r\n    function onTransferLiquidity(address from, address to, uint256 lpAmount) external;\r\n    function claimUserShares(uint pid, address user) external;\r\n    function claimLiquidityShares(address user, address[] calldata tokens, uint256[] calldata balances, uint256[] calldata weights, uint256 amount, bool _add) external;\r\n}\r\n\r\ninterface IOracle {\r\n    function requestTokenPrice(address token) external returns(uint8 decimal, uint256 price);\r\n}\r\n\r\ninterface IPool is IERC20 {\r\n    function getCurrentTokens() external view returns (address[] memory);\r\n    function getNormalizedWeight(address token) external view returns (uint);\r\n    function getBalance(address token) external view returns (uint);\r\n}\r\n\r\ncontract LPMiningV1 is ILPMining, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct ShareInfo {\r\n        uint256 tvl;\r\n        uint256 accPoolPerShare;\r\n        uint256 lastRewardBlock;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        IPool mPool;\r\n        //reference currency for tvl calculation\r\n        uint256 poolIndex;\r\n        uint256 referIndex;\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. token to distribute per block.\r\n        uint256 lastTvl;\r\n        uint256 accTokenPerShare;\r\n        uint256 rewardDebt;\r\n        address[] tokens;\r\n        uint256[] balances;\r\n        uint256[] weights;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    // pool info\r\n    address[] public pools;\r\n    mapping(address => PoolInfo) public poolInfo;\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // top share info\r\n    ShareInfo public shareInfo;\r\n\r\n    // contract governors\r\n    mapping(address => bool) private governors;\r\n    modifier onlyGovernor{\r\n        require(governors[_msgSender()], \"LPMiningV1: caller is not the governor\");\r\n        _;\r\n    }\r\n\r\n    IOracle public priceOracle;\r\n    // The block number when Token mining starts.\r\n    uint256 immutable public startBlock;\r\n    // The block number when triple rewards mining ends.\r\n    uint256 immutable public endTripleBlock;\r\n    // The block number when Token mining ends.\r\n    uint256 public endBlock;\r\n\r\n    // tokens created per block changed with Token price.\r\n    uint256 public tokenPerBlock = 15 * 10 ** 17;\r\n\r\n    // award\r\n    IAward  public award;\r\n\r\n    event Initialization(address award, uint256 _tokenPerBlock, uint256 startBlock, uint256 endTripleBlock, uint256 endBlock, address oracle);\r\n    event Add(address mPool, uint256 index, uint256 allocP);\r\n    event Set(uint256 pid, uint256 allocPoint);\r\n    event ReferCurrencyChanged(address pool, uint256 oldIndex, uint256 newIndex);\r\n    event ClaimLiquidityShares(address pool, address user, uint256 rewards);\r\n    event ClaimUserShares(uint pid, address user, uint256 rewards);\r\n    event OnTransferLiquidity(address from, address to, uint256 lpAmount, uint256 fromAwards, uint256 toAwards);\r\n\r\n    // init LPMiningV1\r\n    // constructor params\r\n    constructor(\r\n        address _award,\r\n        uint256 _tokenPerBlock,\r\n        uint256 _startBlock,\r\n        uint256 _endTripleBlock,\r\n        uint256 _endBlock,\r\n        address _oracle\r\n    ) public {\r\n        require(_award != address(0), \"LPMiningV1: award invalid\");\r\n        require(_startBlock < _endTripleBlock && _endTripleBlock < _endBlock, \"LPMiningV1: blocks range invalid\");\r\n        require(_oracle != address(0), \"LPMiningV1: oracle invalid\");\r\n        award = IAward(_award);\r\n        tokenPerBlock = _tokenPerBlock;\r\n        endTripleBlock = _endTripleBlock;\r\n        governors[_msgSender()] = true;\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        shareInfo.lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\r\n        priceOracle = IOracle(_oracle);\r\n        emit Initialization(_award, _tokenPerBlock, _startBlock, _endTripleBlock, _endBlock, _oracle);\r\n    }\r\n\r\n    function poolIn(address pool) view public returns (bool){\r\n        if (address(poolInfo[pool].mPool) == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function indexOfPool(address pool) view public returns (uint256){\r\n        if (poolIn(pool)) {\r\n            return poolInfo[pool].poolIndex;\r\n        }\r\n        return uint256(- 1);\r\n    }\r\n\r\n    function setEndBlock(uint256 _endBlock) onlyOwner external{\r\n        endBlock = _endBlock;\r\n    }\r\n\r\n    // add pool\r\n    function add(address pool, uint256 index, uint256 allocP) override onlyGovernor external {\r\n        require(!poolIn(pool), \"LPMiningV1: pool duplicate\");\r\n        require(pools.length.add(1) < uint256(- 1), \"LPMiningV1: pools list overflow\");\r\n        IPool pPool = IPool(pool);\r\n        require(index < pPool.getCurrentTokens().length, \"LPMiningV1: reference token not exist\");\r\n        address[] memory tokens = pPool.getCurrentTokens();\r\n        uint256[] memory _balances = new uint256[](tokens.length);\r\n        uint256[] memory _weights = new uint256[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            _balances[i] = pPool.getBalance(tokens[i]);\r\n            _weights[i] = pPool.getNormalizedWeight(tokens[i]);\r\n        }\r\n        poolInfo[pool] = PoolInfo({\r\n        mPool : pPool,\r\n        poolIndex : pools.length,\r\n        referIndex : index,\r\n        lastTvl : 0,\r\n        allocPoint : allocP,\r\n        accTokenPerShare : 0,\r\n        rewardDebt : 0,\r\n        tokens : tokens,\r\n        balances : _balances,\r\n        weights : _weights\r\n        });\r\n        pools.push(pool);\r\n        updateRewards();\r\n        sharePoolRewards(poolInfo[pool]);\r\n        emit Add(pool, index, allocP);\r\n    }\r\n\r\n    function set(uint256 pid, uint256 allocPoint) override onlyGovernor external {\r\n        require(pid < pools.length, \"LPMiningV1: pool not exist\");\r\n        PoolInfo storage info = poolInfo[pools[pid]];\r\n        poolInfo[pools[pid]].allocPoint = allocPoint;\r\n        updateRewards();\r\n        sharePoolRewards(info);\r\n        emit Set(pid, allocPoint);\r\n    }\r\n\r\n    // add governor\r\n    function addGovernor(address governor) onlyOwner external {\r\n        governors[governor] = true;\r\n    }\r\n    // remove governor\r\n    function removeGovernor(address governor) onlyOwner external {\r\n        governors[governor] = false;\r\n    }\r\n\r\n    function updateOracle(address oracle) onlyGovernor external {\r\n        require(oracle != address(0), \"LPMiningV1: oracle invalid\");\r\n        priceOracle = IOracle(oracle);\r\n    }\r\n\r\n    // batch share pool rewards\r\n    function batchSharePools() override external {\r\n        updateRewards();\r\n        for (uint i = 0; i < pools.length; i = i.add(1)) {\r\n            sharePoolRewards(poolInfo[pools[i]]);\r\n        }\r\n    }\r\n\r\n    // update award\r\n    function updateAward(address _award) external onlyOwner {\r\n        require(_award != address(0), \"LPMiningV1: award invalid\");\r\n        award = IAward(_award);\r\n    }\r\n\r\n    // update Reference token index\r\n    function updateReferenceToken(uint256 pid, uint256 rIndex) override onlyGovernor external {\r\n        require(pid < pools.length, \"LPMiningV1: pool not exist\");\r\n        address pool = pools[pid];\r\n        require(rIndex < IPool(pool).getCurrentTokens().length, \"LPMiningV1: reference token not exist\");\r\n        PoolInfo storage info = poolInfo[pool];\r\n        uint256 old = info.referIndex;\r\n        info.referIndex = rIndex;\r\n        updateRewards();\r\n        sharePoolRewards(info);\r\n        emit ReferCurrencyChanged(pool, old, rIndex);\r\n    }\r\n\r\n    function claimUserShares(uint pid, address user) override external {\r\n        require(pid < pools.length, \"LPMiningV1: pool not exist\");\r\n        uint256 rewards = calUserRewards(pid, user, 0, true);\r\n        if (rewards > 0) {\r\n            award.addAward(user, rewards);\r\n        }\r\n        emit ClaimUserShares(pid, user, rewards);\r\n    }\r\n\r\n    function claimLiquidityShares(address user, address[] calldata tokens, uint256[] calldata balances, uint256[] calldata weights, uint256 amount, bool _add) override external {\r\n        uint256 pid = indexOfPool(msg.sender);\r\n        if (pid != uint256(- 1)) {\r\n            PoolInfo storage pool = poolInfo[msg.sender];\r\n            pool.tokens = tokens;\r\n            pool.balances = balances;\r\n            pool.weights = weights;\r\n            uint256 rewards = calUserRewards(pid, user, amount, _add);\r\n            if (rewards > 0) {\r\n                award.addAward(user, rewards);\r\n            }\r\n            emit ClaimLiquidityShares(msg.sender, user, rewards);\r\n        }\r\n    }\r\n\r\n    // View function to see  pool and user's pending Token on frontend.\r\n    function pendingShares(uint256 pid, address user) public view returns (uint256) {\r\n        PoolInfo memory info = poolInfo[pools[pid]];\r\n        UserInfo memory uinfo = userInfo[pid][user];\r\n        if (info.mPool.totalSupply() == 0 || shareInfo.tvl == 0 || shareInfo.lastRewardBlock >= block.number) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 accPoolPerShare = shareInfo.accPoolPerShare;\r\n        uint256 multiplier = getMultiplier(shareInfo.lastRewardBlock, block.number);\r\n        uint256 rewards = multiplier.mul(tokenPerBlock).mul(1e18).div(shareInfo.tvl);\r\n        accPoolPerShare = accPoolPerShare.add(rewards);\r\n\r\n        uint256 accTokenPerShare = info.accTokenPerShare;\r\n        rewards = accPoolPerShare.mul(info.lastTvl).sub(info.rewardDebt).div(info.mPool.totalSupply());\r\n        accTokenPerShare = accTokenPerShare.add(rewards);\r\n        return accTokenPerShare.mul(info.mPool.balanceOf(user)).sub(uinfo.rewardDebt).div(1e18);\r\n    }\r\n\r\n    function onTransferLiquidity(address from, address to, uint256 lpAmount) override external {\r\n        uint256 pid = indexOfPool(msg.sender);\r\n        if (pid != uint256(- 1)) {\r\n            uint256 fromAwards = calUserRewards(pid, from, lpAmount, false);\r\n            uint256 toAwards = calUserRewards(pid, to, lpAmount, true);\r\n            if (fromAwards > 0) {\r\n                if (Address.isContract(from)) {\r\n                    award.destroy(fromAwards);\r\n                } else {\r\n                    award.addAward(from, fromAwards);\r\n                }\r\n            }\r\n            if (toAwards > 0) {\r\n                if (Address.isContract(to)) {\r\n                    award.destroy(toAwards);\r\n                } else {\r\n                    award.addAward(to, toAwards);\r\n                }\r\n            }\r\n            emit OnTransferLiquidity(from, to, lpAmount, fromAwards, toAwards);\r\n        }\r\n    }\r\n\r\n    //cal pending rewards per tvl of pools\r\n    function updateRewards() private {\r\n        if (shareInfo.tvl > 0 && block.number > shareInfo.lastRewardBlock) {\r\n            uint256 multiplier = getMultiplier(shareInfo.lastRewardBlock, block.number);\r\n            uint256 rewards = multiplier.mul(tokenPerBlock).mul(1e18).div(shareInfo.tvl);\r\n            shareInfo.accPoolPerShare = shareInfo.accPoolPerShare.add(rewards);\r\n        }\r\n        shareInfo.lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n    }\r\n\r\n    //cal pending rewards for given pool\r\n    function sharePoolRewards(PoolInfo storage info) private {\r\n        _sharePoolRewards(info, 0, true);\r\n    }\r\n\r\n    //cal pending rewards for given pool\r\n    function _sharePoolRewards(PoolInfo storage info, uint256 lpAmount, bool _add) private {\r\n        uint newTotalLiquidity = info.mPool.totalSupply();\r\n        uint lastTotalLiquidity = _add ? newTotalLiquidity.sub(lpAmount) : newTotalLiquidity.add(lpAmount);\r\n        if (lastTotalLiquidity > 0) {\r\n            uint256 rewards = shareInfo.accPoolPerShare.mul(info.lastTvl).sub(info.rewardDebt).div(lastTotalLiquidity);\r\n            info.accTokenPerShare = info.accTokenPerShare.add(rewards);\r\n        }\r\n        uint256 newTvl = getPoolTvl(info);\r\n        info.rewardDebt = shareInfo.accPoolPerShare.mul(newTvl);\r\n        shareInfo.tvl = shareInfo.tvl.add(newTvl).sub(info.lastTvl);\r\n        info.lastTvl = newTvl;\r\n    }\r\n\r\n    // cal user shares\r\n    function calUserRewards(uint256 pid, address user, uint256 lpAmount, bool _add) private returns (uint256){\r\n        updateRewards();\r\n        PoolInfo storage info = poolInfo[pools[pid]];\r\n        _sharePoolRewards(info, lpAmount, _add);\r\n\r\n        UserInfo storage user_info = userInfo[pid][user];\r\n        uint256 newAmount = info.mPool.balanceOf(user);\r\n        uint256 lastAmount = _add ? newAmount.sub(lpAmount) : newAmount.add(lpAmount);\r\n        uint256 shares = info.accTokenPerShare.mul(lastAmount).sub(user_info.rewardDebt).div(1e18);\r\n        user_info.rewardDebt = newAmount.mul(info.accTokenPerShare);\r\n        return shares;\r\n    }\r\n\r\n    function getPoolTvl(PoolInfo memory info) private returns (uint256){\r\n        address baseToken = info.tokens[info.referIndex];\r\n        uint256 balance = info.balances[info.referIndex];\r\n        uint256 nw = info.weights[info.referIndex];\r\n        uint256 totalBalance = bdiv(balance, nw);\r\n        (uint8 decimal, uint256 price) = priceOracle.requestTokenPrice(baseToken);\r\n        require(price > 0, \"LPMiningV1: token price invalid\");\r\n        uint256 divisor = 10 ** uint256(decimal);\r\n        return totalBalance.mul(price).mul(info.allocPoint).div(divisor);\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\r\n        if (_to <= endBlock) {\r\n            if (_to <= endTripleBlock) {\r\n                return _to.sub(_from).mul(3);\r\n            } else if (_from < endTripleBlock) {\r\n                return endTripleBlock.sub(_from).mul(3).add(_to.sub(endTripleBlock));\r\n            }\r\n            return _to.sub(_from);\r\n        } else if (_from >= endBlock) {\r\n            return 0;\r\n        } else {\r\n            if (_from < endTripleBlock) {\r\n                return endTripleBlock.sub(_from).mul(3).add(endBlock.sub(endTripleBlock));\r\n            }\r\n            return endBlock.sub(_from);\r\n        }\r\n    }\r\n\r\n    function bdiv(uint a, uint b) internal pure returns (uint){\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * 1e18;\r\n        require(a == 0 || c0 / a == 1e18, \"ERR_DIV_INTERNAL\");\r\n        // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\");\r\n        //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_award\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTripleBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocP\",\"type\":\"uint256\"}],\"name\":\"Add\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"ClaimLiquidityShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"ClaimUserShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"award\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTripleBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"Initialization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAwards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAwards\",\"type\":\"uint256\"}],\"name\":\"OnTransferLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIndex\",\"type\":\"uint256\"}],\"name\":\"ReferCurrencyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"Set\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocP\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"award\",\"outputs\":[{\"internalType\":\"contract IAward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchSharePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_add\",\"type\":\"bool\"}],\"name\":\"claimLiquidityShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimUserShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTripleBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"indexOfPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"onTransferLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"pendingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolIn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"mPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTvl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"setEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shareInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tvl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPoolPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_award\",\"type\":\"address\"}],\"name\":\"updateAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"updateOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rIndex\",\"type\":\"uint256\"}],\"name\":\"updateReferenceToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LPMiningV1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005a867f6b759ca090e47cbfdbb3ea76e42726286200000000000000000000000000000000000000000000000015a63bbc199c00000000000000000000000000000000000000000000000000000000000000ac1b600000000000000000000000000000000000000000000000000000000000ae32880000000000000000000000000000000000000000000000000000000001852db0000000000000000000000000b659f06aa83aaa0563653b1e8b4276d990c8a500","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6c2d21c304a38a4a05090d6725c885735ad9b8374a6e607c01bbf825e27080d8"}]}