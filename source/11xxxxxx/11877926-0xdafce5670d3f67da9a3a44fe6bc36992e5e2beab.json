{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: No\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/v612/DELTA/Periphery/DELTA_Limited_Staking_Window.sol\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n    function balanceOf(address) external returns (uint256);\r\n}\r\n\r\ninterface IRLP {\r\n  function rebase() external;\r\n  function wrap() external;\r\n  function setBaseLPToken(address) external;\r\n  function openRebasing() external;\r\n  function balanceOf(address) external returns (uint256);\r\n  function transfer(address, uint256) external returns (bool);\r\n}\r\n\r\ninterface IDELTA_DEEP_FARMING_VAULT {\r\n    function depositFor(address, uint256,uint256) external;\r\n}\r\n\r\ninterface IRESERVE_VAULT {\r\n    function setRatio(uint256) external;\r\n}\r\n\r\ncontract DELTA_Limited_Staking_Window {\r\n  using SafeMath for uint256;\r\n  \r\n  struct LiquidityContribution {\r\n    address byWho;\r\n    uint256 howMuchETHUnits;\r\n    uint256 contributionTimestamp;\r\n    uint256 creditsAdded;\r\n  }\r\n\r\n\r\n  //////////\r\n  // STORAGE\r\n  //////////\r\n\r\n  ///////////\r\n  // Unchanging variables and constants \r\n  /// @dev All this variables should be set only once. Anything else is a bug.\r\n\r\n  // Constants\r\n  address constant internal UNISWAP_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n  address public DELTA_FINANCIAL_MULTISIG;\r\n  /// @notice the person who sets the multisig wallet, happens only once\r\n  // This person has no power over the contract only power to set the multisig wallet\r\n  address immutable public INTERIM_ADMIN;\r\n  IWETH constant public wETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n  address public reserveVaultAddress;\r\n  address public deltaDeepFarmingVaultAddress;\r\n  uint256 public LSW_RUN_TIME = 10 days;\r\n  uint256 public constant MAX_ETH_POOL_SEED = 1500 ether;\r\n\r\n  // @notice periode after the LSW is ended to claim the LP and the bonuses\r\n  uint256 public constant CLAIMING_PERIOD = 30 days;\r\n  uint256 public constant MAX_TIME_BONUS_PERCENT = 30;\r\n\r\n  IRLP public rebasingLP; // Wrapped LP\r\n  address public deltaTokenAddress;\r\n\r\n  ///////////\r\n\r\n  ///////////\r\n  // Referral handling variables\r\n  /// @dev Variables handling referral bonuses and IDs calculations\r\n\r\n  /// @dev Sequential referral IDs (skipping 0)\r\n  uint256 public totalReferralIDs; \r\n  /// @dev mappings and reverse mapping handling the referral id ( for links to be smaller)\r\n  mapping(uint256 => address) public referralCodeMappingIndexedByID; \r\n  mapping(address => uint256) public referralCodeMappingIndexedByAddress;\r\n  /// @dev we store bonus WETH in this variable because we don't want to send it until LSW is over... Because of the possibility of refund\r\n  mapping(address => uint256) public referralBonusWETH;\r\n  /// @dev boolean flag if the user already claimed his WETH bonus\r\n  mapping(address => bool) public referralBonusWETHClaimed;\r\n  uint256 public totalWETHEarmarkedForReferrers;\r\n\r\n  ///////////\r\n\r\n\r\n  ///////////\r\n  // Liquidity contribution variables\r\n  /// @dev variables for storing liquidity contributions and subsequent calculation for LP distribution\r\n\r\n  /// @dev An array of all contributions with metadata\r\n  LiquidityContribution [] public liquidityContributionsArray;\r\n  /// @dev This is ETH contributed by the specific person, it doesn't include any bonuses this is used to handle refunds\r\n  mapping(address => uint256) public liquidityContributedInETHUnitsMapping;  \r\n  /// @notice Each person has a credit based on their referrals and other bonuses as well as ETH contributions. This is what is used for owed LP\r\n  mapping(address => uint256) public liquidityCreditsMapping;\r\n  /// @dev a boolean flag for an address to signify they have already claimed LP owed to them\r\n  mapping(address => bool) public claimedLP;\r\n  /// @notice Calculated at the time of liquidity addition. RLP per each credit\r\n  /// @dev stored multiplied by 1e12 for change\r\n  uint256 public rlpPerCredit;\r\n  /// @dev total Credit inside the smart contract used for ending calculation for rlpPerCredit\r\n  uint256 public totalCreditValue;\r\n  ///////////\r\n\r\n\r\n  ///////////\r\n  // Refund handling variables\r\n\r\n  /// @notice Variables used for potential refund if the liquidity addition fails. This failover happens 2 days after LSW is supposed to be over, and its is not.\r\n  /// @dev mapping of boolean flags if the user already claimed his refund\r\n  mapping(address => bool) public refundClaimed;\r\n  /// @notice boolean flag that can be initiated if LSW didnt end 2 days after it was supposed to calling the refund function.\r\n  /// @dev This opens refunds, refunds do not adjust anything except the above mapping. Its important this variable is never triggered\r\n  bool public refundsOpen;\r\n  ///////////\r\n\r\n  ///////////\r\n  // Handling LSW timing variables\r\n\r\n  /// @dev variables for length of LSW, separate from constant ones above\r\n  bool public liquidityGenerationHasStarted;\r\n  bool public liquidityGenerationHasEnded;\r\n  /// @dev timestamps are not dynamic and generated upon calling the start function\r\n  uint256 public liquidityGenerationStartTimestamp;\r\n  uint256 public liquidityGenerationEndTimestamp;\r\n  ///////////\r\n\r\n\r\n\r\n  // constructor is only called by the token contract\r\n  constructor() public {\r\n      INTERIM_ADMIN = msg.sender;\r\n  }\r\n\r\n\r\n  /// @dev fallback on eth sent to the contract ( note WETH doesn't send ETH to this contract so no carveout is needed )\r\n  receive() external payable {\r\n    revertBecauseUserDidNotProvideAgreement();\r\n  }\r\n\r\n  function setMultisig(address multisig) public {\r\n      onlyInterimAdmin();\r\n    \r\n      require(DELTA_FINANCIAL_MULTISIG == address(0), \"only set once\");\r\n      DELTA_FINANCIAL_MULTISIG = multisig;\r\n  }\r\n\r\n  function onlyInterimAdmin() public view {\r\n      require(INTERIM_ADMIN == msg.sender, \"wrong\");\r\n  }\r\n\r\n  function setReserveVault(address reserveVault) public {\r\n      onlyMultisig();\r\n      reserveVaultAddress = reserveVault;\r\n  }\r\n\r\n  /// Helper functions\r\n  function setRLPWrap(address rlpAddress) public {\r\n      onlyMultisig();\r\n      rebasingLP = IRLP(rlpAddress);\r\n  }\r\n\r\n  function setDELTAToken(address deltaToken, bool delegateCall) public {\r\n      onlyMultisig();\r\n      if(delegateCall == false) {\r\n        deltaTokenAddress = deltaToken;\r\n      } else {\r\n          bytes memory callData = abi.encodePacked(bytes4(keccak256(bytes(\"getTokenInfo()\"))), \"\");\r\n        (,bytes memory addressDelta)= deltaToken.delegatecall(callData);\r\n        deltaTokenAddress = abi.decode(addressDelta, (address));\r\n      }\r\n  }\r\n\r\n  function setFarmingVaultAddress(address farmingVault) public {\r\n      onlyMultisig();\r\n      deltaDeepFarmingVaultAddress = farmingVault;\r\n      require(address(rebasingLP) != address(0), \"Need rlp to be set\");\r\n      require(farmingVault != address(0), \"Provide an address for farmingVault\");\r\n      IERC20(address(rebasingLP)).approve(farmingVault, uint(-1));\r\n  }\r\n  \r\n  function extendLSWEndTime(uint256 numberSeconds) public {\r\n      onlyMultisig();\r\n      liquidityGenerationEndTimestamp = liquidityGenerationEndTimestamp.add(numberSeconds);\r\n      LSW_RUN_TIME = LSW_RUN_TIME.add(numberSeconds);\r\n  }\r\n\r\n\r\n\r\n  /// @notice This function starts the LSW and opens deposits and creates the RLP wrap\r\n  function startLiquidityGeneration() public {\r\n    onlyMultisig();\r\n\r\n    // We check that this is called by the correct authorithy\r\n    /// @dev deltaToken has a time countdown in it that will make this function avaible to call \r\n    require(liquidityGenerationHasStarted == false, \"startLiquidityGeneration() called when LSW had already started\");\r\n\r\n    // We start the LSW\r\n    liquidityGenerationHasStarted = true;\r\n    // Informational timestamp only written here\r\n    // All calculations are based on the variable below end timestamp and run time which is used to bonus calculations\r\n    liquidityGenerationStartTimestamp = block.timestamp;\r\n    liquidityGenerationEndTimestamp = liquidityGenerationStartTimestamp + LSW_RUN_TIME;\r\n\r\n  }\r\n \r\n  /// @notice publically callable function that assigns a sequential shortened referral ID so a long one doesnt need to be provided in the URL\r\n  function makeRefCode() public returns (uint256) {\r\n    // If that address already has one, we dont make a new one\r\n    if(referralCodeMappingIndexedByAddress[msg.sender] != 0){\r\n       return referralCodeMappingIndexedByAddress[msg.sender];\r\n     }\r\n     else {\r\n       return _makeRefCode(msg.sender);\r\n     }\r\n  }\r\n\r\n  /// @dev Assigns a unique index to referrers, starting at 1\r\n  function _makeRefCode(address referrer) internal returns (uint256) {\r\n      totalReferralIDs++; // lead to skip 0 code for the LSW \r\n      // Populate reverse as well for lookup above\r\n      referralCodeMappingIndexedByID[totalReferralIDs] = referrer;\r\n      referralCodeMappingIndexedByAddress[msg.sender] = totalReferralIDs;\r\n      return totalReferralIDs;\r\n  }\r\n\r\n  /// @dev Not using modifiers is a purposeful choice for code readability.\r\n  function revertBecauseUserDidNotProvideAgreement() internal pure {\r\n    revert(\"No agreement provided, please review the smart contract before interacting with it\");\r\n  }\r\n\r\n\r\n  function adminEndLSWAndRefundEveryone() public {\r\n    onlyMultisig();\r\n    liquidityGenerationEndTimestamp = 0;\r\n    openRefunds();\r\n  }\r\n\r\n  function onlyMultisig() public view {\r\n    require(msg.sender == DELTA_FINANCIAL_MULTISIG, \"FBI OPEN UP\");\r\n  }\r\n\r\n\r\n  /// @notice a publically callable function that ends the LSW, adds liquidity and splits RLP for each credit.\r\n  function endLiquidityDeployment() public {\r\n    // Check if it already ended\r\n    require(block.timestamp > liquidityGenerationEndTimestamp.add(5 minutes), \"LSW Not over yet.\"); // Added few blocks here\r\n    // Check if it was already run\r\n    require(liquidityGenerationHasEnded == false, \"LSW Already ended\");\r\n    require(refundsOpen == false, \"Refunds Opened, no ending\");\r\n\r\n    // Check if all variable addresses are set\r\n    // This includes the delta token\r\n    // Rebasing lp wrap\r\n    // Reserve vault which acts as options plunge insurance and floor price reserve \r\n    // And operating capital for loans\r\n    // And the farming vault which is used to auto stake in it\r\n    require(deltaTokenAddress != address(0), \"Delta Token is not set\");\r\n    require(address(rebasingLP) != address(0), \"Rlp is not set\");\r\n    require(address(reserveVaultAddress) != address(0), \"Reserve Vault is not set\");\r\n    require(address(deltaDeepFarmingVaultAddress) != address(0), \"Deep farming vault isn't set\");\r\n\r\n    // We wrap the delta token in the interface\r\n    IERC20 deltaToken = IERC20(deltaTokenAddress);\r\n    // Check the balance we have\r\n    // Note : if the process wan't complete correctly, the balance here would be wrong\r\n    // Because DELTA token returns a balanace \r\n    uint256 balanceOfDELTA = deltaToken.balanceOf(address(this)); \r\n    // We make sure we for sure have the total supply\r\n    require(balanceOfDELTA == deltaToken.totalSupply(), \"Did not get the whole supply of deltaToken\");\r\n    /// We mkake sure the supply is equal to the agreed on 45mln\r\n    require(balanceOfDELTA == 45_000_000e18, \"Did not get the whole supply of deltaToken\");\r\n\r\n    // Optimistically get pair\r\n    address deltaWethUniswapPair = IUniswapV2Factory(UNISWAP_FACTORY).getPair(deltaTokenAddress, address(wETH));\r\n    if(deltaWethUniswapPair == address(0)) { // Pair doesn't exist yet \r\n      // create pair returns address\r\n      deltaWethUniswapPair = IUniswapV2Factory(UNISWAP_FACTORY).createPair(\r\n        deltaTokenAddress,\r\n        address(wETH)\r\n      );\r\n    }\r\n\r\n    // Split between DELTA financial and pool\r\n    // intented outcome 50% split between pool and further fund for tokens and WETH\r\n    uint256 balanceWETHPreSplit = wETH.balanceOf(address(this));\r\n    require(balanceWETHPreSplit > 0, \"Not enough WETH\");\r\n    wETH.transfer(DELTA_FINANCIAL_MULTISIG, balanceWETHPreSplit.div(2)); // send half\r\n    uint256 balanceWETHPostSplit = wETH.balanceOf(address(this)); // requery\r\n    // We remove the WETH we had earmarked for referals\r\n    uint256 balanceWETHPostReferal = balanceWETHPostSplit.sub(totalWETHEarmarkedForReferrers);\r\n\r\n    /// @dev note this will revert if there is less than 1500 eth at this stage\r\n    /// We just want refunds if that's the case cause it's not worth bothering\r\n    uint256 balanceWETHForReserves = balanceWETHPostReferal.sub(MAX_ETH_POOL_SEED, \"Not enough ETH\");\r\n\r\n    /// @dev we check that bonuses are less than 5% of total deposited because they should be at max 5\r\n    /// Anything else is a issue\r\n    /// Note added 1ETH for possible change\r\n    require(totalWETHEarmarkedForReferrers <= balanceWETHPreSplit.div(20).add(1e18), \"Sanity check failure 3\");\r\n    wETH.transfer(reserveVaultAddress, balanceWETHForReserves);\r\n    // We seed the pool with WETH\r\n    wETH.transfer(deltaWethUniswapPair, MAX_ETH_POOL_SEED);\r\n    require(wETH.balanceOf(address(this)) == totalWETHEarmarkedForReferrers, \"Math Error\");\r\n\r\n    // Transfer DELTA\r\n    /// @dev this address is already mature as in it has 100% of DELTA in its balance \r\n    uint256 deltaForPoolAndReserve = balanceOfDELTA.div(2);\r\n    /// Smaller number / bigger number = float  with 1000 for precision\r\n    uint256 percentOfBalanceToReserves = MAX_ETH_POOL_SEED.mul(1000).div(balanceWETHPostReferal);\r\n    // We take the precision out here\r\n    uint256 delfaForPool = deltaForPoolAndReserve.mul(percentOfBalanceToReserves).div(1000);\r\n\r\n    // transfer to pool\r\n    deltaToken.transfer(deltaWethUniswapPair, delfaForPool);\r\n    // We check if we are not sending 10% by mistake not whitelisting this address for whole sends\r\n    // Note we don't check the rest because it should not deviate \r\n    require(deltaToken.balanceOf(deltaWethUniswapPair) == delfaForPool, \"LSW did not get permissions to send directly to balance\");\r\n    // Transfer to team vesting\r\n    deltaToken.transfer(DELTA_FINANCIAL_MULTISIG, balanceOfDELTA.div(2));\r\n    // transfer to floor/liqudation insurance reserves\r\n    deltaToken.transfer(reserveVaultAddress, deltaToken.balanceOf(address(this))); // queried again in case of rounding problems\r\n    \r\n    /// This ratio is set as how much 1 whole eth buys\r\n    /// Since eth is 1e18 and delta is same we can do this here\r\n    /// Note that we don't expect 45mln eth so we dont really lose precision (delta supply is 45mln)\r\n    IRESERVE_VAULT(reserveVaultAddress).setRatio(\r\n        delfaForPool.div(MAX_ETH_POOL_SEED)\r\n    );\r\n\r\n    // just wrapping in the interface\r\n    IUniswapV2Pair newPair = IUniswapV2Pair(deltaWethUniswapPair);\r\n    // Add liquidity\r\n    newPair.mint(address(this)); //transfer LP here\r\n    // WE approve the rlp to spend because thats what the wrap function uses (transferFor)\r\n    newPair.approve(address(rebasingLP), uint(-1));\r\n\r\n    // We set the base token in a whitelist for rLP for LSW\r\n    rebasingLP.setBaseLPToken(address(newPair));\r\n\r\n    /// @dev outside call, this function is supposed to wrap all LP of this address and issue rebasibngLP and send it to this address\r\n    /// This switch is 1:1 1LP for 1 rebasingLP\r\n    rebasingLP.wrap();\r\n\r\n    // Rebase liquidity \r\n    /// @notice First rebase rebases RLP 3x. This means this would hit the gas limit if it was made in this call. \r\n    /// So it just triggers a boolean flag to rebase and then trading is opened.\r\n    /// @dev itended side effect of this is flipping a boolean flag inside the rebasingLP contract. It will open the rebasing function to be called about 30 times\r\n    /// Until its called that amount of times trading or transfering of DELTA token will not be opened. \r\n    /// This is done so price of RLP will be 3x that it was minted at instantly. Also will generate about 30bln in volume\r\n    rebasingLP.openRebasing();\r\n    // Split LP per Credit\r\n    uint256 totalRLP = rebasingLP.balanceOf(address(this));\r\n    require(totalRLP > 0, \"Sanity check failure 1\");\r\n    // We store as 1e12 more for change\r\n    rlpPerCredit = totalRLP.mul(1e12).div(totalCreditValue);\r\n    require(rlpPerCredit > 0, \"Sanity check failure 2\");\r\n\r\n    // Finalize to open claims (claimLP and ETH claiming for referal)\r\n    liquidityGenerationHasEnded = true;\r\n  }\r\n\r\n  function claimOrStakeAndClaimLP(bool claimToWalletInstead) public {\r\n    // Make sure the LSW ended ( this is set in fn endLiquidityDeployment() only)\r\n    // And is only set when all checks have passed and we good\r\n    require(liquidityGenerationHasEnded, \"Liquidity Generation isn't over\");\r\n\r\n    // Make sure the claiming period isn't over\r\n    // Note that we hav ea claiming period here so rLP doesnt get stuck or ETH doesnt get stuck in thsi contract\r\n    // This is because of the referal system having wrong addresses in it possibly\r\n    require(block.timestamp < liquidityGenerationEndTimestamp.add(CLAIMING_PERIOD), \"Claiming period is over\");\r\n  \r\n    // Make sure the person has something to claim\r\n    require(liquidityContributedInETHUnitsMapping[msg.sender] > 0, \"You have nothing to claim.\");\r\n    // Make sure the person hasnt already claimed\r\n    require(claimedLP[msg.sender] == false, \"You have already claimed.\");\r\n    // Set the already claimed flag\r\n    claimedLP[msg.sender] = true;\r\n\r\n    // We calculate the amount of rebasing LP due\r\n    uint256 rlpDue = liquidityCreditsMapping[msg.sender].mul(rlpPerCredit).div(1e12);\r\n    // And send it out\r\n    // We check if the person wants to claim to the wallet, the default is to stake it for him in the vault\r\n    if(claimToWalletInstead) {\r\n        rebasingLP.transfer(msg.sender, rlpDue);\r\n    }\r\n    else {\r\n        IDELTA_DEEP_FARMING_VAULT(deltaDeepFarmingVaultAddress).depositFor(msg.sender,rlpDue,0);\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /// @dev we loop over all liquidity contributions of a person and return them here for front end display\r\n  /// Note this might suffer from gas limits on infura if there are enogh deposits and we are aware of that\r\n  /// Its just a nice helper function that is not nessesary\r\n  function allLiquidityContributionsOfAnAddress(address person) public view returns (LiquidityContribution  [] memory liquidityContributionsOfPerson) {\r\n\r\n    uint256 j; // Index of the memory array\r\n\r\n    /// @dev we grab liquidity contributions at current index and compare to the provided address, and if it matches we push it to the array\r\n    for(uint256 i = 0; i < liquidityContributionsArray.length; i++) {\r\n      LiquidityContribution memory currentContribution = liquidityContributionsArray[i];\r\n      if(currentContribution.byWho == person) {\r\n        liquidityContributionsOfPerson[j] = currentContribution;\r\n        j++;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /// @notice Sends the bonus WETH to the referer after LSW is over.\r\n  function getWETHBonusForReferrals() public {\r\n    require(liquidityGenerationHasEnded == true, \"LSW Not ended\");\r\n\r\n    // Make sure the claiming period isn't over\r\n    // This is done in case ETH is stuck with malformed addresses\r\n    require(block.timestamp < liquidityGenerationEndTimestamp.add(CLAIMING_PERIOD), \"Claiming period is over\");\r\n    require(referralBonusWETHClaimed[msg.sender] == false, \"Already claimed, check wETH balance not ETH\");\r\n    require(referralBonusWETH[msg.sender] > 0, \"nothing to claim\");\r\n    /// @dev flag as claimed so no other calls is possible to this\r\n    /// Note that even if reentry was possible here we set it first before sending out weth\r\n    referralBonusWETHClaimed[msg.sender] = true;\r\n    /// @dev wETH transfer( token ) has no hook possibility\r\n    wETH.transfer(msg.sender, referralBonusWETH[msg.sender]); \r\n  }\r\n\r\n  /// @notice Transfer any remaining tokens in the contract\r\n  /// This is done after the claiming period is over in case there are malformed not claimed referal amounts \r\n  function finalizeLSW(address _token) public {\r\n    onlyMultisig();\r\n\r\n    require(liquidityGenerationHasEnded == true, \"LSW Not ended\");\r\n    require(block.timestamp >= liquidityGenerationEndTimestamp.add(CLAIMING_PERIOD), \"Claiming period is not over\");\r\n    \r\n    IERC20 token = IERC20(_token);\r\n\r\n    /// @dev Transfer remaining tokens to the team. Those are tokens that has been\r\n    /// unclaimed or transferred to the contract.\r\n    token.transfer(DELTA_FINANCIAL_MULTISIG, token.balanceOf(address(this)));\r\n  }\r\n\r\n  /// @notice this function allows anyone to refund the eth deposited in case the contract cannot finish\r\n  /// This is a nessesary function because of the contrract not having admin controls\r\n  /// And is only here as a safety pillow failure\r\n  function getRefund() public {\r\n    require(refundsOpen, \"Refunds are not open\");\r\n    require(refundClaimed[msg.sender]  == false, \"Already got a refund, check your wETH balance.\");\r\n    refundClaimed[msg.sender] = true;\r\n\r\n    // We send wETH9 here so there is no callback\r\n    wETH.transfer(msg.sender, liquidityContributedInETHUnitsMapping[msg.sender]);\r\n  }\r\n\r\n  // This function opens refunds,  if LSW didnt finish 2 days after it was supposed to. This means something went wrong.\r\n  function openRefunds() public {\r\n\r\n    require(liquidityGenerationHasEnded == false, \"Liquidity generation has ended\"); // We correctly ended the LSW\r\n    require(liquidityGenerationHasStarted == true, \"Liquidity generation has not started\");\r\n    // Liquidity genertion should had ended 2 days ago!\r\n    require(block.timestamp > liquidityGenerationEndTimestamp.add(2 days), \"Post LSW grace period isn't over\");\r\n    /// This can be set over and over again with no issue here\r\n    refundsOpen = true;\r\n\r\n  }\r\n\r\n\r\n  /// @dev Returns bonus in credit units, and adds and calculates credit for the referrer\r\n  /// @return credit units (something like wETH but in credit) this is for the referee ( person who was refered)\r\n  function handleReferredDepositWithAddress(address referrerAddress) internal returns (uint256) {\r\n\r\n    if(referrerAddress == msg.sender)  { return 0; } //We dont let self referrals and bail here without any bonuses.\r\n\r\n    require(msg.value > 0, \"Sanity check failure\");\r\n    uint256 wETHBonus = msg.value.div(20); // 5%\r\n    uint256 creditBonus = wETHBonus; // Samesies\r\n    totalWETHEarmarkedForReferrers = totalWETHEarmarkedForReferrers.add(wETHBonus);\r\n    require(wETHBonus > 0 && creditBonus > 0 , \"Sanity check failure 2\");\r\n\r\n    // We give 5% wETH of the deposit to the person\r\n    referralBonusWETH[referrerAddress] = referralBonusWETH[referrerAddress].add(wETHBonus);\r\n\r\n    //We add credit\r\n    liquidityCreditsMapping[referrerAddress] = liquidityCreditsMapping[referrerAddress].add(creditBonus);\r\n    // Update total credits\r\n    totalCreditValue = totalCreditValue.add(creditBonus);\r\n    \r\n    // We return 10% bonus for the person who was refered\r\n    return creditBonus.mul(2);\r\n  }\r\n\r\n  /// @dev checks if a address for this referral ID exists, if it doesnt just returns 0 skipping the adding function\r\n  function handleReferredDepositWithReferralID(uint256 referralID) internal returns (uint256 personWhoGotReferedBonus) {\r\n    address referrerAddress = referralCodeMappingIndexedByID[referralID];\r\n    // We check if the referral number was registered, and if its not the same person.\r\n    if(referrerAddress != address(0) && referrerAddress != msg.sender) {\r\n      return handleReferredDepositWithAddress(referrerAddress);\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function secondsLeftInLiquidityGenerationEvent() public view returns ( uint256 ) {\r\n\r\n    if(block.timestamp >= liquidityGenerationEndTimestamp) { return 0; }\r\n    return liquidityGenerationEndTimestamp - block.timestamp;\r\n\r\n  }\r\n\r\n  function liquidityGenerationParticipationAgreement() public pure returns (string memory) {\r\n    return \"I understand that I'm interacting with a smart contract. I understand that liquidity im providing is locked forever. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project to liable for any losses of misunderstandings\";\r\n  }\r\n\r\n  // referrerAddress or referralID must be provided, the unused parameter should be left as 0\r\n  function contributeLiquidity(bool readAndAgreedToLiquidityProviderAgreement, address referrerAddress, uint256 referralID) public payable {\r\n    require(refundsOpen == false, \"Refunds Opened, no deposit\");\r\n    // We check that LSW has already started\r\n    require(liquidityGenerationHasStarted, \"Liquidity generation did not start\");\r\n    // We check if liquidity generation didn't end\r\n    require(liquidityGenerationHasEnded == false, \"Liquidity generation has ended\");\r\n    // We check if liquidity genration still has time in it\r\n    require(secondsLeftInLiquidityGenerationEvent() > 0, \"Liquidity generation has ended 2\");\r\n    // We check if user agreed with the terms of the smart contract\r\n    if(readAndAgreedToLiquidityProviderAgreement == false) {\r\n      revertBecauseUserDidNotProvideAgreement();\r\n    }\r\n    require(msg.value > 0, \"Ethereum needs to be provided\");\r\n\r\n    // We add credit bonus, which is 10% if user is referred\r\n    // RefID takes precedence here\r\n    uint256 creditBonus;\r\n    if(referralID != 0) {\r\n      creditBonus = handleReferredDepositWithReferralID(referralID); // TO REVIEW: handleReferredDepositWithReferralID returns the reward (referrer and referee)\r\n    } else if (referrerAddress != address(0)){\r\n      creditBonus = handleReferredDepositWithAddress(referrerAddress); // TO REVIEW: handleReferredDepositWithReferralID returns the reward (referrer and referee)\r\n    } // Else bonus is 0\r\n\r\n    // We add the time bonus to the credit \r\n    creditBonus = creditBonus.add(calculateCreditBonusBasedOnCurrentTime(msg.value));\r\n\r\n    // Credit bonus should never be bigger than credit here. Max 30% + 10%. Aka 40% of msg.value\r\n    // Note this is a magic number here, since we dont really want to read the max bonus again from storage\r\n    require(msg.value.mul(41).div(100) > creditBonus, \"Sanity check failure\");\r\n\r\n    // We update the global number of credit so we can distribute LP later\r\n    uint256 creditValue = msg.value.add(creditBonus);\r\n    totalCreditValue = totalCreditValue.add(creditValue);\r\n\r\n    // Give the person credit and the bonus\r\n    liquidityCreditsMapping[msg.sender] = liquidityCreditsMapping[msg.sender].add(creditValue);\r\n    // Save the persons deposit for refunds in case\r\n    liquidityContributedInETHUnitsMapping[msg.sender] = liquidityContributedInETHUnitsMapping[msg.sender].add(msg.value);\r\n\r\n    // We add it to array of all deposits\r\n    liquidityContributionsArray.push(LiquidityContribution({\r\n      byWho : msg.sender,\r\n      howMuchETHUnits : msg.value,\r\n      contributionTimestamp : block.timestamp,\r\n      creditsAdded : creditValue // Stores the deposit + the bonus\r\n    }));\r\n\r\n    // We turn ETH into WETH9\r\n    wETH.deposit{value : msg.value}();\r\n  }\r\n\r\n  /// @dev intended return is the bonus credit in terms of ETH units\r\n  // At the start of LSW is 30%, ramping down to 0% in the last 12 hours of LSW.\r\n  function calculateCreditBonusBasedOnCurrentTime(uint256 depositValue) internal view returns (uint256) {\r\n    uint256 secondsLeft = secondsLeftInLiquidityGenerationEvent();\r\n    uint256 totalSeconds = LSW_RUN_TIME;\r\n\r\n    // We get percent left in the LSW\r\n    uint256 percentLeft = secondsLeft.mul(100).div(totalSeconds); // 24 hours before LSW end, we get 7 for percentLeft - highest value for this possible is 100 (by a bot)\r\n\r\n    // We calculate bonus based on percent left. Eg 100% of the time remaining, means a 30% bonus. 50% of the time remaining, means a 15% bonus.\r\n    // MAX_TIME_BONUS_PERCENT is a constant set to 30 (double-check on review)\r\n    // Max example with 1 ETH contribute: 30 * 100 * 1eth / 10000 = 0.3eth\r\n    // Low end (towards the end of LSW) > 0 example MAX_TIME_BONUS_PERCENT == 7;\r\n      // 30 * 7 * 1eth / 10000 = 0.021 eth\r\n    // Min example MAX_TIME_BONUS_PERCENT == 0; returns 0\r\n    /// 100 % bonus\r\n    /// 30*100*1e18/10000 == 0.3 * 1e18\r\n    /// Dust numbers\r\n    /// 30*100*1/10000 == 0\r\n    uint256 bonus = MAX_TIME_BONUS_PERCENT.mul(percentLeft).mul(depositValue).div(10000);\r\n    require(depositValue.mul(31).div(100) > bonus , \"Sanity check failure bonus\");\r\n    return bonus;\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CLAIMING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELTA_FINANCIAL_MULTISIG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERIM_ADMIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LSW_RUN_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ETH_POOL_SEED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TIME_BONUS_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminEndLSWAndRefundEveryone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"person\",\"type\":\"address\"}],\"name\":\"allLiquidityContributionsOfAnAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"byWho\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"howMuchETHUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contributionTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creditsAdded\",\"type\":\"uint256\"}],\"internalType\":\"struct DELTA_Limited_Staking_Window.LiquidityContribution[]\",\"name\":\"liquidityContributionsOfPerson\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"claimToWalletInstead\",\"type\":\"bool\"}],\"name\":\"claimOrStakeAndClaimLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"readAndAgreedToLiquidityProviderAgreement\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralID\",\"type\":\"uint256\"}],\"name\":\"contributeLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deltaDeepFarmingVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deltaTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endLiquidityDeployment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberSeconds\",\"type\":\"uint256\"}],\"name\":\"extendLSWEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"finalizeLSW\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWETHBonusForReferrals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityContributedInETHUnitsMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityContributionsArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"byWho\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"howMuchETHUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contributionTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creditsAdded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityCreditsMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGenerationEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGenerationHasEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGenerationHasStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGenerationParticipationAgreement\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityGenerationStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeRefCode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyInterimAdmin\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyMultisig\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openRefunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebasingLP\",\"outputs\":[{\"internalType\":\"contract IRLP\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBonusWETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBonusWETHClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCodeMappingIndexedByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralCodeMappingIndexedByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refundClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundsOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rlpPerCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsLeftInLiquidityGenerationEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deltaToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"delegateCall\",\"type\":\"bool\"}],\"name\":\"setDELTAToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmingVault\",\"type\":\"address\"}],\"name\":\"setFarmingVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multisig\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rlpAddress\",\"type\":\"address\"}],\"name\":\"setRLPWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserveVault\",\"type\":\"address\"}],\"name\":\"setReserveVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startLiquidityGeneration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCreditValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReferralIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWETHEarmarkedForReferrers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DELTA_Limited_Staking_Window","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8e047108cbc80ca9083f0d2150ab6ae266599213f854958a3299549f25233567"}]}