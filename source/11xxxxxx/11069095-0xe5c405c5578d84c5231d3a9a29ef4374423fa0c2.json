{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"AssetTransfers.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  SafeMath as SafeMath256\\n} from \\u0027./SafeMath.sol\\u0027;\\n\\nimport { IERC20 } from \\u0027./Interfaces.sol\\u0027;\\n\\n\\n/**\\n * @notice This library provides helper utilities for transfering assets in and out of contracts.\\n * It further validates ERC-20 compliant balance updates in the case of token assets\\n */\\nlibrary AssetTransfers {\\n  using SafeMath256 for uint256;\\n\\n  /**\\n   * @dev Transfers tokens from a wallet into a contract during deposits. `wallet` must already\\n   * have called `approve` on the token contract for at least `tokenQuantity`. Note this only\\n   * applies to tokens since ETH is sent in the deposit transaction via `msg.value`\\n   */\\n  function transferFrom(\\n    address wallet,\\n    IERC20 tokenAddress,\\n    uint256 quantityInAssetUnits\\n  ) internal {\\n    uint256 balanceBefore = tokenAddress.balanceOf(address(this));\\n\\n    // Because we check for the expected balance change we can safely ignore the return value of transferFrom\\n    tokenAddress.transferFrom(wallet, address(this), quantityInAssetUnits);\\n\\n    uint256 balanceAfter = tokenAddress.balanceOf(address(this));\\n    require(\\n      balanceAfter.sub(balanceBefore) == quantityInAssetUnits,\\n      \\u0027Token contract returned transferFrom success without expected balance change\\u0027\\n    );\\n  }\\n\\n  /**\\n   * @dev Transfers ETH or token assets from a contract to 1) another contract, when `Exchange`\\n   * forwards funds to `Custodian` during deposit or 2) a wallet, when withdrawing\\n   */\\n  function transferTo(\\n    address payable walletOrContract,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) internal {\\n    if (asset == address(0x0)) {\\n      require(\\n        walletOrContract.send(quantityInAssetUnits),\\n        \\u0027ETH transfer failed\\u0027\\n      );\\n    } else {\\n      uint256 balanceBefore = IERC20(asset).balanceOf(walletOrContract);\\n\\n      // Because we check for the expected balance change we can safely ignore the return value of transfer\\n      IERC20(asset).transfer(walletOrContract, quantityInAssetUnits);\\n\\n      uint256 balanceAfter = IERC20(asset).balanceOf(walletOrContract);\\n      require(\\n        balanceAfter.sub(balanceBefore) == quantityInAssetUnits,\\n        \\u0027Token contract returned transfer success without expected balance change\\u0027\\n      );\\n    }\\n  }\\n}\\n\"},\"Custodian.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport { Address } from \\u0027./Address.sol\\u0027;\\n\\nimport { ICustodian } from \\u0027./Interfaces.sol\\u0027;\\nimport { Owned } from \\u0027./Owned.sol\\u0027;\\nimport { AssetTransfers } from \\u0027./AssetTransfers.sol\\u0027;\\n\\n\\n/**\\n * @notice The Custodian contract. Holds custody of all deposited funds for whitelisted Exchange\\n * contract with minimal additional logic\\n */\\ncontract Custodian is ICustodian, Owned {\\n  // Events //\\n\\n  /**\\n   * @notice Emitted on construction and when Governance upgrades the Exchange contract address\\n   */\\n  event ExchangeChanged(address oldExchange, address newExchange);\\n  /**\\n   * @notice Emitted on construction and when Governance replaces itself by upgrading the Governance contract address\\n   */\\n  event GovernanceChanged(address oldGovernance, address newGovernance);\\n\\n  address _exchange;\\n  address _governance;\\n\\n  /**\\n   * @notice Instantiate a new Custodian\\n   *\\n   * @dev Sets `owner` and `admin` to `msg.sender`. Sets initial values for Exchange and Governance\\n   * contract addresses, after which they can only be changed by the currently set Governance contract\\n   * itself\\n   *\\n   * @param exchange Address of deployed Exchange contract to whitelist\\n   * @param governance ddress of deployed Governance contract to whitelist\\n   */\\n  constructor(address exchange, address governance) public Owned() {\\n    require(Address.isContract(exchange), \\u0027Invalid exchange contract address\\u0027);\\n    require(\\n      Address.isContract(governance),\\n      \\u0027Invalid governance contract address\\u0027\\n    );\\n\\n    _exchange = exchange;\\n    _governance = governance;\\n\\n    emit ExchangeChanged(address(0x0), exchange);\\n    emit GovernanceChanged(address(0x0), governance);\\n  }\\n\\n  /**\\n   * @notice ETH can only be sent by the Exchange\\n   */\\n  receive() external override payable onlyExchange {}\\n\\n  /**\\n   * @notice Withdraw any asset and amount to a target wallet\\n   *\\n   * @dev No balance checking performed\\n   *\\n   * @param wallet The wallet to which assets will be returned\\n   * @param asset The address of the asset to withdraw (ETH or ERC-20 contract)\\n   * @param quantityInAssetUnits The quantity in asset units to withdraw\\n   */\\n  function withdraw(\\n    address payable wallet,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) external override onlyExchange {\\n    AssetTransfers.transferTo(wallet, asset, quantityInAssetUnits);\\n  }\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Exchange contract\\n   *\\n   * @return The address of the currently whitelisted Exchange contract\\n   */\\n  function loadExchange() external override view returns (address) {\\n    return _exchange;\\n  }\\n\\n  /**\\n   * @notice Sets a new Exchange contract address\\n   *\\n   * @param newExchange The address of the new whitelisted Exchange contract\\n   */\\n  function setExchange(address newExchange) external override onlyGovernance {\\n    require(Address.isContract(newExchange), \\u0027Invalid contract address\\u0027);\\n\\n    address oldExchange = _exchange;\\n    _exchange = newExchange;\\n\\n    emit ExchangeChanged(oldExchange, newExchange);\\n  }\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Governance contract\\n   *\\n   * @return The address of the currently whitelisted Governance contract\\n   */\\n  function loadGovernance() external override view returns (address) {\\n    return _governance;\\n  }\\n\\n  /**\\n   * @notice Sets a new Governance contract address\\n   *\\n   * @param newGovernance The address of the new whitelisted Governance contract\\n   */\\n  function setGovernance(address newGovernance)\\n    external\\n    override\\n    onlyGovernance\\n  {\\n    require(Address.isContract(newGovernance), \\u0027Invalid contract address\\u0027);\\n\\n    address oldGovernance = _governance;\\n    _governance = newGovernance;\\n\\n    emit GovernanceChanged(oldGovernance, newGovernance);\\n  }\\n\\n  // RBAC //\\n\\n  modifier onlyExchange() {\\n    require(msg.sender == _exchange, \\u0027Caller must be Exchange contract\\u0027);\\n    _;\\n  }\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == _governance, \\u0027Caller must be Governance contract\\u0027);\\n    _;\\n  }\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @notice Enums used in `Order` and `Withdrawal` structs\\n */\\ncontract Enums {\\n  enum OrderSelfTradePrevention {\\n    // Decrement and cancel\\n    dc,\\n    // Cancel oldest\\n    co,\\n    // Cancel newest\\n    cn,\\n    // Cancel both\\n    cb\\n  }\\n  enum OrderSide { Buy, Sell }\\n  enum OrderTimeInForce {\\n    // Good until cancelled\\n    gtc,\\n    // Good until time\\n    gtt,\\n    // Immediate or cancel\\n    ioc,\\n    // Fill or kill\\n    fok\\n  }\\n  enum OrderType {\\n    Market,\\n    Limit,\\n    LimitMaker,\\n    StopLoss,\\n    StopLossLimit,\\n    TakeProfit,\\n    TakeProfitLimit\\n  }\\n  enum WithdrawalType { BySymbol, ByAddress }\\n}\\n\\n\\n/**\\n * @notice Struct definitions\\n */\\ncontract Structs {\\n  /**\\n   * @notice Argument type for `Exchange.executeTrade` and `Signatures.getOrderWalletHash`\\n   */\\n  struct Order {\\n    // Not currently used but reserved for future use. Must be 1\\n    uint8 signatureHashVersion;\\n    // UUIDv1 unique to wallet\\n    uint128 nonce;\\n    // Wallet address that placed order and signed hash\\n    address walletAddress;\\n    // Type of order\\n    Enums.OrderType orderType;\\n    // Order side wallet is on\\n    Enums.OrderSide side;\\n    // Order quantity in base or quote asset terms depending on isQuantityInQuote flag\\n    uint64 quantityInPips;\\n    // Is quantityInPips in quote terms\\n    bool isQuantityInQuote;\\n    // For limit orders, price in decimal pips * 10^8 in quote terms\\n    uint64 limitPriceInPips;\\n    // For stop orders, stop loss or take profit price in decimal pips * 10^8 in quote terms\\n    uint64 stopPriceInPips;\\n    // Optional custom client order ID\\n    string clientOrderId;\\n    // TIF option specified by wallet for order\\n    Enums.OrderTimeInForce timeInForce;\\n    // STP behavior specified by wallet for order\\n    Enums.OrderSelfTradePrevention selfTradePrevention;\\n    // Cancellation time specified by wallet for GTT TIF order\\n    uint64 cancelAfter;\\n    // The ECDSA signature of the order hash as produced by Signatures.getOrderWalletHash\\n    bytes walletSignature;\\n  }\\n\\n  /**\\n   * @notice Return type for `Exchange.loadAssetBySymbol`, and `Exchange.loadAssetByAddress`; also\\n   * used internally by `AssetRegistry`\\n   */\\n  struct Asset {\\n    // Flag to distinguish from empty struct\\n    bool exists;\\n    // The asset\\u0027s address\\n    address assetAddress;\\n    // The asset\\u0027s symbol\\n    string symbol;\\n    // The asset\\u0027s decimal precision\\n    uint8 decimals;\\n    // Flag set when asset registration confirmed. Asset deposits, trades, or withdrawals only allowed if true\\n    bool isConfirmed;\\n    // Timestamp as ms since Unix epoch when isConfirmed was asserted\\n    uint64 confirmedTimestampInMs;\\n  }\\n\\n  /**\\n   * @notice Argument type for `Exchange.executeTrade` specifying execution parameters for matching orders\\n   */\\n  struct Trade {\\n    // Base asset symbol\\n    string baseAssetSymbol;\\n    // Quote asset symbol\\n    string quoteAssetSymbol;\\n    // Base asset address\\n    address baseAssetAddress;\\n    // Quote asset address\\n    address quoteAssetAddress;\\n    // Gross amount including fees of base asset executed\\n    uint64 grossBaseQuantityInPips;\\n    // Gross amount including fees of quote asset executed\\n    uint64 grossQuoteQuantityInPips;\\n    // Net amount of base asset received by buy side wallet after fees\\n    uint64 netBaseQuantityInPips;\\n    // Net amount of quote asset received by sell side wallet after fees\\n    uint64 netQuoteQuantityInPips;\\n    // Asset address for liquidity maker\\u0027s fee\\n    address makerFeeAssetAddress;\\n    // Asset address for liquidity taker\\u0027s fee\\n    address takerFeeAssetAddress;\\n    // Fee paid by liquidity maker\\n    uint64 makerFeeQuantityInPips;\\n    // Fee paid by liquidity taker\\n    uint64 takerFeeQuantityInPips;\\n    // Execution price of trade in decimal pips * 10^8 in quote terms\\n    uint64 priceInPips;\\n    // Which side of the order (buy or sell) the liquidity maker was on\\n    Enums.OrderSide makerSide;\\n  }\\n\\n  /**\\n   * @notice Argument type for `Exchange.withdraw` and `Signatures.getWithdrawalWalletHash`\\n   */\\n  struct Withdrawal {\\n    // Distinguishes between withdrawals by asset symbol or address\\n    Enums.WithdrawalType withdrawalType;\\n    // UUIDv1 unique to wallet\\n    uint128 nonce;\\n    // Address of wallet to which funds will be returned\\n    address payable walletAddress;\\n    // Asset symbol\\n    string assetSymbol;\\n    // Asset address\\n    address assetAddress; // Used when assetSymbol not specified\\n    // Withdrawal quantity\\n    uint64 quantityInPips;\\n    // Gas fee deducted from withdrawn quantity to cover dispatcher tx costs\\n    uint64 gasFeeInPips;\\n    // Not currently used but reserved for future use. Must be true\\n    bool autoDispatchEnabled;\\n    // The ECDSA signature of the withdrawal hash as produced by Signatures.getWithdrawalWalletHash\\n    bytes walletSignature;\\n  }\\n}\\n\\n\\n/**\\n * @notice Interface of the ERC20 standard as defined in the EIP, but with no return values for\\n * transfer and transferFrom. By asserting expected balance changes when calling these two methods\\n * we can safely ignore their return values. This allows support of non-compliant tokens that do not\\n * return a boolean. See https://github.com/ethereum/solidity/issues/4116\\n */\\ninterface IERC20 {\\n  /**\\n   * @notice Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external;\\n\\n  /**\\n   * @notice Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @notice Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @notice Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @notice Interface to Custodian contract. Used by Exchange and Governance contracts for internal\\n * delegate calls\\n */\\ninterface ICustodian {\\n  /**\\n   * @notice ETH can only be sent by the Exchange\\n   */\\n  receive() external payable;\\n\\n  /**\\n   * @notice Withdraw any asset and amount to a target wallet\\n   *\\n   * @dev No balance checking performed\\n   *\\n   * @param wallet The wallet to which assets will be returned\\n   * @param asset The address of the asset to withdraw (ETH or ERC-20 contract)\\n   * @param quantityInAssetUnits The quantity in asset units to withdraw\\n   */\\n  function withdraw(\\n    address payable wallet,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Exchange contract\\n   *\\n   * @return The address of the currently whitelisted Exchange contract\\n   */\\n  function loadExchange() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Exchange contract address\\n   *\\n   * @param newExchange The address of the new whitelisted Exchange contract\\n   */\\n  function setExchange(address newExchange) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Governance contract\\n   *\\n   * @return The address of the currently whitelisted Governance contract\\n   */\\n  function loadGovernance() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Governance contract address\\n   *\\n   * @param newGovernance The address of the new whitelisted Governance contract\\n   */\\n  function setGovernance(address newGovernance) external;\\n}\\n\\n\\n/**\\n * @notice Interface to Exchange contract. Provided only to document struct usage\\n */\\ninterface IExchange {\\n  /**\\n   * @notice Settles a trade between two orders submitted and matched off-chain\\n   *\\n   * @param buy A `Structs.Order` struct encoding the parameters of the buy-side order (receiving base, giving quote)\\n   * @param sell A `Structs.Order` struct encoding the parameters of the sell-side order (giving base, receiving quote)\\n   * @param trade A `Structs.Trade` struct encoding the parameters of this trade execution of the counterparty orders\\n   */\\n  function executeTrade(\\n    Structs.Order calldata buy,\\n    Structs.Order calldata sell,\\n    Structs.Trade calldata trade\\n  ) external;\\n\\n  /**\\n   * @notice Settles a user withdrawal submitted off-chain. Calls restricted to currently whitelisted Dispatcher wallet\\n   *\\n   * @param withdrawal A `Structs.Withdrawal` struct encoding the parameters of the withdrawal\\n   */\\n  function withdraw(Structs.Withdrawal calldata withdrawal) external;\\n}\\n\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\n\\n\\n/**\\n * @notice Mixin that provide separate owner and admin roles for RBAC\\n */\\nabstract contract Owned {\\n  address immutable _owner;\\n  address _admin;\\n\\n  modifier onlyOwner {\\n    require(msg.sender == _owner, \\u0027Caller must be owner\\u0027);\\n    _;\\n  }\\n  modifier onlyAdmin {\\n    require(msg.sender == _admin, \\u0027Caller must be admin\\u0027);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Sets both the owner and admin roles to the contract creator\\n   */\\n  constructor() public {\\n    _owner = msg.sender;\\n    _admin = msg.sender;\\n  }\\n\\n  /**\\n   * @notice Sets a new whitelisted admin wallet\\n   *\\n   * @param newAdmin The new whitelisted admin wallet. Must be different from the current one\\n   */\\n  function setAdmin(address newAdmin) external onlyOwner {\\n    require(newAdmin != address(0x0), \\u0027Invalid wallet address\\u0027);\\n    require(newAdmin != _admin, \\u0027Must be different from current admin\\u0027);\\n\\n    _admin = newAdmin;\\n  }\\n\\n  /**\\n   * @notice Clears the currently whitelisted admin wallet, effectively disabling any functions requiring\\n   * the admin role\\n   */\\n  function removeAdmin() external onlyOwner {\\n    _admin = address(0x0);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldExchange\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"ExchangeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"loadExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"setExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantityInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Custodian","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a36972e347e538e6c7afb9f44fb10dda7bba9ba2000000000000000000000000c883c1774bc4e699dfd3abd122fdb751702b7146","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8f2d7e8a73ba50c6319574cb20d91f871fa9340c7aa747bd3eccae39a5d5d949"}]}