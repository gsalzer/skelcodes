{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\modules\\Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Managerable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract Managerable is Ownable {\r\n\r\n    address private _managerAddress;\r\n    /**\r\n     * @dev modifier, Only manager can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyManager() {\r\n        require(_managerAddress == msg.sender,\"Managerable: caller is not the Manager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev set manager by owner. \r\n     *\r\n     */\r\n    function setManager(address managerAddress)\r\n    public\r\n    onlyOwner\r\n    {\r\n        _managerAddress = managerAddress;\r\n    }\r\n    /**\r\n     * @dev get manager address. \r\n     *\r\n     */\r\n    function getManager()public view returns (address) {\r\n        return _managerAddress;\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IFNXOracle.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ninterface IFNXOracle {\r\n    /**\r\n  * @notice retrieves price of an asset\r\n  * @dev function to get price for an asset\r\n  * @param asset Asset for which to get the price\r\n  * @return uint mantissa of asset price (scaled by 1e8) or zero if unset or contract paused\r\n  */\r\n    function getPrice(address asset) external view returns (uint256);\r\n    function getUnderlyingPrice(uint256 cToken) external view returns (uint256);\r\n    function getPrices(uint256[] calldata assets) external view returns (uint256[]memory);\r\n    function getAssetAndUnderlyingPrice(address asset,uint256 underlying) external view returns (uint256,uint256);\r\n//    function getSellOptionsPrice(address oToken) external view returns (uint256);\r\n//    function getBuyOptionsPrice(address oToken) external view returns (uint256);\r\n}\r\ncontract ImportOracle is Ownable{\r\n    IFNXOracle internal _oracle;\r\n    function oraclegetPrices(uint256[] memory assets) internal view returns (uint256[]memory){\r\n        uint256[] memory prices = _oracle.getPrices(assets);\r\n        uint256 len = assets.length;\r\n        for (uint i=0;i<len;i++){\r\n        require(prices[i] >= 100 && prices[i] <= 1e30);\r\n        }\r\n        return prices;\r\n    }\r\n    function oraclePrice(address asset) internal view returns (uint256){\r\n        uint256 price = _oracle.getPrice(asset);\r\n        require(price >= 100 && price <= 1e30);\r\n        return price;\r\n    }\r\n    function oracleUnderlyingPrice(uint256 cToken) internal view returns (uint256){\r\n        uint256 price = _oracle.getUnderlyingPrice(cToken);\r\n        require(price >= 100 && price <= 1e30);\r\n        return price;\r\n    }\r\n    function oracleAssetAndUnderlyingPrice(address asset,uint256 cToken) internal view returns (uint256,uint256){\r\n        (uint256 price1,uint256 price2) = _oracle.getAssetAndUnderlyingPrice(asset,cToken);\r\n        require(price1 >= 100 && price1 <= 1e30);\r\n        require(price2 >= 100 && price2 <= 1e30);\r\n        return (price1,price2);\r\n    }\r\n    function getOracleAddress() public view returns(address){\r\n        return address(_oracle);\r\n    }\r\n    function setOracleAddress(address oracle)public onlyOwner{\r\n        _oracle = IFNXOracle(oracle);\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\whiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\underlyingAssets.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a underlyingAssets filters a eligible underlying.\r\n     */\r\ncontract UnderlyingAssets is Ownable {\r\n    using whiteListUint32 for uint32[];\r\n    // The eligible underlying list\r\n    uint32[] internal underlyingAssets;\r\n    /**\r\n     * @dev Implementation of add an eligible underlying into the underlyingAssets.\r\n     * @param underlying new eligible underlying.\r\n     */\r\n    function addUnderlyingAsset(uint32 underlying)public onlyOwner{\r\n        underlyingAssets.addWhiteListUint32(underlying);\r\n    }\r\n    function setUnderlyingAsset(uint32[] memory underlyings)public onlyOwner{\r\n        underlyingAssets = underlyings;\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid underlying from the underlyingAssets.\r\n     * @param removeUnderlying revoked underlying.\r\n     */\r\n    function removeUnderlyingAssets(uint32 removeUnderlying)public onlyOwner returns(bool) {\r\n        return underlyingAssets.removeWhiteListUint32(removeUnderlying);\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible underlyingAssets.\r\n     */\r\n    function getUnderlyingAssets()public view returns (uint32[] memory){\r\n        return underlyingAssets;\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input underlying is eligible.\r\n     * @param underlying input underlying for testing.\r\n     */    \r\n    function isEligibleUnderlyingAsset(uint32 underlying) public view returns (bool){\r\n        return underlyingAssets.isEligibleUint32(underlying);\r\n    }\r\n    function _getEligibleUnderlyingIndex(uint32 underlying) internal view returns (uint256){\r\n        return underlyingAssets._getEligibleIndexUint32(underlying);\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IVolatility.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ninterface IVolatility {\r\n    function calculateIv(uint32 underlying,uint8 optType,uint256 expiration,uint256 currentPrice,uint256 strikePrice)external view returns (uint256);\r\n}\r\ncontract ImportVolatility is Ownable{\r\n    IVolatility internal _volatility;\r\n    function getVolatilityAddress() public view returns(address){\r\n        return address(_volatility);\r\n    }\r\n    function setVolatilityAddress(address volatility)public onlyOwner{\r\n        _volatility = IVolatility(volatility);\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IOptionsPrice.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ninterface IOptionsPrice {\r\n    function getOptionsPrice(uint256 currentPrice, uint256 strikePrice, uint256 expiration,uint32 underlying,uint8 optType)external view returns (uint256);\r\n    function getOptionsPrice_iv(uint256 currentPrice, uint256 strikePrice, uint256 expiration,\r\n                uint256 ivNumerator,uint8 optType)external view returns (uint256);\r\n    function calOptionsPriceRatio(uint256 selfOccupied,uint256 totalOccupied,uint256 totalCollateral) external view returns (uint256);\r\n}\r\ncontract ImportOptionsPrice is Ownable{\r\n    IOptionsPrice internal _optionsPrice;\r\n    function getOptionsPriceAddress() public view returns(address){\r\n        return address(_optionsPrice);\r\n    }\r\n    function setOptionsPriceAddress(address optionsPrice)public onlyOwner{\r\n        _optionsPrice = IOptionsPrice(optionsPrice);\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Operator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract Operator is Ownable {\r\n    using whiteListAddress for address[];\r\n    address[] private _operatorList;\r\n    /**\r\n     * @dev modifier, every operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperator() {\r\n        require(_operatorList.isEligibleAddress(msg.sender),\"Managerable: caller is not the Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperatorIndex(uint256 index) {\r\n        require(_operatorList.length>index && _operatorList[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev add a new operator by owner. \r\n     *\r\n     */\r\n    function addOperator(address addAddress)public onlyOwner{\r\n        _operatorList.addWhiteListAddress(addAddress);\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address addAddress)public onlyOwner{\r\n        _operatorList[index] = addAddress;\r\n    }\r\n    /**\r\n     * @dev remove operator by owner. \r\n     *\r\n     */\r\n    function removeOperator(address removeAddress)public onlyOwner returns (bool){\r\n        return _operatorList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev get all operators. \r\n     *\r\n     */\r\n    function getOperator()public view returns (address[] memory) {\r\n        return _operatorList;\r\n    }\r\n    /**\r\n     * @dev set all operators by owner. \r\n     *\r\n     */\r\n    function setOperators(address[] memory operators)public onlyOwner {\r\n        _operatorList = operators;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\ImputRange.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract ImputRange is Ownable {\r\n    \r\n    //The maximum input amount limit.\r\n    uint256 private maxAmount = 1e30;\r\n    //The minimum input amount limit.\r\n    uint256 private minAmount = 1e2;\r\n    \r\n    modifier InRange(uint256 amount) {\r\n        require(maxAmount>=amount && minAmount<=amount,\"input amount is out of input amount range\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Determine whether the input amount is within the valid range\r\n     * @param Amount Test value which is user input\r\n     */\r\n    function isInputAmountInRange(uint256 Amount)public view returns (bool){\r\n        return(maxAmount>=Amount && minAmount<=Amount);\r\n    }\r\n    /*\r\n    function isInputAmountSmaller(uint256 Amount)public view returns (bool){\r\n        return maxAmount>=amount;\r\n    }\r\n    function isInputAmountLarger(uint256 Amount)public view returns (bool){\r\n        return minAmount<=amount;\r\n    }\r\n    */\r\n    modifier Smaller(uint256 amount) {\r\n        require(maxAmount>=amount,\"input amount is larger than maximium\");\r\n        _;\r\n    }\r\n    modifier Larger(uint256 amount) {\r\n        require(minAmount<=amount,\"input amount is smaller than maximium\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev get the valid range of input amount\r\n     */\r\n    function getInputAmountRange() public view returns(uint256,uint256) {\r\n        return (minAmount,maxAmount);\r\n    }\r\n    /**\r\n     * @dev set the valid range of input amount\r\n     * @param _minAmount the minimum input amount limit\r\n     * @param _maxAmount the maximum input amount limit\r\n     */\r\n    function setInputAmountRange(uint256 _minAmount,uint256 _maxAmount) public onlyOwner{\r\n        minAmount = _minAmount;\r\n        maxAmount = _maxAmount;\r\n    }        \r\n}\r\n\r\n// File: contracts\\OptionsPool\\OptionsData.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OptionsData is UnderlyingAssets,ImputRange,Managerable,ImportOracle,ImportVolatility,ImportOptionsPrice,Operator{\r\n\r\n        // store option info\r\n        struct OptionsInfo {\r\n        address     owner;      // option's owner\r\n        uint8   \toptType;    //0 for call, 1 for put\r\n        uint24\t\tunderlying; // underlying ID, 1 for BTC,2 for ETH\r\n        uint64      optionsPrice;\r\n\r\n        address     settlement;    //user's settlement paying for option. \r\n        uint64      createTime;\r\n        uint32\t\texpiration; //\r\n\r\n\r\n        uint128     amount; \r\n        uint128     settlePrice;\r\n\r\n        uint128     strikePrice;    //  strike price\t\t\r\n        uint32      priceRate;    //underlying Price\t\r\n        uint64      iv;\r\n        uint32      extra;\r\n    }\r\n\r\n    uint256 internal limitation = 1 hours;\r\n    //all options information list\r\n    OptionsInfo[] internal allOptions;\r\n    //user options balances\r\n    mapping(address=>uint64[]) internal optionsBalances;\r\n    //expiration whitelist\r\n    uint32[] internal expirationList;\r\n    \r\n    // first option position which is needed calculate.\r\n    uint256 internal netWorthirstOption;\r\n    // options latest networth balance. store all options's net worth share started from first option.\r\n    mapping(address=>int256) internal optionsLatestNetWorth;\r\n\r\n    // first option position which is needed calculate.\r\n    uint256 internal occupiedFirstOption; \r\n    //latest calcutated Options Occupied value.\r\n    uint256 internal callOccupied;\r\n    uint256 internal putOccupied;\r\n    //latest Options volatile occupied value when bought or selled options.\r\n    int256 internal callLatestOccupied;\r\n    int256 internal putLatestOccupied;\r\n\r\n    /**\r\n     * @dev Emitted when `owner` create a new option. \r\n     * @param owner new option's owner\r\n     * @param optionID new option's id\r\n     * @param optionID new option's type \r\n     * @param underlying new option's underlying \r\n     * @param expiration new option's expiration timestamp\r\n     * @param strikePrice  new option's strikePrice\r\n     * @param amount  new option's amount\r\n     */\r\n    event CreateOption(address indexed owner,uint256 indexed optionID,uint8 optType,uint32 underlying,uint256 expiration,uint256 strikePrice,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `owner` burn `amount` his option which id is `optionID`. \r\n     */    \r\n    event BurnOption(address indexed owner,uint256 indexed optionID,uint amount);\r\n    event DebugEvent(uint256 id,uint256 value1,uint256 value2);\r\n}\r\n/*\r\ncontract OptionsDataV2 is OptionsData{\r\n        // store option info\r\n    struct OptionsInfoV2 {\r\n        uint64     optionID;    //an increasing nubmer id, begin from one.\r\n        uint64\t\texpiration; // Expiration timestamp\r\n        uint128     strikePrice;    //strike price\r\n        uint8   \toptType;    //0 for call, 1 for put\r\n        uint32\t\tunderlying; // underlying ID, 1 for BTC,2 for ETH\r\n        address     owner;      // option's owner\r\n        uint256     amount;         // mint amount\r\n    }\r\n    // store option extra info\r\n    struct OptionsInfoExV2 {\r\n        address      settlement;    //user's settlement paying for option. \r\n        uint128      tokenTimePrice; //option's buying price based on settlement, used for options share calculation\r\n        uint128      underlyingPrice;//underlying price when option is created.\r\n        uint128      fullPrice;      //option's buying price.\r\n        uint128      ivNumerator;   // option's iv numerator when option is created.\r\n//        uint256      ivDenominator;// option's iv denominator when option is created.\r\n    }\r\n        //all options information list\r\n    OptionsInfoV2[] internal allOptionsV2;\r\n    // all option's extra information map\r\n    mapping(uint256=>OptionsInfoExV2) internal optionExtraMapV2;\r\n        //user options balances\r\n//    mapping(address=>uint64[]) internal optionsBalancesV2;\r\n}\r\n*/\r\n\r\n// File: contracts\\modules\\tuple64.sol\r\n\r\npragma solidity =0.5.16;\r\nlibrary tuple64 {\r\n    // add whiteList\r\n    function getValue0(uint256 input) internal pure returns (uint256){\r\n        return uint256(uint64(input));\r\n    }\r\n    function getValue1(uint256 input) internal pure returns (uint256){\r\n        return uint256(uint64(input>>64));\r\n    }\r\n    function getValue2(uint256 input) internal pure returns (uint256){\r\n        return uint256(uint64(input>>128));\r\n    }\r\n    function getValue3(uint256 input) internal pure returns (uint256){\r\n        return uint256(uint64(input>>192));\r\n    }\r\n    function getTuple(uint256 input0,uint256 input1,uint256 input2,uint256 input3) internal pure returns (uint256){\r\n        return input0+(input1<<64)+(input2<<128)+(input3<<192);\r\n    }\r\n    function getTuple3(uint256 input0,uint256 input1,uint256 input2) internal pure returns (uint256){\r\n        return input0+(input1<<64)+(input2<<128);\r\n    }\r\n    function getTuple2(uint256 input0,uint256 input1) internal pure returns (uint256){\r\n        return input0+(input1<<64);\r\n    }\r\n}\r\n\r\n// File: contracts\\OptionsPool\\Optionsbase.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @title Options data contract.\r\n * @dev A Smart-contract to store options info.\r\n *\r\n */\r\ncontract OptionsBase is OptionsData {\r\n    using whiteListUint32 for uint32[];\r\n    constructor () public{\r\n        initialize();\r\n    }\r\n    function initialize() onlyOwner public {\r\n        expirationList =  [1 days,2 days,3 days, 7 days, 10 days, 15 days,20 days, 30 days/*,90 days*/];\r\n        underlyingAssets = [1,2];\r\n    }\r\n    function setTimeLimitation(uint256 _limit)public onlyOwner{\r\n        limitation = _limit;\r\n    }\r\n    function getTimeLimitation()public view returns(uint256){\r\n        return limitation;\r\n    }\r\n    \r\n    /**\r\n     * @dev retrieve user's options' id. \r\n     * @param user user's account.\r\n     */     \r\n    function getUserOptionsID(address user)public view returns(uint64[] memory){\r\n        return optionsBalances[user];\r\n    }\r\n    /**\r\n     * @dev retrieve user's `size` number of options' id. \r\n     * @param user user's account.\r\n     * @param from user's option list begin positon.\r\n     * @param size retrieve size.\r\n     */ \r\n    function getUserOptionsID(address user,uint256 from,uint256 size)public view returns(uint64[] memory){\r\n        require(from <optionsBalances[user].length,\"input from is overflow\");\r\n        require(size>0,\"input size is zero\");\r\n        uint64[] memory userIdAry = new uint64[](size);\r\n        if (from+size>optionsBalances[user].length){\r\n            size = optionsBalances[user].length-from;\r\n        }\r\n        for (uint256 i= 0;i<size;i++){\r\n            userIdAry[i] = optionsBalances[user][from+i];\r\n        }\r\n        return userIdAry;\r\n    }\r\n    /**\r\n     * @dev retrieve all option list length. \r\n     */ \r\n    function getOptionInfoLength()public view returns (uint256){\r\n        return allOptions.length;\r\n    }\r\n    function getOptionInfo(uint64 id)internal view returns(address,uint256,uint256,uint256,uint256){\r\n        OptionsInfo memory info = allOptions[id-1];\r\n        return (info.owner,\r\n            (uint256(id) << 128)+(uint256(info.underlying) << 64) + info.optType,\r\n            (uint256(info.createTime+limitation) << 128)+(uint256(info.createTime) << 64)+info.createTime+info.expiration,\r\n            info.strikePrice,\r\n            info.amount);\r\n            \r\n    }\r\n    /**\r\n     * @dev retrieve `size` number of options' information. \r\n     * @param from all option list begin positon.\r\n     * @param size retrieve size.\r\n     */     \r\n    function getOptionInfoList(uint256 from,uint256 size)public view \r\n                returns(address[] memory,uint256[] memory,uint256[] memory,uint256[] memory,uint256[] memory){\r\n        uint256 allLen = allOptions.length;\r\n        require(from <allLen,\"input from is overflow\");\r\n        require(size>0,\"input size is zero\");\r\n        if (from+size>allLen){\r\n            size = allLen - from;\r\n        }\r\n        address[] memory ownerArr = new address[](size);\r\n        uint256[] memory type_underlying_id = new uint256[](size);\r\n        uint256[] memory exp_create_limit = new uint256[](size);\r\n        uint256[] memory priceArr = new uint256[](size);\r\n        uint256[] memory amountArr = new uint256[](size);\r\n        for (uint i=0;i<size;i++){\r\n            (ownerArr[i],type_underlying_id[i],exp_create_limit[i],priceArr[i],amountArr[i]) = \r\n                getOptionInfo(uint64(from+i+1));\r\n        }\r\n        return (ownerArr,type_underlying_id,exp_create_limit,priceArr,amountArr);\r\n    }\r\n\r\n    /**\r\n     * @dev retrieve given `ids` options' information. \r\n     * @param ids retrieved options' id.\r\n     */   \r\n    function getOptionInfoListFromID(uint64[] memory ids)public view \r\n                returns(address[] memory,uint256[] memory,uint256[] memory,uint256[] memory,uint256[] memory){\r\n        uint256 size = ids.length;\r\n        require(size > 0, \"input ids array is empty\");\r\n        address[] memory ownerArr = new address[](size);\r\n        uint256[] memory type_underlying_id = new uint256[](size);\r\n        uint256[] memory exp_create_limit = new uint256[](size);\r\n        uint256[] memory priceArr = new uint256[](size);\r\n        uint256[] memory amountArr = new uint256[](size);\r\n        for (uint i=0;i<size;i++){\r\n            (ownerArr[i],type_underlying_id[i],exp_create_limit[i],priceArr[i],amountArr[i]) = \r\n                getOptionInfo(ids[i]);\r\n        }\r\n        return (ownerArr,type_underlying_id,exp_create_limit,priceArr,amountArr);\r\n    }\r\n        /**\r\n     * @dev retrieve given `ids` options' information. \r\n     * @param user retrieved user's address.\r\n     */   \r\n    function getUserAllOptionInfo(address user)public view \r\n                returns(address[] memory,uint256[] memory,uint256[] memory,uint256[] memory,uint256[] memory){\r\n        return getOptionInfoListFromID(optionsBalances[user]);\r\n    }\r\n    /**\r\n     * @dev retrieve given `optionsId` option's burned limit timestamp. \r\n     * @param optionsId retrieved option's id.\r\n     */ \r\n    function getOptionsLimitTimeById(uint256 optionsId)public view returns(uint256){\r\n        require(optionsId>0 && optionsId <= allOptions.length,\"option id is not exist\");\r\n        OptionsInfo storage info = allOptions[optionsId-1];\r\n        return info.createTime + limitation;\r\n    }\r\n    /**\r\n     * @dev retrieve given `optionsId` option's information. \r\n     * @param optionsId retrieved option's id.\r\n     */ \r\n    function getOptionsById(uint256 optionsId)public view returns(uint256,address,uint8,uint32,uint256,uint256,uint256){\r\n        OptionsInfo memory info = _getOptionsById(optionsId);\r\n        return (optionsId,info.owner,info.optType,info.underlying,info.createTime+info.expiration,info.strikePrice,info.amount);\r\n    }\r\n    /**\r\n     * @dev retrieve given `optionsId` option's extra information. \r\n     * @param optionsId retrieved option's id.\r\n     */\r\n    function getOptionsExtraById(uint256 optionsId)public view returns(address,uint256,uint256,uint256,uint256){\r\n        OptionsInfo memory info = _getOptionsById(optionsId);\r\n        return (info.settlement,info.settlePrice,(info.strikePrice*info.priceRate)>>28,\r\n                info.optionsPrice,info.iv);\r\n    }\r\n    /**\r\n     * @dev An auxiliary function, get underlying prices. \r\n     */\r\n    function getUnderlyingPrices()internal view returns(uint256[] memory){\r\n        uint256 underlyingLen = underlyingAssets.length;\r\n        uint256[] memory prices = new uint256[](underlyingLen);\r\n        for (uint256 i = 0;i<underlyingLen;i++){\r\n            prices[i] = oracleUnderlyingPrice(underlyingAssets[i]);\r\n        }\r\n        return prices;\r\n    }\r\n    /**\r\n     * @dev create new option, store option info.\r\n     * @param from option's owner\r\n     * @param type_ly_expiration the tuple64 of option type, underlying,expiration\r\n     * @param strikePrice option's strike price and underlying price\r\n     * @param underlyingPrice option's paid price and price rate\r\n     * @param amount option's amount\r\n     */\r\n    function _createOptions(address from,address settlement,uint256 type_ly_expiration,\r\n        uint128 strikePrice,uint128 underlyingPrice,uint128 amount,uint128 settlePrice) internal returns(uint256){\r\n        uint32 expiration = uint32(type_ly_expiration>>128);\r\n        require(underlyingAssets.isEligibleUint32(uint32(type_ly_expiration>>64)) , \"underlying is unsupported asset\");\r\n        require(expirationList.isEligibleUint32(expiration),\"expiration value is not supported\");\r\n        uint256 iv = _volatility.calculateIv(uint32(type_ly_expiration>>64),uint8(type_ly_expiration),expiration,\r\n            underlyingPrice,strikePrice); \r\n        uint256 optPrice = _optionsPrice.getOptionsPrice_iv(underlyingPrice,strikePrice,expiration,iv,uint8(type_ly_expiration));\r\n        allOptions.push(OptionsInfo(from,\r\n            uint8(type_ly_expiration),\r\n            uint24(type_ly_expiration>>64),\r\n            uint64(optPrice),\r\n            settlement,\r\n            uint64(now),\r\n            expiration,\r\n            amount,\r\n            settlePrice,\r\n            strikePrice,\r\n            uint32((underlyingPrice<<28)/strikePrice),\r\n            uint64(iv),\r\n            0));\r\n        uint64 optionID = uint64(allOptions.length);\r\n        optionsBalances[from].push(optionID);\r\n        emit CreateOption(from,optionID,uint8(type_ly_expiration),uint32(type_ly_expiration>>64),expiration+now,\r\n            strikePrice,amount);\r\n        return optPrice;\r\n    }\r\n    /**\r\n     * @dev An auxiliary function, store new option's extra information.\r\n     * @param info option's information\r\n     * @param settlement the Coin address which user's paying for\r\n     * @param priceAndRate option's paid price\r\n     * @param underlyingAndStrike option's strike price and underlying price\r\n     */\r\n     /*\r\n    function setOptionsExtra(OptionsInfo memory info,address settlement,uint256 priceAndRate,uint256 underlyingAndStrike,uint256 settlePrice) internal{\r\n        uint256 underlyingPrice = (underlyingAndStrike>>128);\r\n        uint256 expiration = info.expiration - now;\r\n        uint256 ivNumerator = _volatility.calculateIv(info.underlying,info.optType,expiration,underlyingPrice,uint256(uint128(underlyingAndStrike)));\r\n        uint128 optionPrice = uint128(priceAndRate>>128);\r\n        uint128 rate = uint128(priceAndRate);\r\n        settlePrice = settlePrice/(uint256(rate));\r\n        optionExtraMap[info.optionID-1]= OptionsInfoEx(settlement,settlePrice,underlyingPrice,(uint256(optionPrice)*rate)>>32,ivNumerator,1<<32);\r\n    }\r\n    */\r\n    /**\r\n     * @dev burn an exist option whose id is `id`.\r\n     * @param from option's owner\r\n     * @param amount option's amount\r\n     */\r\n    function _burnOptions(address from,uint256 id,OptionsInfo memory info,uint256 amount)internal{\r\n//        OptionsInfo storage info = _getOptionsById(id);\r\n        require(info.createTime+info.expiration>now,\"option is expired\");\r\n        require(info.owner == from,\"caller is not the options owner\");\r\n        require(info.amount >= amount,\"option amount is insufficient\");\r\n        allOptions[id-1].amount = info.amount-uint128(amount);\r\n        emit BurnOption(from,id,amount);\r\n    }\r\n    /**\r\n     * @dev calculate option's exercise worth.\r\n     * @param optionsId option's id\r\n     * @param amount option's amount\r\n     */\r\n    function getExerciseWorth(uint256 optionsId,uint256 amount)public view returns(uint256){\r\n        OptionsInfo memory info = _getOptionsById(optionsId);\r\n        require(info.createTime+info.expiration>now,\"option is expired\");\r\n        require(info.amount >= amount,\"option amount is insufficient\");\r\n        uint256 underlyingPrice = oracleUnderlyingPrice(info.underlying);\r\n        uint256 tokenPayback = _getOptionsPayback(info.optType,info.strikePrice,underlyingPrice);\r\n        if (tokenPayback == 0 ){\r\n            return 0;\r\n        } \r\n        return tokenPayback*amount;\r\n    }\r\n    /**\r\n     * @dev An auxiliary function, calculate option's exercise payback.\r\n     * @param optType option's type\r\n     * @param strikePrice option's strikePrice\r\n     * @param underlyingPrice underlying's price\r\n     */\r\n    function _getOptionsPayback(uint8 optType,uint256 strikePrice,uint256 underlyingPrice)internal pure returns(uint256){\r\n        if ((optType == 0) == (strikePrice>underlyingPrice)){ // call\r\n            return 0;\r\n        } else {\r\n            return (optType == 0) ? underlyingPrice - strikePrice : strikePrice - underlyingPrice;\r\n        }\r\n    }\r\n    /**\r\n     * @dev retrieve option by id, check option's id.\r\n     * @param id option's id\r\n     */\r\n    function _getOptionsById(uint256 id)internal view returns(OptionsInfo storage){\r\n        require(id>0 && id <= allOptions.length,\"option id is not exist\");\r\n        return allOptions[id-1];\r\n    }\r\n\r\n    // /**\r\n    //  * @dev check option's underlying and expiration.\r\n    //  * @param expiration option's expiration\r\n    //  * @param underlying option's underlying\r\n    //  */\r\n    // function buyOptionCheck(uint32 expiration,uint32 underlying)public view{\r\n    //     require(underlyingAssets.isEligibleUint32(underlying) , \"underlying is unsupported asset\");\r\n    //     require(expirationList.isEligibleUint32(expiration),\"expiration value is not supported\");\r\n    // }\r\n    /**\r\n     * @dev Implementation of add an eligible expiration into the expirationList.\r\n     * @param expiration new eligible expiration.\r\n     */\r\n    function addExpiration(uint32 expiration)public onlyOwner{\r\n        expirationList.addWhiteListUint32(expiration);\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid expiration from the expirationList.\r\n     * @param removeExpiration revoked expiration.\r\n     */\r\n    function removeExpirationList(uint32 removeExpiration)public onlyOwner returns(bool) {\r\n        return expirationList.removeWhiteListUint32(removeExpiration);\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible expirationList.\r\n     */\r\n    function getExpirationList()public view returns (uint32[] memory){\r\n        return expirationList;\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input expiration is eligible.\r\n     * @param expiration input expiration for testing.\r\n     */    \r\n    function isEligibleExpiration(uint32 expiration) public view returns (bool){\r\n        return expirationList.isEligibleUint32(expiration);\r\n    }\r\n\r\n    /**\r\n     * @dev An auxiliary function, retrieve first available option's positon.\r\n     * @param begin  the start of option's positon\r\n     * @param latestBegin  the latest begin option positon.\r\n     * @param end  the end of option's positon\r\n     */\r\n    function getFirstOption(uint256 begin,uint256 latestBegin,uint256 end) internal view returns(uint256,uint256){\r\n        uint256 newFirstOption = latestBegin;\r\n        if (begin > newFirstOption){\r\n            //if in other phase, begin != new begin\r\n            return (begin,newFirstOption);\r\n        }\r\n        begin = newFirstOption;\r\n        for (;begin<end;begin++){\r\n            OptionsInfo storage info = allOptions[begin];\r\n            if(info.createTime+info.expiration<now || info.amount == 0){\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        //if in first phase, begin = new begin\r\n        return (begin,begin);\r\n    }\r\n    /**\r\n     * @dev calculate option's occupied collateral.\r\n     * @param option  option's information\r\n     * @param underlyingPrice  underlying current price.\r\n     */\r\n    function calOptionsCollateral(OptionsInfo memory option,uint256 underlyingPrice)internal view returns(uint256){\r\n        uint256 amount = option.amount;\r\n        if (option.createTime+option.expiration<=now || amount == 0){\r\n            return 0;\r\n        }\r\n        uint256 totalOccupied = _getOptionsWorth(option.optType,option.strikePrice,underlyingPrice)*amount;\r\n        require(totalOccupied<=1e40,\"Option collateral occupied calculate error\");\r\n        return totalOccupied;\r\n    }\r\n    /**\r\n     * @dev calculate one option's occupied collateral.\r\n     * @param optType  option's type\r\n     * @param strikePrice  option's strikePrice\r\n     * @param underlyingPrice  underlying current price.\r\n     */\r\n    function _getOptionsWorth(uint8 optType,uint256 strikePrice,uint256 underlyingPrice)internal pure returns(uint256){\r\n        if ((optType == 0) == (strikePrice>underlyingPrice)){ // call\r\n            return strikePrice;\r\n        } else {\r\n            return underlyingPrice;\r\n        }\r\n    }\r\n    /**\r\n     * @dev calculate `amount` number of Option's full price when option is burned.\r\n     * @param optionID  option's optionID\r\n     * @param amount  option's amount\r\n     */\r\n    function getBurnedFullPay(uint256 optionID,uint256 amount) Smaller(amount) public view returns(address,uint256){\r\n        OptionsInfo memory info = _getOptionsById(optionID);\r\n        return (info.settlement,info.optionsPrice*amount/info.settlePrice);\r\n    }\r\n}\r\n\r\n// File: contracts\\OptionsPool\\OptionsOccupiedCal.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @title Options collateral occupied calculation contract for finnexus proposal v2.\r\n * @dev A Smart-contract for collateral occupied calculation.\r\n *\r\n */\r\ncontract OptionsOccupiedCal is OptionsBase {\r\n\r\n    /**\r\n     * @dev retrieve collateral occupied calculation information.\r\n     */    \r\n    function getOccupiedCalInfo()public view returns(uint256,int256,int256){\r\n        return (occupiedFirstOption,callLatestOccupied,putLatestOccupied);\r\n    }\r\n    /**\r\n     * @dev calculate collateral occupied value, and modify database, only foundation operator can modify database.\r\n     */  \r\n    function setOccupiedCollateral() public onlyOperatorIndex(1) {\r\n        int256 latestCallOccupied = callLatestOccupied;\r\n        int256 latestPutOccupied = putLatestOccupied;\r\n        uint256 lastOption = allOptions.length;\r\n        (uint256 totalCallOccupied,uint256 totalPutOccupied,uint256 beginOption,bool success) = calculatePhaseOccupiedCollateral(lastOption, occupiedFirstOption,lastOption);\r\n        if (success){\r\n            setCollateralPhase(totalCallOccupied,totalPutOccupied,beginOption,latestCallOccupied,latestPutOccupied);\r\n        }\r\n    }\r\n    /**\r\n     * @dev calculate collateral occupied value.\r\n     * @param lastOption last option's position.\r\n     * @param beginOption begin option's poisiton.\r\n     * @param endOption end option's poisiton.\r\n     */  \r\n    function calculatePhaseOccupiedCollateral(uint256 lastOption,uint256 beginOption,uint256 endOption) public view returns(uint256,uint256,uint256,bool){\r\n        if (beginOption <  occupiedFirstOption){\r\n            beginOption =  occupiedFirstOption;\r\n        }\r\n        if (beginOption>=lastOption){\r\n            return (0,0,0,false);\r\n        }\r\n        if (endOption>lastOption) {\r\n            endOption = lastOption;\r\n        }else if(endOption <  occupiedFirstOption){\r\n            return (0,0,0,false);\r\n        }\r\n        (uint256 totalCallOccupied,uint256 totalPutOccupied,uint256 newFirstOption) = _calculateOccupiedCollateral(beginOption,endOption);\r\n        return (totalCallOccupied,totalPutOccupied,newFirstOption,true);\r\n    }\r\n    /**\r\n     * @dev subfunction, calculate collateral occupied value.\r\n     * @param begin begin option's poisiton.\r\n     * @param end end option's poisiton.\r\n     */  \r\n    function _calculateOccupiedCollateral(uint256 begin,uint256 end)internal view returns(uint256,uint256,uint256){\r\n        uint256 newFirstOption;\r\n        (begin,newFirstOption) = getFirstOption(begin, occupiedFirstOption,end);\r\n        uint256[] memory prices = getUnderlyingPrices();\r\n        uint256 totalCallOccupied = 0;\r\n        uint256 totalPutOccupied = 0;\r\n        for (;begin<end;begin++){\r\n            uint256 index = _getEligibleUnderlyingIndex(allOptions[begin].underlying);\r\n            uint256 value = calOptionsCollateral(allOptions[begin],prices[index]);\r\n            if (allOptions[begin].optType == 0){\r\n                totalCallOccupied += value;\r\n            }else{\r\n                totalPutOccupied += value;\r\n            }\r\n        }\r\n        return (totalCallOccupied,totalPutOccupied,newFirstOption);\r\n    }\r\n    /**\r\n     * @dev set collateral occupied value, only foundation operator can modify database.\r\n     * @param totalCallOccupied new call options occupied collateral calculation result.\r\n     * @param totalPutOccupied new put options occupied collateral calculation result.\r\n     * @param beginOption new first valid option's positon.\r\n     * @param latestCallOccpied latest call options' occupied value when operater invoke collateral occupied calculation.\r\n     * @param latestPutOccpied latest put options' occupied value when operater invoke collateral occupied calculation.\r\n     */  \r\n    function setCollateralPhase(uint256 totalCallOccupied,uint256 totalPutOccupied,uint256 beginOption,\r\n            int256 latestCallOccpied,int256 latestPutOccpied) public onlyOperatorIndex(1){\r\n        require(beginOption <= allOptions.length, \"beginOption calculate Error\");\r\n        if (beginOption >  occupiedFirstOption){\r\n             occupiedFirstOption = beginOption;\r\n        }\r\n        callOccupied = totalCallOccupied;\r\n        putOccupied = totalPutOccupied;\r\n        require(latestCallOccpied>=-1e40 && latestCallOccpied<=1e40,\"options fall calculate error\");\r\n        require(latestPutOccpied>=-1e40 && latestPutOccpied<=1e40,\"options fall calculate error\");\r\n        callLatestOccupied -= latestCallOccpied;\r\n        putLatestOccupied -= latestPutOccpied;\r\n    }\r\n    /**\r\n     * @dev get real total collateral occupied value.\r\n     */ \r\n    function getAllTotalOccupiedCollateral() public view returns (uint256,uint256) {\r\n        return (getCallTotalOccupiedCollateral(),getPutTotalOccupiedCollateral());\r\n    }\r\n    /**\r\n     * @dev get call options total collateral occupied value.\r\n     */ \r\n    function getCallTotalOccupiedCollateral() public view returns (uint256) {\r\n        if (callLatestOccupied>=0){\r\n            uint256 result = callOccupied+uint256(callLatestOccupied);\r\n            require(result>=callOccupied,\"TotalOccupiedCollateral calculate overflow\");\r\n            return result;\r\n        }else{\r\n            uint256 latestOccupied = uint256(-callLatestOccupied);\r\n            if (callOccupied>latestOccupied){\r\n                return callOccupied - latestOccupied;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n        /**\r\n     * @dev get put options total collateral occupied value.\r\n     */ \r\n    function getPutTotalOccupiedCollateral() public view returns (uint256) {\r\n        if (putLatestOccupied>=0){\r\n            uint256 result = putOccupied+uint256(putLatestOccupied);\r\n            require(result>=putOccupied,\"TotalOccupiedCollateral calculate overflow\");\r\n            return result;\r\n        }else{\r\n            uint256 latestOccupied = uint256(-putLatestOccupied);\r\n            if (putOccupied>latestOccupied){\r\n                return putOccupied - latestOccupied;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @dev get real total collateral occupied value.\r\n     */ \r\n    function getTotalOccupiedCollateral() public view returns (uint256) {\r\n        return getCallTotalOccupiedCollateral() + getPutTotalOccupiedCollateral();\r\n    }\r\n//     /**\r\n//      * @dev add new option collateral occupied value when user create a new option.\r\n//      * @param optionID new option's ID.\r\n//      */ \r\n//     function _addOptionsCollateral(uint256 optionID) internal {\r\n//         OptionsInfo memory info = allOptions[optionID-1];\r\n// //        OptionsInfoEx storage infoEx =  optionExtraMap[optionID-1];\r\n//         uint256 newOccupied = calOptionsCollateral(info,(info.strikePrice*info.priceRate)>>28);\r\n//         if (info.optType == 0){\r\n//             callLatestOccupied += int256(newOccupied);\r\n//         }else{\r\n//             putLatestOccupied += int256(newOccupied);\r\n//         }\r\n//     }\r\n    /**\r\n     * @dev deduct burned option collateral occupied value when user burn option.\r\n     * @param info burned option's information.\r\n     * @param amount burned option's amount.\r\n     * @param underlyingPrice current underlying price.\r\n     */ \r\n    function _burnOptionsCollateral(OptionsInfo memory info,uint256 amount,uint256 underlyingPrice) internal {\r\n        uint256 newOccupied = _getOptionsWorth(info.optType,info.strikePrice,underlyingPrice)*amount;\r\n        require(newOccupied<=1e40,\"Option collateral occupied calculate error\");\r\n        if (info.optType == 0){\r\n            callLatestOccupied -= int256(newOccupied);\r\n        }else{\r\n            putLatestOccupied -= int256(newOccupied);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\OptionsPool\\OptionsNetWorthCal.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @title Options net worth calculation contract for finnexus proposal v2.\r\n * @dev A Smart-contract for net worth calculation.\r\n *\r\n */\r\ncontract OptionsNetWorthCal is OptionsOccupiedCal {\r\n    /**\r\n     * @dev retrieve all information for net worth calculation. \r\n     * @param whiteList collateral address whitelist.\r\n     */ \r\n    function getNetWrothCalInfo(address[] memory whiteList)public view returns(uint256,int256[] memory){\r\n        uint256 len = whiteList.length;\r\n        int256[] memory latestNetWorth = new int256[](len);\r\n            for (uint256 i = 0;i<len;i++){\r\n            latestNetWorth[i] = optionsLatestNetWorth[whiteList[i]];\r\n        }\r\n        return ( netWorthirstOption,latestNetWorth);\r\n    }\r\n    /**\r\n     * @dev retrieve latest options net worth which paid in settlement coin. \r\n     * @param settlement settlement coin address.\r\n     */ \r\n    function getNetWrothLatestWorth(address settlement)public view returns(int256){\r\n        return optionsLatestNetWorth[settlement];\r\n    }\r\n    /**\r\n     * @dev set latest options net worth balance, only manager contract can modify database.\r\n     * @param newFirstOption new first valid option position.\r\n     * @param latestNetWorth latest options net worth.\r\n     * @param whiteList eligible collateral address white list.\r\n     */ \r\n    function setSharedState(uint256 newFirstOption,int256[] memory latestNetWorth,address[] memory whiteList) public onlyOperatorIndex(0){\r\n        require(newFirstOption <= allOptions.length, \"newFirstOption calculate Error\");\r\n        if (newFirstOption >  netWorthirstOption){\r\n             netWorthirstOption = newFirstOption;\r\n        }\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i = 0;i<len;i++){\r\n            require(latestNetWorth[i]>=-1e40 && latestNetWorth[i]<=1e40,\"latestNetWorth calculate error\");\r\n            optionsLatestNetWorth[whiteList[i]] += latestNetWorth[i];\r\n        }\r\n    }\r\n    /**\r\n     * @dev calculate options time shared value,from begin to end in the alloptionsList.\r\n     * @param lastOption the last option position.\r\n     * @param begin the begin options position.\r\n     * @param end the end options position.\r\n     * @param whiteList eligible collateral address white list.\r\n     */\r\n    function calRangeSharedPayment(uint256 lastOption,uint256 begin,uint256 end,address[] memory whiteList)\r\n            public view returns(int256[] memory,uint256[] memory,uint256){\r\n        if (begin>=lastOption || end <  netWorthirstOption){\r\n            return(new int256[](whiteList.length),new uint256[](whiteList.length),0);\r\n        }\r\n        if (end>lastOption) {\r\n            end = lastOption;\r\n        }\r\n        (uint256[] memory sharedBalances,uint256 _firstOption) = _calculateSharedPayment(begin,end,whiteList);\r\n        if (begin < _firstOption){\r\n            int256[] memory newNetworth = calculateExpiredPayment(begin,_firstOption,whiteList);\r\n            return (newNetworth,sharedBalances,_firstOption);\r\n        }\r\n        \r\n        return (new int256[](whiteList.length),sharedBalances,_firstOption);\r\n    }\r\n    /**\r\n     * @dev subfunction, calculate options time shared value,from begin to end in the alloptionsList.\r\n     * @param begin the begin options position.\r\n     * @param end the end options position.\r\n     * @param whiteList eligible collateral address white list.\r\n     */\r\n    function _calculateSharedPayment(uint256 begin,uint256 end,address[] memory whiteList)\r\n            internal view returns(uint256[] memory,uint256){\r\n        uint256[] memory totalSharedPayment = new uint256[](whiteList.length);\r\n        uint256 newFirstOption;\r\n        (begin,newFirstOption) = getFirstOption(begin, netWorthirstOption,end); \r\n        for (;begin<end;begin++){\r\n            OptionsInfo storage info = allOptions[begin];\r\n            uint256 timeValue = _calculateCurrentPrice((info.strikePrice*info.priceRate)>>28,info.optionsPrice,\r\n                info.createTime+info.expiration,info.iv,info.optType);\r\n            if (timeValue<info.optionsPrice){\r\n                timeValue = info.optionsPrice - timeValue;\r\n                uint256 index = whiteListAddress._getEligibleIndexAddress(whiteList,info.settlement);\r\n                timeValue = timeValue*info.amount/info.settlePrice;\r\n                require(timeValue<=1e40,\"option time shared value calculate error\");\r\n                totalSharedPayment[index] = totalSharedPayment[index]+timeValue;\r\n            }\r\n        }\r\n        return (totalSharedPayment,newFirstOption);\r\n    }\r\n    /**\r\n     * @dev subfunction, calculate expired options shared value,from begin to end in the alloptionsList.\r\n     * @param begin the begin options position.\r\n     * @param end the end options position.\r\n     * @param whiteList eligible collateral address white list.\r\n     */\r\n    function calculateExpiredPayment(uint256 begin,uint256 end,address[] memory whiteList)internal view returns(int256[] memory){\r\n        int256[] memory totalExpiredPayment = new int256[](whiteList.length);\r\n        for (;begin<end;begin++){\r\n            OptionsInfo storage info = allOptions[begin];\r\n            uint256 amount = info.amount;\r\n            if (amount>0){\r\n                uint256 index = whiteListAddress._getEligibleIndexAddress(whiteList,info.settlement);\r\n                uint256 timeValue = info.optionsPrice*amount/info.settlePrice;\r\n                require(timeValue<=1e40,\"option time shared value calculate error\");\r\n                totalExpiredPayment[index] = totalExpiredPayment[index]+int256(timeValue);\r\n            }\r\n        }\r\n        return totalExpiredPayment;\r\n    }\r\n    /**\r\n     * @dev calculate options payback fall value,from begin to end in the alloptionsList.\r\n     * @param lastOption the last option position.\r\n     * @param begin the begin options position.\r\n     * @param end the end options position.\r\n     * @param whiteList eligible collateral address white list.\r\n     */\r\n    function calculatePhaseOptionsFall(uint256 lastOption,uint256 begin,uint256 end,address[] memory whiteList) public view returns(int256[] memory){\r\n        if (begin>=lastOption || end <  netWorthirstOption){\r\n            return new int256[](whiteList.length);\r\n        }\r\n        if (end>lastOption) {\r\n            end = lastOption;\r\n        }\r\n        if (begin <=  netWorthirstOption) {\r\n            begin =  netWorthirstOption;\r\n        }\r\n        uint256[] memory prices = getUnderlyingPrices();\r\n        int256[] memory OptionsFallBalances = _calRangeOptionsFall(begin,end,whiteList,prices);\r\n        uint256 whiteListLen = whiteList.length;\r\n        for (uint256 index = 0;index<whiteListLen;index++){\r\n            OptionsFallBalances[index] = OptionsFallBalances[index]/(int256(oraclePrice(whiteList[index])));\r\n        }\r\n        return OptionsFallBalances;\r\n    }\r\n    /**\r\n     * @dev subfunction, calculate options payback fall value,from begin to lastOption in the alloptionsList.\r\n     * @param begin the begin option position.\r\n     * @param lastOption the last option position.\r\n     * @param whiteList eligible collateral address white list.\r\n     * @param prices eligible underlying price list.\r\n     */\r\n    function _calRangeOptionsFall(uint256 begin,uint256 lastOption,address[] memory whiteList,uint256[] memory prices)\r\n                 internal view returns(int256[] memory){\r\n        int256[] memory OptionsFallBalances = new int256[](whiteList.length);\r\n        for (;begin<lastOption;begin++){\r\n            OptionsInfo storage info = allOptions[begin];\r\n            uint256 amount = info.amount;\r\n            if(info.createTime + info.expiration<now || amount == 0){\r\n                continue;\r\n            }\r\n            uint256 index = _getEligibleUnderlyingIndex(info.underlying);\r\n            int256 curValue = _calCurtimeCallateralFall(info,amount,prices[index]);\r\n            if (curValue != 0){\r\n                index = whiteListAddress._getEligibleIndexAddress(whiteList,info.settlement);\r\n                OptionsFallBalances[index] = OptionsFallBalances[index]-curValue;\r\n            }\r\n        }\r\n        return OptionsFallBalances;\r\n    }\r\n    /**\r\n     * @dev subfunction, calculate option payback fall value.\r\n     * @param info the option information.\r\n     * @param amount the option amount to calculate.\r\n     * @param curPrice current underlying price.\r\n     */\r\n    function _calCurtimeCallateralFall(OptionsInfo memory info,uint256 amount,uint256 curPrice) internal view returns(int256){\r\n        if (info.createTime + info.expiration<=now || amount == 0){\r\n            return 0;\r\n        }\r\n        uint256 newFall = _getOptionsPayback(info.optType,info.optionsPrice,curPrice)*amount;\r\n        uint256 OriginFall = _getOptionsPayback(info.optType,info.optionsPrice,(info.strikePrice*info.priceRate)>>28)*amount;\r\n        int256 curValue = int256(newFall) - int256(OriginFall);\r\n        require(curValue>=-1e40 && curValue<=1e40,\"options fall calculate error\");\r\n        return curValue;\r\n    }\r\n    /*\r\n    function _addNewOptionsNetworth(OptionsInfo memory info)  internal {\r\n        OptionsInfoEx storage infoEx =  optionExtraMap[info.optionID-1];\r\n        uint256 price = oraclePrice(info.underlying);\r\n        uint256 curValue = _calCurtimeCallateralFall(info,getOptionAmount(info),(info.strikePrice*info.priceRate)>>28)/price;\r\n        optionsLatestNetWorth[nfo.underlying] = optionsLatestNetWorth[nfo.underlying].sub(int256(curValue));\r\n    }\r\n    */\r\n    /**\r\n     * @dev set burn option net worth change.\r\n     * @param info the option information.\r\n     * @param amount the option amount to calculate.\r\n     * @param underlyingPrice underlying price when option is created.\r\n     * @param currentPrice current underlying price.\r\n     */\r\n    function _burnOptionsNetworth(OptionsInfo memory info,uint256 amount,uint256 underlyingPrice,uint256 currentPrice) internal {\r\n        int256 curValue = _calCurtimeCallateralFall(info,amount,underlyingPrice);\r\n        uint256 timeWorth = info.optionsPrice>currentPrice ? info.optionsPrice-currentPrice : 0;\r\n        timeWorth = timeWorth*amount/info.settlePrice;\r\n        address settlement = info.settlement;\r\n        curValue = curValue / int256(oraclePrice(settlement));\r\n        int256 value = curValue - int256(timeWorth);\r\n        optionsLatestNetWorth[settlement] = optionsLatestNetWorth[settlement]+value;\r\n    }\r\n    /**\r\n     * @dev An anxiliary function, calculate time shared current option price.\r\n     * @param curprice underlying price when option is created.\r\n     * @param strikePrice the option strikePrice.\r\n     * @param expiration option time expiration time left, equal option.expiration - now.\r\n     * @param ivNumerator Implied valotility numerator when option is created.\r\n     */\r\n    function _calculateCurrentPrice(uint256 curprice,uint256 strikePrice,uint256 expiration,uint256 ivNumerator,uint8 optType)internal view returns (uint256){\r\n        if (expiration > now){\r\n            return _optionsPrice.getOptionsPrice_iv(curprice,strikePrice,expiration-now,ivNumerator,\r\n                optType);\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: contracts\\OptionsPool\\OptionsPool.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @title Options pool contract.\r\n * @dev store options' information and nessesary options' calculation.\r\n *\r\n */\r\ncontract OptionsPool is OptionsNetWorthCal {\r\n    /**\r\n     * @dev constructor function , setting contract address.\r\n     * @param oracleAddr FNX oracle contract address\r\n     * @param optionsPriceAddr options price contract address\r\n     * @param ivAddress implied volatility contract address\r\n     */  \r\n    constructor (address oracleAddr,address optionsPriceAddr,address ivAddress)public{\r\n        _oracle = IFNXOracle(oracleAddr);\r\n        _optionsPrice = IOptionsPrice(optionsPriceAddr);\r\n        _volatility = IVolatility(ivAddress);\r\n    }\r\n    function update() onlyOwner public {\r\n\r\n    }\r\n    /**\r\n     * @dev retrieve all information for collateral occupied and net worth calculation.\r\n     * @param whiteList settlement address whitelist.\r\n     */ \r\n    function getOptionCalRangeAll(address[] memory whiteList)public view returns(uint256,int256,int256,uint256,int256[] memory,uint256,uint256){\r\n        (uint256 occupiedFirst,int256 callOccupiedlatest,int256 putOccupiedlatest) = getOccupiedCalInfo();\r\n        (uint256 netFirst,int256[] memory netLatest) = getNetWrothCalInfo(whiteList);\r\n        return (occupiedFirst,callOccupiedlatest,putOccupiedlatest,netFirst,netLatest,allOptions.length,block.number);\r\n    }\r\n    /**\r\n     * @dev create new option,modify collateral occupied and net worth value, only manager contract can invoke this.\r\n     * @param from user's address.\r\n     * @param type_ly_expiration tuple64 for option type,underlying,expiration.\r\n     * @param strikePrice user's input new option's strike price.\r\n     * @param underlyingPrice current new option's price, calculated by options price contract.\r\n     * @param amount user's input new option's amount.\r\n     */ \r\n    function createOptions(address from,address settlement,uint256 type_ly_expiration,\r\n        uint128 strikePrice,uint128 underlyingPrice,uint128 amount,uint128 settlePrice) onlyManager public returns(uint256){\r\n        uint256 price = _createOptions(from,settlement,type_ly_expiration,strikePrice,underlyingPrice,amount,settlePrice);\r\n        uint256 totalOccupied = _getOptionsWorth(uint8(type_ly_expiration),strikePrice,underlyingPrice)*amount;\r\n        require(totalOccupied<=1e40,\"Option collateral occupied calculate error\");\r\n        if (uint8(type_ly_expiration) == 0){\r\n            callLatestOccupied += int256(totalOccupied);\r\n        }else{\r\n            putLatestOccupied += int256(totalOccupied);\r\n        }\r\n        //_addOptionsCollateral(allOptions.length);\r\n        return price;\r\n//        _addNewOptionsNetworth(info);\r\n    }\r\n    /**\r\n     * @dev burn option,modify collateral occupied and net worth value, only manager contract can invoke this.\r\n     * @param from user's address.\r\n     * @param id user's input option's id.\r\n     * @param amount user's input burned option's amount.\r\n     * @param optionPrice current new option's price, calculated by options price contract.\r\n     */ \r\n    function burnOptions(address from,uint256 id,uint256 amount,uint256 optionPrice)public onlyManager Smaller(amount) OutLimitation(id){\r\n        OptionsInfo memory info = _getOptionsById(id);\r\n        _burnOptions(from,id,info,amount);\r\n        uint256 currentPrice = oracleUnderlyingPrice(info.underlying);\r\n        _burnOptionsCollateral(info,amount,currentPrice);\r\n        _burnOptionsNetworth(info,amount,currentPrice,optionPrice);\r\n    }\r\n        modifier OutLimitation(uint256 id) {\r\n        require(allOptions[id-1].createTime+limitation<now,\"Time limitation is not expired!\");\r\n        _;\r\n    }   \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optionsPriceAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ivAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"optType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreateOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value2\",\"type\":\"uint256\"}],\"name\":\"DebugEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"expiration\",\"type\":\"uint32\"}],\"name\":\"addExpiration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"}],\"name\":\"addUnderlyingAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionPrice\",\"type\":\"uint256\"}],\"name\":\"burnOptions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastOption\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"begin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"whiteList\",\"type\":\"address[]\"}],\"name\":\"calRangeSharedPayment\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastOption\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beginOption\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endOption\",\"type\":\"uint256\"}],\"name\":\"calculatePhaseOccupiedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastOption\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"begin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"whiteList\",\"type\":\"address[]\"}],\"name\":\"calculatePhaseOptionsFall\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"type_ly_expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"strikePrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"underlyingPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"settlePrice\",\"type\":\"uint128\"}],\"name\":\"createOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTotalOccupiedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBurnedFullPay\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCallTotalOccupiedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionsId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getExerciseWorth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpirationList\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInputAmountRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"whiteList\",\"type\":\"address[]\"}],\"name\":\"getNetWrothCalInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"}],\"name\":\"getNetWrothLatestWorth\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOccupiedCalInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"whiteList\",\"type\":\"address[]\"}],\"name\":\"getOptionCalRangeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOptionInfoLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getOptionInfoList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"ids\",\"type\":\"uint64[]\"}],\"name\":\"getOptionInfoListFromID\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionsId\",\"type\":\"uint256\"}],\"name\":\"getOptionsById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionsId\",\"type\":\"uint256\"}],\"name\":\"getOptionsExtraById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionsId\",\"type\":\"uint256\"}],\"name\":\"getOptionsLimitTimeById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOptionsPriceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPutTotalOccupiedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLimitation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalOccupiedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnderlyingAssets\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserAllOptionInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserOptionsID\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserOptionsID\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVolatilityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"expiration\",\"type\":\"uint32\"}],\"name\":\"isEligibleExpiration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"}],\"name\":\"isEligibleUnderlyingAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"isInputAmountInRange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"removeExpiration\",\"type\":\"uint32\"}],\"name\":\"removeExpirationList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"removeUnderlying\",\"type\":\"uint32\"}],\"name\":\"removeUnderlyingAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCallOccupied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPutOccupied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beginOption\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"latestCallOccpied\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"latestPutOccpied\",\"type\":\"int256\"}],\"name\":\"setCollateralPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"setInputAmountRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerAddress\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setOccupiedCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"optionsPrice\",\"type\":\"address\"}],\"name\":\"setOptionsPriceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFirstOption\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"latestNetWorth\",\"type\":\"int256[]\"},{\"internalType\":\"address[]\",\"name\":\"whiteList\",\"type\":\"address[]\"}],\"name\":\"setSharedState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setTimeLimitation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"underlyings\",\"type\":\"uint32[]\"}],\"name\":\"setUnderlyingAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"volatility\",\"type\":\"address\"}],\"name\":\"setVolatilityAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OptionsPool","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000366080a2605d37d91b69f9ac08d0434142fa01240000000000000000000000005e5114738ff0e6a36c289ecddd46c1975cefc27200000000000000000000000021d40f44d3c93ba4f0d94fa212a666fec381e26c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://44330aef20d1bec111c00d9505dec23b01e33136b453b486ce4c3337288c9811"}]}