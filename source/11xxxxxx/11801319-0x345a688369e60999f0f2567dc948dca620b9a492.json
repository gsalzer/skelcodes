{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL\r\npragma solidity 0.6.12;\r\n\r\ninterface IGraSwapRouter {\r\n    event AddLiquidity(uint stockAmount, uint moneyAmount, uint liquidity);\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    // liquidity\r\n    function addLiquidity(\r\n        address stock,\r\n        address money,\r\n        bool isOnlySwap,\r\n        uint amountStockDesired,\r\n        uint amountMoneyDesired,\r\n        uint amountStockMin,\r\n        uint amountMoneyMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountStock, uint amountMoney, uint liquidity);\r\n    function removeLiquidity(\r\n        address pair,\r\n        uint liquidity,\r\n        uint amountStockMin,\r\n        uint amountMoneyMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountStock, uint amountMoney);\r\n\r\n    // swap token\r\n    function swapToken(\r\n        address token,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    // limit order\r\n    function limitOrder(\r\n        bool isBuy,\r\n        address pair,\r\n        uint prevKey,\r\n        uint price,\r\n        uint32 id,\r\n        uint stockAmount,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ninterface IGraSwapFactory {\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\r\n    function setFeeToAddresses(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setFeeBPS(uint32 bps) external;\r\n    function setPairLogic(address implLogic) external;\r\n\r\n    function allPairsLength() external view returns (uint);\r\n    function feeTo_1() external view returns (address);\r\n    function feeTo_2() external view returns (address);\r\n    function feeToPrivate() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function feeBPS() external view returns (uint32);\r\n    function pairLogic() external returns (address);\r\n    function getTokensFromPair(address pair) external view returns (address stock, address money);\r\n    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\r\n}\r\n\r\ninterface IGraSwapERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IGraSwapPool {\r\n    // more liquidity was minted\r\n    event Mint(address indexed sender, uint stockAndMoneyAmount, address indexed to);\r\n    // liquidity was burned\r\n    event Burn(address indexed sender, uint stockAndMoneyAmount, address indexed to);\r\n    // amounts of reserved stock and money in this pair changed\r\n    event Sync(uint reserveStockAndMoney);\r\n\r\n    function internalStatus() external view returns(uint[3] memory res);\r\n    function getReserves() external view returns (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID);\r\n    function getBooked() external view returns (uint112 bookedStock, uint112 bookedMoney, uint32 firstBuyID);\r\n    function stock() external returns (address);\r\n    function money() external returns (address);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint stockAmount, uint moneyAmount);\r\n    function skim(address to) external;\r\n    function sync() external;\r\n}\r\n\r\ninterface IGraSwapPair {\r\n    event NewLimitOrder(uint data); // new limit order was sent by an account\r\n    event NewMarketOrder(uint data); // new market order was sent by an account\r\n    event OrderChanged(uint data); // old orders in orderbook changed\r\n    event DealWithPool(uint data); // new order deal with the AMM pool\r\n    event RemoveOrder(uint data); // an order was removed from the orderbook\r\n    \r\n    // Return three prices in rational number form, i.e., numerator/denominator.\r\n    // They are: the first sell order's price; the first buy order's price; the current price of the AMM pool.\r\n    function getPrices() external returns (\r\n        uint firstSellPriceNumerator,\r\n        uint firstSellPriceDenominator,\r\n        uint firstBuyPriceNumerator,\r\n        uint firstBuyPriceDenominator,\r\n        uint poolPriceNumerator,\r\n        uint poolPriceDenominator);\r\n\r\n    // This function queries a list of orders in orderbook. It starts from 'id' and iterates the single-linked list, util it reaches the end, \r\n    // or until it has found 'maxCount' orders. If 'id' is 0, it starts from the beginning of the single-linked list.\r\n    // It may cost a lot of gas. So you'd not to call in on chain. It is mainly for off-chain query.\r\n    // The first uint256 returned by this function is special: the lowest 24 bits is the first order's id and the the higher bits is block height.\r\n    // THe other uint256s are all corresponding to an order record of the single-linked list.\r\n    function getOrderList(bool isBuy, uint32 id, uint32 maxCount) external view returns (uint[] memory);\r\n\r\n    // remove an order from orderbook and return its booked (i.e. frozen) money to maker\r\n    // 'id' points to the order to be removed\r\n    // prevKey points to 3 previous orders in the single-linked list\r\n    function removeOrder(bool isBuy, uint32 id, uint72 positionID) external;\r\n\r\n    function removeOrders(uint[] calldata rmList) external;\r\n\r\n    // Try to deal a new limit order or insert it into orderbook\r\n    // its suggested order id is 'id' and suggested positions are in 'prevKey'\r\n    // prevKey points to 3 existing orders in the single-linked list\r\n    // the order's sender is 'sender'. the order's amount is amount*stockUnit, which is the stock amount to be sold or bought.\r\n    // the order's price is 'price32', which is decimal floating point value.\r\n    function addLimitOrder(bool isBuy, address sender, uint64 amount, uint32 price32, uint32 id, uint72 prevKey) external payable;\r\n\r\n    // Try to deal a new market order. 'sender' pays 'inAmount' of 'inputToken', in exchange of the other token kept by this pair\r\n    function addMarketOrder(address inputToken, address sender, uint112 inAmount) external payable returns (uint);\r\n\r\n    // Given the 'amount' of stock and decimal floating point price 'price32', calculate the 'stockAmount' and 'moneyAmount' to be traded\r\n    function calcStockAndMoney(uint64 amount, uint32 price32) external pure returns (uint stockAmount, uint moneyAmount);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath256 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/*\r\nThis library defines a decimal floating point number. It has 8 decimal significant digits. Its maximum value is 9.9999999e+15.\r\nAnd its minimum value is 1.0e-16. The following golang code explains its detail implementation.\r\n\r\nfunc buildPrice(significant int, exponent int) uint32 {\r\n\tif !(10000000 <= significant && significant <= 99999999) {\r\n\t\tpanic(\"Invalid significant\")\r\n\t}\r\n\tif !(-16 <= exponent && exponent <= 15) {\r\n\t\tpanic(\"Invalid exponent\")\r\n\t}\r\n\treturn uint32(((exponent+16)<<27)|significant);\r\n}\r\n\r\nfunc priceToFloat(price uint32) float64 {\r\n\texponent := int(price>>27)\r\n\tsignificant := float64(price&((1<<27)-1))\r\n\treturn significant * math.Pow10(exponent-23)\r\n}\r\n\r\n*/\r\n\r\n// A price presented as a rational number\r\nstruct RatPrice {\r\n    uint numerator;   // at most 54bits\r\n    uint denominator; // at most 76bits\r\n}\r\n\r\nlibrary DecFloat32 {\r\n    uint32 public constant MANTISSA_MASK = (1<<27) - 1;\r\n    uint32 public constant MAX_MANTISSA = 9999_9999;\r\n    uint32 public constant MIN_MANTISSA = 1000_0000;\r\n    uint32 public constant MIN_PRICE = MIN_MANTISSA;\r\n    uint32 public constant MAX_PRICE = (31<<27)|MAX_MANTISSA;\r\n\r\n    // 10 ** (i + 1)\r\n    function powSmall(uint32 i) internal pure returns (uint) {\r\n        uint x = 2695994666777834996822029817977685892750687677375768584125520488993233305610;\r\n        return (x >> (32*i)) & ((1<<32)-1);\r\n    }\r\n\r\n    // 10 ** (i * 8)\r\n    function powBig(uint32 i) internal pure returns (uint) {\r\n        uint y = 3402823669209384634633746076162356521930955161600000001;\r\n        return (y >> (64*i)) & ((1<<64)-1);\r\n    }\r\n\r\n    // if price32=( 0<<27)|12345678 then numerator=12345678 denominator=100000000000000000000000\r\n    // if price32=( 1<<27)|12345678 then numerator=12345678 denominator=10000000000000000000000\r\n    // if price32=( 2<<27)|12345678 then numerator=12345678 denominator=1000000000000000000000\r\n    // if price32=( 3<<27)|12345678 then numerator=12345678 denominator=100000000000000000000\r\n    // if price32=( 4<<27)|12345678 then numerator=12345678 denominator=10000000000000000000\r\n    // if price32=( 5<<27)|12345678 then numerator=12345678 denominator=1000000000000000000\r\n    // if price32=( 6<<27)|12345678 then numerator=12345678 denominator=100000000000000000\r\n    // if price32=( 7<<27)|12345678 then numerator=12345678 denominator=10000000000000000\r\n    // if price32=( 8<<27)|12345678 then numerator=12345678 denominator=1000000000000000\r\n    // if price32=( 9<<27)|12345678 then numerator=12345678 denominator=100000000000000\r\n    // if price32=(10<<27)|12345678 then numerator=12345678 denominator=10000000000000\r\n    // if price32=(11<<27)|12345678 then numerator=12345678 denominator=1000000000000\r\n    // if price32=(12<<27)|12345678 then numerator=12345678 denominator=100000000000\r\n    // if price32=(13<<27)|12345678 then numerator=12345678 denominator=10000000000\r\n    // if price32=(14<<27)|12345678 then numerator=12345678 denominator=1000000000\r\n    // if price32=(15<<27)|12345678 then numerator=12345678 denominator=100000000\r\n    // if price32=(16<<27)|12345678 then numerator=12345678 denominator=10000000\r\n    // if price32=(17<<27)|12345678 then numerator=12345678 denominator=1000000\r\n    // if price32=(18<<27)|12345678 then numerator=12345678 denominator=100000\r\n    // if price32=(19<<27)|12345678 then numerator=12345678 denominator=10000\r\n    // if price32=(20<<27)|12345678 then numerator=12345678 denominator=1000\r\n    // if price32=(21<<27)|12345678 then numerator=12345678 denominator=100\r\n    // if price32=(22<<27)|12345678 then numerator=12345678 denominator=10\r\n    // if price32=(23<<27)|12345678 then numerator=12345678 denominator=1\r\n    // if price32=(24<<27)|12345678 then numerator=123456780 denominator=1\r\n    // if price32=(25<<27)|12345678 then numerator=1234567800 denominator=1\r\n    // if price32=(26<<27)|12345678 then numerator=12345678000 denominator=1\r\n    // if price32=(27<<27)|12345678 then numerator=123456780000 denominator=1\r\n    // if price32=(28<<27)|12345678 then numerator=1234567800000 denominator=1\r\n    // if price32=(29<<27)|12345678 then numerator=12345678000000 denominator=1\r\n    // if price32=(30<<27)|12345678 then numerator=123456780000000 denominator=1\r\n    // if price32=(31<<27)|12345678 then numerator=1234567800000000 denominator=1\r\n    function expandPrice(uint32 price32) internal pure returns (RatPrice memory) {\r\n        uint s = price32&((1<<27)-1);\r\n        uint32 a = price32 >> 27;\r\n        RatPrice memory price;\r\n        if(a >= 24) {\r\n            uint32 b = a - 24;\r\n            price.numerator = s * powSmall(b);\r\n            price.denominator = 1;\r\n        } else if(a == 23) {\r\n            price.numerator = s;\r\n            price.denominator = 1;\r\n        } else {\r\n            uint32 b = 22 - a;\r\n            price.numerator = s;\r\n            price.denominator = powSmall(b&0x7) * powBig(b>>3);\r\n        }\r\n        return price;\r\n    }\r\n\r\n    function getExpandPrice(uint price) internal pure returns(uint numerator, uint denominator) {\r\n        uint32 m = uint32(price) & MANTISSA_MASK;\r\n        require(MIN_MANTISSA <= m && m <= MAX_MANTISSA, \"Invalid Price\");\r\n        RatPrice memory actualPrice = expandPrice(uint32(price));\r\n        return (actualPrice.numerator, actualPrice.denominator);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract GraSwapRouter is IGraSwapRouter {\r\n    using SafeMath256 for uint;\r\n    address public immutable override factory;\r\n\r\n    modifier ensure(uint deadline) {\r\n        // solhint-disable-next-line not-rely-on-time,\r\n        require(deadline >= block.timestamp, \"GraSwapRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory) public {\r\n        factory = _factory;\r\n    }\r\n\r\n    function _addLiquidity(address pair, uint amountStockDesired, uint amountMoneyDesired,\r\n        uint amountStockMin, uint amountMoneyMin) private view returns (uint amountStock, uint amountMoney) {\r\n\r\n        (uint reserveStock, uint reserveMoney, ) = IGraSwapPool(pair).getReserves();\r\n        if (reserveStock == 0 && reserveMoney == 0) {\r\n            (amountStock, amountMoney) = (amountStockDesired, amountMoneyDesired);\r\n        } else {\r\n            uint amountMoneyOptimal = _quote(amountStockDesired, reserveStock, reserveMoney);\r\n            if (amountMoneyOptimal <= amountMoneyDesired) {\r\n                require(amountMoneyOptimal >= amountMoneyMin, \"GraSwapRouter: INSUFFICIENT_MONEY_AMOUNT\");\r\n                (amountStock, amountMoney) = (amountStockDesired, amountMoneyOptimal);\r\n            } else {\r\n                uint amountStockOptimal = _quote(amountMoneyDesired, reserveMoney, reserveStock);\r\n                assert(amountStockOptimal <= amountStockDesired);\r\n                require(amountStockOptimal >= amountStockMin, \"GraSwapRouter: INSUFFICIENT_STOCK_AMOUNT\");\r\n                (amountStock, amountMoney) = (amountStockOptimal, amountMoneyDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidity(address stock, address money, bool isOnlySwap, uint amountStockDesired,\r\n        uint amountMoneyDesired, uint amountStockMin, uint amountMoneyMin, address to, uint deadline) external\r\n        payable override ensure(deadline) returns (uint amountStock, uint amountMoney, uint liquidity) {\r\n\r\n        if (stock != address(0) && money != address(0)) {\r\n            require(msg.value == 0, 'GraSwapRouter: NOT_ENTER_ETH_VALUE');\r\n        }\r\n        address pair = IGraSwapFactory(factory).tokensToPair(stock, money, isOnlySwap);\r\n        if (pair == address(0)) {\r\n            pair = IGraSwapFactory(factory).createPair(stock, money, isOnlySwap);\r\n        }\r\n        (amountStock, amountMoney) = _addLiquidity(pair, amountStockDesired,\r\n            amountMoneyDesired, amountStockMin, amountMoneyMin);\r\n        _safeTransferFrom(stock, msg.sender, pair, amountStock);\r\n        _safeTransferFrom(money, msg.sender, pair, amountMoney);\r\n        liquidity = IGraSwapPool(pair).mint(to);\r\n        emit AddLiquidity(amountStock, amountMoney, liquidity);\r\n    }\r\n\r\n    function _removeLiquidity(address pair, uint liquidity, uint amountStockMin,\r\n        uint amountMoneyMin, address to) private returns (uint amountStock, uint amountMoney) {\r\n        IERC20(pair).transferFrom(msg.sender, pair, liquidity);\r\n        (amountStock, amountMoney) = IGraSwapPool(pair).burn(to);\r\n        require(amountStock >= amountStockMin, \"GraSwapRouter: INSUFFICIENT_STOCK_AMOUNT\");\r\n        require(amountMoney >= amountMoneyMin, \"GraSwapRouter: INSUFFICIENT_MONEY_AMOUNT\");\r\n    }\r\n\r\n    function removeLiquidity(address pair, uint liquidity, uint amountStockMin, uint amountMoneyMin,\r\n        address to, uint deadline) external override ensure(deadline) returns (uint amountStock, uint amountMoney) {\r\n        // ensure pair exist\r\n        _getTokensFromPair(pair);\r\n        (amountStock, amountMoney) = _removeLiquidity(pair, liquidity, amountStockMin, amountMoneyMin, to);\r\n    }\r\n\r\n    function _swap(address input, uint amountIn, address[] memory path, address _to) internal virtual returns (uint[] memory amounts) {\r\n        amounts = new uint[](path.length + 1);\r\n        amounts[0] = amountIn;\r\n\r\n        for (uint i = 0; i < path.length; i++) {\r\n            (address to, bool isLastSwap) = i < path.length - 1 ? (path[i+1], false) : (_to, true);\r\n            amounts[i + 1] = IGraSwapPair(path[i]).addMarketOrder(input, to, uint112(amounts[i]));\r\n            if (!isLastSwap) {\r\n                (address stock, address money) = _getTokensFromPair(path[i]);\r\n                input = (stock != input) ? stock : money;\r\n            }\r\n        }\r\n    }\r\n\r\n    function swapToken(address token, uint amountIn, uint amountOutMin, address[] calldata path,\r\n        address to, uint deadline) external payable override ensure(deadline) returns (uint[] memory amounts) {\r\n\r\n        if (token != address(0)) { require(msg.value == 0, 'GraSwapRouter: NOT_ENTER_ETH_VALUE'); }\r\n        require(path.length >= 1, \"GraSwapRouter: INVALID_PATH\");\r\n        // ensure pair exist\r\n        _getTokensFromPair(path[0]);\r\n        _safeTransferFrom(token, msg.sender, path[0], amountIn);\r\n        amounts = _swap(token, amountIn, path, to);\r\n        require(amounts[path.length] >= amountOutMin, \"GraSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function limitOrder(bool isBuy, address pair, uint prevKey, uint price, uint32 id,\r\n        uint stockAmount, uint deadline) external payable override ensure(deadline) {\r\n\r\n        (address stock, address money) = _getTokensFromPair(pair);\r\n        {\r\n            (uint _stockAmount, uint _moneyAmount) = IGraSwapPair(pair).calcStockAndMoney(uint64(stockAmount), uint32(price));\r\n            if (isBuy) {\r\n                if (money != address(0)) { require(msg.value == 0, 'GraSwapRouter: NOT_ENTER_ETH_VALUE'); }\r\n                _safeTransferFrom(money, msg.sender, pair, _moneyAmount);\r\n            } else {\r\n                if (stock != address(0)) { require(msg.value == 0, 'GraSwapRouter: NOT_ENTER_ETH_VALUE'); }\r\n                _safeTransferFrom(stock, msg.sender, pair, _stockAmount);\r\n            }\r\n        }\r\n        IGraSwapPair(pair).addLimitOrder(isBuy, msg.sender, uint64(stockAmount), uint32(price), id, uint72(prevKey));\r\n    }\r\n\r\n    // todo. add encoded bytes interface for limitOrder.\r\n\r\n    function _safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        if (token == address(0)) {\r\n            _safeTransferETH(to, value);\r\n            uint inputValue = msg.value;\r\n            if (inputValue > value) { _safeTransferETH(msg.sender, inputValue - value); }\r\n            return;\r\n        }\r\n\r\n        uint beforeAmount = IERC20(token).balanceOf(to);\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"GraSwapRouter: TRANSFER_FROM_FAILED\");\r\n        uint afterAmount = IERC20(token).balanceOf(to);\r\n        require(afterAmount == beforeAmount + value, \"GraSwapRouter: TRANSFER_FAILED\");\r\n    }\r\n\r\n    function _safeTransferETH(address to, uint value) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function _quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, \"GraSwapRouter: INSUFFICIENT_AMOUNT\");\r\n        require(reserveA > 0 && reserveB > 0, \"GraSwapRouter: INSUFFICIENT_LIQUIDITY\");\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function _getTokensFromPair(address pair) internal view returns(address stock, address money) {\r\n        (stock, money) = IGraSwapFactory(factory).getTokensFromPair(pair);\r\n        require(stock != address(0) || money != address(0), \"GraSwapRouter: PAIR_NOT_EXIST\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stockAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moneyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stock\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"money\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOnlySwap\",\"type\":\"bool\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"money\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isOnlySwap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountStockDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMoneyDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountStockMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMoneyMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountStock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMoney\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"stockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"limitOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountStockMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMoneyMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountStock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMoney\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapToken\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"GraSwapRouter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b74e5c4137afd6a7dbd9d43c9d7af2a258e57a7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2f120497554018922cce9d226742773d8a494e25b798161365ce69dd19ef4911"}]}