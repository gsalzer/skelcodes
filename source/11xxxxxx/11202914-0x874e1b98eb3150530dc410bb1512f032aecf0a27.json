{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n// ----------------------------------------------------------------------------\r\n// yBXTB Service contract\r\n// ----------------------------------------------------------------------------\r\npragma solidity ^0.7.4;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function addSafe(uint _a, uint _b) internal pure returns (uint c) {\r\n        c = _a + _b;\r\n        require(c >= _a);\r\n    }\r\n    function subSafe(uint _a, uint _b) internal pure returns (uint c) {\r\n        require(_b <= _a, \"Insufficient balance\");\r\n        c = _a - _b;\r\n    }\r\n    function mulSafe(uint _a, uint _b) internal pure returns (uint c) {\r\n        c = _a * _b;\r\n        require(_a == 0 || c / _a == _b);\r\n    }\r\n    function divSafe(uint _a, uint _b) internal pure returns (uint c) {\r\n        require(_b > 0);\r\n        c = _a / _b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\n// For BXTB Interface\r\ninterface ERC20Interface {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _tokenOwner) external view returns (uint);\r\n    function allowance(address _tokenOwner, address _spender) external view returns (uint);\r\n    function transfer(address _to, uint _amount) external returns (bool);\r\n    function approve(address _spender, uint _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint _amount) external returns (bool);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n// ----------------------------------------------------------------------------\r\ninterface ApproveAndCallFallBack {\r\n    function receiveApproval(address _tokenOwner, uint256 _amount, address _tokenContract, bytes memory _data) external;\r\n}\r\n\r\ninterface SettlementInterface {\r\n    function disburseCommissions(bool _disburseBackstop) external;\r\n}\r\n\r\n\r\n// For USDT Interface\r\n// Changed 'constant' to 'view' for compiler 0.5.4\r\ninterface ERC20_USDT {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address who) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function transfer(address to, uint value) external;\r\n    function approve(address spender, uint value) external;\r\n    function transferFrom(address from, address to, uint value) external;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// yBXTB Service Contract\r\n// ----------------------------------------------------------------------------\r\ncontract YieldTokenService is ApproveAndCallFallBack, SettlementInterface, Owned {\r\n    using SafeMath for uint;\r\n\r\n    address public constant USDTContract = 0xdAC17F958D2ee523a2206206994597C13D831ec7;      // USDT contract\r\n    address public constant BXTBContract = 0x7bA9caa5D19002618F1D93e691490377361D5E60;      // BXTB contract\r\n    address public constant yieldTokenContract = 0x39dCCA7984B22cCB0347DeEAeEaaEE6e6Ce9ba9F;     // yBXTB contract\r\n    address public constant CHIPContract = 0x73F737dE96cF8987CA2C4C1FDC5134688BB2e10f;      // CHIP contract\r\n\r\n    address public bxtbFoundation = 0x616143B2e9ADC2F48c9Ad4C30162e0782297f06f;\r\n    address public recoveryAdmin;\r\n    address public settlementAdmin;\r\n    address public backstopAdmin;\r\n\r\n    uint public totalPoolUSDTCollateral;\r\n    uint public totalPoolBXTB;\r\n\r\n    uint public totalPoolCHIPBackStop;\r\n    uint public totalPoolCHIPBackStopAvailable;\r\n\r\n    uint public totalPoolCHIPCommissions;\r\n    uint public totalPoolCHIPCommissionsAvailable;\r\n\r\n    uint public totalSupplyYieldToken;\r\n    uint public outstandingYieldToken;\r\n\r\n    uint public totalSupplyCHIP;\r\n    uint public outstandingCHIP;\r\n\r\n    uint public constant decimals = 6;\r\n    uint public collateralizationRatio;\r\n\r\n    uint public bxtbTokenRatio;\r\n\r\n    bool public allowStaking;\r\n    bool public allowCommissions;\r\n\r\n    constructor() {\r\n        bxtbTokenRatio = 100;           // 100%\r\n        collateralizationRatio = 100;   // 100%\r\n\r\n        allowStaking = true;\r\n        allowCommissions = false;\r\n    }\r\n\r\n    event TotalSupplyYieldTokenChanged(uint _amount);                   // Load YieldToken supply\r\n    event TotalSupplyCHIPChanged(uint _amount);                         // Load CHIP supply\r\n    event OutstandingSupplyChanged();                                   // Change in YieldToken & CHIP in circulation\r\n    event ChangeBxtbTokenRatio(uint _amount);                           // Token ratio changed\r\n    event CommissionReceived(address indexed _sender, uint _amount);    // Commissions received\r\n    event CommissionsDisbursed(uint _amount);\r\n    event BackstopDisbursed(uint _amount);\r\n    event BackstopAdjusted(bool _refunded, uint _amount);\r\n\r\n\r\n    function receiveApproval(address _tokenOwner, uint256 _amount, address _tokenContract, bytes memory _data) public override {\r\n        // Prevent ERC20 short address attack\r\n        // _data length is not fixed\r\n        require((msg.data.length == (6 * 32) + 4) && (_data.length == 1), \"Input length error\");\r\n\r\n        require(msg.sender == yieldTokenContract ||\r\n        msg.sender == CHIPContract ||\r\n        msg.sender == BXTBContract, \"Unknown caller\");\r\n\r\n        // Mode 0x10: Normal deposit\r\n        // Mode 0xF0: Load reserve tokens\r\n        uint8 mode = uint8(_data[0]);\r\n        require(mode == 0x10 || mode == 0xE0 || mode == 0xF0, \"Mode not accepted\");\r\n\r\n        if(mode == 0x10) {\r\n            // Normal deposits for Stake and Redeem\r\n            // Sanity check\r\n            require(totalSupplyYieldToken == totalSupplyCHIP, \"Supply imbalance\");\r\n            uint wildChip;\r\n\r\n            // Credit to caller\r\n            if(msg.sender == BXTBContract) {\r\n                // Stake\r\n                // Staking paused by admin\r\n                require(allowStaking == true, \"Staking is paused\");\r\n\r\n                // Get allowance\r\n                uint allowanceUsdt = ERC20_USDT(USDTContract).allowance(_tokenOwner, address(this));\r\n                uint allowanceBxtb = _amount;\r\n\r\n                // Enforce token staking ratio\r\n                if(bxtbTokenRatio == 100) {  // 100 percent\r\n                    // Get minimum common size. Size must be the same\r\n                    if(allowanceUsdt <= allowanceBxtb) allowanceBxtb = allowanceUsdt;\r\n                    else allowanceUsdt = allowanceBxtb;\r\n                }\r\n                else {\r\n                    if(bxtbTokenRatio > 0) {\r\n                        uint allowanceBxtbExpected = allowanceUsdt.mulSafe(bxtbTokenRatio).divSafe(100);\r\n                        if(allowanceBxtb >= allowanceBxtbExpected) allowanceBxtb = allowanceBxtbExpected;  // Sufficient BXTB\r\n                        else allowanceUsdt = allowanceBxtb.mulSafe(100).divSafe(bxtbTokenRatio);  // Reduce USDT due to insufficient BXTB\r\n                    }\r\n                    else allowanceBxtb = 0;  // Prevent divide-by-zero errors\r\n                }\r\n\r\n                // Issue YieldToken 'n' CHIP\r\n                require(allowanceUsdt > 0, \"Zero stake\");\r\n\r\n                // How many YieldToken are in reserve?\r\n                uint remainderYieldToken = totalSupplyYieldToken.subSafe(outstandingYieldToken);\r\n                // If not enough YieldToken. Reject transaction\r\n                require((allowanceUsdt <= remainderYieldToken) && (remainderYieldToken > 0), \"Staking size exceeded\");\r\n\r\n                // Accept USDT\r\n                ERC20_USDT(USDTContract).transferFrom(_tokenOwner, address(this), allowanceUsdt);\r\n\r\n                // For every USDT stake, issue 1 CHIP and 1 YieldToken\r\n                // Update pool counter\r\n                totalPoolUSDTCollateral = totalPoolUSDTCollateral.addSafe(allowanceUsdt);\r\n\r\n                // Send out event for change in outstanding supply\r\n                emit OutstandingSupplyChanged();\r\n\r\n                // Accept BXTB\r\n                if(allowanceBxtb > 0) {\r\n                    ERC20Interface(BXTBContract).transferFrom(_tokenOwner, address(this), allowanceBxtb);\r\n                    totalPoolBXTB = totalPoolBXTB.addSafe(allowanceBxtb);\r\n                }\r\n\r\n                // Issue YieldToken and CHIP, and update outstanding tokens\r\n                // outstandingYieldToken and outstandingCHIP must be synchronized at all cost!\r\n                outstandingYieldToken = outstandingYieldToken.addSafe(allowanceUsdt);\r\n                outstandingCHIP = outstandingCHIP.addSafe(allowanceUsdt);\r\n\r\n                ERC20Interface(yieldTokenContract).transfer(_tokenOwner, allowanceUsdt);\r\n                ERC20Interface(CHIPContract).transfer(_tokenOwner, allowanceUsdt);\r\n\r\n                // Calculate collat ratio\r\n                wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\r\n                if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\r\n                else collateralizationRatio = 100;\r\n            }\r\n            else if(msg.sender == CHIPContract) {\r\n                // Redeem\r\n                // Get allowance\r\n                uint allowanceYieldToken = ERC20Interface(yieldTokenContract).allowance(_tokenOwner, address(this));\r\n                uint allowanceCHIP = _amount;\r\n\r\n                uint allowanceSize;\r\n                // Get minimum common size. Size must be the same\r\n                if(allowanceYieldToken <= allowanceCHIP) allowanceSize = allowanceYieldToken;\r\n                else allowanceSize = allowanceCHIP;\r\n\r\n                // Redeem YieldToken and CHIP tokens\r\n                require(allowanceSize > 0, \"Zero redeem\");\r\n\r\n                // Can't redeem more than outstanding CHIP\r\n                require((allowanceSize <= outstandingCHIP) && (outstandingCHIP > 0), \"Redemption size exceeded\");\r\n\r\n                // Accept YieldToken and CHIP\r\n                ERC20Interface(yieldTokenContract).transferFrom(_tokenOwner, address(this), allowanceSize);\r\n                ERC20Interface(CHIPContract).transferFrom(_tokenOwner, address(this), allowanceSize);\r\n\r\n                // Take YieldToken and CHIP out of circulation\r\n                // outstandingYieldToken and outstandingCHIP must be synchronized at all cost\r\n                outstandingYieldToken = outstandingYieldToken.subSafe(allowanceSize);\r\n                outstandingCHIP = outstandingCHIP.subSafe(allowanceSize);\r\n\r\n                // Emit event for change in outstanding supply\r\n                emit OutstandingSupplyChanged();\r\n\r\n                // Pay out equivalent amount of USDT, and send BXTB to Foundation\r\n                uint shareOfBxtb;\r\n\r\n                if(outstandingCHIP > 0) {\r\n                    // Update pool counters\r\n                    totalPoolUSDTCollateral = totalPoolUSDTCollateral.subSafe(allowanceSize);\r\n                    // Send back collateral\r\n                    ERC20_USDT(USDTContract).transfer(_tokenOwner, allowanceSize);\r\n\r\n                    // Enforce token redemption ratio\r\n                    if(bxtbTokenRatio == 100) shareOfBxtb = allowanceSize;  // 100 percent\r\n                    else shareOfBxtb = allowanceSize.mulSafe(bxtbTokenRatio).divSafe(100);\r\n\r\n                    // Can't take out more BXTB than exists\r\n                    if(shareOfBxtb > totalPoolBXTB) shareOfBxtb = totalPoolBXTB;\r\n\r\n                    // Update counters\r\n                    totalPoolBXTB = totalPoolBXTB.subSafe(shareOfBxtb);\r\n                    // Send BXTB to foundation\r\n                    ERC20Interface(BXTBContract).transfer(bxtbFoundation, shareOfBxtb);\r\n\r\n                    // Calculate collat ratio\r\n                    wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\r\n                    if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\r\n                    else collateralizationRatio = 100;\r\n                }\r\n                else {\r\n                    // Last redeemer: Disburse everything\r\n                    // In case contract accumulates more than expected, this clears out the account\r\n                    // Hard resets USDT counter. No more outstanding CHIP and YieldTokens\r\n                    outstandingCHIP = 0;\r\n                    outstandingYieldToken = 0;\r\n\r\n                    // Pay out USDT\r\n                    totalPoolUSDTCollateral = 0;\r\n                    uint residualValue = ERC20_USDT(USDTContract).balanceOf(address(this));\r\n                    ERC20_USDT(USDTContract).transfer(_tokenOwner, residualValue);\r\n\r\n                    // Hard reset BXTB counters\r\n                    totalPoolBXTB = 0;\r\n                    // Send BXTB to foundation\r\n                    shareOfBxtb = ERC20Interface(BXTBContract).balanceOf(address(this));\r\n                    ERC20Interface(BXTBContract).transfer(bxtbFoundation, shareOfBxtb);\r\n\r\n                    // Calculate collat ratio\r\n                    collateralizationRatio = 100;\r\n                }\r\n            }\r\n            else revert(\"Unknown stake/redeem token\");\r\n        }\r\n        else if(mode == 0xE0) {\r\n            // Pay commissions\r\n            require(msg.sender == CHIPContract, \"Only CHIP accepted\");\r\n            payCommission(_tokenOwner);\r\n        }\r\n        else if(mode == 0xF0) {\r\n            // Load reserve tokens\r\n            // Only contract owner can load it\r\n            require((_tokenOwner == owner) && (owner != address(0)), \"Caller must be owner\");\r\n            // Check allowance\r\n            require(_amount > 0, \"Zero deposit\");\r\n\r\n            // YieldToken and CHIP reserve must be equal prior to staking commencement\r\n            if(msg.sender == yieldTokenContract) {\r\n                // Retrieve tokens\r\n                ERC20Interface(yieldTokenContract).transferFrom(_tokenOwner, address(this), _amount);\r\n                // Update total supply\r\n                totalSupplyYieldToken = totalSupplyYieldToken.addSafe(_amount);\r\n                // Emit event\r\n                emit TotalSupplyYieldTokenChanged(totalSupplyYieldToken);\r\n            }\r\n            else if(msg.sender == CHIPContract) {\r\n                // Retrieve tokens\r\n                ERC20Interface(CHIPContract).transferFrom(_tokenOwner, address(this), _amount);\r\n                // Update total supply\r\n                totalSupplyCHIP = totalSupplyCHIP.addSafe(_amount);\r\n                // Emit event\r\n                emit TotalSupplyCHIPChanged(totalSupplyCHIP);\r\n            }\r\n            else revert(\"Unknown reserve token\");\r\n        }\r\n    }\r\n\r\n    // Pay commission\r\n    function payCommission(address _sender) internal {\r\n        require(allowCommissions == true, \"Commissions paused\");\r\n\r\n        uint allowanceCHIP = ERC20Interface(CHIPContract).allowance(_sender, address(this));\r\n        require(allowanceCHIP > 0, \"Zero commission\");\r\n\r\n        if(outstandingYieldToken > 0) {\r\n            // Distribute commission to unit holders\r\n            // Accept the deposit\r\n            ERC20Interface(CHIPContract).transferFrom(_sender, address(this), allowanceCHIP);\r\n            // Send to comission pools\r\n            distributeToPools(allowanceCHIP);\r\n            // Log event\r\n            emit CommissionReceived(_sender, allowanceCHIP);\r\n        }\r\n        else {\r\n            // This code should be unreachable\r\n            // No more unit holders\r\n            address recipient;\r\n            if(owner != address(0)) recipient = owner;  // Send to contract owner\r\n            else if(settlementAdmin != address(0)) recipient = settlementAdmin;  // If no contract owner, send to Settlement Admin\r\n            else if(bxtbFoundation != address(0)) recipient = bxtbFoundation;  // If no contract owner, send to BXTB Foundation\r\n            else revert(\"No recipients\");  // No foundation, decline commission\r\n\r\n            // Accept the deposit\r\n            ERC20Interface(CHIPContract).transferFrom(_sender, recipient, allowanceCHIP);\r\n            // Log event\r\n            emit CommissionReceived(_sender, allowanceCHIP);\r\n        }\r\n    }\r\n\r\n    function distributeToPools(uint _amount) internal {\r\n        require(outstandingYieldToken > 0, \"No more unit holders\");\r\n\r\n        uint backstopShortfall;\r\n        uint backstopTarget = totalPoolUSDTCollateral.divSafe(10);  // Target backstop to be 10% of collateral\r\n\r\n        // Over collateralize coin up to 10% (100% collateral + 10% backstop)\r\n        if(totalPoolCHIPBackStop < backstopTarget) backstopShortfall = backstopTarget.subSafe(totalPoolCHIPBackStop);\r\n\r\n        // Share commission between internal totalPools\r\n        if(backstopShortfall > 0) {\r\n            // Send portion to backstop pool\r\n            uint allocateBackstop = _amount.divSafe(6);  // 1/6th goes to backstop pool\r\n\r\n            if(allocateBackstop > backstopShortfall) allocateBackstop = backstopShortfall;  // Limit reached\r\n\r\n            uint allocateCommission = _amount.subSafe(allocateBackstop);\r\n\r\n            // Send to pools\r\n            totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(allocateBackstop);                    // Cumulative amount deposited\r\n            totalPoolCHIPBackStopAvailable = totalPoolCHIPBackStopAvailable.addSafe(allocateBackstop);  // Current balance in contract\r\n\r\n            totalPoolCHIPCommissions = totalPoolCHIPCommissions.addSafe(allocateCommission);                    // Cumulative amount deposited\r\n            totalPoolCHIPCommissionsAvailable = totalPoolCHIPCommissionsAvailable.addSafe(allocateCommission);  // Current balance in contract\r\n        }\r\n        else {\r\n            // Send all to commissions pool\r\n            totalPoolCHIPCommissions = totalPoolCHIPCommissions.addSafe(_amount);                       // Cumulative amount deposited\r\n            totalPoolCHIPCommissionsAvailable = totalPoolCHIPCommissionsAvailable.addSafe(_amount);     // Current balance in contract\r\n        }\r\n\r\n        // Calculate collat ratio\r\n        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\r\n        if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\r\n        else collateralizationRatio = 100;\r\n    }\r\n\r\n    // Perform settlement\r\n    function disburseCommissions(bool _disburseBackstop) external override {\r\n        require((msg.sender == yieldTokenContract) ||\r\n        (msg.sender == settlementAdmin) ||\r\n            (msg.sender == owner) , \"Caller not authorized\");\r\n\r\n        require(settlementAdmin != address(0), \"Settlement Admin address error\");\r\n\r\n        // How much funds to disburse?\r\n        uint withdrawAmount = totalPoolCHIPCommissionsAvailable;\r\n        totalPoolCHIPCommissionsAvailable = 0;\r\n        // Pay out to settlementAdmin account\r\n        ERC20Interface(CHIPContract).transfer(settlementAdmin, withdrawAmount);\r\n        emit CommissionsDisbursed(withdrawAmount);\r\n\r\n        // Send out the backstop balance too\r\n        if(_disburseBackstop == true) {\r\n            require(backstopAdmin != address(0), \"Backstop Admin address error\");\r\n\r\n            // How much to pay out?\r\n            withdrawAmount = totalPoolCHIPBackStopAvailable;\r\n            totalPoolCHIPBackStopAvailable = 0;\r\n            // Disburse backstop CHIPs to backstop Admin\r\n            ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);\r\n            emit BackstopDisbursed(withdrawAmount);\r\n        }\r\n    }\r\n\r\n    // Send out backstop balance\r\n    function disburseBackstop() external {\r\n        require((msg.sender == backstopAdmin) || (msg.sender == owner), \"Caller not authorized\");\r\n        require(backstopAdmin != address(0), \"Backstop Admin address error\");\r\n\r\n        // How much to pay out?\r\n        uint withdrawAmount = totalPoolCHIPBackStopAvailable;\r\n        totalPoolCHIPBackStopAvailable = 0;\r\n        // Disburse backstop CHIPs to backstop Admin\r\n        ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);\r\n        emit BackstopDisbursed(withdrawAmount);\r\n    }\r\n\r\n    // Update collat ratio after refunding backstop to CHIP or yBXTB holders\r\n    function adjustBackstop(bool _refunded, uint _amount) external {\r\n        require((msg.sender == backstopAdmin) || (msg.sender == owner), \"Caller not authorized\");\r\n\r\n        if(_refunded == true) totalPoolCHIPBackStop = totalPoolCHIPBackStop.subSafe(_amount);  // Back out refunded amount\r\n        else totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(_amount);  // Add more. This is used to fix user errors\r\n\r\n        // Recalculate collateralization ratio\r\n        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\r\n        if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\r\n        else collateralizationRatio = 100;\r\n\r\n        emit BackstopAdjusted(_refunded, _amount);\r\n    }\r\n\r\n    // Change Recovery Admin for lost coins\r\n    function changeRecoveryAdmin(address _newAddress) external {\r\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\r\n        require((msg.sender == recoveryAdmin) || (msg.sender == owner), \"Caller not authorized\");\r\n        recoveryAdmin = _newAddress;\r\n    }\r\n\r\n    // Change Settlement Admin for daily settlements\r\n    function changeSettlementAdmin(address _newAddress) external {\r\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\r\n        require((msg.sender == settlementAdmin) || (msg.sender == owner), \"Caller not authorized\");\r\n        settlementAdmin = _newAddress;\r\n    }\r\n\r\n    // Change Backstop Admin for managing backstop balance\r\n    function changeBackstopAdmin(address _newAddress) external {\r\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\r\n        require((msg.sender == backstopAdmin) || (msg.sender == owner), \"Caller not authorized\");\r\n        backstopAdmin = _newAddress;\r\n    }\r\n\r\n    // Change BXBT Foundation Address\r\n    function changeBxtbFoundation(address _newAddress) external {\r\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\r\n        require(msg.sender == bxtbFoundation, \"Caller not authorized\");\r\n        bxtbFoundation = _newAddress;\r\n    }\r\n\r\n    // Change BXTB-to-USDT ratio for staking, and BXTB-to-YieldToken ratio redemption\r\n    function changebxtbTokenRatio(uint _newRatio) external {\r\n        require(msg.sender == bxtbFoundation, \"Caller not authorized\");\r\n        bxtbTokenRatio = _newRatio;\r\n        emit ChangeBxtbTokenRatio(_newRatio);\r\n    }\r\n\r\n    function setAllowStaking(bool _allow) external onlyOwner {\r\n        allowStaking = _allow;\r\n    }\r\n\r\n    function setAllowCommissions(bool _allow) external onlyOwner {\r\n        allowCommissions = _allow;\r\n    }\r\n\r\n    // Retrieve lost coins (USDT, BXTB, YieldToken, CHIP)\r\n    // If coins are accidentally sent to the contract, calling this function will recover them\r\n    function recoverLostCoins(uint _amount, address _fromTokenContract, address _recoveryAddress) external {\r\n        require(msg.data.length == (3 * 32) + 4, \"Input length error\");\r\n\r\n        bool hasAdmin;\r\n        if(recoveryAdmin != address(0)) {\r\n            if(msg.sender == recoveryAdmin) {\r\n                hasAdmin = true;\r\n            }\r\n            else if(_fromTokenContract == BXTBContract) {\r\n                // But also let foundation call for BXTB\r\n                if(bxtbFoundation != address(0)) {\r\n                    if(msg.sender != bxtbFoundation) revert(\"Caller must be admin\");\r\n                }\r\n                else revert(\"Caller must be admin\");\r\n            }\r\n            else revert(\"Caller must be admin\");\r\n        }\r\n\r\n        if(_fromTokenContract == USDTContract) recoverLostUSDT(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\r\n        else if(_fromTokenContract == BXTBContract) recoverLostBXTB(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\r\n        else recoverLostERC20(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\r\n    }\r\n\r\n    function recoverLostUSDT(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\r\n        uint amountAdmin;\r\n        uint amountOwner;\r\n        uint amountRecoveryAddress;\r\n        uint amountSender;\r\n\r\n        uint sweepAmount;\r\n        uint recoverAmount;\r\n\r\n        // How much is lost in this contract?\r\n        sweepAmount = ERC20_USDT(_fromTokenContract).balanceOf(address(this));\r\n        if(sweepAmount > totalPoolUSDTCollateral) {\r\n            sweepAmount = sweepAmount.subSafe(totalPoolUSDTCollateral);\r\n\r\n            // Retrieve amount\r\n            if(_amount <= sweepAmount) {\r\n                recoverAmount = _amount.mulSafe(3).divSafe(4);\r\n                sweepAmount = sweepAmount.subSafe(recoverAmount);\r\n            }\r\n\r\n            if(_hasAdmin) {\r\n                // Send 1/4 + swept up amounts to admin\r\n                amountAdmin = sweepAmount;\r\n\r\n                // Send 3/4 to recovery address or admin\r\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\r\n                else amountAdmin = amountAdmin.addSafe(recoverAmount);\r\n            }\r\n            else {\r\n                // Send 1/4 fees + swept up amounts to: Owner\r\n                amountOwner = sweepAmount;\r\n\r\n                // Send 3/4 balance to: Recovery address, Sender\r\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\r\n                else amountSender = recoverAmount;\r\n            }\r\n\r\n            if(amountAdmin > 0) ERC20_USDT(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\r\n            if(amountOwner > 0) ERC20_USDT(_fromTokenContract).transfer(owner, amountOwner);\r\n            if(amountRecoveryAddress > 0) ERC20_USDT(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\r\n            if(amountSender > 0) ERC20_USDT(_fromTokenContract).transfer(_sender, amountSender);\r\n        }\r\n    }\r\n\r\n    function recoverLostBXTB(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\r\n        uint amountAdmin;\r\n        uint amountFoundation;\r\n        uint amountRecoveryAddress;\r\n        uint amountSender;\r\n\r\n        uint sweepAmount;\r\n        uint recoverAmount;\r\n\r\n        // How much is lost in this contract?\r\n        sweepAmount = ERC20Interface(_fromTokenContract).balanceOf(address(this));\r\n        if(sweepAmount > totalPoolBXTB) {\r\n            sweepAmount = sweepAmount.subSafe(totalPoolBXTB);\r\n\r\n            // Retrieve amount\r\n            if(_amount <= sweepAmount) {\r\n                recoverAmount = _amount.mulSafe(3).divSafe(4);\r\n                sweepAmount = sweepAmount.subSafe(recoverAmount);\r\n            }\r\n\r\n            if(_hasAdmin) {\r\n                // Send 1/4 fees + swept up amounts to: BXTB foundation, Admin\r\n                if(bxtbFoundation != address(0)) amountFoundation = sweepAmount;\r\n                else amountAdmin = sweepAmount;\r\n                // Send 3/4 balance to: Recovery address, Admin\r\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\r\n                else amountAdmin = amountAdmin.addSafe(recoverAmount);\r\n            }\r\n            else {\r\n                // Send 1/4 fees + swept up amounts to: BXTB foundation, Recovery address, Sender\r\n                if(bxtbFoundation != address(0)) amountFoundation = sweepAmount;\r\n                else if(_recoveryAddress != address(0)) amountRecoveryAddress = sweepAmount;\r\n                else amountSender = sweepAmount;\r\n\r\n                // Send 3/4 balance to: Recovery address, Sender\r\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = amountRecoveryAddress.addSafe(recoverAmount);\r\n                else amountSender = amountSender.addSafe(recoverAmount);\r\n            }\r\n\r\n            if(amountAdmin > 0) ERC20Interface(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\r\n            if(amountFoundation > 0) ERC20Interface(_fromTokenContract).transfer(bxtbFoundation, amountFoundation);\r\n            if(amountRecoveryAddress > 0) ERC20Interface(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\r\n            if(amountSender > 0) ERC20Interface(_fromTokenContract).transfer(_sender, amountSender);\r\n        }\r\n    }\r\n\r\n    function recoverLostERC20(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\r\n        uint amountAdmin;\r\n        uint amountOwner;\r\n        uint amountRecoveryAddress;\r\n        uint amountSender;\r\n\r\n        uint sweepAmount;\r\n        uint recoverAmount;\r\n        uint poolSize;\r\n\r\n        // How much is lost in this contract?\r\n        sweepAmount = ERC20Interface(_fromTokenContract).balanceOf(address(this));\r\n\r\n        if(_fromTokenContract == yieldTokenContract) poolSize = outstandingYieldToken;\r\n        else if(_fromTokenContract == CHIPContract) poolSize = outstandingCHIP;\r\n        else poolSize = 0;\r\n\r\n        if(sweepAmount > poolSize) {\r\n            sweepAmount = sweepAmount.subSafe(poolSize);\r\n\r\n            // Retrieve amount\r\n            if(_amount <= sweepAmount) {\r\n                recoverAmount = _amount.mulSafe(3).divSafe(4);\r\n                sweepAmount = sweepAmount.subSafe(recoverAmount);\r\n            }\r\n\r\n            if(_hasAdmin) {\r\n                // Send 1/4 fees + swept up amounts to: Admin\r\n                amountAdmin = sweepAmount;\r\n\r\n                // Send 3/4 balance to: Recovery address, Admin\r\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\r\n                else amountAdmin = amountAdmin.addSafe(recoverAmount);\r\n            }\r\n            else {\r\n                // Send 1/4 fees + swept up amounts to: Owner\r\n                amountOwner = sweepAmount;\r\n\r\n                // Send 3/4 balance to: Recovery address, Sender\r\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\r\n                else amountSender = recoverAmount;\r\n            }\r\n\r\n            if(amountAdmin > 0) ERC20Interface(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\r\n            if(amountOwner > 0) ERC20Interface(_fromTokenContract).transfer(owner, amountOwner);\r\n            if(amountRecoveryAddress > 0) ERC20Interface(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\r\n            if(amountSender > 0) ERC20Interface(_fromTokenContract).transfer(_sender, amountSender);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_refunded\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BackstopAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BackstopDisbursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ChangeBxtbTokenRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CommissionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CommissionsDisbursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OutstandingSupplyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TotalSupplyCHIPChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TotalSupplyYieldTokenChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BXTBContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHIPContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_refunded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"adjustBackstop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowCommissions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backstopAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bxtbFoundation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bxtbTokenRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeBackstopAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeBxtbFoundation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeRecoveryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeSettlementAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRatio\",\"type\":\"uint256\"}],\"name\":\"changebxtbTokenRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disburseBackstop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_disburseBackstop\",\"type\":\"bool\"}],\"name\":\"disburseCommissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outstandingCHIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outstandingYieldToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fromTokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recoveryAddress\",\"type\":\"address\"}],\"name\":\"recoverLostCoins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setAllowCommissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setAllowStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolBXTB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolCHIPBackStop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolCHIPBackStopAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolCHIPCommissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolCHIPCommissionsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolUSDTCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyCHIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyYieldToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"YieldTokenService","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4450a54379e6743581d55a6f62fc86bf731ffd4006e9be508cba7d2732e5309a"}]}