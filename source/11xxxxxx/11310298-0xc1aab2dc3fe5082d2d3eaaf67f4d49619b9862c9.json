{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/erc1820/ERC1820Client.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @dev Taken from node_modules/erc1820\\n * updated solidity version\\n * commented out interfaceAddr & delegateManagement\\n */\\ninterface ERC1820Registry {\\n\\tfunction setInterfaceImplementer(\\n\\t\\taddress _addr,\\n\\t\\tbytes32 _interfaceHash,\\n\\t\\taddress _implementer\\n\\t) external;\\n\\n\\tfunction getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address);\\n\\n\\tfunction setManager(address _addr, address _newManager) external;\\n\\n\\tfunction getManager(address _addr) external view returns (address);\\n}\\n\\n\\n/// Base client to interact with the registry.\\ncontract ERC1820Client {\\n\\tERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\\n\\t\\t0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\\n\\t);\\n\\n\\tfunction setInterfaceImplementation(\\n\\t\\tstring memory _interfaceLabel,\\n\\t\\taddress _implementation\\n\\t) internal {\\n\\t\\tbytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\\n\\t\\tERC1820REGISTRY.setInterfaceImplementer(\\n\\t\\t\\taddress(this),\\n\\t\\t\\tinterfaceHash,\\n\\t\\t\\t_implementation\\n\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/gsn/GSNRecipient.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/GSN/IRelayRecipient.sol\\\";\\nimport \\\"../../node_modules/@openzeppelin/contracts/GSN/IRelayHub.sol\\\";\\nimport \\\"../../node_modules/@openzeppelin/contracts/GSN/Context.sol\\\";\\n\\nimport \\\"../storage/SecurityTokenStorage.sol\\\";\\n\\n\\n// copied here to be included in coverage\\n\\n/**\\n * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface\\n * and enables GSN support on all contracts in the inheritance tree.\\n *\\n * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},\\n *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be\\n * provided by derived contracts. See the\\n * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more\\n * information on how to use the pre-built {GSNRecipientSignature} and\\n * {GSNRecipientERC20Fee}, or how to write your own.\\n */\\nabstract contract GSNRecipient is\\n\\tSecurityTokenStorage,\\n\\tIRelayRecipient,\\n\\tContext\\n{\\n\\t/**\\n\\t * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.\\n\\t */\\n\\tevent RelayHubChanged(\\n\\t\\taddress indexed oldRelayHub,\\n\\t\\taddress indexed newRelayHub\\n\\t);\\n\\n\\t/**\\n\\t * @dev Returns the address of the {IRelayHub} contract for this recipient.\\n\\t */\\n\\tfunction getHubAddr() public override view returns (address) {\\n\\t\\treturn _relayHub;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not\\n\\t * use the default instance.\\n\\t *\\n\\t * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old\\n\\t * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.\\n\\t */\\n\\tfunction _upgradeRelayHub(address newRelayHub) internal virtual {\\n\\t\\taddress currentRelayHub = _relayHub;\\n\\t\\trequire(newRelayHub != address(0), \\\"zero address\\\");\\n\\t\\trequire(newRelayHub != currentRelayHub, \\\"current one\\\");\\n\\n\\t\\temit RelayHubChanged(currentRelayHub, newRelayHub);\\n\\n\\t\\t_relayHub = newRelayHub;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If\\n\\t * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.\\n\\t */\\n\\t// This function is view for future-proofing, it may require reading from\\n\\t// storage in the future.\\n\\tfunction relayHubVersion() public view returns (string memory) {\\n\\t\\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n\\t\\treturn \\\"1.0.0\\\";\\n\\t}\\n\\n\\t/**\\n\\t * @dev Withdraws the recipient's deposits in `RelayHub`.\\n\\t *\\n\\t * Derived contracts should expose this in an external interface with proper access control.\\n\\t */\\n\\tfunction _withdrawDeposits(uint256 amount, address payable payee)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t{\\n\\t\\tIRelayHub(_relayHub).withdraw(amount, payee);\\n\\t}\\n\\n\\t// Overrides for Context's functions: when called from RelayHub, sender and\\n\\t// data require some pre-processing: the actual sender is stored at the end\\n\\t// of the call data, which in turns means it needs to be removed from it\\n\\t// when handling said data.\\n\\n\\t/**\\n\\t * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\\n\\t * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).\\n\\t *\\n\\t * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.\\n\\t */\\n\\tfunction _msgSender()\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (address payable)\\n\\t{\\n\\t\\tif (msg.sender != _relayHub) {\\n\\t\\t\\treturn msg.sender;\\n\\t\\t} else {\\n\\t\\t\\treturn _getRelayedCallSender();\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,\\n\\t * and a reduced version for GSN relayed calls (where msg.data contains additional information).\\n\\t *\\n\\t * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.\\n\\t */\\n\\tfunction _msgData() internal virtual override view returns (bytes memory) {\\n\\t\\tif (msg.sender != _relayHub) {\\n\\t\\t\\treturn msg.data;\\n\\t\\t} else {\\n\\t\\t\\treturn _getRelayedCallData();\\n\\t\\t}\\n\\t}\\n\\n\\t// Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the\\n\\t// internal hook.\\n\\n\\t/**\\n\\t * @dev See `IRelayRecipient.preRelayedCall`.\\n\\t *\\n\\t * This function should not be overriden directly, use `_preRelayedCall` instead.\\n\\t *\\n\\t * * Requirements:\\n\\t *\\n\\t * - the caller must be the `RelayHub` contract.\\n\\t */\\n\\tfunction preRelayedCall(bytes memory context)\\n\\t\\tpublic\\n\\t\\tvirtual\\n\\t\\toverride\\n\\t\\treturns (bytes32)\\n\\t{\\n\\t\\trequire(msg.sender == getHubAddr(), \\\"not hub\\\");\\n\\t\\treturn _preRelayedCall(context);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See `IRelayRecipient.preRelayedCall`.\\n\\t *\\n\\t * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\\n\\t * must implement this function with any relayed-call preprocessing they may wish to do.\\n\\t *\\n\\t */\\n\\tfunction _preRelayedCall(bytes memory context)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\treturns (bytes32);\\n\\n\\t/**\\n\\t * @dev See `IRelayRecipient.postRelayedCall`.\\n\\t *\\n\\t * This function should not be overriden directly, use `_postRelayedCall` instead.\\n\\t *\\n\\t * * Requirements:\\n\\t *\\n\\t * - the caller must be the `RelayHub` contract.\\n\\t */\\n\\tfunction postRelayedCall(\\n\\t\\tbytes memory context,\\n\\t\\tbool success,\\n\\t\\tuint256 actualCharge,\\n\\t\\tbytes32 preRetVal\\n\\t) public virtual override {\\n\\t\\trequire(msg.sender == getHubAddr(), \\\"not hub\\\");\\n\\t\\t_postRelayedCall(context, success, actualCharge, preRetVal);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See `IRelayRecipient.postRelayedCall`.\\n\\t *\\n\\t * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\\n\\t * must implement this function with any relayed-call postprocessing they may wish to do.\\n\\t *\\n\\t */\\n\\tfunction _postRelayedCall(\\n\\t\\tbytes memory context,\\n\\t\\tbool success,\\n\\t\\tuint256 actualCharge,\\n\\t\\tbytes32 preRetVal\\n\\t) internal virtual;\\n\\n\\t/**\\n\\t * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract\\n\\t * will be charged a fee by RelayHub\\n\\t */\\n\\tfunction _approveRelayedCall()\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256, bytes memory)\\n\\t{\\n\\t\\treturn _approveRelayedCall(\\\"\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev See `GSNRecipient._approveRelayedCall`.\\n\\t *\\n\\t * This overload forwards `context` to _preRelayedCall and _postRelayedCall.\\n\\t */\\n\\tfunction _approveRelayedCall(bytes memory context)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256, bytes memory)\\n\\t{\\n\\t\\treturn (_RELAYED_CALL_ACCEPTED, context);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.\\n\\t */\\n\\tfunction _rejectRelayedCall(uint256 errorCode)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256, bytes memory)\\n\\t{\\n\\t\\treturn (_RELAYED_CALL_REJECTED + errorCode, \\\"\\\");\\n\\t}\\n\\n\\t/*\\n\\t * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's\\n\\t * `serviceFee`.\\n\\t */\\n\\tfunction _computeCharge(\\n\\t\\tuint256 gas,\\n\\t\\tuint256 gasPrice,\\n\\t\\tuint256 serviceFee\\n\\t) internal pure returns (uint256) {\\n\\t\\t// The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be\\n\\t\\t// charged for 1.4 times the spent amount.\\n\\t\\treturn (gas * gasPrice * (100 + serviceFee)) / 100;\\n\\t}\\n\\n\\tfunction _getRelayedCallSender()\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (address payable result)\\n\\t{\\n\\t\\t// We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\\n\\t\\t// is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\\n\\t\\t// so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\\n\\t\\t// require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\\n\\t\\t// bytes. This can always be done due to the 32-byte prefix.\\n\\n\\t\\t// The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\\n\\t\\t// easiest/most-efficient way to perform this operation.\\n\\n\\t\\t// These fields are not accessible from assembly\\n\\t\\tbytes memory array = msg.data;\\n\\t\\tuint256 index = msg.data.length;\\n\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n\\t\\t\\tresult := and(\\n\\t\\t\\t\\tmload(add(array, index)),\\n\\t\\t\\t\\t0xffffffffffffffffffffffffffffffffffffffff\\n\\t\\t\\t)\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction _getRelayedCallData() private pure returns (bytes memory) {\\n\\t\\t// RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,\\n\\t\\t// we must strip the last 20 bytes (length of an address type) from it.\\n\\n\\t\\tuint256 actualDataLength = msg.data.length - 20;\\n\\t\\tbytes memory actualData = new bytes(actualDataLength);\\n\\n\\t\\tfor (uint256 i = 0; i < actualDataLength; ++i) {\\n\\t\\t\\tactualData[i] = msg.data[i];\\n\\t\\t}\\n\\n\\t\\treturn actualData;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/gsn/GSNable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/GSN/IRelayRecipient.sol\\\";\\nimport \\\"./GSNRecipient.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title GSNable\\n * @dev enables GSN capability by implementing GSNRecipient\\n * Can be set to accept ALL, NONE or add a MODULE implementing restrictions\\n */\\ncontract GSNable is GSNRecipient {\\n\\t/**\\n\\t * @dev Emitted when a new GSN mode is set\\n\\t */\\n\\tevent GSNModeSet(gsnMode);\\n\\n\\t/**\\n\\t * @dev Emitted when a new GSN module address is set\\n\\t */\\n\\tevent GSNModuleSet(IRelayRecipient);\\n\\n\\t/**\\n\\t * @dev Add access control by overriding this function!\\n\\t * should return true if sender is authorized\\n\\t */\\n\\tfunction _isGSNController() internal virtual view returns (bool) {\\n\\t\\tthis;\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Address of the GSN MODULE implementing IRelayRecipient\\n\\t */\\n\\tIRelayRecipient private _gsnModule = IRelayRecipient(address(0));\\n\\n\\t/**\\n\\t * @dev Modifier to make a function callable only when _isGSNController returns true\\n\\t */\\n\\tmodifier onlyGSNController() {\\n\\t\\trequire(_isGSNController(), \\\"!GSN_CONTROLLER\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev doc in IRelayRecipient\\n\\t */\\n\\tfunction acceptRelayedCall(\\n\\t\\taddress relay,\\n\\t\\taddress from,\\n\\t\\tbytes calldata encodedFunction,\\n\\t\\tuint256 transactionFee,\\n\\t\\tuint256 gasPrice,\\n\\t\\tuint256 gasLimit,\\n\\t\\tuint256 nonce,\\n\\t\\tbytes calldata approvalData,\\n\\t\\tuint256 maxPossibleCharge\\n\\t) external override view returns (uint256, bytes memory) {\\n\\t\\tif (_gsnMode == gsnMode.ALL) {\\n\\t\\t\\treturn _approveRelayedCall();\\n\\t\\t} else if (_gsnMode == gsnMode.MODULE) {\\n\\t\\t\\treturn\\n\\t\\t\\t\\t_gsnModule.acceptRelayedCall(\\n\\t\\t\\t\\t\\trelay,\\n\\t\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\t\\tencodedFunction,\\n\\t\\t\\t\\t\\ttransactionFee,\\n\\t\\t\\t\\t\\tgasPrice,\\n\\t\\t\\t\\t\\tgasLimit,\\n\\t\\t\\t\\t\\tnonce,\\n\\t\\t\\t\\t\\tapprovalData,\\n\\t\\t\\t\\t\\tmaxPossibleCharge\\n\\t\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\treturn _rejectRelayedCall(0);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev doc in IRelayRecipient\\n\\t */\\n\\tfunction _preRelayedCall(bytes memory context)\\n\\t\\tinternal\\n\\t\\toverride\\n\\t\\treturns (bytes32)\\n\\t{\\n\\t\\tif (_gsnMode == gsnMode.MODULE) {\\n\\t\\t\\treturn _gsnModule.preRelayedCall(context);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev doc in IRelayRecipient\\n\\t */\\n\\tfunction _postRelayedCall(\\n\\t\\tbytes memory context,\\n\\t\\tbool success,\\n\\t\\tuint256 actualCharge,\\n\\t\\tbytes32 preRetVal\\n\\t) internal override {\\n\\t\\tif (_gsnMode == gsnMode.MODULE) {\\n\\t\\t\\treturn\\n\\t\\t\\t\\t_gsnModule.postRelayedCall(\\n\\t\\t\\t\\t\\tcontext,\\n\\t\\t\\t\\t\\tsuccess,\\n\\t\\t\\t\\t\\tactualCharge,\\n\\t\\t\\t\\t\\tpreRetVal\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets GSN mode to either ALL, NONE or MODULE\\n\\t * @param mode ALL, NONE or MODULE\\n\\t */\\n\\tfunction setGSNMode(gsnMode mode) public onlyGSNController {\\n\\t\\t_gsnMode = gsnMode(mode);\\n\\t\\temit GSNModeSet(mode);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Gets GSN mode\\n\\t * @return gsnMode ALL, NONE or MODULE\\n\\t */\\n\\tfunction getGSNMode() public view onlyGSNController returns (gsnMode) {\\n\\t\\treturn _gsnMode;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets Module address for MODULE mode\\n\\t * @param newGSNModule Address of new GSN module\\n\\t */\\n\\tfunction setGSNModule(IRelayRecipient newGSNModule)\\n\\t\\tpublic\\n\\t\\tonlyGSNController\\n\\t{\\n\\t\\t_gsnModule = newGSNModule;\\n\\t\\temit GSNModuleSet(newGSNModule);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Upgrades the relay hub address\\n\\t * @param newRelayHub Address of new relay hub\\n\\t */\\n\\tfunction upgradeRelayHub(address newRelayHub) public onlyGSNController {\\n\\t\\t_upgradeRelayHub(newRelayHub);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Withdraws GSN deposits for this contract\\n\\t * @param amount Amount to be withdrawn\\n\\t * @param payee Address to sned the funds to\\n\\t */\\n\\tfunction withdrawDeposits(uint256 amount, address payable payee)\\n\\t\\tpublic\\n\\t\\tonlyGSNController\\n\\t{\\n\\t\\t_withdrawDeposits(amount, payee);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IAdmin.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title IAdmin\\n * @dev Administrable interface\\n */\\ninterface IAdmin {\\n\\t/**\\n\\t * @param role Role that is being assigned\\n\\t * @param account The address that is being assigned a role\\n\\t * @dev Assigns a role to an account\\n\\t * only ADMIN\\n\\t */\\n\\tfunction addRole(bytes32 role, address account) external;\\n\\n\\t/**\\n\\t * @param roles Roles that are being assigned\\n\\t * @param accounts The addresses that are being assigned a role\\n\\t * @dev Assigns a bulk of roles to accounts\\n\\t * only ADMIN\\n\\t */\\n\\tfunction bulkAddRole(bytes32[] calldata roles, address[] calldata accounts)\\n\\t\\texternal;\\n\\n\\t/**\\n\\t * @param role Role that is being removed\\n\\t * @param account The address that a role is removed from\\n\\t * @dev Removes a role from an account\\n\\t * only ADMIN\\n\\t */\\n\\tfunction removeRole(bytes32 role, address account) external;\\n\\n\\t/**\\n\\t * @param role Role that is being renounced by the _msgSender()\\n\\t * @dev Removes a role from the sender's address\\n\\t */\\n\\tfunction renounceRole(bytes32 role) external;\\n\\n\\t/**\\n\\t * @dev check if an account has a role\\n\\t * @return bool True if account has role\\n\\t */\\n\\tfunction hasRole(bytes32 role, address account)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bool);\\n\\n\\t/**\\n\\t * @dev Emitted when `account` is granted `role`.\\n\\t *\\n\\t * `sender` is the account that originated the contract call, an admin role\\n\\t * bearer except when using {_setupRole}.\\n\\t */\\n\\tevent RoleGranted(\\n\\t\\tbytes32 indexed role,\\n\\t\\taddress indexed account,\\n\\t\\taddress indexed sender\\n\\t);\\n\\n\\t/**\\n\\t * @dev Emitted when `account` is revoked `role`.\\n\\t *\\n\\t * `sender` is the account that originated the contract call:\\n\\t *   - if using `revokeRole`, it is the admin role bearer\\n\\t *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n\\t */\\n\\tevent RoleRevoked(\\n\\t\\tbytes32 indexed role,\\n\\t\\taddress indexed account,\\n\\t\\taddress indexed sender\\n\\t);\\n\\n\\t/**\\n\\t * @dev Emitted whenever an account renounced a role\\n\\t */\\n\\tevent RoleRenounced(bytes32 indexed role, address indexed account);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IConstrainable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../interfaces/IConstraintModule.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title IConstrainable\\n * @dev Constrainable interface\\n */\\ninterface IConstrainable {\\n\\tevent ModulesByPartitionSet(\\n\\t\\taddress indexed caller,\\n\\t\\tbytes32 indexed partition,\\n\\t\\tIConstraintModule[] newModules\\n\\t);\\n\\n\\t/**\\n\\t * @dev Returns all modules for requested partition\\n\\t * @param partition Partition to get modules for\\n\\t * @return IConstraintModule[]\\n\\t */\\n\\tfunction getModulesByPartition(bytes32 partition)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (IConstraintModule[] memory);\\n\\n\\t/**\\n\\t * @dev Sets all modules for partition\\n\\t * @param partition Partition to set modules for\\n\\t * @param newModules IConstraintModule[] array of new modules for this partition\\n\\t */\\n\\tfunction setModulesByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\tIConstraintModule[] calldata newModules\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IConstraintModule.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title IConstraintModule\\n * @dev ConstraintModule's interface\\n */\\ninterface IConstraintModule {\\n\\t// ConstraintModule should also implement an interface to the token they are referring to\\n\\t// to call functions like hasRole() from Administrable\\n\\n\\t// string private _module_name;\\n\\n\\t/**\\n\\t * @dev Validates live transfer. Can modify state\\n\\t * @param msg_sender Sender of this function call\\n\\t * @param partition Partition the tokens are being transferred from\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer.\\n\\t * @param operatorData Information attached to the transfer, by the operator.\\n\\t * @return valid transfer is valid\\n\\t * @return reason Why the transfer failed (intended for require statement)\\n\\t */\\n\\tfunction executeTransfer(\\n\\t\\taddress msg_sender,\\n\\t\\tbytes32 partition,\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external returns (bool valid, string memory reason);\\n\\n\\t/**\\n\\t * @dev Returns module name\\n\\t * @return bytes32 name of the constraint module\\n\\t */\\n\\tfunction getModuleName() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @title IERC1400 token standard\\n * @dev ERC1400 interface\\n */\\ninterface IERC1400 {\\n\\t// Document Management\\n\\t/**\\n\\t * [ERC1400 INTERFACE (1/9)]\\n\\t * @dev Access a document associated with the token.\\n\\t * @param documentName Short name (represented as a bytes32) associated to the document.\\n\\t * @return Requested document + document hash.\\n\\t */\\n\\tfunction getDocument(bytes32 documentName)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (string memory, bytes32); // 1/9\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (2/9)]\\n\\t * @dev Associate a document with the token.\\n\\t * @param documentName Short name (represented as a bytes32) associated to the document.\\n\\t * @param uri Document content.\\n\\t * @param documentHash Hash of the document [optional parameter].\\n\\t */\\n\\tfunction setDocument(\\n\\t\\tbytes32 documentName,\\n\\t\\tstring calldata uri,\\n\\t\\tbytes32 documentHash\\n\\t) external; // 2/9\\n\\n\\t/**\\n\\t * @dev Event emitted when a new document is set\\n\\t */\\n\\tevent Document(bytes32 indexed name, string uri, bytes32 documentHash);\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (3/9)]\\n\\t * @dev Know if the token can be controlled by operators.\\n\\t * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\\n\\t * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\\n\\t */\\n\\tfunction isControllable() external view returns (bool); // 3/9\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (4/9)]\\n\\t * @dev Know if new tokens can be issued in the future.\\n\\t * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\\n\\t */\\n\\tfunction isIssuable() external view returns (bool); // 4/9\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (5/9)]\\n\\t * @dev Issue tokens from a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param tokenHolder Address for which we want to issue tokens.\\n\\t * @param value Number of tokens issued.\\n\\t * @param data Information attached to the issuance, by the issuer.\\n\\t */\\n\\tfunction issueByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress tokenHolder,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external; // 5/9\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens were issued to a partition\\n\\t */\\n\\tevent IssuedByPartition(\\n\\t\\tbytes32 indexed partition,\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 value,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (6/9)]\\n\\t * @dev Redeem tokens of a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param value Number of tokens redeemed.\\n\\t * @param data Information attached to the redemption, by the redeemer.\\n\\t */\\n\\tfunction redeemByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external; // 6/9\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (7/9)]\\n\\t * @dev Redeem tokens of a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param tokenHolder Address for which we want to redeem tokens.\\n\\t * @param value Number of tokens redeemed.\\n\\t * @param data Information attached to the redemption.\\n\\t * @param operatorData Information attached to the redemption, by the operator.\\n\\t */\\n\\tfunction operatorRedeemByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress tokenHolder,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external; // 7/9\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens are redeemed from a partition\\n\\t */\\n\\tevent RedeemedByPartition(\\n\\t\\tbytes32 indexed partition,\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed from,\\n\\t\\tuint256 value,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (8/9)]\\n\\t * function canTransferByPartition\\n\\t * not implemented\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (9/9)]\\n\\t * function canOperatorTransferByPartition\\n\\t * not implemented\\n\\t */\\n\\n\\t/********************** ERC1400 OPTIONAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400 STANDARD]\\n\\t * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\\n\\t * Once set to false, '_isControllable' can never be set to 'true' again.\\n\\t */\\n\\tfunction renounceControl() external;\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400 STANDARD]\\n\\t * @dev Definitely renounce the possibility to issue new tokens.\\n\\t * Once set to false, '_isIssuable' can never be set to 'true' again.\\n\\t */\\n\\tfunction renounceIssuance() external;\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400Capped.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @title IERC1400Capped\\n * @dev ERC1400Capped interface\\n */\\ninterface IERC1400Capped {\\n\\t/**\\n\\t * @dev Returns the cap on the token's total supply.\\n\\t */\\n\\tfunction cap() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Sets cap to a new value\\n\\t * New value need to be higher than old one\\n\\t * Is only callable by CAP?_EDITOR\\n\\t * @param newCap value of new cap\\n\\t */\\n\\tfunction setCap(uint256 newCap) external;\\n\\n\\t/**\\n\\t * @dev Event emitted when a new cap is set\\n\\t */\\n\\tevent CapSet(uint256 newCap);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400Partition.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @title IERC1400Partition partially fungible token standard\\n * @dev ERC1400Partition interface\\n */\\ninterface IERC1400Partition {\\n\\t/**\\n\\t * @dev ERC20 backwards-compatibility\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/********************** NEW FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * @dev Returns the total supply of a given partition\\n\\t * For ERC20 compatibility via proxy\\n\\t * @param partition Requested partition\\n\\t * @return uint256 _totalSupplyByPartition\\n\\t */\\n\\tfunction totalSupplyByPartition(bytes32 partition)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/********************** ERC1400Partition EXTERNAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (1/10)]\\n\\t * @dev Get balance of a tokenholder for a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param tokenHolder Address for which the balance is returned.\\n\\t * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\\n\\t */\\n\\tfunction balanceOfByPartition(bytes32 partition, address tokenHolder)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (2/10)]\\n\\t * @dev Get partitions index of a tokenholder.\\n\\t * @param tokenHolder Address for which the partitions index are returned.\\n\\t * @return Array of partitions index of 'tokenHolder'.\\n\\t */\\n\\tfunction partitionsOf(address tokenHolder)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bytes32[] memory);\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (3/10)]\\n\\t * @dev Transfer tokens from a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, by the token holder.\\n\\t * @return Destination partition.\\n\\t */\\n\\tfunction transferByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bytes32);\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (4/10)]\\n\\t * @dev Transfer tokens from a specific partition through an operator.\\n\\t * @param partition Name of the partition.\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer.\\n\\t * @param operatorData Information attached to the transfer, by the operator.\\n\\t * @return Destination partition.\\n\\t */\\n\\tfunction operatorTransferByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external returns (bytes32);\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (5/10)]\\n\\t * function getDefaultPartitions\\n\\t * default partition is always equal to _totalPartitions\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (6/10)]\\n\\t * function setDefaultPartitions\\n\\t * default partition is always equal to _totalPartitions\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (7/10)]\\n\\t * @dev Get controllers for a given partition.\\n\\t * Function used for ERC1400Raw and ERC20 backwards compatibility.\\n\\t * @param partition Name of the partition.\\n\\t * @return Array of controllers for partition.\\n\\t */\\n\\tfunction controllersByPartition(bytes32 partition)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address[] memory);\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (8/10)]\\n\\t * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address to set as an operator for 'msg.sender'.\\n\\t */\\n\\tfunction authorizeOperatorByPartition(bytes32 partition, address operator)\\n\\t\\texternal;\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (9/10)]\\n\\t * @dev Remove the right of the operator address to be an operator on a given\\n\\t * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\\n\\t */\\n\\tfunction revokeOperatorByPartition(bytes32 partition, address operator)\\n\\t\\texternal;\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (10/10)]\\n\\t * @dev Indicate whether the operator address is an operator of the tokenHolder\\n\\t * address for the given partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address which may be an operator of tokenHolder for the given partition.\\n\\t * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\\n\\t * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\\n\\t */\\n\\tfunction isOperatorForPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress operator,\\n\\t\\taddress tokenHolder\\n\\t) external view returns (bool); // 10/10\\n\\n\\t/********************* ERC1400Partition OPTIONAL FUNCTIONS ***************************/\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400Partition STANDARD]\\n\\t * @dev Get list of existing partitions.\\n\\t * @return Array of all exisiting partitions.\\n\\t */\\n\\tfunction totalPartitions() external view returns (bytes32[] memory);\\n\\n\\t/************** ERC1400Raw BACKWARDS RETROCOMPATIBILITY *************************/\\n\\n\\t/**\\n\\t * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, by the token holder.\\n\\t */\\n\\tfunction transferWithData(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\\n\\t * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, and intended for the token holder ('from').\\n\\t */\\n\\tfunction transferFromWithData(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens are transferred from a partition\\n\\t */\\n\\tevent TransferByPartition(\\n\\t\\tbytes32 indexed fromPartition,\\n\\t\\taddress operator,\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 value,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens are transferred between partitions\\n\\t */\\n\\tevent ChangedPartition(\\n\\t\\tbytes32 indexed fromPartition,\\n\\t\\tbytes32 indexed toPartition,\\n\\t\\tuint256 value\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when an operator is authorized for a partition\\n\\t */\\n\\tevent AuthorizedOperatorByPartition(\\n\\t\\tbytes32 indexed partition,\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed tokenHolder\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when an operator authorization is revoked for a partition\\n\\t */\\n\\tevent RevokedOperatorByPartition(\\n\\t\\tbytes32 indexed partition,\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed tokenHolder\\n\\t);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400Raw.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @title IERC1400Raw token standard\\n * @dev ERC1400Raw interface\\n */\\ninterface IERC1400Raw {\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (1/13)]\\n\\t * @dev Get the name of the token, e.g., \\\"MyToken\\\".\\n\\t * @return Name of the token.\\n\\t */\\n\\tfunction name() external view returns (string memory); // 1/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (2/13)]\\n\\t * @dev Get the symbol of the token, e.g., \\\"MYT\\\".\\n\\t * @return Symbol of the token.\\n\\t */\\n\\tfunction symbol() external view returns (string memory); // 2/13\\n\\n\\t// implemented in ERC20\\n\\t// function totalSupply() external view returns (uint256); // 3/13\\n\\t// function balanceOf(address owner) external view returns (uint256); // 4/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (5/13)]\\n\\t * @dev Get the smallest part of the token that’s not divisible.\\n\\t * @return The smallest non-divisible part of the token.\\n\\t */\\n\\tfunction granularity() external view returns (uint256); // 5/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (6/13)]\\n\\t * @dev Get the list of controllers\\n\\t * @return List of addresses of all the controllers.\\n\\t */\\n\\t// function controllers() external view returns (address[] memory); // 6/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (7/13)]\\n\\t * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\\n\\t * and redeem tokens on its behalf.\\n\\t * @param operator Address to set as an operator for 'msg.sender'.\\n\\t */\\n\\tfunction authorizeOperator(address operator) external; // 7/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (8/13)]\\n\\t * @dev Remove the right of the operator address to be an operator for 'msg.sender'\\n\\t * and to transfer and redeem tokens on its behalf.\\n\\t * @param operator Address to rescind as an operator for 'msg.sender'.\\n\\t */\\n\\tfunction revokeOperator(address operator) external; // 8/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (9/13)]\\n\\t * @dev Indicate whether the operator address is an operator of the tokenHolder address.\\n\\t * @param operator Address which may be an operator of tokenHolder.\\n\\t * @param tokenHolder Address of a token holder which may have the operator address as an operator.\\n\\t * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\\n\\t */\\n\\tfunction isOperator(address operator, address tokenHolder)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bool); // 9/13\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (10/13)]\\n\\t * function transferWithData\\n\\t * is overridden in ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (11/13)]\\n\\t * function transferFromWithData\\n\\t * is overridden in ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (12/13)]\\n\\t * function redeem\\n\\t * is not needed when using ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (13/13)]\\n\\t * function redeemFrom\\n\\t * is not needed when using ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens are transferred with data\\n\\t */\\n\\tevent TransferWithData(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 value,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens are issued\\n\\t */\\n\\tevent Issued(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 value,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when tokens are redeemed\\n\\t */\\n\\tevent Redeemed(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed from,\\n\\t\\tuint256 value,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when an operator is authorized\\n\\t */\\n\\tevent AuthorizedOperator(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed tokenHolder\\n\\t);\\n\\n\\t/**\\n\\t * @dev Event emitted when an operator authorization is revoked\\n\\t */\\n\\tevent RevokedOperator(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed tokenHolder\\n\\t);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title IOwnable\\n * @dev IOwnable interface\\n */\\ninterface IOwnable {\\n\\t/**\\n\\t * @dev Emitted when owership of the security token is transferred.\\n\\t */\\n\\tevent OwnershipTransferred(\\n\\t\\taddress indexed previousOwner,\\n\\t\\taddress indexed newOwner\\n\\t);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/interfaces/IPausable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title IPausable\\n * @dev IPausable interface\\n */\\ninterface IPausable {\\n\\t/**\\n\\t * @dev Emitted when the pause is triggered by a pauser (`account`).\\n\\t */\\n\\tevent Paused(address account);\\n\\n\\t/**\\n\\t * @dev Emitted when the pause is lifted by a pauser (`account`).\\n\\t */\\n\\tevent Unpaused(address account);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/storage/SecurityTokenStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../interfaces/IConstraintModule.sol\\\";\\n\\n\\ncontract SecurityTokenStorage {\\n\\t// Administrable\\n\\t/**\\n\\t * @dev Contains all the roles mapped to wether an account holds it or not\\n\\t */\\n\\tmapping(bytes32 => mapping(address => bool)) internal _roles;\\n\\n\\t// Constrainable\\n\\t/**\\n\\t * @dev Contains active constraint modules for a given partition\\n\\t */\\n\\tmapping(bytes32 => IConstraintModule[]) internal _modulesByPartition;\\n\\n\\t// ERC1400Raw\\n\\tstring internal _name;\\n\\tstring internal _symbol;\\n\\tuint256 internal _granularity;\\n\\tuint256 internal _totalSupply;\\n\\n\\t/**\\n\\t * @dev Indicate whether the token can still be controlled by operators or not anymore.\\n\\t */\\n\\tbool internal _isControllable;\\n\\n\\t/**\\n\\t * @dev Indicates the paused state\\n\\t */\\n\\tbool internal _paused;\\n\\n\\t/**\\n\\t * @dev Mapping from tokenHolder to balance.\\n\\t */\\n\\tmapping(address => uint256) internal _balances;\\n\\n\\t/**\\n\\t * @dev Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\\n\\t */\\n\\tmapping(address => mapping(address => bool)) internal _authorizedOperator;\\n\\n\\t// ERC1400Partition\\n\\t/**\\n\\t * @dev Contains complete list of partitions that hold tokens.\\n\\t * Is used for ERC20 transfer\\n\\t */\\n\\tbytes32[] internal _totalPartitions;\\n\\n\\t/**\\n\\t * @dev Mapping from partition to their index.\\n\\t */\\n\\tmapping(bytes32 => uint256) internal _indexOfTotalPartitions;\\n\\n\\t/**\\n\\t * @dev Mapping from partition to global balance of corresponding partition.\\n\\t */\\n\\tmapping(bytes32 => uint256) internal _totalSupplyByPartition;\\n\\n\\t/**\\n\\t * @dev Mapping from tokenHolder to their partitions.\\n\\t */\\n\\tmapping(address => bytes32[]) internal _partitionsOf;\\n\\n\\t/**\\n\\t * @dev Mapping from (tokenHolder, partition) to their index.\\n\\t */\\n\\tmapping(address => mapping(bytes32 => uint256)) internal _indexOfPartitionsOf;\\n\\n\\t/**\\n\\t * @dev Mapping from (tokenHolder, partition) to balance of corresponding partition.\\n\\t */\\n\\tmapping(address => mapping(bytes32 => uint256)) internal _balanceOfByPartition;\\n\\n\\t/**************** Mappings to find partition operators ************************/\\n\\t/**\\n\\t * @dev Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\\n\\t */\\n\\tmapping(address => mapping(bytes32 => mapping(address => bool))) internal _authorizedOperatorByPartition;\\n\\n\\t/**\\n\\t * @dev Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\\n\\t */\\n\\tmapping(bytes32 => address[]) internal _controllersByPartition;\\n\\n\\t// INFO partition controllers can be set by the admin just like other roles\\n\\t// Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\\n\\t// mapping(bytes32 => mapping(address => bool)) internal _isControllerByPartition;\\n\\t/****************************************************************************/\\n\\n\\t// ERC1400ERC20\\n\\t/**\\n\\t * @dev Mapping from (tokenHolder, spender) to allowed value.\\n\\t */\\n\\tmapping(address => mapping(address => uint256)) internal _allowances;\\n\\n\\t// ERC1400\\n\\tstruct Doc {\\n\\t\\tstring docURI;\\n\\t\\tbytes32 docHash;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Mapping for token URIs.\\n\\t */\\n\\tmapping(bytes32 => Doc) internal _documents;\\n\\n\\t/**\\n\\t * @dev Indicate whether the token can still be issued by the issuer or not anymore.\\n\\t */\\n\\tbool internal _isIssuable;\\n\\n\\t// Capped\\n\\t/**\\n\\t * @dev Overall cap of the security token\\n\\t */\\n\\tuint256 internal _cap;\\n\\n\\t// Ownable\\n\\t/**\\n\\t * @dev Owner of the security token\\n\\t */\\n\\taddress internal _owner;\\n\\n\\t// GSN\\n\\t/**\\n\\t * @dev Enum describing the possible GSN modes\\n\\t */\\n\\tenum gsnMode { ALL, MODULE, NONE }\\n\\n\\t/**\\n\\t * @dev Can be set to accept ALL, NONE or MODULE mode\\n\\t * Initialized with ALL\\n\\t */\\n\\tgsnMode internal _gsnMode;\\n\\n\\t/**\\n\\t * @dev Default RelayHub address, deployed on mainnet and all testnets at the same address\\n\\t */\\n\\taddress internal _relayHub;\\n\\n\\tuint256 internal _RELAYED_CALL_ACCEPTED;\\n\\tuint256 internal _RELAYED_CALL_REJECTED;\\n\\n\\t/**\\n\\t * @dev How much gas is forwarded to postRelayedCall\\n\\t */\\n\\tuint256 internal _POST_RELAYED_CALL_MAX_GAS;\\n\\n\\t// ReentrancyGuard\\n\\tbool internal _notEntered;\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/Administrable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../interfaces/IAdmin.sol\\\";\\nimport \\\"../gsn/GSNable.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title Administrable\\n * @dev Manages roles for all inheriting contracts\\n */\\ncontract Administrable is IAdmin, GSNable {\\n\\t/**\\n     * @dev list of standard roles\\n     * roles can be added (i.e. for constraint modules)\\n     *\\n     * --main roles--\\n     * ADMIN   (can add and remove roles)\\n     * CONTROLLER (ERC1400, can force-transfer tokens if contract _isControllable)\\n     * ISSUER (ISSUER)\\n     * REDEEMER (BURNER, can redeem tokens, their own OR others IF _isOperatorForPartition())\\n     * MODULE_EDITOR (can edit constraint modules),\\n     *\\n     * --additional roles--\\n     * DOCUMENT_EDITOR\\n     * CAP_EDITOR\\n\\n     * --constraint module roles--\\n     * PAUSER\\n     * WHITELIST_EDITOR\\n     * TIME_LOCK_EDITOR\\n     * SPENDING_LIMITS_EDITOR\\n     * VESTING_PERIOD_EDITOR\\n     * GSN_CONTROLLER\\n     * DEFAULT_PARTITIONS_EDITOR\\n\\t *\\n\\t * ...\\n     */\\n\\n\\t// EVENTS in IAdmin.sol\\n\\n\\t/**\\n\\t * @dev Modifier to make a function callable only when the caller is a specific role.\\n\\t */\\n\\tmodifier onlyRole(bytes32 role) {\\n\\t\\trequire(hasRole(role, _msgSender()), \\\"unauthorized\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @param role Role that is being assigned\\n\\t * @param account The address that is being assigned a role\\n\\t * @dev Assigns a role to an account\\n\\t * only ADMIN\\n\\t */\\n\\tfunction addRole(bytes32 role, address account)\\n\\t\\tpublic\\n\\t\\toverride\\n\\t\\tonlyRole(bytes32(\\\"ADMIN\\\"))\\n\\t{\\n\\t\\t_add(role, account);\\n\\t}\\n\\n\\t/**\\n\\t * @param roles Roles that are being assigned\\n\\t * @param accounts The addresses that are being assigned a role\\n\\t * @dev Assigns a bulk of roles to accounts\\n\\t * only ADMIN\\n\\t */\\n\\tfunction bulkAddRole(bytes32[] memory roles, address[] memory accounts)\\n\\t\\tpublic\\n\\t\\toverride\\n\\t\\tonlyRole(bytes32(\\\"ADMIN\\\"))\\n\\t{\\n\\t\\trequire(roles.length <= 100, \\\"too many roles\\\");\\n\\t\\trequire(roles.length == accounts.length, \\\"length\\\");\\n\\t\\tfor (uint256 i = 0; i < roles.length; i++) {\\n\\t\\t\\t_add(roles[i], accounts[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @param role Role that is being removed\\n\\t * @param account The address that a role is removed from\\n\\t * @dev Removes a role from an account\\n\\t * only ADMIN\\n\\t */\\n\\tfunction removeRole(bytes32 role, address account)\\n\\t\\tpublic\\n\\t\\toverride\\n\\t\\tonlyRole(bytes32(\\\"ADMIN\\\"))\\n\\t{\\n\\t\\t_remove(role, account);\\n\\t}\\n\\n\\t/**\\n\\t * @param role Role that is being renounced by the _msgSender()\\n\\t * @dev Removes a role from the sender's address\\n\\t * ATTENTION: it is possible to remove the last ADMINN role by renouncing it!\\n\\t */\\n\\tfunction renounceRole(bytes32 role) public override {\\n\\t\\t_remove(role, _msgSender());\\n\\n\\t\\temit RoleRenounced(role, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * @dev check if an account has a role\\n\\t * @return bool True if account has role\\n\\t */\\n\\tfunction hasRole(bytes32 role, address account)\\n\\t\\tpublic\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\treturn _roles[role][account];\\n\\t}\\n\\n\\t/******* INTERNAL FUNCTIONS *******/\\n\\n\\t/**\\n\\t * @dev give an account access to a role\\n\\t */\\n\\tfunction _add(bytes32 role, address account) internal {\\n\\t\\trequire(!hasRole(role, account), \\\"already has role\\\");\\n\\n\\t\\t_roles[role][account] = true;\\n\\n\\t\\temit RoleGranted(role, account, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * @dev remove an account's access to a role\\n\\t * cannot remove own ADMIN role\\n\\t * address must have role\\n\\t */\\n\\tfunction _remove(bytes32 role, address account) internal {\\n\\t\\trequire(hasRole(role, account), \\\"does not have role\\\");\\n\\n\\t\\t_roles[role][account] = false;\\n\\n\\t\\temit RoleRevoked(role, account, _msgSender());\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/Constrainable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./Administrable.sol\\\";\\nimport \\\"../interfaces/IConstraintModule.sol\\\";\\nimport \\\"../interfaces/IConstrainable.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title Constrainable\\n * @dev Adds transfer constraints in the form of updatable constraint modules\\n */\\ncontract Constrainable is IConstrainable, Administrable {\\n\\t/**\\n\\t * @dev Validates live transfer. Can modify state\\n\\t * @param msg_sender Sender of this function call\\n\\t * @param partition Partition the tokens are being transferred from\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer.\\n\\t * @param operatorData Information attached to the transfer, by the operator\\n\\t */\\n\\tfunction _executeTransfer(\\n\\t\\taddress msg_sender,\\n\\t\\tbytes32 partition,\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal {\\n\\t\\tfor (uint256 i = 0; i < _modulesByPartition[partition].length; i++) {\\n\\t\\t\\t(\\n\\t\\t\\t\\tbool valid,\\n\\t\\t\\t\\tstring memory reason\\n\\t\\t\\t) = _modulesByPartition[partition][i].executeTransfer(\\n\\t\\t\\t\\tmsg_sender,\\n\\t\\t\\t\\tpartition,\\n\\t\\t\\t\\toperator,\\n\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\tto,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\toperatorData\\n\\t\\t\\t);\\n\\n\\t\\t\\trequire(valid, reason);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns all modules for requested partition\\n\\t * @param partition Partition to get modules for\\n\\t * @return IConstraintModule[]\\n\\t */\\n\\tfunction getModulesByPartition(bytes32 partition)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (IConstraintModule[] memory)\\n\\t{\\n\\t\\treturn _modulesByPartition[partition];\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets all modules for partition\\n\\t * @param partition Partition to set modules for\\n\\t * @param newModules IConstraintModule[] array of new modules for this partition\\n\\t */\\n\\tfunction setModulesByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\tIConstraintModule[] calldata newModules\\n\\t) external override {\\n\\t\\trequire(\\n\\t\\t\\thasRole(bytes32(\\\"MODULE_EDITOR\\\"), _msgSender()),\\n\\t\\t\\t\\\"!MODULE_EDITOR\\\"\\n\\t\\t);\\n\\t\\t_modulesByPartition[partition] = newModules;\\n\\t\\temit ModulesByPartitionSet(_msgSender(), partition, newModules);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400Capped.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"../interfaces/IERC1400Capped.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title ERC1400Capped\\n * @dev Regulating the cap of the security token\\n */\\ncontract ERC1400Capped is IERC1400Capped, Ownable {\\n\\t/**\\n\\t * @dev Returns the cap on the token's total supply.\\n\\t */\\n\\tfunction cap() public override view returns (uint256) {\\n\\t\\treturn _cap;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets cap to a new value\\n\\t * New value need to be higher than old one\\n\\t * Is only callable by CAP?_EDITOR\\n\\t * @param newCap value of new cap\\n\\t */\\n\\tfunction setCap(uint256 newCap) public override {\\n\\t\\trequire(hasRole(bytes32(\\\"CAP_EDITOR\\\"), _msgSender()), \\\"!CAP_EDITOR\\\");\\n\\t\\trequire((newCap > _cap), \\\"new cap needs to be higher\\\");\\n\\n\\t\\t// set new cap\\n\\t\\t_cap = newCap;\\n\\t\\temit CapSet(newCap);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400ERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./ERC1400Partition.sol\\\";\\nimport \\\"../interfaces/IERC1400Raw.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title ERC1400ERC20\\n * @dev Expands ERC1400s function by those of the ERC20 standard\\n */\\ncontract ERC1400ERC20 is ERC1400Partition, IERC20 {\\n\\t/**\\n\\t * @dev Returns the ERC20 decimal property as 0\\n\\t * @return uint8 Always returns decimals as 0\\n\\t */\\n\\tfunction decimals() external pure returns (uint8) {\\n\\t\\treturn uint8(0);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() public override view returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by `account`.\\n\\t */\\n\\tfunction balanceOf(address who) public override view returns (uint256) {\\n\\t\\treturn _balances[who];\\n\\t}\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transfer(address to, uint256 value)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\t_transferFromTotalPartitions(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tto,\\n\\t\\t\\tvalue,\\n\\t\\t\\t\\\"\\\",\\n\\t\\t\\t\\\"\\\"\\n\\t\\t);\\n\\t\\t// emitted in _transferByPartition\\n\\t\\t// emit Transfer(_msgSender(), to, value);\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remaining number of tokens that `spender` will be\\n\\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n\\t * zero by default.\\n\\t *\\n\\t * This value changes when {approve} or {transferFrom} are called.\\n\\t */\\n\\tfunction allowance(address owner, address spender)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn _allowances[owner][spender];\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address spender, uint256 value)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\t// Transfer Blocked - Sender not eligible\\n\\t\\trequire(spender != address(0), \\\"zero address\\\");\\n\\n\\t\\t// mitigate https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n\\t\\t_allowances[_msgSender()][spender] = 0;\\n\\n\\t\\t_allowances[_msgSender()][spender] = value;\\n\\n\\t\\temit Approval(_msgSender(), spender, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n\\t * allowance mechanism. `amount` is then deducted from the caller's\\n\\t * allowance.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) external override returns (bool) {\\n\\t\\t// check if is operator by partition or has enough allowance here\\n\\t\\trequire(value <= _allowances[from][_msgSender()], \\\"allowance too low\\\");\\n\\t\\t// Transfer Blocked - Identity restriction\\n\\n\\t\\t_allowances[from][_msgSender()] = _allowances[from][_msgSender()].sub(\\n\\t\\t\\tvalue\\n\\t\\t);\\n\\n\\t\\t// transfer by partition\\n\\t\\t_transferFromTotalPartitions(from, from, to, value, \\\"\\\", \\\"\\\");\\n\\n\\t\\t// emitted in _transferByPartition\\n\\t\\t// emit Transfer(_msgSender(), to, value);\\n\\t\\treturn true;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400Partition.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./ERC1400Raw.sol\\\";\\nimport \\\"../interfaces/IERC1400Partition.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title ERC1400Partition\\n * @dev ERC1400Partition logic\\n * inspired by and modeled after https://github.com/ConsenSys/UniversalToken\\n */\\ncontract ERC1400Partition is IERC1400Partition, ERC1400Raw {\\n\\t/**\\n\\t * @dev Returns the total supply of a given partition\\n\\t * For ERC20 compatibility via proxy\\n\\t * @param partition Requested partition\\n\\t * @return uint256 _totalSupplyByPartition\\n\\t */\\n\\tfunction totalSupplyByPartition(bytes32 partition)\\n\\t\\tpublic\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn _totalSupplyByPartition[partition];\\n\\t}\\n\\n\\t/********************** ERC1400Partition EXTERNAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (1/10)]\\n\\t * @dev Get balance of a tokenholder for a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param tokenHolder Address for which the balance is returned.\\n\\t * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\\n\\t */\\n\\tfunction balanceOfByPartition(bytes32 partition, address tokenHolder)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn _balanceOfByPartition[tokenHolder][partition];\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (2/10)]\\n\\t * @dev Get partitions index of a tokenholder.\\n\\t * @param tokenHolder Address for which the partitions index are returned.\\n\\t * @return Array of partitions index of 'tokenHolder'.\\n\\t */\\n\\tfunction partitionsOf(address tokenHolder)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (bytes32[] memory)\\n\\t{\\n\\t\\treturn _partitionsOf[tokenHolder];\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (3/10)]\\n\\t * @dev Transfer tokens from a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, by the token holder.\\n\\t * @return Destination partition.\\n\\t */\\n\\tfunction transferByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external override returns (bytes32) {\\n\\t\\treturn\\n\\t\\t\\t_transferByPartition(\\n\\t\\t\\t\\tpartition,\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\tto,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\t\\\"\\\"\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (4/10)]\\n\\t * @dev Transfer tokens from a specific partition through an operator.\\n\\t * @param partition Name of the partition.\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer.\\n\\t * @param operatorData Information attached to the transfer, by the operator.\\n\\t * @return Destination partition.\\n\\t */\\n\\tfunction operatorTransferByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external override returns (bytes32) {\\n\\t\\trequire(\\n\\t\\t\\t_isOperatorForPartition(partition, _msgSender(), from),\\n\\t\\t\\t\\\"!CONTROLLER or !operator\\\"\\n\\t\\t);\\n\\t\\t// Transfer Blocked - Identity restriction\\n\\n\\t\\treturn\\n\\t\\t\\t_transferByPartition(\\n\\t\\t\\t\\tpartition,\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\tto,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\toperatorData\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (5/10)]\\n\\t * function getDefaultPartitions\\n\\t * default partition is always equal to _totalPartitions\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (6/10)]\\n\\t * function setDefaultPartitions\\n\\t * default partition is always equal to _totalPartitions\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (7/10)]\\n\\t * @dev Get controllers for a given partition.\\n\\t * Function used for ERC1400Raw and ERC20 backwards compatibility.\\n\\t * @param partition Name of the partition.\\n\\t * @return Array of controllers for partition.\\n\\t */\\n\\tfunction controllersByPartition(bytes32 partition)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (address[] memory)\\n\\t{\\n\\t\\treturn _controllersByPartition[partition];\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (8/10)]\\n\\t * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address to set as an operator for 'msg.sender'.\\n\\t */\\n\\tfunction authorizeOperatorByPartition(bytes32 partition, address operator)\\n\\t\\texternal\\n\\t\\toverride\\n\\t{\\n\\t\\t_authorizedOperatorByPartition[_msgSender()][partition][operator] = true;\\n\\t\\temit AuthorizedOperatorByPartition(partition, operator, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (9/10)]\\n\\t * @dev Remove the right of the operator address to be an operator on a given\\n\\t * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\\n\\t */\\n\\tfunction revokeOperatorByPartition(bytes32 partition, address operator)\\n\\t\\texternal\\n\\t\\toverride\\n\\t{\\n\\t\\t_authorizedOperatorByPartition[_msgSender()][partition][operator] = false;\\n\\t\\temit RevokedOperatorByPartition(partition, operator, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Partition INTERFACE (10/10)]\\n\\t * @dev Indicate whether the operator address is an operator of the tokenHolder\\n\\t * address for the given partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address which may be an operator of tokenHolder for the given partition.\\n\\t * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\\n\\t * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\\n\\t */\\n\\tfunction isOperatorForPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress operator,\\n\\t\\taddress tokenHolder\\n\\t) external override view returns (bool) {\\n\\t\\treturn _isOperatorForPartition(partition, operator, tokenHolder);\\n\\t}\\n\\n\\t/********************** ERC1400Partition INTERNAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Indicate whether the operator address is an operator of the tokenHolder\\n\\t * address for the given partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param operator Address which may be an operator of tokenHolder for the given partition.\\n\\t * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\\n\\t * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\\n\\t */\\n\\tfunction _isOperatorForPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress operator,\\n\\t\\taddress tokenHolder\\n\\t) internal view returns (bool) {\\n\\t\\treturn (_authorizedOperatorByPartition[tokenHolder][partition][operator] ||\\n\\t\\t\\t(_isControllable && hasRole(bytes32(\\\"CONTROLLER\\\"), operator)));\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Transfer tokens from a specific partition.\\n\\t * @param fromPartition Partition of the tokens to transfer.\\n\\t * @param operator The address performing the transfer.\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\\n\\t * @param operatorData Information attached to the transfer, by the operator (if any).\\n\\t * @return Destination partition.\\n\\t */\\n\\tfunction _transferByPartition(\\n\\t\\tbytes32 fromPartition,\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal returns (bytes32) {\\n\\t\\trequire(\\n\\t\\t\\t_balanceOfByPartition[from][fromPartition] >= value,\\n\\t\\t\\t\\\"insufficient funds\\\"\\n\\t\\t);\\n\\t\\t// Transfer Blocked - Sender balance insufficient\\n\\n\\t\\t// The RIVER Principle\\n\\t\\t// all transaction go to base partition by default\\n\\t\\t// so over time, tokens converge towards the base!\\n\\t\\tbytes32 toPartition = bytes32(0);\\n\\n\\t\\tif (operatorData.length != 0 && data.length >= 64) {\\n\\t\\t\\ttoPartition = _getDestinationPartition(fromPartition, data);\\n\\t\\t}\\n\\n\\t\\t_removeTokenFromPartition(from, fromPartition, value);\\n\\t\\t_transferWithData(\\n\\t\\t\\tfromPartition,\\n\\t\\t\\toperator,\\n\\t\\t\\tfrom,\\n\\t\\t\\tto,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\toperatorData\\n\\t\\t);\\n\\t\\t_addTokenToPartition(to, toPartition, value);\\n\\n\\t\\temit TransferByPartition(\\n\\t\\t\\tfromPartition,\\n\\t\\t\\toperator,\\n\\t\\t\\tfrom,\\n\\t\\t\\tto,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\toperatorData\\n\\t\\t);\\n\\n\\t\\t// purely for better visibility on etherscan\\n\\t\\temit Transfer(from, to, value);\\n\\n\\t\\tif (toPartition != fromPartition) {\\n\\t\\t\\temit ChangedPartition(fromPartition, toPartition, value);\\n\\t\\t}\\n\\n\\t\\treturn toPartition;\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Remove a token from a specific partition.\\n\\t * @param from Token holder.\\n\\t * @param partition Name of the partition.\\n\\t * @param value Number of tokens to transfer.\\n\\t */\\n\\tfunction _removeTokenFromPartition(\\n\\t\\taddress from,\\n\\t\\tbytes32 partition,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t_balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition]\\n\\t\\t\\t.sub(value);\\n\\t\\t_totalSupplyByPartition[partition] = _totalSupplyByPartition[partition]\\n\\t\\t\\t.sub(value);\\n\\n\\t\\t// If the total supply is zero, finds and deletes the partition.\\n\\t\\tif (_totalSupplyByPartition[partition] == 0) {\\n\\t\\t\\tuint256 index1 = _indexOfTotalPartitions[partition];\\n\\t\\t\\trequire(index1 > 0, \\\"last partition\\\");\\n\\t\\t\\t// Transfer Blocked - Token restriction\\n\\n\\t\\t\\t// move the last item into the index being vacated\\n\\t\\t\\tbytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\\n\\t\\t\\t_totalPartitions[index1 - 1] = lastValue;\\n\\t\\t\\t// adjust for 1-based indexing\\n\\t\\t\\t_indexOfTotalPartitions[lastValue] = index1;\\n\\n\\t\\t\\t_totalPartitions.pop();\\n\\t\\t\\t_indexOfTotalPartitions[partition] = 0;\\n\\t\\t}\\n\\n\\t\\t// If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\\n\\t\\tif (_balanceOfByPartition[from][partition] == 0) {\\n\\t\\t\\tuint256 index2 = _indexOfPartitionsOf[from][partition];\\n\\t\\t\\trequire(index2 > 0, \\\"last partition\\\");\\n\\t\\t\\t// Transfer Blocked - Token restriction\\n\\n\\t\\t\\t// move the last item into the index being vacated\\n\\t\\t\\tbytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length -\\n\\t\\t\\t\\t1];\\n\\t\\t\\t_partitionsOf[from][index2 - 1] = lastValue;\\n\\t\\t\\t// adjust for 1-based indexing\\n\\t\\t\\t_indexOfPartitionsOf[from][lastValue] = index2;\\n\\n\\t\\t\\t_partitionsOf[from].pop();\\n\\t\\t\\t_indexOfPartitionsOf[from][partition] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Add a token to a specific partition.\\n\\t * @param to Token recipient.\\n\\t * @param partition Name of the partition.\\n\\t * @param value Number of tokens to transfer.\\n\\t */\\n\\tfunction _addTokenToPartition(\\n\\t\\taddress to,\\n\\t\\tbytes32 partition,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\tif (value != 0) {\\n\\t\\t\\tif (_indexOfPartitionsOf[to][partition] == 0) {\\n\\t\\t\\t\\t_partitionsOf[to].push(partition);\\n\\t\\t\\t\\t_indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\\n\\t\\t\\t}\\n\\t\\t\\t_balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition]\\n\\t\\t\\t\\t.add(value);\\n\\n\\t\\t\\tif (_indexOfTotalPartitions[partition] == 0) {\\n\\t\\t\\t\\t_totalPartitions.push(partition);\\n\\t\\t\\t\\t_indexOfTotalPartitions[partition] = _totalPartitions.length;\\n\\t\\t\\t}\\n\\t\\t\\t_totalSupplyByPartition[partition] = _totalSupplyByPartition[partition]\\n\\t\\t\\t\\t.add(value);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Retrieve the destination partition from the 'data' field.\\n\\t * By convention, a partition change is requested ONLY when 'data' starts\\n\\t * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n\\t * When the flag is detected, the destination tranche is extracted from the\\n\\t * 32 bytes following the flag.\\n\\t * @param fromPartition Partition of the tokens to transfer.\\n\\t * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\\n\\t * @return toPartition Destination partition.\\n\\t */\\n\\tfunction _getDestinationPartition(bytes32 fromPartition, bytes memory data)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes32 toPartition)\\n\\t{\\n\\t\\t/* prettier-ignore */\\n\\t\\tbytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n\\t\\tbytes32 flag;\\n\\t\\tassembly {\\n\\t\\t\\tflag := mload(add(data, 32))\\n\\t\\t}\\n\\t\\tif (flag == changePartitionFlag) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\ttoPartition := mload(add(data, 64))\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ttoPartition = fromPartition;\\n\\t\\t}\\n\\t}\\n\\n\\t/********************* ERC1400Partition OPTIONAL FUNCTIONS ***************************/\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400Partition STANDARD]\\n\\t * @dev Get list of existing partitions.\\n\\t * @return Array of all exisiting partitions.\\n\\t */\\n\\tfunction totalPartitions()\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (bytes32[] memory)\\n\\t{\\n\\t\\treturn _totalPartitions;\\n\\t}\\n\\n\\t/************** ERC1400Raw BACKWARDS RETROCOMPATIBILITY *************************/\\n\\n\\t/**\\n\\t * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, by the token holder.\\n\\t */\\n\\tfunction transferWithData(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external override {\\n\\t\\t_transferFromTotalPartitions(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tto,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\t\\\"\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\\n\\t * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, and intended for the token holder ('from').\\n\\t */\\n\\tfunction transferFromWithData(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external override {\\n\\t\\trequire(_isOperator(_msgSender(), from), \\\"!operator\\\");\\n\\n\\t\\t_transferFromTotalPartitions(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tfrom,\\n\\t\\t\\tto,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\toperatorData\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400Partition STANDARD]\\n\\t * @dev Transfer tokens from all partitions.\\n\\t * @param operator The address performing the transfer.\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\\n\\t * @param operatorData Information attached to the transfer by the operator (if any).\\n\\t */\\n\\tfunction _transferFromTotalPartitions(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal {\\n\\t\\trequire(_totalPartitions.length != 0, \\\"no partitions\\\"); // Transfer Blocked - Token restriction\\n\\t\\trequire(_totalPartitions.length <= 100, \\\"too many partitions\\\");\\n\\n\\t\\tuint256 _remainingValue = value;\\n\\t\\tuint256 _localBalance;\\n\\n\\t\\tfor (uint256 i = 0; i < _totalPartitions.length; i++) {\\n\\t\\t\\t_localBalance = _balanceOfByPartition[from][_totalPartitions[i]];\\n\\t\\t\\tif (_remainingValue <= _localBalance) {\\n\\t\\t\\t\\t_transferByPartition(\\n\\t\\t\\t\\t\\t_totalPartitions[i],\\n\\t\\t\\t\\t\\toperator,\\n\\t\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\t\\tto,\\n\\t\\t\\t\\t\\t_remainingValue,\\n\\t\\t\\t\\t\\tdata,\\n\\t\\t\\t\\t\\toperatorData\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t_remainingValue = 0;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if (_localBalance != 0) {\\n\\t\\t\\t\\t_transferByPartition(\\n\\t\\t\\t\\t\\t_totalPartitions[i],\\n\\t\\t\\t\\t\\toperator,\\n\\t\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\t\\tto,\\n\\t\\t\\t\\t\\t_localBalance,\\n\\t\\t\\t\\t\\tdata,\\n\\t\\t\\t\\t\\toperatorData\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t_remainingValue = _remainingValue - _localBalance;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\trequire(_remainingValue == 0, \\\"insufficient balance\\\"); // Transfer Blocked - Token restriction\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400Raw.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../erc1820/ERC1820Client.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\nimport \\\"../interfaces/IERC1400Raw.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title ERC1400Raw\\n * @dev ERC1400Raw logic\\n * inspired by and modeled after https://github.com/ConsenSys/UniversalToken\\n */\\ncontract ERC1400Raw is IERC1400Raw, ERC1820Client, ReentrancyGuard {\\n\\tusing SafeMath for uint256;\\n\\n\\t// INFO\\n\\t// moved functionality to admin contract controller role\\n\\t// Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\\n\\t// address[] internal _controllers;\\n\\n\\t// Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\\n\\t// mapping(address => bool) internal _isController;\\n\\n\\t/********************** ERC1400Raw EXTERNAL FUNCTIONS ***************************/\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (1/13)]\\n\\t * @dev Get the name of the token, e.g., \\\"MyToken\\\".\\n\\t * @return Name of the token.\\n\\t */\\n\\tfunction name() external override view returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (2/13)]\\n\\t * @dev Get the symbol of the token, e.g., \\\"MYT\\\".\\n\\t * @return Symbol of the token.\\n\\t */\\n\\tfunction symbol() external override view returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (3/13)]\\n\\t * INFO replaced by ERC20\\n\\t * @dev Get the total number of issued tokens.\\n\\t * @return Total supply of tokens currently in circulation.\\n\\t */\\n\\t/* function totalSupply() public override view returns (uint256) {\\n        return _totalSupply;\\n    } */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (4/13)]\\n\\t * INFO replaced by ERC20\\n\\t * @dev Get the balance of the account with address 'tokenHolder'.\\n\\t * @param tokenHolder Address for which the balance is returned.\\n\\t * @return Amount of token held by 'tokenHolder' in the token contract.\\n\\t */\\n\\t/* function balanceOf(address tokenHolder) public override view returns (uint256) {\\n        return _balances[tokenHolder];\\n    } */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (5/13)]\\n\\t * @dev Get the smallest part of the token that’s not divisible.\\n\\t * @return The smallest non-divisible part of the token.\\n\\t */\\n\\tfunction granularity() external override view returns (uint256) {\\n\\t\\treturn _granularity;\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (6/13)]\\n\\t * @dev Always returns an empty array, since controllers are only managed in Administrable\\n\\t * @return c Empty list\\n\\t */\\n\\t/* function controllers() external override view returns (address[] memory c) {\\n\\t\\treturn c;\\n\\t} */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (7/13)]\\n\\t * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\\n\\t * and redeem tokens on its behalf.\\n\\t * @param operator Address to set as an operator for 'msg.sender'.\\n\\t */\\n\\tfunction authorizeOperator(address operator) external override {\\n\\t\\trequire(operator != _msgSender(), \\\"cannot authorize yourself\\\");\\n\\t\\t_authorizedOperator[operator][_msgSender()] = true;\\n\\t\\temit AuthorizedOperator(operator, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (8/13)]\\n\\t * @dev Remove the right of the operator address to be an operator for 'msg.sender'\\n\\t * and to transfer and redeem tokens on its behalf.\\n\\t * @param operator Address to rescind as an operator for 'msg.sender'.\\n\\t */\\n\\tfunction revokeOperator(address operator) external override {\\n\\t\\trequire(operator != _msgSender(), \\\"cannot revoke yourself\\\");\\n\\t\\t_authorizedOperator[operator][_msgSender()] = false;\\n\\t\\temit RevokedOperator(operator, _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (9/13)]\\n\\t * @dev Indicate whether the operator address is an operator of the tokenHolder address.\\n\\t * @param operator Address which may be an operator of tokenHolder.\\n\\t * @param tokenHolder Address of a token holder which may have the operator address as an operator.\\n\\t * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\\n\\t */\\n\\tfunction isOperator(address operator, address tokenHolder)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\treturn _isOperator(operator, tokenHolder);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (10/13)]\\n\\t * function transferWithData\\n\\t * is overridden in ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (11/13)]\\n\\t * function transferFromWithData\\n\\t * is overridden in ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (12/13)]\\n\\t * function redeem\\n\\t * is not needed when using ERC1400Partition\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400Raw INTERFACE (13/13)]\\n\\t * function redeemFrom\\n\\t * is not needed when using ERC1400Partition\\n\\t */\\n\\n\\t/********************** ERC1400Raw INTERNAL FUNCTIONS ***************************/\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Check if 'value' is multiple of the granularity.\\n\\t * @param value The quantity that want's to be checked.\\n\\t * @return 'true' if 'value' is a multiple of the granularity.\\n\\t */\\n\\tfunction _isMultiple(uint256 value) internal view returns (bool) {\\n\\t\\treturn (value.div(_granularity).mul(_granularity) == value);\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Indicate whether the operator address is an operator of the tokenHolder address.\\n\\t * @param operator Address which may be an operator of 'tokenHolder'.\\n\\t * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\\n\\t * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\\n\\t */\\n\\tfunction _isOperator(address operator, address tokenHolder)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\treturn (operator == tokenHolder ||\\n\\t\\t\\t_authorizedOperator[operator][tokenHolder] ||\\n\\t\\t\\t(_isControllable && hasRole(bytes32(\\\"CONTROLLER\\\"), operator)));\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Perform the transfer of tokens.\\n\\t * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\\n\\t * @param operator The address performing the transfer.\\n\\t * @param from Token holder.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to transfer.\\n\\t * @param data Information attached to the transfer.\\n\\t * @param operatorData Information attached to the transfer by the operator (if any)..\\n\\t */\\n\\n\\tfunction _transferWithData(\\n\\t\\tbytes32 partition,\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal nonReentrant {\\n\\t\\trequire(_isMultiple(value), \\\"violates granularity\\\");\\n\\t\\t// Transfer Blocked - Token granularity\\n\\t\\trequire(to != address(0), \\\"zero address\\\");\\n\\t\\t// Transfer Blocked - Receiver not eligible\\n\\t\\t// require(_balances[from] >= value, \\\"insufficient balance\\\"); // already checked in ERC1400Partition\\n\\t\\t// Transfer Blocked - Sender balance insufficient\\n\\n\\t\\trequire(!_paused, \\\"paused\\\");\\n\\n\\t\\t// CONTROLLER bypasses constraint modules\\n\\t\\tif (\\n\\t\\t\\t!(_isControllable && hasRole(bytes32(\\\"CONTROLLER\\\"), _msgSender()))\\n\\t\\t) {\\n\\t\\t\\t_executeTransfer(\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\tpartition,\\n\\t\\t\\t\\toperator,\\n\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\tto,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\toperatorData\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t// _callSender(partition, operator, from, to, value, data, operatorData);\\n\\n\\t\\t_balances[from] = _balances[from].sub(value);\\n\\t\\t_balances[to] = _balances[to].add(value);\\n\\n\\t\\t// _callRecipient(partition, operator, from, to, value, data, operatorData, preventLocking);\\n\\n\\t\\temit TransferWithData(operator, from, to, value, data, operatorData);\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Perform the token redemption.\\n\\t * @param operator The address performing the redemption.\\n\\t * @param from Token holder whose tokens will be redeemed.\\n\\t * @param value Number of tokens to redeem.\\n\\t * @param data Information attached to the redemption.\\n\\t * @param operatorData Information attached to the redemption, by the operator (if any).\\n\\t */\\n\\tfunction _redeem(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal nonReentrant {\\n\\t\\trequire(_isMultiple(value), \\\"violates granularity\\\");\\n\\t\\t// Transfer Blocked - Token granularity\\n\\t\\trequire(from != address(0), \\\"zero address\\\");\\n\\t\\t// Transfer Blocked - Sender not eligible\\n\\t\\t// require(_balances[from] >= value, \\\"insufficient balance\\\");\\n\\t\\t// already checked in _redeemByPartition\\n\\n\\t\\t// is REDEEMER\\n\\t\\trequire(hasRole(bytes32(\\\"REDEEMER\\\"), _msgSender()), \\\"!REDEEMER\\\");\\n\\n\\t\\t// we don't validate when redeeming\\n\\n\\t\\t_balances[from] = _balances[from].sub(value);\\n\\t\\t_totalSupply = _totalSupply.sub(value);\\n\\n\\t\\temit Redeemed(operator, from, value, data, operatorData);\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Perform the issuance of tokens.\\n\\t * @param operator Address which triggered the issuance.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens issued.\\n\\t * @param data Information attached to the issuance, and intended for the recipient (to).\\n\\t * @param operatorData Information attached to the issuance by the operator (if any).\\n\\t */\\n\\tfunction _issue(\\n\\t\\taddress operator,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal nonReentrant {\\n\\t\\trequire(_isMultiple(value), \\\"violates granularity\\\");\\n\\t\\t// Transfer Blocked - Token granularity\\n\\t\\trequire(to != address(0), \\\"zero address\\\");\\n\\t\\t// Transfer Blocked - Receiver not eligible\\n\\n\\t\\trequire(hasRole(bytes32(\\\"ISSUER\\\"), _msgSender()), \\\"!ISSUER\\\");\\n\\n\\t\\t// we don't validate when minting\\n\\n\\t\\t_totalSupply = _totalSupply.add(value);\\n\\t\\t_balances[to] = _balances[to].add(value);\\n\\n\\t\\t// _callRecipient(partition, operator, address(0), to, value, data, operatorData, true);\\n\\n\\t\\temit Issued(operator, to, value, data, operatorData);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/Ownable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title Ownable\\n * @dev modeled after @openzeppelin/contracts/access/Ownable.sol\\n */\\ncontract Ownable is IOwnable, Pausable {\\n\\t// EVENTS in IOwnable.sol\\n\\n\\t/**\\n\\t * @dev Returns the address of the current owner.\\n\\t */\\n\\tfunction owner() public view returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t * Can only be called by the current owner.\\n\\t */\\n\\tfunction transferOwnership(address newOwner) public virtual {\\n\\t\\trequire(hasRole(bytes32(\\\"ADMIN\\\"), _msgSender()), \\\"!ADMIN\\\");\\n\\t\\trequire(\\n\\t\\t\\tnewOwner != address(0),\\n\\t\\t\\t\\\"Ownable: new owner is the zero address\\\"\\n\\t\\t);\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/Pausable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./Constrainable.sol\\\";\\nimport \\\"../interfaces/IPausable.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title Pausable\\n * @dev modeled after @openzeppelin/contracts/utils/Pausable.sol\\n */\\ncontract Pausable is IPausable, Constrainable {\\n\\t// EVENTS in IPausable.sol\\n\\n\\t/**\\n\\t * @dev Returns true if the contract is paused, and false otherwise.\\n\\t * @return bool True if the contract is paused\\n\\t */\\n\\tfunction paused() public view returns (bool) {\\n\\t\\treturn _paused;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Called by a pauser to pause, triggers stopped state.\\n\\t */\\n\\tfunction pause() public {\\n\\t\\trequire(!_paused, \\\"paused\\\");\\n\\t\\trequire(hasRole(bytes32(\\\"PAUSER\\\"), _msgSender()), \\\"!PAUSER\\\");\\n\\t\\t_paused = true;\\n\\t\\temit Paused(_msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * @dev Called by a pauser to unpause, returns to normal state.\\n\\t */\\n\\tfunction unpause() public {\\n\\t\\trequire(_paused, \\\"not paused\\\");\\n\\t\\trequire(hasRole(bytes32(\\\"PAUSER\\\"), _msgSender()), \\\"!PAUSER\\\");\\n\\t\\t_paused = false;\\n\\t\\temit Unpaused(_msgSender());\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/token/SecurityToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../../node_modules/@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"./ERC1400ERC20.sol\\\";\\nimport \\\"../interfaces/IERC1400.sol\\\";\\n\\n\\n/**\\n * @author Simon Dosch\\n * @title SecurityToken\\n * @dev Main contract of the micobo Security Token Contract Suite\\n * inspired by and modeled after https://github.com/ConsenSys/UniversalToken\\n * implements access control for GSN\\n * implements new function bulkIssueByPartition\\n * implements IERC1400\\n * inherits ERC1400ERC20\\n */\\ncontract SecurityToken is ERC1400ERC20, IERC1400, Initializable {\\n\\t/**\\n\\t * @dev Returns the version string of the {SecurityToken} for which this recipient implementation was built.\\n\\t */\\n\\tfunction version() public view returns (string memory) {\\n\\t\\tthis;\\n\\t\\treturn \\\"1.0.0\\\";\\n\\t}\\n\\n\\t// INITIALIZATION\\n\\t/**\\n\\t * @dev Initialize ERC1400 + register\\n\\t * the contract implementation in ERC1820Registry.\\n\\t * @param name Name of the token.\\n\\t * @param symbol Symbol of the token.\\n\\t * @param granularity Granularity of the token.\\n\\t */\\n\\tfunction initialize(\\n\\t\\tstring calldata name,\\n\\t\\tstring calldata symbol,\\n\\t\\tuint256 granularity,\\n\\t\\tuint256 cap,\\n\\t\\taddress admin,\\n\\t\\taddress controller,\\n\\t\\taddress issuer,\\n\\t\\taddress redeemer,\\n\\t\\taddress module_editor\\n\\t) external initializer {\\n\\t\\t_add(bytes32(\\\"ADMIN\\\"), admin);\\n\\t\\t_add(bytes32(\\\"CONTROLLER\\\"), controller);\\n\\t\\t_add(bytes32(\\\"ISSUER\\\"), issuer);\\n\\t\\t_add(bytes32(\\\"REDEEMER\\\"), redeemer);\\n\\t\\t_add(bytes32(\\\"MODULE_EDITOR\\\"), module_editor);\\n\\n\\t\\t_cap = cap;\\n\\t\\temit CapSet(cap);\\n\\n\\t\\tsetInterfaceImplementation(\\\"ERC1400Token\\\", address(this));\\n\\n\\t\\t_isIssuable = true;\\n\\t\\t_isControllable = true;\\n\\n\\t\\t_owner = admin;\\n\\t\\temit OwnershipTransferred(address(0), admin);\\n\\n\\t\\t// ERC1400Raw\\n\\t\\t_name = name;\\n\\t\\t_symbol = symbol;\\n\\t\\t_totalSupply = 0;\\n\\n\\t\\t// Token granularity can not be lower than 1\\n\\t\\trequire(granularity >= 1, \\\"granularity too low\\\");\\n\\t\\t_granularity = granularity;\\n\\n\\t\\t// GSN\\n\\t\\t_gsnMode = gsnMode.ALL;\\n\\n\\t\\t// Default RelayHub address, deployed on mainnet and all testnets at the same address\\n\\t\\t_relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;\\n\\n\\t\\t_RELAYED_CALL_ACCEPTED = 0;\\n\\t\\t_RELAYED_CALL_REJECTED = 11;\\n\\n\\t\\t// How much gas is forwarded to postRelayedCall\\n\\t\\t_POST_RELAYED_CALL_MAX_GAS = 100000;\\n\\n\\t\\t// Reentrancy\\n\\t\\t_initializeReentrancyGuard();\\n\\t}\\n\\n\\t// GSN\\n\\t/**\\n\\t * @dev Adding access control by overriding this function!\\n\\t * @return true if sender is GSN_CONTROLLER\\n\\t */\\n\\tfunction _isGSNController() internal override view returns (bool) {\\n\\t\\treturn hasRole(bytes32(\\\"GSN_CONTROLLER\\\"), _msgSender());\\n\\t}\\n\\n\\t// BULK ISSUANCE\\n\\t/**\\n\\t * @dev Mints to a number of token holder at the same time\\n\\t * Must be issuable and tokenHolders and values must bne same length\\n\\t * @param partition partition id tokens should be minted for\\n\\t * @param tokenHolders addresses of all token receiver in the same order as \\\"values\\\"\\n\\t * @param values amounts of tokens to be minted in the same order as \\\"tokenHolders\\\"\\n\\t * @param data Additional data for issueByPartition\\n\\t */\\n\\tfunction bulkIssueByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress[] memory tokenHolders,\\n\\t\\tuint256[] memory values,\\n\\t\\tbytes memory data\\n\\t) public {\\n\\t\\trequire(_isIssuable, \\\"token not issuable\\\");\\n\\t\\trequire(tokenHolders.length <= 100, \\\"too many tokenHolders\\\");\\n\\t\\trequire(\\n\\t\\t\\ttokenHolders.length == values.length,\\n\\t\\t\\t\\\"different array lengths\\\"\\n\\t\\t);\\n\\n\\t\\tfor (uint256 i = 0; i < tokenHolders.length; i++) {\\n\\t\\t\\trequire(_totalSupply.add(values[i]) <= _cap, \\\"exceeds cap\\\");\\n\\t\\t\\t_issueByPartition(\\n\\t\\t\\t\\tpartition,\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\ttokenHolders[i],\\n\\t\\t\\t\\tvalues[i],\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\t\\\"\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/********************** ERC1400 EXTERNAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (1/9)]\\n\\t * @dev Access a document associated with the token.\\n\\t * @param documentName Short name (represented as a bytes32) associated to the document.\\n\\t * @return Requested document + document hash.\\n\\t */\\n\\tfunction getDocument(bytes32 documentName)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (string memory, bytes32)\\n\\t{\\n\\t\\treturn (\\n\\t\\t\\t_documents[documentName].docURI,\\n\\t\\t\\t_documents[documentName].docHash\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (2/9)]\\n\\t * @dev Associate a document with the token.\\n\\t * @param documentName Short name (represented as a bytes32) associated to the document.\\n\\t * @param uri Document content.\\n\\t * @param documentHash Hash of the document [optional parameter].\\n\\t */\\n\\tfunction setDocument(\\n\\t\\tbytes32 documentName,\\n\\t\\tstring calldata uri,\\n\\t\\tbytes32 documentHash\\n\\t) external override {\\n\\t\\trequire(\\n\\t\\t\\thasRole(bytes32(\\\"DOCUMENT_EDITOR\\\"), _msgSender()),\\n\\t\\t\\t\\\"!DOCUMENT_EDITOR\\\"\\n\\t\\t);\\n\\t\\t_documents[documentName] = Doc({ docURI: uri, docHash: documentHash });\\n\\t\\temit Document(documentName, uri, documentHash);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (3/9)]\\n\\t * @dev Know if the token can be controlled by operators.\\n\\t * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\\n\\t * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\\n\\t */\\n\\tfunction isControllable() external override view returns (bool) {\\n\\t\\treturn _isControllable;\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (4/9)]\\n\\t * @dev Know if new tokens can be issued in the future.\\n\\t * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\\n\\t */\\n\\tfunction isIssuable() external override view returns (bool) {\\n\\t\\treturn _isIssuable;\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (5/9)]\\n\\t * @dev Issue tokens from a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param tokenHolder Address for which we want to issue tokens.\\n\\t * @param value Number of tokens issued.\\n\\t * @param data Information attached to the issuance, by the issuer.\\n\\t */\\n\\tfunction issueByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress tokenHolder,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data // onlyMinter is taken care of in _issue function\\n\\t) external override {\\n\\t\\trequire(_isIssuable, \\\"token not issuable\\\");\\n\\n\\t\\t// total cap is always the sum of all partitionCaps, so it can't be violated\\n\\n\\t\\trequire(_totalSupply.add(value) <= _cap, \\\"exceeds cap\\\");\\n\\n\\t\\t_issueByPartition(\\n\\t\\t\\tpartition,\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\ttokenHolder,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\t\\\"\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (6/9)]\\n\\t * @dev Redeem tokens of a specific partition.\\n\\t * only controllers can redeem\\n\\t * @param partition Name of the partition.\\n\\t * @param value Number of tokens redeemed.\\n\\t * @param data Information attached to the redemption, by the redeemer.\\n\\t */\\n\\tfunction redeemByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external override {\\n\\t\\t// only REDEEMER can burn tokens (checked in _redeem())\\n\\n\\t\\t_redeemByPartition(\\n\\t\\t\\tpartition,\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\t\\\"\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (7/9)]\\n\\t * @dev Redeem tokens of a specific partition.\\n\\t * @param partition Name of the partition.\\n\\t * @param tokenHolder Address for which we want to redeem tokens.\\n\\t * @param value Number of tokens redeemed.\\n\\t * @param data Information attached to the redemption.\\n\\t * @param operatorData Information attached to the redemption, by the operator.\\n\\t */\\n\\tfunction operatorRedeemByPartition(\\n\\t\\tbytes32 partition,\\n\\t\\taddress tokenHolder,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external override {\\n\\t\\t// only REDEEMER can burn tokens (checked in _redeem())\\n\\n\\t\\trequire(\\n\\t\\t\\t_isOperatorForPartition(partition, _msgSender(), tokenHolder),\\n\\t\\t\\t\\\"!CONTROLLER or !operator\\\"\\n\\t\\t);\\n\\t\\t// Transfer Blocked - Identity restriction\\n\\n\\t\\t_redeemByPartition(\\n\\t\\t\\tpartition,\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\ttokenHolder,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\toperatorData\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (8/9)]\\n\\t * function canTransferByPartition\\n\\t * not implemented\\n\\t */\\n\\n\\t/**\\n\\t * [ERC1400 INTERFACE (9/9)]\\n\\t * function canOperatorTransferByPartition\\n\\t * not implemented\\n\\t */\\n\\n\\t/********************** ERC1400 INTERNAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Issue tokens from a specific partition.\\n\\t * @param toPartition Name of the partition.\\n\\t * @param operator The address performing the issuance.\\n\\t * @param to Token recipient.\\n\\t * @param value Number of tokens to issue.\\n\\t * @param data Information attached to the issuance.\\n\\t * @param operatorData Information attached to the issuance, by the operator (if any).\\n\\t */\\n\\n\\tfunction _issueByPartition(\\n\\t\\tbytes32 toPartition,\\n\\t\\taddress operator,\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal {\\n\\t\\t_issue(operator, to, value, data, operatorData);\\n\\t\\t_addTokenToPartition(to, toPartition, value);\\n\\n\\t\\temit IssuedByPartition(\\n\\t\\t\\ttoPartition,\\n\\t\\t\\toperator,\\n\\t\\t\\tto,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\toperatorData\\n\\t\\t);\\n\\n\\t\\t// purely for better visibility on etherscan\\n\\t\\temit Transfer(address(0), to, value);\\n\\t}\\n\\n\\t/**\\n\\t * [INTERNAL]\\n\\t * @dev Redeem tokens of a specific partition.\\n\\t * @param fromPartition Name of the partition.\\n\\t * @param operator The address performing the redemption.\\n\\t * @param from Token holder whose tokens will be redeemed.\\n\\t * @param value Number of tokens to redeem.\\n\\t * @param data Information attached to the redemption.\\n\\t * @param operatorData Information attached to the redemption, by the operator (if any).\\n\\t */\\n\\n\\tfunction _redeemByPartition(\\n\\t\\tbytes32 fromPartition,\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\tuint256 value,\\n\\t\\tbytes memory data,\\n\\t\\tbytes memory operatorData\\n\\t) internal {\\n\\t\\trequire(\\n\\t\\t\\t_balanceOfByPartition[from][fromPartition] >= value,\\n\\t\\t\\t\\\"insufficient balance\\\"\\n\\t\\t);\\n\\t\\t// Transfer Blocked - Sender balance insufficient\\n\\n\\t\\t_removeTokenFromPartition(from, fromPartition, value);\\n\\t\\t_redeem(operator, from, value, data, operatorData);\\n\\n\\t\\temit RedeemedByPartition(\\n\\t\\t\\tfromPartition,\\n\\t\\t\\toperator,\\n\\t\\t\\tfrom,\\n\\t\\t\\tvalue,\\n\\t\\t\\tdata,\\n\\t\\t\\toperatorData\\n\\t\\t);\\n\\n\\t\\t// purely for better visibility on etherscan\\n\\t\\temit Transfer(from, address(0), value);\\n\\t}\\n\\n\\t/********************** ERC1400 OPTIONAL FUNCTIONS **************************/\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400 STANDARD]\\n\\t * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\\n\\t * Once set to false, '_isControllable' can never be set to 'true' again.\\n\\t */\\n\\tfunction renounceControl() external override {\\n\\t\\trequire(hasRole(bytes32(\\\"ADMIN\\\"), _msgSender()), \\\"!ADMIN\\\");\\n\\t\\t_isControllable = false;\\n\\t}\\n\\n\\t/**\\n\\t * [NOT MANDATORY FOR ERC1400 STANDARD]\\n\\t * @dev Definitely renounce the possibility to issue new tokens.\\n\\t * Once set to false, '_isIssuable' can never be set to 'true' again.\\n\\t */\\n\\tfunction renounceIssuance() external override {\\n\\t\\trequire(hasRole(bytes32(\\\"ADMIN\\\"), _msgSender()), \\\"!ADMIN\\\");\\n\\t\\t_isIssuable = false;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../token/ERC1400Capped.sol\\\";\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard is ERC1400Capped {\\n\\tfunction _initializeReentrancyGuard() internal {\\n\\t\\t// Storing an initial non-zero value makes deployment a bit more\\n\\t\\t// expensive, but in exchange the refund on every call to nonReentrant\\n\\t\\t// will be lower in amount. Since refunds are capped to a percetange of\\n\\t\\t// the total transaction's gas, it is best to keep them low in cases\\n\\t\\t// like this one, to increase the likelihood of the full refund coming\\n\\t\\t// into effect.\\n\\t\\t_notEntered = true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Prevents a contract from calling itself, directly or indirectly.\\n\\t * Calling a `nonReentrant` function from another `nonReentrant`\\n\\t * function is not supported. It is possible to prevent this from happening\\n\\t * by making the `nonReentrant` function external, and make it call a\\n\\t * `private` function that does the actual work.\\n\\t */\\n\\tmodifier nonReentrant() {\\n\\t\\t// On the first call to nonReentrant, _notEntered will be true\\n\\t\\trequire(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n\\t\\t// Any calls to nonReentrant after this point will fail\\n\\t\\t_notEntered = false;\\n\\n\\t\\t_;\\n\\n\\t\\t// By storing the original value once again, a refund is triggered (see\\n\\t\\t// https://eips.ethereum.org/EIPS/eip-2200)\\n\\t\\t_notEntered = true;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/GSN/IRelayHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract\\n * directly.\\n *\\n * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on\\n * how to deploy an instance of `RelayHub` on your local test network.\\n */\\ninterface IRelayHub {\\n    // Relay management\\n\\n    /**\\n     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller\\n     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay\\n     * cannot be its own owner.\\n     *\\n     * All Ether in this function call will be added to the relay's stake.\\n     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.\\n     *\\n     * Emits a {Staked} event.\\n     */\\n    function stake(address relayaddr, uint256 unstakeDelay) external payable;\\n\\n    /**\\n     * @dev Emitted when a relay's stake or unstakeDelay are increased\\n     */\\n    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\\n\\n    /**\\n     * @dev Registers the caller as a relay.\\n     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).\\n     *\\n     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received\\n     * `transactionFee` is not enforced by {relayCall}.\\n     *\\n     * Emits a {RelayAdded} event.\\n     */\\n    function registerRelay(uint256 transactionFee, string calldata url) external;\\n\\n    /**\\n     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out\\n     * {RelayRemoved} events) lets a client discover the list of available relays.\\n     */\\n    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\\n\\n    /**\\n     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.\\n     *\\n     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be\\n     * callable.\\n     *\\n     * Emits a {RelayRemoved} event.\\n     */\\n    function removeRelayByOwner(address relay) external;\\n\\n    /**\\n     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.\\n     */\\n    event RelayRemoved(address indexed relay, uint256 unstakeTime);\\n\\n    /** Deletes the relay from the system, and gives back its stake to the owner.\\n     *\\n     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.\\n     *\\n     * Emits an {Unstaked} event.\\n     */\\n    function unstake(address relay) external;\\n\\n    /**\\n     * @dev Emitted when a relay is unstaked for, including the returned stake.\\n     */\\n    event Unstaked(address indexed relay, uint256 stake);\\n\\n    // States a relay can be in\\n    enum RelayState {\\n        Unknown, // The relay is unknown to the system: it has never been staked for\\n        Staked, // The relay has been staked for, but it is not yet active\\n        Registered, // The relay has registered itself, and is active (can relay calls)\\n        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\\n    }\\n\\n    /**\\n     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function\\n     * to return an empty entry.\\n     */\\n    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\\n\\n    // Balance management\\n\\n    /**\\n     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.\\n     *\\n     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.\\n     *\\n     * Emits a {Deposited} event.\\n     */\\n    function depositFor(address target) external payable;\\n\\n    /**\\n     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.\\n     */\\n    event Deposited(address indexed recipient, address indexed from, uint256 amount);\\n\\n    /**\\n     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.\\n     */\\n    function balanceOf(address target) external view returns (uint256);\\n\\n    /**\\n     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and\\n     * contracts can use it to reduce their funding.\\n     *\\n     * Emits a {Withdrawn} event.\\n     */\\n    function withdraw(uint256 amount, address payable dest) external;\\n\\n    /**\\n     * @dev Emitted when an account withdraws funds from `RelayHub`.\\n     */\\n    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\\n\\n    // Relaying\\n\\n    /**\\n     * @dev Checks if the `RelayHub` will accept a relayed operation.\\n     * Multiple things must be true for this to happen:\\n     *  - all arguments must be signed for by the sender (`from`)\\n     *  - the sender's nonce must be the current one\\n     *  - the recipient must accept this transaction (via {acceptRelayedCall})\\n     *\\n     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error\\n     * code if it returns one in {acceptRelayedCall}.\\n     */\\n    function canRelay(\\n        address relay,\\n        address from,\\n        address to,\\n        bytes calldata encodedFunction,\\n        uint256 transactionFee,\\n        uint256 gasPrice,\\n        uint256 gasLimit,\\n        uint256 nonce,\\n        bytes calldata signature,\\n        bytes calldata approvalData\\n    ) external view returns (uint256 status, bytes memory recipientContext);\\n\\n    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.\\n    enum PreconditionCheck {\\n        OK,                         // All checks passed, the call can be relayed\\n        WrongSignature,             // The transaction to relay is not signed by requested sender\\n        WrongNonce,                 // The provided nonce has already been used by the sender\\n        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall\\n        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code\\n    }\\n\\n    /**\\n     * @dev Relays a transaction.\\n     *\\n     * For this to succeed, multiple conditions must be met:\\n     *  - {canRelay} must `return PreconditionCheck.OK`\\n     *  - the sender must be a registered relay\\n     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender\\n     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the\\n     * recipient) use all gas available to them\\n     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is\\n     * spent)\\n     *\\n     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded\\n     * function and {postRelayedCall} will be called in that order.\\n     *\\n     * Parameters:\\n     *  - `from`: the client originating the request\\n     *  - `to`: the target {IRelayRecipient} contract\\n     *  - `encodedFunction`: the function call to relay, including data\\n     *  - `transactionFee`: fee (%) the relay takes over actual gas cost\\n     *  - `gasPrice`: gas price the client is willing to pay\\n     *  - `gasLimit`: gas to forward when calling the encoded function\\n     *  - `nonce`: client's nonce\\n     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses\\n     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the\\n     * `RelayHub`, but it still can be used for e.g. a signature.\\n     *\\n     * Emits a {TransactionRelayed} event.\\n     */\\n    function relayCall(\\n        address from,\\n        address to,\\n        bytes calldata encodedFunction,\\n        uint256 transactionFee,\\n        uint256 gasPrice,\\n        uint256 gasLimit,\\n        uint256 nonce,\\n        bytes calldata signature,\\n        bytes calldata approvalData\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when an attempt to relay a call failed.\\n     *\\n     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The\\n     * actual relayed call was not executed, and the recipient not charged.\\n     *\\n     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values\\n     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.\\n     */\\n    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\\n\\n    /**\\n     * @dev Emitted when a transaction is relayed.\\n     * Useful when monitoring a relay's operation and relayed calls to a contract\\n     *\\n     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.\\n     *\\n     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.\\n     */\\n    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\\n\\n    // Reason error codes for the TransactionRelayed event\\n    enum RelayCallStatus {\\n        OK,                      // The transaction was successfully relayed and execution successful - never included in the event\\n        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed\\n        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting\\n        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting\\n        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient's balance changing\\n    }\\n\\n    /**\\n     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will\\n     * spend up to `relayedCallStipend` gas.\\n     */\\n    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.\\n     */\\n    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);\\n\\n     // Relay penalization.\\n     // Any account can penalize relays, removing them from the system immediately, and rewarding the\\n    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it\\n    // still loses half of its stake.\\n\\n    /**\\n     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and\\n     * different data (gas price, gas limit, etc. may be different).\\n     *\\n     * The (unsigned) transaction data and signature for both transactions must be provided.\\n     */\\n    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;\\n\\n    /**\\n     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.\\n     */\\n    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;\\n\\n    /**\\n     * @dev Emitted when a relay is penalized.\\n     */\\n    event Penalized(address indexed relay, address sender, uint256 amount);\\n\\n    /**\\n     * @dev Returns an account's nonce in `RelayHub`.\\n     */\\n    function getNonce(address from) external view returns (uint256);\\n}\\n\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/GSN/IRelayRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.\\n *\\n * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.\\n */\\ninterface IRelayRecipient {\\n    /**\\n     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.\\n     */\\n    function getHubAddr() external view returns (address);\\n\\n    /**\\n     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the\\n     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).\\n     *\\n     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call\\n     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,\\n     * and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the\\n     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for\\n     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature\\n     * over all or some of the previous values.\\n     *\\n     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,\\n     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.\\n     *\\n     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered\\n     * rejected. A regular revert will also trigger a rejection.\\n     */\\n    function acceptRelayedCall(\\n        address relay,\\n        address from,\\n        bytes calldata encodedFunction,\\n        uint256 transactionFee,\\n        uint256 gasPrice,\\n        uint256 gasLimit,\\n        uint256 nonce,\\n        bytes calldata approvalData,\\n        uint256 maxPossibleCharge\\n    )\\n        external\\n        view\\n        returns (uint256, bytes memory);\\n\\n    /**\\n     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.\\n     * pre-charge the sender of the transaction.\\n     *\\n     * `context` is the second value returned in the tuple by {acceptRelayedCall}.\\n     *\\n     * Returns a value to be passed to {postRelayedCall}.\\n     *\\n     * {preRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\\n     * will not be executed, but the recipient will still be charged for the transaction's cost.\\n     */\\n    function preRelayedCall(bytes calldata context) external returns (bytes32);\\n\\n    /**\\n     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.\\n     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform\\n     * contract-specific bookkeeping.\\n     *\\n     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of\\n     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,\\n     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.\\n     *\\n     *\\n     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\\n     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the\\n     * transaction's cost.\\n     */\\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1024\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"CapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"Document\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum SecurityTokenStorage.gsnMode\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"GSNModeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRelayRecipient\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"GSNModuleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract IConstraintModule[]\",\"name\":\"newModules\",\"type\":\"address[]\"}],\"name\":\"ModulesByPartitionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRelayHub\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRelayHub\",\"type\":\"address\"}],\"name\":\"RelayHubChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoleRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferWithData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encodedFunction\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"transactionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"approvalData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maxPossibleCharge\",\"type\":\"uint256\"}],\"name\":\"acceptRelayedCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"roles\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"bulkAddRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"tokenHolders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bulkIssueByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"documentName\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGSNMode\",\"outputs\":[{\"internalType\":\"enum SecurityTokenStorage.gsnMode\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHubAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"getModulesByPartition\",\"outputs\":[{\"internalType\":\"contract IConstraintModule[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"granularity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module_editor\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"actualCharge\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"preRetVal\",\"type\":\"bytes32\"}],\"name\":\"postRelayedCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"preRelayedCall\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayHubVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"documentName\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SecurityTokenStorage.gsnMode\",\"name\":\"mode\",\"type\":\"uint8\"}],\"name\":\"setGSNMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRelayRecipient\",\"name\":\"newGSNModule\",\"type\":\"address\"}],\"name\":\"setGSNModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"contract IConstraintModule[]\",\"name\":\"newModules\",\"type\":\"address[]\"}],\"name\":\"setModulesByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"totalSupplyByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRelayHub\",\"type\":\"address\"}],\"name\":\"upgradeRelayHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdrawDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SecurityToken","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"1024","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}