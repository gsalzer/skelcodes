{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.10;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a/*, \"SafeMath: addition overflow\"*/);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b <= a/*, errorMessage*/);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        assert(c / a == b/*, \"SafeMath: multiplication overflow\"*/);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b > 0/*, errorMessage*/);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b != 0/*, errorMessage*/);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract IERC20 {\r\n    function balanceOf(address account) public view virtual returns (uint256);\r\n    function transfer(address to, uint256 value) public virtual returns (bool);\r\n    function approve(address spender, uint256 amount) public virtual returns (bool);\r\n    function updateMyStakes() public virtual;\r\n}\r\n\r\n/**\r\n * @dev A token holder contract that will allow a beneficiary to extract the\r\n * tokens after a given release time. \r\n *\r\n * Useful for simple vesting schedules like \"advisors get all of their tokens\r\n * after 2 years\".\r\n * \r\n * This contract was modified to support a monthly (30-day) vesting schedule.\r\n */\r\ncontract TokenTimelock {\r\n    using SafeMath for uint256;\r\n\r\n    // ERC20 basic token contract being held\r\n    IERC20 private _token;\r\n\r\n    // Beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // Timestamp when the timelock started\r\n    uint256 private _startTime;\r\n    \r\n    // Timestamp of the last time vested tokens were claimed\r\n    uint256 private _lastRelease;\r\n    \r\n    // Total days tokens will be locked for\r\n    uint private _totalDays;\r\n    \r\n    // Total tokens the contract holds\r\n    uint private _totalTokens;\r\n    uint private _adjustmentFactor;\r\n    // True when the first month of tokens were claimed\r\n    bool private _vestingStarted;\r\n    \r\n    modifier onlyBeneficiary() {\r\n        require(msg.sender == _beneficiary, \"Caller must be beneficiary.\");\r\n        _;\r\n    }\r\n    \r\n\r\n    constructor (IERC20 token) public {\r\n        _token = token;\r\n        _beneficiary = msg.sender;\r\n        _startTime = block.timestamp;\r\n        _lastRelease = block.timestamp;\r\n        _totalDays = 60;   // 2 months\r\n        _vestingStarted = false;\r\n    }\r\n\r\n    /**\r\n     * @return the token being held.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the time when the timelock started.\r\n     */\r\n    function startTime() public view returns (uint256) {\r\n        return _startTime;\r\n    }\r\n    \r\n    function lastRelease() public view returns (uint256) {\r\n        return _lastRelease;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by timelock to beneficiary.\r\n     */\r\n    function release() public onlyBeneficiary {\r\n        \r\n        if(!_vestingStarted) {\r\n            _totalTokens = _token.balanceOf(address(this));\r\n            _vestingStarted = true;\r\n            _token.transfer(_beneficiary, 500000E18);\r\n            return;\r\n        }\r\n        \r\n        require(_totalTokens > 0, \"TokenTimelock: no tokens to release\");\r\n         \r\n        uint daysSinceLast = block.timestamp.sub(_lastRelease) / 86400;\r\n        \r\n        require(daysSinceLast > 30);\r\n        \r\n        _lastRelease = block.timestamp;\r\n        \r\n        uint amount = mulDiv(_totalTokens, 30, _totalDays);\r\n\r\n        _token.transfer(_beneficiary, amount);\r\n    }\r\n    \r\n    // Only used in case the above does not work (after 720 days)\r\n    function releaseTheRest() external onlyBeneficiary {\r\n        \r\n        uint daysSinceStart = block.timestamp.sub(_startTime) / 86400;\r\n        require(daysSinceStart >= 60);\r\n        uint amount = _token.balanceOf(address(this));\r\n        _token.transfer(_beneficiary, amount);\r\n        \r\n    }\r\n    \r\n    function updateBeneficiary(address newBeneficiary) external onlyBeneficiary {\r\n        _beneficiary = newBeneficiary;\r\n    }\r\n    \r\n    function updateAdjustmentFactor(uint adjustmentFactor) external onlyBeneficiary {\r\n        _adjustmentFactor = adjustmentFactor;\r\n    }\r\n    \r\n    // Used if more tokens are transferred to be locked\r\n    function syncBalance() external onlyBeneficiary {\r\n        _totalTokens = _token.balanceOf(address(this));\r\n    }\r\n    \r\n    function claimLockedStakes() external onlyBeneficiary {\r\n        _token.updateMyStakes();\r\n    }\r\n    \r\n    function updateToken(address newToken) external onlyBeneficiary {\r\n        _token.approve(newToken, 1000000000E18);\r\n        _token = IERC20(newToken);\r\n    }\r\n    \r\n    function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\r\n          (uint l, uint h) = fullMul (x, y);\r\n          assert (h < z);\r\n          uint mm = mulmod (x, y, z);\r\n          if (mm > l) h -= 1;\r\n          l -= mm;\r\n          uint pow2 = z & -z;\r\n          z /= pow2;\r\n          l /= pow2;\r\n          l += h * ((-pow2) / pow2 + 1);\r\n          uint r = 1;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          return l * r;\r\n    }\r\n    \r\n    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\r\n          uint mm = mulmod (x, y, uint (-1));\r\n          l = x * y;\r\n          h = mm - l;\r\n          if (mm < l) h -= 1;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLockedStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseTheRest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustmentFactor\",\"type\":\"uint256\"}],\"name\":\"updateAdjustmentFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"updateBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"updateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenTimelock","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008da25b8ed753a5910013167945a676921e864436","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5abddb61d427d44efacc184e9084e04b076d8764ae39d3b29bbea97e3ae39699"}]}