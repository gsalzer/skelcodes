{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\ncontract Token {\r\n  function transfer(address to, uint256 value) public returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool success);\r\n  function balanceOf(address account) external view returns(uint256);\r\n  function allowance(address _owner, address _spender)external view returns(uint256);\r\n}\r\n\r\nlibrary SafeMath{\r\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) {\r\n        return 0;}\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract SeekRewardsDex {\r\n    using SafeMath for uint;\r\n    event DepositandWithdraw(address from,address tokenAddress,uint256 amount,uint256 type_); //Type = 0-deposit 1- withdraw , Token address = address(0) - eth , address - token address;\r\n    \r\n    address payable public admin; // admin address\r\n    address payable public admin2;\r\n    address private feeAddress;\r\n    address public feeTokenAddress;\r\n    // uint256 public feeAmount;\r\n    bool public dexStatus;   // status to hold the dex transaction ;\r\n    \r\n    /*\r\n    * if status =0 no fee for fee token buyer else fee will be taken\r\n    */\r\n    \r\n    bool public feeTokenStatus;\r\n      \r\n    struct orders{ // order details\r\n        address userAddress;\r\n        address tokenAddress;\r\n        uint8 status;\r\n        uint128 type_;\r\n        uint128 price;\r\n        uint128 quantity;\r\n        uint128 tradeQuantity;\r\n    }\r\n    \r\n\r\n\r\n    struct tokens{ // token details\r\n        address tokenAddress;\r\n        string tokenSymbol;\r\n        uint128 decimals;\r\n        uint120 withdrawFee;\r\n        uint8 status;\r\n    }\r\n    \r\n   \r\n    \r\n    constructor(address payable _admin1, address payable _admin2,address feeAddress_,address feetokenaddress_,bool _status) public{ \r\n        admin = _admin1;\r\n        admin2 = _admin2;\r\n        feeAddress = feeAddress_;\r\n        dexStatus = true; // set dex status to active during contract creation\r\n        feeTokenAddress = feetokenaddress_;\r\n        feeTokenStatus = _status;\r\n    }\r\n\r\n    \r\n    mapping(uint256=>orders) public Order; //place order by passing userID and orderID as argument;\r\n    \r\n    mapping(address=>mapping(address=>uint256))public userDetails;  // trader token balance;\r\n    \r\n    mapping(address=>uint256) public withdrawfee; // admin can set fee amount to token addresses\r\n     \r\n     mapping(address=>tokens) public tokendetails; //admin can add token details\r\n     \r\n     mapping(address=>bool) public user_status; // to check user is new to dex\r\n     \r\n     mapping(uint256=>bool)public tradeOrders; // trading details;\r\n     \r\n     mapping(address=>mapping(address=>uint256))public adminProfit; //  admin profit's\r\n    \r\n    modifier dexstatuscheck(){ // check wheather dex is active or not\r\n       require(dexStatus==true);\r\n       _;\r\n    }\r\n    \r\n    modifier onlyFeeAddress(){\r\n        require(msg.sender == feeAddress);\r\n       _;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n    require(msg.sender == admin);\r\n      _;\r\n    }\r\n    \r\n    function setDexStatus(bool status_) onlyOwner public returns(bool){ // admin can change dex to inactive if needed\r\n        dexStatus = status_; // if true dex is active & false dex is inactive\r\n        return true;\r\n    }   \r\n    \r\n    function changeFeeAddress(address changeFeeaddress) onlyOwner public returns(bool){\r\n        feeAddress = changeFeeaddress;\r\n        return true;\r\n    }\r\n    \r\n    function changeAdmin(address payable changeAdminaddress) onlyOwner public returns(bool){\r\n        admin = changeAdminaddress;\r\n        return true;\r\n    }\r\n \r\n    function setFeeToken(address feeTokenaddress,bool _status) onlyOwner public returns(bool){\r\n        feeTokenAddress = feeTokenaddress;\r\n        feeTokenStatus = _status;\r\n        return true;\r\n    }\r\n\r\n    function addToken(address tokenAddress_,string memory tokenSymbol,uint128 decimal_,uint120 withdrawFee_) onlyFeeAddress public returns(bool){\r\n        require(tokendetails[tokenAddress_].status==0); // if status is true token already exist;\r\n        tokendetails[tokenAddress_].tokenAddress=tokenAddress_;\r\n        tokendetails[tokenAddress_].tokenSymbol=tokenSymbol; // token symbol\r\n        tokendetails[tokenAddress_].decimals=decimal_; // token decimals\r\n        tokendetails[tokenAddress_].withdrawFee = withdrawFee_;   \r\n        tokendetails[tokenAddress_].status=1; // changing token  status\r\n        return true;\r\n    }\r\n    \r\n    // verifing dex status for following functionalities.To check dex is active or not;\r\n    function deposit() dexstatuscheck public payable returns(bool) { \r\n        require((msg.sender!= admin) && (msg.sender!= admin2));\r\n        require(msg.value > 0); \r\n        userDetails[msg.sender][address(0)]=userDetails[msg.sender][address(0)].add(msg.value);\r\n        user_status[msg.sender]=true; \r\n        emit DepositandWithdraw( msg.sender, address(0),msg.value,0);\r\n        return true;\r\n    }\r\n    \r\n    function tokenDeposit(address tokenaddr,uint256 tokenAmount) dexstatuscheck public returns(bool)\r\n    {\r\n        require((msg.sender!= admin) && (msg.sender!= admin2));\r\n        require(tokenAmount > 0 && tokendetails[tokenaddr].status==1); // to deposit token , token should be added by admin\r\n        require(tokenallowance(tokenaddr,msg.sender,address(this)) > 0); // checking contract allowance by user\r\n        userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].add(tokenAmount);\r\n        Token(tokenaddr).transferFrom(msg.sender,address(this), tokenAmount);\r\n        user_status[msg.sender]=true; \r\n        emit DepositandWithdraw( msg.sender,tokenaddr,tokenAmount,0);\r\n        return true;\r\n        \r\n    }\r\n  \r\n  // user withdraw\r\n  \r\n    function withdraw(uint8 type_,address tokenaddr,uint256 amount) dexstatuscheck public returns(bool) {\r\n        require((msg.sender!= admin) && (msg.sender!= admin2));\r\n        require((type_ ==0) || (type_ == 1)); // type : 0- ether withdraw 1- token withdraw;\r\n         if(type_==0){ // withdraw ether\r\n         require(tokenaddr == address(0)); // tokenaddress should be ether (address(0))\r\n         require(amount>0 && amount <= userDetails[msg.sender][address(0)] && withdrawfee[address(0)]<amount); //check user balance\r\n         require(amount<=address(this).balance);\r\n                msg.sender.transfer(amount.sub(withdrawfee[address(0)]));   // transfer withdraw amount  \r\n                userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].sub(amount); // decreasing user balance\r\n                adminProfit[admin][address(0)] = adminProfit[admin][address(0)].add(withdrawfee[address(0)]); // increasing withdraw fee\r\n                \r\n        }\r\n        else{ //withdraw token\r\n        require(tokenaddr != address(0) && tokendetails[tokenaddr].status==1);   // token address should not be ether \r\n        require(amount>0 && amount <= userDetails[msg.sender][tokenaddr] && withdrawfee[tokenaddr]<amount);\r\n              Token(tokenaddr).transfer(msg.sender, (amount.sub(withdrawfee[tokenaddr])));// transfer withdraw amount  \r\n              userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].sub(amount);  // decreasing user balance\r\n              adminProfit[admin][tokenaddr] = adminProfit[admin][tokenaddr].add(withdrawfee[tokenaddr]); // increasing withdraw fee\r\n        }\r\n        emit DepositandWithdraw( msg.sender,tokenaddr,amount,1);\r\n        return true;\r\n    }\r\n    \r\n    //admin profit withdraw\r\n     function adminProfitWithdraw(uint8 type_,address tokenAddr)public returns(bool){ //  tokenAddr = type 0 - address(0),  type 1 - token address;\r\n       require((msg.sender == admin) || (msg.sender == admin2)); // only by admin\r\n       require(type_ ==0 || type_ == 1);\r\n         if(type_==0){ // withdraw ether\r\n            msg.sender.transfer(adminProfit[msg.sender][address(0)]); // total  ether profit is transfered to admin\r\n            adminProfit[msg.sender][address(0)]=0; // set 0 to admin ether profit after transfer\r\n                \r\n        }\r\n        else{ //withdraw token\r\n            require(tokenAddr != address(0)) ;\r\n            Token(tokenAddr).transfer(msg.sender, adminProfit[msg.sender][tokenAddr]); // total  token profit is transfered to admin\r\n            adminProfit[msg.sender][tokenAddr]=0;// set 0 to admin token profit after transfer\r\n        }\r\n            return true;\r\n        }\r\n        \r\n        \r\n    function setwithdrawfee(address[] memory addr,uint120[] memory feeamount)public returns(bool)  // admin can set withdraw fee for token and ether\r\n        {\r\n          require(msg.sender==admin);\r\n          //array length should be within 10.\r\n          require(addr.length <10 && feeamount.length < 10 && addr.length==feeamount.length);\r\n          for(uint8 i=0;i<addr.length;i++){\r\n                withdrawfee[addr[i]]=feeamount[i];   \r\n                tokendetails[addr[i]].withdrawFee = feeamount[i];   //storing value of fee   \r\n          }\r\n           return true;\r\n        }\r\n\r\n    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) { // vrs signature verification\r\n        string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n        uint256 lengthOffset;\r\n        uint256 length;\r\n        assembly {\r\n            length := mload(message)\r\n            lengthOffset := add(header, 57)\r\n        }\r\n        require(length <= 999999);\r\n        uint256 lengthLength = 0;\r\n        uint256 divisor = 100000; \r\n        while (divisor != 0) {\r\n            uint256 digit = length.div(divisor);\r\n            if (digit == 0) {\r\n             \r\n                if (lengthLength == 0) {\r\n                      divisor = divisor.div(10);\r\n                      continue;\r\n                    }\r\n            }\r\n            lengthLength++;\r\n            length = length.sub(digit.mul(divisor));\r\n            divisor = divisor.div(10);\r\n            digit = digit.add(0x30);\r\n            lengthOffset++;\r\n            assembly {\r\n                mstore8(lengthOffset, digit)\r\n            }\r\n        }  \r\n        if (lengthLength == 0) {\r\n            lengthLength = 1 + 0x19 + 1;\r\n        } else {\r\n            lengthLength = lengthLength.add(1 + 0x19);\r\n        }\r\n        assembly {\r\n            mstore(header, lengthLength)\r\n        }\r\n        bytes32 check = keccak256(abi.encodePacked(header, message));\r\n        return ecrecover(check, v, r, s);\r\n    }\r\n    \r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n \r\n    function addressToString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n    \r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n \r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n \r\n    // makerOrder\r\n      // 0- orderid\r\n      // 1- quantity\r\n      // 2- price\r\n      // 3 - type  1- buy 2- sell\r\n      // 4- expiryTime\r\n      // 5 - trade amount\r\n      // 6 - buyer dex token status\r\n      // 7 - trade fee\r\n  \r\n    // takerOrder\r\n      // 0- orderid\r\n      // 1- quantity\r\n      // 2- price\r\n      // 3 - type  1- buy 2- sell\r\n      // 4- expiryTime\r\n      // 5 - trade amount\r\n      // 6 - buyer dex token status\r\n      // 7 - trade fee\r\n  \r\n    // tradeAddress\r\n    // 0- makertokenAddress\r\n    // 1- makeruserAddress\r\n    // 2 - takertokenaddress\r\n    // 3 - takeruseraddress\r\n    function makeOrder(uint128[8] memory makerOrder, uint128[8] memory takerOrder,address[4] memory tradeAddress,uint8[2] memory  v,bytes32[4] memory rs) onlyFeeAddress public returns(bool){\r\n        require(tradeOrders[makerOrder[0]]!=true && tradeOrders[takerOrder[0]] !=true);\r\n        require(makerOrder[4]>=block.timestamp && takerOrder[4]>=block.timestamp);  // expiry time less than current time\r\n        uint256 amount__m;\r\n        uint256 amount__t;\r\n        makerOrder[6]=0;\r\n        takerOrder[6]=0;\r\n        \r\n        \r\n        if(Order[makerOrder[0]].status ==0){ // if maker order is new;  && tradeAddress[0]!=feeTokenAddress\r\n            // if maker buy or sell but receiving amt is fee token \r\n            if(tradeAddress[2]==feeTokenAddress){\r\n                (feeTokenStatus) ? makerOrder[6]=1 : makerOrder[6]=0;\r\n            }\r\n            else{\r\n                require(userDetails[tradeAddress[1]][feeTokenAddress]>=makerOrder[7]);   // trade will happen event if fee amount is unset\r\n                makerOrder[6]=1;\r\n                if(tradeAddress[0] == feeTokenAddress ){\r\n                  amount__m =amount__m.add(makerOrder[7]);\r\n                }\r\n            }\r\n            // vrs verification  for maker  when order is new;\r\n            require(verify(strConcat(uint2str(makerOrder[0]),addressToString(tradeAddress[0]),uint2str(makerOrder[2]),uint2str(makerOrder[1]),uint2str(makerOrder[4])),v[0],rs[0],rs[1])==tradeAddress[1]);\r\n            makerOrder[5] = makerOrder[1];\r\n        }\r\n        else{\r\n            require(Order[makerOrder[0]].tradeQuantity > 0);\r\n           \r\n            makerOrder[2] = Order[makerOrder[0]].price;\r\n            makerOrder[3] = Order[makerOrder[0]].type_;\r\n            makerOrder[5] = Order[makerOrder[0]].tradeQuantity;\r\n            tradeAddress[0] = Order[makerOrder[0]].tokenAddress;\r\n            tradeAddress[1] = Order[makerOrder[0]].userAddress;\r\n        }\r\n\r\n        if(Order[takerOrder[0]].status ==0){  // if taker order is new;\r\n            // if taker buy or sell but receiving amt is fee token \r\n            if(tradeAddress[0]==feeTokenAddress){\r\n                (feeTokenStatus) ? takerOrder[6]=1 : takerOrder[6]=0;\r\n            }\r\n            else{\r\n                // trade will happen even if fee amount is unset\r\n                require(userDetails[tradeAddress[3]][feeTokenAddress]>=takerOrder[7]);      \r\n                takerOrder[6]=1;\r\n                \r\n                if(tradeAddress[2] == feeTokenAddress){\r\n                    amount__t =amount__t.add(takerOrder[7]);\r\n                }\r\n            }\r\n            // vrs verification  for taker  when order is new;\r\n            require(verify(strConcat(uint2str(takerOrder[0]),addressToString(tradeAddress[2]),uint2str(takerOrder[2]),uint2str(takerOrder[1]),uint2str(takerOrder[4])),v[1],rs[2],rs[3])==tradeAddress[3]);\r\n            takerOrder[5] = takerOrder[1];\r\n        }\r\n        else{\r\n            require(Order[takerOrder[0]].tradeQuantity > 0);\r\n            takerOrder[2] = Order[takerOrder[0]].price;\r\n            takerOrder[3] = Order[takerOrder[0]].type_;\r\n            takerOrder[5] = Order[takerOrder[0]].tradeQuantity;\r\n            tradeAddress[2] = Order[takerOrder[0]].tokenAddress;\r\n            tradeAddress[3] = Order[takerOrder[0]].userAddress;\r\n        }\r\n\r\n        uint128 tradeAmount;\r\n\r\n        if(takerOrder[5] > makerOrder[5]){\r\n            tradeAmount = makerOrder[5];\r\n        }\r\n        else{\r\n            tradeAmount = takerOrder[5];\r\n        }\r\n        \r\n        //if maker order is buy \r\n        if(makerOrder[3] == 1){ \r\n            amount__m =amount__m.add(((tradeAmount)*(makerOrder[2]))/tokendetails[tradeAddress[0]].decimals) ; // maker buy trade amount\r\n            amount__t =amount__t.add(tradeAmount);  // taker sell trade amount;\r\n        }\r\n        else{    //else maker order is sell \r\n            amount__m = amount__m.add(tradeAmount); // maker sell trade amount\r\n            amount__t = amount__t.add(tradeAmount*(makerOrder[2])/ tokendetails[tradeAddress[2]].decimals); // taker sell trade amount\r\n        }\r\n        \r\n        if(userDetails[tradeAddress[1]][tradeAddress[0]]<amount__m){  // trade amount <= maker balance;\r\n            return false;\r\n        }\r\n        \r\n        if(userDetails[tradeAddress[3]][tradeAddress[2]]<amount__t){ // trader amount <= taker balance\r\n            return false;\r\n        }\r\n\r\n        if(takerOrder[5] > makerOrder[5]){\r\n            if(Order[takerOrder[0]].status!=1){\r\n                Order[takerOrder[0]].userAddress = tradeAddress[3];\r\n                Order[takerOrder[0]].type_ = takerOrder[3];\r\n                Order[takerOrder[0]].price = takerOrder[2];\r\n                Order[takerOrder[0]].quantity  = takerOrder[1];\r\n                Order[takerOrder[0]].tradeQuantity  = takerOrder[5];\r\n                Order[takerOrder[0]].tokenAddress = tradeAddress[2];\r\n                Order[takerOrder[0]].status=1; // storing taker order details and updating status to 1\r\n            }\r\n            Order[takerOrder[0]].tradeQuantity -=tradeAmount; \r\n            Order[makerOrder[0]].tradeQuantity=0;\r\n            tradeOrders[makerOrder[0]] = true;\r\n        }\r\n        else if(takerOrder[5] < makerOrder[5]){\r\n            if(Order[makerOrder[0]].status!=1  ){\r\n                Order[makerOrder[0]].userAddress = tradeAddress[1];\r\n                Order[makerOrder[0]].type_ = makerOrder[3];\r\n                Order[makerOrder[0]].price = makerOrder[2];\r\n                Order[makerOrder[0]].quantity  = makerOrder[1];\r\n                Order[makerOrder[0]].tradeQuantity  =  makerOrder[5];\r\n                Order[makerOrder[0]].tokenAddress = tradeAddress[0];\r\n                Order[makerOrder[0]].status=1; // storing maker order details and updating status to 1     \r\n             }\r\n            Order[makerOrder[0]].tradeQuantity -=tradeAmount;\r\n            Order[takerOrder[0]].tradeQuantity=0;\r\n            tradeOrders[takerOrder[0]] = true;\r\n        }\r\n        else{\r\n            Order[makerOrder[0]].tradeQuantity=0;\r\n            Order[takerOrder[0]].tradeQuantity=0;\r\n            tradeOrders[makerOrder[0]] = true;\r\n            tradeOrders[takerOrder[0]] = true;\r\n        }\r\n        // maker receive amount\r\n        makerOrder[5] = uint128(amount__t); \r\n        // taker receive amount\r\n        takerOrder[5] = uint128(amount__m);\r\n                    \r\n        if(makerOrder[6]==1 ){\r\n            // If maker is seller and token sold is feetoken\r\n            // fee is deducted from the user(maker) and admin balance(feetoken) is updated\r\n            if(tradeAddress[0] == feeTokenAddress){\r\n                amount__m = amount__m.sub(makerOrder[7]);\r\n                takerOrder[5]=sub128(takerOrder[5],uint128(makerOrder[7]));\r\n                // reduce user balance\r\n                userDetails[tradeAddress[1]][feeTokenAddress] =userDetails[tradeAddress[1]][feeTokenAddress].sub(makerOrder[7]);\r\n                // update admin balance\r\n                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(makerOrder[7]).div(2));\r\n                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[7]).div(2));\r\n            }\r\n            // If maker is buyer and token buy is fee token or maker is seller and receiving token is fee token.\r\n            else if(tradeAddress[2] == feeTokenAddress){\r\n                // trade amount >= feeAmount\r\n                if(makerOrder[5]>=makerOrder[7]){\r\n                    makerOrder[5] = sub128(makerOrder[5],uint128(makerOrder[7]));\r\n                    adminProfit[admin][feeTokenAddress] = adminProfit[admin][feeTokenAddress].add(uint(makerOrder[7]).div(2));     \r\n                    adminProfit[admin2][feeTokenAddress] = adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[7]).div(2));     \r\n                }\r\n                // trade amount < feeAmount\r\n                // admin  blance is update with trade amount\r\n                // trade amount is set to 0\r\n                else{\r\n                    adminProfit[admin][feeTokenAddress] = adminProfit[admin][feeTokenAddress].add(uint(makerOrder[5]).div(2));\r\n                    adminProfit[admin2][feeTokenAddress] = adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[5]).div(2));\r\n                    // hence reset to 0\r\n                    makerOrder[5] = 0;\r\n                }\r\n            }\r\n            // general trade for tokens other than feetoken\r\n            else{\r\n                userDetails[tradeAddress[1]][feeTokenAddress] =userDetails[tradeAddress[1]][feeTokenAddress].sub(makerOrder[7]);\r\n                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(makerOrder[7]).div(2));\r\n                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[7]).div(2));\r\n            }\r\n        }\r\n            \r\n        if(takerOrder[6]==1){\r\n            // If taker is seller and token sold is feetoken\r\n            // fee is deducted from the user(taker) and admin balance(feetoken) is updated\r\n            if(tradeAddress[2] == feeTokenAddress){\r\n                amount__t = amount__t.sub(takerOrder[7]);\r\n                makerOrder[5] =sub128(makerOrder[5],uint128(takerOrder[7]));\r\n                // reduce user balance\r\n                userDetails[tradeAddress[3]][feeTokenAddress] = userDetails[tradeAddress[3]][feeTokenAddress].sub(takerOrder[7]);\r\n                // update admin balance\r\n                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(takerOrder[7]).div(2));  \r\n                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[7]).div(2));  \r\n            }\r\n            // If taker is buyer and token buy is fee token or taker is seller and receiving token is fee token.\r\n            else if(tradeAddress[0] == feeTokenAddress){\r\n                // user balance >= fee amount\r\n                // fee is deducted from the user(taker) and admin balance(feetoken) is updated\r\n              \r\n                // trade amount >= feeAmount\r\n                if(takerOrder[5]>=takerOrder[7]){\r\n                    takerOrder[5] = sub128(takerOrder[5],uint128(takerOrder[7]));\r\n                    adminProfit[admin][feeTokenAddress] = adminProfit[admin][feeTokenAddress].add(uint(takerOrder[7]).div(2));\r\n                    adminProfit[admin2][feeTokenAddress] = adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[7]).div(2));\r\n                }\r\n                // trade amount < feeAmount\r\n                // admin  blance is update with trade amount\r\n                // trade amount is set to 0\r\n                else{\r\n                    adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(takerOrder[5]).div(2));        \r\n                    adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[5]).div(2));   \r\n                    \r\n                    takerOrder[5]=0;\r\n                }\r\n                \r\n            }\r\n            // general trade for tokens other than feetoken\r\n            else{\r\n                userDetails[tradeAddress[3]][feeTokenAddress] = userDetails[tradeAddress[3]][feeTokenAddress].sub(takerOrder[7]);\r\n                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(takerOrder[7]).div(2));   \r\n                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[7]).div(2));   \r\n            }\r\n        }\r\n                    \r\n        // decrease taker and maker's balance with trade amount;\r\n        userDetails[tradeAddress[1]][tradeAddress[0]] = userDetails[tradeAddress[1]][tradeAddress[0]].sub(amount__m);   // freeze buyer amount   \r\n        userDetails[tradeAddress[3]][tradeAddress[2]] = userDetails[tradeAddress[3]][tradeAddress[2]].sub(amount__t);   // freeze buyer amount \r\n        \r\n        //trading\r\n        userDetails[tradeAddress[1]][tradeAddress[2]] = userDetails[tradeAddress[1]][tradeAddress[2]].add(makerOrder[5]); //marker order\r\n        userDetails[tradeAddress[3]][tradeAddress[0]] = userDetails[tradeAddress[3]][tradeAddress[0]].add(takerOrder[5]); //take order\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function sub128(uint128 a, uint128 b) internal pure  returns (uint128) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n     function viewTokenBalance(address tokenAddr,address baladdr)public view returns(uint256){ // to check token balance\r\n        return Token(tokenAddr).balanceOf(baladdr);\r\n    }\r\n    \r\n    function tokenallowance(address tokenAddr,address owner,address _spender) public view returns(uint256){ // to check token allowance to contract\r\n        return Token(tokenAddr).allowance(owner,_spender);\r\n    }\r\n    \r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_admin1\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_admin2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feetokenaddress_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_\",\"type\":\"uint256\"}],\"name\":\"DepositandWithdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Order\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"type_\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"tradeQuantity\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"decimal_\",\"type\":\"uint128\"},{\"internalType\":\"uint120\",\"name\":\"withdrawFee_\",\"type\":\"uint120\"}],\"name\":\"addToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin2\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"adminProfitWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"changeAdminaddress\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"changeFeeaddress\",\"type\":\"address\"}],\"name\":\"changeFeeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTokenStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128[8]\",\"name\":\"makerOrder\",\"type\":\"uint128[8]\"},{\"internalType\":\"uint128[8]\",\"name\":\"takerOrder\",\"type\":\"uint128[8]\"},{\"internalType\":\"address[4]\",\"name\":\"tradeAddress\",\"type\":\"address[4]\"},{\"internalType\":\"uint8[2]\",\"name\":\"v\",\"type\":\"uint8[2]\"},{\"internalType\":\"bytes32[4]\",\"name\":\"rs\",\"type\":\"bytes32[4]\"}],\"name\":\"makeOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status_\",\"type\":\"bool\"}],\"name\":\"setDexStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeTokenaddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setFeeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"uint120[]\",\"name\":\"feeamount\",\"type\":\"uint120[]\"}],\"name\":\"setwithdrawfee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"tokenallowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokendetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"decimals\",\"type\":\"uint128\"},{\"internalType\":\"uint120\",\"name\":\"withdrawFee\",\"type\":\"uint120\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tradeOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baladdr\",\"type\":\"address\"}],\"name\":\"viewTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SeekRewardsDex","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cf49e1ba6954f02d321e09c0f8e947957074c6b800000000000000000000000046221c12bcf1a59c2e7763c04ac2ad4e0d7aec4e0000000000000000000000008b39a01eb15037d4086e1d89e1124dcac53ca36b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://366ca3d0a3195db86599ea4ebd5b6a6adaaeb5ca20bbac26df7efa373297228f"}]}