{"status":"1","message":"OK","result":[{"SourceCode":"pragma abicoder v2;\r\npragma solidity ^0.7.0;\r\n\r\ncontract MultiBalances {\r\n    \r\n  struct TokensToCheck {\r\n        address holder_address;\r\n        address[] token_addresses;\r\n    }\r\n    \r\n    struct Balance {\r\n        address token_address;\r\n        uint balance;\r\n    }\r\n    \r\n    struct Balances {\r\n        address holder_address;\r\n        Balance[] balances;\r\n    }\r\n\r\n  /* public functions */\r\n\r\n  /* Check the ERC20 token balances of a wallet for multiple tokens.\r\n     Returns array of token balances in wei units. */\r\n  function tokenBalances(address user,  address[] calldata tokens) external view returns (uint[] memory balances) {\r\n    balances = new uint[](tokens.length);\r\n    \r\n    for(uint i = 0; i < tokens.length; i++) {\r\n      if(tokens[i] != address(0x0)) { \r\n        balances[i] = tokenBalance(user, tokens[i]); // check token balance and catch errors\r\n      } else {\r\n        balances[i] = user.balance; // ETH balance    \r\n      }\r\n    }    \r\n    return balances;\r\n  }\r\n  \r\n  function balancesOneByOne(TokensToCheck[] calldata tokensToCheck) external view returns (Balances[] memory balances) {\r\n      Balances[] memory balances = new Balances[](tokensToCheck.length);\r\n      \r\n      for(uint i = 0; i < tokensToCheck.length; i++) { // holder address and token addresses\r\n        address holderAddress = tokensToCheck[i].holder_address;\r\n        address[] memory tokenAddresses = tokensToCheck[i].token_addresses;\r\n        Balance[] memory tokenBalances = new Balance[](tokenAddresses.length);\r\n        \r\n        for(uint j = 0; j < tokenAddresses.length; j++) { // token addresses\r\n              if (tokenAddresses[j] != address(0x0)) { \r\n                tokenBalances[j] = Balance(address(tokenAddresses[j]), tokenBalance(holderAddress, tokenAddresses[j]));\r\n              } else {\r\n                tokenBalances[j] = Balance(address(0x0), address(holderAddress).balance); // ETH balance    \r\n              }\r\n          }\r\n          balances[i] = Balances(holderAddress, tokenBalances);\r\n      }\r\n      return balances;\r\n    }\r\n\r\n  \r\n /* Private functions */\r\n\r\n /* Check the token balance of a wallet in a token contract.\r\n    Returns 0 on a bad token contract   */\r\n  function tokenBalance(address user, address token) internal view returns (uint) {\r\n    // token.balanceOf(user), selector 0x70a08231\r\n    return getNumberOneArg(token, 0x70a08231, user);\r\n  }\r\n  \r\n  /* Generic private functions */\r\n  \r\n  // Get a token or exchange value that requires 1 address argument (most likely arg1 == user).\r\n  // selector is the hashed function signature (see top comments)\r\n  function getNumberOneArg(address contractAddr, bytes4 selector, address arg1) internal view returns (uint) {\r\n    if(isAContract(contractAddr)) {\r\n      (bool success, bytes memory result) = contractAddr.staticcall(abi.encodeWithSelector(selector, arg1));\r\n      // if the contract call succeeded & the result looks good to parse\r\n      if(success && result.length == 32) {\r\n        return abi.decode(result, (uint)); // return the result as uint\r\n      } else {\r\n        return 0; // function call failed, return 0\r\n      }\r\n    } else {\r\n      return 0; // not a valid contract, return 0 instead of error\r\n    }\r\n  }\r\n\r\n  \r\n  // check if contract (token, exchange) is actually a smart contract and not a 'regular' address\r\n  function isAContract(address contractAddr) internal view returns (bool) {\r\n    uint256 codeSize;\r\n    assembly { codeSize := extcodesize(contractAddr) } // contract code size\r\n    return codeSize > 0; \r\n    // Might not be 100% foolproof, but reliable enough for an early return in 'view' functions \r\n  }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder_address\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"token_addresses\",\"type\":\"address[]\"}],\"internalType\":\"struct MultiBalances.TokensToCheck[]\",\"name\":\"tokensToCheck\",\"type\":\"tuple[]\"}],\"name\":\"balancesOneByOne\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"holder_address\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiBalances.Balance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MultiBalances.Balances[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultiBalances","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4d075676e793e88886955120f383def6fad07971c35490222e8c02a135bb96ca"}]}