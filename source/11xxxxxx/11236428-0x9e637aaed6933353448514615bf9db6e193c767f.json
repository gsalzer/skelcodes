{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\ncontract WasBonus {\r\n    using SafeMath for uint;\r\n    \r\n    address public wasaddr;  //was token address\r\n    address public wasFarmer; //wasFarmer contract\r\n    address public owner; //owner\r\n    uint public allTotalApply; //record all apply amount\r\n    uint public totalWithdraw; //record total withdraw number;\r\n    uint public beginTimestamp; // the timestamp of deploy contract\r\n    uint public limitTime = 86400; // time period for epoch\r\n    uint public oneEth = 1 ether;\r\n    uint public minCurry = 500; //the min curry from user\r\n    uint public currentEpoch;  //start from 0 ,whern setNextEpoch() ,record newest epoch \r\n    uint public hasMintedWas; //record all will min was token amount;\r\n    uint public hasMintedNotWithdraw; //record the amount of user will withdraw\r\n    uint public currentEpochWaitWas; //current was available\r\n    \r\n    constructor(address _wasaddr,address _wasFarmer) public {\r\n        wasaddr = _wasaddr;\r\n        wasFarmer = _wasFarmer;\r\n        owner = msg.sender;\r\n        beginTimestamp = 1605110400; // UTC +8  2020-11-12-00-00\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    struct UserData {\r\n        uint firstEpoch; // epoch of user first apply \r\n        uint applyTimes; // record user apply times\r\n        uint applyAmount; // record user apply number;\r\n        uint withdrawAmount; // record user withdraw;\r\n        uint lastEpoch; // record user apply newest epoch;\r\n        bool isWithDraw;\r\n    }\r\n    mapping (address => UserData) public userData;\r\n    mapping (address => mapping(uint => uint)) public userApplyAmount;\r\n    mapping (uint => uint) public epochApplyTotal;\r\n    mapping (uint => uint) public accPerEpochReward;\r\n\r\n    address[] public userArr;\r\n    //change new owner;\r\n    function transferOwner(address _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n    //set time period for epoch\r\n    function setLimitTime(uint _limitTime) public onlyOwner {\r\n        limitTime = _limitTime;\r\n    }\r\n    //set min curry from user;\r\n    function setMinCurry(uint _newMinCurry) public onlyOwner {\r\n        minCurry = _newMinCurry;\r\n    }\r\n      //set beginBlockTimestamp  ;\r\n    function setBeginBlockTimestamp(uint beginBlockTimestamp ) public onlyOwner {\r\n        beginTimestamp = beginBlockTimestamp;\r\n    }\r\n    //get current epoch;\r\n    function curEpoch() public view returns(uint){\r\n        return uint(block.timestamp.sub(beginTimestamp)/limitTime).add(1);\r\n    }\r\n    //user apply to do \r\n    function applyUser() public {\r\n        require(userApplyAmount[msg.sender][curEpoch()] == 0);\r\n        // curryBals = curryBals.mul(oneEth);\r\n        uint curryBals = IwasFarmer(wasFarmer).checkUserPairTotalLpCurry(msg.sender);\r\n        \r\n        require(curryBals >= oneEth.mul(minCurry));\r\n        UserData storage user = userData[msg.sender];\r\n        if(user.firstEpoch ==0){\r\n            user.firstEpoch = curEpoch();\r\n            user.withdrawAmount = 0;\r\n            userArr.push(msg.sender);\r\n        }\r\n        user.applyAmount = user.applyAmount.add(curryBals);\r\n        user.applyTimes = user.applyTimes.add(1);\r\n\r\n        if(user.isWithDraw){\r\n            user.lastEpoch = curEpoch();\r\n            user.isWithDraw = false;\r\n        }\r\n        \r\n        userApplyAmount[msg.sender][curEpoch()] = curryBals;\r\n        \r\n        epochApplyTotal[curEpoch()] = epochApplyTotal[curEpoch()].add(curryBals);\r\n        allTotalApply = allTotalApply.add(curryBals);\r\n        //update and calculate last epoch unitReward;\r\n        if(currentEpoch ==0){\r\n            currentEpoch = curEpoch();\r\n        }\r\n        setNextEpoch();\r\n    }\r\n    \r\n    //user getReward to do;\r\n    function getReward() public {\r\n        require(userData[msg.sender].applyAmount > 0);\r\n        require(curEpoch() > 0);\r\n        require(curEpoch() > userData[msg.sender].lastEpoch);\r\n        \r\n        uint lastEpoch = userData[msg.sender].lastEpoch;\r\n        uint reward = viewReward(msg.sender,lastEpoch ,currentEpoch);\r\n        require(reward >0);\r\n        safeTransfer(msg.sender,reward);\r\n        userData[msg.sender].withdrawAmount = userData[msg.sender].withdrawAmount.add(reward);\r\n        userData[msg.sender].lastEpoch = currentEpoch;\r\n        userData[msg.sender].isWithDraw = true;\r\n        totalWithdraw = totalWithdraw.add(reward);\r\n        hasMintedNotWithdraw = hasMintedNotWithdraw.sub(reward);\r\n        //update and calculate last epoch unitReward;\r\n        setNextEpoch();\r\n    }\r\n\r\n    //\r\n    function setNextEpoch() public {\r\n        if(curEpoch() > currentEpoch){\r\n            if(epochApplyTotal[currentEpoch] >0 && totalWas() > hasMintedNotWithdraw){\r\n                uint newWasBal = totalWas().sub(hasMintedNotWithdraw);\r\n                uint epochReward = newWasBal.mul(1e12).div(epochApplyTotal[currentEpoch]);\r\n                accPerEpochReward[currentEpoch] = epochReward;\r\n                hasMintedWas = hasMintedWas.add(newWasBal);\r\n                hasMintedNotWithdraw = hasMintedNotWithdraw.add(newWasBal);\r\n            }\r\n            currentEpoch = curEpoch();\r\n        }\r\n    }\r\n    \r\n    function safeTransfer(address _to,uint _amount) internal {\r\n        uint balance = totalWas();\r\n        if(_amount > balance){\r\n            IERC20(wasaddr).transfer(_to,balance);\r\n        }else{\r\n            IERC20(wasaddr).transfer(_to,_amount);\r\n        }\r\n    }\r\n    function userLen() public view returns(uint){\r\n        return userArr.length;\r\n    }\r\n    \r\n    function totalWas() public view returns(uint){\r\n        return IERC20(wasaddr).balanceOf(address(this));\r\n    }\r\n    \r\n    function viewReward(address _user,uint _start,uint _end) public view returns(uint){\r\n        \r\n        uint totalReward;\r\n        for(uint i=_start;i<=_end;i++){\r\n            uint perAcc = accPerEpochReward[i];\r\n            if(perAcc > 0){\r\n               uint applyAmount =  userApplyAmount[_user][i];\r\n               if(applyAmount > 0){\r\n                   totalReward = totalReward.add(perAcc.mul(applyAmount).div(1e12));\r\n               }\r\n            }\r\n        }\r\n        return totalReward;\r\n    }\r\n\r\n    function viewRewardCur(address _user) public view returns(uint){\r\n        uint curWas = totalWas().sub(hasMintedNotWithdraw);\r\n        uint userApply = userApplyAmount[_user][curEpoch()];\r\n        if(userApply > 0){\r\n            return userApply.mul(curWas).div(epochApplyTotal[curEpoch()]);\r\n        }\r\n    }\r\n    \r\n    //when valid contract will be something problem or others;\r\n    bool isValid;\r\n    function setGetInvalid(address _receive) public onlyOwner {\r\n        require(!isValid);\r\n        IERC20(wasaddr).transfer(_receive,IERC20(wasaddr).balanceOf(address(this)));\r\n    }\r\n    //if valid contract is ok,that will be change isvalid ;\r\n    function setValidOk() public onlyOwner {\r\n        require(!isValid);\r\n        isValid = true;\r\n    }\r\n}\r\ninterface IERC20{\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IwasFarmer {\r\n    function checkUserPairTotalLpCurry(address _user)external view returns(uint);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wasaddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wasFarmer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accPerEpochReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTotalApply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applyUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beginTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochWaitWas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochApplyTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasMintedNotWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasMintedWas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minCurry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"beginBlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"setBeginBlockTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receive\",\"type\":\"address\"}],\"name\":\"setGetInvalid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitTime\",\"type\":\"uint256\"}],\"name\":\"setLimitTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinCurry\",\"type\":\"uint256\"}],\"name\":\"setMinCurry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setNextEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setValidOk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userApplyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userArr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"firstEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"applyTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"applyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastEpoch\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithDraw\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"viewReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewRewardCur\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wasFarmer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wasaddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WasBonus","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa94ffeebb5c382e7f4eb3ea536b5ac73b73de180000000000000000000000006e1b9e39069c7ab291d4631b37d9c4d434952afd","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fe3c1a0047afabd055c53a543074afc96f84d30fdf2b6fc6a8166fa7b983ac5e"}]}