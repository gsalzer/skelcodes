{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: UNLICENSED\r\n//Check before deployment: Hardcoded token contract address, pair address\r\n\r\n/*\r\nGeneric presale contract for ERC20 token.\r\nImportant: Set gas limit to 210000 if sending ether directly! It reserves much but consumes max 80%.\r\n\r\nPresale allows buying specified ERC20 for rate mentioned in constructor.\r\nAllowed amounts: 0.05 ETH to 0.5 ETH.\r\nPresale ends once there is no supply left.\r\nOnce eth is sent to this presale contract sender gets their tokens, eth is wrapped and sent \r\ndirectly to the liquidity pool along with the same amount of tokens. The pool is synced \r\nto reflect new ratio right away and calculates token price correctly.\r\nNeither ERC20 nor ETH goes to any wallet except token to buyer. Deployer will receive no ether \r\nfrom this presale.\r\nThis makes liquidity continuously inflating and keeping price near presale price ratio\r\nby keeping either the presale or direct uniswap trade cheaper at every moment.\r\nOnce presale ends there is enough ether liquidity and the price can start going up!\r\n\r\n*/\r\n\r\npragma solidity =0.7.6;\r\n\r\ninterface UNIV2Sync {\r\n    function sync() external;\r\n}\r\n\r\ninterface IERC {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function feeDistributor() external view returns (address);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function balanceOf(address _owner) external returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function withdraw(uint256 _amount) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Presale {\r\n    using Address for address;\r\n\r\n    address public token;\r\n    address public pair;\r\n    address public wethContract;\r\n    uint256 public rate;\r\n    uint256 public weiRaised;\r\n    \r\n    constructor() {\r\n        rate = 5e9; //16.5M2e = 8 eth -> 2M2e = 2e8 = 1/5 e9 = 1e18 wei/5e9, 1M2e = 0.5\r\n        weiRaised = 0;\r\n        token = 0x8937041C8C52a78c25aa54051F6a9dAdA23D42A2; //mainnet\r\n        pair = 0x76d629ebAD7fDf703Ed5923f41F20c472e8F23E3; //mainnet\r\n        //wethContract = 0xc778417E063141139Fce010982780140Aa0cD5Ab; //ropsten\r\n        wethContract = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; //mainnet\r\n    }\r\n\r\n    receive() external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n    \r\n    function buyTokens(address _beneficiary) public payable {\r\n        require(msg.sender == tx.origin); //no automated arbitrage\r\n        require(_beneficiary != address(0));\r\n        require(msg.value >= 5e16 wei && msg.value <= 5e17 wei);\r\n        uint256 tokens = msg.value/rate; \r\n        weiRaised+=msg.value;\r\n        IERC(token).transfer(_beneficiary,tokens);\r\n        IERC(token).transfer(pair,tokens);\r\n        //Convert any ETH to WETH (always).\r\n        uint256 amountETH = address(this).balance;\r\n        if (amountETH > 0) {\r\n            IWETH(wethContract).deposit{value : amountETH}();\r\n        }\r\n        uint256 amountWETH =  IWETH(wethContract).balanceOf(address(this));\r\n        //Sends weth to pool\r\n        if (amountWETH > 0) {\r\n            IWETH(wethContract).transfer(pair, amountWETH);\r\n        }\r\n        UNIV2Sync(pair).sync(); //important to reflect updated price\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ERC20Presale","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://186abb548c46d37bb19a37b50c0282a50a673f8511d96fd82c6655668860cf12"}]}