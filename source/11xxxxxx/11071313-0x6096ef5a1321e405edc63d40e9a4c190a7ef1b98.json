{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.1;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nabstract contract ERC20Basic {\r\n    function totalSupply() external virtual returns (uint);\r\n    function balanceOf(address who) public virtual view returns (uint);\r\n    function transfer(address to, uint value) public virtual;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\nabstract contract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view virtual returns (uint);\r\n    function transferFrom(address from, address to, uint value) public virtual;\r\n    function approve(address spender, uint value) public virtual;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nabstract contract BasicToken is ERC20Basic {\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) balances;\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n\r\n    function balanceOf(address _owner) public override virtual view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\nabstract contract StandardToken is BasicToken, ERC20 {\r\n    using SafeMath for uint;\r\n    \r\n    enum ETransferType{\r\n        transferTo,\r\n        transferFrom,\r\n        transferToTeam\r\n    }\r\n    \r\n    mapping (address => mapping (address => uint)) allowed;\r\n    \r\n    address internal devAddress = 0xBBa154c29688A7422348f68474443b5665d6d92F;\r\n    address internal marketingAddress = 0xFDb4a96229104d7A2F82D520EfD4CffCF6BBe663;\r\n    address internal adviserAddress = 0x544A4d166a1335F50a836F17F01f18Bf2011a440;\r\n    \r\n    address internal privateSaleAddress = 0xaE1F789fAEAAe491327BC84EA5435EdE0d895F67;\r\n    address internal publicSaleAddress = 0x6700e2CF974Bd32014f4C6F1fa35E0DcFDdE7f91;\r\n    address internal communityAddress = 0xBc6F3E510Ca895828c777d1631891D2a8957F36D;\r\n    \r\n    //Specify time that team addresses can transfer token\r\n    uint256 internal teamAddressCanTransferTimestamp = 1609459200;  //01-01-2021\r\n    \r\n    function transfer(address _to, uint _value) public override virtual onlyPayloadSize(2 * 32) {\r\n        _transfer(msg.sender,_to,_value, ETransferType.transferTo);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) public virtual override onlyPayloadSize(3 * 32) {\r\n        validateNotTransferToTeamAddress(recipient);\r\n        validateTeamCanOnlyTransferAfterConfiguredTime(sender);\r\n        \r\n         require(balances[sender] >= amount && amount > 0, \"Not enough balance\");\r\n         require(allowance(sender, _msgSender()) >= amount,\"Allowance is not enough\");\r\n         \r\n        balances[sender] = balances[sender].sub(amount);\r\n        balances[recipient] = balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount, ETransferType transferType) internal {\r\n        require(balances[sender] >= amount);\r\n        \r\n        if(transferType != ETransferType.transferToTeam){\r\n            validateNotTransferToTeamAddress(recipient);\r\n            validateTeamCanOnlyTransferAfterConfiguredTime(sender);\r\n        }\r\n        \r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        balances[sender] = balances[sender].sub(amount);\r\n        balances[recipient] = balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public virtual override onlyPayloadSize(2 * 32) {\r\n        require(_value >= 0);\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public virtual view override returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function _msgSender() internal view returns(address){\r\n        return msg.sender;\r\n    }\r\n    \r\n    function validateNotTransferToTeamAddress(address recipient) internal view{\r\n        require(recipient!= devAddress,\"Can not transfer to dev address\");\r\n        require(recipient!= marketingAddress,\"Can not transfer to marketing address\");\r\n        require(recipient!= adviserAddress,\"Can not transfer to adviser address\");\r\n        require(recipient!= privateSaleAddress,\"Can not transfer to private sale address\");\r\n        require(recipient!= publicSaleAddress,\"Can not transfer to public sale address\");\r\n        require(recipient!= communityAddress,\"Can not transfer to community address\");\r\n    }\r\n    \r\n    function validateTeamCanOnlyTransferAfterConfiguredTime(address sender) internal view{\r\n        if(sender == devAddress || sender == marketingAddress || sender == adviserAddress){\r\n            require (_now() >= teamAddressCanTransferTimestamp,\"The team addresses is allowed to transfer after 01-01-2021\");\r\n        }\r\n    }\r\n    \r\n    function _now() internal view returns(uint256){\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\ncontract PFIToken is StandardToken {\r\n    modifier onlyOwner{\r\n        require(_msgSender() == owner, \"Fobidden\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    using SafeMath for uint;\r\n    \r\n    string public name = 'plain.finance';\r\n    string public symbol = 'PFI';\r\n    uint public decimals = 18;\r\n    uint256 public override totalSupply = 21500000000000000000000;\r\n    address public owner;\r\n\r\n    constructor () {\r\n        balances[_msgSender()] = totalSupply;\r\n        owner = _msgSender();\r\n        \r\n        _transferToTeam(devAddress, totalSupply.mul(87).div(1000)); //8.7%\r\n        _transferToTeam(marketingAddress, totalSupply.mul(8).div(100)); //8%\r\n        _transferToTeam(adviserAddress, totalSupply.mul(5).div(100)); //5%\r\n        _transferToTeam(privateSaleAddress, totalSupply.div(10)); //10%\r\n        _transferToTeam(publicSaleAddress, totalSupply.mul(3).div(10)); //30%\r\n        _transferToTeam(communityAddress, totalSupply.mul(383).div(1000)); //38.3%\r\n    }\r\n    \r\n    function mint(address account, uint256 amount) public onlyOwner {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n        balances[account] = balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n    \r\n    function burn(address account, uint256 amount) public onlyOwner  {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        balances[account] = balances[account].sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n    function _transferToTeam(address recipient, uint256 amount) internal {\r\n        _transfer(_msgSender(),recipient,amount, ETransferType.transferToTeam);\r\n    }\r\n\r\n    event Issue(uint amount);\r\n}\r\n\r\n// SPDX-License-Identifier: MIT","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Issue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PFIToken","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://393f7ec9739dffaf482a21b4c57ccdf902fe173e4ecdb04ac1ec014835a63d34"}]}