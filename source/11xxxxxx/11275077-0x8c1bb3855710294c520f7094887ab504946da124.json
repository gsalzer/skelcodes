{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITether {\n    function transferFrom(address _from, address _to, uint256 _value) external;\n\n    function transfer(address _to, uint256 _value) external;\n}\n\ncontract ITwoKeyAdmin {\n    function getDefaultIntegratorFeePercent() public view returns (uint);\n    function getDefaultNetworkTaxPercent() public view returns (uint);\n    function getTwoKeyRewardsReleaseDate() external view returns(uint);\n    function updateReceivedTokensAsModerator(uint amountOfTokens) public;\n    function updateReceivedTokensAsModeratorPPC(uint amountOfTokens, address campaignPlasma) public;\n    function addFeesCollectedInCurrency(string currency, uint amount) public payable;\n\n    function updateTokensReceivedFromDistributionFees(uint amountOfTokens) public;\n}\n\ncontract ITwoKeyEventSource {\n\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external;\n    function rejected(address _campaign, address _converter) external;\n\n    function convertedAcquisition(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonation(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external;\n\n    function executed(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external;\n\n    function tokensWithdrawnFromPurchasesHandler(\n        address campaignAddress,\n        uint _conversionID,\n        uint _tokensAmountWithdrawn\n    )\n    external;\n\n    function emitDebtEvent(\n        address _plasmaAddress,\n        uint _amount,\n        bool _isAddition,\n        string _currency\n    )\n    external;\n\n    function emitReceivedTokensToDeepFreezeTokenPool(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitReceivedTokensAsModerator(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitDAIReleasedAsIncome(\n        address _campaignContractAddress,\n        uint _amountOfDAI\n    )\n    public;\n\n    function emitEndedBudgetCampaign(\n        address campaignPlasmaAddress,\n        uint contractorLeftover,\n        uint moderatorEarningsDistributed\n    )\n    public;\n\n\n    function emitUserWithdrawnNetworkEarnings(\n        address user,\n        uint amountOfTokens\n    )\n    public;\n\n    function emitRebalancedRewards(\n        uint cycleId,\n        uint difference,\n        string action\n    )\n    public;\n}\n\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n    function getStableCoinTo2KEYQuota(address stableCoinAddress) public view returns (uint,uint);\n    function getStableCoinToUSDQuota(address stableCoin) public view returns (uint);\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract IUpgradableExchange {\n\n    function buyRate2key() public view returns (uint);\n    function sellRate2key() public view returns (uint);\n\n    function buyTokensWithERC20(\n        uint amountOfTokens,\n        address tokenAddress\n    )\n    public\n    returns (uint,uint);\n\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    returns (uint,uint);\n\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    public\n    payable;\n\n    function report2KEYWithdrawnFromNetwork(\n        uint amountOfTokensWithdrawn\n    )\n    public;\n\n    function getEth2DaiAverageExchangeRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint);\n\n    function getContractId(\n        address _contractAddress\n    )\n    public\n    view\n    returns (uint);\n\n    function getEth2KeyAverageRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint);\n\n    function returnLeftoverAfterRebalancing(\n        uint amountOf2key\n    )\n    public;\n\n\n    function getMore2KeyTokensForRebalancing(\n        uint amountOf2KeyRequested\n    )\n    public\n    view\n    returns (uint);\n\n\n    function releaseAllDAIFromContractToReserve()\n    public;\n\n    function setKyberReserveInterfaceContractAddress(\n        address kyberReserveContractAddress\n    )\n    public;\n\n    function setSpreadWei(\n        uint newSpreadWei\n    )\n    public;\n\n    function withdrawDAIAvailableToFill2KEYReserve(\n        uint amountOfDAI\n    )\n    public\n    returns (uint);\n\n    function returnTokensBackToExchangeV1(\n        uint amountOfTokensToReturn\n    )\n    public;\n\n\n    function getMore2KeyTokensForRebalancingV1(\n        uint amountOfTokensRequested\n    )\n    public;\n}\n\ncontract ITwoKeyBudgetCampaignsPaymentsHandlerStorage is IStructuredStorage{\n\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyBudgetCampaignsPaymentsHandler is Upgradeable, ITwoKeySingletonUtils {\n\n    using SafeMath for *;\n\n    /**\n     * State variables\n     * TO BE EXPANDED\n     */\n\n    string constant _campaignPlasma2initialBudget2Key = \"campaignPlasma2initialBudget2Key\";\n    string constant _campaignPlasma2isCampaignEnded = \"campaignPlasma2isCampaignEnded\";\n    string constant _campaignPlasma2contractor = \"campaignPlasma2contractor\";\n\n    string constant _campaignPlasma2isBudgetedWith2KeyDirectly = \"campaignPlasma2isBudgetedWith2KeyDirectly\";\n    string constant _campaignPlasma2StableCoinAddress = \"campaignPlasma2StableCoinAddress\";\n    string constant _campaignPlasma2rebalancingRatio = \"campaignPlasma2rebalancingRatio\";\n    string constant _campaignPlasma2initialRate = \"campaignPlasma2initalRate\";\n    string constant _campaignPlasma2bountyPerConversion2KEY = \"campaignPlasma2bountyPerConversion2KEY\";\n    string constant _campaignPlasma2amountOfStableCoins = \"campaignPlasma2amountOfStableCoins\";\n    string constant _numberOfDistributionCycles = \"numberOfDistributionCycles\";\n    string constant _distributionCycleToTotalDistributed = \"_distributionCycleToTotalDistributed\";\n    string constant _campaignPlasma2ReferrerRewardsTotal = \"campaignPlasma2ReferrerRewardsTotal\";\n    string constant _campaignPlasmaToModeratorEarnings = \"campaignPlasmaToModeratorEarnings\";\n    string constant _campaignPlasmaToLeftOverForContractor = \"campaignPlasmaToLeftOverForContractor\";\n    string constant _campaignPlasmaToLeftoverWithdrawnByContractor = \"campaignPlasmaToLeftoverWithdrawnByContractor\";\n    string constant _feePerCycleIdPerReferrer = \"feePerCycleIdPerReferrer\";\n\n    ITwoKeyBudgetCampaignsPaymentsHandlerStorage public PROXY_STORAGE_CONTRACT;\n\n    bool initialized;\n\n    function setInitialParams(\n        address _twoKeySingletonRegistry,\n        address _proxyStorageContract\n    )\n    public\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyBudgetCampaignsPaymentsHandlerStorage(_proxyStorageContract);\n\n        initialized = true;\n    }\n\n    /**\n     * ------------------------------------\n     *          Contractor actions\n     * ------------------------------------\n     */\n\n    /**\n     * @notice          Function which will be used in order to add inventory for campaign\n     *                  directly with 2KEY tokens. In order to make this\n     *                  transfer secure,\n     *                  user will firstly have to approve this contract to take from him\n     *                  amount of tokens and then call contract function which will execute\n     *                  transferFrom action. This function can be called only once.\n     *\n     * @param           campaignPlasma is the plasma campaign address which is user adding inventory for.\n     * @param           amountOf2KEYTokens is the amount of 2KEY tokens user adds to budget\n     */\n    function addInventory2KEY(\n        address campaignPlasma,\n        uint amountOf2KEYTokens,\n        uint bountyPerConversionFiat\n    )\n    public\n    {\n        // Require that budget is not previously set and assign amount of 2KEY tokens\n        requireBudgetNotSetAndSetBudget(campaignPlasma, amountOf2KEYTokens);\n        // Set that contractor is the msg.sender of this method for the campaign passed\n        setAddress(keccak256(_campaignPlasma2contractor, campaignPlasma), msg.sender);\n\n        // Get 2KEY sell rate at the moment\n        uint rate = IUpgradableExchange(getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\")).sellRate2key();\n\n        // calculate bounty per conversion 2KEY\n        uint bountyPerConversion2KEY = bountyPerConversionFiat.mul(10**18).div(rate);\n\n        // Calculate and set bounty per conversion in 2KEY units\n        setUint(\n            keccak256(_campaignPlasma2bountyPerConversion2KEY, campaignPlasma),\n            bountyPerConversion2KEY\n        );\n\n        // Set rate at which 2KEY is put to campaign\n        setUint(\n            keccak256(_campaignPlasma2initialRate, campaignPlasma),\n            rate\n        );\n\n        // Set that campaign is budgeted directly with 2KEY tokens\n        setBool(\n            keccak256(_campaignPlasma2isBudgetedWith2KeyDirectly, campaignPlasma),\n            true\n        );\n\n        // Take 2KEY tokens from the contractor\n        IERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\")).transferFrom(\n            msg.sender,\n            address(this),\n            amountOf2KEYTokens\n        );\n    }\n\n    /**\n     * @notice          Function which will be used in order to add inventory for campaign\n     *                  directly with stable coin tokens. In order to make this\n     *                  transfer secure,\n     *                  user will firstly have to approve this contract to take from him\n     *                  amount of tokens and then call contract function which will execute\n     *                  transferFrom action. This function can be called only once.\n     *\n     * @param           campaignPlasma is the plasma campaign address which is user adding inventory for.\n     * @param           amountOfStableCoins is the amount of stable coins user adds to budget\n     * @param           tokenAddress is stableCoinAddress\n     */\n    function addInventory(\n        address campaignPlasma,\n        uint amountOfStableCoins,\n        uint bountyPerConversionFiat,\n        address tokenAddress\n    )\n    public\n    {\n        // Set that contractor is the msg.sender of this method for the campaign passed\n        setAddress(keccak256(_campaignPlasma2contractor, campaignPlasma), msg.sender);\n\n        address twoKeyUpgradableExchange = getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\");\n\n        // Handle case for Tether due to different ERC20 interface it has\n        if (tokenAddress == getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"USDT\")) {\n            // Take stable coins from the contractor and directly transfer them to upgradable exchange\n            ITether(tokenAddress).transferFrom(\n                msg.sender,\n                twoKeyUpgradableExchange,\n                amountOfStableCoins\n            );\n        } else {\n            // Take stable coins from the contractor and directly transfer them to upgradable exchange\n            IERC20(tokenAddress).transferFrom(\n                msg.sender,\n                twoKeyUpgradableExchange,\n                amountOfStableCoins\n            );\n        }\n\n\n        uint totalTokensBought;\n        uint tokenPrice;\n\n        // Buy tokens\n        (totalTokensBought, tokenPrice) = IUpgradableExchange(twoKeyUpgradableExchange).buyTokensWithERC20(amountOfStableCoins, tokenAddress);\n\n        // Calculate and set bounty per conversion in 2KEY units\n        uint bountyPerConversion2KEY = bountyPerConversionFiat.mul(10 ** 18).div(tokenPrice);\n\n        // Require that budget is not previously set and set initial budget to amount of 2KEY tokens\n        requireBudgetNotSetAndSetBudget(campaignPlasma, totalTokensBought);\n\n        // SSTORE 20k gas * 3 = 60k 3x uint ==> 256 bytes * 3 * 8 =  6144 gas\n        // 375 gas + 5 gas for each byte\n        // 10%   60000 - 6144 = 53856 saving\n\n        setUint(\n            keccak256(_campaignPlasma2bountyPerConversion2KEY, campaignPlasma),\n            bountyPerConversion2KEY\n        );\n\n        setUint(\n            keccak256(_campaignPlasma2amountOfStableCoins, campaignPlasma),\n            amountOfStableCoins\n        );\n\n        // Set stable coin which is used to budget campaign\n        setAddress(\n            keccak256(_campaignPlasma2StableCoinAddress, campaignPlasma),\n            tokenAddress\n        );\n\n        // Set the rate at which we have bought 2KEY tokens\n        setUint(\n            keccak256(_campaignPlasma2initialRate, campaignPlasma),\n            tokenPrice\n        );\n    }\n\n\n    /**\n     * @notice          Function where contractor can withdraw if there's any leftover on his campaign\n     * @param           campaignPlasmaAddress is plasma address of campaign\n     */\n    function withdrawLeftoverForContractor(\n        address campaignPlasmaAddress\n    )\n    public\n    {\n        // Require that this function is possible to call only by contractor\n        require(\n            getAddress(keccak256(_campaignPlasma2contractor,campaignPlasmaAddress)) == msg.sender\n        );\n\n        // Get the leftover for contractor\n        uint leftoverForContractor = getUint(\n            keccak256(_campaignPlasmaToLeftOverForContractor, campaignPlasmaAddress)\n        );\n\n        // Check that he has some leftover which can be zero in case that campaign is not ended yet\n        require(leftoverForContractor > 0);\n\n        // Generate key if contractor have withdrawn his leftover for specific campaign\n        bytes32 key = keccak256(_campaignPlasmaToLeftoverWithdrawnByContractor, campaignPlasmaAddress);\n\n        // Require that he didn't withdraw it\n        require(getBool(key) == false);\n\n        // State that now he has withdrawn the tokens.\n        setBool(key, true);\n\n        transfer2KEY(\n            msg.sender,\n            leftoverForContractor\n        );\n    }\n\n\n    /**\n     * ------------------------------------\n     *          Maintainer actions\n     * ------------------------------------\n     */\n\n    /**\n     * @notice          Function to end selected budget campaign by maintainer, and perform\n     *                  actions regarding rebalancing, reserving tokens, and distributing\n     *                  moderator earnings, as well as calculating leftover for contractor\n     *\n     * @param           campaignPlasma is the plasma address of the campaign\n     * @param           totalAmountForReferrerRewards is the total amount before rebalancing referrers earned\n     * @param           totalAmountForModeratorRewards is the total amount moderator earned before rebalancing\n     */\n    function endCampaignReserveTokensAndRebalanceRates(\n        address campaignPlasma,\n        uint totalAmountForReferrerRewards,\n        uint totalAmountForModeratorRewards\n    )\n    public\n    onlyMaintainer\n    {\n        // Generate key for storage variable isCampaignEnded\n        bytes32 keyIsCampaignEnded = keccak256(_campaignPlasma2isCampaignEnded, campaignPlasma);\n\n        // Require that campaign is not ended yet\n        require(getBool(keyIsCampaignEnded) == false);\n\n        // End campaign\n        setBool(keyIsCampaignEnded, true);\n\n        // Get how many tokens were inserted at the beginning\n        uint initialBountyForCampaign = getInitialBountyForCampaign(campaignPlasma);\n\n        // Rebalancing everything except referrer rewards\n        uint amountToRebalance = initialBountyForCampaign.sub(totalAmountForReferrerRewards);\n\n        // Amount after rebalancing is initially amount to rebalance\n        uint amountAfterRebalancing = amountToRebalance;\n\n        // Initially rebalanced moderator rewards are total moderator rewards\n        uint rebalancedModeratorRewards = totalAmountForModeratorRewards;\n\n        // Initial ratio is 1\n        uint rebalancingRatio = 10**18;\n\n        if(getIsCampaignBudgetedDirectlyWith2KEY(campaignPlasma) == false) {\n            // If budget added as stable coin we do rebalancing\n            (amountAfterRebalancing, rebalancingRatio)\n                = rebalanceRates(\n                    getInitial2KEYRateForCampaign(campaignPlasma),\n                    amountToRebalance\n            );\n\n            rebalancedModeratorRewards = totalAmountForModeratorRewards.mul(rebalancingRatio).div(10**18);\n        }\n\n        uint leftoverForContractor = amountAfterRebalancing.sub(rebalancedModeratorRewards);\n\n        // Set moderator earnings for this campaign and immediately distribute them\n        setAndDistributeModeratorEarnings(campaignPlasma, rebalancedModeratorRewards);\n\n        // Set total amount to use for referrers\n        setUint(\n            keccak256(_campaignPlasma2ReferrerRewardsTotal, campaignPlasma),\n            totalAmountForReferrerRewards\n        );\n\n        // Leftover for contractor\n        setUint(\n            keccak256(_campaignPlasmaToLeftOverForContractor, campaignPlasma),\n            leftoverForContractor\n        );\n\n        // Set rebalancing ratio for campaign\n        setRebalancingRatioForCampaign(campaignPlasma, rebalancingRatio);\n\n        // Emit an event to checksum all the balances per campaign\n        ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\"))\n            .emitEndedBudgetCampaign(\n                campaignPlasma,\n                leftoverForContractor,\n                rebalancedModeratorRewards\n            );\n    }\n\n\n    /**\n     * @notice          Function to distribute rewards between influencers, increment global cycle id,\n     *                  and update how much rewards are ever being distributed from this contract\n     *\n     * @param           influencers is the array of influencers\n     * @param           balances is the array of corresponding balances for the influencers above\n     *\n     */\n    function pushAndDistributeRewardsBetweenInfluencers(\n        address [] influencers,\n        uint [] balances,\n        uint nonRebalancedTotalPayout,\n        uint rebalancedTotalPayout,\n        uint cycleId,\n        uint feePerReferrerIn2KEY\n    )\n    public\n    onlyMaintainer\n    {\n        // Get the address of 2KEY token\n        address twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n        // Get the address of twoKeyUpgradableExchange contract\n        address twoKeyUpgradableExchange = getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\");\n        // Total distributed in cycle\n        uint totalDistributed;\n        // Iterator\n        uint i;\n\n        uint difference;\n        // Leads to we need to return some tokens back to Upgradable Exchange\n        if(nonRebalancedTotalPayout > rebalancedTotalPayout) {\n            difference = nonRebalancedTotalPayout.sub(rebalancedTotalPayout);\n            IERC20(twoKeyEconomy).approve(twoKeyUpgradableExchange, difference);\n            IUpgradableExchange(twoKeyUpgradableExchange).returnTokensBackToExchangeV1(difference);\n            ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitRebalancedRewards(\n                cycleId,\n                difference,\n                \"RETURN_TOKENS_TO_EXCHANGE\"\n            );\n        } else if (nonRebalancedTotalPayout < rebalancedTotalPayout) {\n            // Leads to we need to get more tokens from Upgradable Exchange\n            difference = rebalancedTotalPayout.sub(nonRebalancedTotalPayout);\n            IUpgradableExchange(twoKeyUpgradableExchange).getMore2KeyTokensForRebalancingV1(difference);\n            ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitRebalancedRewards(\n                cycleId,\n                difference,\n                \"GET_TOKENS_FROM_EXCHANGE\"\n            );\n        }\n\n        uint numberOfReferrers = influencers.length;\n\n        // Iterate through all influencers, distribute them rewards, and account amount received per cycle id\n        for (i = 0; i < numberOfReferrers; i++) {\n            // Require that referrer earned more than fees\n            require(balances[i] > feePerReferrerIn2KEY);\n            // Sub fee per referrer from balance to pay\n            uint balance = balances[i].sub(feePerReferrerIn2KEY);\n            // Transfer required tokens to influencer\n            IERC20(twoKeyEconomy).transfer(influencers[i], balance);\n            // Sum up to totalDistributed to referrers\n            totalDistributed = totalDistributed.add(balance);\n        }\n\n\n        transferFeesToAdmin(feePerReferrerIn2KEY, numberOfReferrers, twoKeyEconomy);\n\n\n        // Set how much is total distributed per distribution cycle\n        setUint(\n            keccak256(_distributionCycleToTotalDistributed, cycleId),\n            totalDistributed\n        );\n    }\n\n\n    /**\n     * ------------------------------------------------\n     *        Internal functions performing logic operations\n     * ------------------------------------------------\n     */\n\n    /**\n     * @notice          Function to transfer fees taken from referrer rewards to admin contract\n     * @param           feePerReferrer is fee taken per referrer equaling 0.5$ in 2KEY at the moment\n     * @param           numberOfReferrers is number of referrers being rewarded in this cycle\n     * @param           twoKeyEconomy is 2KEY token contract\n     */\n    function transferFeesToAdmin(\n        uint feePerReferrer,\n        uint numberOfReferrers,\n        address twoKeyEconomy\n    )\n    internal\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n\n        IERC20(twoKeyEconomy).transfer(\n            twoKeyAdmin,\n            feePerReferrer.mul(numberOfReferrers)\n        );\n\n        // Update in admin tokens receiving from fees\n        ITwoKeyAdmin(twoKeyAdmin).updateTokensReceivedFromDistributionFees(feePerReferrer.mul(numberOfReferrers));\n    }\n\n\n    /**\n     * @notice          Function to set how many tokens are being distributed to moderator\n     *                  as well as distribute them.\n     * @param           campaignPlasma is the plasma address of selected campaign\n     * @param           rebalancedModeratorRewards is the amount for moderator after rebalancing\n     */\n    function setAndDistributeModeratorEarnings(\n        address campaignPlasma,\n        uint rebalancedModeratorRewards\n    )\n    internal\n    {\n        // Account amount moderator earned on this campaign\n        setUint(\n            keccak256(_campaignPlasmaToModeratorEarnings, campaignPlasma),\n            rebalancedModeratorRewards\n        );\n\n        // Get twoKeyAdmin address\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n\n        // Transfer 2KEY tokens to moderator\n        transfer2KEY(\n            twoKeyAdmin,\n            rebalancedModeratorRewards\n        );\n\n        // Update moderator on received tokens so it can proceed distribution to TwoKeyDeepFreezeTokenPool\n        ITwoKeyAdmin(twoKeyAdmin).updateReceivedTokensAsModeratorPPC(rebalancedModeratorRewards, campaignPlasma);\n    }\n\n    /**\n     * @notice          Function to require that initial budget is not set, which\n     *                  will prevent any way of adding inventory to specific campaigns\n     *                  after it's first time added\n     * @param           campaignPlasma is campaign plasma address\n     */\n    function requireBudgetNotSetAndSetBudget(\n        address campaignPlasma,\n        uint amount2KEYTokens\n    )\n    internal\n    {\n\n        bytes32 keyHashForInitialBudget = keccak256(_campaignPlasma2initialBudget2Key, campaignPlasma);\n        // Require that initial budget is not being added, since it can be done only once.\n        require(getUint(keyHashForInitialBudget) == 0);\n        // Set initial budget added\n        setUint(keyHashForInitialBudget, amount2KEYTokens);\n    }\n\n    function rebalanceRates(\n        uint initial2KEYRate,\n        uint amountOfTokensToRebalance\n    )\n    internal\n    returns (uint,uint)\n    {\n\n        // Load twoKeyEconomy address\n        address twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n        // Load twoKeyUpgradableExchange address\n        address twoKeyUpgradableExchange = getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\");\n        // Take the current usd to 2KEY rate against we're rebalancing contractor leftover and moderator rewards\n        uint usd2KEYRateWeiNow = IUpgradableExchange(twoKeyUpgradableExchange).sellRate2key();\n\n        // Ratio is initial rate divided by new rate, so if rate went up, this will be less than 1\n        uint rebalancingRatio = initial2KEYRate.mul(10**18).div(usd2KEYRateWeiNow);\n\n        // Calculate new rebalanced amount of tokens\n        uint rebalancedAmount = amountOfTokensToRebalance.mul(rebalancingRatio).div(10**18);\n\n        // If price went up, leads to ratio is going to be less than 10**18\n        if(rebalancingRatio < 10**18) {\n            // Calculate how much tokens should be given back to exchange\n            uint tokensToGiveBackToExchange = amountOfTokensToRebalance.sub(rebalancedAmount);\n            // Approve upgradable exchange to take leftover back\n            IERC20(twoKeyEconomy).approve(twoKeyUpgradableExchange, tokensToGiveBackToExchange);\n            // Call the function to release all DAI for this contract to reserve and to take approved amount of 2key back to liquidity pool\n            IUpgradableExchange(twoKeyUpgradableExchange).returnTokensBackToExchangeV1(tokensToGiveBackToExchange);\n        }\n        // Otherwise we assume that price went down, which leads that ratio will be greater than 10**18\n        else  {\n            uint tokensToTakeFromExchange = rebalancedAmount.sub(amountOfTokensToRebalance);\n            // Get more tokens we need\n            IUpgradableExchange(twoKeyUpgradableExchange).getMore2KeyTokensForRebalancingV1(tokensToTakeFromExchange);\n        }\n        // Return new rebalanced amount as well as ratio against which rebalancing was done.\n        return (rebalancedAmount, rebalancingRatio);\n    }\n\n\n    /**\n     * ------------------------------------------------\n     *        Internal getters and setters\n     * ------------------------------------------------\n     */\n\n    function getUint(\n        bytes32 key\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(key);\n    }\n\n    function setUint(\n        bytes32 key,\n        uint value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setUint(key,value);\n    }\n\n    function getBool(\n        bytes32 key\n    )\n    internal\n    view\n    returns (bool)\n    {\n        return PROXY_STORAGE_CONTRACT.getBool(key);\n    }\n\n    function setBool(\n        bytes32 key,\n        bool value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setBool(key,value);\n    }\n\n    function getAddress(\n        bytes32 key\n    )\n    internal\n    view\n    returns (address)\n    {\n        return PROXY_STORAGE_CONTRACT.getAddress(key);\n    }\n\n    function setAddress(\n        bytes32 key,\n        address value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setAddress(key,value);\n    }\n\n    function equals(\n        string a,\n        string b\n    )\n    internal\n    pure\n    returns (bool) {\n        return keccak256(a) == keccak256(b) ? true : false;\n    }\n\n\n    /**\n     * @notice          Function whenever called, will increment number of distribution cycles\n     */\n    function incrementNumberOfDistributionCycles()\n    internal\n    {\n        bytes32 key = keccak256(_numberOfDistributionCycles);\n        setUint(key,getUint(key) + 1);\n    }\n\n\n    /**\n     * @notice \t\t\tFunction to transfer 2KEY tokens\n     *\n     * @param\t\t\treceiver is the address of tokens receiver\n     * @param\t\t\tamount is the amount of tokens to be transfered\n     */\n    function transfer2KEY(\n        address receiver,\n        uint amount\n    )\n    internal\n    {\n        IERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\")).transfer(\n            receiver,\n            amount\n        );\n    }\n\n    /**\n     * @notice          Internal setter function to store how much stable coins were\n     *                  added to fund this campaign\n     * @param           campaignPlasma is plasma campaign address\n     * @param           amountOfStableCoins is the amount used for campaign funding\n     */\n    function setAmountOfStableCoinsUsedToFundCampaign(\n        address campaignPlasma,\n        uint amountOfStableCoins\n    )\n    internal\n    {\n        setUint(\n            keccak256(_campaignPlasma2amountOfStableCoins, campaignPlasma),\n            amountOfStableCoins\n        );\n    }\n\n    function setRebalancingRatioForCampaign(\n        address campaignPlasma,\n        uint rebalancingRatio\n    )\n    internal\n    {\n        setUint(\n            keccak256(_campaignPlasma2rebalancingRatio, campaignPlasma),\n            rebalancingRatio\n        );\n    }\n\n\n    /**\n     * ------------------------------------------------\n     *              Public getters\n     * ------------------------------------------------\n     */\n\n    /**\n     * @notice          Function to return rebalancing ratio for specific campaign,\n     *                  in case campaign was funded with 2KEY will return 1 ETH as neutral\n     * @param           campaignPlasma is plasma campaign address\n     */\n    function getRebalancingRatioForCampaign(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        uint ratio = getUint(keccak256(_campaignPlasma2rebalancingRatio, campaignPlasma));\n        return  ratio != 0 ? ratio : 10**18;\n    }\n\n    /**\n     * @notice          Function to get number of distribution cycles ever\n     */\n    function getNumberOfCycles()\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_numberOfDistributionCycles));\n    }\n\n\n    /**\n     * @notice          Function to get how much was initial bounty for selected camapaign in 2KEY tokens\n     *\n     * @param           campaignPlasma is the plasma address of the campaign\n     */\n    function getInitialBountyForCampaign(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_campaignPlasma2initialBudget2Key, campaignPlasma));\n    }\n\n\n    /**\n     * @notice          Function to retrieve the initial rate at which 2KEY tokens were bought if\n     *                  were bought at all. Otherwise it returns 0.\n     * @param           campaignPlasma is plasma address of the campaign\n     */\n    function getInitial2KEYRateForCampaign(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_campaignPlasma2initialRate, campaignPlasma));\n    }\n\n\n    /**\n     * @notice          Function to get how much is distributed in cycle\n     * @param           cycleId is the ID of that cycle\n     */\n    function getTotalDistributedInCycle(\n        uint cycleId\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_distributionCycleToTotalDistributed, cycleId));\n    }\n\n\n    /**\n     * @notice          Function to get moderator rebalanced earnings for this campaign\n     * @param           campaignAddress is plasma campaign address\n     */\n    function getModeratorEarningsRebalancedForCampaign(\n        address campaignAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        return (\n            getUint(keccak256(_campaignPlasmaToModeratorEarnings, campaignAddress)) //moderator earnings)\n        );\n    }\n\n\n    /**\n     * @notice          Function to get contractor rebalanced leftover for campaign\n     * @param           campaignAddress is plasma campaign address\n     */\n    function getContractorRebalancedLeftoverForCampaign(\n        address campaignAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        return (\n            getUint(keccak256(_campaignPlasmaToLeftOverForContractor, campaignAddress)) // contractor leftover\n        );\n    }\n\n\n    /**\n     * @notice          Function to get moderator earnings and contractor leftover after we rebalanced campaign\n     * @param           campaignAddress is the address of campaign\n     */\n    function getModeratorEarningsAndContractorLeftoverRebalancedForCampaign(\n        address campaignAddress\n    )\n    public\n    view\n    returns (uint,uint)\n    {\n        return (\n            getModeratorEarningsRebalancedForCampaign(campaignAddress),\n            getContractorRebalancedLeftoverForCampaign(campaignAddress)\n        );\n    }\n\n    function getIfLeftoverForCampaignIsWithdrawn(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (bool)\n    {\n        bool isWithdrawn = getBool(keccak256(_campaignPlasmaToLeftoverWithdrawnByContractor, campaignPlasma));\n        return isWithdrawn;\n    }\n\n    function getNonRebalancedReferrerRewards(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_campaignPlasma2ReferrerRewardsTotal, campaignPlasma));\n    }\n\n    /**\n     * @notice          Function to get balance of stable coins on this contract\n     * @param           stableCoinsAddresses is the array of stable coins addresses we want to fetch\n     *                  balances for\n     */\n    function getBalanceOfStableCoinsOnContract(\n        address [] stableCoinsAddresses\n    )\n    public\n    view\n    returns (uint[])\n    {\n        uint len = stableCoinsAddresses.length;\n        uint [] memory balances = new uint[](len);\n        uint i;\n        for(i = 0; i < len; i++) {\n            balances[i] = IERC20(stableCoinsAddresses[i]).balanceOf(address(this));\n        }\n        return balances;\n    }\n\n\n    /**\n     * @notice          Function to check amount of stable coins used to func ppc campaign\n     * @param           campaignPlasma is campaign plasma address\n     */\n    function getAmountOfStableCoinsUsedToFundCampaign(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_campaignPlasma2amountOfStableCoins, campaignPlasma));\n    }\n\n    /**\n     * @notice          Function to return bounty per conversion in 2KEY tokens\n     * @param           campaignPlasma is plasma campaign of address requested\n     */\n    function getBountyPerConversion2KEY(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(\n            keccak256(_campaignPlasma2bountyPerConversion2KEY, campaignPlasma)\n        );\n    }\n\n    /**\n     * @notice          Function to check if campaign is budgeted directly with 2KEY\n     */\n    function getIsCampaignBudgetedDirectlyWith2KEY(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (bool)\n    {\n        return getBool(keccak256(_campaignPlasma2isBudgetedWith2KeyDirectly, campaignPlasma));\n    }\n\n    function getStableCoinAddressUsedToFundCampaign(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (address)\n    {\n        return getAddress(keccak256(_campaignPlasma2StableCoinAddress, campaignPlasma));\n    }\n\n    /**\n     * @notice          Function to return summary related to specific campaign\n     * @param           campaignPlasma is plasma campaign of address\n     */\n    function getCampaignSummary(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (bytes)\n    {\n        return (\n            abi.encodePacked(\n                getInitialBountyForCampaign(campaignPlasma),\n                getBountyPerConversion2KEY(campaignPlasma),\n                getAmountOfStableCoinsUsedToFundCampaign(campaignPlasma),\n                getInitial2KEYRateForCampaign(campaignPlasma),\n                getContractorRebalancedLeftoverForCampaign(campaignPlasma),\n                getModeratorEarningsRebalancedForCampaign(campaignPlasma),\n                getRebalancingRatioForCampaign(campaignPlasma),\n                getNonRebalancedReferrerRewards(campaignPlasma),\n                getIfLeftoverForCampaignIsWithdrawn(campaignPlasma)\n        )\n        );\n    }\n\n    /**\n     * @notice          Function to fetch inital params computed while adding inventory\n     * @param           campaignPlasma is the plasma address of the campaign being requested\n     */\n    function getInitialParamsForCampaign(\n        address campaignPlasma\n    )\n    public\n    view\n    returns (uint,uint,uint,bool,address)\n    {\n        return (\n            getInitialBountyForCampaign(campaignPlasma), // initial bounty for campaign\n            getBountyPerConversion2KEY(campaignPlasma), // bounty per conversion in 2KEY tokens\n            getInitial2KEYRateForCampaign(campaignPlasma), // rate at the moment of inventory adding\n            getIsCampaignBudgetedDirectlyWith2KEY(campaignPlasma), // Get if campaign is funded directly with 2KEY\n            getCampaignContractor(campaignPlasma) // get contractor of campaign\n        );\n    }\n\n    function getCampaignContractor(\n        address campaignAddress\n    )\n    public\n    view\n    returns (address)\n    {\n        return getAddress(keccak256(_campaignPlasma2contractor, campaignAddress));\n    }\n\n    /**\n     *\n     */\n    function getRequiredBudget2KEY(\n        string fiatCurrency,\n        uint fiatBudgetAmount\n    )\n    public\n    view\n    returns (uint)\n    {\n        // GET 2KEY - USD rate\n        uint rate = IUpgradableExchange(getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\")).sellRate2key();\n\n        // For now ignore fiat currency assuming it's USD always\n        return fiatBudgetAmount.mul(10 ** 18).div(rate);\n    }\n\n    function getFeePerCycleIdPerReferrer(\n        uint cycleId\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_feePerCycleIdPerReferrer, cycleId));\n    }\n\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletonRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorageContract\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getAmountOfStableCoinsUsedToFundCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"},{\"name\":\"totalAmountForReferrerRewards\",\"type\":\"uint256\"},{\"name\":\"totalAmountForModeratorRewards\",\"type\":\"uint256\"}],\"name\":\"endCampaignReserveTokensAndRebalanceRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getIsCampaignBudgetedDirectlyWith2KEY\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"getFeePerCycleIdPerReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"getTotalDistributedInCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getInitialParamsForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignAddress\",\"type\":\"address\"}],\"name\":\"getContractorRebalancedLeftoverForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getNonRebalancedReferrerRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getInitialBountyForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignAddress\",\"type\":\"address\"}],\"name\":\"getCampaignContractor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getInitial2KEYRateForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"},{\"name\":\"amountOfStableCoins\",\"type\":\"uint256\"},{\"name\":\"bountyPerConversionFiat\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addInventory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"},{\"name\":\"amountOf2KEYTokens\",\"type\":\"uint256\"},{\"name\":\"bountyPerConversionFiat\",\"type\":\"uint256\"}],\"name\":\"addInventory2KEY\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfCycles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getIfLeftoverForCampaignIsWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignAddress\",\"type\":\"address\"}],\"name\":\"getModeratorEarningsRebalancedForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getRebalancingRatioForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"influencers\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"nonRebalancedTotalPayout\",\"type\":\"uint256\"},{\"name\":\"rebalancedTotalPayout\",\"type\":\"uint256\"},{\"name\":\"cycleId\",\"type\":\"uint256\"},{\"name\":\"feePerReferrerIn2KEY\",\"type\":\"uint256\"}],\"name\":\"pushAndDistributeRewardsBetweenInfluencers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"campaignPlasmaAddress\",\"type\":\"address\"}],\"name\":\"withdrawLeftoverForContractor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fiatCurrency\",\"type\":\"string\"},{\"name\":\"fiatBudgetAmount\",\"type\":\"uint256\"}],\"name\":\"getRequiredBudget2KEY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stableCoinsAddresses\",\"type\":\"address[]\"}],\"name\":\"getBalanceOfStableCoinsOnContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getCampaignSummary\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignAddress\",\"type\":\"address\"}],\"name\":\"getModeratorEarningsAndContractorLeftoverRebalancedForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getBountyPerConversion2KEY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"getStableCoinAddressUsedToFundCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TwoKeyBudgetCampaignsPaymentsHandler","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}