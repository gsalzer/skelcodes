{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC20Lib.sol\\\";\\n\\n/// @title MinimalProxy Factory\\n/// @author coinstructor.io\\n/// @dev Refer to https://eips.ethereum.org/EIPS/eip-1167 for details\\n/// @notice The Factory contract creates Minimal Proxies using EIP1167,\\n/// @notice which point to ERC20 contracts implementation, this saving on gas\\ncontract ERC20Factory {\\n  // Service fee for each MinimalProxy creation\\n  uint256 constant serviceFee = 50000000000000000; // 0.05 ETH\\n\\n  // The owner of the contract, who receives the funds\\n  address payable immutable public owner;\\n\\n  /// @notice Event will be emitted every time a new ERC20 MinimalProxy is created\\n  /// @param newERC20Address is an address of the newly created ERC20 token MinimalProxy\\n  event ERC20Created(address newERC20Address);\\n\\n  constructor(address payable _owner) {\\n    owner = _owner;\\n  }\\n\\n  /// @notice Creates a MinimalProxy contract via EIP1167 assembly code\\n  /// @dev Using this implementation: https://github.com/optionality/clone-factory\\n  /// @param target is an address of implementation, to which the MinimalProxy will point to\\n  /// @return result is an address of a newly created MinimalProxy\\n  function createClone(address target) internal returns (address result) {\\n    bytes20 targetBytes = bytes20(target);\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n      mstore(add(clone, 0x14), targetBytes)\\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      result := create(0, clone, 0x37)\\n    }\\n  }\\n\\n  /// @notice Tests if MinimalProxy instance really points to the correct implementation\\n  /// @param target is an address of implementation, to which the MinimalProxy should point to\\n  /// @param query is an address of MinimalProxy that needs to be tested\\n  /// @return result is true if MinimalProxy really points to the implementation address\\n  function isClone(address target, address query) external view returns (bool result) {\\n    bytes20 targetBytes = bytes20(target);\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\n      mstore(add(clone, 0xa), targetBytes)\\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n\\n      let other := add(clone, 0x40)\\n      extcodecopy(query, other, 0, 0x2d)\\n      result := and(\\n        eq(mload(clone), mload(other)),\\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\\n      )\\n    }\\n  }\\n\\n  /// @notice Pays out all Factory ETH balance to owners address\\n  function payout() external {\\n    require(owner.send(address(this).balance));\\n  }\\n\\n  /// @notice Pays out all Factory ERC20 token balance to owners address\\n  /// @param _tokenAddress is an address of the ERC20 token to payout\\n  function payoutToken(address _tokenAddress) external {\\n    IERC20Lib token = IERC20Lib(_tokenAddress);\\n    uint256 amount = token.balanceOf(address(this));\\n    require(amount \\u003e 0, \\\"Nothing to payout\\\");\\n    token.transfer(owner, amount);\\n  }\\n\\n  /// @notice Creates and initializes the ERC20 MinimalProxy contract\\n  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\\n  /// @param name_ is the ERC20 token name\\n  /// @param symbol_ is the ERC20 token symbol\\n  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\\n  function createERC20(address libraryAddress_, string memory name_, string memory symbol_, uint256 totalSupply_) payable external {\\n    // The service fee should be paid when calling this function\\n    require(msg.value \\u003e= serviceFee, \\\"Service Fee of 0.05ETH wasn\\u0027t paid\\\");\\n    address clone = createClone(libraryAddress_);\\n    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\\n    emit ERC20Created(clone);\\n  }\\n}\"},\"IERC20Lib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IERC20Lib {\\n  function init(address owner_, string memory name_, string memory symbol_, uint256 totalSupply_) external;\\n  function balanceOf(address account) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newERC20Address\",\"type\":\"address\"}],\"name\":\"ERC20Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"libraryAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"name\":\"createERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"query\",\"type\":\"address\"}],\"name\":\"isClone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"payoutToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20Factory","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000862ab2a5e8feeca125519b5c6f948eb7954cfacb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://142aaad9674c4d01ebb6be9431b831c9719f7eb357cffcb6e12e0b3a4f4890b3"}]}