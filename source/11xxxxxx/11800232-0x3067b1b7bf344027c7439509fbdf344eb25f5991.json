{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.7.0 <0.8.0;\r\n\r\n/**\r\n    * @notice this interface is taken from indexed-core commit hash dae7f231d0f58bfc0993f6c01199cd6b74b01895\r\n */\r\ninterface IndexPoolI {\r\n  function getDenormalizedWeight(address token) external view returns (uint256);\r\n  function getBalance(address token) external view returns (uint256);\r\n  function getUsedBalance(address token) external view returns (uint256);\r\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);    \r\n}\r\n\r\ninterface ERC20I {\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/**\r\n    * @notice SimpleMultiCall is a multicall-like contract for reading IndexPool information\r\n    * @notice it is intended to minimize the need for manual abi encoding/decoding\r\n    * @notice and leverage Golang's abigen to do the heavy lifting\r\n */\r\ncontract SimpleMultiCall {\r\n\r\n    // index pool methods\r\n\r\n    function getDenormalizedWeights(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory weights = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            weights[i] = IndexPoolI(poolAddress).getDenormalizedWeight(tokens[i]);\r\n        }\r\n        return (tokens, weights);\r\n    }\r\n\r\n    function getBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getUsedBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getUsedBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getSpotPrices(\r\n        address poolAddress,\r\n        address[] memory inTokens,\r\n        address[] memory outTokens\r\n    )\r\n        public\r\n        view \r\n        returns (address[] memory, address[] memory, uint256[] memory)\r\n    {\r\n        require(inTokens.length == outTokens.length);\r\n        uint256[] memory prices = new uint256[](inTokens.length);\r\n        for (uint256 i = 0; i < inTokens.length; i++) {\r\n            prices[i] = IndexPoolI(poolAddress).getSpotPrice(inTokens[i], outTokens[i]);\r\n        }\r\n        return (inTokens, outTokens, prices);\r\n    }\r\n\r\n    // erc20 methods\r\n\r\n    function getTotalSupplies(\r\n        address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory, uint256[] memory)\r\n    {\r\n        uint256[] memory supplies = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            supplies[i] = ERC20I(tokens[i]).totalSupply();\r\n        }\r\n        return (tokens, supplies);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getDenormalizedWeights\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"inTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"outTokens\",\"type\":\"address[]\"}],\"name\":\"getSpotPrices\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getTotalSupplies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getUsedBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SimpleMultiCall","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://44470bd2564b5e5b98cf0a195bf1b5960c678d1fb0cc4d8bd8cd0424a29be5a0"}]}