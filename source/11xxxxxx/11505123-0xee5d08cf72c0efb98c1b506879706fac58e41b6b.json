{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/ControllerInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./PriceOracle.sol\\\";\\r\\n\\r\\nabstract contract ControllerInterface {\\r\\n    /// @notice Indicator that this is a Controller contract (for inspection)\\r\\n    bool public constant isController = true;\\r\\n\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function enterMarkets(address[] calldata pTokens) external virtual returns (uint[] memory);\\r\\n    function exitMarket(address pToken) external virtual returns (uint);\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function mintAllowed(address pToken, address minter, uint mintAmount) external virtual returns (uint);\\r\\n    function redeemAllowed(address pToken, address redeemer, uint redeemTokens) external virtual returns (uint);\\r\\n    function redeemVerify(address pToken, address redeemer, uint redeemAmount, uint redeemTokens) external virtual;\\r\\n    function borrowAllowed(address pToken, address borrower, uint borrowAmount) external virtual returns (uint);\\r\\n\\r\\n    function repayBorrowAllowed(\\r\\n        address pToken,\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint repayAmount) external virtual returns (uint);\\r\\n\\r\\n    function liquidateBorrowAllowed(\\r\\n        address pTokenBorrowed,\\r\\n        address pTokenCollateral,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint repayAmount) external virtual returns (uint);\\r\\n\\r\\n    function seizeAllowed(\\r\\n        address pTokenCollateral,\\r\\n        address pTokenBorrowed,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint seizeTokens) external virtual returns (uint);\\r\\n\\r\\n    function transferAllowed(address pToken, address src, address dst, uint transferTokens) external virtual returns (uint);\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    function liquidateCalculateSeizeTokens(\\r\\n        address pTokenBorrowed,\\r\\n        address pTokenCollateral,\\r\\n        uint repayAmount) external view virtual returns (uint, uint);\\r\\n\\r\\n    function getOracle() external view virtual returns (PriceOracle);\\r\\n}\\r\\n\",\r\n      \"keccak256\": \"0x09cc90ca2f75b3e16a22d3660d4bc3ad4a06d54e14964ebde913d0d4cde68c20\"\r\n    },\r\n    \"contracts/ErrorReporter.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\ncontract ControllerErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        UNAUTHORIZED,\\r\\n        CONTROLLER_MISMATCH,\\r\\n        INSUFFICIENT_SHORTFALL,\\r\\n        INSUFFICIENT_LIQUIDITY,\\r\\n        INVALID_CLOSE_FACTOR,\\r\\n        INVALID_COLLATERAL_FACTOR,\\r\\n        INVALID_LIQUIDATION_INCENTIVE,\\r\\n        MARKET_NOT_ENTERED, // no longer possible\\r\\n        MARKET_NOT_LISTED,\\r\\n        MARKET_ALREADY_LISTED,\\r\\n        MATH_ERROR,\\r\\n        NONZERO_BORROW_BALANCE,\\r\\n        PRICE_ERROR,\\r\\n        PRICE_UPDATE_ERROR,\\r\\n        REJECTION,\\r\\n        SNAPSHOT_ERROR,\\r\\n        TOO_MANY_ASSETS,\\r\\n        TOO_MUCH_REPAY\\r\\n    }\\r\\n\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\r\\n        EXIT_MARKET_BALANCE_OWED,\\r\\n        EXIT_MARKET_REJECTION,\\r\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\r\\n        SET_CLOSE_FACTOR_VALIDATION,\\r\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\r\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\r\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\r\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\r\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\r\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\r\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\r\\n        SET_MAX_ASSETS_OWNER_CHECK,\\r\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\r\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\r\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\r\\n        SUPPORT_MARKET_EXISTS,\\r\\n        SUPPORT_MARKET_OWNER_CHECK\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\r\\n      */\\r\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), opaqueError);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        UNAUTHORIZED,\\r\\n        BAD_INPUT,\\r\\n        CONTROLLER_REJECTION,\\r\\n        CONTROLLER_CALCULATION_ERROR,\\r\\n        INTEREST_RATE_MODEL_ERROR,\\r\\n        INVALID_ACCOUNT_PAIR,\\r\\n        INVALID_CLOSE_AMOUNT_REQUESTED,\\r\\n        INVALID_COLLATERAL_FACTOR,\\r\\n        MATH_ERROR,\\r\\n        MARKET_NOT_FRESH,\\r\\n        MARKET_NOT_LISTED,\\r\\n        TOKEN_INSUFFICIENT_ALLOWANCE,\\r\\n        TOKEN_INSUFFICIENT_BALANCE,\\r\\n        TOKEN_INSUFFICIENT_CASH,\\r\\n        TOKEN_TRANSFER_IN_FAILED,\\r\\n        TOKEN_TRANSFER_OUT_FAILED\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\\r\\n     *       This is because FailureInfo grows significantly faster, and\\r\\n     *       the order of Error has some meaning, while the order of FailureInfo\\r\\n     *       is entirely arbitrary.\\r\\n     */\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\\r\\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\\r\\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\\r\\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\\r\\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\\r\\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\\r\\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\r\\n        BORROW_ACCRUE_INTEREST_FAILED,\\r\\n        BORROW_CASH_NOT_AVAILABLE,\\r\\n        BORROW_FRESHNESS_CHECK,\\r\\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\r\\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\r\\n        BORROW_MARKET_NOT_LISTED,\\r\\n        BORROW_CONTROLLER_REJECTION,\\r\\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\\r\\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\\r\\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\\r\\n        LIQUIDATE_CONTROLLER_REJECTION,\\r\\n        LIQUIDATE_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\\r\\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\\r\\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\\r\\n        LIQUIDATE_FRESHNESS_CHECK,\\r\\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\\r\\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\\r\\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\\r\\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\\r\\n        LIQUIDATE_SEIZE_CONTROLLER_REJECTION,\\r\\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\\r\\n        LIQUIDATE_SEIZE_TOO_MUCH,\\r\\n        MINT_ACCRUE_INTEREST_FAILED,\\r\\n        MINT_CONTROLLER_REJECTION,\\r\\n        MINT_EXCHANGE_CALCULATION_FAILED,\\r\\n        MINT_EXCHANGE_RATE_READ_FAILED,\\r\\n        MINT_FRESHNESS_CHECK,\\r\\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\r\\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\r\\n        MINT_TRANSFER_IN_FAILED,\\r\\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\\r\\n        REDEEM_ACCRUE_INTEREST_FAILED,\\r\\n        REDEEM_CONTROLLER_REJECTION,\\r\\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\\r\\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\\r\\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\\r\\n        REDEEM_FRESHNESS_CHECK,\\r\\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\r\\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\r\\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\\r\\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\\r\\n        REDUCE_RESERVES_ADMIN_CHECK,\\r\\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\\r\\n        REDUCE_RESERVES_FRESH_CHECK,\\r\\n        REDUCE_RESERVES_VALIDATION,\\r\\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\\r\\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\\r\\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\r\\n        REPAY_BORROW_CONTROLLER_REJECTION,\\r\\n        REPAY_BORROW_FRESHNESS_CHECK,\\r\\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\r\\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\r\\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\\r\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\r\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\r\\n        SET_CONTROLLER_OWNER_CHECK,\\r\\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\\r\\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\\r\\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\\r\\n        SET_MAX_ASSETS_OWNER_CHECK,\\r\\n        SET_ORACLE_MARKET_NOT_LISTED,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\r\\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\\r\\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\\r\\n        SET_RESERVE_FACTOR_FRESH_CHECK,\\r\\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\\r\\n        TRANSFER_CONTROLLER_REJECTION,\\r\\n        TRANSFER_NOT_ALLOWED,\\r\\n        TRANSFER_NOT_ENOUGH,\\r\\n        TRANSFER_TOO_MUCH,\\r\\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\\r\\n        ADD_RESERVES_FRESH_CHECK,\\r\\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\\r\\n        SET_NEW_IMPLEMENTATION\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\r\\n      */\\r\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), opaqueError);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract OracleErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        UNAUTHORIZED,\\r\\n        UPDATE_PRICE\\r\\n    }\\r\\n\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        NO_RESERVES,\\r\\n        PERIOD_NOT_ELAPSED,\\r\\n        SET_NEW_ADDRESSES,\\r\\n        SET_NEW_IMPLEMENTATION,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract FactoryErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        INVALID_POOL,\\r\\n        MARKET_NOT_LISTED,\\r\\n        UNAUTHORIZED\\r\\n    }\\r\\n\\r\\n    //TODO: Add more cases\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        CREATE_PETH_POOL,\\r\\n        CREATE_PPIE_POOL,\\r\\n        DEFICIENCY_ETH_LIQUIDITY_IN_POOL,\\r\\n        PAIR_IS_NOT_EXIST,\\r\\n        SET_MIN_LIQUIDITY_OWNER_CHECK,\\r\\n        SET_NEW_CONTROLLER,\\r\\n        SET_NEW_EXCHANGE_RATE,\\r\\n        SET_NEW_IMPLEMENTATION,\\r\\n        SET_NEW_INTEREST_RATE_MODEL,\\r\\n        SET_NEW_ORACLE,\\r\\n        SET_NEW_RESERVE_FACTOR,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\r\\n        SUPPORT_MARKET_BAD_RESULT\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract RegistryErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        UNAUTHORIZED\\r\\n    }\\r\\n\\r\\n    //TODO: Add more cases\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        SET_NEW_IMPLEMENTATION,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\r\\n        SET_NEW_FACTORY\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n      **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n      */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\",\r\n      \"keccak256\": \"0xe1bcb3a482a468266ee892e6df9f563fc2513931fa929b3a6188353ffc491aa3\"\r\n    },\r\n    \"contracts/IPriceFeeds.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ninterface AggregatorInterface {\\r\\n    function latestAnswer() external view returns (int256);\\r\\n}\\r\\n\\r\\nlibrary UQ112x112 {\\r\\n    uint224 constant Q112 = 2**112;\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\r\\n        z = uint224(y) * Q112; // never overflows\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\r\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\r\\n        z = x / uint224(y);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary FixedPoint {\\r\\n    // range: [0, 2**112 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    // range: [0, 2**144 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq144x112 {\\r\\n        uint _x;\\r\\n    }\\r\\n\\r\\n    uint8 private constant RESOLUTION = 112;\\r\\n\\r\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\r\\n    // reverts on overflow\\r\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\r\\n        uint z;\\r\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\r\\n        return uq144x112(z);\\r\\n    }\\r\\n\\r\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\r\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\r\\n        return uint144(self._x >> RESOLUTION);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\",\r\n      \"keccak256\": \"0x7b507fc54fede80f5b151e41408b3e106025cefaf01fe33c637467b94c6d3f1a\"\r\n    },\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\n/**\\r\\n  * @title DeFiPie's InterestRateModel Interface\\r\\n  * @author DeFiPie\\r\\n  */\\r\\nabstract contract InterestRateModel {\\r\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\r\\n    bool public constant isInterestRateModel = true;\\r\\n\\r\\n    /**\\r\\n      * @notice Calculates the current borrow interest rate per block\\r\\n      * @param cash The total amount of cash the market has\\r\\n      * @param borrows The total amount of borrows the market has outstanding\\r\\n      * @param reserves The total amount of reserves the market has\\r\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\r\\n      */\\r\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view virtual returns (uint);\\r\\n\\r\\n    /**\\r\\n      * @notice Calculates the current supply interest rate per block\\r\\n      * @param cash The total amount of cash the market has\\r\\n      * @param borrows The total amount of borrows the market has outstanding\\r\\n      * @param reserves The total amount of reserves the market has\\r\\n      * @param reserveFactorMantissa The current reserve factor the market has\\r\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\r\\n      */\\r\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view virtual returns (uint);\\r\\n\\r\\n}\\r\\n\",\r\n      \"keccak256\": \"0x888dd34d8e448ed26653b79a3a9eff0a7784dc5bc599dcfe25524ed3f87b9d71\"\r\n    },\r\n    \"contracts/PTokenInterfaces.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./ControllerInterface.sol\\\";\\r\\nimport \\\"./InterestRateModel.sol\\\";\\r\\nimport \\\"./ProxyWithRegistry.sol\\\";\\r\\n\\r\\ncontract PTokenStorage is ProxyWithRegistryStorage {\\r\\n    /**\\r\\n     * @dev Guard variable for re-entrancy checks\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token name for this token\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token symbol for this token\\r\\n     */\\r\\n    string public symbol;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token decimals for this token\\r\\n     */\\r\\n    uint8 public decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev Maximum borrow rate that can ever be applied (.0005% / block)\\r\\n     */\\r\\n\\r\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\r\\n\\r\\n    /**\\r\\n     * @dev Maximum fraction of interest that can be set aside for reserves\\r\\n     */\\r\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\r\\n\\r\\n    /**\\r\\n     * @notice Contract which oversees inter-pToken operations\\r\\n     */\\r\\n    ControllerInterface public controller;\\r\\n\\r\\n    /**\\r\\n     * @notice Model which tells what the current interest rate should be\\r\\n     */\\r\\n    InterestRateModel public interestRateModel;\\r\\n\\r\\n    /**\\r\\n     * @dev Initial exchange rate used when minting the first PTokens (used when totalSupply = 0)\\r\\n     */\\r\\n    uint internal initialExchangeRateMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Fraction of interest currently set aside for reserves\\r\\n     */\\r\\n    uint public reserveFactorMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Block number that interest was last accrued at\\r\\n     */\\r\\n    uint public accrualBlockNumber;\\r\\n\\r\\n    /**\\r\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\r\\n     */\\r\\n    uint public borrowIndex;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\r\\n     */\\r\\n    uint public totalBorrows;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of reserves of the underlying held in this market\\r\\n     */\\r\\n    uint public totalReserves;\\r\\n\\r\\n    /**\\r\\n     * @notice Total number of tokens in circulation\\r\\n     */\\r\\n    uint public totalSupply;\\r\\n\\r\\n    /**\\r\\n     * @dev Official record of token balances for each account\\r\\n     */\\r\\n    mapping (address => uint) internal accountTokens;\\r\\n\\r\\n    /**\\r\\n     * @dev Approved token transfer amounts on behalf of others\\r\\n     */\\r\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\r\\n\\r\\n    /**\\r\\n     * @notice Container for borrow balance information\\r\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\r\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\r\\n     */\\r\\n    struct BorrowSnapshot {\\r\\n        uint principal;\\r\\n        uint interestIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mapping of account addresses to outstanding borrow balances\\r\\n     */\\r\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\r\\n}\\r\\n\\r\\nabstract contract PTokenInterface is PTokenStorage {\\r\\n    /**\\r\\n     * @notice Indicator that this is a PToken contract (for inspection)\\r\\n     */\\r\\n    bool public constant isPToken = true;\\r\\n\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interest is accrued\\r\\n     */\\r\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows, uint totalReserves);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are minted\\r\\n     */\\r\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are redeemed\\r\\n     */\\r\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when underlying is borrowed\\r\\n     */\\r\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is repaid\\r\\n     */\\r\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is liquidated\\r\\n     */\\r\\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address pTokenCollateral, uint seizeTokens);\\r\\n\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when controller is changed\\r\\n     */\\r\\n    event NewController(ControllerInterface oldController, ControllerInterface newController);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interestRateModel is changed\\r\\n     */\\r\\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserve factor is changed\\r\\n     */\\r\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are added\\r\\n     */\\r\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are reduced\\r\\n     */\\r\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Transfer event\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint amount);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Approval event\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function transfer(address dst, uint amount) external virtual returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\\r\\n    function approve(address spender, uint amount) external virtual returns (bool);\\r\\n    function allowance(address owner, address spender) external view virtual returns (uint);\\r\\n    function balanceOf(address owner) external view virtual returns (uint);\\r\\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\\r\\n    function getAccountSnapshot(address account) external view virtual returns (uint, uint, uint, uint);\\r\\n    function borrowRatePerBlock() external view virtual returns (uint);\\r\\n    function supplyRatePerBlock() external view virtual returns (uint);\\r\\n    function totalBorrowsCurrent() external virtual returns (uint);\\r\\n    function borrowBalanceCurrent(address account) external virtual returns (uint);\\r\\n    function borrowBalanceStored(address account) public view virtual returns (uint);\\r\\n    function exchangeRateCurrent() public virtual returns (uint);\\r\\n    function exchangeRateStored() public view virtual returns (uint);\\r\\n    function getCash() external view virtual returns (uint);\\r\\n    function accrueInterest() public virtual returns (uint);\\r\\n    function seize(address liquidator, address borrower, uint seizeTokens) external virtual returns (uint);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setController(ControllerInterface newController) public virtual returns (uint);\\r\\n    function _setReserveFactor(uint newReserveFactorMantissa) external virtual returns (uint);\\r\\n    function _reduceReserves(uint reduceAmount) external virtual returns (uint);\\r\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public virtual returns (uint);\\r\\n}\\r\\n\\r\\ncontract PErc20Storage {\\r\\n    /**\\r\\n     * @notice Underlying asset for this PToken\\r\\n     */\\r\\n    address public underlying;\\r\\n}\\r\\n\\r\\nabstract contract PErc20Interface is PErc20Storage {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint mintAmount) external virtual returns (uint);\\r\\n    function redeem(uint redeemTokens) external virtual returns (uint);\\r\\n    function redeemUnderlying(uint redeemAmount) external virtual returns (uint);\\r\\n    function borrow(uint borrowAmount) external virtual returns (uint);\\r\\n    function repayBorrow(uint repayAmount) external virtual returns (uint);\\r\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external virtual returns (uint);\\r\\n    function liquidateBorrow(address borrower, uint repayAmount, PTokenInterface pTokenCollateral) external virtual returns (uint);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _addReserves(uint addAmount) external virtual returns (uint);\\r\\n}\\r\\n\\r\\ncontract PPIEStorage {\\r\\n    /// @notice A record of each accounts delegate\\r\\n    mapping (address => address) public delegates;\\r\\n\\r\\n    /// @notice A checkpoint for marking number of votes from a given block\\r\\n    struct Checkpoint {\\r\\n        uint32 fromBlock;\\r\\n        uint96 votes;\\r\\n    }\\r\\n\\r\\n    /// @notice A record of votes checkpoints for each account, by index\\r\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\r\\n\\r\\n    /// @notice The number of checkpoints for each account\\r\\n    mapping (address => uint32) public numCheckpoints;\\r\\n\\r\\n   /// @notice The EIP-712 typehash for the contract's domain\\r\\n   bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n   /// @notice The EIP-712 typehash for the delegation struct used by the contract\\r\\n   bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\r\\n\\r\\n   /// @notice A record of states for signing / validating signatures\\r\\n   mapping (address => uint) public nonces;\\r\\n}\\r\\n\\r\\nabstract contract PPIEInterface is PPIEStorage {\\r\\n    /// @notice An event thats emitted when an account changes its delegate\\r\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\r\\n\\r\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\r\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\r\\n\\r\\n    function delegate(address delegatee) external virtual;\\r\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external virtual;\\r\\n    function getCurrentVotes(address account) external view virtual returns (uint96);\\r\\n    function getPriorVotes(address account, uint blockNumber) external view virtual returns (uint96);\\r\\n}\",\r\n      \"keccak256\": \"0x36f635640f4319082a79e98de8ac6eba5e190056176c3a87015c23c20ec94f1a\"\r\n    },\r\n    \"contracts/PriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nabstract contract PriceOracle {\\r\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\r\\n    bool public constant isPriceOracle = true;\\r\\n\\r\\n    event PriceUpdated(address asset, uint price);\\r\\n\\r\\n    /**\\r\\n      * @notice Get the underlying price of a pToken asset\\r\\n      * @param pToken The pToken to get the underlying price of\\r\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\r\\n      *  Zero means the price is unavailable.\\r\\n      */\\r\\n    function getUnderlyingPrice(address pToken) external view virtual returns (uint);\\r\\n\\r\\n    function updateUnderlyingPrice(address pToken) external virtual returns (uint);\\r\\n}\",\r\n      \"keccak256\": \"0x9819a9a63bfc68ed841974b5da2f0ee27ae4baae87670fb99188a33186f35404\"\r\n    },\r\n    \"contracts/ProxyWithRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./RegistryInterface.sol\\\";\\r\\n\\r\\ncontract ProxyWithRegistryStorage {\\r\\n\\r\\n    /**\\r\\n     * @notice Address of the registry contract\\r\\n     */\\r\\n    address public registry;\\r\\n}\\r\\n\\r\\nabstract contract ProxyWithRegistryInterface is ProxyWithRegistryStorage {\\r\\n    function _setRegistry(address _registry) internal virtual;\\r\\n    function _pTokenImplementation() internal view virtual returns (address);\\r\\n}\\r\\n\\r\\ncontract ProxyWithRegistry is ProxyWithRegistryInterface {\\r\\n    /**\\r\\n     *  Returns actual address of the implementation contract from current registry\\r\\n     *  @return registry Address of the registry\\r\\n     */\\r\\n    function _pTokenImplementation() internal view override returns (address) {\\r\\n        return RegistryInterface(registry).pTokenImplementation();\\r\\n    }\\r\\n\\r\\n    function _setRegistry(address _registry) internal override {\\r\\n        registry = _registry;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ImplementationStorage {\\r\\n\\r\\n    address public implementation;\\r\\n\\r\\n    function _setImplementation(address implementation_) internal {\\r\\n        implementation = implementation_;\\r\\n    }\\r\\n}\",\r\n      \"keccak256\": \"0xbca7f4ac024754179b7448e1a6d76ad3c029c1544e0c128e1d5000eea7f30b8a\"\r\n    },\r\n    \"contracts/Registry.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./PTokenInterfaces.sol\\\";\\r\\nimport './RegistryStorage.sol';\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\n\\r\\ncontract Registry is RegistryStorage, RegistryErrorReporter {\\r\\n\\r\\n    address public factory;\\r\\n    address public pTokenImplementation;\\r\\n\\r\\n    mapping (address => address) public pTokens;\\r\\n    address public pETH;\\r\\n    address public pPIE;\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is changed\\r\\n     */\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\r\\n     */\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n      * @notice Emitted when PTokenImplementation is changed\\r\\n      */\\r\\n    event NewPTokenImplementation(address oldImplementation, address newImplementation);\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function initialize(address _pTokenImplementation) public {\\r\\n        require(pTokenImplementation == address(0), \\\"Registry may only be initialized once\\\");\\r\\n\\r\\n        pTokenImplementation = _pTokenImplementation;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  Sets address of actual pToken implementation contract\\r\\n     *  @return uint 0 = success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function setPTokenImplementation(address newImplementation) external returns (uint) {\\r\\n        if (msg.sender != admin) {\\r\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_NEW_IMPLEMENTATION);\\r\\n        }\\r\\n\\r\\n        address oldImplementation = pTokenImplementation;\\r\\n        pTokenImplementation = newImplementation;\\r\\n\\r\\n        emit NewPTokenImplementation(oldImplementation, pTokenImplementation);\\r\\n\\r\\n        return(uint(Error.NO_ERROR));\\r\\n    }\\r\\n\\r\\n    function _setFactoryContract(address _factory) external returns (uint) {\\r\\n        if (msg.sender != admin) {\\r\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_NEW_FACTORY);\\r\\n        }\\r\\n\\r\\n        factory = _factory;\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function addPToken(address underlying, address pToken) public returns (uint) {\\r\\n        require(msg.sender == admin || msg.sender == factory, \\\"Only admin or factory can add PTokens\\\");\\r\\n\\r\\n        PTokenInterface(pToken).isPToken(); // Sanity check to make sure its really a PToken\\r\\n\\r\\n        require(pTokens[underlying] == address(0), \\\"Token already added\\\");\\r\\n        pTokens[underlying] = pToken;\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function addPETH(address pETH_) public returns (uint) {\\r\\n        require(msg.sender == admin || msg.sender == factory, \\\"Only admin or factory can add PETH\\\");\\r\\n\\r\\n        PTokenInterface(pETH_).isPToken(); // Sanity check to make sure its really a PToken\\r\\n\\r\\n        require(pETH == address(0), \\\"ETH already added\\\");\\r\\n        pETH = pETH_;\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function addPPIE(address pPIE_) public returns (uint) {\\r\\n        require(msg.sender == admin || msg.sender == factory, \\\"Only admin or factory can add PPIE\\\");\\r\\n\\r\\n        PTokenInterface(pPIE_).isPToken(); // Sanity check to make sure its really a PToken\\r\\n\\r\\n        require(pPIE == address(0), \\\"PIE already added\\\");\\r\\n        pPIE = pPIE_;\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n}\",\r\n      \"keccak256\": \"0xa3555e0071dae67e39a0556ba12f1f4309e45de39a30bda107cc01e40fa98cf5\"\r\n    },\r\n    \"contracts/RegistryInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\ninterface RegistryInterface {\\r\\n\\r\\n    /**\\r\\n     *  Returns admin address for cToken contracts\\r\\n     *  @return admin address\\r\\n     */\\r\\n    function admin() external view returns (address payable);\\r\\n\\r\\n    /**\\r\\n     *  Returns address of actual PToken implementation contract\\r\\n     *  @return Address of contract\\r\\n     */\\r\\n    function pTokenImplementation() external view returns (address);\\r\\n\\r\\n    function addPToken(address underlying, address pToken) external returns(uint);\\r\\n    function addPETH(address pETH_) external returns(uint);\\r\\n    function addPPIE(address pPIE_) external returns(uint);\\r\\n}\\r\\n\",\r\n      \"keccak256\": \"0x445e9bfc9f8cbd6c5c9107048c1e78fe646636826696aefbba726911afe7fb87\"\r\n    },\r\n    \"contracts/RegistryStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\ncontract RegistryStorage {\\r\\n    address public implementation;\\r\\n    address public admin;\\r\\n    address public pendingAdmin;\\r\\n}\",\r\n      \"keccak256\": \"0x74b7f86a0c80a2913157f262d3d7d6bc815ad2d3085aec4aedda1d35c0e2e74c\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\r\\n// Subject to the MIT license.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, errorMessage);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot underflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot underflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, errorMessage);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers.\\r\\n     * Reverts on division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers.\\r\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\",\r\n      \"keccak256\": \"0xf94171283a6c49e443b2050d95df8591fbd0f75c4ee8375196ffb489011e0521\"\r\n    },\r\n    \"contracts/UniswapPriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./PriceOracle.sol\\\";\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\nimport \\\"./PTokenInterfaces.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IPriceFeeds.sol\\\";\\r\\nimport \\\"./UniswapPriceOracleStorage.sol\\\";\\r\\nimport './Registry.sol';\\r\\n\\r\\ncontract UniswapPriceOracle is UniswapPriceOracleStorage, PriceOracle, OracleErrorReporter {\\r\\n    using FixedPoint for *;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    Registry public registry;\\r\\n    address public uniswapFactory;\\r\\n    address public WETHUniswap;\\r\\n    address public ETHUSDPriceFeed;\\r\\n\\r\\n    struct cumulativePrice {\\r\\n        FixedPoint.uq112x112 price0Average;\\r\\n        FixedPoint.uq112x112 price1Average;\\r\\n        uint price0CumulativePrevious;\\r\\n        uint price1CumulativePrevious;\\r\\n        uint32 blockTimestampPrevious;\\r\\n    }\\r\\n\\r\\n    mapping(address => cumulativePrice) public cumulativePrices;\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    function initialize(\\r\\n        address registry_,\\r\\n        address uniswapFactory_,\\r\\n        address WETHUniswap_,\\r\\n        address ETHUSDPriceFeed_\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        require(\\r\\n            registry == Registry(address(0)) &&\\r\\n            uniswapFactory == address(0) &&\\r\\n            WETHUniswap == address(0) &&\\r\\n            ETHUSDPriceFeed == address(0)\\r\\n            , \\\"UniswapPriceOracle may only be initialized once\\\"\\r\\n        );\\r\\n\\r\\n        registry = Registry(registry_);\\r\\n        uniswapFactory = uniswapFactory_;\\r\\n        WETHUniswap = WETHUniswap_;\\r\\n        ETHUSDPriceFeed = ETHUSDPriceFeed_;\\r\\n    }\\r\\n\\r\\n    function update(address asset) public returns (uint) {\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(getUniswapPair(asset));\\r\\n\\r\\n        uint112 reserve0;\\r\\n        uint112 reserve1;\\r\\n        uint32 blockTimestamp;\\r\\n        (reserve0, reserve1, blockTimestamp) = pair.getReserves();\\r\\n\\r\\n        if (reserve0 == 0 || reserve1 == 0) {\\r\\n            return fail(Error.UPDATE_PRICE, FailureInfo.NO_RESERVES);\\r\\n        }\\r\\n\\r\\n        if (!isPeriodElapsed(asset)) {\\r\\n            return fail(Error.UPDATE_PRICE, FailureInfo.PERIOD_NOT_ELAPSED);\\r\\n        }\\r\\n\\r\\n        // check old pool or new\\r\\n        if (isNewAssetForOracle(asset)) {\\r\\n            // calc average price using reserves for young pools\\r\\n            cumulativePrices[asset].price0Average = FixedPoint.uq112x112(uqdiv(encode(reserve1), reserve0));\\r\\n            cumulativePrices[asset].price1Average = FixedPoint.uq112x112(uqdiv(encode(reserve0), reserve1));\\r\\n        } else {\\r\\n            uint32 timeElapsed = blockTimestamp - cumulativePrices[asset].blockTimestampPrevious;\\r\\n\\r\\n            // overflow is desired, casting never truncates\\r\\n            // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n            cumulativePrices[asset].price0Average = FixedPoint.uq112x112(uint224((pair.price0CumulativeLast() - cumulativePrices[asset].price0CumulativePrevious) / timeElapsed));\\r\\n            cumulativePrices[asset].price1Average = FixedPoint.uq112x112(uint224((pair.price1CumulativeLast() - cumulativePrices[asset].price1CumulativePrevious) / timeElapsed));\\r\\n        }\\r\\n\\r\\n        // update data\\r\\n        cumulativePrices[asset].price0CumulativePrevious = pair.price0CumulativeLast();\\r\\n        cumulativePrices[asset].price1CumulativePrevious = pair.price1CumulativeLast();\\r\\n        cumulativePrices[asset].blockTimestampPrevious = blockTimestamp;\\r\\n\\r\\n        emit PriceUpdated(asset, getCourseInETH(asset));\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n    function getUniswapPair(address asset) public view returns (address) {\\r\\n        IUniswapV2Factory factory = IUniswapV2Factory(uniswapFactory);\\r\\n        return factory.getPair(WETHUniswap, asset);\\r\\n    }\\r\\n\\r\\n    function getUnderlyingPrice(address pToken) public view override returns (uint) {\\r\\n        if (pToken == registry.pETH()) {\\r\\n            return getPriceInUSD(registry.pETH());\\r\\n        }\\r\\n\\r\\n        address asset = address(PErc20Interface(pToken).underlying());\\r\\n\\r\\n        return getPriceInUSD(asset);\\r\\n    }\\r\\n\\r\\n    function updateUnderlyingPrice(address pToken) public override returns (uint) {\\r\\n        if (pToken == registry.pETH()) {\\r\\n            return uint(Error.NO_ERROR);\\r\\n        }\\r\\n\\r\\n        address asset = address(PErc20Interface(pToken).underlying());\\r\\n\\r\\n        return update(asset);\\r\\n    }\\r\\n\\r\\n    // Get the most recent price for a asset in USD with 18 decimals of precision.\\r\\n    function getPriceInUSD(address asset) public view virtual returns (uint) {\\r\\n        uint ETHUSDPrice = uint(AggregatorInterface(ETHUSDPriceFeed).latestAnswer());\\r\\n        uint AssetETHCourse = getCourseInETH(asset);\\r\\n\\r\\n        // div 1e8 is chainlink precision for ETH\\r\\n        return ETHUSDPrice.mul(AssetETHCourse).div(1e8);\\r\\n    }\\r\\n\\r\\n    function getCourseInETH(address asset) public view returns(uint) {\\r\\n        if (asset == registry.pETH()) {\\r\\n            // ether always worth 1\\r\\n            return 1e18;\\r\\n        }\\r\\n\\r\\n        uint power = PTokenInterface(asset).decimals();\\r\\n        uint amountIn = 10**power;\\r\\n        uint amountOut;\\r\\n\\r\\n        address pair = getUniswapPair(asset);\\r\\n\\r\\n        address token0 = IUniswapV2Pair(pair).token0();\\r\\n        address token1 = IUniswapV2Pair(pair).token1();\\r\\n\\r\\n        if (asset == token0) {\\r\\n            amountOut = cumulativePrices[asset].price0Average.mul(amountIn).decode144();\\r\\n        } else {\\r\\n            require(asset == token1, 'Oracle: INVALID_TOKEN');\\r\\n            amountOut = cumulativePrices[asset].price1Average.mul(amountIn).decode144();\\r\\n        }\\r\\n\\r\\n        return amountOut;\\r\\n    }\\r\\n\\r\\n    function isNewAssetForOracle(address asset) public view returns (bool) {\\r\\n        return bool(cumulativePrices[asset].blockTimestampPrevious == 0);\\r\\n    }\\r\\n\\r\\n    function isPeriodElapsed(address asset) public view returns (bool) {\\r\\n        if (isNewAssetForOracle(asset)) {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(getUniswapPair(asset));\\r\\n        ( , , uint32 blockTimestamp) = pair.getReserves();\\r\\n\\r\\n        uint32 timeElapsed = blockTimestamp - cumulativePrices[asset].blockTimestampPrevious;\\r\\n\\r\\n        return bool(timeElapsed > PERIOD);\\r\\n    }\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 y) internal view returns (uint224 z) {\\r\\n        z = uint224(y) * uint224(Q112); // never overflows\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\r\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\r\\n        z = x / uint224(y);\\r\\n    }\\r\\n\\r\\n    function _setNewAddresses(\\r\\n        address registry_,\\r\\n        address uniswapFactory_,\\r\\n        address WETHUniswap_,\\r\\n        address ETHUSDPriceFeed_\\r\\n    ) external returns (uint) {\\r\\n        // Check caller = admin\\r\\n        if (msg.sender != admin) {\\r\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_NEW_ADDRESSES);\\r\\n        }\\r\\n\\r\\n        registry = Registry(registry_);\\r\\n        uniswapFactory = uniswapFactory_;\\r\\n        WETHUniswap = WETHUniswap_;\\r\\n        ETHUSDPriceFeed = ETHUSDPriceFeed_;\\r\\n\\r\\n        return uint(Error.NO_ERROR);\\r\\n    }\\r\\n\\r\\n}\",\r\n      \"keccak256\": \"0xe20e928bc58ab07583e91f2aabc242df1adb04a5fd6252ded3f8d5229ba39f5f\"\r\n    },\r\n    \"contracts/UniswapPriceOracleStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\ncontract UniswapPriceOracleStorage {\\r\\n    address public implementation;\\r\\n    address public admin;\\r\\n    address public pendingAdmin;\\r\\n    uint Q112 = 2**112;\\r\\n    uint public constant PERIOD = 10 minutes;\\r\\n}\",\r\n      \"keccak256\": \"0x3f6dc1bf136b72902683f8783dd792125894417efd112c0aa91512252e8e56ef\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETHUSDPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETHUniswap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapFactory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WETHUniswap_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ETHUSDPriceFeed_\",\"type\":\"address\"}],\"name\":\"_setNewAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cumulativePrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"internalType\":\"struct FixedPoint.uq112x112\",\"name\":\"price0Average\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"internalType\":\"struct FixedPoint.uq112x112\",\"name\":\"price1Average\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"price0CumulativePrevious\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1CumulativePrevious\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestampPrevious\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getCourseInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPriceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getUniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapFactory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WETHUniswap_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ETHUSDPriceFeed_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"isNewAssetForOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"isPeriodElapsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPriceOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"updateUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapPriceOracle","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}