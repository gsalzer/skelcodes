{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AllowanceTarget.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interface/IAllowanceTarget.sol\\\";\\n\\n/**\\n * @dev AllowanceTarget contract\\n */\\ncontract AllowanceTarget is IAllowanceTarget {\\n    using Address for address;\\n\\n    uint256 constant private TIME_LOCK_DURATION = 1 days;\\n\\n    address public spender;\\n    address public newSpender;\\n    uint256 public timelockExpirationTime;\\n\\n    modifier onlySpender() {\\n        require(spender == msg.sender, \\\"AllowanceTarget: not the spender\\\");\\n        _;\\n    }\\n\\n\\n    constructor(address _spender) public {\\n        require(_spender != address(0), \\\"AllowanceTarget: _spender should not be 0\\\");\\n\\n        // Set spender\\n        spender = _spender;\\n    }\\n\\n\\n    function setSpenderWithTimelock(address _newSpender) override external onlySpender {\\n        require(_newSpender.isContract(), \\\"AllowanceTarget: new spender not a contract\\\");\\n        require(newSpender == address(0) && timelockExpirationTime == 0, \\\"AllowanceTarget: SetSpender in progress\\\");\\n\\n        timelockExpirationTime = now + TIME_LOCK_DURATION;\\n        newSpender = _newSpender;\\n    }\\n\\n    function completeSetSpender() override external {\\n        require(timelockExpirationTime != 0, \\\"AllowanceTarget: no pending SetSpender\\\");\\n        require(now >= timelockExpirationTime, \\\"AllowanceTarget: time lock not expired yet\\\");\\n\\n        // Set new spender\\n        spender = newSpender;\\n        // Reset\\n        timelockExpirationTime = 0;\\n        newSpender = address(0);\\n    }\\n\\n\\n    function teardown() override external onlySpender {\\n        selfdestruct(payable(spender));\\n    }\\n\\n\\n    /// @dev Execute an arbitrary call. Only an authority can call this.\\n    /// @param target The call target.\\n    /// @param callData The call data.\\n    /// @return resultData The data returned by the call.\\n    function executeCall(\\n        address payable target,\\n        bytes calldata callData\\n    )\\n        override\\n        external\\n        onlySpender\\n        returns (bytes memory resultData)\\n    {\\n        bool success;\\n        (success, resultData) = target.call(callData);\\n        if (!success) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IAllowanceTarget.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IAllowanceTarget {\\n    function setSpenderWithTimelock(address _newSpender) external;\\n    function completeSetSpender() external;\\n    function executeCall(address payable _target, bytes calldata _callData) external returns (bytes memory resultData);\\n    function teardown() external;\\n}\"\r\n    },\r\n    \"contracts/Spender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interface/IAllowanceTarget.sol\\\";\\n\\n/**\\n * @dev Spender contract\\n */\\ncontract Spender {\\n    using SafeMath for uint256;\\n\\n    // Constants do not have storage slot.\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    uint256 constant private TIME_LOCK_DURATION = 1 days;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    address public allowanceTarget;\\n    mapping(address => bool) private authorized;\\n    mapping(address => bool) private tokenBlacklist;\\n    uint256 public numPendingAuthorized;\\n    mapping(uint256 => address) public pendingAuthorized;\\n    uint256 public timelockExpirationTime;\\n    uint256 public contractDeployedTime;\\n    bool public timelockActivated;\\n\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Spender: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(authorized[msg.sender], \\\"Spender: not authorized\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"Spender: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n\\n    /************************************************************\\n    *                    Timelock management                    *\\n    *************************************************************/\\n    /// @dev Everyone can activate timelock after the contract has been deployed for more than 1 day.\\n    function activateTimelock() external {\\n        bool canActivate = block.timestamp.sub(contractDeployedTime) > 1 days;\\n        require(canActivate && ! timelockActivated, \\\"Spender: can not activate timelock yet or has been activated\\\");\\n        timelockActivated = true;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor(address _operator) public {\\n        require(_operator != address(0), \\\"Spender: _operator should not be 0\\\");\\n\\n        // Set operator\\n        operator = _operator;\\n        timelockActivated = false;\\n        contractDeployedTime = block.timestamp;\\n    }\\n\\n    function setAllowanceTarget(address _allowanceTarget) external onlyOperator {\\n        require(allowanceTarget == address(0), \\\"Spender: can not reset allowance target\\\");\\n\\n        // Set allowanceTarget\\n        allowanceTarget = _allowanceTarget;\\n    }\\n\\n\\n\\n    /************************************************************\\n    *          AllowanceTarget interaction functions            *\\n    *************************************************************/\\n    function setNewSpender(address _newSpender) external onlyOperator {\\n        IAllowanceTarget(allowanceTarget).setSpenderWithTimelock(_newSpender);\\n    }\\n\\n    function teardownAllowanceTarget() external onlyOperator {\\n        IAllowanceTarget(allowanceTarget).teardown();\\n    }\\n\\n\\n\\n    /************************************************************\\n    *           Whitelist and blacklist functions               *\\n    *************************************************************/\\n    function isBlacklisted(address _tokenAddr) external view returns (bool) {\\n        return tokenBlacklist[_tokenAddr];\\n    }\\n\\n    function blacklist(address[] calldata _tokenAddrs, bool[] calldata _isBlacklisted) external onlyOperator {\\n        require(_tokenAddrs.length == _isBlacklisted.length, \\\"Spender: length mismatch\\\");\\n        for (uint256 i = 0; i < _tokenAddrs.length; i++) {\\n            tokenBlacklist[_tokenAddrs[i]] = _isBlacklisted[i];\\n        }\\n    }\\n    \\n    function isAuthorized(address _caller) external view returns (bool) {\\n        return authorized[_caller];\\n    }\\n\\n    function authorize(address[] calldata _pendingAuthorized) external onlyOperator {\\n        require(_pendingAuthorized.length > 0, \\\"Spender: authorize list is empty\\\");\\n        require(numPendingAuthorized == 0 && timelockExpirationTime == 0, \\\"Spender: an authorize current in progress\\\");\\n\\n        if (timelockActivated) {\\n            numPendingAuthorized = _pendingAuthorized.length;\\n            for (uint256 i = 0; i < _pendingAuthorized.length; i++) {\\n                require(_pendingAuthorized[i] != address(0), \\\"Spender: can not authorize zero address\\\");\\n                pendingAuthorized[i] = _pendingAuthorized[i];\\n            }\\n            timelockExpirationTime = now + TIME_LOCK_DURATION;\\n        } else {\\n            for (uint256 i = 0; i < _pendingAuthorized.length; i++) {\\n                require(_pendingAuthorized[i] != address(0), \\\"Spender: can not authorize zero address\\\");\\n                authorized[_pendingAuthorized[i]] = true;\\n            }\\n        }\\n    }\\n\\n    function completeAuthorize() external {\\n        require(timelockExpirationTime != 0, \\\"Spender: no pending authorize\\\");\\n        require(now >= timelockExpirationTime, \\\"Spender: time lock not expired yet\\\");\\n\\n        for (uint256 i = 0; i < numPendingAuthorized; i++) {\\n            authorized[pendingAuthorized[i]] = true;\\n            delete pendingAuthorized[i];\\n        }\\n        timelockExpirationTime = 0;\\n        numPendingAuthorized = 0;\\n    }\\n\\n    function deauthorize(address[] calldata _deauthorized) external onlyOperator {\\n        for (uint256 i = 0; i < _deauthorized.length; i++) {\\n            authorized[_deauthorized[i]] = false;\\n        }\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    /// @dev Spend tokens on user's behalf. Only an authority can call this.\\n    /// @param _user The user to spend token from.\\n    /// @param _tokenAddr The address of the token.\\n    /// @param _amount Amount to spend.\\n    function spendFromUser(address _user, address _tokenAddr, uint256 _amount) external onlyAuthorized {\\n        require(! tokenBlacklist[_tokenAddr], \\\"Spender: token is blacklisted\\\");\\n\\n        if (_tokenAddr != ETH_ADDRESS && _tokenAddr != ZERO_ADDRESS) {\\n\\n            uint256 balanceBefore = IERC20(_tokenAddr).balanceOf(msg.sender);\\n            (bool callSucceed, ) = address(allowanceTarget).call(\\n                abi.encodeWithSelector(\\n                    IAllowanceTarget.executeCall.selector,\\n                    _tokenAddr,\\n                    abi.encodeWithSelector(\\n                        IERC20.transferFrom.selector,\\n                        _user,\\n                        msg.sender,\\n                        _amount\\n                    )\\n                )\\n            );\\n            require(callSucceed, \\\"Spender: ERC20 transferFrom failed\\\");\\n            // Check balance\\n            uint256 balanceAfter = IERC20(_tokenAddr).balanceOf(msg.sender);\\n            require(balanceAfter.sub(balanceBefore) == _amount, \\\"Spender: ERC20 transferFrom result mismatch\\\");\\n\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/user_proxy/UserProxyV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interface/IPMM.sol\\\";\\nimport \\\"../interface/IPermanentStorage.sol\\\";\\nimport \\\"../utils/lib_storage/UserProxyStorage.sol\\\";\\n\\n/**\\n * @dev UserProxy contract\\n */\\ncontract UserProxyV4 {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public operator;\\n    string public version;  // Current version of the contract\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     * @dev Access control and ownership management.\\n     */\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"UserProxy: not the operator\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"UserProxy: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n    /* End of access control and ownership management */\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    function initialize(address _newAMMWrapper, address _newPMM) external {\\n        require(_newAMMWrapper != address(0), \\\"UserProxy: _newAMMWrapper should not be 0\\\");\\n        require(_newPMM != address(0), \\\"UserProxy: _newPMM should not be 0\\\");\\n\\n        // Set amm/pmm\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\\n        PMMStorage.getStorage().pmmAddr = _newPMM;\\n    }\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return AMMWrapperStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function setAMMStatus(bool _enable) public onlyOperator {\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    function isAMMEnabled() public view returns (bool) {\\n        return AMMWrapperStorage.getStorage().isEnabled;\\n    }\\n\\n    /**\\n     * @dev Update AMMWrapper contract address. Used only when ABI of AMMWrapeer remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradeAMMWrapper(address _newAMMWrapperAddr, bool _enable) external onlyOperator {\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    /**\\n     * @dev proxy to AMM\\n     */\\n    function toAMM(bytes calldata _payload) external payable {\\n        require(isAMMEnabled(), \\\"UserProxy: AMM is disabled\\\");\\n\\n        (bool callSucceed,) = ammWrapperAddr().call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PMMStorage.getStorage().pmmAddr;\\n    }\\n\\n    function isPMMEnabled() public view returns (bool) {\\n        return PMMStorage.getStorage().isEnabled;\\n    }\\n    /**\\n     * @dev Update PMM contract address. Used only when ABI of PMM remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradePMM(address _newPMMAddr, bool _enable) external onlyOperator {\\n        PMMStorage.getStorage().pmmAddr = _newPMMAddr;\\n        PMMStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    function setPMMStatus(bool _enable) public onlyOperator {\\n        PMMStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    /**\\n     * @dev proxy to PMM\\n     */\\n    function toPMM(bytes calldata _payload) external payable {\\n        require(isPMMEnabled(), \\\"UserProxy: PMM is disabled\\\");\\n\\n        (bool callSucceed,) = pmmAddr().call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPMM.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../pmm/0xLibs/LibOrder.sol\\\";\\nimport \\\"./ISetAllowance.sol\\\";\\n\\ninterface IPMM is ISetAllowance {\\n    function fill(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    ) external payable returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interface/IPermanentStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IPermanentStorage {\\n    function wethAddr() external view returns (address);\\n    function getCurveTokenIndex(address _makerAddr, address _assetAddr) external view returns (int128);\\n    function setCurveTokenIndex(address _makerAddr, address[] calldata _assetAddrs) external;\\n    function isTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRelayerValid(address _relayer) external view returns (bool);\\n    function setTransactionSeen(bytes32 _transactionHash) external;\\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\\n}\"\r\n    },\r\n    \"contracts/utils/lib_storage/UserProxyStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xbf49677e3150252dfa801a673d2d5ec21eaa360a4674864e55e79041e3f65a6b;\\n\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the AMMWrapper contract.\\n        address ammWrapperAddr;\\n        // Is AMM enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary PMMStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x8f135983375ba6442123d61647e7325c1753eabc2e038e44d3b888a970def89a;\\n\\n\\n    /// @dev Storage bucket for proxy contract.\\n    struct Storage {\\n        // The address of the PMM contract.\\n        address pmmAddr;\\n        // Is PMM enabled\\n        bool isEnabled;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"userproxy.pmm.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibOrder.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./LibEIP712.sol\\\";\\n\\n\\ncontract LibOrder is\\n    LibEIP712\\n{\\n    // Hash for the EIP712 Order Schema\\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\\n        \\\"Order(\\\",\\n        \\\"address makerAddress,\\\",\\n        \\\"address takerAddress,\\\",\\n        \\\"address feeRecipientAddress,\\\",\\n        \\\"address senderAddress,\\\",\\n        \\\"uint256 makerAssetAmount,\\\",\\n        \\\"uint256 takerAssetAmount,\\\",\\n        \\\"uint256 makerFee,\\\",\\n        \\\"uint256 takerFee,\\\",\\n        \\\"uint256 expirationTimeSeconds,\\\",\\n        \\\"uint256 salt,\\\",\\n        \\\"bytes makerAssetData,\\\",\\n        \\\"bytes takerAssetData\\\",\\n        \\\")\\\"\\n    ));\\n\\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\\n    // An order's state is unaffected by external factors, like account balances.\\n    enum OrderStatus {\\n        INVALID,                     // Default value\\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\\n        FILLABLE,                    // Order is fillable\\n        EXPIRED,                     // Order has already expired\\n        FULLY_FILLED,                // Order is fully filled\\n        CANCELLED                    // Order has been cancelled\\n    }\\n\\n    // solhint-disable max-line-length\\n    struct Order {\\n        address makerAddress;           // Address that created the order.      \\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\\n    }\\n    // solhint-enable max-line-length\\n\\n    struct OrderInfo {\\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\\n    }\\n\\n    /// @dev Calculates Keccak-256 hash of the order.\\n    /// @param order The order structure.\\n    /// @return orderHash Keccak-256 EIP712 hash of the order.\\n    function getOrderHash(Order memory order)\\n        internal\\n        view\\n        returns (bytes32 orderHash)\\n    {\\n        orderHash = hashEIP712Message(hashOrder(order));\\n        return orderHash;\\n    }\\n\\n    /// @dev Calculates EIP712 hash of the order.\\n    /// @param order The order structure.\\n    /// @return result EIP712 hash of the order.\\n    function hashOrder(Order memory order)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\\n\\n        // Assembly for more efficiently computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP712_ORDER_SCHEMA_HASH,\\n        //     bytes32(order.makerAddress),\\n        //     bytes32(order.takerAddress),\\n        //     bytes32(order.feeRecipientAddress),\\n        //     bytes32(order.senderAddress),\\n        //     order.makerAssetAmount,\\n        //     order.takerAssetAmount,\\n        //     order.makerFee,\\n        //     order.takerFee,\\n        //     order.expirationTimeSeconds,\\n        //     order.salt,\\n        //     keccak256(order.makerAssetData),\\n        //     keccak256(order.takerAssetData)\\n        // ));\\n\\n        assembly {\\n            // Calculate memory addresses that will be swapped out before hashing\\n            let pos1 := sub(order, 32)\\n            let pos2 := add(order, 320)\\n            let pos3 := add(order, 352)\\n\\n            // Backup\\n            let temp1 := mload(pos1)\\n            let temp2 := mload(pos2)\\n            let temp3 := mload(pos3)\\n            \\n            // Hash in place\\n            mstore(pos1, schemaHash)\\n            mstore(pos2, makerAssetDataHash)\\n            mstore(pos3, takerAssetDataHash)\\n            result := keccak256(pos1, 416)\\n            \\n            // Restore\\n            mstore(pos1, temp1)\\n            mstore(pos2, temp2)\\n            mstore(pos3, temp3)\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interface/ISetAllowance.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ISetAllowance {\\n    function setAllowance(address[] memory tokenList, address spender) external;\\n    function closeAllowance(address[] memory tokenList, address spender) external;\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibEIP712.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.6.0;\\n\\n\\ncontract LibEIP712 {\\n\\n    // EIP191 header for EIP712 prefix\\n    string constant internal EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    // EIP712 Domain Name value\\n    string constant internal EIP712_DOMAIN_NAME = \\\"0x Protocol\\\";\\n\\n    // EIP712 Domain Version value\\n    string constant internal EIP712_DOMAIN_VERSION = \\\"2\\\";\\n\\n    // Hash of the EIP712 Domain Separator Schema\\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\\n        \\\"EIP712Domain(\\\",\\n        \\\"string name,\\\",\\n        \\\"string version,\\\",\\n        \\\"address verifyingContract\\\",\\n        \\\")\\\"\\n    ));\\n\\n    // Hash of the EIP712 Domain Separator data\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public EIP712_DOMAIN_HASH;\\n\\n    constructor ()\\n        public\\n    {\\n        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n            bytes12(0),\\n            address(this)\\n        ));\\n    }\\n\\n    /// @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\\n    /// @param hashStruct The EIP712 hash struct.\\n    /// @return result EIP712 hash applied to this EIP712 Domain.\\n    function hashEIP712Message(bytes32 hashStruct)\\n        internal\\n        view\\n        returns (bytes32 result)\\n    {\\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\\n\\n        // Assembly for more efficient computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP191_HEADER,\\n        //     EIP712_DOMAIN_HASH,\\n        //     hashStruct    \\n        // ));\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 66)\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/UserProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"./utils/lib_storage/UserProxyStorage.sol\\\";\\n\\n/**\\n * @dev UserProxy contract\\n */\\ncontract UserProxy {\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    string public version;  // Current version of the contract\\n\\n    receive() external payable {}\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"UserProxy: not the operator\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"UserProxy: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\\n    function initialize(address _operator) external {\\n        require(_operator != address(0), \\\"UserProxy: _operator should not be 0\\\");\\n        require(\\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"\\\")),\\n            \\\"UserProxy: not upgrading from default version\\\"\\n        );\\n\\n        // Set operator\\n        operator = _operator;\\n        // Upgrade version\\n        version = \\\"5.0.0\\\";\\n    }\\n\\n\\n    /************************************************************\\n    *                     Getter functions                      *\\n    *************************************************************/\\n    function ammWrapperAddr() public view returns (address) {\\n        return AMMWrapperStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function isAMMEnabled() public view returns (bool) {\\n        return AMMWrapperStorage.getStorage().isEnabled;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PMMStorage.getStorage().pmmAddr;\\n    }\\n\\n    function isPMMEnabled() public view returns (bool) {\\n        return PMMStorage.getStorage().isEnabled;\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    function setAMMStatus(bool _enable) public onlyOperator {\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    /**\\n     * @dev Update AMMWrapper contract address. Used only when ABI of AMMWrapeer remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradeAMMWrapper(address _newAMMWrapperAddr, bool _enable) external onlyOperator {\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    function setPMMStatus(bool _enable) public onlyOperator {\\n        PMMStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    /**\\n     * @dev Update PMM contract address. Used only when ABI of PMM remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradePMM(address _newPMMAddr, bool _enable) external onlyOperator {\\n        PMMStorage.getStorage().pmmAddr = _newPMMAddr;\\n        PMMStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    /**\\n     * @dev proxy the call to AMM\\n     */\\n    function toAMM(bytes calldata _payload) external payable {\\n        require(isAMMEnabled(), \\\"UserProxy: AMM is disabled\\\");\\n\\n        (bool callSucceed,) = ammWrapperAddr().call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev proxy the call to PMM\\n     */\\n    function toPMM(bytes calldata _payload) external payable {\\n        require(isPMMEnabled(), \\\"UserProxy: PMM is disabled\\\");\\n\\n        (bool callSucceed,) = pmmAddr().call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/user_proxy/UserProxyV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interface/IAMM.sol\\\";\\nimport \\\"../interface/IPMM.sol\\\";\\nimport \\\"../interface/IPermanentStorage.sol\\\";\\nimport \\\"../utils/lib_storage/UserProxyStorage.sol\\\";\\n\\n/**\\n * @dev UserProxy contract\\n */\\ncontract UserProxyV3 {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public owner;\\n    uint256 public version;  // Current version of the contract\\n    IPermanentStorage public permStorage;\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     * @dev Access control and ownership management.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"UserProxy: not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyAMMorPMM() {\\n        require(\\n            (msg.sender == AMMWrapperStorage.getStorage().ammWrapperAddr) ||\\n            (msg.sender == PMMStorage.getStorage().pmmAddr),\\n            \\\"UserProxy: not a valid contract\\\"\\n        );\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"UserProxy: owner can not be zero address\\\");\\n        owner = _newOwner;\\n    }\\n    /* End of access control and ownership management */\\n\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    function initialize(IPermanentStorage _permStorage, address _pmmAddr) external {\\n        require(version == 2, \\\"UserProxy: not upgrading from version 2\\\");\\n\\n        // Upgrade version\\n        version = 3;\\n        // Set permanent storage\\n        permStorage = _permStorage;\\n        // Plug in and enable PMM\\n        PMMStorage.getStorage().pmmAddr = _pmmAddr;\\n        PMMStorage.getStorage().isEnabled = true;\\n    }\\n\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return AMMWrapperStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function setAMMStatus(bool _enable) public onlyOwner {\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    function isAMMEnabled() public view returns (bool) {\\n        return AMMWrapperStorage.getStorage().isEnabled;\\n    }\\n\\n    /**\\n     * @dev Update AMMWrapper contract address. Used only when ABI of AMMWrapeer remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradeAMMWrapper(address _newAMMWrapperAddr) external onlyOwner {\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n    }\\n\\n    /**\\n     * @dev proxy to AMM\\n     */\\n    // function toAMM(bytes calldata _payload, bytes memory _sig) external payable {\\n    function toAMM(bytes calldata _payload) external payable {\\n        require(isAMMEnabled(), \\\"UserProxy: AMM is disabled\\\");\\n        address _ammWrapperAddr = ammWrapperAddr();\\n\\n        // Since ABI decoding requires padded data, we cannot use abi.decode(_payload[:4], (bytes4)).\\n        bytes4 functionSig =\\n            _payload[0] |\\n            (bytes4(_payload[1]) >> 8) |\\n            (bytes4(_payload[2]) >> 16) |\\n            (bytes4(_payload[3]) >> 24);\\n\\n        if (functionSig == IAMM.trade.selector) {\\n            (bool callSucceed,) = _ammWrapperAddr.call{value: msg.value}(_payload);\\n            if (callSucceed == false) {\\n                // Get the error message returned\\n                assembly {\\n                    let ptr := mload(0x40)\\n                    let size := returndatasize()\\n                    returndatacopy(ptr, 0, size)\\n                    revert(ptr, size)\\n                }\\n            }\\n        } else {\\n            revert(\\\"UserProxy: toAMM function sigature mismatch\\\");\\n        }\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PMMStorage.getStorage().pmmAddr;\\n    }\\n    function isPMMEnabled() public view returns (bool) {\\n        return PMMStorage.getStorage().isEnabled;\\n    }\\n    /**\\n     * @dev Update PMM contract address. Used only when ABI of PMM remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradePMM(address _newPMMAddr) external onlyOwner {\\n        PMMStorage.getStorage().pmmAddr = _newPMMAddr;\\n    }\\n\\n    function setPMMStatus(bool _enable) public onlyOwner {\\n        PMMStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    function toPMM(bytes calldata _payload) external payable {\\n        require(isPMMEnabled(), \\\"UserProxy: PMM is disabled\\\");\\n\\n        address _pmmAddr = pmmAddr();\\n        IPMM pmm = IPMM(_pmmAddr);\\n        // Since ABI decoding requires padded data, we cannot use abi.decode(_payload[:4], (bytes4)).\\n        bytes4 functionSig =\\n            _payload[0] |\\n            (bytes4(_payload[1]) >> 8) |\\n            (bytes4(_payload[2]) >> 16) |\\n            (bytes4(_payload[3]) >> 24);\\n        (\\n            uint256 userSalt,\\n            bytes memory data,\\n            bytes memory userSignature\\n        ) = abi.decode(_payload[4:], (uint256, bytes, bytes));\\n\\n        if (functionSig == IPMM.fill.selector) {\\n            pmm.fill\\n                {value: msg.value}(\\n                    userSalt,\\n                    data,\\n                    userSignature\\n                );\\n        } else {\\n            revert(\\\"UserProxy: toPMM function sigature mismatch\\\");\\n        }\\n    }\\n\\n    function spendFromUser(address user, address takerAssetAddr, uint256 takerAssetAmount) external onlyAMMorPMM() {\\n        if (takerAssetAddr != ETH_ADDRESS &&\\n            takerAssetAddr != ZERO_ADDRESS &&\\n            takerAssetAddr != permStorage.wethAddr()) {\\n            IERC20(takerAssetAddr).safeTransferFrom(user, msg.sender, takerAssetAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IAMM.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ISetAllowance.sol\\\";\\n\\ninterface IAMM is ISetAllowance {\\n    function trade(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _feeFactor,\\n        address _spender,\\n        address payable _receiver,\\n        uint256 _nonce,\\n        uint256 _deadline,\\n        bytes memory _sig\\n    ) payable external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/user_proxy/UserProxyV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../interface/IAMM.sol\\\";\\nimport \\\"../interface/IPermanentStorage.sol\\\";\\nimport \\\"../utils/lib_storage/UserProxyStorage.sol\\\";\\n\\n/**\\n * @dev UserProxy contract\\n */\\ncontract UserProxyV2 {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public owner;\\n    uint256 public version;  // Current version of the contract\\n    IPermanentStorage public permStorage;\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     * @dev Access control and ownership management.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"UserProxy: not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyAMMorPMM() {\\n        require(\\n            (msg.sender == AMMWrapperStorage.getStorage().ammWrapperAddr) ||\\n            (msg.sender == PMMStorage.getStorage().pmmAddr),\\n            \\\"UserProxy: not a valid contract\\\"\\n        );\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"UserProxy: owner can not be zero address\\\");\\n        owner = _newOwner;\\n    }\\n    /* End of access control and ownership management */\\n\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    function initialize(IPermanentStorage _permStorage, address _newAMMWrapperAddr) external {\\n        require(version == 0, \\\"UserProxy: already initialized\\\");\\n\\n        // Upgrade version\\n        version = 2;\\n        // Set permanent storage\\n        permStorage = _permStorage;\\n        // Upgrade AMMWrapper\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n        AMMWrapperStorage.getStorage().isEnabled = true;\\n    }\\n\\n\\n    /**\\n     * @dev Spender logic: managing allowance\\n     */\\n    function setAllowance(address[] calldata tokenAddrs, address spender) external onlyOwner {\\n        for (uint i = 0; i < tokenAddrs.length; i++) {\\n            IERC20 token = IERC20(tokenAddrs[i]);\\n            token.safeApprove(spender, MAX_UINT);\\n            token.safeApprove(address(this), MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata tokenAddrs, address spender) external onlyOwner {\\n        for (uint i = 0; i < tokenAddrs.length; i++) {\\n            IERC20 token = IERC20(tokenAddrs[i]);\\n            token.safeApprove(spender, 0);\\n            token.safeApprove(address(this), 0);\\n        }\\n    }\\n    /* End of Spender logic */\\n\\n\\n    function ammWrapperAddr() external view returns (address) {\\n        return AMMWrapperStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function setAMMStatus(bool _enable) public onlyOwner {\\n        AMMWrapperStorage.getStorage().isEnabled = _enable;\\n    }\\n\\n    function isAMMEnabled() public view returns (bool) {\\n        return AMMWrapperStorage.getStorage().isEnabled;\\n    }\\n\\n    /**\\n     * @dev Update AMMWrapper contract address. Used only when ABI of AMMWrapeer remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogeth.\\n     */\\n    function upgradeAMMWrapper(address _newAMMWrapperAddr) external onlyOwner {\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n    }\\n\\n    /**\\n     * @dev proxy to AMM\\n     */\\n    function toAMM(bytes calldata _payload) external payable {\\n        require(isAMMEnabled(), \\\"UserProxy: AMM is disabled\\\");\\n        // Load the AMMWrapper address\\n        address _ammWrapperAddr = AMMWrapperStorage.getStorage().ammWrapperAddr;\\n        \\n        // Since ABI decoding requires padded data, we cannot use abi.decode(_payload[:4], (bytes4)).\\n        bytes4 functionSig =\\n            _payload[0] |\\n            (bytes4(_payload[1]) >> 8) |\\n            (bytes4(_payload[2]) >> 16) |\\n            (bytes4(_payload[3]) >> 24);\\n\\n         if (functionSig == IAMM.trade.selector) {\\n            (bool status,) = _ammWrapperAddr.call{value: msg.value}(_payload);\\n            require(status, \\\"UserProxy: ammWrapper call failed\\\");\\n        } else {\\n            revert(\\\"UserProxy: toAMM function sigature mismatch\\\");\\n        }\\n    }\\n\\n    function toPMM(bytes calldata payload) external payable {\\n        // require(isMarketMakerProxy[order.makerAddress], \\\"MAKER_ADDRESS_ERROR\\\");\\n    }\\n\\n    function spendFromUser(address user, address takerAssetAddr, uint256 takerAssetAmount) external onlyAMMorPMM() {\\n        if (takerAssetAddr != ETH_ADDRESS && takerAssetAddr != ZERO_ADDRESS && takerAssetAddr != permStorage.wethAddr()) {\\n            IERC20(takerAssetAddr).safeTransferFrom(user, msg.sender, takerAssetAmount);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/stub/UserProxyStub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interface/IAMM.sol\\\";\\n\\ncontract UserProxyStub {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public operator;\\n    address public weth;\\n    address public ammWrapperAddr;\\n    address public pmmAddr;\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     * @dev Access control and ownership management.\\n     */\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"UserProxyStub: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyAMMorPMM() {\\n        require((ammWrapperAddr == msg.sender) || (pmmAddr == msg.sender), \\\"UserProxyStub: not ammWrapper or pmm\\\");\\n        _;\\n    }\\n    /* End of access control and ownership management */\\n\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    constructor(address _weth) public {\\n        operator = msg.sender;\\n        weth = _weth;\\n    }\\n\\n    function upgradePMM(address _pmmAddr) external onlyOperator {\\n        pmmAddr = _pmmAddr;\\n    }\\n\\n    function upgradeAMMWrapper(address _ammWrapperAddr) external onlyOperator {\\n        ammWrapperAddr = _ammWrapperAddr;\\n    }\\n\\n    function toAMM(bytes calldata _payload) external payable {\\n        (bool callSucceed,) = ammWrapperAddr.call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    function toPMM(bytes calldata _payload) external payable {\\n        (bool callSucceed,) = pmmAddr.call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/user_proxy/UserProxyV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../interface/IAMMV1.sol\\\";\\nimport \\\"../utils/lib_storage/UserProxyStorage.sol\\\";\\n\\n/**\\n * @dev UserProxy contract\\n */\\ncontract UserProxyV1 {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    uint256 constant private MAX_UINT = 2**256 - 1;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public owner;\\n\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     * @dev Access control and ownership management.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"UserProxy: not the owner\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"UserProxy: owner can not be zero address\\\");\\n        owner = _newOwner;\\n    }\\n    /* End of access control and ownership management */\\n\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    function initialize(address _ammWrapperAddr, address _owner) external {\\n        require(owner == address(0), \\\"UserProxy: already initialized\\\");\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _ammWrapperAddr;\\n        owner = _owner;\\n    }\\n\\n\\n    /**\\n     * @dev Spender logic: managing allowance\\n     */\\n    function setAllowance(address[] calldata tokenAddrs, address spender) external onlyOwner {\\n        for (uint i = 0; i < tokenAddrs.length; i++) {\\n            IERC20 token = IERC20(tokenAddrs[i]);\\n            token.safeApprove(spender, MAX_UINT);\\n            token.safeApprove(address(this), MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata tokenAddrs, address spender) external onlyOwner {\\n        for (uint i = 0; i < tokenAddrs.length; i++) {\\n            IERC20 token = IERC20(tokenAddrs[i]);\\n            token.safeApprove(spender, 0);\\n            token.safeApprove(address(this), 0);\\n        }\\n    }\\n    /* End of Spender logic */\\n\\n\\n    function ammWrapperAddr() external view returns (address) {\\n        return AMMWrapperStorage.getStorage().ammWrapperAddr;\\n    }\\n    /**\\n     * @dev Update AMMWrapper contract address. Used only when ABI of AMMWrapeer remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogeth.\\n     */\\n    function upgradeAMMWrapper(address _newAMMWrapperAddr) external onlyOwner {\\n        AMMWrapperStorage.getStorage().ammWrapperAddr = _newAMMWrapperAddr;\\n    }\\n\\n    /**\\n     * @dev proxy to AMM\\n     */\\n    function toAMM(bytes calldata _payload) external payable {\\n        // Load the AMMWrapper address\\n        address _ammWrapperAddr = AMMWrapperStorage.getStorage().ammWrapperAddr;\\n        \\n        // Since ABI decoding requires padded data, we cannot use abi.decode(_payload[:4], (bytes4)).\\n        bytes4 functionSig =\\n            _payload[0] |\\n            (bytes4(_payload[1]) >> 8) |\\n            (bytes4(_payload[2]) >> 16) |\\n            (bytes4(_payload[3]) >> 24);\\n\\n         if (functionSig == IAMMV1.trade.selector) {\\n            // Option 1: parse payload and do a normal function call\\n            (\\n                address _pool,\\n                address _fromAssetAddress,\\n                address _toAssetAddress,\\n                uint256 _fromAmount,\\n                uint256 _minAmount,\\n                address payable _spender,\\n                uint256 deadline\\n            ) = abi.decode(_payload[4:], (address, address, address, uint256, uint256, address, uint256));\\n\\n            if (_fromAssetAddress != ETH_ADDRESS && _fromAssetAddress != ZERO_ADDRESS) {\\n                IERC20(_fromAssetAddress).safeTransferFrom(_spender, address(this), _fromAmount);\\n            }\\n\\n            uint256 receivedAmount = IAMMV1(_ammWrapperAddr).trade\\n                {value: msg.value}(\\n                    _pool,\\n                    _fromAssetAddress,\\n                    _toAssetAddress,\\n                    _fromAmount,\\n                    _minAmount,\\n                    payable(address(this)),\\n                    deadline\\n                );\\n            // Option 2: proxy the payload directly with low level call\\n            // (bool status, bytes memory ret) = ammWrapperAddr.call{value: msg.value}(_payload);\\n            // uint256 receivedAmount = abi.decode(ret, (uint256));\\n            if (_toAssetAddress != ETH_ADDRESS && _toAssetAddress != ZERO_ADDRESS) {\\n                IERC20(_toAssetAddress).safeTransfer(_spender, receivedAmount);\\n            } else {\\n                _spender.transfer(receivedAmount);\\n            }\\n        } else {\\n            revert(\\\"UserProxy: toAMM function sigature mismatch\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IAMMV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IAMMV1 {\\n    function getMakerOutAmount(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount\\n    ) external view returns (uint256);\\n\\n    function getBestOutAmount(\\n        address[] memory _makerAddresses,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount\\n    ) external view returns (address bestMaker, uint256 bestAmount);\\n\\n    function getTakerInAmount(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount\\n    ) external view returns (uint256);\\n\\n    function getBestInAmount(\\n        address[] memory _makerAddresses,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount\\n    ) external view returns (address bestMaker, uint256 bestAmount);\\n\\n    function trade(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        address _spender,\\n        uint256 deadline\\n    ) payable external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/amm_wrapper/AMMWrapperV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../interface/IUniswapExchange.sol\\\";\\nimport \\\"../interface/IUniswapFactory.sol\\\";\\nimport \\\"../interface/IUniswapRouterV2.sol\\\";\\nimport \\\"../interface/ICurveFi.sol\\\";\\nimport \\\"../interface/IAMMV1.sol\\\";\\nimport \\\"../interface/IWeth.sol\\\";\\n\\ncontract AMMWrapperV2 is\\n    IAMMV1,\\n    ReentrancyGuard\\n{\\n    using SafeERC20 for IERC20;\\n\\n    address public constant UNISWAP_V1_FACTORY_ADDRESS = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\\n    address public constant UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    IWETH constant internal weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n    event Swapped(\\n        address spender,\\n        address fromAssetAddress,\\n        address toAssetAddress,\\n        uint256 takerAssetAmount,\\n        uint256 makerAssetAmount\\n    );\\n\\n    // makerAddress address => ERC20 token address => makerAddress index\\n    mapping(address => mapping(address => int128)) public curveTokenIndexes;\\n\\n    event CurveTokenAdded(\\n        address indexed makerAddress,\\n        address indexed assetAddress,\\n        int128 index\\n    );\\n\\n    receive() external payable {}\\n\\n    function setCurveTokenIndex(address _makerAddress, address[] calldata _assetAddresses) external {\\n        int128 tokenLength = int128(_assetAddresses.length);\\n        for (int128 i = 0 ; i < tokenLength; i++) {\\n            address assetAddress = _assetAddresses[uint256(i)];\\n            curveTokenIndexes[_makerAddress][assetAddress] = i;\\n            emit CurveTokenAdded(_makerAddress, assetAddress, i);\\n        }\\n    }\\n\\n    function getMakerOutAmount(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 makerAssetAmount;\\n        if (curveTokenIndexes[_makerAddress][_fromAssetAddress] != 0 || \\n            curveTokenIndexes[_makerAddress][_toAssetAddress] != 0\\n        ) {\\n            int128 i = curveTokenIndexes[_makerAddress][_fromAssetAddress];\\n            int128 j = curveTokenIndexes[_makerAddress][_toAssetAddress];\\n            ICurveFi curve = ICurveFi(_makerAddress);\\n            makerAssetAmount = curve.get_dy_underlying(i, j, _takerAssetAmount);\\n        } else if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                makerAssetAmount = exchange.getEthToTokenInputPrice(_takerAssetAmount);\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                makerAssetAmount = exchange.getTokenToEthInputPrice(_takerAssetAmount);\\n            } else {\\n                IUniswapExchange fromExchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                IUniswapExchange toExchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                uint256 ethAmount = fromExchange.getTokenToEthInputPrice(_takerAssetAmount);\\n                makerAssetAmount = toExchange.getEthToTokenInputPrice(ethAmount);\\n            }\\n        } else if (_makerAddress == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n            address[] memory path = new address[](2);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                path[0] = address(weth);\\n                path[1] = _toAssetAddress;\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                path[0] = _fromAssetAddress;\\n                path[1] = address(weth);\\n            } else {\\n                path[0] = _fromAssetAddress;\\n                path[1] = _toAssetAddress;\\n            }\\n            uint256[] memory amounts = router.getAmountsOut(_takerAssetAmount, path);\\n            makerAssetAmount = amounts[1];\\n        } else {\\n            revert(\\\"Unsupported makerAddress\\\");\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function getBestOutAmount(\\n        address[] memory _makerAddresses,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 0;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 makerAssetAmount = getMakerOutAmount(makerAddress, _fromAssetAddress, _toAssetAddress, _takerAssetAmount);\\n            if (makerAssetAmount > bestAmount) {\\n                bestAmount = makerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function getTakerInAmount(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 takerAssetAmount;\\n        if (curveTokenIndexes[_makerAddress][_fromAssetAddress] != 0 || \\n            curveTokenIndexes[_makerAddress][_toAssetAddress] != 0\\n        ) {\\n            int128 i = curveTokenIndexes[_makerAddress][_fromAssetAddress];\\n            int128 j = curveTokenIndexes[_makerAddress][_toAssetAddress];\\n            ICurveFi curve = ICurveFi(_makerAddress);\\n            takerAssetAmount = curve.get_dy_underlying(j, i, _makerAssetAmount);\\n        } else if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                takerAssetAmount = exchange.getEthToTokenOutputPrice(_makerAssetAmount);\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                takerAssetAmount = exchange.getTokenToEthOutputPrice(_makerAssetAmount);\\n            } else {\\n                IUniswapExchange fromExchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                IUniswapExchange toExchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                uint256 ethAmount = toExchange.getEthToTokenOutputPrice(_makerAssetAmount);\\n                takerAssetAmount = fromExchange.getTokenToEthOutputPrice(ethAmount);\\n            }\\n        } else if (_makerAddress == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n            address[] memory path = new address[](2);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                path[0] = address(weth);\\n                path[1] = _toAssetAddress;\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                path[0] = _fromAssetAddress;\\n                path[1] = address(weth);\\n            } else {\\n                path[0] = _fromAssetAddress;\\n                path[1] = _toAssetAddress;\\n            }\\n            uint256[] memory amounts = router.getAmountsIn(_makerAssetAmount, path);\\n            takerAssetAmount = amounts[0];\\n        } else {\\n            revert(\\\"Unsupported makerAddress\\\");\\n        }\\n        return takerAssetAmount;\\n    }\\n\\n    function getBestInAmount(\\n        address[] memory _makerAddresses,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 2**256 - 1;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 takerAssetAmount = getTakerInAmount(makerAddress, _fromAssetAddress, _toAssetAddress, _makerAssetAmount);\\n            if (takerAssetAmount < bestAmount) {\\n                bestAmount = takerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function trade(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        address _spender,\\n        uint256 deadline\\n    )\\n        override\\n        payable\\n        external\\n        nonReentrant\\n        returns (uint256) \\n    {\\n        address fromAssetInternalAddress = _fromAssetAddress;\\n        address toAssetInternalAddress = _toAssetAddress;\\n        IERC20 fromAssetInternal = IERC20(_fromAssetAddress);\\n        address targetContract = _makerAddress;\\n\\n        if (_fromAssetAddress == ZERO_ADDRESS ||\\n            _fromAssetAddress == ETH_ADDRESS) {    \\n            require(msg.value > 0, \\\"AMMWrapperV2: msg.value is zero\\\");\\n            require(_takerAssetAmount == msg.value, \\\"AMMWrapperV2: msg.value doesn't match\\\");\\n        }\\n\\n        // Transfer asset from user and deposit to weth if needed\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS &&\\n            (_fromAssetAddress == ZERO_ADDRESS ||\\n            _fromAssetAddress == ETH_ADDRESS) ) {\\n            // Deposit ETH to weth\\n            weth.deposit{value: msg.value}();\\n            fromAssetInternalAddress = address(weth);\\n            fromAssetInternal = IERC20(fromAssetInternalAddress);\\n        }   else if (_fromAssetAddress != ZERO_ADDRESS &&\\n                    _fromAssetAddress != ETH_ADDRESS) {\\n            // Transfer token from user\\n            fromAssetInternal.safeTransferFrom(_spender, address(this), _takerAssetAmount);\\n        }\\n\\n        // Replace _toAssetAddress to weth if it's ZERO_ADDRESS or ETH_ADDRESS\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS &&\\n            (_toAssetAddress == ZERO_ADDRESS ||\\n            _toAssetAddress == ETH_ADDRESS)) {\\n            toAssetInternalAddress = address(weth);\\n        }\\n\\n        // Approve\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n            targetContract = factory.getExchange(_fromAssetAddress);\\n        }\\n\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS ||\\n            (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS && (_fromAssetAddress != ZERO_ADDRESS && _fromAssetAddress != ETH_ADDRESS))\\n        ) {\\n            fromAssetInternal.safeIncreaseAllowance(targetContract, _takerAssetAmount);\\n        }\\n\\n        // Swap\\n        if (curveTokenIndexes[_makerAddress][fromAssetInternalAddress] != 0 || \\n            curveTokenIndexes[_makerAddress][toAssetInternalAddress] != 0\\n        ) {\\n            int128 i = curveTokenIndexes[_makerAddress][fromAssetInternalAddress];\\n            int128 j = curveTokenIndexes[_makerAddress][toAssetInternalAddress];\\n            _tradeCurveTokenToToken(_makerAddress, i, j, _takerAssetAmount, _makerAssetAmount);\\n        } else if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            _tradeUniswapV1(_fromAssetAddress, _toAssetAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        } else if (_makerAddress == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            _tradeUniswapV2TokenToToken(fromAssetInternalAddress, toAssetInternalAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        } else {\\n            revert(\\\"Unsupported makerAddress\\\");\\n        }\\n\\n        // Close allowance\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS ||\\n            (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS && (_fromAssetAddress != ZERO_ADDRESS && _fromAssetAddress != ETH_ADDRESS))\\n        ) {\\n            fromAssetInternal.safeApprove(targetContract, 0);\\n        }\\n\\n        // Send back assets to spender\\n        uint256 makerAssetAmount = _sendBackAssets(_makerAddress, _toAssetAddress, _makerAssetAmount, _spender);\\n        emit Swapped(_spender, _fromAssetAddress, _toAssetAddress, _takerAssetAmount, makerAssetAmount);\\n        return makerAssetAmount;\\n    }\\n\\n    function _tradeUniswapV1(\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    )\\n        internal \\n        returns (uint256) \\n    {\\n        uint256 amount = 0;\\n        if (_fromAssetAddress == ZERO_ADDRESS ||\\n            _fromAssetAddress == ETH_ADDRESS) {\\n            amount = _tradeUniswapV1EthToToken(_toAssetAddress, _makerAssetAmount, deadline);\\n        } else if (_toAssetAddress == ZERO_ADDRESS ||\\n                    _toAssetAddress == ETH_ADDRESS) {\\n            amount =_tradeUniswapV1TokenToEth(_fromAssetAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        } else {\\n            amount = _tradeUniswapV1TokenToToken(_fromAssetAddress, _toAssetAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        }\\n        return amount;\\n    }\\n\\n    function _sendBackAssets(\\n        address _makerAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount,\\n        address _spender\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 makerAssetAmount = 0;\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS &&\\n            (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS)) {\\n            makerAssetAmount = address(this).balance;\\n            require(makerAssetAmount >= _makerAssetAmount, \\\"AMMWrapperV2: insufficient ETH\\\");\\n            // TODO: review the amount of gas provision\\n            (bool success, ) = _spender.call{ gas: 30000, value: makerAssetAmount }(\\\"\\\");\\n            require(success, \\\"AMMWrapperV2: Failed to transfer funds\\\");\\n        } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n            IERC20 wethToken = IERC20(address(weth));\\n            weth.withdraw(wethToken.balanceOf(address(this)));\\n            makerAssetAmount = address(this).balance;\\n            require(makerAssetAmount >= _makerAssetAmount, \\\"AMMWrapperV2: insufficient ETH\\\");\\n            // TODO: review the amount of gas provision\\n            (bool success, ) = _spender.call{ gas: 30000, value: makerAssetAmount }(\\\"\\\");\\n            require(success, \\\"AMMWrapperV2: Failed to transfer funds\\\");\\n        } else {\\n            IERC20 toAsset = IERC20(_toAssetAddress);\\n            makerAssetAmount = toAsset.balanceOf(address(this));\\n            require(makerAssetAmount >= _makerAssetAmount, \\\"AMMWrapperV2: insufficient token\\\");\\n            toAsset.safeTransfer(_spender, makerAssetAmount);\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function _tradeCurveTokenToToken(\\n        address _makerAddress,\\n        int128 i,\\n        int128 j,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount\\n    ) \\n        internal \\n    {\\n        ICurveFi curve = ICurveFi(_makerAddress);\\n        curve.exchange_underlying(i, j, _takerAssetAmount, _makerAssetAmount);\\n    }\\n\\n    function _tradeUniswapV1EthToToken(\\n        address _assetAddress,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    )\\n        internal\\n        returns (uint256 tokenBought)\\n    {\\n        IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n        address exchangeAddress = factory.getExchange(_assetAddress);\\n        uint256 amount = IUniswapExchange(exchangeAddress)\\n            .ethToTokenSwapInput\\n            {value: address(this).balance}(\\n                _makerAssetAmount,\\n                deadline\\n            );\\n        return amount;\\n    }\\n\\n    function _tradeUniswapV1TokenToEth(\\n        address _assetAddress,\\n        uint256 _makerAssetAmount,\\n        uint256 _minEthAmount,\\n        uint256 deadline\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n        address exchange = factory.getExchange(_assetAddress);\\n        uint256 ethAmount = IUniswapExchange(exchange)\\n            .tokenToEthSwapInput(\\n                _makerAssetAmount,\\n                _minEthAmount,\\n                deadline\\n            );\\n        return ethAmount;\\n    }\\n\\n    function _tradeUniswapV1TokenToToken(\\n        address _takerAssetAddress,\\n        address _makerAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    ) \\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n        address exchange = factory.getExchange(_takerAssetAddress);\\n        uint256 ethAmount = IUniswapExchange(exchange)\\n            .tokenToEthSwapInput(\\n                _takerAssetAmount,\\n                uint256(1),\\n                deadline\\n            );\\n        uint256 amount = IUniswapExchange(factory.getExchange(_makerAssetAddress))\\n            .ethToTokenSwapInput\\n            {value: ethAmount}(\\n                _makerAssetAmount,\\n                deadline\\n            );\\n        return amount;\\n    }\\n\\n    function _tradeUniswapV2TokenToToken(\\n        address _takerAssetAddress,\\n        address _makerAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    ) \\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n        address[] memory path = new address[](2);\\n        path[0] = _takerAssetAddress;\\n        path[1] = _makerAssetAddress;\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            path,\\n            address(this),\\n            deadline\\n        );\\n        return amounts[1];\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUniswapExchange.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapExchange {\\n    // Address of ERC20 token sold on this exchange\\n    function tokenAddress() external view returns (address token);\\n    // Address of Uniswap Factory\\n    function factoryAddress() external view returns (address factory);\\n    // Provide Liquidity\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\\n    // Get Prices\\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\\n    // Trade ETH to ERC20\\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256 tokens_bought);\\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\\n    // Trade ERC20 to ETH\\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\\n    // Trade ERC20 to ERC20\\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\\n    // Trade ERC20 to Custom Pool\\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\\n    // ERC20 comaptibility for liquidity tokens\\n    function name() external view returns (bytes32);\\n    function symbol() external view returns (bytes32);\\n    function decimals() external view returns (uint256);\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    // Never use\\n    function setup(address token_addr) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUniswapFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapFactory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n\\n    // Create Exchange\\n    function createExchange(address token) external returns (address exchange);\\n    // Get Exchange and Token Info\\n    function getExchange(address token) external view returns (address exchange);\\n    function getToken(address exchange) external view returns (address token);\\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\\n    // Never use\\n    function initializeFactory(address template) external;\\n}\\n\\n    \\n\\n    \"\r\n    },\r\n    \"contracts/interface/IUniswapRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapRouterV2 {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/interface/ICurveFi.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface ICurveFi {\\n    function get_virtual_price() external returns (uint256 out);\\n    function add_liquidity(\\n        uint256[2] calldata amounts,\\n        uint256 deadline\\n    ) external;\\n\\n    function add_liquidity(\\n        // sBTC pool\\n        uint256[3] calldata amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function add_liquidity(\\n        // bUSD pool\\n        uint256[4] calldata amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256 out);\\n\\n    function get_dy_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256 out);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        uint256 deadline\\n    ) external;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        uint256 deadline\\n    ) external;\\n\\n    function remove_liquidity(\\n        uint256 _amount,\\n        uint256 deadline,\\n        uint256[2] calldata min_amounts\\n    ) external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[2] calldata amounts,\\n        uint256 deadline\\n    ) external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[3] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[4] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\\n        external;\\n\\n    function commit_new_parameters(\\n        int128 amplification,\\n        int128 new_fee,\\n        int128 new_admin_fee\\n    ) external;\\n\\n    function apply_new_parameters() external;\\n\\n    function revert_new_parameters() external;\\n\\n    function commit_transfer_ownership(address _owner) external;\\n\\n    function apply_transfer_ownership() external;\\n\\n    function revert_transfer_ownership() external;\\n\\n    function withdraw_admin_fees() external;\\n\\n    function coins(int128 arg0) external returns (address out);\\n\\n    function underlying_coins(int128 arg0) external returns (address out);\\n\\n    function balances(int128 arg0) external returns (uint256 out);\\n\\n    function A() external returns (int128 out);\\n\\n    function fee() external returns (int128 out);\\n\\n    function admin_fee() external returns (int128 out);\\n\\n    function owner() external returns (address out);\\n\\n    function admin_actions_deadline() external returns (uint256 out);\\n\\n    function transfer_ownership_deadline() external returns (uint256 out);\\n\\n    function future_A() external returns (int128 out);\\n\\n    function future_fee() external returns (int128 out);\\n\\n    function future_admin_fee() external returns (int128 out);\\n\\n    function future_owner() external returns (address out);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IWeth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/pmm/PMMV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../pmm/0xLibs/LibOrder.sol\\\";\\nimport \\\"../pmm/0xLibs/LibDecoder.sol\\\";\\nimport \\\"../pmm/0xLibs/LibEncoder.sol\\\";\\nimport \\\"../interface/IUserProxyV3.sol\\\";\\nimport \\\"../interface/IZeroExchange.sol\\\";\\nimport \\\"../interface/IWeth.sol\\\";\\nimport \\\"../interface/IPMM.sol\\\";\\nimport \\\"../interface/IPermanentStorageV1.sol\\\";\\n\\ncontract PMMV1 is\\n    ReentrancyGuard,\\n    IPMM,\\n    LibOrder,\\n    LibDecoder,\\n    LibEncoder\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /* Constants */\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    string public constant SOURCE = \\\"0x v2\\\";\\n    uint256 private constant BPS_MAX = 10000;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public immutable operator;\\n    IUserProxyV3 public immutable userProxy;\\n    IPermanentStorageV1 public immutable permStorage;\\n    IZeroExchange public immutable zeroExchange;\\n    address public immutable zxERC20Proxy;\\n\\n    struct TradeInfo {\\n        address user;\\n        address receiver;\\n        uint16 feeFactor;\\n        address makerAssetAddr;\\n        address takerAssetAddr;\\n        bytes32 transactionHash;\\n        bytes32 orderHash;\\n    }\\n\\n    // events\\n    event FillOrder(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        bytes32 indexed orderHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint16 feeFactor\\n    );\\n\\n    modifier onlyOperator {\\n        require(operator == msg.sender, \\\"PMM: not operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"PMM: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    receive() external payable {\\n    }\\n\\n    constructor (address _operator, IUserProxyV3 _userProxy, IPermanentStorageV1 _permStorage, IZeroExchange _zeroExchange, address _zxERC20Proxy) public {\\n        operator = _operator;\\n        userProxy = _userProxy;\\n        permStorage = _permStorage;\\n        zeroExchange = _zeroExchange;\\n        zxERC20Proxy = _zxERC20Proxy;\\n        // this const follow ZX_EXCHANGE address\\n        // encodeTransactionHash depend ZX_EXCHANGE address\\n        EIP712_DOMAIN_HASH = keccak256(\\n            abi.encodePacked(\\n                EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n                bytes12(0),\\n                address(_zeroExchange)\\n            )\\n        );\\n    }\\n\\n    function setAllowance(address[] memory tokenList, address spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < tokenList.length; i++) {\\n            IERC20(tokenList[i]).safeApprove(spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] memory tokenList, address spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < tokenList.length; i++) {\\n            IERC20(tokenList[i]).safeApprove(spender, 0);\\n        }\\n    }\\n\\n    function _depositToWethIfNeeded(address takerAssetAddr, LibOrder.Order memory order) internal {\\n        IWETH weth = IWETH(permStorage.wethAddr());\\n        if (address(weth) == takerAssetAddr) {\\n            require(\\n                msg.value == order.takerAssetAmount,\\n                \\\"PMM: insufficient ETH\\\"\\n            );\\n            weth.deposit{value: msg.value}();\\n        }\\n    }\\n\\n    function fill(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    )\\n        override\\n        public\\n        payable\\n        onlyUserProxy\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        // decode & assert\\n        (LibOrder.Order memory order,\\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\\n\\n        require(permStorage.isValidMM(order.makerAddress), \\\"PMM: not registered market maker\\\");\\n        userProxy.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\\n        _depositToWethIfNeeded(tradeInfo.takerAssetAddr, order);\\n\\n        // saved transaction\\n        permStorage.setTransactionUser(tradeInfo.transactionHash, tradeInfo.user);\\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\\n\\n        // send tx to 0x\\n        zeroExchange.executeTransaction(\\n            userSalt,\\n            address(this),\\n            data,\\n            userSignature\\n        );\\n\\n        // settle token/ETH to user\\n        uint256 settleAmount = _settle(tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\\n\\n        emit FillOrder(\\n            SOURCE,\\n            tradeInfo.transactionHash,\\n            tradeInfo.orderHash,\\n            tradeInfo.user,\\n            tradeInfo.takerAssetAddr,\\n            order.takerAssetAmount,\\n            order.makerAddress,\\n            tradeInfo.makerAssetAddr,\\n            order.makerAssetAmount,\\n            tradeInfo.receiver,\\n            settleAmount,\\n            tradeInfo.feeFactor\\n        );\\n        return settleAmount;\\n    }\\n\\n    // assert & decode transaction\\n    function _assertTransaction(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    )\\n        internal\\n        view\\n        returns(\\n            LibOrder.Order memory order,\\n            TradeInfo memory tradeInfo\\n        )\\n    {\\n        // decode fillOrder data\\n        uint256 takerFillAmount;\\n        bytes memory mmSignature;\\n        (order, takerFillAmount, mmSignature) = decodeFillOrder(data);\\n\\n        tradeInfo = TradeInfo(\\n            address(0),\\n            address(0),\\n            0,\\n            address(0),\\n            address(0),\\n            0,\\n            0\\n        );\\n\\n        require(\\n            order.takerAddress == address(this),\\n            \\\"PMM: incorrect taker\\\"\\n        );\\n        require(\\n            order.takerAssetAmount == takerFillAmount,\\n            \\\"PMM: incorrect fill amount\\\"\\n        );\\n\\n        // generate transactionHash\\n        tradeInfo.transactionHash = encodeTransactionHash(\\n            userSalt,\\n            address(this),\\n            data\\n        );\\n\\n        // require(\\n        //     permStorage.getTransactionUser(tradeInfo.transactionHash) == address(0),\\n        //     \\\"PMM: transaction replayed\\\"\\n        // );\\n\\n        tradeInfo.orderHash = getOrderHash(order);\\n\\n        tradeInfo.feeFactor = uint16(order.salt);\\n        tradeInfo.receiver = decodeUserSignatureWithoutSign(userSignature);\\n        tradeInfo.user = _ecrecoverAddress(tradeInfo.transactionHash, userSignature);\\n\\n        require(\\n            tradeInfo.user == order.feeRecipientAddress,\\n            \\\"PMM: maker signed address should be equal to user\\\"\\n        );\\n\\n        require(\\n            tradeInfo.feeFactor < 10000,\\n            \\\"PMM: invalid fee factor\\\"\\n        );\\n\\n        require(\\n            tradeInfo.receiver != address(0),\\n            \\\"PMM: invalid receiver\\\"\\n        );\\n\\n        // decode asset\\n        // just support ERC20\\n        tradeInfo.makerAssetAddr = decodeERC20Asset(order.makerAssetData);\\n        tradeInfo.takerAssetAddr = decodeERC20Asset(order.takerAssetData);\\n        return (\\n            order,\\n            tradeInfo\\n        );        \\n    }\\n\\n    // settle\\n    function _settle(address receiver, address makerAssetAddr, uint256 makerAssetAmount, uint16 feeFactor) internal returns(uint256) {\\n        uint256 settleAmount = makerAssetAmount;\\n        if (feeFactor > 0) {\\n            // settleAmount = settleAmount * (10000 - feeFactor) / 10000\\n            settleAmount = settleAmount.mul((BPS_MAX).sub(feeFactor)).div(BPS_MAX);\\n        }\\n\\n        IWETH weth = IWETH(permStorage.wethAddr());\\n        if (makerAssetAddr == address(weth)){\\n            weth.withdraw(settleAmount);\\n            payable(receiver).transfer(settleAmount);\\n        } else {\\n            IERC20(makerAssetAddr).safeTransfer(receiver, settleAmount);\\n        }\\n\\n        return settleAmount;\\n    }\\n\\n    function isValidSignature(bytes32 transactionHash, bytes memory signature) external pure returns (bytes32){\\n        // User signature is already verified in `fill`, skip validation\\n        return keccak256(\\\"isValidWalletSignature(bytes32,address,bytes)\\\");\\n    }\\n\\n    function _ecrecoverAddress(bytes32 transactionHash, bytes memory signature) internal pure returns (address){\\n        (uint8 v, bytes32 r, bytes32 s, address receiver) = decodeUserSignature(signature);\\n        return ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\n                    transactionHash,\\n                    receiver\\n                )),\\n            v, r, s\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibDecoder.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibOrder.sol\\\";\\nimport \\\"../../utils/LibBytes.sol\\\";\\n\\ncontract LibDecoder {\\n    using LibBytes for bytes;\\n\\n    function decodeFillOrder(bytes memory data) internal pure returns(LibOrder.Order memory order, uint256 takerFillAmount, bytes memory mmSignature) {\\n        require(\\n            data.length > 800,\\n            \\\"LibDecoder: LENGTH_LESS_800\\\"\\n        );\\n\\n        // compare method_id\\n        // 0x64a3bc15 is fillOrKillOrder's method id.\\n        require(\\n            data.readBytes4(0) == 0x64a3bc15,\\n            \\\"LibDecoder: WRONG_METHOD_ID\\\"\\n        );\\n        \\n        bytes memory dataSlice;\\n        assembly {\\n            dataSlice := add(data, 4)\\n        }\\n        return abi.decode(dataSlice, (LibOrder.Order, uint256, bytes));\\n\\n    }\\n\\n    function decodeMmSignature(bytes memory signature) internal pure returns(uint8 v, bytes32 r, bytes32 s) {\\n        v = uint8(signature[0]);\\n        r = signature.readBytes32(1);\\n        s = signature.readBytes32(33);\\n\\n        return (v, r, s);\\n    }\\n\\n    function decodeUserSignatureWithoutSign(bytes memory signature) internal pure returns(address receiver) {\\n        require(\\n            signature.length == 85 || signature.length == 86,\\n            \\\"LibDecoder: LENGTH_85_REQUIRED\\\"\\n        );\\n        receiver = signature.readAddress(65);\\n\\n        return receiver;\\n    }\\n\\n    function decodeUserSignature(bytes memory signature) internal pure returns(uint8 v, bytes32 r, bytes32 s, address receiver) {\\n        receiver = decodeUserSignatureWithoutSign(signature);\\n\\n        v = uint8(signature[0]);\\n        r = signature.readBytes32(1);\\n        s = signature.readBytes32(33);\\n\\n        return (v, r, s, receiver);\\n    }\\n\\n    function decodeERC20Asset(bytes memory assetData) internal pure returns(address) {\\n        require(\\n            assetData.length == 36,\\n            \\\"LibDecoder: LENGTH_36_REQUIRED\\\"\\n        );\\n\\n        return assetData.readAddress(16);\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibEncoder.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibEIP712.sol\\\";\\n\\ncontract LibEncoder is\\n    LibEIP712\\n{\\n    // Hash for the EIP712 ZeroEx Transaction Schema\\n    bytes32 constant internal EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH = keccak256(\\n        abi.encodePacked(\\n        \\\"ZeroExTransaction(\\\",\\n        \\\"uint256 salt,\\\",\\n        \\\"address signerAddress,\\\",\\n        \\\"bytes data\\\",\\n        \\\")\\\"\\n    ));\\n\\n    function encodeTransactionHash(\\n        uint256 salt,\\n        address signerAddress,\\n        bytes memory data\\n    )\\n        internal\\n        view \\n        returns (bytes32 result)\\n    {\\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\\n        bytes32 dataHash = keccak256(data);\\n\\n        // Assembly for more efficiently computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\\n        //     salt,\\n        //     bytes32(signerAddress),\\n        //     keccak256(data)\\n        // ));\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(memPtr, schemaHash)                                                               // hash of schema\\n            mstore(add(memPtr, 32), salt)                                                            // salt\\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))  // signerAddress\\n            mstore(add(memPtr, 96), dataHash)                                                        // hash of data\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 128)\\n        }\\n        result = hashEIP712Message(result);\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interface/IUserProxyV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IUserProxyV3 {\\n    function spendFromUser(address user, address takerAssetAddr, uint256 takerAssetAmount) external;\\n}\"\r\n    },\r\n    \"contracts/interface/IZeroExchange.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2018 ZeroEx Intl.\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n    http://www.apache.org/licenses/LICENSE-2.0\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n*/\\n\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IZeroExchange {\\n    function executeTransaction(\\n        uint256 salt,\\n        address signerAddress,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPermanentStorageV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IPermanentStorageV1 {\\n    function wethAddr() external view returns (address);\\n    function getCurveTokenIndex(address _makerAddr, address _assetAddr) external view returns (int128);\\n    function setCurveTokenIndex(address _makerAddr, address[] calldata _assetAddrs) external;\\n    function getNonce(address _user) external view returns (uint256);\\n    function increNonce(address _user) external;\\n    function getTransactionUser(bytes32 _transactionHash) external view returns (address);\\n    function setTransactionUser(bytes32 _transactionHash, address _user) external;\\n    function isValidMM(address _marketMaker) external view returns (bool);\\n    function registerMM(address _marketMaker, bool _add) external;\\n}\"\r\n    },\r\n    \"contracts/utils/LibBytes.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2018 ZeroEx Intl.\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n  http://www.apache.org/licenses/LICENSE-2.0\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\\n*/\\n\\npragma solidity ^0.6.0;\\n\\n\\nlibrary LibBytes {\\n  using LibBytes for bytes;\\n\\n  /***********************************|\\n  |        Pop Bytes Functions        |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Pops the last byte off of a byte array by modifying its length.\\n   * @param b Byte array that will be modified.\\n   * @return result The byte that was popped off.\\n   */\\n  function popLastByte(bytes memory b)\\n    internal\\n    pure\\n    returns (bytes1 result)\\n  {\\n    require(\\n      b.length > 0,\\n      \\\"LibBytes#popLastByte: greater than zero length required\\\"\\n    );\\n\\n    // Store last byte.\\n    result = b[b.length - 1];\\n\\n    assembly {\\n      // Decrement length of byte array.\\n      let newLen := sub(mload(b), 1)\\n      mstore(b, newLen)\\n    }\\n    return result;\\n  }\\n\\n  /// @dev Reads an address from a position in a byte array.\\n  /// @param b Byte array containing an address.\\n  /// @param index Index in byte array of address.\\n  /// @return result address from byte array.\\n  function readAddress(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (address result)\\n  {\\n    require(\\n      b.length >= index + 20,  // 20 is length of address\\n      \\\"LibBytes#readAddress greater or equal to 20 length required\\\"\\n    );\\n\\n    // Add offset to index:\\n    // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\\n    // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\\n    index += 20;\\n\\n    // Read address from array memory\\n    assembly {\\n      // 1. Add index to address of bytes array\\n      // 2. Load 32-byte word from memory\\n      // 3. Apply 20-byte mask to obtain address\\n      result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n    }\\n    return result;\\n  }\\n\\n  /***********************************|\\n  |        Read Bytes Functions       |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Reads a bytes32 value from a position in a byte array.\\n   * @param b Byte array containing a bytes32 value.\\n   * @param index Index in byte array of bytes32 value.\\n   * @return result bytes32 value from byte array.\\n   */\\n  function readBytes32(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes32 result)\\n  {\\n    require(\\n      b.length >= index + 32,\\n      \\\"LibBytes#readBytes32 greater or equal to 32 length required\\\"\\n    );\\n\\n    // Arrays are prefixed by a 256 bit length parameter\\n    index += 32;\\n\\n    // Read the bytes32 from array memory\\n    assembly {\\n      result := mload(add(b, index))\\n    }\\n    return result;\\n  }\\n\\n  /// @dev Reads an unpadded bytes4 value from a position in a byte array.\\n  /// @param b Byte array containing a bytes4 value.\\n  /// @param index Index in byte array of bytes4 value.\\n  /// @return result bytes4 value from byte array.\\n  function readBytes4(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes4 result)\\n  {\\n    require(\\n      b.length >= index + 4,\\n      \\\"LibBytes#readBytes4 greater or equal to 4 length required\\\"\\n    );\\n\\n    // Arrays are prefixed by a 32 byte length field\\n    index += 32;\\n\\n    // Read the bytes4 from array memory\\n    assembly {\\n      result := mload(add(b, index))\\n      // Solidity does not require us to clean the trailing bytes.\\n      // We do it anyway\\n      result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\\n    }\\n    return result;\\n  }\\n\\n  function readBytes2(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes2 result)\\n  {\\n    require(\\n      b.length >= index + 2,\\n      \\\"LibBytes#readBytes2 greater or equal to 2 length required\\\"\\n    );\\n\\n    // Arrays are prefixed by a 32 byte length field\\n    index += 32;\\n\\n    // Read the bytes4 from array memory\\n    assembly {\\n      result := mload(add(b, index))\\n      // Solidity does not require us to clean the trailing bytes.\\n      // We do it anyway\\n      result := and(result, 0xFFFF000000000000000000000000000000000000000000000000000000000000)\\n    }\\n    return result;\\n  }\\n}\"\r\n    },\r\n    \"contracts/storage/PermanentStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"../interface/IPermanentStorageV1.sol\\\";\\nimport \\\"../utils/lib_storage/PSStorageV1.sol\\\";\\n\\ncontract PermanentStorageV1 is IPermanentStorageV1 {\\n\\n    // Constants do not have storage slot.\\n    bytes32 public constant curveTokenIndexStorageId = 0xf4c750cdce673f6c35898d215e519b86e3846b1f0532fb48b84fe9d80f6de2fc; // keccak256(\\\"curveTokenIndex\\\")\\n    bytes32 public constant nonceStorageId = 0x8a15a97f6259594aa8bc88e85b717672e3bd1edd2a77d009527d64035f1878ed;  // keccak256(\\\"nonces\\\")\\n    bytes32 public constant transactionsStorageId = 0x06b06d69b368c15164608b3fad50feade19592196c279c0bced1c810c096a717;  // keccak256(\\\"transactions\\\")\\n    bytes32 public constant isValidMarketMakerStorageId = 0xd229d32753f9c4fdb887a71e0562ec1c0a209dda65e83ea49656f6971259e3ae;  // keccak256(\\\"isValidMarketMaker\\\")\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public operator;\\n    string public version;  // Current version of the contract\\n    mapping(bytes32 => mapping(address => bool)) private permission;\\n\\n\\n    /**\\n     * @dev Access control and operatorship management.\\n     */\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"PermanentStorage: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier validRole(address _role) {\\n        require(\\n            (_role == operator) || (_role == ammWrapperAddr()) || (_role == pmmAddr()),\\n            \\\"PermanentStorage: not a valid role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier isPermitted(bytes32 _storageId, address _role) {\\n        require(permission[_storageId][_role], \\\"PermanentStorage: has no permission\\\");\\n        _;\\n    }\\n\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"PermanentStorage: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool) {\\n        return permission[_storageId][_role];\\n    }\\n\\n    function setPermission(bytes32 _storageId, address _role, bool _enabled) external onlyOperator validRole(_role) {\\n        permission[_storageId][_role] = _enabled;\\n    }\\n    /* End of access control and operatorship management */\\n\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    function initialize(address _operator) external {\\n        require(\\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"\\\")),\\n            \\\"PermanentStorage: not upgrading from default version\\\"\\n        );\\n\\n        version = \\\"5.0.0\\\";\\n        operator = _operator;\\n    }\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return PSStorageV1.getStorage().ammWrapperAddr;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PSStorageV1.getStorage().pmmAddr;\\n    }\\n\\n    function wethAddr() override external view returns (address) {\\n        return PSStorageV1.getStorage().wethAddr;\\n    }\\n\\n    /**\\n     * @dev Update AMMWrapper contract address. Used only when ABI of AMMWrapeer remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradeAMMWrapper(address _newAMMWrapper) external onlyOperator {\\n        PSStorageV1.getStorage().ammWrapperAddr = _newAMMWrapper;\\n    }\\n\\n    /**\\n     * @dev Update PMM contract address. Used only when ABI of PMM remain unchanged.\\n     * Otherwise, UserProxy contract should be upgraded altogether.\\n     */\\n    function upgradePMM(address _newPMM) external onlyOperator {\\n        PSStorageV1.getStorage().pmmAddr = _newPMM;\\n    }\\n\\n    function upgradeWETH(address _newWETH) external onlyOperator {\\n        PSStorageV1.getStorage().wethAddr = _newWETH;\\n    }\\n\\n    function getCurveTokenIndex(address _makerAddr, address _assetAddr) override external view returns (int128) {\\n        return AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_assetAddr];\\n    }\\n\\n    function setCurveTokenIndex(address _makerAddr, address[] calldata _assetAddrs) isPermitted(curveTokenIndexStorageId, msg.sender) override external {\\n        int128 tokenLength = int128(_assetAddrs.length);\\n        for (int128 i = 0 ; i < tokenLength; i++) {\\n            address assetAddr = _assetAddrs[uint256(i)];\\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i;\\n        }\\n    }\\n\\n    function getNonce(address _user) override external view returns (uint256) {\\n        return AMMWrapperStorage.getStorage().nonces[_user];\\n    }\\n\\n    function increNonce(address _user) override external isPermitted(nonceStorageId, msg.sender) {\\n        AMMWrapperStorage.getStorage().nonces[_user] = AMMWrapperStorage.getStorage().nonces[_user] + 1;\\n    }\\n\\n    function getTransactionUser(bytes32 _transactionHash) override external view returns (address) {\\n        return PMMStorage.getStorage().transactions[_transactionHash];\\n    }\\n\\n    function setTransactionUser(bytes32 _transactionHash, address _user) override public isPermitted(transactionsStorageId, msg.sender) {\\n        require(PMMStorage.getStorage().transactions[_transactionHash] == address(0), \\\"PermanentStorage: transaction already set\\\");\\n        require(_user != address(0), \\\"PermanentStorage: can not set to zero address\\\");\\n        PMMStorage.getStorage().transactions[_transactionHash] = _user;\\n    }\\n\\n    function isValidMM(address _marketMaker) override external view returns (bool) {\\n        return PMMStorage.getStorage().isValidMarketMaker[_marketMaker];\\n    }\\n\\n    function registerMM(address _marketMaker, bool _add) override external onlyOperator {\\n        PMMStorage.getStorage().isValidMarketMaker[_marketMaker] = _add;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/lib_storage/PSStorageV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary PSStorageV1 {\\n    bytes32 private constant STORAGE_SLOT = 0x92dd52b981a2dd69af37d8a3febca29ed6a974aede38ae66e4ef773173aba471;\\n\\n    struct Storage {\\n        address ammWrapperAddr;\\n        address pmmAddr;\\n        address wethAddr;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.storage.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xd38d862c9fa97c2fa857a46e08022d272a3579c114ca4f335f1e5fcb692c045e;\\n\\n    struct Storage {\\n        mapping(address => uint256) nonces;\\n        mapping(address => mapping(address => int128)) curveTokenIndexes;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary PMMStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xf9faf013fe1696003dca3723ade1a1b88f21762ea39d9dfa2c55c5bd9c4ae6e9;\\n\\n    struct Storage {\\n        mapping(bytes32 => address) transactions;\\n        mapping(address => bool) isValidMarketMaker;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.pmm.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\"\r\n    },\r\n    \"contracts/amm_wrapper/AMMWrapperV3.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interface/IUserProxyV3.sol\\\";\\nimport \\\"../interface/IUniswapExchange.sol\\\";\\nimport \\\"../interface/IUniswapFactory.sol\\\";\\nimport \\\"../interface/IUniswapRouterV2.sol\\\";\\nimport \\\"../interface/ICurveFi.sol\\\";\\nimport \\\"../interface/IAMM.sol\\\";\\nimport \\\"../interface/IWeth.sol\\\";\\nimport \\\"../interface/IPermanentStorageV1.sol\\\";\\nimport \\\"../utils/SignatureValidator.sol\\\";\\n\\ncontract AMMWrapperV3 is\\n    IAMM,\\n    ReentrancyGuard,\\n    SignatureValidator\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /* Constants */\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant BPS_MAX = 10000;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    IUserProxyV3 public immutable userProxy;\\n    IPermanentStorageV1 public immutable permStorage;\\n    address public immutable UNISWAP_V2_ROUTER_02_ADDRESS;\\n\\n    /* Storage */\\n    address public operator;\\n    uint256 public subsidyFactor;\\n\\n    /* Struct and event declaration */\\n    // Group the local variables together to prevent\\n    // Compiler error: Stack too deep, try removing local variables.\\n    struct GroupedVars {\\n        IWETH weth;\\n        bool fromEth;\\n        bool toEth;\\n        bool makerIsUniV2;\\n        string source;\\n        bytes32 transactionHash;\\n        address takerAssetInternalAddr;\\n        address makerAssetInternalAddr;\\n        uint256 receivedAmount;\\n        uint256 settleAmount;\\n\\n        // Variables used as the copy of the function parameters\\n        // to bypass stack too deep error when logging event.\\n        address userAddr;\\n        address takerAssetAddr;\\n        uint256 takerAssetAmount;\\n        address makerAddr;\\n        address makerAssetAddr;\\n        uint256 makerAssetAmount;\\n        address payable receiverAddr;\\n        uint16 feeFactor;\\n    }\\n\\n    event Swapped(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint16 feeFactor,\\n        uint16 subsidyFactor\\n    );\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"AMMWrapper: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"AMMWrapper: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    constructor (address _operator, uint256 _subsidyFactor, IUserProxyV3 _userProxy, IPermanentStorageV1 _permStorage, address _uniswap_v2_router) public {\\n        operator = _operator;\\n        subsidyFactor = _subsidyFactor;\\n        userProxy = _userProxy;\\n        permStorage = _permStorage;\\n        UNISWAP_V2_ROUTER_02_ADDRESS = _uniswap_v2_router;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"AMMWrapper: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n    function setSubsidyFactor(uint256 _subsidyFactor) external onlyOperator {\\n        subsidyFactor = _subsidyFactor;\\n    }\\n\\n    function setAllowance(address[] memory tokenList, address spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < tokenList.length; i++) {\\n            IERC20(tokenList[i]).safeApprove(spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] memory tokenList, address spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < tokenList.length; i++) {\\n            IERC20(tokenList[i]).safeApprove(spender, 0);\\n        }\\n    }\\n\\n    function depositETH() external onlyOperator {\\n        uint256 balance = address(this).balance;\\n        IWETH weth = IWETH(permStorage.wethAddr());\\n        if (balance > 0) weth.deposit{value: balance}();\\n    }\\n\\n    function _prepare(\\n        bool fromEth,\\n        IWETH weth,\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        address _userAddr,\\n        address _receiverAddr,\\n        uint256 _nonce,\\n        uint256 _deadline,\\n        bytes memory _sig\\n    ) internal returns (bytes32 transactionHash) {\\n        // Verify user signature\\n        // keccak256(\\\"tradeWithPermit(address makerAddr,address takerAssetAddr,address makerAssetAddr,uint256 takerAssetAmount,uint256 makerAssetAmount,address receiverAddr,uint256 nonce,uint256 deadline)\\\");\\n        // Compute `_hash` in two steps to prevent stack too deep error\\n        transactionHash = keccak256(\\n            abi.encode(\\n                TRADE_WITH_PERMIT_TYPEHASH,\\n                _makerAddr,\\n                _takerAssetAddr,\\n                _makerAssetAddr,\\n                _takerAssetAmount,\\n                _makerAssetAmount,\\n                _userAddr,\\n                _receiverAddr,\\n                _nonce,\\n                _deadline\\n            )\\n        );\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                transactionHash\\n            )\\n        );\\n        require(isValidSignature(_userAddr, EIP712SignDigest, bytes(\\\"\\\"), _sig), \\\"AMMWrapper: invalid user signature\\\");\\n\\n        // Validate user nonce\\n        require(permStorage.getNonce(_userAddr) == _nonce, \\\"AMMWrapper: invalid user nonce\\\");\\n        // Increment user nonce\\n        permStorage.increNonce(_userAddr);\\n\\n        // Transfer asset from user and deposit to weth if needed\\n        if (fromEth) {    \\n            require(msg.value > 0, \\\"AMMWrapper: msg.value is zero\\\");\\n            require(_takerAssetAmount == msg.value, \\\"AMMWrapper: msg.value doesn't match\\\");\\n            // Deposit ETH to weth\\n            weth.deposit{value: msg.value}();\\n        } else {\\n            userProxy.spendFromUser(_userAddr, _takerAssetAddr, _takerAssetAmount);\\n        }\\n    }\\n\\n    function _swap(\\n        bool makerIsUniV2,\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _deadline\\n    ) internal returns (string memory source, uint256 receivedAmount) {\\n        // Approve\\n        IERC20(_takerAssetAddr).safeApprove(_makerAddr, _takerAssetAmount);\\n\\n        // Swap\\n        int128 fromTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _takerAssetAddr);\\n        int128 toTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _makerAssetAddr);\\n        // minAmount = makerAssetAmount * (10000 - subsidyFactor) / 10000\\n        uint256 minAmount = _makerAssetAmount.mul((BPS_MAX.sub(subsidyFactor))).div(BPS_MAX);\\n        if (fromTokenCurveIndex != 0 || toTokenCurveIndex != 0) {\\n            source = \\\"Curve\\\";\\n            uint256 balanceBeforeTrade = IERC20(_makerAssetAddr).balanceOf(address(this));\\n            _tradeCurveTokenToToken(_makerAddr, fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount, minAmount);\\n            uint256 balanceAfterTrade = IERC20(_makerAssetAddr).balanceOf(address(this));\\n            receivedAmount = balanceAfterTrade.sub(balanceBeforeTrade);\\n        } else if (makerIsUniV2) {\\n            source = \\\"Uniswap V2\\\";\\n            receivedAmount = _tradeUniswapV2TokenToToken(_takerAssetAddr, _makerAssetAddr, _takerAssetAmount, minAmount, _deadline);\\n        } else {\\n            revert(\\\"AMMWrapper: Unsupported makerAddr\\\");\\n        }\\n\\n        // Close allowance\\n        IERC20(_takerAssetAddr).safeApprove(_makerAddr, 0);\\n    }\\n\\n    function _settle(\\n        bool _toEth,\\n        IWETH weth,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount,\\n        uint256 _receivedAmount,\\n        uint256 _feeFactor,\\n        address payable _receiverAddr\\n    )\\n        internal\\n        returns (uint256 settleAmount)\\n    {\\n        IERC20 makerAsset;\\n        if (_toEth) {\\n            makerAsset = IERC20(address(weth));\\n        } else {\\n            makerAsset = IERC20(_makerAssetAddr);\\n        }\\n\\n        if (_receivedAmount == _makerAssetAmount) {\\n            settleAmount = _receivedAmount;\\n        } else if (_receivedAmount > _makerAssetAmount) {\\n            // shouldCollectFee = ((receivedAmount - makerAssetAmount) / receivedAmount) > (feeFactor / 10000)\\n            bool shouldCollectFee = _receivedAmount.sub(_makerAssetAmount).mul(BPS_MAX) > _feeFactor.mul(_receivedAmount);\\n            if (shouldCollectFee) {\\n                // settleAmount = receivedAmount * (1 - feeFactor) / 10000\\n                settleAmount = _receivedAmount.mul(BPS_MAX.sub(_feeFactor)).div(BPS_MAX);\\n            } else {\\n                settleAmount = _makerAssetAmount;\\n            }\\n        } else {\\n            // If fee factor is smaller than subsidy factor, choose fee factor as actual subsidy factor\\n            // since we should subsidize less if we charge less.\\n            uint256 actualSubsidyFactor = (subsidyFactor < _feeFactor) ? subsidyFactor : _feeFactor;\\n\\n            // inSubsidyRange = ((makerAssetAmount - receivedAmount) / receivedAmount) > (actualSubsidyFactor / 10000)\\n            bool inSubsidyRange = _makerAssetAmount.sub(_receivedAmount).mul(BPS_MAX) <= actualSubsidyFactor.mul(_receivedAmount);\\n            require(inSubsidyRange, \\\"AMMWrapper: amount difference larger than subsidy amount\\\");\\n\\n            bool hasEnoughToSubsidize = (makerAsset.balanceOf(address(this)) >= _makerAssetAmount);\\n            require(hasEnoughToSubsidize, \\\"AMMWrapper: not enough savings to subsidize\\\");\\n\\n            settleAmount = _makerAssetAmount;\\n        }\\n\\n        // Transfer token/Eth to receiver\\n        if (_toEth) {\\n            weth.withdraw(settleAmount);\\n            _receiverAddr.transfer(settleAmount);\\n        } else {\\n            makerAsset.safeTransfer(_receiverAddr, settleAmount);\\n        }\\n    }\\n\\n    function trade(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _feeFactor,\\n        address _userAddr,\\n        address payable _receiverAddr,\\n        uint256 _nonce,\\n        uint256 _deadline,\\n        bytes memory _sig\\n    )\\n        override\\n        payable\\n        external\\n        nonReentrant\\n        onlyUserProxy\\n        returns (uint256) \\n    {\\n        GroupedVars memory vars;\\n        vars.weth = IWETH(permStorage.wethAddr());\\n\\n        // These variables are copied straight from function parameters and\\n        // used to bypass stack too deep error.\\n        vars.userAddr = _userAddr;\\n        vars.takerAssetAddr = _takerAssetAddr;\\n        vars.takerAssetAmount = _takerAssetAmount;\\n        vars.makerAddr = _makerAddr;\\n        vars.makerAssetAddr = _makerAssetAddr;\\n        vars.makerAssetAmount = _makerAssetAmount;\\n        vars.receiverAddr = _receiverAddr;\\n        vars.feeFactor = uint16(_feeFactor);\\n\\n        // Assign trade vairables\\n        vars.fromEth = (_takerAssetAddr == ZERO_ADDRESS || _takerAssetAddr == ETH_ADDRESS);\\n        vars.toEth = (_makerAssetAddr == ZERO_ADDRESS || _makerAssetAddr == ETH_ADDRESS);\\n        vars.makerIsUniV2 = (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS);\\n        vars.takerAssetInternalAddr = vars.fromEth? address(vars.weth) : _takerAssetAddr;\\n        vars.makerAssetInternalAddr = vars.toEth ? address(vars.weth) : _makerAssetAddr;\\n\\n        vars.transactionHash = _prepare(\\n            vars.fromEth,\\n            vars.weth,\\n            vars.makerAddr,\\n            vars.takerAssetAddr,\\n            vars.makerAssetAddr,\\n            vars.takerAssetAmount,\\n            vars.makerAssetAmount,\\n            vars.userAddr,\\n            vars.receiverAddr,\\n            _nonce,\\n            _deadline,\\n            _sig\\n        );\\n\\n        (vars.source, vars.receivedAmount) = _swap(\\n            vars.makerIsUniV2,\\n            vars.makerAddr,\\n            vars.takerAssetInternalAddr,\\n            vars.makerAssetInternalAddr,\\n            vars.takerAssetAmount,\\n            vars.makerAssetAmount,\\n            _deadline\\n        );\\n\\n        // Settle\\n        vars.settleAmount = _settle(\\n            vars.toEth,\\n            vars.weth,\\n            vars.makerAssetAddr,\\n            vars.makerAssetAmount,\\n            vars.receivedAmount,\\n            vars.feeFactor,\\n            vars.receiverAddr\\n        );\\n\\n        emit Swapped(\\n            vars.source,\\n            vars.transactionHash,\\n            vars.userAddr,\\n            vars.takerAssetAddr,\\n            vars.takerAssetAmount,\\n            vars.makerAddr,\\n            vars.makerAssetAddr,\\n            vars.makerAssetAmount,\\n            vars.receiverAddr,\\n            vars.settleAmount,\\n            vars.feeFactor,\\n            uint16(subsidyFactor)\\n        );\\n\\n        return vars.settleAmount;\\n    }\\n\\n    function _tradeCurveTokenToToken(\\n        address _makerAddr,\\n        int128 i,\\n        int128 j,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount\\n    ) \\n        internal \\n    {\\n        ICurveFi curve = ICurveFi(_makerAddr);\\n        curve.exchange_underlying(i, j, _takerAssetAmount, _makerAssetAmount);\\n    }\\n\\n    function _tradeUniswapV2TokenToToken(\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _deadline\\n    ) \\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n        address[] memory path = new address[](2);\\n        path[0] = _takerAssetAddr;\\n        path[1] = _makerAssetAddr;\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            path,\\n            address(this),\\n            _deadline\\n        );\\n        return amounts[1];\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/SignatureValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../interface/IERC1271Wallet.sol\\\";\\nimport \\\"./LibBytes.sol\\\";\\nimport \\\"./AMMLibEIP712.sol\\\";\\n\\n/**\\n * @dev Contains logic for signature validation.\\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\\n */\\ncontract SignatureValidator is AMMLibEIP712 {\\n  using LibBytes for bytes;\\n\\n  /***********************************|\\n  |             Variables             |\\n  |__________________________________*/\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\\n\\n  // Allowed signature types.\\n  enum SignatureType {\\n    Illegal,                     // 0x00, default value\\n    Invalid,                     // 0x01\\n    EIP712,                      // 0x02\\n    EthSign,                     // 0x03\\n    WalletBytes,                 // 0x04\\n    WalletBytes32,               // 0x05\\n    NSignatureTypes              // 0x08, number of signature types. Always leave at end.\\n\\n    // 0x SignatureType\\n    // Wallet,                      // 0x04\\n    // Validator,                   // 0x05\\n  }\\n\\n\\n  /***********************************|\\n  |        Signature Functions        |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Verifies that a hash has been signed by the given signer.\\n   * @param _signerAddress  Address that should have signed the given hash.\\n   * @param _hash           Hash of the EIP-712 encoded data\\n   * @param _data           Full EIP-712 data structure that was hashed and signed\\n   * @param _sig            Proof that the hash has been signed by signer.\\n   *      For non wallet signatures, _sig is expected to be an array tightly encoded as\\n   *      (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType)\\n   * @return isValid True if the address recovered from the provided signature matches the input signer address.\\n   */\\n  function isValidSignature(\\n    address _signerAddress,\\n    bytes32 _hash,\\n    bytes memory _data,\\n    bytes memory _sig\\n  )\\n    public\\n    view\\n    returns (bool isValid)\\n  {\\n    require(\\n      _sig.length > 0,\\n      \\\"SignatureValidator#isValidSignature: length greater than 0 required\\\"\\n    );\\n\\n    require(\\n      _signerAddress != address(0x0),\\n      \\\"SignatureValidator#isValidSignature: invalid signer\\\"\\n    );\\n\\n    // Pop last byte off of signature byte array.\\n    uint8 signatureTypeRaw = uint8(_sig.popLastByte());\\n\\n    // Ensure signature is supported\\n    require(\\n      signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\\n      \\\"SignatureValidator#isValidSignature: unsupported signature\\\"\\n    );\\n\\n    // Extract signature type\\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\\n\\n    // Variables are not scoped in Solidity.\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n    address recovered;\\n\\n    // Always illegal signature.\\n    // This is always an implicit option since a signer can create a\\n    // signature array with invalid type or length. We may as well make\\n    // it an explicit option. This aids testing and analysis. It is\\n    // also the initialization value for the enum type.\\n    if (signatureType == SignatureType.Illegal) {\\n      revert(\\\"SignatureValidator#isValidSignature: illegal signature\\\");\\n\\n\\n    // Signature using EIP712\\n    } else if (signatureType == SignatureType.EIP712) {\\n      require(\\n        _sig.length == 97,\\n        \\\"SignatureValidator#isValidSignature: length 97 required\\\"\\n      );\\n      r = _sig.readBytes32(0);\\n      s = _sig.readBytes32(32);\\n      v = uint8(_sig[64]);\\n      recovered = ecrecover(_hash, v, r, s);\\n      isValid = _signerAddress == recovered;\\n      return isValid;\\n\\n\\n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\\n    } else if (signatureType == SignatureType.EthSign) {\\n      require(\\n        _sig.length == 97,\\n        \\\"SignatureValidator#isValidSignature: length 97 required\\\"\\n      );\\n      r = _sig.readBytes32(0);\\n      s = _sig.readBytes32(32);\\n      v = uint8(_sig[64]);\\n      recovered = ecrecover(\\n        keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)),\\n        v,\\n        r,\\n        s\\n      );\\n      isValid = _signerAddress == recovered;\\n      return isValid;\\n\\n\\n    // Signature verified by wallet contract with data validation.\\n    } else if (signatureType == SignatureType.WalletBytes) {\\n      isValid = ERC1271_MAGICVALUE == IERC1271Wallet(_signerAddress).isValidSignature(_data, _sig);\\n      return isValid;\\n\\n\\n    // Signature verified by wallet contract without data validation.\\n    } else if (signatureType == SignatureType.WalletBytes32) {\\n      isValid = ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(_signerAddress).isValidSignature(_hash, _sig);\\n      return isValid;\\n    }\\n\\n    // Anything else is illegal (We do not return false because\\n    // the signature may actually be valid, just not in a format\\n    // that we currently support. In this case returning false\\n    // may lead the caller to incorrectly believe that the\\n    // signature was invalid.)\\n    revert(\\\"SignatureValidator#isValidSignature: unsupported signature\\\");\\n  }\\n}\"\r\n    },\r\n    \"contracts/interface/IERC1271Wallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ninterface  IERC1271Wallet {\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n   *   > This function MAY modify Ethereum's state\\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\\n   * @param _signature  Signature byte array associated with _data\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   *\\n   */\\n  function isValidSignature(\\n    bytes calldata _data,\\n    bytes calldata _signature)\\n    external\\n    view\\n    returns (bytes4 magicValue);\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n   *   > This function MAY modify Ethereum's state\\n   * @param _hash       keccak256 hash that was signed\\n   * @param _signature  Signature byte array associated with _data\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   */\\n  function isValidSignature(\\n    bytes32 _hash,\\n    bytes calldata _signature)\\n    external\\n    view\\n    returns (bytes4 magicValue);\\n}\"\r\n    },\r\n    \"contracts/utils/AMMLibEIP712.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2018 ZeroEx Intl.\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.6.0;\\n\\ncontract AMMLibEIP712 {\\n    /***********************************|\\n    |             Constants             |\\n    |__________________________________*/\\n\\n    // EIP-191 Header\\n    string public constant EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    // EIP712Domain\\n    string public constant EIP712_DOMAIN_NAME = \\\"Tokenlon\\\";\\n    string public constant EIP712_DOMAIN_VERSION = \\\"v5\\\";\\n\\n    // EIP712Domain Separator\\n    bytes32 public immutable EIP712_DOMAIN_SEPARATOR = keccak256(\\n        abi.encode(\\n            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n            getChainID(),\\n            address(this)\\n        )\\n    );\\n\\n    // keccak256(\\\"tradeWithPermit(address makerAddr,address takerAssetAddr,address makerAssetAddr,uint256 takerAssetAmount,uint256 makerAssetAmount,address userAddr,address receiverAddr,uint256 salt,uint256 deadline)\\\");\\n    bytes32 public constant TRADE_WITH_PERMIT_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"tradeWithPermit(\\\",\\n            \\\"address makerAddr,\\\",\\n            \\\"address takerAssetAddr,\\\",\\n            \\\"address makerAssetAddr,\\\",\\n            \\\"uint256 takerAssetAmount,\\\",\\n            \\\"uint256 makerAssetAmount,\\\",\\n            \\\"address userAddr,\\\",\\n            \\\"address receiverAddr,\\\",\\n            \\\"uint256 salt,\\\",\\n            \\\"uint256 deadline\\\",\\n            \\\")\\\"\\n        )\\n    );\\n    \\n    /**\\n        * @dev Return `chainId`\\n        */\\n    function getChainID() internal pure returns (uint) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/AMMWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interface/ISpender.sol\\\";\\nimport \\\"./interface/IUniswapExchange.sol\\\";\\nimport \\\"./interface/IUniswapFactory.sol\\\";\\nimport \\\"./interface/IUniswapRouterV2.sol\\\";\\nimport \\\"./interface/ICurveFi.sol\\\";\\nimport \\\"./interface/IAMM.sol\\\";\\nimport \\\"./interface/IWeth.sol\\\";\\nimport \\\"./interface/IPermanentStorage.sol\\\";\\nimport \\\"./utils/SignatureValidator.sol\\\";\\n\\ncontract AMMWrapper is\\n    IAMM,\\n    ReentrancyGuard,\\n    SignatureValidator\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant BPS_MAX = 10000;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    address public immutable userProxy;\\n    ISpender public immutable spender;\\n    IPermanentStorage public immutable permStorage;\\n    address public immutable UNISWAP_V2_ROUTER_02_ADDRESS;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    uint256 public subsidyFactor;\\n\\n    /* Struct and event declaration */\\n    // Group the local variables together to prevent\\n    // Compiler error: Stack too deep, try removing local variables.\\n    struct GroupedVars {\\n        IWETH weth;\\n        bool fromEth;\\n        bool toEth;\\n        bool makerIsUniV2;\\n        string source;\\n        bytes32 transactionHash;\\n        address takerAssetInternalAddr;\\n        address makerAssetInternalAddr;\\n        uint256 receivedAmount;\\n        uint256 settleAmount;\\n\\n        // Variables used as the copy of the function parameters\\n        // to bypass stack too deep error when logging event.\\n        address userAddr;\\n        address takerAssetAddr;\\n        uint256 takerAssetAmount;\\n        address makerAddr;\\n        address makerAssetAddr;\\n        uint256 makerAssetAmount;\\n        address payable receiverAddr;\\n        uint16 feeFactor;\\n        uint16 subsidyFactor;\\n    }\\n\\n    event Swapped(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint256 receivedAmount,\\n        uint16 feeFactor,\\n        uint16 subsidyFactor\\n    );\\n\\n\\n    receive() external payable {}\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"AMMWrapper: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"AMMWrapper: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"AMMWrapper: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor (address _operator, uint256 _subsidyFactor, address _userProxy, ISpender _spender, IPermanentStorage _permStorage, address _uniswap_v2_router) public {\\n        operator = _operator;\\n        subsidyFactor = _subsidyFactor;\\n        userProxy = _userProxy;\\n        spender = _spender;\\n        permStorage = _permStorage;\\n        UNISWAP_V2_ROUTER_02_ADDRESS = _uniswap_v2_router;\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    function setSubsidyFactor(uint256 _subsidyFactor) external onlyOperator {\\n        subsidyFactor = _subsidyFactor;\\n    }\\n\\n    /**\\n     * @dev approve spender to transfer tokens from this contract. This is used to collect fee.\\n     */\\n    function setAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev convert collected ETH to WETH\\n     */\\n    function depositETH() external onlyOperator {\\n        uint256 balance = address(this).balance;\\n        IWETH weth = IWETH(permStorage.wethAddr());\\n        if (balance > 0) weth.deposit{value: balance}();\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function trade(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _feeFactor,\\n        address _userAddr,\\n        address payable _receiverAddr,\\n        uint256 _salt,\\n        uint256 _deadline,\\n        bytes calldata _sig\\n    )\\n        override\\n        payable\\n        external\\n        nonReentrant\\n        onlyUserProxy\\n        returns (uint256) \\n    {\\n        require(_deadline >= block.timestamp, \\\"AMMWrapper: expired order\\\");\\n        GroupedVars memory vars;\\n        vars.weth = IWETH(permStorage.wethAddr());\\n\\n        // These variables are copied straight from function parameters and\\n        // used to bypass stack too deep error.\\n        vars.userAddr = _userAddr;\\n        vars.takerAssetAddr = _takerAssetAddr;\\n        vars.takerAssetAmount = _takerAssetAmount;\\n        vars.makerAddr = _makerAddr;\\n        vars.makerAssetAddr = _makerAssetAddr;\\n        vars.makerAssetAmount = _makerAssetAmount;\\n        vars.receiverAddr = _receiverAddr;\\n        vars.subsidyFactor = uint16(subsidyFactor);\\n        vars.feeFactor = uint16(_feeFactor);\\n        if (! permStorage.isRelayerValid(tx.origin)) {\\n            vars.feeFactor = (vars.subsidyFactor > vars.feeFactor) ? vars.subsidyFactor : vars.feeFactor;\\n            vars.subsidyFactor = 0;\\n        }\\n\\n        // Assign trade vairables\\n        vars.fromEth = (_takerAssetAddr == ZERO_ADDRESS || _takerAssetAddr == ETH_ADDRESS);\\n        vars.toEth = (_makerAssetAddr == ZERO_ADDRESS || _makerAssetAddr == ETH_ADDRESS);\\n        vars.makerIsUniV2 = (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS);\\n        vars.takerAssetInternalAddr = vars.fromEth? address(vars.weth) : _takerAssetAddr;\\n        vars.makerAssetInternalAddr = vars.toEth ? address(vars.weth) : _makerAssetAddr;\\n\\n        vars.transactionHash = _prepare(\\n            vars.fromEth,\\n            vars.weth,\\n            vars.makerAddr,\\n            vars.takerAssetAddr,\\n            vars.makerAssetAddr,\\n            vars.takerAssetAmount,\\n            vars.makerAssetAmount,\\n            vars.userAddr,\\n            vars.receiverAddr,\\n            _salt,\\n            _deadline,\\n            _sig\\n        );\\n\\n        (vars.source, vars.receivedAmount) = _swap(\\n            vars.makerIsUniV2,\\n            vars.makerAddr,\\n            vars.takerAssetInternalAddr,\\n            vars.makerAssetInternalAddr,\\n            vars.takerAssetAmount,\\n            vars.makerAssetAmount,\\n            _deadline,\\n            vars.subsidyFactor\\n        );\\n\\n        // Settle\\n        vars.settleAmount = _settle(\\n            vars.toEth,\\n            vars.weth,\\n            IERC20(vars.makerAssetInternalAddr),\\n            vars.makerAssetAmount,\\n            vars.receivedAmount,\\n            vars.feeFactor,\\n            vars.subsidyFactor,\\n            vars.receiverAddr\\n        );\\n\\n        emit Swapped(\\n            vars.source,\\n            vars.transactionHash,\\n            vars.userAddr,\\n            vars.takerAssetAddr,\\n            vars.takerAssetAmount,\\n            vars.makerAddr,\\n            vars.makerAssetAddr,\\n            vars.makerAssetAmount,\\n            vars.receiverAddr,\\n            vars.settleAmount,\\n            vars.receivedAmount,\\n            vars.feeFactor,\\n            vars.subsidyFactor\\n        );\\n\\n        return vars.settleAmount;\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It verifies user signature, transfer tokens from user and store tx hash to prevent replay attack.\\n     */\\n    function _prepare(\\n        bool fromEth,\\n        IWETH weth,\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        address _userAddr,\\n        address _receiverAddr,\\n        uint256 _salt,\\n        uint256 _deadline,\\n        bytes memory _sig\\n    ) internal returns (bytes32 transactionHash) {\\n        // Verify user signature\\n        // TRADE_WITH_PERMIT_TYPEHASH = keccak256(\\\"tradeWithPermit(address makerAddr,address takerAssetAddr,address makerAssetAddr,uint256 takerAssetAmount,uint256 makerAssetAmount,address userAddr,address receiverAddr,uint256 salt,uint256 deadline)\\\");\\n        transactionHash = keccak256(\\n            abi.encode(\\n                TRADE_WITH_PERMIT_TYPEHASH,\\n                _makerAddr,\\n                _takerAssetAddr,\\n                _makerAssetAddr,\\n                _takerAssetAmount,\\n                _makerAssetAmount,\\n                _userAddr,\\n                _receiverAddr,\\n                _salt,\\n                _deadline\\n            )\\n        );\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                transactionHash\\n            )\\n        );\\n        require(isValidSignature(_userAddr, EIP712SignDigest, bytes(\\\"\\\"), _sig), \\\"AMMWrapper: invalid user signature\\\");\\n\\n        // Transfer asset from user and deposit to weth if needed\\n        if (fromEth) {    \\n            require(msg.value > 0, \\\"AMMWrapper: msg.value is zero\\\");\\n            require(_takerAssetAmount == msg.value, \\\"AMMWrapper: msg.value doesn't match\\\");\\n            // Deposit ETH to weth\\n            weth.deposit{value: msg.value}();\\n        } else {\\n            spender.spendFromUser(_userAddr, _takerAssetAddr, _takerAssetAmount);\\n        }\\n\\n        // Validate that the transaction is not seen before\\n        require(! permStorage.isTransactionSeen(transactionHash), \\\"AMMWrapper: transaction seen before\\\");\\n        // Set transaction as seen\\n        permStorage.setTransactionSeen(transactionHash);\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It executes the swap on chosen AMM.\\n     */\\n    function _swap(\\n        bool makerIsUniV2,\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _deadline,\\n        uint256 _subsidyFactor\\n    ) internal returns (string memory source, uint256 receivedAmount) {\\n        // Approve\\n        IERC20(_takerAssetAddr).safeApprove(_makerAddr, _takerAssetAmount);\\n\\n        // Swap\\n        // minAmount = makerAssetAmount * (10000 - subsidyFactor) / 10000\\n        uint256 minAmount = _makerAssetAmount.mul((BPS_MAX.sub(_subsidyFactor))).div(BPS_MAX);\\n\\n        if (makerIsUniV2) {\\n            source = \\\"Uniswap V2\\\";\\n            receivedAmount = _tradeUniswapV2TokenToToken(_takerAssetAddr, _makerAssetAddr, _takerAssetAmount, minAmount, _deadline);\\n        } else {\\n            int128 fromTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _takerAssetAddr);\\n            int128 toTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _makerAssetAddr);\\n            if (! (fromTokenCurveIndex == 0 && toTokenCurveIndex == 0)) {\\n                source = \\\"Curve\\\";\\n                uint256 balanceBeforeTrade = IERC20(_makerAssetAddr).balanceOf(address(this));\\n                _tradeCurveTokenToToken(_makerAddr, fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount, minAmount);\\n                uint256 balanceAfterTrade = IERC20(_makerAssetAddr).balanceOf(address(this));\\n                receivedAmount = balanceAfterTrade.sub(balanceBeforeTrade);\\n            } else {\\n                revert(\\\"AMMWrapper: Unsupported makerAddr\\\");\\n            }\\n        }\\n\\n        // Close allowance\\n        IERC20(_takerAssetAddr).safeApprove(_makerAddr, 0);\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It collects fee from the trade or compensates the trade based on the actual amount swapped.\\n     */\\n    function _settle(\\n        bool _toEth,\\n        IWETH weth,\\n        IERC20 _makerAsset,\\n        uint256 _makerAssetAmount,\\n        uint256 _receivedAmount,\\n        uint256 _feeFactor,\\n        uint256 _subsidyFactor,\\n        address payable _receiverAddr\\n    )\\n        internal\\n        returns (uint256 settleAmount)\\n    {\\n        if (_receivedAmount == _makerAssetAmount) {\\n            settleAmount = _receivedAmount;\\n        } else if (_receivedAmount > _makerAssetAmount) {\\n            // shouldCollectFee = ((receivedAmount - makerAssetAmount) / receivedAmount) > (feeFactor / 10000)\\n            bool shouldCollectFee = _receivedAmount.sub(_makerAssetAmount).mul(BPS_MAX) > _feeFactor.mul(_receivedAmount);\\n            if (shouldCollectFee) {\\n                // settleAmount = receivedAmount * (1 - feeFactor) / 10000\\n                settleAmount = _receivedAmount.mul(BPS_MAX.sub(_feeFactor)).div(BPS_MAX);\\n            } else {\\n                settleAmount = _makerAssetAmount;\\n            }\\n        } else {\\n            require(_subsidyFactor > 0, \\\"AMMWrapper: this trade will not be subsidized\\\");\\n\\n            // If fee factor is smaller than subsidy factor, choose fee factor as actual subsidy factor\\n            // since we should subsidize less if we charge less.\\n            uint256 actualSubsidyFactor = (_subsidyFactor < _feeFactor) ? _subsidyFactor : _feeFactor;\\n\\n            // inSubsidyRange = ((makerAssetAmount - receivedAmount) / receivedAmount) > (actualSubsidyFactor / 10000)\\n            bool inSubsidyRange = _makerAssetAmount.sub(_receivedAmount).mul(BPS_MAX) <= actualSubsidyFactor.mul(_receivedAmount);\\n            require(inSubsidyRange, \\\"AMMWrapper: amount difference larger than subsidy amount\\\");\\n\\n            bool hasEnoughToSubsidize = (_makerAsset.balanceOf(address(this)) >= _makerAssetAmount);\\n            require(hasEnoughToSubsidize, \\\"AMMWrapper: not enough savings to subsidize\\\");\\n\\n            settleAmount = _makerAssetAmount;\\n        }\\n\\n        // Transfer token/Eth to receiver\\n        if (_toEth) {\\n            weth.withdraw(settleAmount);\\n            _receiverAddr.transfer(settleAmount);\\n        } else {\\n            _makerAsset.safeTransfer(_receiverAddr, settleAmount);\\n        }\\n    }\\n\\n    function _tradeCurveTokenToToken(\\n        address _makerAddr,\\n        int128 i,\\n        int128 j,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount\\n    ) \\n        internal \\n    {\\n        ICurveFi curve = ICurveFi(_makerAddr);\\n        curve.exchange_underlying(i, j, _takerAssetAmount, _makerAssetAmount);\\n    }\\n\\n    function _tradeUniswapV2TokenToToken(\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _deadline\\n    ) \\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n        address[] memory path = new address[](2);\\n        path[0] = _takerAssetAddr;\\n        path[1] = _makerAssetAddr;\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            path,\\n            address(this),\\n            _deadline\\n        );\\n        return amounts[1];\\n    }\\n}\"\r\n    },\r\n    \"contracts/interface/ISpender.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ISpender {\\n    function spendFromUser(address _user, address _tokenAddr, uint256 _amount) external;\\n}\"\r\n    },\r\n    \"contracts/AMMQuoter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interface/IUniswapExchange.sol\\\";\\nimport \\\"./interface/IUniswapFactory.sol\\\";\\nimport \\\"./interface/IUniswapRouterV2.sol\\\";\\nimport \\\"./interface/ICurveFi.sol\\\";\\nimport \\\"./interface/IWeth.sol\\\";\\nimport \\\"./interface/IPermanentStorage.sol\\\";\\n\\ncontract AMMQuoter {\\n    using SafeMath for uint256;\\n    /* Constants */\\n    string public constant version = \\\"5.0.0\\\";\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    address public immutable UNISWAP_V2_ROUTER_02_ADDRESS;\\n    IPermanentStorage public immutable permStorage;\\n\\n    event CurveTokenAdded(\\n        address indexed makerAddress,\\n        address indexed assetAddress,\\n        int128 index\\n    );\\n\\n    constructor (IPermanentStorage _permStorage, address _uniswap_v2_router) public {\\n        permStorage = _permStorage;\\n        UNISWAP_V2_ROUTER_02_ADDRESS = _uniswap_v2_router;\\n    }\\n    function getMakerOutAmount(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        address weth = permStorage.wethAddr();\\n        uint256 makerAssetAmount;\\n        int128 fromTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _takerAssetAddr);\\n        int128 toTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _makerAssetAddr);\\n        if (fromTokenCurveIndex != 0 || \\n            toTokenCurveIndex != 0\\n        ) {\\n            ICurveFi curve = ICurveFi(_makerAddr);\\n            makerAssetAmount = curve.get_dy_underlying(fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount).sub(1);\\n        } else if (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n            address[] memory path = new address[](2);\\n            if (_takerAssetAddr == ZERO_ADDRESS || _takerAssetAddr == ETH_ADDRESS) {\\n                path[0] = weth;\\n                path[1] = _makerAssetAddr;\\n            } else if (_makerAssetAddr == ZERO_ADDRESS || _makerAssetAddr == ETH_ADDRESS) {\\n                path[0] = _takerAssetAddr;\\n                path[1] = weth;\\n            } else {\\n                path[0] = _takerAssetAddr;\\n                path[1] = _makerAssetAddr;\\n            }\\n            uint256[] memory amounts = router.getAmountsOut(_takerAssetAmount, path);\\n            makerAssetAmount = amounts[1];\\n        } else {\\n            revert(\\\"Unsupported makerAddress\\\");\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function getBestOutAmount(\\n        address[] memory _makerAddresses,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount\\n    )\\n        public\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 0;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 makerAssetAmount = getMakerOutAmount(makerAddress, _takerAssetAddr, _makerAssetAddr, _takerAssetAmount);\\n            if (makerAssetAmount > bestAmount) {\\n                bestAmount = makerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function getTakerInAmount(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        address weth = permStorage.wethAddr();\\n        uint256 takerAssetAmount;\\n        int128 fromTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _takerAssetAddr);\\n        int128 toTokenCurveIndex = permStorage.getCurveTokenIndex(_makerAddr, _makerAssetAddr);\\n        if (fromTokenCurveIndex != 0 || \\n            toTokenCurveIndex != 0\\n        ) {\\n            ICurveFi curve = ICurveFi(_makerAddr);\\n            takerAssetAmount = curve.get_dy_underlying(toTokenCurveIndex, fromTokenCurveIndex, _makerAssetAmount);\\n        } else if (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n            address[] memory path = new address[](2);\\n            if (_takerAssetAddr == ZERO_ADDRESS || _takerAssetAddr == ETH_ADDRESS) {\\n                path[0] = weth;\\n                path[1] = _makerAssetAddr;\\n            } else if (_makerAssetAddr == ZERO_ADDRESS || _makerAssetAddr == ETH_ADDRESS) {\\n                path[0] = _takerAssetAddr;\\n                path[1] = weth;\\n            } else {\\n                path[0] = _takerAssetAddr;\\n                path[1] = _makerAssetAddr;\\n            }\\n            uint256[] memory amounts = router.getAmountsIn(_makerAssetAmount, path);\\n            takerAssetAmount = amounts[0];\\n        } else {\\n            revert(\\\"Unsupported makerAddress\\\");\\n        }\\n        return takerAssetAmount;\\n    }\\n\\n    function getBestInAmount(\\n        address[] memory _makerAddresses,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount\\n    )\\n        public\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 2**256 - 1;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 takerAssetAmount = getTakerInAmount(makerAddress, _takerAssetAddr, _makerAssetAddr, _makerAssetAmount);\\n            if (takerAssetAmount < bestAmount) {\\n                bestAmount = takerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/amm_wrapper/AMMWrapperV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"../interface/IUniswapExchange.sol\\\";\\nimport \\\"../interface/IUniswapFactory.sol\\\";\\nimport \\\"../interface/IUniswapRouterV2.sol\\\";\\nimport \\\"../interface/ICurveFi.sol\\\";\\nimport \\\"../interface/IAMMV1.sol\\\";\\nimport \\\"../interface/IWeth.sol\\\";\\n\\ncontract AMMWrapperV1 is\\n    IAMMV1,\\n    ReentrancyGuard\\n{\\n    using SafeERC20 for IERC20;\\n\\n    address public constant UNISWAP_V1_FACTORY_ADDRESS = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\\n    address public constant UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    IWETH constant internal weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n    event Swapped(\\n        address spender,\\n        address fromAssetAddress,\\n        address toAssetAddress,\\n        uint256 takerAssetAmount,\\n        uint256 makerAssetAmount\\n    );\\n\\n    receive() external payable {}\\n\\n    function getMakerOutAmount(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 makerAssetAmount;\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                makerAssetAmount = exchange.getEthToTokenInputPrice(_takerAssetAmount);\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                makerAssetAmount = exchange.getTokenToEthInputPrice(_takerAssetAmount);\\n            } else {\\n                IUniswapExchange fromExchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                IUniswapExchange toExchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                uint256 ethAmount = fromExchange.getTokenToEthInputPrice(_takerAssetAmount);\\n                makerAssetAmount = toExchange.getEthToTokenInputPrice(ethAmount);\\n            }\\n        } else if (_makerAddress == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n            address[] memory path = new address[](2);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                path[0] = address(weth);\\n                path[1] = _toAssetAddress;\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                path[0] = _fromAssetAddress;\\n                path[1] = address(weth);\\n            } else {\\n                path[0] = _fromAssetAddress;\\n                path[1] = _toAssetAddress;\\n            }\\n            uint256[] memory amounts = router.getAmountsOut(_takerAssetAmount, path);\\n            makerAssetAmount = amounts[1];\\n        } else {\\n            revert(\\\"AMMWrapperV1: Unsupported makerAddress\\\");\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function getBestOutAmount(\\n        address[] memory _makerAddresses,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 0;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 makerAssetAmount = getMakerOutAmount(makerAddress, _fromAssetAddress, _toAssetAddress, _takerAssetAmount);\\n            if (makerAssetAmount > bestAmount) {\\n                bestAmount = makerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function getTakerInAmount(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 takerAssetAmount;\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                takerAssetAmount = exchange.getEthToTokenOutputPrice(_makerAssetAmount);\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                IUniswapExchange exchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                takerAssetAmount = exchange.getTokenToEthOutputPrice(_makerAssetAmount);\\n            } else {\\n                IUniswapExchange fromExchange = IUniswapExchange(factory.getExchange(_fromAssetAddress));\\n                IUniswapExchange toExchange = IUniswapExchange(factory.getExchange(_toAssetAddress));\\n                uint256 ethAmount = toExchange.getEthToTokenOutputPrice(_makerAssetAmount);\\n                takerAssetAmount = fromExchange.getTokenToEthOutputPrice(ethAmount);\\n            }\\n        } else if (_makerAddress == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n            address[] memory path = new address[](2);\\n            if (_fromAssetAddress == ZERO_ADDRESS || _fromAssetAddress == ETH_ADDRESS) {\\n                path[0] = address(weth);\\n                path[1] = _toAssetAddress;\\n            } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n                path[0] = _fromAssetAddress;\\n                path[1] = address(weth);\\n            } else {\\n                path[0] = _fromAssetAddress;\\n                path[1] = _toAssetAddress;\\n            }\\n            uint256[] memory amounts = router.getAmountsIn(_makerAssetAmount, path);\\n            takerAssetAmount = amounts[0];\\n        } else {\\n            revert(\\\"AMMWrapperV1: Unsupported makerAddress\\\");\\n        }\\n        return takerAssetAmount;\\n    }\\n\\n    function getBestInAmount(\\n        address[] memory _makerAddresses,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount\\n    )\\n        override\\n        public\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 2**256 - 1;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 takerAssetAmount = getTakerInAmount(makerAddress, _fromAssetAddress, _toAssetAddress, _makerAssetAmount);\\n            if (takerAssetAmount < bestAmount) {\\n                bestAmount = takerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function trade(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        address _spender,\\n        uint256 deadline\\n    )\\n        override\\n        payable\\n        external\\n        nonReentrant\\n        returns (uint256) \\n    {\\n        address fromAssetInternalAddress = _fromAssetAddress;\\n        address toAssetInternalAddress = _toAssetAddress;\\n        IERC20 fromAssetInternal = IERC20(_fromAssetAddress);\\n        address targetContract = _makerAddress;\\n\\n        if (_fromAssetAddress == ZERO_ADDRESS ||\\n            _fromAssetAddress == ETH_ADDRESS) {    \\n            require(msg.value > 0, \\\"AMMWrapperV1: msg.value is zero\\\");\\n            require(_takerAssetAmount == msg.value, \\\"AMMWrapperV1: msg.value doesn't match\\\");\\n        }\\n\\n        // Transfer asset from user and deposit to weth if needed\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS &&\\n            (_fromAssetAddress == ZERO_ADDRESS ||\\n            _fromAssetAddress == ETH_ADDRESS) ) {\\n            // Deposit ETH to weth\\n            weth.deposit{value: msg.value}();\\n            fromAssetInternalAddress = address(weth);\\n            fromAssetInternal = IERC20(fromAssetInternalAddress);\\n        }   else if (_fromAssetAddress != ZERO_ADDRESS &&\\n                    _fromAssetAddress != ETH_ADDRESS) {\\n            // Transfer token from user\\n            fromAssetInternal.safeTransferFrom(_spender, address(this), _takerAssetAmount);\\n        }\\n\\n        // Replace _toAssetAddress to weth if it's ZERO_ADDRESS or ETH_ADDRESS\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS &&\\n            (_toAssetAddress == ZERO_ADDRESS ||\\n            _toAssetAddress == ETH_ADDRESS)) {\\n            toAssetInternalAddress = address(weth);\\n        }\\n\\n        // Approve\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n            targetContract = factory.getExchange(_fromAssetAddress);\\n        }\\n\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS ||\\n            (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS && (_fromAssetAddress != ZERO_ADDRESS && _fromAssetAddress != ETH_ADDRESS))\\n        ) {\\n            fromAssetInternal.safeIncreaseAllowance(targetContract, _takerAssetAmount);\\n        }\\n\\n        // Swap\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS) {\\n            _tradeUniswapV1(_fromAssetAddress, _toAssetAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        } else if (_makerAddress == UNISWAP_V2_ROUTER_02_ADDRESS) {\\n            _tradeUniswapV2TokenToToken(fromAssetInternalAddress, toAssetInternalAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        } else {\\n            revert(\\\"AMMWrapperV1: Unsupported makerAddress\\\");\\n        }\\n\\n        // Close allowance\\n        if (_makerAddress != UNISWAP_V1_FACTORY_ADDRESS ||\\n            (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS && (_fromAssetAddress != ZERO_ADDRESS && _fromAssetAddress != ETH_ADDRESS))\\n        ) {\\n            fromAssetInternal.safeApprove(targetContract, 0);\\n        }\\n\\n        // Send back assets to spender\\n        uint256 makerAssetAmount = _sendBackAssets(_makerAddress, _toAssetAddress, _makerAssetAmount, _spender);\\n        emit Swapped(_spender, _fromAssetAddress, _toAssetAddress, _takerAssetAmount, makerAssetAmount);\\n        return makerAssetAmount;\\n    }\\n\\n    function _tradeUniswapV1(\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    )\\n        internal \\n        returns (uint256) \\n    {\\n        uint256 amount = 0;\\n        if (_fromAssetAddress == ZERO_ADDRESS ||\\n            _fromAssetAddress == ETH_ADDRESS) {\\n            amount = _tradeUniswapV1EthToToken(_toAssetAddress, _makerAssetAmount, deadline);\\n        } else if (_toAssetAddress == ZERO_ADDRESS ||\\n                    _toAssetAddress == ETH_ADDRESS) {\\n            amount =_tradeUniswapV1TokenToEth(_fromAssetAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        } else {\\n            amount = _tradeUniswapV1TokenToToken(_fromAssetAddress, _toAssetAddress, _takerAssetAmount, _makerAssetAmount, deadline);\\n        }\\n        return amount;\\n    }\\n\\n    function _sendBackAssets(\\n        address _makerAddress,\\n        address _toAssetAddress,\\n        uint256 _makerAssetAmount,\\n        address _spender\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 makerAssetAmount = 0;\\n        if (_makerAddress == UNISWAP_V1_FACTORY_ADDRESS &&\\n            (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS)) {\\n            makerAssetAmount = address(this).balance;\\n            require(makerAssetAmount >= _makerAssetAmount, \\\"AMMWrapperV1: insufficient ETH\\\");\\n            // TODO: review the amount of gas provision\\n            (bool success, ) = _spender.call{ gas: 30000, value: makerAssetAmount }(\\\"\\\");\\n            require(success, \\\"AMMWrapperV1: Failed to transfer funds\\\");\\n        } else if (_toAssetAddress == ZERO_ADDRESS || _toAssetAddress == ETH_ADDRESS) {\\n            IERC20 wethToken = IERC20(address(weth));\\n            weth.withdraw(wethToken.balanceOf(address(this)));\\n            makerAssetAmount = address(this).balance;\\n            require(makerAssetAmount >= _makerAssetAmount, \\\"AMMWrapperV1: insufficient ETH\\\");\\n            // TODO: review the amount of gas provision\\n            (bool success, ) = _spender.call{ gas: 30000, value: makerAssetAmount }(\\\"\\\");\\n            require(success, \\\"AMMWrapperV1: Failed to transfer funds\\\");\\n        } else {\\n            IERC20 toAsset = IERC20(_toAssetAddress);\\n            makerAssetAmount = toAsset.balanceOf(address(this));\\n            require(makerAssetAmount >= _makerAssetAmount, \\\"AMMWrapperV1: insufficient token\\\");\\n            toAsset.safeTransfer(_spender, makerAssetAmount);\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function _tradeCurveTokenToToken(\\n        address _makerAddress,\\n        int128 i,\\n        int128 j,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount\\n    ) \\n        internal \\n    {\\n        ICurveFi curve = ICurveFi(_makerAddress);\\n        curve.exchange_underlying(i, j, _takerAssetAmount, _makerAssetAmount);\\n    }\\n\\n    function _tradeUniswapV1EthToToken(\\n        address _assetAddress,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    )\\n        internal\\n        returns (uint256 tokenBought)\\n    {\\n        IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n        address exchangeAddress = factory.getExchange(_assetAddress);\\n        uint256 amount = IUniswapExchange(exchangeAddress)\\n            .ethToTokenSwapInput\\n            {value: address(this).balance}(\\n                _makerAssetAmount,\\n                deadline\\n            );\\n        return amount;\\n    }\\n\\n    function _tradeUniswapV1TokenToEth(\\n        address _assetAddress,\\n        uint256 _makerAssetAmount,\\n        uint256 _minEthAmount,\\n        uint256 deadline\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n        address exchange = factory.getExchange(_assetAddress);\\n        uint256 ethAmount = IUniswapExchange(exchange)\\n            .tokenToEthSwapInput(\\n                _makerAssetAmount,\\n                _minEthAmount,\\n                deadline\\n            );\\n        return ethAmount;\\n    }\\n\\n    function _tradeUniswapV1TokenToToken(\\n        address _takerAssetAddress,\\n        address _makerAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    ) \\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapFactory factory = IUniswapFactory(UNISWAP_V1_FACTORY_ADDRESS);\\n        address exchange = factory.getExchange(_takerAssetAddress);\\n        uint256 ethAmount = IUniswapExchange(exchange)\\n            .tokenToEthSwapInput(\\n                _takerAssetAmount,\\n                uint256(1),\\n                deadline\\n            );\\n        uint256 amount = IUniswapExchange(factory.getExchange(_makerAssetAddress))\\n            .ethToTokenSwapInput\\n            {value: ethAmount}(\\n                _makerAssetAmount,\\n                deadline\\n            );\\n        return amount;\\n    }\\n\\n    function _tradeUniswapV2TokenToToken(\\n        address _takerAssetAddress,\\n        address _makerAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 deadline\\n    ) \\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapRouterV2 router = IUniswapRouterV2(UNISWAP_V2_ROUTER_02_ADDRESS);\\n        address[] memory path = new address[](2);\\n        path[0] = _takerAssetAddress;\\n        path[1] = _makerAssetAddress;\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            path,\\n            address(this),\\n            deadline\\n        );\\n        return amounts[1];\\n    }\\n}\"\r\n    },\r\n    \"contracts/PMM.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./pmm/0xLibs/LibOrder.sol\\\";\\nimport \\\"./pmm/0xLibs/LibDecoder.sol\\\";\\nimport \\\"./pmm/0xLibs/LibEncoder.sol\\\";\\nimport \\\"./interface/ISpender.sol\\\";\\nimport \\\"./interface/IZeroExchange.sol\\\";\\nimport \\\"./interface/IWeth.sol\\\";\\nimport \\\"./interface/IPMM.sol\\\";\\nimport \\\"./interface/IPermanentStorage.sol\\\";\\nimport \\\"./interface/IERC1271Wallet.sol\\\";\\n\\ncontract PMM is\\n    ReentrancyGuard,\\n    IPMM,\\n    LibOrder,\\n    LibDecoder,\\n    LibEncoder\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    // Constants do not have storage slot.\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    string public constant SOURCE = \\\"0x v2\\\";\\n    uint256 private constant BPS_MAX = 10000;\\n    bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;  // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    address public immutable userProxy;\\n    ISpender public immutable spender;\\n    IPermanentStorage public immutable permStorage;\\n    IZeroExchange public immutable zeroExchange;\\n    address public immutable zxERC20Proxy;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n\\n    struct TradeInfo {\\n        address user;\\n        address receiver;\\n        uint16 feeFactor;\\n        address makerAssetAddr;\\n        address takerAssetAddr;\\n        bytes32 transactionHash;\\n        bytes32 orderHash;\\n    }\\n\\n    // events\\n    event FillOrder(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        bytes32 indexed orderHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint16 feeFactor\\n    );\\n\\n\\n    receive() external payable {}\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator {\\n        require(operator == msg.sender, \\\"PMM: not operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"PMM: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"AMMWrapper: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor (address _operator, address _userProxy, ISpender _spender, IPermanentStorage _permStorage, IZeroExchange _zeroExchange, address _zxERC20Proxy) public {\\n        operator = _operator;\\n        userProxy = _userProxy;\\n        spender = _spender;\\n        permStorage = _permStorage;\\n        zeroExchange = _zeroExchange;\\n        zxERC20Proxy = _zxERC20Proxy;\\n        // This constant follows ZX_EXCHANGE address\\n        EIP712_DOMAIN_HASH = keccak256(\\n            abi.encodePacked(\\n                EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n                bytes12(0),\\n                address(_zeroExchange)\\n            )\\n        );\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /**\\n     * @dev approve spender to transfer tokens from this contract. This is used to collect fee.\\n     */\\n    function setAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n        }\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function fill(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    )\\n        override\\n        public\\n        payable\\n        onlyUserProxy\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        // decode & assert\\n        (LibOrder.Order memory order,\\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\\n\\n        // Deposit to WETH if taker asset is ETH, else transfer from user\\n        IWETH weth = IWETH(permStorage.wethAddr());\\n        if (address(weth) == tradeInfo.takerAssetAddr) {\\n            require(\\n                msg.value == order.takerAssetAmount,\\n                \\\"PMM: insufficient ETH\\\"\\n            );\\n            weth.deposit{value: msg.value}();\\n        } else {\\n            spender.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\\n        }\\n\\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\\n\\n        // send tx to 0x\\n        zeroExchange.executeTransaction(\\n            userSalt,\\n            address(this),\\n            data,\\n            \\\"\\\"\\n        );\\n\\n        // settle token/ETH to user\\n        uint256 settleAmount = _settle(weth, tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\\n\\n        emit FillOrder(\\n            SOURCE,\\n            tradeInfo.transactionHash,\\n            tradeInfo.orderHash,\\n            tradeInfo.user,\\n            tradeInfo.takerAssetAddr,\\n            order.takerAssetAmount,\\n            order.makerAddress,\\n            tradeInfo.makerAssetAddr,\\n            order.makerAssetAmount,\\n            tradeInfo.receiver,\\n            settleAmount,\\n            tradeInfo.feeFactor\\n        );\\n        return settleAmount;\\n    }\\n\\n    /**\\n     * @dev internal function of `fill`.\\n     * It decodes and validates transaction data.\\n     */\\n    function _assertTransaction(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    )\\n        internal\\n        view\\n        returns(\\n            LibOrder.Order memory order,\\n            TradeInfo memory tradeInfo\\n        )\\n    {\\n        // decode fillOrder data\\n        uint256 takerFillAmount;\\n        bytes memory mmSignature;\\n        (order, takerFillAmount, mmSignature) = decodeFillOrder(data);\\n\\n        require(\\n            order.takerAddress == address(this),\\n            \\\"PMM: incorrect taker\\\"\\n        );\\n        require(\\n            order.takerAssetAmount == takerFillAmount,\\n            \\\"PMM: incorrect fill amount\\\"\\n        );\\n\\n        // generate transactionHash\\n        tradeInfo.transactionHash = encodeTransactionHash(\\n            userSalt,\\n            address(this),\\n            data\\n        );\\n\\n        tradeInfo.orderHash = getOrderHash(order);\\n        tradeInfo.feeFactor = uint16(order.salt);\\n        tradeInfo.receiver = decodeUserSignatureWithoutSign(userSignature);\\n        tradeInfo.user = _ecrecoverAddress(tradeInfo.transactionHash, userSignature);\\n\\n        if (tradeInfo.user != order.feeRecipientAddress) {\\n            require(\\n                order.feeRecipientAddress.isContract(),\\n                \\\"PMM: invalid contract address\\\"\\n            );\\n            // isValidSignature() should return magic value: bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n            require(\\n                ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(order.feeRecipientAddress)\\n                    .isValidSignature(\\n                        tradeInfo.transactionHash,\\n                        userSignature\\n                    ),\\n                \\\"PMM: invalid ERC1271 signer\\\"\\n            );\\n            tradeInfo.user = order.feeRecipientAddress;\\n        }\\n\\n        require(\\n            tradeInfo.feeFactor < 10000,\\n            \\\"PMM: invalid fee factor\\\"\\n        );\\n\\n        require(\\n            tradeInfo.receiver != address(0),\\n            \\\"PMM: invalid receiver\\\"\\n        );\\n\\n        // decode asset\\n        // just support ERC20\\n        tradeInfo.makerAssetAddr = decodeERC20Asset(order.makerAssetData);\\n        tradeInfo.takerAssetAddr = decodeERC20Asset(order.takerAssetData);\\n        return (\\n            order,\\n            tradeInfo\\n        );        \\n    }\\n\\n    // settle\\n    function _settle(IWETH weth, address receiver, address makerAssetAddr, uint256 makerAssetAmount, uint16 feeFactor) internal returns(uint256) {\\n        uint256 settleAmount = makerAssetAmount;\\n        if (feeFactor > 0) {\\n            // settleAmount = settleAmount * (10000 - feeFactor) / 10000\\n            settleAmount = settleAmount.mul((BPS_MAX).sub(feeFactor)).div(BPS_MAX);\\n        }\\n\\n        if (makerAssetAddr == address(weth)){\\n            weth.withdraw(settleAmount);\\n            payable(receiver).transfer(settleAmount);\\n        } else {\\n            IERC20(makerAssetAddr).safeTransfer(receiver, settleAmount);\\n        }\\n\\n        return settleAmount;\\n    }\\n\\n    function _ecrecoverAddress(bytes32 transactionHash, bytes memory signature) internal pure returns (address){\\n        (uint8 v, bytes32 r, bytes32 s, address receiver) = decodeUserSignature(signature);\\n        return ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\n                    transactionHash,\\n                    receiver\\n                )),\\n            v, r, s\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/stub/ERC1271WalletStub.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interface/ISetAllowance.sol\\\";\\nimport \\\"../interface/IERC1271Wallet.sol\\\";\\n\\ncontract ERC1271WalletStub is\\n    ISetAllowance,\\n    IERC1271Wallet\\n{\\n    using SafeERC20 for IERC20;\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\\n\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    address public operator;\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Quoter: not the operator\\\");\\n        _;\\n    }\\n\\n    constructor (address _operator) public {\\n        operator = _operator;\\n    }\\n\\n    function setAllowance(address[] memory _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] memory _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n        }\\n    }\\n\\n    function isValidSignature(\\n        bytes calldata _data,\\n        bytes calldata _signature)\\n        override\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        return ERC1271_MAGICVALUE;\\n    }\\n\\n    function isValidSignature(\\n        bytes32 _hash,\\n        bytes calldata _signature)\\n        override\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        return ERC1271_MAGICVALUE_BYTES32;\\n    }\\n}\"\r\n    },\r\n    \"contracts/MarketMakerProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./interface/IWeth.sol\\\";\\nimport \\\"./pmm/mmp/Ownable.sol\\\";\\nimport \\\"./pmm/0xLibs/LibDecoder.sol\\\";\\n\\ninterface IIMBTC {\\n    function burn(uint256 amount, bytes calldata data) external;\\n}\\n\\ninterface IWBTC {\\n    function burn(uint256 value) external;\\n}\\n\\ncontract MarketMakerProxy is \\n    Ownable,\\n    LibDecoder\\n{\\n    using SafeERC20 for IERC20;\\n\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 constant MAX_UINT = 2**256 - 1;\\n    address public SIGNER;\\n\\n    // auto withdraw weth to eth\\n    address public WETH_ADDR;\\n    address public withdrawer;\\n    mapping (address => bool) public isWithdrawWhitelist;\\n\\n    modifier onlyWithdrawer() {\\n        require(\\n            msg.sender == withdrawer,\\n            \\\"MarketMakerProxy: only contract withdrawer\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor () public {\\n        owner = msg.sender;\\n        operator = msg.sender;\\n    }\\n\\n    receive() external payable {}\\n\\n    // Manage\\n    function setSigner(address _signer) public onlyOperator {\\n        SIGNER = _signer;\\n    }\\n\\n    function setConfig(address _weth) public onlyOperator {\\n        WETH_ADDR = _weth;\\n    }\\n\\n    function setWithdrawer(address _withdrawer) public onlyOperator {\\n        withdrawer = _withdrawer;\\n    }\\n\\n    function setAllowance(address[] memory token_addrs, address spender) public onlyOperator {\\n        for (uint i = 0; i < token_addrs.length; i++) {\\n            address token = token_addrs[i];\\n            IERC20(token).safeApprove(spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] memory token_addrs, address spender) public onlyOperator {\\n        for (uint i = 0; i < token_addrs.length; i++) {\\n            address token = token_addrs[i];\\n            IERC20(token).safeApprove(spender, 0);\\n        }\\n    }\\n\\n    function registerWithdrawWhitelist(address _addr, bool _add) public onlyOperator {\\n        isWithdrawWhitelist[_addr] = _add;\\n    }\\n\\n    function withdraw(address token, address payable to, uint256 amount) public onlyWithdrawer {\\n        require(\\n            isWithdrawWhitelist[to],\\n            \\\"MarketMakerProxy: not in withdraw whitelist\\\"\\n        );\\n        if(token == WETH_ADDR) {\\n            IWETH(WETH_ADDR).withdraw(amount);\\n            to.transfer(amount);\\n        } else {\\n            IERC20(token).safeTransfer(to , amount);\\n        }\\n    }\\n\\n    function withdrawETH(address payable to, uint256 amount) public onlyWithdrawer {\\n        require(\\n            isWithdrawWhitelist[to],\\n            \\\"MarketMakerProxy: not in withdraw whitelist\\\"\\n        );\\n        to.transfer(amount);\\n    }\\n\\n\\n    function isValidSignature(bytes32 orderHash, bytes memory signature) public view returns (bytes32) {\\n        require(\\n            SIGNER == _ecrecoverAddress(orderHash, signature),\\n            \\\"MarketMakerProxy: invalid signature\\\"\\n        );\\n        return keccak256(\\\"isValidWalletSignature(bytes32,address,bytes)\\\");\\n    }\\n\\n    function _ecrecoverAddress(bytes32 orderHash, bytes memory signature) internal pure returns (address) {\\n        (uint8 v, bytes32 r, bytes32 s) = decodeMmSignature(signature);\\n        return ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    orderHash\\n                )),\\n            v, r, s\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/mmp/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract Ownable {\\n  address public owner;\\n  address public operator;\\n\\n  constructor ()\\n    public\\n  {\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      msg.sender == owner,\\n      \\\"Ownable: only contract owner\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    require(\\n      msg.sender == operator,\\n      \\\"Ownable: only contract operator\\\"\\n    );\\n    _;\\n  }\\n\\n  function transferOwnership(address newOwner)\\n    public\\n    onlyOwner\\n  {\\n    if (newOwner != address(0)) {\\n      owner = newOwner;\\n    }\\n  }\\n\\n  function setOperator(address newOperator)\\n    public\\n    onlyOwner \\n  {\\n    operator = newOperator;\\n  }\\n}\"\r\n    },\r\n    \"contracts/upgrade_proxy/UpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n * \\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     * \\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length > 0) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success,) = _logic.delegatecall(_data);\\n            require(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal override view returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     * \\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/upgrade_proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n * \\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n * \\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     * \\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal virtual view returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     * \\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     * \\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\"\r\n    },\r\n    \"contracts/upgrade_proxy/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n * \\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n * \\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n * \\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n * \\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(_admin);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     * \\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address) {\\n        return _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     * \\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address) {\\n        return _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     * \\n     * Emits an {AdminChanged} event.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeTo(newImplementation);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success,) = newImplementation.delegatecall(data);\\n        require(success);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal override virtual {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\"\r\n    },\r\n    \"contracts/Tokenlon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./upgrade_proxy/TransparentUpgradeableProxy.sol\\\";\\n\\ncontract Tokenlon is TransparentUpgradeableProxy {\\n    constructor(address _logic, address _admin, bytes memory _data) public payable TransparentUpgradeableProxy(_logic, _admin, _data) {}\\n}\"\r\n    },\r\n    \"contracts/PermanentStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"./interface/IPermanentStorage.sol\\\";\\nimport \\\"./utils/lib_storage/PSStorage.sol\\\";\\n\\ncontract PermanentStorage is IPermanentStorage {\\n\\n    // Constants do not have storage slot.\\n    bytes32 public constant curveTokenIndexStorageId = 0xf4c750cdce673f6c35898d215e519b86e3846b1f0532fb48b84fe9d80f6de2fc; // keccak256(\\\"curveTokenIndex\\\")\\n    bytes32 public constant transactionSeenStorageId = 0x695d523b8578c6379a2121164fd8de334b9c5b6b36dff5408bd4051a6b1704d0;  // keccak256(\\\"transactionSeen\\\")\\n    bytes32 public constant relayerValidStorageId = 0x2c97779b4deaf24e9d46e02ec2699240a957d92782b51165b93878b09dd66f61;  // keccak256(\\\"relayerValid\\\")\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    string public version;  // Current version of the contract\\n    mapping(bytes32 => mapping(address => bool)) private permission;\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"PermanentStorage: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier validRole(bool _enabled, address _role) {\\n        if (_enabled) {\\n            require(\\n                (_role == operator) || (_role == ammWrapperAddr()) || (_role == pmmAddr()),\\n                \\\"PermanentStorage: not a valid role\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    modifier isPermitted(bytes32 _storageId, address _role) {\\n        require(permission[_storageId][_role], \\\"PermanentStorage: has no permission\\\");\\n        _;\\n    }\\n\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"PermanentStorage: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n    /// @dev Set permission for entity to write certain storage.\\n    function setPermission(bytes32 _storageId, address _role, bool _enabled) external onlyOperator validRole(_enabled, _role) {\\n        permission[_storageId][_role] = _enabled;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\\n    function initialize(address _operator) external {\\n        require(\\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"\\\")),\\n            \\\"PermanentStorage: not upgrading from default version\\\"\\n        );\\n\\n        version = \\\"5.0.0\\\";\\n        operator = _operator;\\n    }\\n\\n\\n    /************************************************************\\n    *                     Getter functions                      *\\n    *************************************************************/\\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool) {\\n        return permission[_storageId][_role];\\n    }\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return PSStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PSStorage.getStorage().pmmAddr;\\n    }\\n\\n    function wethAddr() override external view returns (address) {\\n        return PSStorage.getStorage().wethAddr;\\n    }\\n\\n    function getCurveTokenIndex(address _makerAddr, address _assetAddr) override external view returns (int128) {\\n        return AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_assetAddr];\\n    }\\n\\n    function isTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRelayerValid(address _relayer) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().relayerValid[_relayer];\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /// @dev Update AMMWrapper contract address.\\n    function upgradeAMMWrapper(address _newAMMWrapper) external onlyOperator {\\n        PSStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\\n    }\\n\\n    /// @dev Update PMM contract address.\\n    function upgradePMM(address _newPMM) external onlyOperator {\\n        PSStorage.getStorage().pmmAddr = _newPMM;\\n    }\\n\\n    /// @dev Update WETH contract address.\\n    function upgradeWETH(address _newWETH) external onlyOperator {\\n        PSStorage.getStorage().wethAddr = _newWETH;\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function setCurveTokenIndex(address _makerAddr, address[] calldata _assetAddrs) override external isPermitted(curveTokenIndexStorageId, msg.sender) {\\n        int128 tokenLength = int128(_assetAddrs.length);\\n        for (int128 i = 0 ; i < tokenLength; i++) {\\n            address assetAddr = _assetAddrs[uint256(i)];\\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i;\\n        }\\n    }\\n\\n    function setTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRelayersValid(address[] calldata _relayers, bool[] calldata _isValids) override external isPermitted(relayerValidStorageId, msg.sender) {\\n        require(_relayers.length == _isValids.length, \\\"PermanentStorage: inputs length mismatch\\\");\\n        for (uint256 i = 0; i < _relayers.length; i++) {\\n            AMMWrapperStorage.getStorage().relayerValid[_relayers[i]] = _isValids[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/lib_storage/PSStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary PSStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x92dd52b981a2dd69af37d8a3febca29ed6a974aede38ae66e4ef773173aba471;\\n\\n    struct Storage {\\n        address ammWrapperAddr;\\n        address pmmAddr;\\n        address wethAddr;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.storage.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xd38d862c9fa97c2fa857a46e08022d272a3579c114ca4f335f1e5fcb692c045e;\\n\\n    struct Storage {\\n        mapping(bytes32 => bool) transactionSeen;\\n        mapping(address => mapping(address => int128)) curveTokenIndexes;\\n        mapping(address => bool) relayerValid;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary PMMStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xf9faf013fe1696003dca3723ade1a1b88f21762ea39d9dfa2c55c5bd9c4ae6e9;\\n\\n    struct Storage {\\n        mapping(bytes32 => address) transactions;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.pmm.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subsidyFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"contract ISpender\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"contract IPermanentStorage\",\"name\":\"_permStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswap_v2_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"takerAssetAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAssetAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"feeFactor\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"subsidyFactor\",\"type\":\"uint16\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EIP191_HEADER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRADE_WITH_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V2_ROUTER_02_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"closeAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permStorage\",\"outputs\":[{\"internalType\":\"contract IPermanentStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"setAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subsidyFactor\",\"type\":\"uint256\"}],\"name\":\"setSubsidyFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spender\",\"outputs\":[{\"internalType\":\"contract ISpender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subsidyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_receiverAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AMMWrapper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000000112b7ced0de10a4a44831e978b810b35f82aaa2000000000000000000000000000000000000000000000000000000000000001400000000000000000000000003f34be1bf910116595db1b11e9d1b2ca5d596590000000000000000000000003c68dfc45dc92c9c605d92b49858073e10b857a60000000000000000000000006d9cc14a1d36e6ff13fc6efa9e9326fcd12e79030000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}