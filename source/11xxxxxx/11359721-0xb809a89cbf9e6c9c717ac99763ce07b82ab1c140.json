{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gelatonetwork/core/contracts/provider_modules/IGelatoProviderModule.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {Action, Task} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ninterface IGelatoProviderModule {\\n\\n    /// @notice Check if provider agrees to pay for inputted task receipt\\n    /// @dev Enables arbitrary checks by provider\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @return \\\"OK\\\" if provider agrees\\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Convert action specific payload into proxy specific payload\\n    /// @dev Encoded multiple actions into a multisend\\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\\n    /// @return Encoded payload that will be used for low-level .call on user proxy\\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\\n    function execPayload(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task,\\n        uint256 _cycleId\\n    )\\n        external\\n        view\\n        returns(bytes memory, bool checkReturndata);\\n\\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"../../provider_modules/IGelatoProviderModule.sol\\\";\\nimport {IGelatoCondition} from \\\"../../conditions/IGelatoCondition.sol\\\";\\n\\nstruct Provider {\\n    address addr;  //  if msg.sender == provider => self-Provider\\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\\n}\\n\\nstruct Condition {\\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\\n    bytes data;  // can be bytes32(0) for self-conditional Actions\\n}\\n\\nenum Operation { Call, Delegatecall }\\n\\nenum DataFlow { None, In, Out, InAndOut }\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions;  // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\\n}\\n\\nstruct TaskReceipt {\\n    uint256 id;\\n    address userProxy;\\n    Provider provider;\\n    uint256 index;\\n    Task[] tasks;\\n    uint256 expiryDate;\\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\\n    uint256 submissionsLeft;\\n}\\n\\ninterface IGelatoCore {\\n    event LogTaskSubmitted(\\n        uint256 indexed taskReceiptId,\\n        bytes32 indexed taskReceiptHash,\\n        TaskReceipt taskReceipt\\n    );\\n\\n    event LogExecSuccess(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorSuccessFee,\\n        uint256 sysAdminSuccessFee\\n    );\\n    event LogCanExecFailed(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        string reason\\n    );\\n    event LogExecReverted(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorRefund,\\n        string reason\\n    );\\n\\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\\n\\n    /// @notice API to query whether Task can be submitted successfully.\\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _userProxy The userProxy from which the task will be submitted.\\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\\n    function canSubmitTask(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice API to submit a single Task.\\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task A Gelato Task object: provider, conditions, actions.\\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _cycles How many full cycles will be submitted\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\\n    ///  would be submitted, but not the second\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\\n    ///  that should have occured once the cycle is complete:\\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\\n    ///  ...\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    )\\n        external;\\n\\n    // ================  Exec Suite =========================\\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\\n    ///   In the latter case Executors are refunded by the Task Provider.\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function exec(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel task\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function cancelTask(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel multiple tasks at once\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\\n\\n    /// @notice Compute hash of task receipt\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @return hash of taskReceipt\\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\\n\\n    // ================  Getters =========================\\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\\n    /// @return currentId currentId, last TaskReceiptId submitted\\n    function currentTaskReceiptId() external view returns(uint256);\\n\\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\\n    /// @return hash of taskReceipt\\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/conditions/IGelatoCondition.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\\n        external\\n        view\\n        returns(string memory);\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nimport \\\"./IGelatoCondition.sol\\\";\\n\\nabstract contract GelatoConditionsStandard is IGelatoCondition {\\n    string internal constant OK = \\\"OK\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/ConditionMakerVaultUnsafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport {wmul, wdiv} from \\\"../../../vendor/DSMath.sol\\\";\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    IInstaMakerResolver\\n} from \\\"../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\\\";\\n\\n/// @title ConditionMakerVaultUnsafe\\n/// @notice Condition tracking Maker vault collateralization safety requirements.\\n/// @author Gelato Team\\ncontract ConditionMakerVaultUnsafe is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    /// @notice Convenience function for off-chain _conditionData encoding\\n    /// @dev Use the return for your Task's Condition.data field off-chain.\\n    /// @return The encoded payload for your Task's Condition.data field.\\n    function getConditionData(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes calldata _oraclePayload,\\n        uint256 _minColRatio\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.isVaultUnsafe.selector,\\n                _vaultId,\\n                _priceOracle,\\n                _oraclePayload,\\n                _minColRatio\\n            );\\n    }\\n\\n    /// @notice Standard GelatoCore system function\\n    /// @dev A standard interface for GelatoCore to read Conditions\\n    /// @param _conditionData The data you get from `getConditionData()`\\n    /// @return OK if the Condition is there, else some error message.\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            uint256 _vaultID,\\n            address _priceOracle,\\n            bytes memory _oraclePayload,\\n            uint256 _minColRatio\\n        ) = abi.decode(_conditionData[4:], (uint256, address, bytes, uint256));\\n\\n        return\\n            isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio);\\n    }\\n\\n    /// @notice Specific implementation of this Condition's ok function\\n    /// @dev The price oracle must return a uint256 WAD (10**18) value.\\n    /// @param _vaultId The id of the Maker vault\\n    /// @param _priceOracle The price oracle contract to supply the collateral price\\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\\n    ///  method e.g. the selector for MakerOracle's read fn.\\n    /// @param _minColRatio The minimum collateral ratio measured in the price\\n    /// of the collateral as specified by the _priceOracle.\\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\\n    function isVaultUnsafe(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes memory _oraclePayload,\\n        uint256 _minColRatio\\n    ) public view virtual returns (string memory) {\\n        (bool success, bytes memory returndata) =\\n            _priceOracle.staticcall(_oraclePayload);\\n\\n        if (!success) {\\n            returndata.revertWithError(\\n                \\\"ConditionMakerVaultUnsafe.isVaultUnsafe:oracle:\\\"\\n            );\\n        }\\n\\n        uint256 colPriceInWad = abi.decode(returndata, (uint256));\\n\\n        IInstaMakerResolver.VaultData memory vault =\\n            IInstaMakerResolver(0x0A7008B38E7015F8C36A49eEbc32513ECA8801E5)\\n                .getVaultById(_vaultId);\\n\\n        uint256 colRatio =\\n            wdiv(wmul(vault.collateral, colPriceInWad), vault.debt);\\n\\n        return colRatio < _minColRatio ? OK : \\\"MakerVaultNotUnsafe\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: AGPL-3.0-or-later\\\"\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.4;\\n\\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\n\\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\n\\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nfunction imin(int256 x, int256 y) pure returns (int256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction imax(int256 x, int256 y) pure returns (int256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint256 constant WAD = 10**18;\\nuint256 constant RAY = 10**27;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, y), WAD / 2) / WAD;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction rmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, y), RAY / 2) / RAY;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, WAD), y / 2) / y;\\n}\\n\\n//rounds to zero if x*y < RAY / 2\\nfunction rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction rpow(uint256 x, uint256 n) pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = rmul(z, x);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IInstaMakerResolver {\\n    struct VaultData {\\n        uint256 id;\\n        address owner;\\n        string colType;\\n        uint256 collateral;\\n        uint256 art;\\n        uint256 debt;\\n        uint256 liquidatedCol;\\n        uint256 borrowRate;\\n        uint256 colPrice;\\n        uint256 liquidationRatio;\\n        address vaultAddress;\\n    }\\n\\n    function getVaultById(uint256 id) external view returns (VaultData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/resolvers/PriceOracleResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\n\\n/// @title PriceOracleResolver\\n/// @notice Contract with convenience methods to retrieve oracle addresses or to mock test.\\n/// @dev Can be used to:\\n///  - Query oracle address for Gelato Condition payloads on frontend\\n///  - Test Conditions by using `getMockPrice(address _test)` as `oraclePayload`\\ncontract PriceOracleResolver is Ownable {\\n    using GelatoBytes for bytes;\\n\\n    mapping(string => address) public oracle;\\n    mapping(string => bytes) public oraclePayload;\\n    mapping(address => uint256) public mockPrice;\\n\\n    /// @notice Adds a new Oracle address\\n    /// @dev Only owner can call this, but existing oracle entries are immutable\\n    /// @param _oracle The descriptor of the oracle e.g. ETH/USD-Maker-v1\\n    /// @param _oracleAddress The address of the oracle contract\\n    /// @param _oraclePayload The payload with function selector for the oracle request.\\n    function addOracle(\\n        string memory _oracle,\\n        address _oracleAddress,\\n        bytes calldata _oraclePayload\\n    ) external onlyOwner {\\n        require(\\n            oracle[_oracle] == address(0),\\n            \\\"PriceOracleResolver.addOracle: set\\\"\\n        );\\n        oracle[_oracle] = _oracleAddress;\\n        oraclePayload[_oracle] = _oraclePayload;\\n    }\\n\\n    /// @notice Function that allows easy oracle data testing in production.\\n    /// @dev Your mock prices cannot be overriden by someone else.\\n    /// @param _mockPrice The mock data you want to test against.\\n    function setMockPrice(uint256 _mockPrice) public {\\n        mockPrice[msg.sender] = _mockPrice;\\n    }\\n\\n    /// @notice Use with setMockPrice for easy testing in production.\\n    /// @dev Encode oracle=PriceOracleResolver and oraclePayload=getMockPrice(tester)\\n    ///  to test your Conditions or Actions that make dynamic calls to price oracles.\\n    /// @param _tester The msg.sender during setMockPrice.\\n    /// @return The tester's mockPrice.\\n    function getMockPrice(address _tester) external view returns (uint256) {\\n        return mockPrice[_tester];\\n    }\\n\\n    /// @notice A generelized getter for a price supplied by an oracle contract.\\n    /// @dev The oracle returndata must be formatted as a single uint256.\\n    /// @param _oracle The descriptor of our oracle e.g. ETH/USD-Maker-v1\\n    /// @return The uint256 oracle price\\n    function getPrice(string memory _oracle) external view returns (uint256) {\\n        address oracleAddr = oracle[_oracle];\\n        if (oracleAddr == address(0))\\n            revert(\\\"PriceOracleResolver.getPrice: no oracle\\\");\\n        (bool success, bytes memory returndata) =\\n            oracleAddr.staticcall(oraclePayload[_oracle]);\\n        if (!success)\\n            returndata.revertWithError(\\\"PriceOracleResolver.getPrice:\\\");\\n        return abi.decode(returndata, (uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/ConditionDestVaultWillBeSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _vaultWillBeSafe,\\n    _newVaultWillBeSafe,\\n    _isVaultOwner\\n} from \\\"../../../functions/dapps/FMaker.sol\\\";\\nimport {DAI} from \\\"../../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getRealisedDebt\\n} from \\\"../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../../functions/gelato/FGelato.sol\\\";\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\nimport {sub} from \\\"../../../vendor/DSMath.sol\\\";\\n\\ncontract ConditionDestVaultWillBeSafe is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    function getConditionData(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string calldata _destColType\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.destVaultWillBeSafe.selector,\\n                _dsa,\\n                _fromVaultId,\\n                _destVaultId,\\n                _destColType\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            address _dsa,\\n            uint256 _fromVaultId,\\n            uint256 _destVaultId,\\n            string memory _destColType\\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\\n\\n        return\\n            destVaultWillBeSafe(_dsa, _fromVaultId, _destVaultId, _destColType);\\n    }\\n\\n    function destVaultWillBeSafe(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string memory _destColType\\n    ) public view returns (string memory) {\\n        _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\\n        uint256 wDaiToBorrow =\\n            _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\\n        uint256 wColToDeposit =\\n            sub(\\n                _getMakerVaultCollateralBalance(_fromVaultId),\\n                _getGelatoExecutorFees(\\n                    _getGasCostMakerToMaker(\\n                        _destVaultId == 0,\\n                        _getFlashLoanRoute(DAI, wDaiToBorrow)\\n                    )\\n                )\\n            );\\n\\n        return\\n            destVaultWillBeSafeExplicit(\\n                _destVaultId,\\n                wDaiToBorrow,\\n                wColToDeposit,\\n                _destColType\\n            )\\n                ? OK\\n                : \\\"DestVaultWillNotBeSafe\\\";\\n    }\\n\\n    function destVaultWillBeSafeExplicit(\\n        uint256 _vaultId,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToDeposit,\\n        string memory _colType\\n    ) public view returns (bool) {\\n        return\\n            _vaultId == 0\\n                ? _newVaultWillBeSafe(_colType, _wDaiToBorrow, _wColToDeposit)\\n                : _vaultWillBeSafe(_vaultId, _wDaiToBorrow, _wColToDeposit);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/dapps/FMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {MCD_MANAGER} from \\\"../../constants/CMaker.sol\\\";\\nimport {INSTA_MAPPING} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    ITokenJoinInterface\\n} from \\\"../../interfaces/dapps/Maker/ITokenJoinInterface.sol\\\";\\nimport {IMcdManager} from \\\"../../interfaces/dapps/Maker/IMcdManager.sol\\\";\\nimport {InstaMapping} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {IVat} from \\\"../../interfaces/dapps/Maker/IVat.sol\\\";\\nimport {RAY, add, sub, mul} from \\\"../../vendor/DSMath.sol\\\";\\nimport {_stringToBytes32, _convertTo18} from \\\"../../vendor/Convert.sol\\\";\\n\\nfunction _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n    uint256 dai = vat.dai(urn);\\n\\n    uint256 rad = sub(mul(art, rate), dai);\\n    wad = rad / RAY;\\n\\n    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n}\\n\\nfunction _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n\\n    uint256 rad = mul(art, rate);\\n\\n    tab = rad / RAY;\\n    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\\n}\\n\\nfunction _getMakerVaultCollateralBalance(uint256 _vaultId)\\n    view\\n    returns (uint256)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    IVat vat = IVat(manager.vat());\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    (uint256 ink, ) = vat.urns(ilk, urn);\\n\\n    return ink;\\n}\\n\\nfunction _vaultWillBeSafe(\\n    uint256 _vaultId,\\n    uint256 _amtToBorrow,\\n    uint256 _colToDeposit\\n) view returns (bool) {\\n    require(_vaultId != 0, \\\"_vaultWillBeSafe: invalid vault id.\\\");\\n\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n\\n    ITokenJoinInterface tokenJoinContract =\\n        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\\n\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\\n    (uint256 ink, uint256 art) = vat.urns(ilk, urn);\\n    uint256 dai = vat.dai(urn);\\n\\n    uint256 dink = _convertTo18(tokenJoinContract.dec(), _colToDeposit);\\n    uint256 dart = _getBorrowAmt(_amtToBorrow, dai, rate);\\n\\n    ink = add(ink, dink);\\n    art = add(art, dart);\\n\\n    uint256 tab = mul(rate, art);\\n\\n    return tab <= mul(ink, spot);\\n}\\n\\nfunction _newVaultWillBeSafe(\\n    string memory _colType,\\n    uint256 _amtToBorrow,\\n    uint256 _colToDeposit\\n) view returns (bool) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n    IVat vat = IVat(manager.vat());\\n\\n    bytes32 ilk = _stringToBytes32(_colType);\\n\\n    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\\n\\n    ITokenJoinInterface tokenJoinContract =\\n        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\\n\\n    uint256 ink = _convertTo18(tokenJoinContract.dec(), _colToDeposit);\\n    uint256 art = _getBorrowAmt(_amtToBorrow, 0, rate);\\n\\n    uint256 tab = mul(rate, art);\\n\\n    return tab <= mul(ink, spot);\\n}\\n\\nfunction _getVaultData(IMcdManager manager, uint256 vault)\\n    view\\n    returns (bytes32 ilk, address urn)\\n{\\n    ilk = manager.ilks(vault);\\n    urn = manager.urns(vault);\\n}\\n\\nfunction _getBorrowAmt(\\n    uint256 _amt,\\n    uint256 _dai,\\n    uint256 _rate\\n) pure returns (uint256 dart) {\\n    dart = sub(mul(_amt, RAY), _dai) / _rate;\\n    dart = mul(dart, _rate) < mul(_amt, RAY) ? dart + 1 : dart;\\n}\\n\\nfunction _isVaultOwner(uint256 _vaultId, address _owner) view returns (bool) {\\n    if (_vaultId == 0) return false;\\n\\n    try IMcdManager(MCD_MANAGER).owns(_vaultId) returns (address owner) {\\n        return _owner == owner;\\n    } catch Error(string memory error) {\\n        revert(string(abi.encodePacked(\\\"FMaker._isVaultOwner:\\\", error)));\\n    } catch {\\n        revert(\\\"FMaker._isVaultOwner:undefined\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\n// InstaDapp\\naddress constant INSTA_MEMORY = 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F;\\n\\n// Connectors\\naddress constant CONNECT_MAKER = 0xac02030d8a8F49eD04b2f52C394D3F901A10F8A9;\\naddress constant CONNECT_COMPOUND = 0x15FdD1e902cAC70786fe7D31013B1a806764B5a2;\\naddress constant INSTA_POOL_V2 = 0xeB4bf86589f808f90EEC8e964dBF16Bd4D284905;\\n\\n// Tokens\\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n// Insta Pool\\naddress constant INSTA_POOL_RESOLVER = 0xa004a5afBa04b74037E9E52bA1f7eb02b5E61509;\\nuint256 constant ROUTE_1_TOLERANCE = 1005e15;\\n\\n// Insta Mapping\\naddress constant INSTA_MAPPING = 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88;\\n\"\r\n    },\r\n    \"contracts/functions/gelato/FGelatoDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {add, sub, mul, wmul, wdiv} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    INSTA_POOL_RESOLVER,\\n    ROUTE_1_TOLERANCE\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    GAS_COSTS_FOR_FULL_REFINANCE,\\n    PREMIUM,\\n    VAULT_CREATION_COST\\n} from \\\"../../constants/CDebtBridge.sol\\\";\\nimport {\\n    IInstaPoolResolver\\n} from \\\"../../interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\\\";\\n\\nfunction _wCalcCollateralToWithdraw(\\n    uint256 _wMinColRatioA,\\n    uint256 _wMinColRatioB,\\n    uint256 _wColPrice,\\n    uint256 _wPricedCol,\\n    uint256 _wDebtOnA\\n) pure returns (uint256) {\\n    return\\n        wdiv(\\n            sub(\\n                _wPricedCol,\\n                wdiv(\\n                    sub(\\n                        wmul(_wMinColRatioA, _wPricedCol),\\n                        wmul(_wMinColRatioA, wmul(_wMinColRatioB, _wDebtOnA))\\n                    ),\\n                    sub(_wMinColRatioA, _wMinColRatioB)\\n                )\\n            ),\\n            _wColPrice\\n        );\\n}\\n\\nfunction _wCalcDebtToRepay(\\n    uint256 _wMinColRatioA,\\n    uint256 _wMinColRatioB,\\n    uint256 _wPricedCol,\\n    uint256 _wDebtOnA\\n) pure returns (uint256) {\\n    return\\n        sub(\\n            _wDebtOnA,\\n            wmul(\\n                wdiv(1e18, _wMinColRatioA),\\n                wdiv(\\n                    sub(\\n                        wmul(_wMinColRatioA, _wPricedCol),\\n                        wmul(_wMinColRatioA, wmul(_wMinColRatioB, _wDebtOnA))\\n                    ),\\n                    sub(_wMinColRatioA, _wMinColRatioB)\\n                )\\n            )\\n        );\\n}\\n\\nfunction _getFlashLoanRoute(address _tokenA, uint256 _wTokenADebtToMove)\\n    view\\n    returns (uint256)\\n{\\n    IInstaPoolResolver.RouteData memory rData =\\n        IInstaPoolResolver(INSTA_POOL_RESOLVER).getTokenLimit(_tokenA);\\n\\n    if (rData.dydx > _wTokenADebtToMove) return 0;\\n    if (rData.maker > _wTokenADebtToMove) return 1;\\n    if (rData.compound > _wTokenADebtToMove) return 2;\\n    if (rData.aave > _wTokenADebtToMove) return 3;\\n    revert(\\\"FGelatoDebtBridge._getFlashLoanRoute: illiquid\\\");\\n}\\n\\nfunction _getGasCostMakerToMaker(bool _newVault, uint256 _route)\\n    pure\\n    returns (uint256)\\n{\\n    _checkRouteIndex(_route);\\n    return\\n        _getGasCostPremium(\\n            _newVault\\n                ? add(\\n                    GAS_COSTS_FOR_FULL_REFINANCE()[_route],\\n                    VAULT_CREATION_COST\\n                )\\n                : GAS_COSTS_FOR_FULL_REFINANCE()[_route]\\n        );\\n}\\n\\nfunction _getGasCostMakerToCompound(uint256 _route) pure returns (uint256) {\\n    _checkRouteIndex(_route);\\n    return _getGasCostPremium(GAS_COSTS_FOR_FULL_REFINANCE()[_route]);\\n}\\n\\nfunction _getGasCostPremium(uint256 _rawGasCost) pure returns (uint256) {\\n    return mul(_rawGasCost, add(100, PREMIUM)) / 100;\\n}\\n\\nfunction _getRealisedDebt(uint256 _debtToMove) pure returns (uint256) {\\n    return wmul(_debtToMove, ROUTE_1_TOLERANCE);\\n}\\n\\nfunction _checkRouteIndex(uint256 _route) pure {\\n    require(\\n        _route <= 4,\\n        \\\"FGelatoDebtBridge._getGasCostMakerToMaker: invalid route index\\\"\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/FGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {GELATO_GAS_PRICE_ORACLE} from \\\"../../constants/CGelato.sol\\\";\\nimport {mul} from \\\"../../vendor/DSMath.sol\\\";\\n\\nfunction _getGelatoGasPrice() view returns (uint256) {\\n    int256 oracleGasPrice = GELATO_GAS_PRICE_ORACLE.latestAnswer();\\n    if (oracleGasPrice <= 0) revert(\\\"_getGelatoGasPrice:0orBelow\\\");\\n    return uint256(oracleGasPrice);\\n}\\n\\nfunction _getGelatoExecutorFees(uint256 _gas) view returns (uint256) {\\n    return mul(_gas, _getGelatoGasPrice());\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\naddress constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/ITokenJoinInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface ITokenJoinInterface {\\n    function dec() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IMcdManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IMcdManager {\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function vat() external view returns (address);\\n\\n    function owns(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/IInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\n/// @notice Interface InstaDapp Index\\ninterface IndexInterface {\\n    function connectors(uint256 version) external view returns (address);\\n\\n    function list() external view returns (address);\\n}\\n\\n/// @notice Interface InstaDapp List\\ninterface ListInterface {\\n    function accountID(address _account) external view returns (uint64);\\n}\\n\\n/// @notice Interface InstaDapp InstaMemory\\ninterface MemoryInterface {\\n    function setUint(uint256 _id, uint256 _val) external;\\n\\n    function getUint(uint256 _id) external returns (uint256);\\n}\\n\\n/// @notice Interface InstaDapp Defi Smart Account wallet\\ninterface AccountInterface {\\n    function cast(\\n        address[] calldata _targets,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32[] memory responses);\\n\\n    function version() external view returns (uint256);\\n\\n    function isAuth(address user) external view returns (bool);\\n\\n    function shield() external view returns (bool);\\n}\\n\\ninterface ConnectorInterface {\\n    function connectorID() external view returns (uint256 _type, uint256 _id);\\n\\n    function name() external view returns (string memory);\\n}\\n\\ninterface InstaMapping {\\n    function gemJoinMapping(bytes32) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IVat {\\n    function ilks(bytes32)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function dai(address) external view returns (uint256);\\n\\n    function urns(bytes32, address) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/Convert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {mul as _mul} from \\\"./DSMath.sol\\\";\\n\\nfunction _stringToBytes32(string memory str) pure returns (bytes32 result) {\\n    require(bytes(str).length != 0, \\\"string-empty\\\");\\n    assembly {\\n        result := mload(add(str, 32))\\n    }\\n}\\n\\nfunction _convertTo18(uint256 _dec, uint256 _amt) pure returns (uint256 amt) {\\n    amt = _mul(_amt, 10**(18 - _dec));\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nfunction GAS_COSTS_FOR_FULL_REFINANCE() pure returns (uint256[4] memory) {\\n    return [uint256(2519000), 3140500, 3971000, 4345000];\\n}\\n\\nuint256 constant PREMIUM = 30;\\nuint256 constant VAULT_CREATION_COST = 200000;\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IInstaPoolResolver {\\n    struct RouteData {\\n        uint256 dydx;\\n        uint256 maker;\\n        uint256 compound;\\n        uint256 aave;\\n    }\\n\\n    function getTokenLimit(address token)\\n        external\\n        view\\n        returns (RouteData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IGelatoGasPriceOracle\\n} from \\\"../interfaces/gelato/IGelatoGasPriceOracle.sol\\\";\\n\\nIGelatoGasPriceOracle constant GELATO_GAS_PRICE_ORACLE = IGelatoGasPriceOracle(\\n    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\\n);\\n\"\r\n    },\r\n    \"contracts/interfaces/gelato/IGelatoGasPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IGelatoGasPriceOracle {\\n    function latestAnswer() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/ConditionDebtBridgeIsAffordable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    IGelatoCore\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getRealisedDebt\\n} from \\\"../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../../functions/gelato/FGelato.sol\\\";\\nimport {DAI} from \\\"../../../constants/CInstaDapp.sol\\\";\\nimport {wdiv} from \\\"../../../vendor/DSMath.sol\\\";\\n\\n/// @title ConditionDebtBridgeIsAffordable\\n/// @notice Condition checking if Debt Refinance is affordable.\\n/// @author Gelato Team\\ncontract ConditionDebtBridgeIsAffordable is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    /// @notice Convenience function for off-chain _conditionData encoding\\n    /// @dev Use the return for your Task's Condition.data field off-chain.\\n    /// @dev WARNING _ratioLimit should be in wad standard.\\n    /// @return The encoded payload for your Task's Condition.data field.\\n    function getConditionData(uint256 _vaultId, uint256 _ratioLimit)\\n        public\\n        pure\\n        virtual\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodeWithSelector(\\n                this.isAffordable.selector,\\n                _vaultId,\\n                _ratioLimit\\n            );\\n    }\\n\\n    /// @notice Standard GelatoCore system function\\n    /// @dev A standard interface for GelatoCore to read Conditions\\n    /// @param _conditionData The data you get from `getConditionData()`\\n    /// @return OK if the Condition is there, else some error message.\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (uint256 _vaultID, uint256 _ratioLimit) =\\n            abi.decode(_conditionData[4:], (uint256, uint256));\\n\\n        return isAffordable(_vaultID, _ratioLimit);\\n    }\\n\\n    /// @notice Specific implementation of this Condition's ok function\\n    /// @dev Check if the debt refinancing action is affordable.\\n    /// @dev WARNING _ratioLimit should be in wad standard.\\n    /// @param _vaultId The id of the Maker vault\\n    /// @param _ratioLimit the maximum limit define by the user up on which\\n    /// the debt is too expensive for him\\n    /// @return OK if the Debt Bridge is affordable, otherwise some error message.\\n    function isAffordable(uint256 _vaultId, uint256 _ratioLimit)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        uint256 wColToWithdrawFromMaker =\\n            _getMakerVaultCollateralBalance(_vaultId);\\n        uint256 gasFeesPaidFromCol =\\n            _getGelatoExecutorFees(\\n                _getGasCostMakerToMaker(\\n                    false,\\n                    _getFlashLoanRoute(\\n                        DAI,\\n                        _getRealisedDebt(_getMakerVaultDebt(_vaultId))\\n                    )\\n                )\\n            );\\n        if (wdiv(gasFeesPaidFromCol, wColToWithdrawFromMaker) >= _ratioLimit)\\n            return \\\"DebtBridgeNotAffordable\\\";\\n        return OK;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/FInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {MemoryInterface} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {INSTA_MEMORY} from \\\"../../constants/CInstaDapp.sol\\\";\\n\\nfunction _setUint(uint256 setId, uint256 val) {\\n    if (setId != 0) MemoryInterface(INSTA_MEMORY).setUint(setId, val);\\n}\\n\\nfunction _getUint(uint256 getId, uint256 val) returns (uint256 returnVal) {\\n    returnVal = getId == 0 ? val : MemoryInterface(INSTA_MEMORY).getUint(getId);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/connectors/ConnectGelatoDataPartialRefinanceMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\nimport {sub, wmul} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    DAI,\\n    CONNECT_MAKER,\\n    CONNECT_COMPOUND,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault,\\n    _encodeOpenMakerVault,\\n    _encodedDepositMakerVault,\\n    _encodeBorrowMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodePayExecutor\\n} from \\\"../../functions/InstaDapp/connectors/FConnectGelatoExecutorPayment.sol\\\";\\nimport {\\n    _encodeDepositCompound,\\n    _encodeBorrowCompound\\n} from \\\"../../functions/InstaDapp/connectors/FConnectCompound.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _wCalcCollateralToWithdraw,\\n    _wCalcDebtToRepay\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\n\\ncontract ConnectGelatoDataPartialRefinanceMaker is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    // vaultId: Id of the unsafe vault of the client.\\n    // token:  vault's col token address .\\n    // wMinColRatioMaker: Min col ratio (wad) on Maker debt position\\n    // wMinColRatioB: Min col ratio (wad) on debt position B (e.g. Compound, Maker, ...)\\n    // priceOracle: The price oracle contract to supply the collateral price\\n    //  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    // oraclePayload: The data for making the staticcall to the oracle's read\\n    //  method e.g. the function selector of MakerOracle's read function.\\n    struct PartialDebtBridgePayload {\\n        uint256 vaultId;\\n        address colToken;\\n        string colType;\\n        uint256 wMinColRatioMaker;\\n        uint256 wMinColRatioB;\\n        address priceOracle;\\n        bytes oraclePayload;\\n    }\\n\\n    // solhint-disable const-name-snakecase\\n    string public constant override name =\\n        \\\"ConnectGelatoDataPartialRefinanceMaker-v1.0\\\";\\n    uint256 internal immutable _id;\\n    address internal immutable _connectGelatoExecutorPayment;\\n\\n    uint256 public constant GAS_COST = 1850000;\\n\\n    constructor(uint256 id, address connectGelatoExecutorPayment) {\\n        _id = id;\\n        _connectGelatoExecutorPayment = connectGelatoExecutorPayment;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _payload See PartialDebtBridgePayload struct\\n    function getDataAndCastMakerToMaker(\\n        PartialDebtBridgePayload calldata _payload\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToMaker(_payload);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _payload See PartialDebtBridgePayload struct\\n    function getDataAndCastMakerToCompound(\\n        PartialDebtBridgePayload calldata _payload\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToCompound(_payload);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData =\\n            abi.encodeWithSelector(\\n                AccountInterface.cast.selector,\\n                targets,\\n                datas,\\n                msg.sender // msg.sender == GelatoCore\\n            );\\n\\n        (bool success, bytes memory returndata) =\\n            address(this).delegatecall(castData);\\n        if (!success)\\n            returndata.revertWithError(\\n                \\\"ConnectGelatoDataPartialRefinanceMaker._cast:\\\"\\n            );\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToMaker(PartialDebtBridgePayload calldata _payload)\\n        internal\\n        view\\n        returns (address[] memory targets, bytes[] memory datas)\\n    {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        (\\n            uint256 wDaiDebtToMove,\\n            uint256 wColToWithdrawFromMaker,\\n            uint256 gasFeesPaidFromCol\\n        ) =\\n            computeDebtBridge(\\n                _payload.vaultId,\\n                _payload.wMinColRatioMaker,\\n                _payload.wMinColRatioB,\\n                _payload.priceOracle,\\n                _payload.oraclePayload\\n            );\\n\\n        address[] memory _targets = new address[](7);\\n        _targets[0] = CONNECT_MAKER; // payback\\n        _targets[1] = CONNECT_MAKER; // withdraw\\n        _targets[2] = CONNECT_MAKER; // open ETH-B vault\\n        _targets[3] = CONNECT_MAKER; // deposit\\n        _targets[4] = CONNECT_MAKER; // borrow\\n        _targets[5] = _connectGelatoExecutorPayment; // payExecutor\\n        _targets[6] = INSTA_POOL_V2; // flashPayback\\n\\n        bytes[] memory _datas = new bytes[](7);\\n        _datas[0] = _encodePaybackMakerVault(\\n            _payload.vaultId,\\n            uint256(-1),\\n            0,\\n            0\\n        );\\n        _datas[1] = _encodedWithdrawMakerVault(\\n            _payload.vaultId,\\n            uint256(-1),\\n            0,\\n            0\\n        );\\n        _datas[2] = _encodeOpenMakerVault(_payload.colType);\\n        _datas[3] = _encodedDepositMakerVault(\\n            0,\\n            sub(wColToWithdrawFromMaker, gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        _datas[4] = _encodeBorrowMakerVault(0, wDaiDebtToMove, 0, 0);\\n        _datas[5] = _encodePayExecutor(\\n            _payload.colToken,\\n            gasFeesPaidFromCol,\\n            0,\\n            0\\n        );\\n        _datas[6] = _encodeFlashPayback(DAI, wDaiDebtToMove, 0, 0);\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiDebtToMove,\\n            0,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _dataMakerToCompound(PartialDebtBridgePayload calldata _payload)\\n        internal\\n        view\\n        returns (address[] memory targets, bytes[] memory datas)\\n    {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        (\\n            uint256 wDaiDebtToMove,\\n            uint256 wColToWithdrawFromMaker,\\n            uint256 gasFeesPaidFromCol\\n        ) =\\n            computeDebtBridge(\\n                _payload.vaultId,\\n                _payload.wMinColRatioMaker,\\n                _payload.wMinColRatioB,\\n                _payload.priceOracle,\\n                _payload.oraclePayload\\n            );\\n\\n        address[] memory _targets = new address[](6);\\n        _targets[0] = CONNECT_MAKER; // payback\\n        _targets[1] = CONNECT_MAKER; // withdraw\\n        _targets[2] = CONNECT_COMPOUND; // deposit\\n        _targets[3] = CONNECT_COMPOUND; // borrow\\n        _targets[4] = _connectGelatoExecutorPayment; // payExecutor\\n        _targets[5] = INSTA_POOL_V2; // flashPayback\\n\\n        bytes[] memory _datas = new bytes[](6);\\n        _datas[0] = _encodePaybackMakerVault(\\n            _payload.vaultId,\\n            uint256(-1),\\n            0,\\n            0\\n        );\\n        _datas[1] = _encodedWithdrawMakerVault(\\n            _payload.vaultId,\\n            uint256(-1),\\n            0,\\n            0\\n        );\\n        _datas[2] = _encodeDepositCompound(\\n            _payload.colToken,\\n            sub(wColToWithdrawFromMaker, gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        _datas[3] = _encodeBorrowCompound(DAI, wDaiDebtToMove, 0, 0);\\n        _datas[4] = _encodePayExecutor(\\n            _payload.colToken,\\n            gasFeesPaidFromCol,\\n            0,\\n            0\\n        );\\n        _datas[5] = _encodeFlashPayback(DAI, wDaiDebtToMove, 0, 0);\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiDebtToMove,\\n            0,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    /// @notice Computes values needed for DebtBridge Maker->ProtocolB\\n    /// @dev Use wad for colRatios.\\n    /// @param _vaultId The id of the makerDAO vault.\\n    /// @param _wMinColRatioMaker Min col ratio (wad) on Maker debt position\\n    /// @param _wMinColRatioB Min col ratio (wad) on debt position B (e.g. Compound, Maker, ...)\\n    /// @param _priceOracle The price oracle contract to supply the collateral price\\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\\n    ///  method e.g. the function selector of MakerOracle's read function.\\n    /// @return wDaiDebtToMove DAI Debt (wad) to:\\n    ///   flashBorrow->repay Maker->withdraw from B->flashPayback.\\n    /// @return wColToWithdrawFromMaker (wad) to: withdraw from Maker and deposit on B.\\n    /// @return gasFeesPaidFromCol Gelato automation-gas-fees paid from user's collateral\\n    function computeDebtBridge(\\n        uint256 _vaultId,\\n        uint256 _wMinColRatioMaker,\\n        uint256 _wMinColRatioB,\\n        address _priceOracle,\\n        bytes calldata _oraclePayload\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wDaiDebtToMove,\\n            uint256 wColToWithdrawFromMaker,\\n            uint256 gasFeesPaidFromCol\\n        )\\n    {\\n        uint256 wColPrice;\\n\\n        // Stack too deep\\n        {\\n            (bool success, bytes memory returndata) =\\n                _priceOracle.staticcall(_oraclePayload);\\n\\n            if (!success) {\\n                GelatoBytes.revertWithError(\\n                    returndata,\\n                    \\\"ConnectGelatoPartialDebtBridgeFromMaker.computeDebtBridge:oracle:\\\"\\n                );\\n            }\\n\\n            wColPrice = abi.decode(returndata, (uint256));\\n        }\\n\\n        // TO DO: add fee mechanism for non-ETH collateral debt bridge\\n        // uint256 gasFeesPaidFromCol = _mul(GAS_COST, wmul(_getGelatoGasPrice(), latestPrice));\\n        gasFeesPaidFromCol = _getGelatoExecutorFees(GAS_COST);\\n\\n        uint256 wPricedCol =\\n            wmul(\\n                sub(\\n                    _getMakerVaultCollateralBalance(_vaultId),\\n                    gasFeesPaidFromCol\\n                ),\\n                wColPrice\\n            );\\n\\n        uint256 wDaiDebtOnMaker = _getMakerVaultDebt(_vaultId);\\n\\n        wColToWithdrawFromMaker = _wCalcCollateralToWithdraw(\\n            _wMinColRatioMaker,\\n            _wMinColRatioB,\\n            wColPrice,\\n            wPricedCol,\\n            wDaiDebtOnMaker\\n        );\\n\\n        wDaiDebtToMove = _wCalcDebtToRepay(\\n            _wMinColRatioMaker,\\n            _wMinColRatioB,\\n            wPricedCol,\\n            wDaiDebtOnMaker\\n        );\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IConnectInstaPoolV2 {\\n    function flashBorrowAndCast(\\n        address token,\\n        uint256 amt,\\n        uint256 route,\\n        bytes memory data\\n    ) external payable;\\n\\n    function flashPayback(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FInstaPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\n\\nfunction _encodeFlashPayback(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashPayback.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectMaker\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectMaker.sol\\\";\\n\\nfunction _encodeOpenMakerVault(string memory _colType)\\n    pure\\n    returns (bytes memory)\\n{\\n    return abi.encodeWithSelector(IConnectMaker.open.selector, _colType);\\n}\\n\\nfunction _encodeBorrowMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.borrow.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodedDepositMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.deposit.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodePaybackMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.payback.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodedWithdrawMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.withdraw.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectGelatoExecutorPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectGelatoExecutorPayment\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectGelatoExecutorPayment.sol\\\";\\n\\nfunction _encodePayExecutor(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectGelatoExecutorPayment.payExecutor.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectCompound\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectCompound.sol\\\";\\n\\nfunction _encodeDepositCompound(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectCompound.deposit.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodeBorrowCompound(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectCompound.borrow.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IConnectMaker {\\n    function payback(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function borrow(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function open(string calldata colType)\\n        external\\n        payable\\n        returns (uint256 vault);\\n\\n    function withdraw(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectGelatoExecutorPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {ConnectorInterface} from \\\"../IInstaDapp.sol\\\";\\n\\ninterface IConnectGelatoExecutorPayment is ConnectorInterface {\\n    function payExecutor(\\n        address _token,\\n        uint256 _amt,\\n        uint256 _getId,\\n        uint256 _setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IConnectCompound {\\n    function borrow(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/connectors/ConnectGelatoDataFullMakerToMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\nimport {sub} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    DAI,\\n    CONNECT_MAKER,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _isVaultOwner\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault,\\n    _encodeOpenMakerVault,\\n    _encodedDepositMakerVault,\\n    _encodeBorrowMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodePayExecutor\\n} from \\\"../../functions/InstaDapp/connectors/FConnectGelatoExecutorPayment.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    DataFlow\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ncontract ConnectGelatoDataFullMakerToMaker is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    string public constant OK = \\\"OK\\\";\\n\\n    // solhint-disable const-name-snakecase\\n    string public constant override name =\\n        \\\"ConnectGelatoDataFullMakerToMaker-v2.0\\\";\\n    uint256 internal immutable _id;\\n    address internal immutable _connectGelatoExecutorPayment;\\n\\n    constructor(uint256 id, address connectGelatoExecutorPayment) {\\n        _id = id;\\n        _connectGelatoExecutorPayment = connectGelatoExecutorPayment;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    // ====== ACTION TERMS CHECK ==========\\n    // Overriding IGelatoAction's function (optional)\\n    function termsOk(\\n        uint256, // taskReceipId\\n        address _dsa,\\n        bytes calldata _actionData,\\n        DataFlow,\\n        uint256, // value\\n        uint256 // cycleId\\n    ) public view returns (string memory) {\\n        (uint256 vaultAId, , , ) =\\n            abi.decode(_actionData[4:], (uint256, uint256, address, string));\\n\\n        if (vaultAId == 0)\\n            return \\\"ConnectGelatoDataFullMakerToMaker: Vault A Id is not valid\\\";\\n        if (!_isVaultOwner(vaultAId, _dsa))\\n            return\\n                \\\"ConnectGelatoDataFullMakerToMaker: Vault A not owned by dsa\\\";\\n        return OK;\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _vaultBId Id of the vault B Collateral of the client.\\n    /// @param _colToken  vault's col token address .\\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\\n    function getDataAndCastMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        string calldata _colType\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToMaker(_vaultAId, _vaultBId, _colToken, _colType);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData =\\n            abi.encodeWithSelector(\\n                AccountInterface.cast.selector,\\n                targets,\\n                datas,\\n                msg.sender // msg.sender == GelatoCore\\n            );\\n\\n        (bool success, bytes memory returndata) =\\n            address(this).delegatecall(castData);\\n        if (!success) {\\n            returndata.revertWithError(\\n                \\\"ConnectGelatoDataFullMakerToMaker._cast:\\\"\\n            );\\n        }\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        string calldata _colType\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        _vaultBId = _isVaultOwner(_vaultBId, address(this)) ? _vaultBId : 0;\\n\\n        uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\\n        uint256 wColToWithdrawFromMaker =\\n            _getMakerVaultCollateralBalance(_vaultAId);\\n        uint256 route = _getFlashLoanRoute(DAI, wDaiToBorrow);\\n        uint256 gasCost = _getGasCostMakerToMaker(_vaultBId == 0, route);\\n        uint256 gasFeesPaidFromCol = _getGelatoExecutorFees(gasCost);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _vaultBId == 0\\n                ? _spellsMakerToNewMakerVault(\\n                    _vaultAId,\\n                    _colToken,\\n                    _colType,\\n                    wDaiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromCol\\n                )\\n                : _spellsMakerToMaker(\\n                    _vaultAId,\\n                    _vaultBId,\\n                    _colToken,\\n                    wDaiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromCol\\n                );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToNewMakerVault(\\n        uint256 _vaultAId,\\n        address _colToken,\\n        string calldata _colType,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromCol\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](7);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = CONNECT_MAKER; // open new B vault\\n        targets[3] = CONNECT_MAKER; // deposit\\n        targets[4] = CONNECT_MAKER; // borrow\\n        targets[5] = _connectGelatoExecutorPayment; // payExecutor\\n        targets[6] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](7);\\n        datas[0] = _encodePaybackMakerVault(_vaultAId, uint256(-1), 0, 600);\\n        datas[1] = _encodedWithdrawMakerVault(_vaultAId, uint256(-1), 0, 0);\\n        datas[2] = _encodeOpenMakerVault(_colType);\\n        datas[3] = _encodedDepositMakerVault(\\n            0,\\n            sub(_wColToWithdrawFromMaker, _gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowMakerVault(0, 0, 600, 0);\\n        datas[5] = _encodePayExecutor(_colToken, _gasFeesPaidFromCol, 0, 0);\\n        datas[6] = _encodeFlashPayback(DAI, _wDaiToBorrow, 0, 0);\\n    }\\n\\n    function _spellsMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromCol\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](6);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = CONNECT_MAKER; // deposit\\n        targets[3] = CONNECT_MAKER; // borrow\\n        targets[4] = _connectGelatoExecutorPayment; // payExecutor\\n        targets[5] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](6);\\n        datas[0] = _encodePaybackMakerVault(_vaultAId, uint256(-1), 0, 600);\\n        datas[1] = _encodedWithdrawMakerVault(_vaultAId, uint256(-1), 0, 0);\\n        datas[2] = _encodedDepositMakerVault(\\n            _vaultBId,\\n            sub(_wColToWithdrawFromMaker, _gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        datas[3] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\\n        datas[4] = _encodePayExecutor(_colToken, _gasFeesPaidFromCol, 0, 0);\\n        datas[5] = _encodeFlashPayback(DAI, _wDaiToBorrow, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/ConditionCompareUintsFromTwoSources.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {\\n    IGelatoCore\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\n\\n/// @notice A general contract for retrieving and comparing 2 uints from 2 contracts.\\n/// @dev This contract only works if the refContracts fns returndata has a uint in\\n/// the first 32-byte position.\\ncontract ConditionCompareUintsFromTwoSources is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n    using SafeMath for uint256;\\n\\n    /// @notice Helper to encode the Condition.data field off-chain\\n    function getConditionData(\\n        address _sourceA,\\n        address _sourceB,\\n        bytes calldata _sourceAData,\\n        bytes calldata _sourceBData,\\n        uint256 _minSpread\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encode(\\n                _sourceA,\\n                _sourceB,\\n                _sourceAData,\\n                _sourceBData,\\n                _minSpread\\n            );\\n    }\\n\\n    /// @notice Gelato Standard Condition function.\\n    /// @dev Every Gelato Condition must have this function selector as entry point.\\n    /// @param _conditionData The encoded data from getConditionData()\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            address _sourceA,\\n            address _sourceB,\\n            bytes memory _sourceAData,\\n            bytes memory _sourceBData,\\n            uint256 _minSpread\\n        ) =\\n            abi.decode(\\n                _conditionData,\\n                (address, address, bytes, bytes, uint256)\\n            );\\n        return\\n            compare(_sourceA, _sourceB, _sourceAData, _sourceBData, _minSpread);\\n    }\\n\\n    /// @notice Compares 2 values from sourceA and sourceB to check if minSpread is there.\\n    /// @dev If you want to trigger when ContractA uint is greater than or equal\\n    /// to ContractB by _minSpread: (ContractA=_sourceA, ContractB=_sourceB)\\n    /// For the reverse (lower than/equal to): (ContractA=_sourceB, ContractB=_sourceA)\\n    /// @param _sourceA The first contract that returns a uint for comparison.\\n    /// @param _sourceB The second contract that returns a uint256 for comparison.\\n    /// @param _sourceAData Payload for retrieving the uint from _sourceA.\\n    /// @param _sourceBData Payload for retrieving the uint from _sourceB.\\n    /// @param _minSpread The minimum diff between sourceA and sourceB\\n    ///  for the Condition to be relevant.\\n    /// @return OK if the Condition is fulfilled.\\n    function compare(\\n        address _sourceA,\\n        address _sourceB,\\n        bytes memory _sourceAData,\\n        bytes memory _sourceBData,\\n        uint256 _minSpread\\n    ) public view virtual returns (string memory) {\\n        // Retrieve uint256 from sourceA\\n        (bool success, bytes memory returndata) =\\n            _sourceA.staticcall(_sourceAData);\\n        if (!success) {\\n            return\\n                returndata.returnError(\\n                    \\\"ConditionCompareTwoUints.compare._sourceA:\\\"\\n                );\\n        }\\n        uint256 a = abi.decode(returndata, (uint256));\\n\\n        // Retrieve uint256 from sourceB\\n        (success, returndata) = _sourceB.staticcall(_sourceBData);\\n        if (!success) {\\n            return\\n                returndata.returnError(\\n                    \\\"ConditionCompareTwoUints.compare._sourceB:\\\"\\n                );\\n        }\\n        uint256 b = abi.decode(returndata, (uint256));\\n\\n        if (a >= b.add(_minSpread)) return OK;\\n        return \\\"ANotGreaterOrEqualToBbyMinspread\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/connectors/ConnectGelatoExecutorPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectGelatoExecutorPayment\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectGelatoExecutorPayment.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport {_getUint, _setUint} from \\\"../../functions/InstaDapp/FInstaDapp.sol\\\";\\nimport {ETH} from \\\"../../constants/CInstaDapp.sol\\\";\\n\\n/// @title ConnectGelatoExecutorPayment\\n/// @notice InstaDapp Connector to compensate Gelato Executors for automation-gas.\\n/// @author Gelato Team\\ncontract ConnectGelatoExecutorPayment is IConnectGelatoExecutorPayment {\\n    using Address for address payable;\\n    using SafeERC20 for IERC20;\\n\\n    // solhint-disable-next-line const-name-snakecase\\n    string public constant override name = \\\"ConnectGelatoExecutorPayment-v1.0\\\";\\n\\n    uint256 internal immutable _id;\\n\\n    constructor(uint256 id) {\\n        _id = id;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    /// @notice Transfers automation gas fees to Gelato Executor\\n    /// @dev Gelato Executor risks:\\n    ///    - _getId does not match actual InstaMemory executor payment slot\\n    ///    - _token balance not in DSA\\n    ///    - worthless _token risk\\n    /// payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _token The token used to pay the Executor.\\n    /// @param _amt The amount of _token to pay the Gelato Executor.\\n    /// @param _getId The InstaMemory slot at which the payment amount was stored.\\n    /// @param _setId The InstaMemory slot to save the executor payout amound in.\\n    function payExecutor(\\n        address _token,\\n        uint256 _amt,\\n        uint256 _getId,\\n        uint256 _setId\\n    ) external payable override {\\n        uint256 amt = _getUint(_getId, _amt);\\n        _setUint(_setId, amt);\\n        if (_token == ETH) payable(tx.origin).sendValue(amt);\\n        else IERC20(_token).safeTransfer(tx.origin, amt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/connectors/ConnectGelatoDataFullMakerToCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\nimport {sub} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    DAI,\\n    CONNECT_MAKER,\\n    CONNECT_COMPOUND,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _isVaultOwner\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodePayExecutor\\n} from \\\"../../functions/InstaDapp/connectors/FConnectGelatoExecutorPayment.sol\\\";\\nimport {\\n    _encodeDepositCompound,\\n    _encodeBorrowCompound\\n} from \\\"../../functions/InstaDapp/connectors/FConnectCompound.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    DataFlow\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ncontract ConnectGelatoDataFullMakerToCompound is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    string public constant OK = \\\"OK\\\";\\n\\n    // solhint-disable const-name-snakecase\\n    string public constant override name =\\n        \\\"ConnectGelatoDataFullMakerToCompound-v1.0\\\";\\n    uint256 internal immutable _id;\\n    address internal immutable _connectGelatoExecutorPayment;\\n\\n    constructor(uint256 id, address connectGelatoExecutorPayment) {\\n        _id = id;\\n        _connectGelatoExecutorPayment = connectGelatoExecutorPayment;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    // ====== ACTION TERMS CHECK ==========\\n    /// @notice GelatoCore protocol standard function\\n    /// @dev GelatoCore calls this to verify that a Task is executable\\n    function termsOk(\\n        uint256, // taskReceipId\\n        address _dsa,\\n        bytes calldata _actionData,\\n        DataFlow, // DataFlow\\n        uint256, // value\\n        uint256 // cycleId\\n    ) public view returns (string memory) {\\n        (uint256 vaultId, ) = abi.decode(_actionData[4:], (uint256, address));\\n\\n        if (vaultId == 0)\\n            return\\n                \\\"ConnectGelatoDataFullMakerToCompound: Vault Id is not valid\\\";\\n        if (!_isVaultOwner(vaultId, _dsa))\\n            return\\n                \\\"ConnectGelatoDataFullMakerToCompound: Vault not owned by dsa\\\";\\n        return OK;\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultId Id of the unsafe vault of the client.\\n    /// @param _colToken  vault's col token address .\\n    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\\n        external\\n        payable\\n    {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToCompound(_vaultId, _colToken);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData =\\n            abi.encodeWithSelector(\\n                AccountInterface.cast.selector,\\n                targets,\\n                datas,\\n                msg.sender // msg.sender == GelatoCore\\n            );\\n\\n        (bool success, bytes memory returndata) =\\n            address(this).delegatecall(castData);\\n        if (!success) {\\n            returndata.revertWithError(\\n                \\\"ConnectGelatoDataFullRefinanceMaker._cast:\\\"\\n            );\\n        }\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToCompound(uint256 _vaultId, address _colToken)\\n        internal\\n        view\\n        returns (address[] memory targets, bytes[] memory datas)\\n    {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\\n        uint256 wColToWithdrawFromMaker =\\n            _getMakerVaultCollateralBalance(_vaultId);\\n        uint256 route = _getFlashLoanRoute(DAI, wDaiToBorrow);\\n        uint256 gasCost = _getGasCostMakerToCompound(route);\\n        uint256 gasFeesPaidFromCol = _getGelatoExecutorFees(gasCost);\\n\\n        address[] memory _targets = new address[](6);\\n        _targets[0] = CONNECT_MAKER; // payback\\n        _targets[1] = CONNECT_MAKER; // withdraw\\n        _targets[2] = CONNECT_COMPOUND; // deposit\\n        _targets[3] = CONNECT_COMPOUND; // borrow\\n        _targets[4] = _connectGelatoExecutorPayment; // payExecutor\\n        _targets[5] = INSTA_POOL_V2; // flashPayback\\n\\n        bytes[] memory _datas = new bytes[](6);\\n        _datas[0] = _encodePaybackMakerVault(_vaultId, uint256(-1), 0, 600);\\n        _datas[1] = _encodedWithdrawMakerVault(_vaultId, uint256(-1), 0, 0);\\n        _datas[2] = _encodeDepositCompound(\\n            _colToken,\\n            sub(wColToWithdrawFromMaker, gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        _datas[3] = _encodeBorrowCompound(DAI, 0, 600, 0);\\n        _datas[4] = _encodePayExecutor(_colToken, gasFeesPaidFromCol, 0, 0);\\n        _datas[5] = _encodeFlashPayback(DAI, wDaiToBorrow, 0, 0);\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\nimport {sub} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    DAI,\\n    CONNECT_MAKER,\\n    CONNECT_COMPOUND,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _isVaultOwner\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault,\\n    _encodeOpenMakerVault,\\n    _encodedDepositMakerVault,\\n    _encodeBorrowMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodePayExecutor\\n} from \\\"../../functions/InstaDapp/connectors/FConnectGelatoExecutorPayment.sol\\\";\\nimport {\\n    _encodeDepositCompound,\\n    _encodeBorrowCompound\\n} from \\\"../../functions/InstaDapp/connectors/FConnectCompound.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    DataFlow\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ncontract MockConnectGelatoDataFullMakerToMaker is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    string public constant OK = \\\"OK\\\";\\n\\n    // solhint-disable const-name-snakecase\\n    string public constant override name =\\n        \\\"MockConnectGelatoDataFullMakerToMaker-v1.0\\\";\\n    uint256 internal immutable _id;\\n    address internal immutable _connectGelatoExecutorPayment;\\n\\n    constructor(uint256 id, address connectGelatoExecutorPayment) {\\n        _id = id;\\n        _connectGelatoExecutorPayment = connectGelatoExecutorPayment;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    // ====== ACTION TERMS CHECK ==========\\n    // Overriding IGelatoAction's function (optional)\\n    function termsOk(\\n        uint256, // taskReceipId\\n        address _dsa,\\n        bytes calldata _actionData,\\n        DataFlow,\\n        uint256, // value\\n        uint256 // cycleId\\n    ) public view returns (string memory) {\\n        (, uint256 vaultAId, , , ) =\\n            abi.decode(\\n                _actionData[4:],\\n                (uint256, uint256, uint256, address, string)\\n            );\\n\\n        if (vaultAId == 0)\\n            return \\\"ConnectGelatoDataFullMakerToMaker: Vault A Id is not valid\\\";\\n        if (!_isVaultOwner(vaultAId, _dsa))\\n            return\\n                \\\"ConnectGelatoDataFullMakerToMaker: Vault A not owned by dsa\\\";\\n        return OK;\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _mockRoute we mock this behavior for gas-reporter testing\\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _vaultBId Id of the vault B Collateral of the client.\\n    /// @param _colToken  vault's col token address .\\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\\n    function getDataAndCastMakerToMaker(\\n        uint256 _mockRoute,\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        string calldata _colType\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToMaker(\\n                _mockRoute,\\n                _vaultAId,\\n                _vaultBId,\\n                _colToken,\\n                _colType\\n            );\\n\\n        _cast(targets, datas);\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData =\\n            abi.encodeWithSelector(\\n                AccountInterface.cast.selector,\\n                targets,\\n                datas,\\n                msg.sender // msg.sender == GelatoCore\\n            );\\n\\n        (bool success, bytes memory returndata) =\\n            address(this).delegatecall(castData);\\n        if (!success) {\\n            returndata.revertWithError(\\n                \\\"ConnectGelatoDataFullMakerToMaker._cast:\\\"\\n            );\\n        }\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToMaker(\\n        uint256 _mockRoute,\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        string calldata _colType\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        _vaultBId = _isVaultOwner(_vaultBId, address(this)) ? _vaultBId : 0;\\n\\n        uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\\n        uint256 wColToWithdrawFromMaker =\\n            _getMakerVaultCollateralBalance(_vaultAId);\\n        uint256 route = _getFlashLoanRoute(DAI, wDaiToBorrow);\\n\\n        // Mock Route\\n        route = _mockRoute;\\n\\n        uint256 gasCost = _getGasCostMakerToMaker(_vaultBId == 0, route);\\n        uint256 gasFeesPaidFromCol = _getGelatoExecutorFees(gasCost);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _vaultBId == 0\\n                ? _spellsMakerToNewMakerVault(\\n                    _vaultAId,\\n                    _colToken,\\n                    _colType,\\n                    wDaiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromCol\\n                )\\n                : _spellsMakerToMaker(\\n                    _vaultAId,\\n                    _vaultBId,\\n                    _colToken,\\n                    wDaiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromCol\\n                );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToNewMakerVault(\\n        uint256 _vaultAId,\\n        address _colToken,\\n        string calldata _colType,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromCol\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](7);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = CONNECT_MAKER; // open new B vault\\n        targets[3] = CONNECT_MAKER; // deposit\\n        targets[4] = CONNECT_MAKER; // borrow\\n        targets[5] = _connectGelatoExecutorPayment; // payExecutor\\n        targets[6] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](7);\\n        datas[0] = _encodePaybackMakerVault(_vaultAId, uint256(-1), 0, 600);\\n        datas[1] = _encodedWithdrawMakerVault(_vaultAId, uint256(-1), 0, 0);\\n        datas[2] = _encodeOpenMakerVault(_colType);\\n        datas[3] = _encodedDepositMakerVault(\\n            0,\\n            sub(_wColToWithdrawFromMaker, _gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowMakerVault(0, 0, 600, 0);\\n        datas[5] = _encodePayExecutor(_colToken, _gasFeesPaidFromCol, 0, 0);\\n        datas[6] = _encodeFlashPayback(DAI, _wDaiToBorrow, 0, 0);\\n    }\\n\\n    function _spellsMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromCol\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](6);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = CONNECT_MAKER; // deposit\\n        targets[3] = CONNECT_MAKER; // borrow\\n        targets[4] = _connectGelatoExecutorPayment; // payExecutor\\n        targets[5] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](6);\\n        datas[0] = _encodePaybackMakerVault(_vaultAId, uint256(-1), 0, 600);\\n        datas[1] = _encodedWithdrawMakerVault(_vaultAId, uint256(-1), 0, 0);\\n        datas[2] = _encodedDepositMakerVault(\\n            _vaultBId,\\n            sub(_wColToWithdrawFromMaker, _gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        datas[3] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\\n        datas[4] = _encodePayExecutor(_colToken, _gasFeesPaidFromCol, 0, 0);\\n        datas[5] = _encodeFlashPayback(DAI, _wDaiToBorrow, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/resolvers/MakerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    _getMakerRawVaultDebt,\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _vaultWillBeSafe,\\n    _newVaultWillBeSafe\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\n\\ncontract MakerResolver {\\n    /// @dev Return Debt in wad of the vault associated to the vaultId.\\n    function getMakerVaultRawDebt(uint256 _vaultId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getMakerRawVaultDebt(_vaultId);\\n    }\\n\\n    function getMakerVaultDebt(uint256 _vaultId) public view returns (uint256) {\\n        return _getMakerVaultDebt(_vaultId);\\n    }\\n\\n    /// @dev Return Collateral in wad of the vault associated to the vaultId.\\n    function getMakerVaultCollateralBalance(uint256 _vaultId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getMakerVaultCollateralBalance(_vaultId);\\n    }\\n\\n    function vaultWillBeSafe(\\n        uint256 _vaultId,\\n        uint256 _amtToBorrow,\\n        uint256 _colToDeposit\\n    ) public view returns (bool) {\\n        return _vaultWillBeSafe(_vaultId, _amtToBorrow, _colToDeposit);\\n    }\\n\\n    function newVaultWillBeSafe(\\n        string memory _colType,\\n        uint256 _amtToBorrow,\\n        uint256 _colToDeposit\\n    ) public view returns (bool) {\\n        return _newVaultWillBeSafe(_colType, _amtToBorrow, _colToDeposit);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/gelato/MockDebtBridgeETHBExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\n// import \\\"hardhat/console.sol\\\"; // Uncomment this line for using gasLeft Method\\nimport {\\n    TaskReceipt\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoCore\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoExecutors\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\\\";\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\n\\n/// @dev Automatic gas-reporting for ConnectGelatoDataFullRefinanceMaker ETHA => ETHB\\n//   via hardhat-gas-reporter\\ncontract MockDebtBridgeETHBExecutor {\\n    using GelatoBytes for bytes;\\n    address public gelatoCore;\\n\\n    constructor(address _gelatoCore) payable {\\n        gelatoCore = _gelatoCore;\\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\\n    }\\n\\n    function canExec(\\n        TaskReceipt calldata _taskReceipt,\\n        uint256 _gasLimit,\\n        uint256 _execTxGasPrice\\n    ) external view returns (string memory) {\\n        return\\n            IGelatoCore(gelatoCore).canExec(\\n                _taskReceipt,\\n                _gasLimit,\\n                _execTxGasPrice\\n            );\\n    }\\n\\n    function exec(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost for Task Execution %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute0: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute0AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute0AndOpenVault: %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n\\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute1: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute1AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute1AndOpenVault: %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n\\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute2: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute2AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute2AndOpenVault %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n\\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute3: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute3AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute3AndOpenVAult: %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\ninterface IGelatoExecutors {\\n    event LogExecutorStaked(address indexed executor, uint256 oldStake, uint256 newStake);\\n    event LogExecutorUnstaked(address indexed executor);\\n\\n    event LogExecutorBalanceWithdrawn(\\n        address indexed executor,\\n        uint256 withdrawAmount\\n    );\\n\\n    /// @notice Stake on Gelato to become a whitelisted executor\\n    /// @dev Msg.value has to be >= minExecutorStake\\n    function stakeExecutor() external payable;\\n\\n    /// @notice Unstake on Gelato to become de-whitelisted and withdraw minExecutorStake\\n    function unstakeExecutor() external;\\n\\n    /// @notice Re-assigns multiple providers to other executors\\n    /// @dev Executors must re-assign all providers before being able to unstake\\n    /// @param _providers List of providers to re-assign\\n    /// @param _newExecutor Address of new executor to assign providers to\\n    function multiReassignProviders(address[] calldata _providers, address _newExecutor)\\n        external;\\n\\n\\n    /// @notice Withdraw excess Execur Stake\\n    /// @dev Can only be called if executor is isExecutorMinStaked\\n    /// @param _withdrawAmount Amount to withdraw\\n    /// @return Amount that was actually withdrawn\\n    function withdrawExcessExecutorStake(uint256 _withdrawAmount) external returns(uint256);\\n\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/libraries/GelatoBytes.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithErrorString(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoSysAdmin.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\ninterface IGelatoSysAdmin {\\n    struct GelatoSysAdminInitialState {\\n        address gelatoGasPriceOracle;\\n        bytes oracleRequestData;\\n        uint256 gelatoMaxGas;\\n        uint256 internalGasRequirement;\\n        uint256 minExecutorStake;\\n        uint256 executorSuccessShare;\\n        uint256 sysAdminSuccessShare;\\n        uint256 totalSuccessShare;\\n    }\\n\\n    // Events\\n    event LogGelatoGasPriceOracleSet(address indexed oldOracle, address indexed newOracle);\\n    event LogOracleRequestDataSet(bytes oldData, bytes newData);\\n\\n    event LogGelatoMaxGasSet(uint256 oldMaxGas, uint256 newMaxGas);\\n    event LogInternalGasRequirementSet(uint256 oldRequirment, uint256 newRequirment);\\n\\n    event LogMinExecutorStakeSet(uint256 oldMin, uint256 newMin);\\n\\n    event LogExecutorSuccessShareSet(uint256 oldShare, uint256 newShare, uint256 total);\\n    event LogSysAdminSuccessShareSet(uint256 oldShare, uint256 newShare, uint256 total);\\n\\n    event LogSysAdminFundsWithdrawn(uint256 oldBalance, uint256 newBalance);\\n\\n    // State Writing\\n\\n    /// @notice Assign new gas price oracle\\n    /// @dev Only callable by sysAdmin\\n    /// @param _newOracle Address of new oracle\\n    function setGelatoGasPriceOracle(address _newOracle) external;\\n\\n    /// @notice Assign new gas price oracle\\n    /// @dev Only callable by sysAdmin\\n    /// @param _requestData The encoded payload for the staticcall to the oracle.\\n    function setOracleRequestData(bytes calldata _requestData) external;\\n\\n    /// @notice Assign new maximum gas limit providers can consume in executionWrapper()\\n    /// @dev Only callable by sysAdmin\\n    /// @param _newMaxGas New maximum gas limit\\n    function setGelatoMaxGas(uint256 _newMaxGas) external;\\n\\n    /// @notice Assign new interal gas limit requirement for exec()\\n    /// @dev Only callable by sysAdmin\\n    /// @param _newRequirement New internal gas requirement\\n    function setInternalGasRequirement(uint256 _newRequirement) external;\\n\\n    /// @notice Assign new minimum executor stake\\n    /// @dev Only callable by sysAdmin\\n    /// @param _newMin New minimum executor stake\\n    function setMinExecutorStake(uint256 _newMin) external;\\n\\n    /// @notice Assign new success share for executors to receive after successful execution\\n    /// @dev Only callable by sysAdmin\\n    /// @param _percentage New % success share of total gas consumed\\n    function setExecutorSuccessShare(uint256 _percentage) external;\\n\\n    /// @notice Assign new success share for sysAdmin to receive after successful execution\\n    /// @dev Only callable by sysAdmin\\n    /// @param _percentage New % success share of total gas consumed\\n    function setSysAdminSuccessShare(uint256 _percentage) external;\\n\\n    /// @notice Withdraw sysAdmin funds\\n    /// @dev Only callable by sysAdmin\\n    /// @param _amount Amount to withdraw\\n    /// @param _to Address to receive the funds\\n    function withdrawSysAdminFunds(uint256 _amount, address payable _to) external returns(uint256);\\n\\n    // State Reading\\n    /// @notice Unaccounted tx overhead that will be refunded to executors\\n    function EXEC_TX_OVERHEAD() external pure returns(uint256);\\n\\n    /// @notice Addess of current Gelato Gas Price Oracle\\n    function gelatoGasPriceOracle() external view returns(address);\\n\\n    /// @notice Getter for oracleRequestData state variable\\n    function oracleRequestData() external view returns(bytes memory);\\n\\n    /// @notice Gas limit an executor has to submit to get refunded even if actions revert\\n    function gelatoMaxGas() external view returns(uint256);\\n\\n    /// @notice Internal gas limit requirements ti ensure executor payout\\n    function internalGasRequirement() external view returns(uint256);\\n\\n    /// @notice Minimum stake required from executors\\n    function minExecutorStake() external view returns(uint256);\\n\\n    /// @notice % Fee executors get as a reward for a successful execution\\n    function executorSuccessShare() external view returns(uint256);\\n\\n    /// @notice Total % Fee executors and sysAdmin collectively get as a reward for a successful execution\\n    /// @dev Saves a state read\\n    function totalSuccessShare() external view returns(uint256);\\n\\n    /// @notice Get total fee providers pay executors for a successful execution\\n    /// @param _gas Gas consumed by transaction\\n    /// @param _gasPrice Current gelato gas price\\n    function executorSuccessFee(uint256 _gas, uint256 _gasPrice)\\n        external\\n        view\\n        returns(uint256);\\n\\n    /// @notice % Fee sysAdmin gets as a reward for a successful execution\\n    function sysAdminSuccessShare() external view returns(uint256);\\n\\n    /// @notice Get total fee providers pay sysAdmin for a successful execution\\n    /// @param _gas Gas consumed by transaction\\n    /// @param _gasPrice Current gelato gas price\\n    function sysAdminSuccessFee(uint256 _gas, uint256 _gasPrice)\\n        external\\n        view\\n        returns(uint256);\\n\\n    /// @notice Get sysAdminds funds\\n    function sysAdminFunds() external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/actions/IGelatoAction.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nimport {DataFlow} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\n/// @title IGelatoAction - solidity interface of GelatoActionsStandard\\n/// @notice all the APIs and events of GelatoActionsStandard\\n/// @dev all the APIs are implemented inside GelatoActionsStandard\\ninterface IGelatoAction {\\n    event LogOneWay(\\n        address origin,\\n        address sendToken,\\n        uint256 sendAmount,\\n        address destination\\n    );\\n\\n    event LogTwoWay(\\n        address origin,\\n        address sendToken,\\n        uint256 sendAmount,\\n        address destination,\\n        address receiveToken,\\n        uint256 receiveAmount,\\n        address receiver\\n    );\\n\\n    /// @notice Providers can use this for pre-execution sanity checks, to prevent reverts.\\n    /// @dev GelatoCore checks this in canExec and passes the parameters.\\n    /// @param _taskReceiptId The id of the task from which all arguments are passed.\\n    /// @param _userProxy The userProxy of the task. Often address(this) for delegatecalls.\\n    /// @param _actionData The encoded payload to be used in the Action.\\n    /// @param _dataFlow The dataFlow of the Action.\\n    /// @param _value A special param for ETH sending Actions. If the Action sends ETH\\n    ///  in its Action function implementation, one should expect msg.value therein to be\\n    ///  equal to _value. So Providers can check in termsOk that a valid ETH value will\\n    ///  be used because they also have access to the same value when encoding the\\n    ///  execPayload on their ProviderModule.\\n    /// @param _cycleId For tasks that are part of a Cycle.\\n    /// @return Returns OK, if Task can be executed safely according to the Provider's\\n    ///  terms laid out in this function implementation.\\n    function termsOk(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        bytes calldata _actionData,\\n        DataFlow _dataFlow,\\n        uint256 _value,\\n        uint256 _cycleId\\n    )\\n        external\\n        view\\n        returns(string memory);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/libraries/GelatoTaskReceipt.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nimport {Task, TaskReceipt} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\nlibrary GelatoTaskReceipt {\\n    function task(TaskReceipt memory _TR) internal pure returns(Task memory) {\\n        return _TR.tasks[_TR.index];\\n    }\\n\\n    function nextIndex(TaskReceipt memory _TR) internal pure returns(uint256) {\\n        return _TR.index == _TR.tasks.length - 1 ? 0 : _TR.index + 1;\\n    }\\n\\n    function selfProvider(TaskReceipt memory _TR) internal pure returns(bool) {\\n        return _TR.provider.addr == _TR.userProxy;\\n    }\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoProviders.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"../../provider_modules/IGelatoProviderModule.sol\\\";\\nimport {Action, Provider, Task, TaskReceipt} from \\\"./IGelatoCore.sol\\\";\\nimport {IGelatoCondition} from \\\"../../conditions/IGelatoCondition.sol\\\";\\n\\n// TaskSpec - Will be whitelised by providers and selected by users\\nstruct TaskSpec {\\n    IGelatoCondition[] conditions;   // Address: optional AddressZero for self-conditional actions\\n    Action[] actions;\\n    uint256 gasPriceCeil;\\n}\\n\\ninterface IGelatoProviders {\\n    // Provider Funding\\n    event LogFundsProvided(\\n        address indexed provider,\\n        uint256 amount,\\n        uint256 newProviderFunds\\n    );\\n    event LogFundsUnprovided(\\n        address indexed provider,\\n        uint256 realWithdrawAmount,\\n        uint256 newProviderFunds\\n    );\\n\\n    // Executor By Provider\\n    event LogProviderAssignedExecutor(\\n        address indexed provider,\\n        address indexed oldExecutor,\\n        address indexed newExecutor\\n    );\\n    event LogExecutorAssignedExecutor(\\n        address indexed provider,\\n        address indexed oldExecutor,\\n        address indexed newExecutor\\n    );\\n\\n    // Actions\\n    event LogTaskSpecProvided(address indexed provider, bytes32 indexed taskSpecHash);\\n    event LogTaskSpecUnprovided(address indexed provider, bytes32 indexed taskSpecHash);\\n    event LogTaskSpecGasPriceCeilSet(\\n        address indexed provider,\\n        bytes32 taskSpecHash,\\n        uint256 oldTaskSpecGasPriceCeil,\\n        uint256 newTaskSpecGasPriceCeil\\n    );\\n\\n    // Provider Module\\n    event LogProviderModuleAdded(\\n        address indexed provider,\\n        IGelatoProviderModule indexed module\\n    );\\n    event LogProviderModuleRemoved(\\n        address indexed provider,\\n        IGelatoProviderModule indexed module\\n    );\\n\\n    // =========== GELATO PROVIDER APIs ==============\\n\\n    /// @notice Validation that checks whether Task Spec is being offered by the selected provider\\n    /// @dev Checked in submitTask(), unless provider == userProxy\\n    /// @param _provider Address of selected provider\\n    /// @param _taskSpec Task Spec\\n    /// @return Expected to return \\\"OK\\\"\\n    function isTaskSpecProvided(address _provider, TaskSpec calldata _taskSpec)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Validates that provider has provider module whitelisted + conducts isProvided check in ProviderModule\\n    /// @dev Checked in submitTask() if provider == userProxy\\n    /// @param _userProxy userProxy passed by GelatoCore during submission and exec\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task Task defined in IGelatoCore\\n    /// @return Expected to return \\\"OK\\\"\\n    function providerModuleChecks(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task\\n    )\\n        external\\n        view\\n        returns(string memory);\\n\\n\\n    /// @notice Validate if provider module and seleced TaskSpec is whitelisted by provider\\n    /// @dev Combines \\\"isTaskSpecProvided\\\" and providerModuleChecks\\n    /// @param _userProxy userProxy passed by GelatoCore during submission and exec\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task Task defined in IGelatoCore\\n    /// @return res Expected to return \\\"OK\\\"\\n    function isTaskProvided(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task\\n    )\\n        external\\n        view\\n        returns(string memory res);\\n\\n\\n    /// @notice Validate if selected TaskSpec is whitelisted by provider and that current gelatoGasPrice is below GasPriceCeil\\n    /// @dev If gasPriceCeil is != 0, Task Spec is whitelisted\\n    /// @param _userProxy userProxy passed by GelatoCore during submission and exec\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task Task defined in IGelatoCore\\n    /// @param _gelatoGasPrice Task Receipt defined in IGelatoCore\\n    /// @return res Expected to return \\\"OK\\\"\\n    function providerCanExec(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _gelatoGasPrice\\n    )\\n        external\\n        view\\n        returns(string memory res);\\n\\n    // =========== PROVIDER STATE WRITE APIs ==============\\n    // Provider Funding\\n    /// @notice Deposit ETH as provider on Gelato\\n    /// @param _provider Address of provider who receives ETH deposit\\n    function provideFunds(address _provider) external payable;\\n\\n    /// @notice Withdraw provider funds from gelato\\n    /// @param _withdrawAmount Amount\\n    /// @return amount that will be withdrawn\\n    function unprovideFunds(uint256 _withdrawAmount) external returns(uint256);\\n\\n    /// @notice Assign executor as provider\\n    /// @param _executor Address of new executor\\n    function providerAssignsExecutor(address _executor) external;\\n\\n    /// @notice Assign executor as previous selected executor\\n    /// @param _provider Address of provider whose executor to change\\n    /// @param _newExecutor Address of new executor\\n    function executorAssignsExecutor(address _provider, address _newExecutor) external;\\n\\n    // (Un-)provide Task Spec\\n\\n    /// @notice Whitelist TaskSpecs (A combination of a Condition, Action(s) and a gasPriceCeil) that users can select from\\n    /// @dev If gasPriceCeil is == 0, Task Spec will be executed at any gas price (no ceil)\\n    /// @param _taskSpecs Task Receipt List defined in IGelatoCore\\n    function provideTaskSpecs(TaskSpec[] calldata _taskSpecs) external;\\n\\n    /// @notice De-whitelist TaskSpecs (A combination of a Condition, Action(s) and a gasPriceCeil) that users can select from\\n    /// @dev If gasPriceCeil was set to NO_CEIL, Input NO_CEIL constant as GasPriceCeil\\n    /// @param _taskSpecs Task Receipt List defined in IGelatoCore\\n    function unprovideTaskSpecs(TaskSpec[] calldata _taskSpecs) external;\\n\\n    /// @notice Update gasPriceCeil of selected Task Spec\\n    /// @param _taskSpecHash Result of hashTaskSpec()\\n    /// @param _gasPriceCeil New gas price ceil for Task Spec\\n    function setTaskSpecGasPriceCeil(bytes32 _taskSpecHash, uint256 _gasPriceCeil) external;\\n\\n    // Provider Module\\n    /// @notice Whitelist new provider Module(s)\\n    /// @param _modules Addresses of the modules which will be called during providerModuleChecks()\\n    function addProviderModules(IGelatoProviderModule[] calldata _modules) external;\\n\\n    /// @notice De-Whitelist new provider Module(s)\\n    /// @param _modules Addresses of the modules which will be removed\\n    function removeProviderModules(IGelatoProviderModule[] calldata _modules) external;\\n\\n    // Batch (un-)provide\\n\\n    /// @notice Whitelist new executor, TaskSpec(s) and Module(s) in one tx\\n    /// @param _executor Address of new executor of provider\\n    /// @param _taskSpecs List of Task Spec which will be whitelisted by provider\\n    /// @param _modules List of module addresses which will be whitelisted by provider\\n    function multiProvide(\\n        address _executor,\\n        TaskSpec[] calldata _taskSpecs,\\n        IGelatoProviderModule[] calldata _modules\\n    )\\n        external\\n        payable;\\n\\n\\n    /// @notice De-Whitelist TaskSpec(s), Module(s) and withdraw funds from gelato in one tx\\n    /// @param _withdrawAmount Amount to withdraw from ProviderFunds\\n    /// @param _taskSpecs List of Task Spec which will be de-whitelisted by provider\\n    /// @param _modules List of module addresses which will be de-whitelisted by provider\\n    function multiUnprovide(\\n        uint256 _withdrawAmount,\\n        TaskSpec[] calldata _taskSpecs,\\n        IGelatoProviderModule[] calldata _modules\\n    )\\n        external;\\n\\n    // =========== PROVIDER STATE READ APIs ==============\\n    // Provider Funding\\n\\n    /// @notice Get balance of provider\\n    /// @param _provider Address of provider\\n    /// @return Provider Balance\\n    function providerFunds(address _provider) external view returns(uint256);\\n\\n    /// @notice Get min stake required by all providers for executors to call exec\\n    /// @param _gelatoMaxGas Current gelatoMaxGas\\n    /// @param _gelatoGasPrice Current gelatoGasPrice\\n    /// @return How much provider balance is required for executor to submit exec tx\\n    function minExecProviderFunds(uint256 _gelatoMaxGas, uint256 _gelatoGasPrice)\\n        external\\n        view\\n        returns(uint256);\\n\\n    /// @notice Check if provider has sufficient funds for executor to call exec\\n    /// @param _provider Address of provider\\n    /// @param _gelatoMaxGas Currentt gelatoMaxGas\\n    /// @param _gelatoGasPrice Current gelatoGasPrice\\n    /// @return Whether provider is liquid (true) or not (false)\\n    function isProviderLiquid(\\n        address _provider,\\n        uint256 _gelatoMaxGas,\\n        uint256 _gelatoGasPrice\\n    )\\n        external\\n        view\\n        returns(bool);\\n\\n    // Executor Stake\\n\\n    /// @notice Get balance of executor\\n    /// @param _executor Address of executor\\n    /// @return Executor Balance\\n    function executorStake(address _executor) external view returns(uint256);\\n\\n    /// @notice Check if executor has sufficient stake on gelato\\n    /// @param _executor Address of provider\\n    /// @return Whether executor has sufficient stake (true) or not (false)\\n    function isExecutorMinStaked(address _executor) external view returns(bool);\\n\\n    /// @notice Get executor of provider\\n    /// @param _provider Address of provider\\n    /// @return Provider's executor\\n    function executorByProvider(address _provider)\\n        external\\n        view\\n        returns(address);\\n\\n    /// @notice Get num. of providers which haved assigned an executor\\n    /// @param _executor Address of executor\\n    /// @return Count of how many providers assigned the executor\\n    function executorProvidersCount(address _executor) external view returns(uint256);\\n\\n    /// @notice Check if executor has one or more providers assigned\\n    /// @param _executor Address of provider\\n    /// @return Where 1 or more providers have assigned the executor\\n    function isExecutorAssigned(address _executor) external view returns(bool);\\n\\n    // Task Spec and Gas Price Ceil\\n    /// @notice The maximum gas price the transaction will be executed with\\n    /// @param _provider Address of provider\\n    /// @param _taskSpecHash Hash of provider TaskSpec\\n    /// @return Max gas price an executor will execute the transaction with in wei\\n    function taskSpecGasPriceCeil(address _provider, bytes32 _taskSpecHash)\\n        external\\n        view\\n        returns(uint256);\\n\\n    /// @notice Returns the hash of the formatted TaskSpec.\\n    /// @dev The action.data field of each Action is stripped before hashing.\\n    /// @param _taskSpec TaskSpec\\n    /// @return keccak256 hash of encoded condition address and Action List\\n    function hashTaskSpec(TaskSpec calldata _taskSpec) external view returns(bytes32);\\n\\n    /// @notice Constant used to specify the highest gas price available in the gelato system\\n    /// @dev Input 0 as gasPriceCeil and it will be assigned to NO_CEIL\\n    /// @return MAX_UINT\\n    function NO_CEIL() external pure returns(uint256);\\n\\n    // Providers' Module Getters\\n\\n    /// @notice Check if inputted module is whitelisted by provider\\n    /// @param _provider Address of provider\\n    /// @param _module Address of module\\n    /// @return true if it is whitelisted\\n    function isModuleProvided(address _provider, IGelatoProviderModule _module)\\n        external\\n        view\\n        returns(bool);\\n\\n    /// @notice Get all whitelisted provider modules from a given provider\\n    /// @param _provider Address of provider\\n    /// @return List of whitelisted provider modules\\n    function providerModules(address _provider)\\n        external\\n        view\\n        returns(IGelatoProviderModule[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/gelato/MockFGelatoDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    _wCalcCollateralToWithdraw,\\n    _wCalcDebtToRepay,\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\n\\ncontract FGelatoDebtBridgeMock {\\n    function wCalcCollateralToWithdraw(\\n        uint256 _wMinColRatioMaker,\\n        uint256 _wMinColRatioB,\\n        uint256 _wColPrice,\\n        uint256 _wPricedCol,\\n        uint256 _wDaiDebtOnMaker\\n    ) public pure returns (uint256) {\\n        return\\n            _wCalcCollateralToWithdraw(\\n                _wMinColRatioMaker,\\n                _wMinColRatioB,\\n                _wColPrice,\\n                _wPricedCol,\\n                _wDaiDebtOnMaker\\n            );\\n    }\\n\\n    function wCalcDebtToRepay(\\n        uint256 _wMinColRatioMaker,\\n        uint256 _wMinColRatioB,\\n        uint256 _wPricedCol,\\n        uint256 _wDaiDebtOnMaker\\n    ) public pure returns (uint256) {\\n        return\\n            _wCalcDebtToRepay(\\n                _wMinColRatioMaker,\\n                _wMinColRatioB,\\n                _wPricedCol,\\n                _wDaiDebtOnMaker\\n            );\\n    }\\n\\n    function getFlashLoanRoute(address _tokenA, uint256 _wTokenADebtToMove)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getFlashLoanRoute(_tokenA, _wTokenADebtToMove);\\n    }\\n\\n    function getGasCostMakerToMaker(bool _newVault, uint256 _route)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _getGasCostMakerToMaker(_newVault, _route);\\n    }\\n\\n    function getGasCostMakerToCompound(uint256 _route)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _getGasCostMakerToCompound(_route);\\n    }\\n\\n    function getRealisedDebt(uint256 _debtToMove)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _getRealisedDebt(_debtToMove);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/libraries/GelatoString.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nlibrary GelatoString {\\n    function startsWithOK(string memory _str) internal pure returns (bool) {\\n        if (\\n            bytes(_str).length >= 2 &&\\n            bytes(_str)[0] == \\\"O\\\" &&\\n            bytes(_str)[1] == \\\"K\\\"\\n        ) return true;\\n        return false;\\n    }\\n\\n    function revertWithInfo(string memory _error, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        revert(string(abi.encodePacked(_tracingInfo, _error)));\\n    }\\n\\n    function prefix(string memory _second, string memory _first)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n\\n    function suffix(string memory _first, string memory _second)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connectGelatoExecutorPayment\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OK\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultAId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vaultBId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_colToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_colType\",\"type\":\"string\"}],\"name\":\"getDataAndCastMakerToMaker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dsa\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_actionData\",\"type\":\"bytes\"},{\"internalType\":\"enum DataFlow\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"termsOk\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectGelatoDataFullMakerToMaker","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000003c0000000000000000000000005a6bc81908df5ec5dc4ad3bd59aeaba1b86fc126","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0f880689c4b7bec24cd4cdece7682753b1b9a3597d0683d1eb7f5c63bd8627a3"}]}