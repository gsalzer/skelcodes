{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\n\\r\\ninterface IERC1155TokenReceiver {\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of a single ERC1155 token type\\r\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\r\\n   * This function MAY throw to revert and reject the transfer\\r\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\r\\n   * Note: The token contract address is always the message sender\\r\\n   * @param _operator  The address which called the `safeTransferFrom` function\\r\\n   * @param _from      The address which previously owned the token\\r\\n   * @param _id        The id of the token being transferred\\r\\n   * @param _amount    The amount of tokens being transferred\\r\\n   * @param _data      Additional data with no specified format\\r\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of multiple ERC1155 token types\\r\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\r\\n   * This function MAY throw to revert and reject the transfer\\r\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\r\\n   * Note: The token contract address is always the message sender\\r\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\r\\n   * @param _from      The address which previously owned the token\\r\\n   * @param _ids       An array containing ids of each token being transferred\\r\\n   * @param _amounts   An array containing amounts of each token being transferred\\r\\n   * @param _data      Additional data with no specified format\\r\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\r\\n}\"\r\n    },\r\n    \"contracts/MonetCardToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./libraries/Address.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IERC1155TokenReceiver.sol\\\";\\r\\nimport \\\"./Minter.sol\\\";\\r\\n\\r\\ncontract MonetCardToken is Minter {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    bytes4 private constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\r\\n    bytes4 private constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\r\\n    bytes4 private constant ERC1155_INTERFACE_ID = 0xd9b67a26;\\r\\n\\r\\n    mapping(address => mapping(uint256 => uint256)) internal _balances;\\r\\n    mapping(address => mapping(address => bool)) internal _operators;\\r\\n    mapping(uint256 => uint256) internal _totalSupplies;\\r\\n\\r\\n    // VIEW\\r\\n\\r\\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\r\\n        return _operators[_owner][_operator];\\r\\n    }\\r\\n\\r\\n    function totalSupply(uint256 _id) public view returns (uint256) {\\r\\n        return _totalSupplies[_id];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\\r\\n        return _balances[_owner][_id];\\r\\n    }\\r\\n\\r\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\\r\\n        require(_owners.length == _ids.length, \\\"INVALID_ARRAY_LENGTH\\\");\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](_owners.length);\\r\\n        for (uint256 i = 0; i < _owners.length; i++) {\\r\\n            batchBalances[i] = _balances[_owners[i]][_ids[i]];\\r\\n        }\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    function cardsNumOf(address _owner, uint256 _level,uint256 _carry) public view returns (uint256 nums) {\\r\\n        for (uint256 i = 0; i < 4; i++) {\\r\\n            uint256 num = _balances[_owner][_level.mul(10).add(i)];\\r\\n            nums = nums.add((_carry**(3 - i)).mul(num));\\r\\n        }\\r\\n        return nums;\\r\\n    }\\r\\n\\r\\n    function cardsNumOfAll(address _owner, uint256 _carry) public view returns (uint256[10] memory nums) {\\r\\n        uint256 levelMax = 10;\\r\\n        for (uint256 i = 0; i < levelMax; i++) {\\r\\n            nums[i] = cardsNumOf(_owner, levelMax.sub(i), _carry);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function cardsTotalSupply() public view returns (uint256[40] memory nums) {\\r\\n        uint256 idx;\\r\\n        for (uint256 i = 10; i > 0; i--) {\\r\\n            for (uint256 j = 0; j < 4; j++) {\\r\\n                nums[idx++] = _totalSupplies[i.mul(10).add(j)];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\\r\\n        return _interfaceID == ERC1155_INTERFACE_ID;\\r\\n    }\\r\\n\\r\\n    // PRIVATE\\r\\n    function _mintBatch(address _to, uint256[] memory _ids, uint256[] memory _values) private {\\r\\n        require(_to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        uint256 size = _ids.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            _totalSupplies[_ids[i]] = _totalSupplies[_ids[i]].add(_values[i]);\\r\\n            _balances[_to][_ids[i]] = _balances[_to][_ids[i]].add(_values[i]);\\r\\n        }\\r\\n        emit TransferBatch(msg.sender, address(0), _to, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function _safeBatchBurnFrom(address _from, uint256[] memory _ids, uint256[] memory _values ) private {\\r\\n        require(_ids.length == _values.length, \\\"INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n        uint256 size = _ids.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            _balances[_from][_ids[i]] = _balances[_from][_ids[i]].sub(\\r\\n                _values[i]\\r\\n            );\\r\\n            _totalSupplies[_ids[i]] = _totalSupplies[_ids[i]].sub(_values[i]);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(msg.sender, _from, address(0), _ids, _values);\\r\\n    }\\r\\n\\r\\n    function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount) private {\\r\\n        _balances[_from][_id] = _balances[_from][_id].sub(_amount); // Subtract amount\\r\\n        _balances[_to][_id] = _balances[_to][_id].add(_amount); // Add amount\\r\\n\\r\\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\\r\\n    }\\r\\n\\r\\n    function _safeBatchTransferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256[] memory _ids,\\r\\n        uint256[] memory _amounts\\r\\n    ) private {\\r\\n        require(_ids.length == _amounts.length, \\\"INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n        uint256 size = _ids.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            _balances[_from][_ids[i]] = _balances[_from][_ids[i]].sub(\\r\\n                _amounts[i]\\r\\n            );\\r\\n            _balances[_to][_ids[i]] = _balances[_to][_ids[i]].add(_amounts[i]);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\\r\\n    }\\r\\n\\r\\n    function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) private {\\r\\n        if (_to.isContract()) {\\r\\n            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\\r\\n            require(retval == ERC1155_RECEIVED_VALUE, \\\"INVALID_ON_RECEIVE_MESSAGE\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) private {\\r\\n        if (_to.isContract()) {\\r\\n            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data );\\r\\n            require(retval == ERC1155_BATCH_RECEIVED_VALUE, \\\"INVALID_ON_RECEIVE_MESSAGE\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // EXTERNAL\\r\\n    function safeBatchMint(address _to, uint256[] calldata _ids, uint256[] calldata _values) external onlyMinter {\\r\\n        require(_ids.length == _values.length, \\\"INVALID_ARRAYS_LENGTH\\\");\\r\\n        _mintBatch(_to, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function safeBatchBurnFrom(address _from, uint256[] calldata _ids, uint256[] calldata _amounts) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n\\r\\n        _safeBatchBurnFrom(_from, _ids, _amounts);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n        require(_to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        _safeTransferFrom(_from, _to, _id, _amount);\\r\\n        _callonERC1155Received(_from, _to, _id, _amount, _data);\\r\\n    }\\r\\n\\r\\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n        require(_to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        _safeBatchTransferFrom(_from, _to, _ids, _amounts);\\r\\n        _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\\r\\n    }\\r\\n\\r\\n    function cardsBatchMint(address _to, uint256[] calldata _cards) external onlyMinter {\\r\\n        uint256[] memory _ids = new uint256[](_cards.length);\\r\\n        uint256[] memory _values = new uint256[](_cards.length);\\r\\n        for (uint256 i = 0; i < _cards.length; i++) {\\r\\n            _ids[i] = _cards[i] % 1000;\\r\\n            _values[i] = _cards[i] / 1000;\\r\\n        }\\r\\n        _mintBatch(_to, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function cardsBatchBurnFrom(address _from, uint256[] calldata _cards) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n\\r\\n        uint256[] memory _ids = new uint256[](_cards.length);\\r\\n        uint256[] memory _values = new uint256[](_cards.length);\\r\\n        for (uint256 i = 0; i < _cards.length; i++) {\\r\\n            _ids[i] = _cards[i] % 1000;\\r\\n            _values[i] = _cards[i] / 1000;\\r\\n        }\\r\\n\\r\\n        _safeBatchBurnFrom(_from, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address _operator, bool _approved) external {\\r\\n        _operators[msg.sender][_operator] = _approved;\\r\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\r\\n    }\\r\\n\\r\\n    // EVENT\\r\\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\r\\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n    event URI(string _amount, uint256 indexed _id);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\r\\n    }\\r\\n    \\r\\n    function div(uint a, uint b) internal pure returns (uint z) {\\r\\n        require(b > 0);\\r\\n        return a / b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Minter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport './Ownable.sol';\\n\\ncontract Minter is Ownable {\\n    \\n    mapping(address => bool) private _minters;\\n    \\n    event MinterChanged(address indexed minter, bool approved);\\n\\n\\n    modifier onlyMinter {\\n        require(isMinter(), \\\"Minter: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    function isMinter() public view returns (bool){\\n        return _minters[msg.sender];\\n    }\\n    \\n    function setMinter(address _minter,bool _approved) external onlyOwner {\\n        _minters[_minter] = _approved;\\n        emit MinterChanged(_minter,_approved);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_amount\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_cards\",\"type\":\"uint256[]\"}],\"name\":\"cardsBatchBurnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_cards\",\"type\":\"uint256[]\"}],\"name\":\"cardsBatchMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_carry\",\"type\":\"uint256\"}],\"name\":\"cardsNumOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nums\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_carry\",\"type\":\"uint256\"}],\"name\":\"cardsNumOfAll\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"nums\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cardsTotalSupply\",\"outputs\":[{\"internalType\":\"uint256[40]\",\"name\":\"nums\",\"type\":\"uint256[40]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchBurnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MonetCardToken","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}