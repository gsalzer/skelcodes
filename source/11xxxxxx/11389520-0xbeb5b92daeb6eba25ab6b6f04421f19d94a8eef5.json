{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/OpenOracleData.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.6.10;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title The Open Oracle Data Base Contract\r\n * @author Compound Labs, Inc.\r\n */\r\ncontract OpenOracleData {\r\n    /**\r\n     * @notice The event emitted when a source writes to its storage\r\n     */\r\n    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\r\n\r\n    /**\r\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\r\n     * @param message The payload containing the timestamp, and (key, value) pairs\r\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\r\n     * @return The keys that were written\r\n     */\r\n    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\r\n\r\n    /**\r\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\r\n     * @param source The verifiable author of the data\r\n     * @param key The selector for the value to return\r\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\r\n     */\r\n    //function get(address source, <Key> key) external view returns (uint, <Value>);\r\n\r\n    /**\r\n     * @notice Recovers the source address which signed a message\r\n     * @dev Comparing to a claimed address would add nothing,\r\n     *  as the caller could simply perform the recover and claim that address.\r\n     * @param message The data that was presumably signed\r\n     * @param signature The fingerprint of the data + private key\r\n     * @return The source address which signed the message, presumably\r\n     */\r\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n}\r\n\r\n// File: contracts/OpenOraclePriceData.sol\r\n\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/**\r\n * @title The Open Oracle Price Data Contract\r\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\r\n * @author Compound Labs, Inc.\r\n */\r\ncontract OpenOraclePriceData is OpenOracleData {\r\n    ///@notice The event emitted when a source writes to its storage\r\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\r\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\r\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\r\n\r\n    ///@notice The fundamental unit of storage for a reporter source\r\n    struct Datum {\r\n        uint64 timestamp;\r\n        uint64 value;\r\n    }\r\n\r\n    /**\r\n     * @dev The most recent authenticated data from all sources.\r\n     *  This is private because dynamic mapping keys preclude auto-generated getters.\r\n     */\r\n    mapping(address => mapping(string => Datum)) private data;\r\n\r\n    /**\r\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\r\n     * @param message The payload containing the timestamp, and (key, value) pairs\r\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\r\n     * @return The keys that were written\r\n     */\r\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\r\n        (address source, uint64 timestamp, string memory key, uint64 value) = decodeMessage(message, signature);\r\n        return putInternal(source, timestamp, key, value);\r\n    }\r\n\r\n    function putInternal(address source, uint64 timestamp, string memory key, uint64 value) internal returns (string memory) {\r\n        // Only update if newer than stored, according to source\r\n        Datum storage prior = data[source][key];\r\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes && source != address(0)) {\r\n            data[source][key] = Datum(timestamp, value);\r\n            emit Write(source, key, timestamp, value);\r\n        } else {\r\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    function decodeMessage(bytes calldata message, bytes calldata signature) internal pure returns (address, uint64, string memory, uint64) {\r\n        // Recover the source address\r\n        address source = source(message, signature);\r\n\r\n        // Decode the message and check the kind\r\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\r\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\"prices\")), \"Kind of data must be 'prices'\");\r\n        return (source, timestamp, key, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Read a single key from an authenticated source\r\n     * @param source The verifiable author of the data\r\n     * @param key The selector for the value to return\r\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\r\n     */\r\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\r\n        Datum storage datum = data[source][key];\r\n        return (datum.timestamp, datum.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Read only the value for a single key from an authenticated source\r\n     * @param source The verifiable author of the data\r\n     * @param key The selector for the value to return\r\n     * @return The price value (defaults to 0)\r\n     */\r\n    function getPrice(address source, string calldata key) external view returns (uint64) {\r\n        return data[source][key].value;\r\n    }\r\n}\r\n\r\n// File: contracts/Uniswap/UniswapConfig.sol\r\n\r\n\r\npragma solidity ^0.6.10;\r\n\r\ninterface SLErc20 {\r\n    function underlying() external view returns (address);\r\n}\r\n\r\ncontract UniswapConfig {\r\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\r\n    enum PriceSource {\r\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\r\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\r\n        REPORTER   /// implies the price is set by the reporter\r\n    }\r\n\r\n    /// @dev Describe how the USD price should be determined for an asset.\r\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\r\n    struct TokenConfig {\r\n        address slToken;\r\n        address underlying;\r\n        bytes32 symbolHash;\r\n        uint256 baseUnit;\r\n        PriceSource priceSource;\r\n        uint256 fixedPrice;\r\n        address uniswapMarket;\r\n        address sashimiswapMarket;\r\n        bool isUniswapReversed;\r\n        bool isSashimiswapReversed;\r\n        uint256 uniswapWeight;\r\n        uint256 sashimiswapWeight;\r\n        bool isDoubleAnchorTolerance;\r\n    }\r\n\r\n    /// @notice The max number of tokens this contract is hardcoded to support\r\n    /// @dev Do not change this variable without updating all the fields throughout the contract.\r\n    uint public constant maxTokens = 30;\r\n\r\n    /// @notice The number of tokens this contract actually supports\r\n    uint public immutable numTokens;\r\n\r\n    TokenConfig[] internal tokenConfigs;\r\n\r\n    address internal immutable slToken00;\r\n    address internal immutable slToken01;\r\n    address internal immutable slToken02;\r\n    address internal immutable slToken03;\r\n    address internal immutable slToken04;\r\n    address internal immutable slToken05;\r\n    address internal immutable slToken06;\r\n    address internal immutable slToken07;\r\n    address internal immutable slToken08;\r\n    address internal immutable slToken09;\r\n    address internal immutable slToken10;\r\n    address internal immutable slToken11;\r\n    address internal immutable slToken12;\r\n    address internal immutable slToken13;\r\n    address internal immutable slToken14;\r\n    address internal immutable slToken15;\r\n    address internal immutable slToken16;\r\n    address internal immutable slToken17;\r\n    address internal immutable slToken18;\r\n    address internal immutable slToken19;\r\n    address internal immutable slToken20;\r\n    address internal immutable slToken21;\r\n    address internal immutable slToken22;\r\n    address internal immutable slToken23;\r\n    address internal immutable slToken24;\r\n    address internal immutable slToken25;\r\n    address internal immutable slToken26;\r\n    address internal immutable slToken27;\r\n    address internal immutable slToken28;\r\n    address internal immutable slToken29;\r\n\r\n    address internal immutable underlying00;\r\n    address internal immutable underlying01;\r\n    address internal immutable underlying02;\r\n    address internal immutable underlying03;\r\n    address internal immutable underlying04;\r\n    address internal immutable underlying05;\r\n    address internal immutable underlying06;\r\n    address internal immutable underlying07;\r\n    address internal immutable underlying08;\r\n    address internal immutable underlying09;\r\n    address internal immutable underlying10;\r\n    address internal immutable underlying11;\r\n    address internal immutable underlying12;\r\n    address internal immutable underlying13;\r\n    address internal immutable underlying14;\r\n    address internal immutable underlying15;\r\n    address internal immutable underlying16;\r\n    address internal immutable underlying17;\r\n    address internal immutable underlying18;\r\n    address internal immutable underlying19;\r\n    address internal immutable underlying20;\r\n    address internal immutable underlying21;\r\n    address internal immutable underlying22;\r\n    address internal immutable underlying23;\r\n    address internal immutable underlying24;\r\n    address internal immutable underlying25;\r\n    address internal immutable underlying26;\r\n    address internal immutable underlying27;\r\n    address internal immutable underlying28;\r\n    address internal immutable underlying29;\r\n\r\n    bytes32 internal immutable symbolHash00;\r\n    bytes32 internal immutable symbolHash01;\r\n    bytes32 internal immutable symbolHash02;\r\n    bytes32 internal immutable symbolHash03;\r\n    bytes32 internal immutable symbolHash04;\r\n    bytes32 internal immutable symbolHash05;\r\n    bytes32 internal immutable symbolHash06;\r\n    bytes32 internal immutable symbolHash07;\r\n    bytes32 internal immutable symbolHash08;\r\n    bytes32 internal immutable symbolHash09;\r\n    bytes32 internal immutable symbolHash10;\r\n    bytes32 internal immutable symbolHash11;\r\n    bytes32 internal immutable symbolHash12;\r\n    bytes32 internal immutable symbolHash13;\r\n    bytes32 internal immutable symbolHash14;\r\n    bytes32 internal immutable symbolHash15;\r\n    bytes32 internal immutable symbolHash16;\r\n    bytes32 internal immutable symbolHash17;\r\n    bytes32 internal immutable symbolHash18;\r\n    bytes32 internal immutable symbolHash19;\r\n    bytes32 internal immutable symbolHash20;\r\n    bytes32 internal immutable symbolHash21;\r\n    bytes32 internal immutable symbolHash22;\r\n    bytes32 internal immutable symbolHash23;\r\n    bytes32 internal immutable symbolHash24;\r\n    bytes32 internal immutable symbolHash25;\r\n    bytes32 internal immutable symbolHash26;\r\n    bytes32 internal immutable symbolHash27;\r\n    bytes32 internal immutable symbolHash28;\r\n    bytes32 internal immutable symbolHash29;\r\n\r\n    /**\r\n     * @notice Construct an immutable store of configs into the contract data\r\n     * @param configs The configs for the supported assets\r\n     */\r\n    constructor(TokenConfig[] memory configs) public {\r\n        require(configs.length <= maxTokens, \"too many configs\");\r\n        numTokens = configs.length;\r\n        for(uint i = 0; i < configs.length; i++){\r\n            tokenConfigs.push(configs[i]);\r\n        }\r\n        slToken00 = get(configs, 0).slToken;\r\n        slToken01 = get(configs, 1).slToken;\r\n        slToken02 = get(configs, 2).slToken;\r\n        slToken03 = get(configs, 3).slToken;\r\n        slToken04 = get(configs, 4).slToken;\r\n        slToken05 = get(configs, 5).slToken;\r\n        slToken06 = get(configs, 6).slToken;\r\n        slToken07 = get(configs, 7).slToken;\r\n        slToken08 = get(configs, 8).slToken;\r\n        slToken09 = get(configs, 9).slToken;\r\n        slToken10 = get(configs, 10).slToken;\r\n        slToken11 = get(configs, 11).slToken;\r\n        slToken12 = get(configs, 12).slToken;\r\n        slToken13 = get(configs, 13).slToken;\r\n        slToken14 = get(configs, 14).slToken;\r\n        slToken15 = get(configs, 15).slToken;\r\n        slToken16 = get(configs, 16).slToken;\r\n        slToken17 = get(configs, 17).slToken;\r\n        slToken18 = get(configs, 18).slToken;\r\n        slToken19 = get(configs, 19).slToken;\r\n        slToken20 = get(configs, 20).slToken;\r\n        slToken21 = get(configs, 21).slToken;\r\n        slToken22 = get(configs, 22).slToken;\r\n        slToken23 = get(configs, 23).slToken;\r\n        slToken24 = get(configs, 24).slToken;\r\n        slToken25 = get(configs, 25).slToken;\r\n        slToken26 = get(configs, 26).slToken;\r\n        slToken27 = get(configs, 27).slToken;\r\n        slToken28 = get(configs, 28).slToken;\r\n        slToken29 = get(configs, 29).slToken;\r\n\r\n        underlying00 = get(configs, 0).underlying;\r\n        underlying01 = get(configs, 1).underlying;\r\n        underlying02 = get(configs, 2).underlying;\r\n        underlying03 = get(configs, 3).underlying;\r\n        underlying04 = get(configs, 4).underlying;\r\n        underlying05 = get(configs, 5).underlying;\r\n        underlying06 = get(configs, 6).underlying;\r\n        underlying07 = get(configs, 7).underlying;\r\n        underlying08 = get(configs, 8).underlying;\r\n        underlying09 = get(configs, 9).underlying;\r\n        underlying10 = get(configs, 10).underlying;\r\n        underlying11 = get(configs, 11).underlying;\r\n        underlying12 = get(configs, 12).underlying;\r\n        underlying13 = get(configs, 13).underlying;\r\n        underlying14 = get(configs, 14).underlying;\r\n        underlying15 = get(configs, 15).underlying;\r\n        underlying16 = get(configs, 16).underlying;\r\n        underlying17 = get(configs, 17).underlying;\r\n        underlying18 = get(configs, 18).underlying;\r\n        underlying19 = get(configs, 19).underlying;\r\n        underlying20 = get(configs, 20).underlying;\r\n        underlying21 = get(configs, 21).underlying;\r\n        underlying22 = get(configs, 22).underlying;\r\n        underlying23 = get(configs, 23).underlying;\r\n        underlying24 = get(configs, 24).underlying;\r\n        underlying25 = get(configs, 25).underlying;\r\n        underlying26 = get(configs, 26).underlying;\r\n        underlying27 = get(configs, 27).underlying;\r\n        underlying28 = get(configs, 28).underlying;\r\n        underlying29 = get(configs, 29).underlying;\r\n\r\n        symbolHash00 = get(configs, 0).symbolHash;\r\n        symbolHash01 = get(configs, 1).symbolHash;\r\n        symbolHash02 = get(configs, 2).symbolHash;\r\n        symbolHash03 = get(configs, 3).symbolHash;\r\n        symbolHash04 = get(configs, 4).symbolHash;\r\n        symbolHash05 = get(configs, 5).symbolHash;\r\n        symbolHash06 = get(configs, 6).symbolHash;\r\n        symbolHash07 = get(configs, 7).symbolHash;\r\n        symbolHash08 = get(configs, 8).symbolHash;\r\n        symbolHash09 = get(configs, 9).symbolHash;\r\n        symbolHash10 = get(configs, 10).symbolHash;\r\n        symbolHash11 = get(configs, 11).symbolHash;\r\n        symbolHash12 = get(configs, 12).symbolHash;\r\n        symbolHash13 = get(configs, 13).symbolHash;\r\n        symbolHash14 = get(configs, 14).symbolHash;\r\n        symbolHash15 = get(configs, 15).symbolHash;\r\n        symbolHash16 = get(configs, 16).symbolHash;\r\n        symbolHash17 = get(configs, 17).symbolHash;\r\n        symbolHash18 = get(configs, 18).symbolHash;\r\n        symbolHash19 = get(configs, 19).symbolHash;\r\n        symbolHash20 = get(configs, 20).symbolHash;\r\n        symbolHash21 = get(configs, 21).symbolHash;\r\n        symbolHash22 = get(configs, 22).symbolHash;\r\n        symbolHash23 = get(configs, 23).symbolHash;\r\n        symbolHash24 = get(configs, 24).symbolHash;\r\n        symbolHash25 = get(configs, 25).symbolHash;\r\n        symbolHash26 = get(configs, 26).symbolHash;\r\n        symbolHash27 = get(configs, 27).symbolHash;\r\n        symbolHash28 = get(configs, 28).symbolHash;\r\n        symbolHash29 = get(configs, 29).symbolHash;\r\n    }\r\n\r\n    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\r\n        if (i < configs.length)\r\n            return configs[i];\r\n        return TokenConfig({\r\n            slToken: address(0),\r\n            underlying: address(0),\r\n            symbolHash: bytes32(0),\r\n            baseUnit: uint256(0),\r\n            priceSource: PriceSource(0),\r\n            fixedPrice: uint256(0),\r\n            uniswapMarket: address(0),\r\n            sashimiswapMarket: address(0),\r\n            isUniswapReversed: false,\r\n            isSashimiswapReversed: false,\r\n            uniswapWeight: 0,\r\n            sashimiswapWeight: 0,\r\n            isDoubleAnchorTolerance: false\r\n        });\r\n    }\r\n\r\n    function getSLTokenIndex(address slToken) internal view returns (uint) {\r\n        if (slToken == slToken00) return 0;\r\n        if (slToken == slToken01) return 1;\r\n        if (slToken == slToken02) return 2;\r\n        if (slToken == slToken03) return 3;\r\n        if (slToken == slToken04) return 4;\r\n        if (slToken == slToken05) return 5;\r\n        if (slToken == slToken06) return 6;\r\n        if (slToken == slToken07) return 7;\r\n        if (slToken == slToken08) return 8;\r\n        if (slToken == slToken09) return 9;\r\n        if (slToken == slToken10) return 10;\r\n        if (slToken == slToken11) return 11;\r\n        if (slToken == slToken12) return 12;\r\n        if (slToken == slToken13) return 13;\r\n        if (slToken == slToken14) return 14;\r\n        if (slToken == slToken15) return 15;\r\n        if (slToken == slToken16) return 16;\r\n        if (slToken == slToken17) return 17;\r\n        if (slToken == slToken18) return 18;\r\n        if (slToken == slToken19) return 19;\r\n        if (slToken == slToken20) return 20;\r\n        if (slToken == slToken21) return 21;\r\n        if (slToken == slToken22) return 22;\r\n        if (slToken == slToken23) return 23;\r\n        if (slToken == slToken24) return 24;\r\n        if (slToken == slToken25) return 25;\r\n        if (slToken == slToken26) return 26;\r\n        if (slToken == slToken27) return 27;\r\n        if (slToken == slToken28) return 28;\r\n        if (slToken == slToken29) return 29;\r\n\r\n        return uint(-1);\r\n    }\r\n\r\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\r\n        if (underlying == underlying00) return 0;\r\n        if (underlying == underlying01) return 1;\r\n        if (underlying == underlying02) return 2;\r\n        if (underlying == underlying03) return 3;\r\n        if (underlying == underlying04) return 4;\r\n        if (underlying == underlying05) return 5;\r\n        if (underlying == underlying06) return 6;\r\n        if (underlying == underlying07) return 7;\r\n        if (underlying == underlying08) return 8;\r\n        if (underlying == underlying09) return 9;\r\n        if (underlying == underlying10) return 10;\r\n        if (underlying == underlying11) return 11;\r\n        if (underlying == underlying12) return 12;\r\n        if (underlying == underlying13) return 13;\r\n        if (underlying == underlying14) return 14;\r\n        if (underlying == underlying15) return 15;\r\n        if (underlying == underlying16) return 16;\r\n        if (underlying == underlying17) return 17;\r\n        if (underlying == underlying18) return 18;\r\n        if (underlying == underlying19) return 19;\r\n        if (underlying == underlying20) return 20;\r\n        if (underlying == underlying21) return 21;\r\n        if (underlying == underlying22) return 22;\r\n        if (underlying == underlying23) return 23;\r\n        if (underlying == underlying24) return 24;\r\n        if (underlying == underlying25) return 25;\r\n        if (underlying == underlying26) return 26;\r\n        if (underlying == underlying27) return 27;\r\n        if (underlying == underlying28) return 28;\r\n        if (underlying == underlying29) return 29;\r\n\r\n        return uint(-1);\r\n    }\r\n\r\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\r\n        if (symbolHash == symbolHash00) return 0;\r\n        if (symbolHash == symbolHash01) return 1;\r\n        if (symbolHash == symbolHash02) return 2;\r\n        if (symbolHash == symbolHash03) return 3;\r\n        if (symbolHash == symbolHash04) return 4;\r\n        if (symbolHash == symbolHash05) return 5;\r\n        if (symbolHash == symbolHash06) return 6;\r\n        if (symbolHash == symbolHash07) return 7;\r\n        if (symbolHash == symbolHash08) return 8;\r\n        if (symbolHash == symbolHash09) return 9;\r\n        if (symbolHash == symbolHash10) return 10;\r\n        if (symbolHash == symbolHash11) return 11;\r\n        if (symbolHash == symbolHash12) return 12;\r\n        if (symbolHash == symbolHash13) return 13;\r\n        if (symbolHash == symbolHash14) return 14;\r\n        if (symbolHash == symbolHash15) return 15;\r\n        if (symbolHash == symbolHash16) return 16;\r\n        if (symbolHash == symbolHash17) return 17;\r\n        if (symbolHash == symbolHash18) return 18;\r\n        if (symbolHash == symbolHash19) return 19;\r\n        if (symbolHash == symbolHash20) return 20;\r\n        if (symbolHash == symbolHash21) return 21;\r\n        if (symbolHash == symbolHash22) return 22;\r\n        if (symbolHash == symbolHash23) return 23;\r\n        if (symbolHash == symbolHash24) return 24;\r\n        if (symbolHash == symbolHash25) return 25;\r\n        if (symbolHash == symbolHash26) return 26;\r\n        if (symbolHash == symbolHash27) return 27;\r\n        if (symbolHash == symbolHash28) return 28;\r\n        if (symbolHash == symbolHash29) return 29;\r\n\r\n        return uint(-1);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the i-th config, according to the order they were passed in originally\r\n     * @param i The index of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\r\n        require(i < numTokens, \"token config not found\");\r\n\r\n        return tokenConfigs[i];}\r\n\r\n    /**\r\n     * @notice Get the config for symbol\r\n     * @param symbol The symbol of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\r\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for the symbolHash\r\n     * @param symbolHash The keccack256 of the symbol of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\r\n        uint index = getSymbolHashIndex(symbolHash);\r\n        if (index != uint(-1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        revert(\"token config not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for the slToken\r\n     * @dev If a config for the slToken is not found, falls back to searching for the underlying.\r\n     * @param slToken The address of the slToken of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySLToken(address slToken) public view returns (TokenConfig memory) {\r\n        uint index = getSLTokenIndex(slToken);\r\n        if (index != uint(-1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        return getTokenConfigByUnderlying(SLErc20(slToken).underlying());\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for an underlying asset\r\n     * @param underlying The address of the underlying asset of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\r\n        uint index = getUnderlyingIndex(underlying);\r\n        if (index != uint(-1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        revert(\"token config not found\");\r\n    }\r\n}\r\n\r\n// File: contracts/Uniswap/UniswapLib.sol\r\n\r\n\r\npragma solidity ^0.6.10;\r\n\r\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << 112) / denominator);\r\n    }\r\n\r\n    // decode a uq112x112 into a uint with 18 decimals of precision\r\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\r\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\r\n        // instead, get close to:\r\n        //  (x * 1e18) >> 112\r\n        // without risk of overflowing, e.g.:\r\n        //  (x) / 2 ** (112 - lg(1e18))\r\n        return uint(self._x) / 5192296858534827;\r\n    }\r\n}\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n}\r\n\r\n// File: contracts/Uniswap/UniswapAnchoredView.sol\r\n\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\n\r\nstruct Observation {\r\n    uint timestamp;\r\n    uint acc;\r\n}\r\n\r\ncontract UniswapAnchoredView is UniswapConfig {\r\n    using FixedPoint for *;\r\n\r\n    /// @notice The Open Oracle Price Data contract\r\n    OpenOraclePriceData public immutable priceData;\r\n\r\n    /// @notice The number of wei in 1 ETH\r\n    uint public constant ethBaseUnit = 1e18;\r\n\r\n    /// @notice A common scaling factor to maintain precision\r\n    uint public constant expScale = 1e18;\r\n\r\n    /// @notice The Open Oracle Reporter\r\n    address public immutable reporter;\r\n\r\n    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\r\n    uint public immutable upperBoundAnchorRatio;\r\n\r\n    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\r\n    uint public immutable lowerBoundAnchorRatio;\r\n\r\n    uint public immutable upperBoundAnchorRatio2;\r\n\r\n    uint public immutable lowerBoundAnchorRatio2;\r\n\r\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\r\n    uint public immutable anchorPeriod;\r\n\r\n    /// @notice Official prices by symbol hash\r\n    mapping(bytes32 => uint) public prices;\r\n\r\n    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\r\n    bool public reporterInvalidated;\r\n\r\n    /// @notice The old observation for each symbolHash\r\n    mapping(bytes32 => Observation) public oldUniswapObservations;\r\n\r\n    /// @notice The new observation for each symbolHash\r\n    mapping(bytes32 => Observation) public newUniswapObservations;\r\n\r\n     /// @notice The old observation for each symbolHash\r\n    mapping(bytes32 => Observation) public oldSashimiswapObservations;\r\n\r\n    /// @notice The new observation for each symbolHash\r\n    mapping(bytes32 => Observation) public newSashimiswapObservations;\r\n\r\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\r\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\r\n\r\n    /// @notice The event emitted when the stored price is updated\r\n    event PriceUpdated(string symbol, uint price);\r\n\r\n    /// @notice The event emitted when anchor price is updated\r\n    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\r\n\r\n    /// @notice The event emitted when the uniswap window changes\r\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\r\n\r\n    /// @notice The event emitted when the uniswap window changes\r\n    event SashimiswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\r\n\r\n    /// @notice The event emitted when reporter invalidates itself\r\n    event ReporterInvalidated(address reporter);\r\n\r\n    bytes32 constant ethHash = keccak256(abi.encodePacked(\"ETH\"));\r\n    bytes32 constant rotateHash = keccak256(abi.encodePacked(\"rotate\"));\r\n\r\n    /**\r\n     * @notice Construct a uniswap anchored view for a set of token configurations\r\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\r\n     * @param reporter_ The reporter whose prices are to be used\r\n     * @param anchorToleranceMantissa_ The percentage tolerance that the reporter may deviate from the uniswap anchor\r\n     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\r\n     * @param configs The static token configurations which define what prices are supported and how\r\n     */\r\n    constructor(OpenOraclePriceData priceData_,\r\n                address reporter_,\r\n                uint anchorToleranceMantissa_,\r\n                uint anchorPeriod_,\r\n                TokenConfig[] memory configs) UniswapConfig(configs) public {\r\n        priceData = priceData_;\r\n        reporter = reporter_;\r\n        anchorPeriod = anchorPeriod_;\r\n\r\n        // Allow the tolerance to be whatever the deployer chooses, but prevent under/overflow (and prices from being 0)\r\n        upperBoundAnchorRatio = anchorToleranceMantissa_ > uint(-1) - 100e16 ? uint(-1) : 100e16 + anchorToleranceMantissa_;\r\n        lowerBoundAnchorRatio = anchorToleranceMantissa_ < 100e16 ? 100e16 - anchorToleranceMantissa_ : 1;\r\n        uint doubleAnchorToleranceMantissa = mul(anchorToleranceMantissa_, 2);\r\n        upperBoundAnchorRatio2 = doubleAnchorToleranceMantissa > uint(-1) - 100e16 ? uint(-1) : 100e16 + doubleAnchorToleranceMantissa;\r\n        lowerBoundAnchorRatio2 = doubleAnchorToleranceMantissa < 100e16 ? 100e16 - doubleAnchorToleranceMantissa : 1;\r\n\r\n        for (uint i = 0; i < configs.length; i++) {\r\n            TokenConfig memory config = configs[i];\r\n            require(config.baseUnit > 0, \"baseUnit must be greater than zero\");\r\n            address uniswapMarket = config.uniswapMarket;\r\n            if (config.priceSource == PriceSource.REPORTER) {\r\n                require(uniswapMarket != address(0), \"reported prices must have an anchor\");\r\n                bytes32 symbolHash = config.symbolHash;\r\n                uint uniswapCumulativePrice = currentCumulativePrice(config.uniswapMarket, config.isUniswapReversed);\r\n                oldUniswapObservations[symbolHash].timestamp = block.timestamp;\r\n                newUniswapObservations[symbolHash].timestamp = block.timestamp;\r\n                oldUniswapObservations[symbolHash].acc = uniswapCumulativePrice;\r\n                newUniswapObservations[symbolHash].acc = uniswapCumulativePrice;\r\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, uniswapCumulativePrice, uniswapCumulativePrice);\r\n                if(config.sashimiswapMarket != address(0)){\r\n                    uint sashimiswapCumulativePrice = currentCumulativePrice(config.sashimiswapMarket, config.isSashimiswapReversed);\r\n                    oldSashimiswapObservations[symbolHash].timestamp = block.timestamp;\r\n                    newSashimiswapObservations[symbolHash].timestamp = block.timestamp;\r\n                    oldSashimiswapObservations[symbolHash].acc = sashimiswapCumulativePrice;\r\n                    newSashimiswapObservations[symbolHash].acc = sashimiswapCumulativePrice;\r\n                    emit SashimiswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, sashimiswapCumulativePrice, sashimiswapCumulativePrice);\r\n                }\r\n                \r\n            } else {\r\n                require(uniswapMarket == address(0), \"only reported prices utilize an anchor\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the official price for a symbol\r\n     * @param symbol The symbol to fetch the price of\r\n     * @return Price denominated in USD, with 6 decimals\r\n     */\r\n    function price(string memory symbol) external view returns (uint) {\r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n        return priceInternal(config);\r\n    }\r\n\r\n    function priceInternal(TokenConfig memory config) internal view returns (uint) {\r\n        if (config.priceSource == PriceSource.REPORTER) return prices[config.symbolHash];\r\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\r\n        if (config.priceSource == PriceSource.FIXED_ETH) {\r\n            uint usdPerEth = prices[ethHash];\r\n            require(usdPerEth > 0, \"ETH price not set, cannot convert to dollars\");\r\n            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying price of a slToken\r\n     * @dev Implements the PriceOracle interface for Compound v2.\r\n     * @param slToken The slToken address for price retrieval\r\n     * @return Price denominated in USD, with 18 decimals, for the given slToken address\r\n     */\r\n    function getUnderlyingPrice(address slToken) external view returns (uint) {\r\n        TokenConfig memory config = getTokenConfigBySLToken(slToken);\r\n         // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\r\n         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\r\n        return mul(1e30, priceInternal(config)) / config.baseUnit;\r\n    }\r\n\r\n    /**\r\n     * @notice Post open oracle reporter prices, and recalculate stored price by comparing to anchor\r\n     * @dev We let anyone pay to post anything, but only prices from configured reporter will be stored in the view.\r\n     * @param messages The messages to post to the oracle\r\n     * @param signatures The signatures for the corresponding messages\r\n     * @param symbols The symbols to compare to anchor for authoritative reading\r\n     */\r\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\r\n        require(messages.length == signatures.length, \"messages and signatures must be 1:1\");\r\n\r\n        // Save the prices\r\n        for (uint i = 0; i < messages.length; i++) {\r\n            priceData.put(messages[i], signatures[i]);\r\n        }\r\n\r\n        uint ethPrice = fetchEthPrice();\r\n\r\n        // Try to update the view storage\r\n        for (uint i = 0; i < symbols.length; i++) {\r\n            postPriceInternal(symbols[i], ethPrice);\r\n        }\r\n    }\r\n\r\n    function postPriceInternal(string memory symbol, uint ethPrice) internal {\r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n        require(config.priceSource == PriceSource.REPORTER, \"only reporter prices get posted\");\r\n\r\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\r\n        uint reporterPrice = priceData.getPrice(reporter, symbol);\r\n        uint anchorPrice;\r\n        if (symbolHash == ethHash) {\r\n            anchorPrice = ethPrice;\r\n        } else {\r\n            anchorPrice = fetchAnchorPrice(symbol, config, ethPrice);\r\n        }\r\n\r\n        if (reporterInvalidated) {\r\n            prices[symbolHash] = anchorPrice;\r\n            emit PriceUpdated(symbol, anchorPrice);\r\n        } else if (isWithinAnchor(reporterPrice, anchorPrice, config)) {\r\n            prices[symbolHash] = reporterPrice;\r\n            emit PriceUpdated(symbol, reporterPrice);\r\n        } else {\r\n            emit PriceGuarded(symbol, reporterPrice, anchorPrice);\r\n        }\r\n    }\r\n\r\n    function isWithinAnchor(uint reporterPrice, uint anchorPrice, TokenConfig memory config) internal view returns (bool) {\r\n        if (reporterPrice > 0) {\r\n            uint anchorRatio = mul(anchorPrice, 100e16) / reporterPrice;\r\n            if(config.isDoubleAnchorTolerance){\r\n                return anchorRatio <= upperBoundAnchorRatio2 && anchorRatio >= lowerBoundAnchorRatio2;\r\n            }\r\n            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current token/eth price accumulator from uniswap.\r\n     */\r\n    function currentCumulativePrice(address swapMarket, bool isSwapReversed) internal view returns (uint) {\r\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(swapMarket);\r\n        if (isSwapReversed) {\r\n            return cumulativePrice1;\r\n        } else {\r\n            return cumulativePrice0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\r\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\r\n     */\r\n    function fetchEthPrice() internal returns (uint) {\r\n        return fetchAnchorPrice(\"ETH\", getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\r\n     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\r\n     */\r\n    function fetchAnchorPrice(string memory symbol, TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\r\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeUniswapWindowValues(config.symbolHash, config.uniswapMarket,config.isUniswapReversed);\r\n        uint priceAverage = getPriceAverage(nowCumulativePrice, oldCumulativePrice, oldTimestamp);\r\n\r\n        if(config.sashimiswapMarket != address(0)){\r\n            (uint nowSashimiswapCumulativePrice, uint oldSashimiswapCumulativePrice, uint oldSashimiswapTimestamp) = pokeSashimiswapWindowValues(config.symbolHash, config.sashimiswapMarket,config.isSashimiswapReversed);\r\n            uint sashimiswapPriceAverage = getPriceAverage(nowSashimiswapCumulativePrice, oldSashimiswapCumulativePrice, oldSashimiswapTimestamp);\r\n            if(sashimiswapPriceAverage > 0){\r\n                priceAverage = (mul(priceAverage, config.uniswapWeight) + mul(sashimiswapPriceAverage, config.sashimiswapWeight)) / 10000;\r\n            }\r\n        }\r\n\r\n        uint unscaledPriceMantissa = mul(priceAverage, conversionFactor);\r\n        uint anchorPrice;\r\n\r\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\r\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\r\n        if (config.isUniswapReversed) {\r\n            // unscaledPriceMantissa * ethBaseUnit / config.baseUnit / expScale, but we simplify bc ethBaseUnit == expScale\r\n            anchorPrice = unscaledPriceMantissa / config.baseUnit;\r\n        } else {\r\n            anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\r\n        }\r\n\r\n        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\r\n\r\n        return anchorPrice;\r\n    }\r\n\r\n    function getPriceAverage(uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) internal view returns (uint){\r\n        // This should be impossible, but better safe than sorry\r\n        require(block.timestamp > oldTimestamp, \"now must come after before\");\r\n        uint timeElapsed = block.timestamp - oldTimestamp;\r\n\r\n        // Calculate uniswap time-weighted average price\r\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\r\n        uint rawSwapPriceMantissa = priceAverage.decode112with18();\r\n        return rawSwapPriceMantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Get time-weighted average prices for a token at the current timestamp.\r\n     *  Update new and old observations of lagging window if period elapsed.\r\n     */\r\n    function pokeUniswapWindowValues(bytes32 symbolHash, address swapMarket,bool isSwapReversed) internal returns (uint, uint, uint) {\r\n        uint cumulativePrice = currentCumulativePrice(swapMarket, isSwapReversed);\r\n\r\n        Observation memory newObservation = newUniswapObservations[symbolHash];\r\n\r\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\r\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\r\n        if (timeElapsed >= anchorPeriod) {\r\n            oldUniswapObservations[symbolHash].timestamp = newObservation.timestamp;\r\n            oldUniswapObservations[symbolHash].acc = newObservation.acc;\r\n\r\n            newUniswapObservations[symbolHash].timestamp = block.timestamp;\r\n            newUniswapObservations[symbolHash].acc = cumulativePrice;\r\n            emit UniswapWindowUpdated(symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\r\n        }\r\n        return (cumulativePrice, oldUniswapObservations[symbolHash].acc, oldUniswapObservations[symbolHash].timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Get time-weighted average prices for a token at the current timestamp.\r\n     *  Update new and old observations of lagging window if period elapsed.\r\n     */\r\n    function pokeSashimiswapWindowValues(bytes32 symbolHash, address swapMarket,bool isSwapReversed) internal returns (uint, uint, uint) {\r\n        uint cumulativePrice = currentCumulativePrice(swapMarket, isSwapReversed);\r\n\r\n        Observation memory newObservation = newSashimiswapObservations[symbolHash];\r\n\r\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\r\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\r\n        if (timeElapsed >= anchorPeriod) {\r\n            oldSashimiswapObservations[symbolHash].timestamp = newObservation.timestamp;\r\n            oldSashimiswapObservations[symbolHash].acc = newObservation.acc;\r\n\r\n            newSashimiswapObservations[symbolHash].timestamp = block.timestamp;\r\n            newSashimiswapObservations[symbolHash].acc = cumulativePrice;\r\n            emit SashimiswapWindowUpdated(symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\r\n        }\r\n        return (cumulativePrice, oldSashimiswapObservations[symbolHash].acc, oldSashimiswapObservations[symbolHash].timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Invalidate the reporter, and fall back to using anchor directly in all cases\r\n     * @dev Only the reporter may sign a message which allows it to invalidate itself.\r\n     *  To be used in cases of emergency, if the reporter thinks their key may be compromised.\r\n     * @param message The data that was presumably signed\r\n     * @param signature The fingerprint of the data + private key\r\n     */\r\n    function invalidateReporter(bytes memory message, bytes memory signature) external {\r\n        (string memory decodedMessage, ) = abi.decode(message, (string, address));\r\n        require(keccak256(abi.encodePacked(decodedMessage)) == rotateHash, \"invalid message must be 'rotate'\");\r\n        require(source(message, signature) == reporter, \"invalidation message must come from the reporter\");\r\n        reporterInvalidated = true;\r\n        emit ReporterInvalidated(reporter);\r\n    }\r\n\r\n    /**\r\n     * @notice Recovers the source address which signed a message\r\n     * @dev Comparing to a claimed address would add nothing,\r\n     *  as the caller could simply perform the recover and claim that address.\r\n     * @param message The data that was presumably signed\r\n     * @param signature The fingerprint of the data + private key\r\n     * @return The source address which signed the message, presumably\r\n     */\r\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /// @dev Overflow proof multiplication\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) return 0;\r\n        uint c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n        return c;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract OpenOraclePriceData\",\"name\":\"priceData_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reporter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"anchorToleranceMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"anchorPeriod_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sashimiswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSashimiswapReversed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"uniswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sashimiswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDoubleAnchorTolerance\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig[]\",\"name\":\"configs\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"AnchorPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reporter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchor\",\"type\":\"uint256\"}],\"name\":\"PriceGuarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reporter\",\"type\":\"address\"}],\"name\":\"ReporterInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SashimiswapWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UniswapWindowUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"anchorPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sashimiswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSashimiswapReversed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"uniswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sashimiswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDoubleAnchorTolerance\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"}],\"name\":\"getTokenConfigBySLToken\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sashimiswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSashimiswapReversed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"uniswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sashimiswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDoubleAnchorTolerance\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getTokenConfigBySymbol\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sashimiswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSashimiswapReversed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"uniswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sashimiswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDoubleAnchorTolerance\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"}],\"name\":\"getTokenConfigBySymbolHash\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sashimiswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSashimiswapReversed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"uniswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sashimiswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDoubleAnchorTolerance\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getTokenConfigByUnderlying\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sashimiswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSashimiswapReversed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"uniswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sashimiswapWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDoubleAnchorTolerance\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"invalidateReporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerBoundAnchorRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerBoundAnchorRatio2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"newSashimiswapObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"newUniswapObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oldSashimiswapObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oldUniswapObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"messages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"string[]\",\"name\":\"symbols\",\"type\":\"string[]\"}],\"name\":\"postPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceData\",\"outputs\":[{\"internalType\":\"contract OpenOraclePriceData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporterInvalidated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"source\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperBoundAnchorRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperBoundAnchorRatio2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapAnchoredView","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000074f210e45d43b40fb92affa73fda3a67db2d310b000000000000000000000000032bb4c56b4a0072e3ba9b5b8402062f7ef88f690000000000000000000000000000000000000000000000000000b5e620f48000000000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff40000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d4a11d5eeaac28ec3f61d100daf4d40471f185200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c59998da2c5e4c6b1db946694570273b859a6e4083ccc8faa155edfc4c54eb3cfd730000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bb2b8038a1640196fbe3e38816f3e67cba72d94000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0fa5e92f3efb6826155f1f728e162af9d7cda33a574a1153b58f03ea01cc37e5680000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a478c2975ab1ea89e8196811f51a7b7ade33eb110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec78b1a1d9c2b109e527c9134b25b1a1833b16b6594f92daa9f6d9b7a6024bce9d000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48d6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa00000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93eec34391362c28ee226b3b8624a699ee507a40fa771fd01d38b03ac7b70998bbe0000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000002fdbadf3c4d5a8666bc06645b8358ab803996e280000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bf2179859fc6d5bee9bf9158632dc51678a4100e53506a2f8b8dfe25ce412a1f5d08cbf756d6fada01a88f3f18679258c67f7f080000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a6be7f7c6c454b364cda446ea39be9e5e4369de800000000000000000000000028e240e04113877bf99354e1e4f43a79e59c535a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001097000000000000000000000000000000000000000000000000000000000000167900000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c28e27870558cf22add83540d2126da2e4b464c2b5aa07bc09fd2a89ff8c3e997f711eb342e858c2b47d4a836c683e1dc27463ad0000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b618087dae7765823bc47ffbf38c8ee8489f5ca0000000000000000000000003fa4b0b3053413684d0b658689ede7907bb4d69d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001ea00000000000000000000000000000000000000000000000000000000000025260000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dd845ce5b5034b57996e9c3b854623162367a82cbf8febe374df4919518f5a4d"}]}