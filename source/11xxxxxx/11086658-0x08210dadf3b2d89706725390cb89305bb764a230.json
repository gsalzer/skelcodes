{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.4.22 <0.8.0;\r\n\r\ncontract FYREToken {\r\n    struct Holder {\r\n        uint balance;\r\n        uint appliedSupply;\r\n    }\r\n\r\n    uint constant initialSupply = 48e18;\r\n    uint constant tokensPerRebase = 1e18;\r\n    uint constant rebaseInterval = 30 minutes;\r\n    uint coinCreationTime;\r\n    bool isICOOver = false;\r\n    mapping(address => Holder) holders;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    address master = msg.sender;\r\n    address extraPot;\r\n    bool isMainnet = true;\r\n    bool paused = false;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    constructor() {\r\n        holders[master].balance = initialSupply;\r\n        emit Transfer(address(this), master, initialSupply);\r\n    }\r\n\r\n    // ERC20 functions\r\n\r\n    function name() public pure returns (string memory){\r\n        return \"FYRE\";\r\n    }\r\n\r\n    function symbol() public pure returns (string memory){\r\n        return \"FYRE\";\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _realSupply();\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return holders[_owner].balance;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        if (_transfer(_from, _to, _value)) {\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) private returns (bool success) {\r\n        require(!paused);\r\n        require(_value <= holders[_from].balance);\r\n\r\n        uint totalSupply_ = _realSupply();\r\n\r\n        // inititalize appliedSupply\r\n        if (holders[_from].appliedSupply == 0) {\r\n            holders[_from].appliedSupply = totalSupply_;\r\n        }\r\n        if (holders[_to].appliedSupply == 0) {\r\n            holders[_to].appliedSupply = totalSupply_;\r\n        }\r\n\r\n        // calculate claims\r\n\r\n        uint newBalance;\r\n        uint diff;\r\n\r\n        // sender\r\n\r\n        if (_from != extraPot) {\r\n            newBalance = safeMul(1e18 * holders[_from].balance / holders[_from].appliedSupply, totalSupply_) / 1e18;\r\n            if (newBalance > holders[_from].balance) {\r\n                diff = safeSub(newBalance, holders[_from].balance);\r\n                if (_from != getPairAddress()) {\r\n                    holders[_from].balance = newBalance;\r\n                    emit Transfer(address(this), _from, diff);\r\n                }\r\n                else {\r\n                    // is uniswap pool -> redirect to extra pot\r\n                    holders[extraPot].balance = safeAdd(holders[extraPot].balance, diff);\r\n                    emit Transfer(address(this), extraPot, diff);\r\n                }\r\n\r\n                holders[_from].appliedSupply = totalSupply_;\r\n            }\r\n        }\r\n\r\n        // receiver\r\n\r\n        if (_to != _from && _to != extraPot) {\r\n            newBalance = safeMul(1e18 * holders[_to].balance / holders[_to].appliedSupply, totalSupply_) / 1e18;\r\n            if (newBalance > holders[_to].balance) {\r\n                diff = safeSub(newBalance, holders[_to].balance);\r\n\r\n                if (_to != getPairAddress()) {\r\n                    holders[_to].balance = newBalance;\r\n                    emit Transfer(address(this), _to, diff);\r\n                }\r\n                else {\r\n                    // is uniswap pool -> redirect to extra pot\r\n                    holders[extraPot].balance = safeAdd(holders[extraPot].balance, diff);\r\n                    emit Transfer(address(this), extraPot, diff);\r\n                }\r\n\r\n                holders[_to].appliedSupply = totalSupply_;\r\n            }\r\n        }\r\n\r\n        // transfer tokens from sender to receiver\r\n        if (_from != _to && _value > 0) {\r\n            holders[_from].balance = safeSub(holders[_from].balance, _value);\r\n            holders[_to].balance = safeAdd(holders[_to].balance, _value);\r\n            emit Transfer(_from, _to, _value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // other functions\r\n\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a, \"Subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"Addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"Multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    // just for debugging\r\n    function realBalance() external view returns (uint) {\r\n        Holder memory holder = holders[msg.sender];\r\n\r\n        uint totalSupply_ = _realSupply();\r\n\r\n        uint appliedSupply_local = holder.appliedSupply > 0 ? holder.appliedSupply : totalSupply_;\r\n\r\n        return safeMul(1e18 * holder.balance / appliedSupply_local, totalSupply_) / 1e18;\r\n    }\r\n\r\n    function _realSupply() internal view returns (uint) {\r\n        if (isICOOver) {\r\n            return safeAdd(\r\n                initialSupply,\r\n                safeMul(safeSub(block.timestamp, coinCreationTime) / rebaseInterval, tokensPerRebase)\r\n            );\r\n        }\r\n        else {\r\n            return initialSupply;\r\n        }\r\n    }\r\n\r\n    function getPairAddress() internal view returns (address) {\r\n        // WETH\r\n        address tokenA = isMainnet ? 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 : 0xc778417E063141139Fce010982780140Aa0cD5Ab;\r\n        // this token\r\n        address tokenB = address(this);\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        return address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f, // factory\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\r\n            ))));\r\n    }\r\n\r\n    // management functions\r\n\r\n    modifier onlyMaster() {\r\n        require(msg.sender == master);\r\n        _;\r\n    }\r\n\r\n    function endICO(address _extraPot) external onlyMaster {\r\n        coinCreationTime = block.timestamp;\r\n        extraPot = _extraPot;\r\n\r\n        isICOOver = true;\r\n    }\r\n\r\n    function test(bool _isTest) external onlyMaster {\r\n        isMainnet = !_isTest;\r\n    }\r\n\r\n    function pause(bool _isPaused) external onlyMaster {\r\n        paused = _isPaused;\r\n    }\r\n\r\n    function setExtraPot(address _extraPot) external onlyMaster {\r\n        extraPot = _extraPot;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_extraPot\",\"type\":\"address\"}],\"name\":\"endICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_extraPot\",\"type\":\"address\"}],\"name\":\"setExtraPot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isTest\",\"type\":\"bool\"}],\"name\":\"test\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FYREToken","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c6023b0bc7f19119a25339dec608c9be036617346c95879fcb163ad88cfd0694"}]}