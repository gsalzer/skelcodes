{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: contracts/libraries/TransferHelper.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity >=0.6.0;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/libraries/SafeMath.sol\r\n\r\n\r\n// pragma solidity >=0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/modules/Configable.sol\r\n\r\n// pragma solidity >=0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IConfig {\r\n    function developer() external view returns (address);\r\n    function platform() external view returns (address);\r\n    function factory() external view returns (address);\r\n    function mint() external view returns (address);\r\n    function token() external view returns (address);\r\n    function developPercent() external view returns (uint);\r\n    function share() external view returns (address);\r\n    function base() external view returns (address); \r\n    function governor() external view returns (address);\r\n    function getPoolValue(address pool, bytes32 key) external view returns (uint);\r\n    function getValue(bytes32 key) external view returns(uint);\r\n    function getParams(bytes32 key) external view returns(uint, uint, uint, uint); \r\n    function getPoolParams(address pool, bytes32 key) external view returns(uint, uint, uint, uint); \r\n    function wallets(bytes32 key) external view returns(address);\r\n    function setValue(bytes32 key, uint value) external;\r\n    function setPoolValue(address pool, bytes32 key, uint value) external;\r\n    function setParams(bytes32 _key, uint _min, uint _max, uint _span, uint _value) external;\r\n    function setPoolParams(bytes32 _key, uint _min, uint _max, uint _span, uint _value) external;\r\n    function initPoolParams(address _pool) external;\r\n    function isMintToken(address _token) external returns (bool);\r\n    function prices(address _token) external returns (uint);\r\n    function convertTokenAmount(address _fromToken, address _toToken, uint _fromAmount) external view returns (uint);\r\n    function DAY() external view returns (uint);\r\n    function WETH() external view returns (address);\r\n}\r\n\r\ncontract Configable {\r\n    address public config;\r\n    address public owner;\r\n\r\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function setupConfig(address _config) external onlyOwner {\r\n        config = _config;\r\n        owner = IConfig(config).developer();\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'OWNER FORBIDDEN');\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDeveloper() {\r\n        require(msg.sender == IConfig(config).developer(), 'DEVELOPER FORBIDDEN');\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPlatform() {\r\n        require(msg.sender == IConfig(config).platform(), 'PLATFORM FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory() {\r\n        require(msg.sender == IConfig(config).factory(), 'FACTORY FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == IConfig(config).governor(), 'Governor FORBIDDEN');\r\n        _;\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/modules/ConfigNames.sol\r\n\r\n// pragma solidity >=0.5.16;\r\n\r\nlibrary ConfigNames {\r\n    //GOVERNANCE\r\n    bytes32 public constant PROPOSAL_VOTE_DURATION = bytes32('PROPOSAL_VOTE_DURATION');\r\n    bytes32 public constant PROPOSAL_EXECUTE_DURATION = bytes32('PROPOSAL_EXECUTE_DURATION');\r\n    bytes32 public constant PROPOSAL_CREATE_COST = bytes32('PROPOSAL_CREATE_COST');\r\n    bytes32 public constant STAKE_LOCK_TIME = bytes32('STAKE_LOCK_TIME');\r\n    bytes32 public constant MINT_AMOUNT_PER_BLOCK =  bytes32('MINT_AMOUNT_PER_BLOCK');\r\n    bytes32 public constant INTEREST_PLATFORM_SHARE =  bytes32('INTEREST_PLATFORM_SHARE');\r\n    bytes32 public constant CHANGE_PRICE_DURATION =  bytes32('CHANGE_PRICE_DURATION');\r\n    bytes32 public constant CHANGE_PRICE_PERCENT =  bytes32('CHANGE_PRICE_PERCENT');\r\n\r\n    // POOL\r\n    bytes32 public constant POOL_BASE_INTERESTS = bytes32('POOL_BASE_INTERESTS');\r\n    bytes32 public constant POOL_MARKET_FRENZY = bytes32('POOL_MARKET_FRENZY');\r\n    bytes32 public constant POOL_PLEDGE_RATE = bytes32('POOL_PLEDGE_RATE');\r\n    bytes32 public constant POOL_LIQUIDATION_RATE = bytes32('POOL_LIQUIDATION_RATE');\r\n    bytes32 public constant POOL_MINT_BORROW_PERCENT = bytes32('POOL_MINT_BORROW_PERCENT');\r\n    bytes32 public constant POOL_MINT_POWER = bytes32('POOL_MINT_POWER');\r\n    \r\n    //NOT GOVERNANCE\r\n    bytes32 public constant AAAA_USER_MINT = bytes32('AAAA_USER_MINT');\r\n    bytes32 public constant AAAA_TEAM_MINT = bytes32('AAAA_TEAM_MINT');\r\n    bytes32 public constant AAAA_REWAED_MINT = bytes32('AAAA_REWAED_MINT');\r\n    bytes32 public constant DEPOSIT_ENABLE = bytes32('DEPOSIT_ENABLE');\r\n    bytes32 public constant WITHDRAW_ENABLE = bytes32('WITHDRAW_ENABLE');\r\n    bytes32 public constant BORROW_ENABLE = bytes32('BORROW_ENABLE');\r\n    bytes32 public constant REPAY_ENABLE = bytes32('REPAY_ENABLE');\r\n    bytes32 public constant LIQUIDATION_ENABLE = bytes32('LIQUIDATION_ENABLE');\r\n    bytes32 public constant REINVEST_ENABLE = bytes32('REINVEST_ENABLE');\r\n    bytes32 public constant INTEREST_BUYBACK_SHARE =  bytes32('INTEREST_BUYBACK_SHARE');\r\n\r\n    //POOL\r\n    bytes32 public constant POOL_PRICE = bytes32('POOL_PRICE');\r\n\r\n    //wallet\r\n    bytes32 public constant TEAM = bytes32('team'); \r\n    bytes32 public constant SPARE = bytes32('spare');\r\n    bytes32 public constant REWARD = bytes32('reward');\r\n}\r\n\r\n// Dependency file: contracts/modules/BaseMintField.sol\r\n\r\n// pragma solidity >=0.5.16;\r\n// import \"contracts/libraries/SafeMath.sol\";\r\n// import \"contracts/libraries/TransferHelper.sol\";\r\n// import \"contracts/modules/Configable.sol\";\r\n// import \"contracts/modules/ConfigNames.sol\";\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint);\r\n}\r\n\r\ncontract BaseMintField is Configable {\r\n    using SafeMath for uint;\r\n    \r\n    uint public mintCumulation;\r\n    \r\n    uint public totalLendProductivity;\r\n    uint public totalBorrowProducitivity;\r\n    uint public accAmountPerLend;\r\n    uint public accAmountPerBorrow;\r\n    \r\n    uint public totalBorrowSupply;\r\n    uint public totalLendSupply;\r\n    \r\n    struct UserInfo {\r\n        uint amount;     // How many tokens the user has provided.\r\n        uint rewardDebt; // Reward debt. \r\n        uint rewardEarn; // Reward earn and not minted\r\n        uint index;\r\n    }\r\n    \r\n    mapping(address => UserInfo) public lenders;\r\n    mapping(address => UserInfo) public borrowers;\r\n    \r\n    uint public totalShare;\r\n    uint public mintedShare;\r\n\r\n    event BorrowPowerChange (uint oldValue, uint newValue);\r\n    event InterestRatePerBlockChanged (uint oldValue, uint newValue);\r\n    event BorrowerProductivityIncreased (address indexed user, uint value);\r\n    event BorrowerProductivityDecreased (address indexed user, uint value);\r\n    event LenderProductivityIncreased (address indexed user, uint value);\r\n    event LenderProductivityDecreased (address indexed user, uint value);\r\n    event MintLender(address indexed user, uint userAmount);\r\n    event MintBorrower(address indexed user, uint userAmount);\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function _update() internal virtual {\r\n        uint256 reward = _currentReward();\r\n        totalShare += reward;\r\n        if (totalLendProductivity.add(totalBorrowProducitivity) == 0 || reward == 0) {\r\n            return;\r\n        }\r\n        \r\n        uint borrowReward = reward.mul(IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MINT_BORROW_PERCENT)).div(10000);\r\n        uint lendReward = reward.sub(borrowReward);\r\n     \r\n        if(totalLendProductivity != 0 && lendReward > 0) {\r\n            totalLendSupply = totalLendSupply.add(lendReward);\r\n            accAmountPerLend = accAmountPerLend.add(lendReward.mul(1e12).div(totalLendProductivity));\r\n        }\r\n\r\n        if(totalBorrowProducitivity != 0 && borrowReward > 0) {\r\n            totalBorrowSupply = totalBorrowSupply.add(borrowReward);\r\n            accAmountPerBorrow = accAmountPerBorrow.add(borrowReward.mul(1e12).div(totalBorrowProducitivity));\r\n        }\r\n    }\r\n    \r\n    function _currentReward() internal virtual view returns (uint){\r\n        return mintedShare.add(IERC20(IConfig(config).token()).balanceOf(address(this))).sub(totalShare);\r\n    }\r\n    \r\n    // Audit borrowers's reward to be up-to-date\r\n    function _auditBorrower(address user) internal {\r\n        UserInfo storage userInfo = borrowers[user];\r\n        if (userInfo.amount > 0) {\r\n            uint pending = userInfo.amount.mul(accAmountPerBorrow).div(1e12).sub(userInfo.rewardDebt);\r\n            userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\r\n            mintCumulation = mintCumulation.add(pending);\r\n            userInfo.rewardDebt = userInfo.amount.mul(accAmountPerBorrow).div(1e12);\r\n        }\r\n    }\r\n    \r\n    // Audit lender's reward to be up-to-date\r\n    function _auditLender(address user) internal {\r\n        UserInfo storage userInfo = lenders[user];\r\n        if (userInfo.amount > 0) {\r\n            uint pending = userInfo.amount.mul(accAmountPerLend).div(1e12).sub(userInfo.rewardDebt);\r\n            userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\r\n            mintCumulation = mintCumulation.add(pending);\r\n            userInfo.rewardDebt = userInfo.amount.mul(accAmountPerLend).div(1e12);\r\n        }\r\n    }\r\n\r\n    function _increaseBorrowerProductivity(address user, uint value) internal returns (bool) {\r\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\r\n\r\n        UserInfo storage userInfo = borrowers[user];\r\n        _update();\r\n        _auditBorrower(user);\r\n\r\n        totalBorrowProducitivity = totalBorrowProducitivity.add(value);\r\n\r\n        userInfo.amount = userInfo.amount.add(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerBorrow).div(1e12);\r\n        emit BorrowerProductivityIncreased(user, value);\r\n        return true;\r\n    }\r\n\r\n    function _decreaseBorrowerProductivity(address user, uint value) internal returns (bool) {\r\n        require(value > 0, 'INSUFFICIENT_PRODUCTIVITY');\r\n        \r\n        UserInfo storage userInfo = borrowers[user];\r\n        require(userInfo.amount >= value, \"FORBIDDEN\");\r\n        _update();\r\n        _auditBorrower(user);\r\n        \r\n        userInfo.amount = userInfo.amount.sub(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerBorrow).div(1e12);\r\n        totalBorrowProducitivity = totalBorrowProducitivity.sub(value);\r\n\r\n        emit BorrowerProductivityDecreased(user, value);\r\n        return true;\r\n    }\r\n    \r\n    function _increaseLenderProductivity(address user, uint value) internal returns (bool) {\r\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\r\n\r\n        UserInfo storage userInfo = lenders[user];\r\n        _update();\r\n        _auditLender(user);\r\n\r\n        totalLendProductivity = totalLendProductivity.add(value);\r\n\r\n        userInfo.amount = userInfo.amount.add(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerLend).div(1e12);\r\n        emit LenderProductivityIncreased(user, value);\r\n        return true;\r\n    }\r\n\r\n    // External function call \r\n    // This function will decreases user's productivity by value, and updates the global productivity\r\n    // it will record which block this is happenning and accumulates the area of (productivity * time)\r\n    function _decreaseLenderProductivity(address user, uint value) internal returns (bool) {\r\n        require(value > 0, 'INSUFFICIENT_PRODUCTIVITY');\r\n        \r\n        UserInfo storage userInfo = lenders[user];\r\n        require(userInfo.amount >= value, \"FORBIDDEN\");\r\n        _update();\r\n        _auditLender(user);\r\n        \r\n        userInfo.amount = userInfo.amount.sub(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerLend).div(1e12);\r\n        totalLendProductivity = totalLendProductivity.sub(value);\r\n\r\n        emit LenderProductivityDecreased(user, value);\r\n        return true;\r\n    }\r\n    \r\n    function takeBorrowWithAddress(address user) public view returns (uint) {\r\n        UserInfo storage userInfo = borrowers[user];\r\n        uint _accAmountPerBorrow = accAmountPerBorrow;\r\n        if (totalBorrowProducitivity != 0) {\r\n            uint reward = _currentReward();\r\n            uint borrowReward = reward.mul(IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MINT_BORROW_PERCENT)).div(10000);\r\n            \r\n            _accAmountPerBorrow = accAmountPerBorrow.add(borrowReward.mul(1e12).div(totalBorrowProducitivity));\r\n        }\r\n\r\n        return userInfo.amount.mul(_accAmountPerBorrow).div(1e12).sub(userInfo.rewardDebt).add(userInfo.rewardEarn);\r\n    }\r\n    \r\n    function takeLendWithAddress(address user) public view returns (uint) {\r\n        UserInfo storage userInfo = lenders[user];\r\n        uint _accAmountPerLend = accAmountPerLend;\r\n        if (totalLendProductivity != 0) {\r\n            uint reward = _currentReward();\r\n            uint lendReward = reward.sub(reward.mul(IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MINT_BORROW_PERCENT)).div(10000)); \r\n            _accAmountPerLend = accAmountPerLend.add(lendReward.mul(1e12).div(totalLendProductivity));\r\n        }\r\n        return userInfo.amount.mul(_accAmountPerLend).div(1e12).sub(userInfo.rewardDebt).add(userInfo.rewardEarn);\r\n    }\r\n\r\n    function takeBorrowWithBlock() external view returns (uint, uint) {\r\n        uint earn = takeBorrowWithAddress(msg.sender);\r\n        return (earn, block.number);\r\n    }\r\n    \r\n    function takeLendWithBlock() external view returns (uint, uint) {\r\n        uint earn = takeLendWithAddress(msg.sender);\r\n        return (earn, block.number);\r\n    }\r\n\r\n    function takeAll() public view returns (uint) {\r\n        return takeBorrowWithAddress(msg.sender).add(takeLendWithAddress(msg.sender));\r\n    }\r\n\r\n    function takeAllWithBlock() external view returns (uint, uint) {\r\n        return (takeAll(), block.number);\r\n    }\r\n\r\n    function _mintBorrower() internal returns (uint) {\r\n        _update();\r\n        _auditBorrower(msg.sender); \r\n        if(borrowers[msg.sender].rewardEarn > 0) {\r\n            uint amount = borrowers[msg.sender].rewardEarn;\r\n            _mintDistribution(msg.sender, amount);\r\n            borrowers[msg.sender].rewardEarn = 0;\r\n            emit MintBorrower(msg.sender, amount);\r\n            return amount;\r\n        }\r\n    }\r\n    \r\n    function _mintLender() internal returns (uint) {\r\n        _update();\r\n        _auditLender(msg.sender);\r\n        if(lenders[msg.sender].rewardEarn > 0) {\r\n            uint amount = lenders[msg.sender].rewardEarn;\r\n            _mintDistribution(msg.sender, amount);\r\n            lenders[msg.sender].rewardEarn = 0;\r\n            emit MintLender(msg.sender, amount);\r\n            return amount;\r\n        }\r\n    }\r\n\r\n    // Returns how many productivity a user has and global has.\r\n    function getBorrowerProductivity(address user) external view returns (uint, uint) {\r\n        return (borrowers[user].amount, totalBorrowProducitivity);\r\n    }\r\n    \r\n    function getLenderProductivity(address user) external view returns (uint, uint) {\r\n        return (lenders[user].amount, totalLendProductivity);\r\n    }\r\n\r\n    // Returns the current gorss product rate.\r\n    function interestsPerBlock() external view returns (uint, uint) {\r\n        return (accAmountPerBorrow, accAmountPerLend);\r\n    }\r\n\r\n    function _mintDistribution(address user, uint amount) internal {\r\n        if(amount > 0) {\r\n           mintedShare += amount;\r\n           TransferHelper.safeTransfer(IConfig(config).token(), user, amount);\r\n        }\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/AAAA.sol\r\n\r\n// pragma solidity >=0.5.16;\r\n// import \"contracts/libraries/TransferHelper.sol\";\r\n// import \"contracts/libraries/SafeMath.sol\";\r\n// import \"contracts/modules/Configable.sol\";\r\n// import \"contracts/modules/ConfigNames.sol\";\r\n// import \"contracts/modules/BaseMintField.sol\";\r\n\r\ninterface ICollateralStrategy {\r\n    function invest(address user, uint amount) external; \r\n    function withdraw(address user, uint amount) external;\r\n    function liquidation(address user) external;\r\n    function claim(address user, uint amount, uint total) external;\r\n    function exit(uint amount) external;\r\n    function migrate(address old) external;\r\n    function collateralToken() external returns (address);\r\n}\r\n\r\ninterface IAAAAMint {\r\n    function take() external view returns (uint);\r\n    function mint() external returns (uint);\r\n}\r\n\r\ncontract AAAAPool is Configable, BaseMintField\r\n{\r\n    using SafeMath for uint;\r\n\r\n    address public factory;\r\n    address public supplyToken;\r\n    uint public supplyDecimal;\r\n    address public collateralToken;\r\n    uint public collateralDecimal;\r\n\r\n    struct SupplyStruct {\r\n        uint amountSupply;\r\n        uint interestSettled;\r\n        uint liquidationSettled;\r\n\r\n        uint interests;\r\n        uint liquidation;\r\n    }\r\n\r\n    struct BorrowStruct {\r\n        uint index;\r\n        uint amountCollateral;\r\n        uint interestSettled;\r\n        uint amountBorrow;\r\n        uint interests;\r\n    }\r\n\r\n    struct LiquidationStruct {\r\n        uint amountCollateral;\r\n        uint liquidationAmount;\r\n        uint timestamp;\r\n    }\r\n\r\n    address[] public borrowerList;\r\n    uint public numberBorrowers;\r\n\r\n    mapping(address => SupplyStruct) public supplys;\r\n    mapping(address => BorrowStruct) public borrows;\r\n    mapping(address => LiquidationStruct []) public liquidationHistory;\r\n    mapping(address => uint) public liquidationHistoryLength;\r\n\r\n    uint public interestPerSupply;\r\n    uint public liquidationPerSupply;\r\n    uint public interestPerBorrow;\r\n\r\n    uint public totalLiquidation;\r\n    uint public totalLiquidationSupplyAmount;\r\n\r\n    uint public totalStake;\r\n    uint public totalBorrow;\r\n    uint public totalPledge;\r\n\r\n    uint public remainSupply;\r\n\r\n    uint public lastInterestUpdate;\r\n\r\n    address public collateralStrategy;\r\n    address[] public strategyList;\r\n    uint strategyCount;\r\n\r\n    event Deposit(address indexed _user, uint _amount, uint _collateralAmount);\r\n    event Withdraw(address indexed _user, uint _supplyAmount, uint _collateralAmount, uint _interestAmount);\r\n    event Borrow(address indexed _user, uint _supplyAmount, uint _collateralAmount);\r\n    event Repay(address indexed _user, uint _supplyAmount, uint _collateralAmount, uint _interestAmount);\r\n    event Liquidation(address indexed _liquidator, address indexed _user, uint _supplyAmount, uint _collateralAmount);\r\n    event Reinvest(address indexed _user, uint _reinvestAmount);\r\n\r\n    function switchStrategy(address _collateralStrategy) external onlyPlatform\r\n    {\r\n\r\n        if(collateralStrategy != address(0) && totalPledge > 0)\r\n        {\r\n            ICollateralStrategy(collateralStrategy).exit(totalPledge);\r\n        }\r\n\r\n        if(_collateralStrategy != address(0))\r\n        {\r\n            require(ICollateralStrategy(_collateralStrategy).collateralToken() == collateralToken && collateralStrategy != _collateralStrategy, \"AAAA: INVALID STRATEGY\");\r\n\r\n            strategyCount++;\r\n            strategyList.push(_collateralStrategy);\r\n\r\n            if(totalPledge > 0) {\r\n                TransferHelper.safeTransfer(collateralToken, _collateralStrategy, totalPledge);\r\n            }\r\n            ICollateralStrategy(_collateralStrategy).migrate(collateralStrategy);\r\n        }\r\n\r\n        collateralStrategy = _collateralStrategy;\r\n    }\r\n\r\n    constructor() public \r\n    {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function init(address _supplyToken, address _collateralToken) external onlyFactory\r\n    {\r\n        supplyToken = _supplyToken;\r\n        collateralToken = _collateralToken;\r\n\r\n        lastInterestUpdate = block.number;\r\n    }\r\n\r\n    function updateInterests() internal\r\n    {\r\n        uint totalSupply = totalBorrow + remainSupply;\r\n        uint interestPerBlock = getInterests();\r\n\r\n        interestPerSupply = interestPerSupply.add(totalSupply == 0 ? 0 : interestPerBlock.mul(block.number - lastInterestUpdate).mul(totalBorrow).div(totalSupply));\r\n        interestPerBorrow = interestPerBorrow.add(interestPerBlock.mul(block.number - lastInterestUpdate));\r\n        lastInterestUpdate = block.number;\r\n    }\r\n\r\n    function getInterests() public view returns(uint interestPerBlock)\r\n    {\r\n        uint totalSupply = totalBorrow + remainSupply;\r\n        uint baseInterests = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_BASE_INTERESTS);\r\n        uint marketFrenzy = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MARKET_FRENZY);\r\n        uint aDay = IConfig(config).DAY();\r\n        interestPerBlock = totalSupply == 0 ? 0 : baseInterests.add(totalBorrow.mul(marketFrenzy).div(totalSupply)).div(365 * aDay);\r\n    }\r\n\r\n    function updateLiquidation(uint _liquidation) internal\r\n    {\r\n        uint totalSupply = totalBorrow + remainSupply;\r\n        liquidationPerSupply = liquidationPerSupply.add(totalSupply == 0 ? 0 : _liquidation.mul(1e18).div(totalSupply));\r\n    }\r\n\r\n    function deposit(uint amountDeposit, address from) public onlyPlatform\r\n    {\r\n        require(amountDeposit > 0, \"AAAA: INVALID AMOUNT\");\r\n        uint amountIn = IERC20(supplyToken).balanceOf(address(this)).sub(remainSupply);\r\n        require(amountIn >= amountDeposit, \"AAAA: INVALID AMOUNT\");\r\n\r\n        updateInterests();\r\n\r\n        uint addLiquidation = liquidationPerSupply.mul(supplys[from].amountSupply).div(1e18).sub(supplys[from].liquidationSettled);\r\n\r\n        supplys[from].interests = supplys[from].interests.add(interestPerSupply.mul(supplys[from].amountSupply).div(1e18).sub(supplys[from].interestSettled));\r\n        supplys[from].liquidation = supplys[from].liquidation.add(addLiquidation);\r\n\r\n        supplys[from].amountSupply = supplys[from].amountSupply.add(amountDeposit);\r\n        remainSupply = remainSupply.add(amountDeposit);\r\n        \r\n        totalStake = totalStake.add(amountDeposit);\r\n        _mintToPool();\r\n        _increaseLenderProductivity(from, amountDeposit);\r\n\r\n        supplys[from].interestSettled = interestPerSupply.mul(supplys[from].amountSupply).div(1e18);\r\n        supplys[from].liquidationSettled = liquidationPerSupply.mul(supplys[from].amountSupply).div(1e18);\r\n        emit Deposit(from, amountDeposit, addLiquidation);\r\n    }\r\n\r\n    function reinvest(address from) public onlyPlatform returns(uint reinvestAmount)\r\n    {\r\n        updateInterests();\r\n\r\n        uint addLiquidation = liquidationPerSupply.mul(supplys[from].amountSupply).div(1e18).sub(supplys[from].liquidationSettled);\r\n\r\n        supplys[from].interests = supplys[from].interests.add(interestPerSupply.mul(supplys[from].amountSupply).div(1e18).sub(supplys[from].interestSettled));\r\n        supplys[from].liquidation = supplys[from].liquidation.add(addLiquidation);\r\n\r\n        reinvestAmount = supplys[from].interests;\r\n\r\n        uint platformShare = reinvestAmount.mul(IConfig(config).getValue(ConfigNames.INTEREST_PLATFORM_SHARE)).div(1e18);\r\n        reinvestAmount = reinvestAmount.sub(platformShare);\r\n\r\n        supplys[from].amountSupply = supplys[from].amountSupply.add(reinvestAmount);\r\n        totalStake = totalStake.add(reinvestAmount);\r\n        supplys[from].interests = 0;\r\n\r\n        supplys[from].interestSettled = supplys[from].amountSupply == 0 ? 0 : interestPerSupply.mul(supplys[from].amountSupply).div(1e18);\r\n        supplys[from].liquidationSettled = supplys[from].amountSupply == 0 ? 0 : liquidationPerSupply.mul(supplys[from].amountSupply).div(1e18);\r\n\r\n        distributePlatformShare(platformShare);\r\n        _mintToPool();\r\n        if(reinvestAmount > 0) {\r\n           _increaseLenderProductivity(from, reinvestAmount); \r\n        }\r\n\r\n        emit Reinvest(from, reinvestAmount);\r\n    }\r\n\r\n    function distributePlatformShare(uint platformShare) internal \r\n    {\r\n        require(platformShare <= remainSupply, \"AAAA: NOT ENOUGH PLATFORM SHARE\");\r\n        if(platformShare > 0) {\r\n            uint buybackShare = IConfig(config).getValue(ConfigNames.INTEREST_BUYBACK_SHARE);\r\n            uint buybackAmount = platformShare.mul(buybackShare).div(1e18);\r\n            uint dividendAmount = platformShare.sub(buybackAmount);\r\n            if(dividendAmount > 0) TransferHelper.safeTransfer(supplyToken, IConfig(config).share(), dividendAmount);\r\n            if(buybackAmount > 0) TransferHelper.safeTransfer(supplyToken, IConfig(config).wallets(bytes32(\"team\")), buybackAmount);\r\n            remainSupply = remainSupply.sub(platformShare);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint amountWithdraw, address from) public onlyPlatform returns(uint withdrawSupplyAmount, uint withdrawLiquidation)\r\n    {\r\n        require(amountWithdraw > 0, \"AAAA: INVALID AMOUNT\");\r\n        require(amountWithdraw <= supplys[from].amountSupply, \"AAAA: NOT ENOUGH BALANCE\");\r\n\r\n        updateInterests();\r\n\r\n        uint addLiquidation = liquidationPerSupply.mul(supplys[from].amountSupply).div(1e18).sub(supplys[from].liquidationSettled);\r\n\r\n        supplys[from].interests = supplys[from].interests.add(interestPerSupply.mul(supplys[from].amountSupply).div(1e18).sub(supplys[from].interestSettled));\r\n        supplys[from].liquidation = supplys[from].liquidation.add(addLiquidation);\r\n\r\n        withdrawLiquidation = supplys[from].liquidation.mul(amountWithdraw).div(supplys[from].amountSupply);\r\n        uint withdrawInterest = supplys[from].interests.mul(amountWithdraw).div(supplys[from].amountSupply);\r\n\r\n        uint platformShare = withdrawInterest.mul(IConfig(config).getValue(ConfigNames.INTEREST_PLATFORM_SHARE)).div(1e18);\r\n        uint userShare = withdrawInterest.sub(platformShare);\r\n\r\n        distributePlatformShare(platformShare);\r\n\r\n        uint withdrawLiquidationSupplyAmount = totalLiquidation == 0 ? 0 : withdrawLiquidation.mul(totalLiquidationSupplyAmount).div(totalLiquidation);\r\n        \r\n        if(withdrawLiquidationSupplyAmount < amountWithdraw.add(userShare))\r\n            withdrawSupplyAmount = amountWithdraw.add(userShare).sub(withdrawLiquidationSupplyAmount);\r\n        \r\n        require(withdrawSupplyAmount <= remainSupply, \"AAAA: NOT ENOUGH POOL BALANCE\");\r\n        require(withdrawLiquidation <= totalLiquidation, \"AAAA: NOT ENOUGH LIQUIDATION\");\r\n\r\n        remainSupply = remainSupply.sub(withdrawSupplyAmount);\r\n        totalLiquidation = totalLiquidation.sub(withdrawLiquidation);\r\n        totalLiquidationSupplyAmount = totalLiquidationSupplyAmount.sub(withdrawLiquidationSupplyAmount);\r\n        totalPledge = totalPledge.sub(withdrawLiquidation);\r\n\r\n        supplys[from].interests = supplys[from].interests.sub(withdrawInterest);\r\n        supplys[from].liquidation = supplys[from].liquidation.sub(withdrawLiquidation);\r\n        supplys[from].amountSupply = supplys[from].amountSupply.sub(amountWithdraw);\r\n        totalStake = totalStake.sub(amountWithdraw);\r\n\r\n        supplys[from].interestSettled = supplys[from].amountSupply == 0 ? 0 : interestPerSupply.mul(supplys[from].amountSupply).div(1e18);\r\n        supplys[from].liquidationSettled = supplys[from].amountSupply == 0 ? 0 : liquidationPerSupply.mul(supplys[from].amountSupply).div(1e18);\r\n\r\n        _mintToPool();\r\n        if(withdrawSupplyAmount > 0) {\r\n            TransferHelper.safeTransfer(supplyToken, msg.sender, withdrawSupplyAmount);\r\n        } \r\n\r\n        _decreaseLenderProductivity(from, amountWithdraw); \r\n\r\n        if(withdrawLiquidation > 0) {\r\n            if(collateralStrategy != address(0))\r\n            {\r\n                ICollateralStrategy(collateralStrategy).claim(from, withdrawLiquidation, totalLiquidation.add(withdrawLiquidation));   \r\n            }\r\n            TransferHelper.safeTransfer(collateralToken, msg.sender, withdrawLiquidation);\r\n        }\r\n        \r\n        emit Withdraw(from, withdrawSupplyAmount, withdrawLiquidation, withdrawInterest);\r\n    }\r\n\r\n    function borrow(uint amountCollateral, uint repayAmount, uint expectBorrow, address from) public onlyPlatform\r\n    {\r\n        uint amountIn = IERC20(collateralToken).balanceOf(address(this));\r\n        if(collateralStrategy == address(0))\r\n            amountIn = amountIn.sub(totalPledge);\r\n            \r\n        require(amountIn == amountCollateral, \"AAAA: INVALID AMOUNT\");\r\n\r\n        // if(amountCollateral > 0) TransferHelper.safeTransferFrom(collateralToken, from, address(this), amountCollateral);\r\n\r\n        updateInterests();\r\n        \r\n        uint pledgeRate = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_PLEDGE_RATE);\r\n        uint maxAmount = IConfig(config).convertTokenAmount(collateralToken, supplyToken, borrows[from].amountCollateral.add(amountCollateral));\r\n\r\n        uint maximumBorrow = maxAmount.mul(pledgeRate).div(1e18);\r\n        // uint repayAmount = getRepayAmount(borrows[from].amountCollateral, from);\r\n\r\n        require(repayAmount + expectBorrow <= maximumBorrow, \"AAAA: EXCEED MAX ALLOWED\");\r\n        require(expectBorrow <= remainSupply, \"AAAA: INVALID BORROW\");\r\n\r\n        totalBorrow = totalBorrow.add(expectBorrow);\r\n        totalPledge = totalPledge.add(amountCollateral);\r\n        remainSupply = remainSupply.sub(expectBorrow);\r\n\r\n        if(collateralStrategy != address(0) && amountCollateral > 0)\r\n        {\r\n            IERC20(ICollateralStrategy(collateralStrategy).collateralToken()).approve(collateralStrategy, amountCollateral);\r\n            ICollateralStrategy(collateralStrategy).invest(from, amountCollateral); \r\n        }\r\n\r\n        if(borrows[from].index == 0)\r\n        {\r\n            borrowerList.push(from);\r\n            borrows[from].index = borrowerList.length;\r\n            numberBorrowers ++;\r\n        }\r\n\r\n        borrows[from].interests = borrows[from].interests.add(interestPerBorrow.mul(borrows[from].amountBorrow).div(1e18).sub(borrows[from].interestSettled));\r\n        borrows[from].amountCollateral = borrows[from].amountCollateral.add(amountCollateral);\r\n        borrows[from].amountBorrow = borrows[from].amountBorrow.add(expectBorrow);\r\n        borrows[from].interestSettled = interestPerBorrow.mul(borrows[from].amountBorrow).div(1e18);\r\n\r\n        _mintToPool();\r\n        if(expectBorrow > 0) {\r\n            TransferHelper.safeTransfer(supplyToken, msg.sender, expectBorrow);\r\n            _increaseBorrowerProductivity(from, expectBorrow);\r\n        } \r\n        \r\n        emit Borrow(from, expectBorrow, amountCollateral);\r\n    }\r\n\r\n    function repay(uint amountCollateral, address from) public onlyPlatform returns(uint repayAmount, uint repayInterest)\r\n    {\r\n        require(amountCollateral <= borrows[from].amountCollateral, \"AAAA: NOT ENOUGH COLLATERAL\");\r\n        require(amountCollateral > 0, \"AAAA: INVALID AMOUNT\");\r\n\r\n        uint amountIn = IERC20(supplyToken).balanceOf(address(this)).sub(remainSupply);\r\n\r\n        updateInterests();\r\n\r\n        borrows[from].interests = borrows[from].interests.add(interestPerBorrow.mul(borrows[from].amountBorrow).div(1e18).sub(borrows[from].interestSettled));\r\n\r\n        repayAmount = borrows[from].amountBorrow.mul(amountCollateral).div(borrows[from].amountCollateral);\r\n        repayInterest = borrows[from].interests.mul(amountCollateral).div(borrows[from].amountCollateral);\r\n\r\n        totalPledge = totalPledge.sub(amountCollateral);\r\n        totalBorrow = totalBorrow.sub(repayAmount);\r\n        \r\n        borrows[from].amountCollateral = borrows[from].amountCollateral.sub(amountCollateral);\r\n        borrows[from].amountBorrow = borrows[from].amountBorrow.sub(repayAmount);\r\n        borrows[from].interests = borrows[from].interests.sub(repayInterest);\r\n        borrows[from].interestSettled = borrows[from].amountBorrow == 0 ? 0 : interestPerBorrow.mul(borrows[from].amountBorrow).div(1e18);\r\n\r\n        remainSupply = remainSupply.add(repayAmount.add(repayInterest));\r\n\r\n        if(collateralStrategy != address(0))\r\n        {\r\n            ICollateralStrategy(collateralStrategy).withdraw(from, amountCollateral);\r\n        }\r\n        TransferHelper.safeTransfer(collateralToken, msg.sender, amountCollateral);\r\n        require(amountIn >= repayAmount.add(repayInterest), \"AAAA: INVALID AMOUNT\");\r\n        // TransferHelper.safeTransferFrom(supplyToken, from, address(this), repayAmount.add(repayInterest));\r\n        \r\n        _mintToPool();\r\n        if(repayAmount > 0) {\r\n            _decreaseBorrowerProductivity(from, repayAmount);\r\n        }\r\n\r\n        emit Repay(from, repayAmount, amountCollateral, repayInterest);\r\n    }\r\n\r\n    function liquidation(address _user, address from) public onlyPlatform returns(uint borrowAmount)\r\n    {\r\n        require(supplys[from].amountSupply > 0, \"AAAA: ONLY SUPPLIER\");\r\n\r\n        updateInterests();\r\n\r\n        borrows[_user].interests = borrows[_user].interests.add(interestPerBorrow.mul(borrows[_user].amountBorrow).div(1e18).sub(borrows[_user].interestSettled));\r\n\r\n        uint liquidationRate = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_LIQUIDATION_RATE);\r\n        \r\n        // uint pledgePrice = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_PRICE);\r\n        // uint collateralValue = borrows[_user].amountCollateral.mul(pledgePrice).div(1e18);\r\n        uint collateralValue = IConfig(config).convertTokenAmount(collateralToken, supplyToken, borrows[_user].amountCollateral);\r\n        \r\n        uint expectedRepay = borrows[_user].amountBorrow.add(borrows[_user].interests);\r\n\r\n        require(expectedRepay >= collateralValue.mul(liquidationRate).div(1e18), 'AAAA: NOT LIQUIDABLE');\r\n\r\n        updateLiquidation(borrows[_user].amountCollateral);\r\n\r\n        totalLiquidation = totalLiquidation.add(borrows[_user].amountCollateral);\r\n        totalLiquidationSupplyAmount = totalLiquidationSupplyAmount.add(expectedRepay);\r\n        totalBorrow = totalBorrow.sub(borrows[_user].amountBorrow);\r\n\r\n        borrowAmount = borrows[_user].amountBorrow;\r\n\r\n        LiquidationStruct memory liq;\r\n        liq.amountCollateral = borrows[_user].amountCollateral;\r\n        liq.liquidationAmount = expectedRepay;\r\n        liq.timestamp = block.timestamp;\r\n        \r\n        liquidationHistory[_user].push(liq);\r\n        liquidationHistoryLength[_user] ++;\r\n        ICollateralStrategy(collateralStrategy).liquidation(_user);\r\n        \r\n        emit Liquidation(from, _user, borrows[_user].amountBorrow, borrows[_user].amountCollateral);\r\n\r\n        borrows[_user].amountCollateral = 0;\r\n        borrows[_user].amountBorrow = 0;\r\n        borrows[_user].interests = 0;\r\n        borrows[_user].interestSettled = 0;\r\n        \r\n        _mintToPool();\r\n        if(borrowAmount > 0) {\r\n            _decreaseBorrowerProductivity(_user, borrowAmount);\r\n        }\r\n    }\r\n\r\n    function getTotalAmount() external view returns (uint) {\r\n        return totalStake.add(totalBorrow);\r\n    }\r\n\r\n    function _mintToPool() internal {\r\n        if(IAAAAMint(IConfig(config).mint()).take() > 0) {\r\n            IAAAAMint(IConfig(config).mint()).mint();\r\n        }\r\n    }\r\n\r\n    function mint() external {\r\n        _mintToPool();\r\n        _mintLender();\r\n        _mintBorrower();\r\n    }\r\n\r\n    function _currentReward() internal override view returns (uint) {\r\n        uint remain = IAAAAMint(IConfig(config).mint()).take();\r\n        return remain.add(mintedShare).add(IERC20(IConfig(config).token()).balanceOf(address(this))).sub(totalShare);\r\n    }\r\n}\r\n\r\n// Root file: contracts/AAAAFactory.sol\r\n\r\npragma solidity >=0.5.16;\r\n\r\n// import \"contracts/AAAA.sol\";\r\n// import \"contracts/modules/Configable.sol\";\r\n\r\ninterface IAAAAPool {\r\n    function init(address supplyToken,  address collateralToken) external;\r\n    function setupConfig(address config) external;\r\n}\r\n\r\ninterface IAAAABallot {\r\n    function initialize(address creator, address pool, bytes32 name, uint value, uint reward, string calldata subject, string calldata content) external;\r\n    function setupConfig(address config) external;\r\n}\r\n\r\ncontract AAAAFactory is Configable{\r\n\r\n    event PoolCreated(address indexed lendToken, address indexed collateralToken, address indexed pool);\r\n    event BallotCreated(address indexed creator, address indexed pool, address indexed ballot, bytes32 name, uint value);\r\n\r\n    \r\n    address[] public allPools;\r\n    mapping(address => bool) public isPool;\r\n    mapping (address => mapping (address => address)) public getPool;\r\n    \r\n    address[] public allBallots;\r\n    bytes32 ballotByteCodeHash;\r\n\r\n    function createPool(address _lendToken, address _collateralToken) onlyDeveloper external returns (address pool) {\r\n        require(getPool[_lendToken][_collateralToken] == address(0), \"ALREADY CREATED\");\r\n        \r\n        bytes32 salt = keccak256(abi.encodePacked(_lendToken, _collateralToken));\r\n        bytes memory bytecode = type(AAAAPool).creationCode;\r\n        assembly {\r\n            pool := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        getPool[_lendToken][_collateralToken] = pool;\r\n            \r\n        allPools.push(pool);\r\n        isPool[pool] = true;\r\n        IConfig(config).initPoolParams(pool);\r\n        IAAAAPool(pool).setupConfig(config);\r\n        IAAAAPool(pool).init(_lendToken, _collateralToken);\r\n        \r\n        emit PoolCreated(_lendToken, _collateralToken, pool);\r\n        return pool;\r\n    }\r\n\r\n    function countPools() external view returns(uint) {\r\n        return allPools.length;\r\n    }\r\n    \r\n    function createBallot(\r\n        address _creator, \r\n        address _pool, \r\n        bytes32 _name, \r\n        uint _value, \r\n        uint _reward, \r\n        string calldata _subject, \r\n        string calldata _content, \r\n        bytes calldata _bytecode) onlyGovernor external returns (address ballot) \r\n    {\r\n        bytes32 salt = keccak256(abi.encodePacked(_creator, _value, _subject, block.number));\r\n        bytes memory bytecode = _bytecode;\r\n        require(keccak256(bytecode) == ballotByteCodeHash, \"INVALID BYTECODE.\");\r\n        \r\n        assembly {\r\n            ballot := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        allBallots.push(ballot);\r\n        IAAAABallot(ballot).setupConfig(config);\r\n        IAAAABallot(ballot).initialize(_creator, _pool, _name, _value, _reward, _subject, _content);\r\n        \r\n        emit BallotCreated(_creator, _pool, ballot, _name, _value);\r\n        return ballot;\r\n    }\r\n    \r\n    function countBallots() external view returns (uint){\r\n        return allBallots.length;\r\n    }\r\n\r\n    function changeBallotByteHash(bytes32 _hash) onlyDeveloper external {\r\n        ballotByteCodeHash = _hash;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ballot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BallotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lendToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBallots\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"changeBallotByteHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countBallots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_bytecode\",\"type\":\"bytes\"}],\"name\":\"createBallot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ballot\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AAAAFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f068e863cc096b19d55bd14afee82cdb630e23275be24b40db84a635ecf2a90c"}]}