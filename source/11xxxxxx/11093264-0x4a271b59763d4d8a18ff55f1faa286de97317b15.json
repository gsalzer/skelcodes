{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/StakingFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\n\\r\\nimport \\\"../libraries/AppStorage.sol\\\";\\r\\nimport \\\"../libraries/LibDiamond.sol\\\";\\r\\nimport \\\"../libraries/LibERC20.sol\\\";\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155TokenReceiver.sol\\\";\\r\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\r\\n\\r\\ncontract StakingFacet {\\r\\n    AppStorage internal s;\\r\\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81; // Return value from `onERC1155BatchReceived` call if a contract accepts receipt (i.e `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`).\\r\\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\\r\\n\\r\\n    function frens(address _account) public view returns (uint256 frens_) {\\r\\n        Account memory account = s.accounts[_account];\\r\\n        // this cannot underflow or overflow\\r\\n        uint256 timePeriod = block.timestamp - account.lastUpdate;\\r\\n        frens_ = account.frens;\\r\\n        // 86400 the number of seconds in 1 day\\r\\n        // 100 frens are generated for each LP token over 24 hours\\r\\n        frens_ += ((uint256(account.uniV2PoolTokens) * 100) * timePeriod) / 86400;\\r\\n        // 1 fren is generated for each GHST over 24 hours\\r\\n        frens_ += (account.ghst * timePeriod) / 86400;\\r\\n    }\\r\\n\\r\\n    function updateFrens() internal {\\r\\n        Account storage account = s.accounts[msg.sender];\\r\\n        account.frens = uint104(frens(msg.sender));\\r\\n        account.lastUpdate = uint40(block.timestamp);\\r\\n    }\\r\\n\\r\\n    function stakeGhst(uint256 _ghstValue) external {\\r\\n        updateFrens();\\r\\n        s.accounts[msg.sender].ghst += uint96(_ghstValue);\\r\\n        LibERC20.transferFrom(s.ghstContract, msg.sender, address(this), _ghstValue);\\r\\n    }\\r\\n\\r\\n    function stakeUniV2PoolTokens(uint256 _uniV2PoolTokens) external {\\r\\n        updateFrens();\\r\\n        s.accounts[msg.sender].uniV2PoolTokens += uint96(_uniV2PoolTokens);\\r\\n        LibERC20.transferFrom(s.uniV2PoolContract, msg.sender, address(this), _uniV2PoolTokens);\\r\\n    }\\r\\n\\r\\n    function staked(address _account) external view returns (uint256 ghst_, uint256 uniV2PoolTokens_) {\\r\\n        ghst_ = s.accounts[_account].ghst;\\r\\n        uniV2PoolTokens_ = s.accounts[_account].uniV2PoolTokens;\\r\\n    }\\r\\n\\r\\n    function withdrawGhstStake(uint256 _ghstValue) external {\\r\\n        updateFrens();\\r\\n        uint256 bal = s.accounts[msg.sender].ghst;\\r\\n        require(bal >= _ghstValue, \\\"Staking: Can't withdraw more than staked\\\");\\r\\n        s.accounts[msg.sender].ghst = uint96(bal - _ghstValue);\\r\\n        LibERC20.transfer(s.ghstContract, msg.sender, _ghstValue);\\r\\n    }\\r\\n\\r\\n    function withdrawUniV2PoolStake(uint256 _uniV2PoolTokens) external {\\r\\n        updateFrens();\\r\\n        uint256 bal = s.accounts[msg.sender].uniV2PoolTokens;\\r\\n        require(bal >= _uniV2PoolTokens, \\\"Staking: Can't withdraw more than staked\\\");\\r\\n        s.accounts[msg.sender].uniV2PoolTokens = uint96(bal - _uniV2PoolTokens);\\r\\n        LibERC20.transfer(s.uniV2PoolContract, msg.sender, _uniV2PoolTokens);\\r\\n    }\\r\\n\\r\\n    function withdrawGhstStake() external {\\r\\n        updateFrens();\\r\\n        uint256 bal = s.accounts[msg.sender].ghst;\\r\\n        s.accounts[msg.sender].ghst = uint96(0);\\r\\n        LibERC20.transfer(s.ghstContract, msg.sender, bal);\\r\\n    }\\r\\n\\r\\n    function withdrawUniV2PoolStake() external {\\r\\n        updateFrens();\\r\\n        uint256 bal = s.accounts[msg.sender].uniV2PoolTokens;\\r\\n        s.accounts[msg.sender].uniV2PoolTokens = uint96(0);\\r\\n        LibERC20.transfer(s.uniV2PoolContract, msg.sender, bal);\\r\\n    }\\r\\n\\r\\n    function claimTickets(uint256[] calldata _ids, uint256[] calldata _values) external {\\r\\n        require(_ids.length == _values.length, \\\"Staking: _ids not the same length as _values\\\");\\r\\n        updateFrens();\\r\\n        uint256 frensBal = s.accounts[msg.sender].frens;\\r\\n        for (uint256 i; i < _ids.length; i++) {\\r\\n            uint256 id = _ids[i];\\r\\n            uint256 value = _values[i];\\r\\n            require(id < 6, \\\"Staking: Ticket not found\\\");\\r\\n            uint256 cost = ticketCost(id) * value;\\r\\n            require(frensBal >= cost, \\\"Staking: Not enough frens points\\\");\\r\\n            frensBal -= cost;\\r\\n            s.tickets[id].accountBalances[msg.sender] += value;\\r\\n            s.tickets[id].totalSupply += uint96(value);\\r\\n        }\\r\\n        s.accounts[msg.sender].frens = uint104(frensBal);\\r\\n        emit TransferBatch(msg.sender, address(0), msg.sender, _ids, _values);\\r\\n        uint256 size;\\r\\n        address to = msg.sender;\\r\\n        assembly {\\r\\n            size := extcodesize(to)\\r\\n        }\\r\\n        if (size > 0) {\\r\\n            require(\\r\\n                ERC1155_BATCH_ACCEPTED ==\\r\\n                    IERC1155TokenReceiver(msg.sender).onERC1155BatchReceived(msg.sender, address(0), _ids, _values, new bytes(0)),\\r\\n                \\\"Staking: Ticket transfer rejected/failed\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function ticketCost(uint256 _id) public pure returns (uint256 _frensCost) {\\r\\n        if (_id == 0) {\\r\\n            _frensCost = 50e18;\\r\\n        } else if (_id == 1) {\\r\\n            _frensCost = 250e18;\\r\\n        } else if (_id == 2) {\\r\\n            _frensCost = 500e18;\\r\\n        } else if (_id == 3) {\\r\\n            _frensCost = 2_500e18;\\r\\n        } else if (_id == 4) {\\r\\n            _frensCost = 10_000e18;\\r\\n        } else if (_id == 5) {\\r\\n            _frensCost = 50_000e18;\\r\\n        } else {\\r\\n            revert(\\\"Staking: _id does not exist\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\n\\r\\nstruct Account {\\r\\n    uint96 ghst;\\r\\n    uint96 uniV2PoolTokens;\\r\\n    uint40 lastUpdate;\\r\\n    uint104 frens;\\r\\n}\\r\\n\\r\\nstruct Ticket {\\r\\n    // user address => balance\\r\\n    mapping(address => uint256) accountBalances;\\r\\n    uint96 totalSupply;\\r\\n}\\r\\n\\r\\nstruct AppStorage {\\r\\n    mapping(address => mapping(address => bool)) approved;\\r\\n    mapping(address => Account) accounts;\\r\\n    mapping(uint256 => Ticket) tickets;\\r\\n    address ghstContract;\\r\\n    address uniV2PoolContract;\\r\\n    string ticketsBaseUri;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n*\\n* Implementation of Diamond facet.\\n* Uses the diamond-2 version 1.3.4 implementation:\\n* https://github.com/mudgen/diamond-2\\n*\\n* This is gas optimized by reducing storage reads and storage writes.\\n* This code is as complex as it is to reduce gas costs.\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // owner of the contract\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n        _;\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            uint256 selectorSlotCount = _selectorCount / 8;\\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n                selectorInSlotIndex--;\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge\\r\\n*\\r\\n/******************************************************************************/\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\nlibrary LibERC20 {\\r\\n    function transferFrom(\\r\\n        address _token,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    ) internal {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_token)\\r\\n        }\\r\\n        require(size > 0, \\\"LibERC20: Address has no code\\\");\\r\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _value));\\r\\n        handleReturn(success, result);\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address _token,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    ) internal {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_token)\\r\\n        }\\r\\n        require(size > 0, \\\"LibERC20: Address has no code\\\");\\r\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.transfer.selector, _to, _value));\\r\\n        handleReturn(success, result);\\r\\n    }\\r\\n\\r\\n    function handleReturn(bool _success, bytes memory _result) internal pure {\\r\\n        if (_success) {\\r\\n            if (_result.length > 0) {\\r\\n                require(abi.decode(_result, (bool)), \\\"LibERC20: contract call returned false\\\");\\r\\n            }\\r\\n        } else {\\r\\n            if (_result.length > 0) {\\r\\n                // bubble up any reason for revert\\r\\n                revert(string(_result));\\r\\n            } else {\\r\\n                revert(\\\"LibERC20: contract call reverted\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\n\\r\\n/**\\r\\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\\r\\n*/\\r\\ninterface IERC1155TokenReceiver {\\r\\n    /**\\r\\n        @notice Handle the receipt of a single ERC1155 token type.\\r\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.        \\r\\n        This function MUST return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\\r\\n        This function MUST revert if it rejects the transfer.\\r\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\r\\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\\r\\n        @param _from      The address which previously owned the token\\r\\n        @param _id        The ID of the token being transferred\\r\\n        @param _value     The amount of tokens being transferred\\r\\n        @param _data      Additional data with no specified format\\r\\n        @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n    */\\r\\n    function onERC1155Received(\\r\\n        address _operator,\\r\\n        address _from,\\r\\n        uint256 _id,\\r\\n        uint256 _value,\\r\\n        bytes calldata _data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n        @notice Handle the receipt of multiple ERC1155 token types.\\r\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.        \\r\\n        This function MUST return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\\r\\n        This function MUST revert if it rejects the transfer(s).\\r\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\r\\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\\r\\n        @param _from      The address which previously owned the token\\r\\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\\r\\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\\r\\n        @param _data      Additional data with no specified format\\r\\n        @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n    */\\r\\n    function onERC1155BatchReceived(\\r\\n        address _operator,\\r\\n        address _from,\\r\\n        uint256[] calldata _ids,\\r\\n        uint256[] calldata _values,\\r\\n        bytes calldata _data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity 0.7.3;\\r\\n\\r\\n// Taken from https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\r\\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function kLast() external view returns (uint256);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"claimTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"frens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"frens_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ghstValue\",\"type\":\"uint256\"}],\"name\":\"stakeGhst\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uniV2PoolTokens\",\"type\":\"uint256\"}],\"name\":\"stakeUniV2PoolTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ghst_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniV2PoolTokens_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"ticketCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_frensCost\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawGhstStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ghstValue\",\"type\":\"uint256\"}],\"name\":\"withdrawGhstStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUniV2PoolStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uniV2PoolTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawUniV2PoolStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingFacet","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}