{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.2;\r\n\r\n/***************\r\n**            **\r\n** INTERFACES **\r\n**            **\r\n***************/\r\n\r\n/**\r\n * @title Interface for EllipticCurve contract.\r\n */\r\ninterface EllipticCurveInterface {\r\n\r\n    function validateSignature(bytes32 message, uint[2] calldata rs, uint[2] calldata Q) external view returns (bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for Register contract.\r\n */\r\ninterface RegisterInterface {\r\n\r\n  function getKongAmount(bytes32 primaryPublicKeyHash) external view returns (uint);\r\n  function getTertiaryKeyHash(bytes32 primaryPublicKeyHash) external view returns (bytes32);\r\n  function mintKong(bytes32 primaryPublicKeyHash, address recipient) external;\r\n\r\n}\r\n\r\n/*********************************\r\n**                              **\r\n** ENTROPY DIRECT MINT CONTRACT **\r\n**                              **\r\n*********************************/\r\n\r\n/**\r\n * @title Kong Entropy Contract.\r\n *\r\n * @dev   This contract can be presented with signatures for public keys registered in the\r\n *        `Register` contract. The function `submitEntropy()` verifies the validity of the\r\n *        signature using the remotely deployed `EllipticCurve` contract. If the signature\r\n *        is valid, the contract calls the `mintKong()` function of the `Register` contract\r\n *        to mint Kong.\r\n */\r\ncontract KongEntropyDirectMint {\r\n\r\n    // Addresses of the contracts `Register` and `EllipticCurve`.\r\n    address public _regAddress;\r\n    address public _eccAddress;\r\n\r\n    // Array storing hashes of signatures successfully submitted to submitEntropy() function.\r\n    bytes32[] public _hashedSignaturesArray;\r\n\r\n    // Length of _hashedSignaturesArray.\r\n    uint256 public _hashedSignaturesIndex;\r\n\r\n    // Mapping for minting status of keys.\r\n    mapping(bytes32 => bool) public _mintedKeys;\r\n\r\n    // Emits when submitEntropy() is successfully called.\r\n    event Minted(\r\n        bytes32 primaryPublicKeyHash,\r\n        bytes32 message,\r\n        uint256 r,\r\n        uint256 s\r\n    );\r\n\r\n    /**\r\n     * @dev The constructor sets the addresses of the contracts `Register` and `EllipticCurve`.\r\n     *\r\n     * @param eccAddress           The address of the EllipticCurve contract.\r\n     * @param regAddress           The address of the Register contract.\r\n     */\r\n    constructor(address eccAddress, address regAddress) public {\r\n\r\n        _eccAddress = eccAddress;\r\n        _regAddress = regAddress;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev `submitEntropy()` can be presented with SECP256R1 signatures of public keys registered\r\n     *      in the `Register` contract. When presented with a valid signature in the expected format,\r\n     *      the contract calls the `mintKong()` function of `Register` to mint Kong token to `to`.\r\n\r\n     *\r\n     * @param primaryPublicKeyHash  Hash of the primary public key.\r\n     * @param tertiaryPublicKeyX    The x-coordinate of the tertiary public key.\r\n     * @param tertiaryPublicKeyY    The y-coordinate of the tertiary public key.\r\n     * @param to                    Recipient.\r\n     * @param blockNumber           Block number of the signed blockhash.\r\n     * @param rs                    The array containing the r & s values fo the signature.\r\n     */\r\n    function submitEntropy(\r\n        bytes32 primaryPublicKeyHash,\r\n        uint256 tertiaryPublicKeyX,\r\n        uint256 tertiaryPublicKeyY,\r\n        address to,\r\n        uint256 blockNumber,\r\n        uint256[2] memory rs\r\n    )\r\n        public\r\n    {\r\n\r\n        // Verify that the primary key hash is registered and associated with a non-zero tertiary key hash.\r\n        bytes32 tertiaryPublicKeyHash = RegisterInterface(_regAddress).getTertiaryKeyHash(primaryPublicKeyHash);\r\n        require(tertiaryPublicKeyHash != 0, 'Found no registration.');\r\n\r\n        // Verify that the hash of the provided tertiary key coincides with the stored hash of the tertiary key.\r\n        bytes32 hashedKey = sha256(abi.encodePacked(tertiaryPublicKeyX, tertiaryPublicKeyY));\r\n        require(tertiaryPublicKeyHash == hashedKey, 'Provided key does not hash to expected value.');\r\n\r\n        // Verify that no signature has been submitted before for this key.\r\n        require(_mintedKeys[primaryPublicKeyHash] == false, 'Has already been minted.');\r\n\r\n        // Get Kong amount; Divide internal representation by 10 ** 17 for cost scaling.\r\n        uint scaledKongAmount = RegisterInterface(_regAddress).getKongAmount(primaryPublicKeyHash) / uint(10 ** 17);\r\n\r\n        // Perform work in proportion to scaledKongAmount.\r\n        bytes32 powHash = blockhash(block.number);\r\n        for (uint i=0; i < scaledKongAmount; i++) {\r\n            powHash = keccak256(abi.encodePacked(powHash));\r\n        }\r\n\r\n        // Validate signature.\r\n        bytes32 messageHash = sha256(abi.encodePacked(to, blockhash(blockNumber)));\r\n        require(_validateSignature(messageHash, rs, tertiaryPublicKeyX, tertiaryPublicKeyY), 'Invalid signature.');\r\n\r\n        // Create a hash of the provided signature.\r\n        bytes32 sigHash = sha256(abi.encodePacked(rs[0], rs[1]));\r\n\r\n        // Store hashed signature and update index / length of array.\r\n        _hashedSignaturesIndex = _hashedSignaturesArray.push(sigHash);\r\n\r\n        // Update mapping with minted keys.\r\n        _mintedKeys[primaryPublicKeyHash] = true;\r\n\r\n        // Call minting function in Register contract.\r\n        RegisterInterface(_regAddress).mintKong(primaryPublicKeyHash, to);\r\n\r\n        // Emit event.\r\n        emit Minted(primaryPublicKeyHash, messageHash, rs[0], rs[1]);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to validate SECP256R1 signatures.\r\n     *\r\n     * @param message           The hash of the signed message.\r\n     * @param rs                R+S value of the signature.\r\n     * @param publicKeyX        X-coordinate of the publicKey.\r\n     * @param publicKeyY        Y-coordinate of the publicKey.\r\n     */\r\n    function _validateSignature(\r\n        bytes32 message,\r\n        uint256[2] memory rs,\r\n        uint256 publicKeyX,\r\n        uint256 publicKeyY\r\n    )\r\n        internal view returns (bool)\r\n    {\r\n        return EllipticCurveInterface(_eccAddress).validateSignature(message, rs, [publicKeyX, publicKeyY]);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to return the submitted signatures at location `index` in the array of\r\n     *      signatures.\r\n     *\r\n     * @param index             Location of signature in array of hashed signatures.\r\n     */\r\n    function getHashedSignature(\r\n        uint256 index\r\n    )\r\n        public view returns(bytes32)\r\n    {\r\n        require(index <= _hashedSignaturesIndex - 1, 'Invalid index.');\r\n        return _hashedSignaturesArray[index];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_hashedSignaturesIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_hashedSignaturesArray\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_mintedKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_regAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getHashedSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_eccAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"primaryPublicKeyHash\",\"type\":\"bytes32\"},{\"name\":\"tertiaryPublicKeyX\",\"type\":\"uint256\"},{\"name\":\"tertiaryPublicKeyY\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"rs\",\"type\":\"uint256[2]\"}],\"name\":\"submitEntropy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"eccAddress\",\"type\":\"address\"},{\"name\":\"regAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"primaryPublicKeyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"}]","ContractName":"KongEntropyDirectMint","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f471789937856d80e589f5996cf8b0511ddd9de4000000000000000000000000ba5c23a9644392ac4b8ee2e11bcb1ebab5fad220","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9084743283380819fbc0848b6aa3015644adb286c531a295d14501528eacc00f"}]}