{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/interfaces/IBridgeContract.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IBridgeContract {\\n    function requireToPassMessage(\\n        address,\\n        bytes calldata,\\n        uint256\\n    ) external;\\n\\n    function messageSender() external returns (address);\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/interfaces/ICToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\n\\ninterface ICToken {\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n    function supplyRatePerBlock() external returns (uint256);\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/interfaces/IComptroller.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\ninterface IComptroller {\\n    function claimComp(address holder) external;\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/interfaces/IPERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IPERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/interfaces/IXGTGenerator.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IXGTGenerator {\\n    function tokensStaked(uint256 _amount, address _user) external;\\n\\n    function tokensPooled(uint256 _amount, address _user) external;\\n\\n    function tokensUnstaked(uint256 _amount, address _user) external;\\n\\n    function tokensUnpooled(uint256 _amount, address _user) external;\\n\\n    function claimXGT(address _user) external;\\n\\n    function manualCorrectDeposit(uint256 _daiBalance, address _user) external;\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/metatx/EIP712Base.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\ncontract EIP712Base {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        uint256 chainId;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n            )\\n        );\\n\\n    bytes32 internal domainSeperator;\\n\\n    constructor(string memory name, string memory version) public {\\n        domainSeperator = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function getChainID() internal pure returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function getDomainSeperator() private view returns (bytes32) {\\n        return domainSeperator;\\n    }\\n\\n    /**\\n     * Accept message hash and returns hash message in EIP712 compatible form\\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n     * https://eips.ethereum.org/EIPS/eip-712\\n     * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n     * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n     */\\n    function toTypedMessageHash(bytes32 messageHash)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeperator(), messageHash)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/metatx/EIP712MetaTransaction.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"./EIP712Base.sol\\\";\\n\\ncontract EIP712MetaTransaction is EIP712Base {\\n    using SafeMath for uint256;\\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n            )\\n        );\\n\\n    event MetaTransactionExecuted(\\n        address userAddress,\\n        address payable relayerAddress,\\n        bytes functionSignature\\n    );\\n    mapping(address => uint256) private nonces;\\n\\n    /*\\n     * Meta transaction structure.\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\n     * He should call the desired function directly in that case.\\n     */\\n    struct MetaTransaction {\\n        uint256 nonce;\\n        address from;\\n        bytes functionSignature;\\n    }\\n\\n    constructor(string memory name, string memory version)\\n        public\\n        EIP712Base(name, version)\\n    {}\\n\\n    function convertBytesToBytes4(bytes memory inBytes)\\n        internal\\n        pure\\n        returns (bytes4 outBytes4)\\n    {\\n        if (inBytes.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            outBytes4 := mload(add(inBytes, 32))\\n        }\\n    }\\n\\n    function executeMetaTransaction(\\n        address userAddress,\\n        bytes memory functionSignature,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) public payable returns (bytes memory) {\\n        bytes4 destinationFunctionSig = convertBytesToBytes4(functionSignature);\\n        require(\\n            destinationFunctionSig != msg.sig,\\n            \\\"functionSignature can not be of executeMetaTransaction method\\\"\\n        );\\n        MetaTransaction memory metaTx =\\n            MetaTransaction({\\n                nonce: nonces[userAddress],\\n                from: userAddress,\\n                functionSignature: functionSignature\\n            });\\n        require(\\n            verify(userAddress, metaTx, sigR, sigS, sigV),\\n            \\\"Signer and signature do not match\\\"\\n        );\\n        nonces[userAddress] = nonces[userAddress].add(1);\\n        // Append userAddress at the end to extract it from calling context\\n        (bool success, bytes memory returnData) =\\n            address(this).call(\\n                abi.encodePacked(functionSignature, userAddress)\\n            );\\n\\n        require(success, \\\"Function call not successful\\\");\\n        emit MetaTransactionExecuted(\\n            userAddress,\\n            msg.sender,\\n            functionSignature\\n        );\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(MetaTransaction memory metaTx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    META_TRANSACTION_TYPEHASH,\\n                    metaTx.nonce,\\n                    metaTx.from,\\n                    keccak256(metaTx.functionSignature)\\n                )\\n            );\\n    }\\n\\n    function getNonce(address user) external view returns (uint256 nonce) {\\n        nonce = nonces[user];\\n    }\\n\\n    function verify(\\n        address user,\\n        MetaTransaction memory metaTx,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) internal view returns (bool) {\\n        address signer =\\n            ecrecover(\\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\\n                sigV,\\n                sigR,\\n                sigS\\n            );\\n        require(signer != address(0), \\\"Invalid signature\\\");\\n        return signer == user;\\n    }\\n\\n    function msgSender() internal view returns (address sender) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(\\n                    mload(add(array, index)),\\n                    0xffffffffffffffffffffffffffffffffffffffff\\n                )\\n            }\\n        } else {\\n            sender = msg.sender;\\n        }\\n        return sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ubuntu/git/customers/xionglobal/finance_contracts/contracts/staking/XGTStake.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/ownership/Ownable.sol\\\";\\nimport \\\"../metatx/EIP712MetaTransaction.sol\\\";\\nimport \\\"../metatx/EIP712Base.sol\\\";\\nimport \\\"../interfaces/ICToken.sol\\\";\\nimport \\\"../interfaces/IComptroller.sol\\\";\\nimport \\\"../interfaces/IBridgeContract.sol\\\";\\nimport \\\"../interfaces/IXGTGenerator.sol\\\";\\nimport \\\"../interfaces/IPERC20.sol\\\";\\n\\n// import \\\"../interfaces/IChainlinkOracle.sol\\\";\\n\\ncontract XGTStake is\\n    Initializable,\\n    OpenZeppelinUpgradesOwnable,\\n    EIP712MetaTransaction(\\\"XGTStake\\\", \\\"1\\\")\\n{\\n    using SafeMath for uint256;\\n\\n    IPERC20 public stakeToken;\\n    ICToken public cToken;\\n    IComptroller public comptroller;\\n    IPERC20 public comp;\\n    IBridgeContract public bridge;\\n    // IChainlinkOracle public gasOracle;\\n    // IChainlinkOracle public ethDaiOracle;\\n\\n    address public xgtGeneratorContract;\\n    address public xgtFund;\\n\\n    bool public paused = false;\\n    // uint256 public averageGasPerDeposit = 150000;\\n    // uint256 public averageGasPerWithdraw = 150000;\\n    // mapping(address => bool) public metaTransactors;\\n\\n    uint256 public interestCut = 250; // Interest Cut in Basis Points (250 = 2.5%)\\n    address public interestCutReceiver;\\n\\n    mapping(address => uint256) public userDepositsDai;\\n    mapping(address => uint256) public userDepositsCDai;\\n    uint256 public totalDeposits;\\n\\n    function initialize(\\n        address _stakeToken,\\n        address _cToken,\\n        address _comptroller,\\n        address _comp,\\n        address _bridge,\\n        address _xgtGeneratorContract\\n    ) public initializer {\\n        stakeToken = IPERC20(_stakeToken);\\n        cToken = ICToken(_cToken);\\n        comptroller = IComptroller(_comptroller);\\n        comp = IPERC20(_comp);\\n        bridge = IBridgeContract(_bridge);\\n        // gasOracle = IChainlinkOracle(\\n        // 0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\\n        // );\\n        // ethDaiOracle = IChainlinkOracle(\\n        // 0x773616E4d11A78F511299002da57A0a94577F1f4\\n        // );\\n        xgtGeneratorContract = _xgtGeneratorContract;\\n        interestCutReceiver = 0x36985f8AA15C02964d8450c930354C70f382bBC3;\\n    }\\n\\n    // function changeMetaTxAuth(address _user, bool _allowedToExecute)\\n    //     external\\n    //     onlyOwner\\n    // {\\n    //     metaTransactors[_user] = _allowedToExecute;\\n    // }\\n\\n    function pauseContracts(bool _pause) external onlyOwner {\\n        paused = _pause;\\n    }\\n\\n    function depositTokens(uint256 _amount) external notPaused {\\n        require(\\n            stakeToken.transferFrom(msgSender(), address(this), _amount),\\n            \\\"XGTSTAKE-DAI-TRANSFER-FAILED\\\"\\n        );\\n        require(\\n            stakeToken.approve(address(cToken), _amount),\\n            \\\"XGTSTAKE-DAI-APPROVE-FAILED\\\"\\n        );\\n\\n        uint256 balanceBefore = cToken.balanceOf(address(this));\\n        require(cToken.mint(_amount) == 0, \\\"XGTSTAKE-COMPOUND-DEPOSIT-FAILED\\\");\\n        uint256 cDai = cToken.balanceOf(address(this)).sub(balanceBefore);\\n\\n        userDepositsDai[msgSender()] = userDepositsDai[msgSender()].add(\\n            _amount\\n        );\\n        userDepositsCDai[msgSender()] = userDepositsCDai[msgSender()].add(cDai);\\n        totalDeposits = totalDeposits.add(_amount);\\n\\n        bytes4 _methodSelector =\\n            IXGTGenerator(address(0)).tokensStaked.selector;\\n        bytes memory data =\\n            abi.encodeWithSelector(_methodSelector, _amount, msgSender());\\n        bridge.requireToPassMessage(xgtGeneratorContract, data, 300000);\\n    }\\n\\n    function withdrawTokens(uint256 _amount) external notPaused {\\n        uint256 userDepositDai = userDepositsDai[msgSender()];\\n        uint256 userDepositCDai = userDepositsCDai[msgSender()];\\n        require(userDepositDai > 0, \\\"XGTSTAKE-NO-DEPOSIT\\\");\\n\\n        // If user puts in MAX_UINT256, skip this calcualtion\\n        // and set it to the maximum possible\\n        uint256 cDaiToRedeem = uint256(2**256 - 1);\\n        uint256 amount = _amount;\\n        if (amount != cDaiToRedeem) {\\n            cDaiToRedeem = userDepositCDai.mul(amount).div(userDepositDai);\\n        }\\n\\n        // If the calculation for some reason came up with too much\\n        // or if the user set to withdraw everything: set max\\n        if (cDaiToRedeem > userDepositCDai) {\\n            cDaiToRedeem = userDepositCDai;\\n            amount = userDepositDai;\\n        }\\n\\n        totalDeposits = totalDeposits.sub(amount);\\n        userDepositsDai[msgSender()] = userDepositDai.sub(amount);\\n        userDepositsCDai[msgSender()] = userDepositCDai.sub(cDaiToRedeem);\\n\\n        uint256 before = stakeToken.balanceOf(address(this));\\n        require(\\n            cToken.redeem(cDaiToRedeem) == 0,\\n            \\\"XGTSTAKE-COMPOUND-WITHDRAW-FAILED\\\"\\n        );\\n        uint256 diff = (stakeToken.balanceOf(address(this))).sub(before);\\n        require(diff >= amount, \\\"XGTSTAKE-COMPOUND-AMOUNT-MISMATCH\\\");\\n\\n        // Deduct the interest cut\\n        uint256 interest = diff.sub(amount);\\n        uint256 cut = 0;\\n        if (interest != 0) {\\n            cut = (interest.mul(interestCut)).div(10000);\\n            require(\\n                stakeToken.transfer(interestCutReceiver, cut),\\n                \\\"XGTSTAKE-INTEREST-CUT-TRANSFER-FAILED\\\"\\n            );\\n        }\\n\\n        // Transfer the rest to the user\\n        require(\\n            stakeToken.transfer(msgSender(), diff.sub(cut)),\\n            \\\"XGTSTAKE-USER-TRANSFER-FAILED\\\"\\n        );\\n\\n        bytes4 _methodSelector =\\n            IXGTGenerator(address(0)).tokensUnstaked.selector;\\n        bytes memory data =\\n            abi.encodeWithSelector(_methodSelector, _amount, msgSender());\\n        bridge.requireToPassMessage(xgtGeneratorContract, data, 300000);\\n    }\\n\\n    function correctBalance(address _user) external {\\n        bytes4 _methodSelector =\\n            IXGTGenerator(address(0)).manualCorrectDeposit.selector;\\n        bytes memory data =\\n            abi.encodeWithSelector(\\n                _methodSelector,\\n                userDepositsDai[_user],\\n                _user\\n            );\\n        bridge.requireToPassMessage(xgtGeneratorContract, data, 300000);\\n    }\\n\\n    function claimComp() external {\\n        comptroller.claimComp(address(this));\\n        uint256 balance = comp.balanceOf(address(this));\\n        if (balance > 0) {\\n            require(\\n                comp.transferFrom(address(this), interestCutReceiver, balance),\\n                \\\"XGTSTAKE-TRANSFER-FAILED\\\"\\n            );\\n        }\\n    }\\n\\n    // function refundGas(\\n    //     uint256 _amount,\\n    //     address _user,\\n    //     uint256 _gasAmount\\n    // ) internal returns (uint256) {\\n    //     int256 latestGasPrice = gasOracle.latestAnswer();\\n    //     uint256 latestEthPrice =\\n    //         uint256(1 ether).div(uint256(ethDaiOracle.latestAnswer()));\\n    //     uint256 amount = _amount;\\n    //     if (latestGasPrice >= 0 && latestEthPrice >= 0) {\\n    //         uint256 refund =\\n    //             uint256(latestGasPrice).mul(_gasAmount).mul(latestEthPrice);\\n    //         require(refund < _amount, \\\"XGTSTAKE-DEPOSIT-TOO-SMALL\\\");\\n    //         amount = _amount.sub(refund);\\n    //         require(\\n    //             stakeToken.transferFrom(_user, msgSender(), refund),\\n    //             \\\"XGTSTAKE-DAI-REFUND-TRANSFER-FAILED\\\"\\n    //         );\\n    //     }\\n    //     return amount;\\n    // }\\n\\n    modifier notPaused() {\\n        require(!paused, \\\"XGTSTAKE-Paused\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n *\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\\n */\\ncontract OpenZeppelinUpgradesOwnable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridgeContract\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract ICToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimComp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"contract IPERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"internalType\":\"contract IComptroller\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"correctBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_comptroller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_comp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xgtGeneratorContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestCutReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pauseContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"contract IPERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDepositsCDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDepositsDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xgtFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xgtGeneratorContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XGTStake","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}