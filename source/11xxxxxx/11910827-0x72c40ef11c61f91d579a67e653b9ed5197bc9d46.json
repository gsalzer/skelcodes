{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ONXPlatform.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\nimport \\\"./modules/Configable.sol\\\";\\nimport \\\"./modules/ConfigNames.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\ninterface IONXSupplyToken {\\n\\tfunction mint(address account, uint256 amount) external;\\n\\tfunction burn(address account, uint256 amount) external;\\n\\tfunction approve(address spender, uint256 amount) external;\\n}\\n\\ninterface IWETH {\\n\\tfunction deposit() external payable;\\n\\tfunction withdraw(uint256) external;\\n}\\n\\ninterface IONXPool {\\n\\tfunction deposit(uint _amountDeposit, address _from) external;\\n\\tfunction withdraw(uint _amountWithdraw, address _from) external returns(uint, uint);\\n\\tfunction borrow(uint _amountCollateral, uint _repayAmount, uint _expectBorrow, address _from) external;\\n\\tfunction repay(uint _amountCollateral, address _from) external returns(uint, uint);\\n\\tfunction liquidation(address _user, address _from) external returns (uint);\\n\\tfunction reinvest(address _from) external returns(uint);\\n\\n\\tfunction setCollateralStrategy(address _collateralStrategy, address _supplyStrategy) external;\\n\\tfunction supplys(address user) external view returns(uint,uint,uint,uint,uint);\\n\\tfunction borrows(address user) external view returns(uint,uint,uint,uint,uint);\\n\\tfunction getPoolCapacity() external view returns (uint);\\n\\tfunction supplyToken() external view returns (address);\\n\\tfunction interestPerBorrow() external view returns(uint);\\n\\tfunction interestPerSupply() external view returns(uint);\\n\\tfunction lastInterestUpdate() external view returns(uint);\\n\\tfunction getInterests() external view returns(uint, uint);\\n\\tfunction totalBorrow() external view returns(uint);\\n\\tfunction remainSupply() external view returns(uint);\\n\\tfunction liquidationPerSupply() external view returns(uint);\\n\\tfunction totalLiquidationSupplyAmount() external view returns(uint);\\n\\tfunction totalLiquidation() external view returns(uint);\\n}\\n\\ninterface IONXFactory {\\n    function getPool(address _lendToken, address _collateralToken) external view returns (address);\\n    function countPools() external view returns(uint);\\n    function allPools(uint index) external view returns (address);\\n}\\n\\ncontract ONXPlatform is Configable {\\n\\tusing SafeMath for uint256;\\n\\tuint256 private unlocked;\\n\\taddress public payoutAddress;\\n\\taddress public onxSupplyToken;\\n\\tmodifier lock() {\\n\\t\\trequire(unlocked == 1, \\\"Locked\\\");\\n\\t\\tunlocked = 0;\\n\\t\\t_;\\n\\t\\tunlocked = 1;\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n\\tfunction initialize(address _payoutAddress, address _onxSupplyToken) external initializer {\\n\\t\\tConfigable.__config_initialize();\\n\\t\\tunlocked = 1;\\n\\t\\tpayoutAddress = _payoutAddress;\\n\\t\\tonxSupplyToken = _onxSupplyToken;\\n\\t}\\n\\n\\tfunction deposit(address _lendToken, address _collateralToken, uint256 _amountDeposit) external lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.DEPOSIT_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tTransferHelper.safeTransferFrom(_lendToken, msg.sender, pool, _amountDeposit);\\n\\t\\tif(onxSupplyToken != address(0) && _amountDeposit > 0)\\n\\t\\t{\\n\\t\\t\\tIONXSupplyToken(onxSupplyToken).mint(address(this), _amountDeposit);\\n\\t\\t\\tTransferHelper.safeTransfer(onxSupplyToken, pool, _amountDeposit);\\n\\t\\t}\\n\\t\\tIONXPool(pool).deposit(_amountDeposit, msg.sender);\\n\\t}\\n\\n\\tfunction depositETH(address _lendToken, address _collateralToken) external payable lock {\\n\\t\\trequire(_lendToken == IConfig(config).WETH(), \\\"INVALID WETH POOL\\\");\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.DEPOSIT_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tIWETH(IConfig(config).WETH()).deposit{value: msg.value}();\\n\\t\\tTransferHelper.safeTransfer(_lendToken, pool, msg.value);\\n\\t\\tif(onxSupplyToken != address(0) && msg.value > 0)\\n\\t\\t{\\n\\t\\t\\tIONXSupplyToken(onxSupplyToken).mint(address(this), msg.value);\\n\\t\\t\\tTransferHelper.safeTransfer(onxSupplyToken, pool, msg.value);\\n\\t\\t}\\n\\t\\tIONXPool(pool).deposit(msg.value, msg.sender);\\n\\t}\\n\\n\\tfunction withdraw(address _lendToken, address _collateralToken, uint256 _amountWithdraw) external lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.WITHDRAW_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\t(uint256 withdrawSupplyAmount, uint256 withdrawLiquidationAmount) =\\n\\t\\t\\tIONXPool(pool).withdraw(_amountWithdraw, msg.sender);\\n\\t\\tif (withdrawSupplyAmount > 0) {\\n\\t\\t\\t_innerTransfer(_lendToken, msg.sender, withdrawSupplyAmount);\\n\\t\\t\\tif(onxSupplyToken != address(0) && _amountWithdraw > 0) {\\n\\t\\t\\t\\tIONXSupplyToken(onxSupplyToken).burn(address(this), _amountWithdraw);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (withdrawLiquidationAmount > 0) _innerTransfer(_collateralToken, msg.sender, withdrawLiquidationAmount);\\n\\t}\\n\\n\\tfunction borrow(address _lendToken, address _collateralToken, uint256 _amountCollateral, uint256 _expectBorrow) external lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.BORROW_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tif (_amountCollateral > 0) {\\n\\t\\t\\tTransferHelper.safeTransferFrom(_collateralToken, msg.sender, pool, _amountCollateral);\\n\\t\\t}\\n\\n\\t\\t(, uint256 borrowAmountCollateral, , , ) = IONXPool(pool).borrows(msg.sender);\\n\\t\\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, borrowAmountCollateral, msg.sender);\\n\\t\\tIONXPool(pool).borrow(_amountCollateral, repayAmount, _expectBorrow, msg.sender);\\n\\t\\tif (_expectBorrow > 0) _innerTransfer(_lendToken, msg.sender, _expectBorrow);\\n\\t}\\n\\n\\tfunction borrowTokenWithETH(address _lendToken, address _collateralToken, uint256 _expectBorrow) external payable lock {\\n\\t\\trequire(_collateralToken == IConfig(config).WETH(), \\\"INVALID WETH POOL\\\");\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.BORROW_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n        \\n\\t\\tif (msg.value > 0) {\\n\\t\\t\\tIWETH(IConfig(config).WETH()).deposit{value: msg.value}();\\n\\t\\t\\tTransferHelper.safeTransfer(_collateralToken, pool, msg.value);\\n\\t\\t}\\n\\n\\t\\t(, uint256 borrowAmountCollateral, , , ) = IONXPool(pool).borrows(msg.sender);\\n\\t\\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, borrowAmountCollateral, msg.sender);\\n\\t\\tIONXPool(pool).borrow(msg.value, repayAmount, _expectBorrow, msg.sender);\\n\\t\\tif (_expectBorrow > 0) _innerTransfer(_lendToken, msg.sender, _expectBorrow);\\n\\t}\\n\\n\\tfunction repay(address _lendToken, address _collateralToken, uint256 _amountCollateral) external lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.REPAY_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, _amountCollateral, msg.sender);\\n\\t\\tif (repayAmount > 0) {\\n\\t\\t\\tTransferHelper.safeTransferFrom(_lendToken, msg.sender, pool, repayAmount);\\n\\t\\t}\\n\\n\\t\\t(, uint256 payoutInterest) = IONXPool(pool).repay(_amountCollateral, msg.sender);\\n\\t\\tif (payoutInterest > 0) {\\n\\t\\t\\t_innerTransfer(_lendToken, payoutAddress, payoutInterest);\\n\\t\\t}\\n\\t\\t_innerTransfer(_collateralToken, msg.sender, _amountCollateral);\\n\\t}\\n\\n\\tfunction repayETH(address _lendToken, address _collateralToken, uint256 _amountCollateral) external payable lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.REPAY_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\trequire(_lendToken == IConfig(config).WETH(), \\\"INVALID WETH POOL\\\");\\n\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, _amountCollateral, msg.sender);\\n\\t\\trequire(repayAmount <= msg.value, \\\"INVALID VALUE\\\");\\n\\t\\tif (repayAmount > 0) {\\n\\t\\t\\tIWETH(IConfig(config).WETH()).deposit{value: repayAmount}();\\n\\t\\t\\tTransferHelper.safeTransfer(_lendToken, pool, repayAmount);\\n\\t\\t}\\n\\n\\t\\t(, uint256 payoutInterest) = IONXPool(pool).repay(_amountCollateral, msg.sender);\\n\\t\\tif (payoutInterest > 0) {\\n\\t\\t\\t_innerTransfer(_lendToken, payoutAddress, payoutInterest);\\n\\t\\t}\\n\\t\\t_innerTransfer(_collateralToken, msg.sender, _amountCollateral);\\n\\t\\tif (msg.value > repayAmount) TransferHelper.safeTransferETH(msg.sender, msg.value.sub(repayAmount));\\n\\t}\\n\\n\\tfunction liquidation(address _lendToken, address _collateralToken, address _user) external lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.LIQUIDATION_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tIONXPool(pool).liquidation(_user, msg.sender);\\n\\t}\\n\\n\\tfunction reinvest(address _lendToken, address _collateralToken) external lock {\\n\\t\\trequire(IConfig(config).getValue(ConfigNames.REINVEST_ENABLE) == 1, \\\"NOT ENABLE NOW\\\");\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tIONXPool(pool).reinvest(msg.sender);\\n\\t}\\n\\n\\tfunction _innerTransfer(\\n\\t\\taddress _token,\\n\\t\\taddress _to,\\n\\t\\tuint256 _amount\\n\\t) internal {\\n\\t\\tif (_token == IConfig(config).WETH()) {\\n\\t\\t\\tIWETH(_token).withdraw(_amount);\\n\\t\\t\\tTransferHelper.safeTransferETH(_to, _amount);\\n\\t\\t} else {\\n\\t\\t\\tTransferHelper.safeTransfer(_token, _to, _amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getRepayAmount(address _lendToken, address _collateralToken, uint256 amountCollateral, address from) public view returns (uint256 repayAmount) {\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\n\\t\\t(, uint256 borrowAmountCollateral, uint256 interestSettled, uint256 amountBorrow, uint256 borrowInterests) =\\n\\t\\t\\tIONXPool(pool).borrows(from);\\n\\t\\t(, uint256 borrowInterestPerBlock) = IONXPool(pool).getInterests();\\n\\t\\tuint256 _interestPerBorrow =\\n\\t\\t\\tIONXPool(pool).interestPerBorrow().add(\\n\\t\\t\\t\\tborrowInterestPerBlock.mul(block.number - IONXPool(pool).lastInterestUpdate())\\n\\t\\t\\t);\\n\\t\\tuint256 repayInterest =\\n\\t\\t\\tborrowAmountCollateral == 0 \\n\\t\\t\\t? 0 \\n\\t\\t\\t: borrowInterests.add(_interestPerBorrow.mul(amountBorrow).div(1e18).sub(interestSettled)).mul(amountCollateral).div(borrowAmountCollateral);\\n\\t\\trepayAmount = borrowAmountCollateral == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: amountBorrow.mul(amountCollateral).div(borrowAmountCollateral).add(repayInterest);\\n\\t}\\n\\n\\tfunction getMaximumBorrowAmount(address _lendToken, address _collateralToken, uint256 amountCollateral) external view returns (uint256 amountBorrow) {\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\n\\t\\tuint256 pledgeAmount = IConfig(config).convertTokenAmount(_collateralToken, _lendToken, amountCollateral);\\n\\t\\tuint256 pledgeRate = IConfig(config).getPoolValue(pool, ConfigNames.POOL_PLEDGE_RATE);\\n\\t\\tamountBorrow = pledgeAmount.mul(pledgeRate).div(1e18);\\n\\t}\\n\\n\\tfunction getLiquidationAmount(address _lendToken, address _collateralToken, address from) public view returns (uint256 liquidationAmount) {\\n        \\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t        require(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\n\\t\\t(uint256 amountSupply, , uint256 liquidationSettled, , uint256 supplyLiquidation) =\\n\\t\\t\\tIONXPool(pool).supplys(from);\\n\\t\\tliquidationAmount = supplyLiquidation.add(\\n\\t\\t\\tIONXPool(pool).liquidationPerSupply().mul(amountSupply).div(1e18).sub(liquidationSettled)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction getInterestAmount(address _lendToken, address _collateralToken, address from) public view returns (uint256 interestAmount) {\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\n\\t\\tuint256 totalBorrow = IONXPool(pool).totalBorrow();\\n\\t\\tuint256 totalSupply = totalBorrow + IONXPool(pool).remainSupply();\\n\\t\\t(uint256 amountSupply, uint256 interestSettled, , uint256 interests, ) = IONXPool(pool).supplys(from);\\n\\t\\t(uint256 supplyInterestPerBlock,) = IONXPool(pool).getInterests();\\n\\t\\tuint256 _interestPerSupply =\\n\\t\\t\\tIONXPool(pool).interestPerSupply().add(\\n\\t\\t\\t\\ttotalSupply == 0\\n\\t\\t\\t\\t\\t? 0\\n\\t\\t\\t\\t\\t: supplyInterestPerBlock\\n\\t\\t\\t\\t\\t\\t.mul(block.number - IONXPool(pool).lastInterestUpdate())\\n\\t\\t\\t\\t\\t\\t.mul(IONXPool(pool).totalBorrow())\\n\\t\\t\\t\\t\\t\\t.div(totalSupply)\\n\\t\\t\\t);\\n\\t\\tinterestAmount = interests.add(_interestPerSupply.mul(amountSupply).div(1e18).sub(interestSettled));\\n\\t}\\n\\n\\tfunction getWithdrawAmount(address _lendToken, address _collateralToken, address from)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256 withdrawAmount,\\n\\t\\t\\tuint256 interestAmount,\\n\\t\\t\\tuint256 liquidationAmount\\n\\t\\t)\\n\\t{\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\n\\t\\tuint256 _totalInterest = getInterestAmount(_lendToken, _collateralToken, from);\\n\\t\\tliquidationAmount = getLiquidationAmount(_lendToken, _collateralToken, from);\\n\\t\\tinterestAmount = _totalInterest;\\n\\t\\tuint256 totalLiquidation = IONXPool(pool).totalLiquidation();\\n\\t\\tuint256 withdrawLiquidationSupplyAmount =\\n\\t\\t\\ttotalLiquidation == 0\\n\\t\\t\\t\\t? 0\\n\\t\\t\\t\\t: liquidationAmount.mul(IONXPool(pool).totalLiquidationSupplyAmount()).div(totalLiquidation);\\n\\t\\t(uint256 amountSupply, , , , ) = IONXPool(pool).supplys(from);\\n\\t\\tif (withdrawLiquidationSupplyAmount > amountSupply.add(interestAmount)) withdrawAmount = 0;\\n\\t\\telse withdrawAmount = amountSupply.add(interestAmount).sub(withdrawLiquidationSupplyAmount);\\n\\t}\\n\\n\\tfunction updatePoolParameter(address _lendToken, address _collateralToken, bytes32 _key, uint256 _value) external onlyOwner {\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tIConfig(config).setPoolValue(pool, _key, _value);\\n\\t}\\n\\n\\tfunction setCollateralStrategy(address _lendToken, address _collateralToken, address _collateralStrategy, address _supplyStrategy) external onlyOwner\\n\\t{\\n\\t\\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\\n\\t\\trequire(pool != address(0), \\\"POOL NOT EXIST\\\");\\n\\t\\tIONXPool(pool).setCollateralStrategy(_collateralStrategy, _supplyStrategy);\\n\\t}\\n\\n\\tfunction setPayoutAddress(address _payoutAddress) external onlyOwner {\\n\\t\\tpayoutAddress = _payoutAddress;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Configable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\ninterface IConfig {\\n\\t\\tfunction owner() external view returns (address);\\n    function platform() external view returns (address);\\n    function factory() external view returns (address);\\n    function mint() external view returns (address);\\n    function token() external view returns (address);\\n    function developPercent() external view returns (uint);\\n    function share() external view returns (address);\\n    function base() external view returns (address); \\n    function governor() external view returns (address);\\n    function getPoolValue(address pool, bytes32 key) external view returns (uint);\\n    function getValue(bytes32 key) external view returns(uint);\\n    function getParams(bytes32 key) external view returns(uint, uint, uint); \\n    function getPoolParams(address pool, bytes32 key) external view returns(uint, uint, uint); \\n    function wallets(bytes32 key) external view returns(address);\\n    function setValue(bytes32 key, uint value) external;\\n    function setPoolValue(address pool, bytes32 key, uint value) external;\\n    function initPoolParams(address _pool) external;\\n    function isMintToken(address _token) external returns (bool);\\n    function prices(address _token) external returns (uint);\\n    function convertTokenAmount(address _fromToken, address _toToken, uint _fromAmount) external view returns (uint);\\n    function DAY() external view returns (uint);\\n    function WETH() external view returns (address);\\n}\\n\\ncontract Configable is Initializable {\\n\\taddress public config;\\n\\taddress public owner;\\n\\tevent OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\\n\\n\\tfunction __config_initialize() internal initializer {\\n\\t\\towner = msg.sender;\\n\\t}\\n\\n\\tfunction setupConfig(address _config) external onlyOwner {\\n\\t\\tconfig = _config;\\n\\t\\towner = IConfig(config).owner();\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == owner, \\\"OWNER FORBIDDEN\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyPlatform() {\\n\\t\\trequire(msg.sender == IConfig(config).platform(), \\\"PLATFORM FORBIDDEN\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyFactory() {\\n\\t\\t\\trequire(msg.sender == IConfig(config).factory(), 'FACTORY FORBIDDEN');\\n\\t\\t\\t_;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/modules/ConfigNames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\n\\nlibrary ConfigNames {\\n\\t//GOVERNANCE\\n\\tbytes32 public constant STAKE_LOCK_TIME = bytes32(\\\"STAKE_LOCK_TIME\\\");\\n\\tbytes32 public constant CHANGE_PRICE_DURATION = bytes32(\\\"CHANGE_PRICE_DURATION\\\");\\n\\tbytes32 public constant CHANGE_PRICE_PERCENT = bytes32(\\\"CHANGE_PRICE_PERCENT\\\"); // POOL\\n\\tbytes32 public constant POOL_BASE_INTERESTS = bytes32(\\\"POOL_BASE_INTERESTS\\\");\\n\\tbytes32 public constant POOL_MARKET_FRENZY = bytes32(\\\"POOL_MARKET_FRENZY\\\");\\n\\tbytes32 public constant POOL_PLEDGE_RATE = bytes32(\\\"POOL_PLEDGE_RATE\\\");\\n\\tbytes32 public constant POOL_LIQUIDATION_RATE = bytes32(\\\"POOL_LIQUIDATION_RATE\\\");\\n\\tbytes32 public constant POOL_MINT_BORROW_PERCENT = bytes32(\\\"POOL_MINT_BORROW_PERCENT\\\");\\n\\tbytes32 public constant POOL_MINT_POWER = bytes32(\\\"POOL_MINT_POWER\\\");\\n\\tbytes32 public constant POOL_REWARD_RATE = bytes32(\\\"POOL_REWARD_RATE\\\");\\n\\tbytes32 public constant POOL_ARBITRARY_RATE = bytes32(\\\"POOL_ARBITRARY_RATE\\\");\\n\\n\\t//NOT GOVERNANCE\\n\\tbytes32 public constant DEPOSIT_ENABLE = bytes32(\\\"DEPOSIT_ENABLE\\\");\\n\\tbytes32 public constant WITHDRAW_ENABLE = bytes32(\\\"WITHDRAW_ENABLE\\\");\\n\\tbytes32 public constant BORROW_ENABLE = bytes32(\\\"BORROW_ENABLE\\\");\\n\\tbytes32 public constant REPAY_ENABLE = bytes32(\\\"REPAY_ENABLE\\\");\\n\\tbytes32 public constant LIQUIDATION_ENABLE = bytes32(\\\"LIQUIDATION_ENABLE\\\");\\n\\tbytes32 public constant REINVEST_ENABLE = bytes32(\\\"REINVEST_ENABLE\\\");\\n\\tbytes32 public constant POOL_PRICE = bytes32(\\\"POOL_PRICE\\\"); //wallet\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\n\\nlibrary SafeMath {\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b <= a, errorMessage);\\n\\t\\tuint256 c = a - b;\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers. Reverts on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn div(a, b, \\\"SafeMath: division by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b > 0, errorMessage);\\n\\t\\tuint256 c = a / b;\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * Reverts when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * Reverts with custom message when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b != 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nlibrary TransferHelper {\\n\\tfunction safeApprove(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t// bytes4(keccak256(bytes('approve(address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: APPROVE_FAILED\\\");\\n\\t}\\n\\n\\tfunction safeTransfer(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FAILED\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(\\n\\t\\taddress token,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FROM_FAILED\\\");\\n\\t}\\n\\n\\tfunction safeTransferETH(address to, uint256 value) internal {\\n\\t\\t(bool success, ) = to.call{value: value}(new bytes(0));\\n\\t\\trequire(success, \\\"TransferHelper: ETH_TRANSFER_FAILED\\\");\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n * \\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n * \\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectBorrow\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expectBorrow\",\"type\":\"uint256\"}],\"name\":\"borrowTokenWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountDeposit\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getInterestAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getLiquidationAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidationAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"}],\"name\":\"getMaximumBorrowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBorrow\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getRepayAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getWithdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_onxSupplyToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"liquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onxSupplyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountCollateral\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountCollateral\",\"type\":\"uint256\"}],\"name\":\"repayETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralStrategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_supplyStrategy\",\"type\":\"address\"}],\"name\":\"setCollateralStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_payoutAddress\",\"type\":\"address\"}],\"name\":\"setPayoutAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updatePoolParameter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ONXPlatform","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}