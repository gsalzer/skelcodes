{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/SafeMath96.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath96 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint96 a, uint256 b) internal pure returns (uint96) {\r\n        require(uint256(uint96(b)) == b, \"SafeMath: addition overflow\");\r\n        uint96 c = a + uint96(b);\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint96 a, uint256 b) internal pure returns (uint96) {\r\n        require(uint256(uint96(b)) == b, \"SafeMath: subtraction overflow\");\r\n        return sub(a, uint96(b), \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        uint96 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/IElections.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Elections contract interface\r\ninterface IElections {\r\n\t\r\n\t// Election state change events\r\n\tevent StakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, uint256 effectiveStake);\r\n\tevent GuardianStatusUpdated(address indexed guardian, bool readyToSync, bool readyForCommittee);\r\n\r\n\t// Vote out / Vote unready\r\n\tevent GuardianVotedUnready(address indexed guardian);\r\n\tevent VoteUnreadyCasted(address indexed voter, address indexed subject, uint256 expiration);\r\n\tevent GuardianVotedOut(address indexed guardian);\r\n\tevent VoteOutCasted(address indexed voter, address indexed subject);\r\n\r\n\t/*\r\n\t * External functions\r\n\t */\r\n\r\n    /// Notifies that the guardian is ready to sync with other nodes\r\n    /// @dev may be called with either the guardian address or the guardian's orbs address\r\n    /// @dev ready to sync state is not managed in the contract that only emits an event\r\n    /// @dev readyToSync clears the readyForCommittee state\r\n\tfunction readyToSync() external;\r\n\r\n    /// Notifies that the guardian is ready to join the committee\r\n    /// @dev may be called with either the guardian address or the guardian's orbs address\r\n    /// @dev a qualified guardian calling readyForCommittee is added to the committee\r\n\tfunction readyForCommittee() external;\r\n\r\n    /// Checks if a guardian is qualified to join the committee\r\n    /// @dev when true, calling readyForCommittee() will result in adding the guardian to the committee\r\n    /// @dev called periodically by guardians to check if they are qualified to join the committee\r\n    /// @param guardian is the guardian to check\r\n    /// @return canJoin indicating that the guardian can join the current committee\r\n\tfunction canJoinCommittee(address guardian) external view returns (bool);\r\n\r\n    /// Returns an address effective stake\r\n    /// The effective stake is derived from a guardian delegate stake and selfs stake  \r\n    /// @return effectiveStake is the guardian's effective stake\r\n\tfunction getEffectiveStake(address guardian) external view returns (uint effectiveStake);\r\n\r\n    /// Returns the current committee along with the guardians' Orbs address and IP\r\n    /// @return committee is a list of the committee members' guardian addresses\r\n    /// @return weights is a list of the committee members' weight (effective stake)\r\n    /// @return orbsAddrs is a list of the committee members' orbs address\r\n    /// @return certification is a list of bool indicating the committee members certification\r\n    /// @return ips is a list of the committee members' ip\r\n\tfunction getCommittee() external view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);\r\n\r\n\t// Vote-unready\r\n\r\n    /// Casts an unready vote on a subject guardian\r\n    /// @dev Called by a guardian as part of the automatic vote-unready flow\r\n    /// @dev The transaction may be sent from the guardian or orbs address.\r\n    /// @param subject is the subject guardian to vote out\r\n    /// @param voteExpiration is the expiration time of the vote unready to prevent counting of a vote that is already irrelevant.\r\n\tfunction voteUnready(address subject, uint voteExpiration) external;\r\n\r\n    /// Returns the current vote unready vote for a voter and a subject pair\r\n    /// @param voter is the voting guardian address\r\n    /// @param subject is the subject guardian address\r\n    /// @return valid indicates whether there is a valid vote\r\n    /// @return expiration returns the votes expiration time\r\n\tfunction getVoteUnreadyVote(address voter, address subject) external view returns (bool valid, uint256 expiration);\r\n\r\n    /// Returns the current vote-unready status of a subject guardian.\r\n    /// @dev the committee and certification data is used to check the certified and committee threshold\r\n    /// @param subject is the subject guardian address\r\n    /// @return committee is a list of the current committee members\r\n    /// @return weights is a list of the current committee members weight\r\n    /// @return certification is a list of bool indicating the committee members certification\r\n    /// @return votes is a list of bool indicating the members that votes the subject unready\r\n    /// @return subjectInCommittee indicates that the subject is in the committee\r\n    /// @return subjectInCertifiedCommittee indicates that the subject is in the certified committee\r\n\tfunction getVoteUnreadyStatus(address subject) external view returns (\r\n\t\taddress[] memory committee,\r\n\t\tuint256[] memory weights,\r\n\t\tbool[] memory certification,\r\n\t\tbool[] memory votes,\r\n\t\tbool subjectInCommittee,\r\n\t\tbool subjectInCertifiedCommittee\r\n\t);\r\n\r\n\t// Vote-out\r\n\r\n    /// Casts a voteOut vote by the sender to the given address\r\n    /// @dev the transaction is sent from the guardian address\r\n    /// @param subject is the subject guardian address\r\n\tfunction voteOut(address subject) external;\r\n\r\n    /// Returns the subject address the addr has voted-out against\r\n    /// @param voter is the voting guardian address\r\n    /// @return subject is the subject the voter has voted out\r\n\tfunction getVoteOutVote(address voter) external view returns (address);\r\n\r\n    /// Returns the governance voteOut status of a guardian.\r\n    /// @dev A guardian is voted out if votedStake / totalDelegatedStake (in percent mille) > threshold\r\n    /// @param subject is the subject guardian address\r\n    /// @return votedOut indicates whether the subject was voted out\r\n    /// @return votedStake is the total stake voting against the subject\r\n    /// @return totalDelegatedStake is the total delegated stake\r\n\tfunction getVoteOutStatus(address subject) external view returns (bool votedOut, uint votedStake, uint totalDelegatedStake);\r\n\r\n\t/*\r\n\t * Notification functions from other PoS contracts\r\n\t */\r\n\r\n    /// Notifies a delegated stake change event\r\n    /// @dev Called by: delegation contract\r\n    /// @param delegate is the delegate to update\r\n    /// @param selfDelegatedStake is the delegate self stake (0 if not self-delegating)\r\n    /// @param delegatedStake is the delegate delegated stake (0 if not self-delegating)\r\n    /// @param totalDelegatedStake is the total delegated stake\r\n\tfunction delegatedStakeChange(address delegate, uint256 selfDelegatedStake, uint256 delegatedStake, uint256 totalDelegatedStake) external /* onlyDelegationsContract onlyWhenActive */;\r\n\r\n    /// Notifies a new guardian was unregistered\r\n    /// @dev Called by: guardian registration contract\r\n    /// @dev when a guardian unregisters its status is updated to not ready to sync and is removed from the committee\r\n    /// @param guardian is the address of the guardian that unregistered\r\n\tfunction guardianUnregistered(address guardian) external /* onlyGuardiansRegistrationContract */;\r\n\r\n    /// Notifies on a guardian certification change\r\n    /// @dev Called by: guardian registration contract\r\n    /// @param guardian is the address of the guardian to update\r\n    /// @param isCertified indicates whether the guardian is certified\r\n\tfunction guardianCertificationChanged(address guardian, bool isCertified) external /* onlyCertificationContract */;\r\n\r\n\r\n\t/*\r\n     * Governance functions\r\n\t */\r\n\r\n\tevent VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);\r\n\tevent VoteOutPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\r\n\tevent VoteUnreadyPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\r\n\tevent MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);\r\n\r\n    /// Sets the minimum self stake requirement for the effective stake\r\n    /// @dev governance function called only by the functional manager\r\n    /// @param minSelfStakePercentMille is the minimum self stake in percent-mille (0-100,000) \r\n\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external /* onlyFunctionalManager */;\r\n\r\n    /// Returns the minimum self-stake required for the effective stake\r\n    /// @return minSelfStakePercentMille is the minimum self stake in percent-mille \r\n\tfunction getMinSelfStakePercentMille() external view returns (uint32);\r\n\r\n    /// Sets the vote-out threshold\r\n    /// @dev governance function called only by the functional manager\r\n    /// @param voteOutPercentMilleThreshold is the minimum threshold in percent-mille (0-100,000)\r\n\tfunction setVoteOutPercentMilleThreshold(uint32 voteOutPercentMilleThreshold) external /* onlyFunctionalManager */;\r\n\r\n    /// Returns the vote-out threshold\r\n    /// @return voteOutPercentMilleThreshold is the minimum threshold in percent-mille\r\n\tfunction getVoteOutPercentMilleThreshold() external view returns (uint32);\r\n\r\n    /// Sets the vote-unready threshold\r\n    /// @dev governance function called only by the functional manager\r\n    /// @param voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille (0-100,000)\r\n\tfunction setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external /* onlyFunctionalManager */;\r\n\r\n    /// Returns the vote-unready threshold\r\n    /// @return voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille\r\n\tfunction getVoteUnreadyPercentMilleThreshold() external view returns (uint32);\r\n\r\n    /// Returns the contract's settings \r\n    /// @return minSelfStakePercentMille is the minimum self stake in percent-mille\r\n    /// @return voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille\r\n    /// @return voteOutPercentMilleThreshold is the minimum threshold in percent-mille\r\n\tfunction getSettings() external view returns (\r\n\t\tuint32 minSelfStakePercentMille,\r\n\t\tuint32 voteUnreadyPercentMilleThreshold,\r\n\t\tuint32 voteOutPercentMilleThreshold\r\n\t);\r\n\r\n    /// Initializes the ready for committee notification for the committee guardians\r\n    /// @dev governance function called only by the initialization admin during migration \r\n    /// @dev identical behaviour as if each guardian sent readyForCommittee() \r\n    /// @param guardians a list of guardians addresses to update\r\n\tfunction initReadyForCommittee(address[] calldata guardians) external /* onlyInitializationAdmin */;\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/IDelegations.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Delegations contract interface\r\ninterface IDelegations /* is IStakeChangeNotifier */ {\r\n\r\n    // Delegation state change events\r\n\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);\r\n\r\n    // Function calls\r\n\tevent Delegated(address indexed from, address indexed to);\r\n\r\n\t/*\r\n     * External functions\r\n     */\r\n\r\n    /// Delegate your stake\r\n    /// @dev updates the election contract on the changes in the delegated stake\r\n    /// @dev updates the rewards contract on the upcoming change in the delegator's delegation state\r\n    /// @param to is the address to delegate to\r\n\tfunction delegate(address to) external /* onlyWhenActive */;\r\n\r\n    /// Refresh the address stake for delegation power based on the staking contract\r\n    /// @dev Disabled stake change update notifications from the staking contract may create mismatches\r\n    /// @dev refreshStake re-syncs the stake data with the staking contract\r\n    /// @param addr is the address to refresh its stake\r\n\tfunction refreshStake(address addr) external /* onlyWhenActive */;\r\n\r\n    /// Refresh the addresses stake for delegation power based on the staking contract\r\n    /// @dev Batched version of refreshStake\r\n    /// @dev Disabled stake change update notifications from the staking contract may create mismatches\r\n    /// @dev refreshStakeBatch re-syncs the stake data with the staking contract\r\n    /// @param addrs is the list of addresses to refresh their stake\r\n\tfunction refreshStakeBatch(address[] calldata addrs) external /* onlyWhenActive */;\r\n\r\n    /// Returns the delegate address of the given address\r\n    /// @param addr is the address to query\r\n    /// @return delegation is the address the addr delegated to\r\n\tfunction getDelegation(address addr) external view returns (address);\r\n\r\n    /// Returns a delegator info\r\n    /// @param addr is the address to query\r\n    /// @return delegation is the address the addr delegated to\r\n    /// @return delegatorStake is the stake of the delegator as reflected in the delegation contract\r\n\tfunction getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);\r\n\t\r\n    /// Returns the delegated stake of an addr \r\n    /// @dev an address that is not self delegating has a 0 delegated stake\r\n    /// @param addr is the address to query\r\n    /// @return delegatedStake is the address delegated stake\r\n\tfunction getDelegatedStake(address addr) external view returns (uint256);\r\n\r\n    /// Returns the total delegated stake\r\n    /// @dev delegatedStake - the total stake delegated to an address that is self delegating\r\n    /// @dev the delegated stake of a non self-delegated address is 0\r\n    /// @return totalDelegatedStake is the total delegatedStake of all the addresses\r\n\tfunction getTotalDelegatedStake() external view returns (uint256) ;\r\n\r\n\t/*\r\n\t * Governance functions\r\n\t */\r\n\r\n\tevent DelegationsImported(address[] from, address indexed to);\r\n\r\n\tevent DelegationInitialized(address indexed from, address indexed to);\r\n\r\n    /// Imports delegations during initial migration\r\n    /// @dev initialization function called only by the initializationManager\r\n    /// @dev Does not update the Rewards or Election contracts\r\n    /// @dev assumes deactivated Rewards\r\n    /// @param from is a list of delegator addresses\r\n    /// @param to is the address the delegators delegate to\r\n\tfunction importDelegations(address[] calldata from, address to) external /* onlyMigrationManager onlyDuringDelegationImport */;\r\n\r\n    /// Initializes the delegation of an address during initial migration \r\n    /// @dev initialization function called only by the initializationManager\r\n    /// @dev behaves identically to a delegate transaction sent by the delegator\r\n    /// @param from is the delegator addresses\r\n    /// @param to is the delegator delegates to\r\n\tfunction initDelegation(address from, address to) external /* onlyInitializationAdmin */;\r\n}\r\n\r\n// File: contracts/IStakeChangeNotifier.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\r\ninterface IStakeChangeNotifier {\r\n    /// @dev Notifies of stake change event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The difference in the total staked amount.\r\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\r\n    /// @param _updatedStake uint256 The updated total staked amount.\r\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\r\n\r\n    /// @dev Notifies of multiple stake change events.\r\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\r\n    /// @param _amounts uint256[] The differences in total staked amounts.\r\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\r\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\r\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\r\n        uint256[] calldata _updatedStakes) external;\r\n\r\n    /// @dev Notifies of stake migration event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The migrated amount.\r\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/spec_interfaces/IStakingContractHandler.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Staking contract handler contract interface in addition to IStakeChangeNotifier\r\ninterface IStakingContractHandler {\r\n    event StakeChangeNotificationSkipped(address indexed stakeOwner);\r\n    event StakeChangeBatchNotificationSkipped(address[] stakeOwners);\r\n    event StakeMigrationNotificationSkipped(address indexed stakeOwner);\r\n\r\n    /*\r\n    * External functions\r\n    */\r\n\r\n    /// Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param stakeOwner address The address to check.\r\n    /// @return uint256 The total stake.\r\n    function getStakeBalanceOf(address stakeOwner) external view returns (uint256);\r\n\r\n    /// Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 is the total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external view returns (uint256);\r\n\r\n    /*\r\n    * Governance functions\r\n    */\r\n\r\n    event NotifyDelegationsChanged(bool notifyDelegations);\r\n\r\n    /// Sets notifications to the delegation contract\r\n    /// @dev staking while notifications are disabled may lead to a discrepancy in the delegation data  \r\n    /// @dev governance function called only by the migration manager\r\n    /// @param notifyDelegations is a bool indicating whether to notify the delegation contract\r\n    function setNotifyDelegations(bool notifyDelegations) external; /* onlyMigrationManager */\r\n\r\n    /// Returns the notifications to the delegation contract status\r\n    /// @return notifyDelegations is a bool indicating whether notifications are enabled\r\n    function getNotifyDelegations() external view returns (bool);\r\n}\r\n\r\n// File: contracts/spec_interfaces/IStakingRewards.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Staking rewards contract interface\r\ninterface IStakingRewards {\r\n\r\n    event DelegatorStakingRewardsAssigned(address indexed delegator, uint256 amount, uint256 totalAwarded, address guardian, uint256 delegatorRewardsPerToken, uint256 delegatorRewardsPerTokenDelta);\r\n    event GuardianStakingRewardsAssigned(address indexed guardian, uint256 amount, uint256 totalAwarded, uint256 delegatorRewardsPerToken, uint256 delegatorRewardsPerTokenDelta, uint256 stakingRewardsPerWeight, uint256 stakingRewardsPerWeightDelta);\r\n    event StakingRewardsClaimed(address indexed addr, uint256 claimedDelegatorRewards, uint256 claimedGuardianRewards, uint256 totalClaimedDelegatorRewards, uint256 totalClaimedGuardianRewards);\r\n    event StakingRewardsAllocated(uint256 allocatedRewards, uint256 stakingRewardsPerWeight);\r\n    event GuardianDelegatorsStakingRewardsPercentMilleUpdated(address indexed guardian, uint256 delegatorsStakingRewardsPercentMille);\r\n\r\n    /*\r\n     * External functions\r\n     */\r\n\r\n    /// Returns the current reward balance of the given address.\r\n    /// @dev calculates the up to date balances (differ from the state)\r\n    /// @param addr is the address to query\r\n    /// @return delegatorStakingRewardsBalance the rewards awarded to the guardian role\r\n    /// @return guardianStakingRewardsBalance the rewards awarded to the guardian role\r\n    function getStakingRewardsBalance(address addr) external view returns (uint256 delegatorStakingRewardsBalance, uint256 guardianStakingRewardsBalance);\r\n\r\n    /// Claims the staking rewards balance of an addr, staking the rewards\r\n    /// @dev Claimed rewards are staked in the staking contract using the distributeRewards interface\r\n    /// @dev includes the rewards for both the delegator and guardian roles\r\n    /// @dev calculates the up to date rewards prior to distribute them to the staking contract\r\n    /// @param addr is the address to claim rewards for\r\n    function claimStakingRewards(address addr) external;\r\n\r\n    /// Returns the current global staking rewards state\r\n    /// @dev calculated to the latest block, may differ from the state read\r\n    /// @return stakingRewardsPerWeight is the potential reward per 1E18 (TOKEN_BASE) committee weight assigned to a guardian was in the committee from day zero\r\n    /// @return unclaimedStakingRewards is the of tokens that were assigned to participants and not claimed yet\r\n    function getStakingRewardsState() external view returns (\r\n        uint96 stakingRewardsPerWeight,\r\n        uint96 unclaimedStakingRewards\r\n    );\r\n\r\n    /// Returns the current guardian staking rewards state\r\n    /// @dev calculated to the latest block, may differ from the state read\r\n    /// @dev notice that the guardian rewards are the rewards for the guardian role as guardian and do not include delegation rewards\r\n    /// @dev use getDelegatorStakingRewardsData to get the guardian's rewards as delegator\r\n    /// @param guardian is the guardian to query\r\n    /// @return balance is the staking rewards balance for the guardian role\r\n    /// @return claimed is the staking rewards for the guardian role that were claimed\r\n    /// @return delegatorRewardsPerToken is the potential reward per token (1E18 units) assigned to a guardian's delegator that delegated from day zero\r\n    /// @return delegatorRewardsPerTokenDelta is the increment in delegatorRewardsPerToken since the last guardian update\r\n    /// @return lastStakingRewardsPerWeight is the up to date stakingRewardsPerWeight used for the guardian state calculation\r\n    /// @return stakingRewardsPerWeightDelta is the increment in stakingRewardsPerWeight since the last guardian update\r\n    function getGuardianStakingRewardsData(address guardian) external view returns (\r\n        uint256 balance,\r\n        uint256 claimed,\r\n        uint256 delegatorRewardsPerToken,\r\n        uint256 delegatorRewardsPerTokenDelta,\r\n        uint256 lastStakingRewardsPerWeight,\r\n        uint256 stakingRewardsPerWeightDelta\r\n    );\r\n\r\n    /// Returns the current delegator staking rewards state\r\n    /// @dev calculated to the latest block, may differ from the state read\r\n    /// @param delegator is the delegator to query\r\n    /// @return balance is the staking rewards balance for the delegator role\r\n    /// @return claimed is the staking rewards for the delegator role that were claimed\r\n    /// @return guardian is the guardian the delegator delegated to receiving a portion of the guardian staking rewards\r\n    /// @return lastDelegatorRewardsPerToken is the up to date delegatorRewardsPerToken used for the delegator state calculation\r\n    /// @return delegatorRewardsPerTokenDelta is the increment in delegatorRewardsPerToken since the last delegator update\r\n    function getDelegatorStakingRewardsData(address delegator) external view returns (\r\n        uint256 balance,\r\n        uint256 claimed,\r\n        address guardian,\r\n        uint256 lastDelegatorRewardsPerToken,\r\n        uint256 delegatorRewardsPerTokenDelta\r\n    );\r\n\r\n    /// Returns an estimation for the delegator and guardian staking rewards for a given duration\r\n    /// @dev the returned value is an estimation, assuming no change in the PoS state\r\n    /// @dev the period calculated for start from the current block time until the current time + duration.\r\n    /// @param addr is the address to estimate rewards for\r\n    /// @param duration is the duration to calculate for in seconds\r\n    /// @return estimatedDelegatorStakingRewards is the estimated reward for the delegator role\r\n    /// @return estimatedGuardianStakingRewards is the estimated reward for the guardian role\r\n    function estimateFutureRewards(address addr, uint256 duration) external view returns (\r\n        uint256 estimatedDelegatorStakingRewards,\r\n        uint256 estimatedGuardianStakingRewards\r\n    );\r\n\r\n    /// Sets the guardian's delegators staking reward portion\r\n    /// @dev by default uses the defaultDelegatorsStakingRewardsPercentMille\r\n    /// @param delegatorRewardsPercentMille is the delegators portion in percent-mille (0 - maxDelegatorsStakingRewardsPercentMille)\r\n    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external;\r\n\r\n    /// Returns a guardian's delegators staking reward portion\r\n    /// @dev If not explicitly set, returns the defaultDelegatorsStakingRewardsPercentMille\r\n    /// @return delegatorRewardsRatioPercentMille is the delegators portion in percent-mille\r\n    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external view returns (uint256 delegatorRewardsRatioPercentMille);\r\n\r\n    /// Returns the amount of ORBS tokens in the staking rewards wallet allocated to staking rewards\r\n    /// @dev The staking wallet balance must always larger than the allocated value\r\n    /// @return allocated is the amount of tokens allocated in the staking rewards wallet\r\n    function getStakingRewardsWalletAllocatedTokens() external view returns (uint256 allocated);\r\n\r\n    /// Returns the current annual staking reward rate\r\n    /// @dev calculated based on the current total committee weight\r\n    /// @return annualRate is the current staking reward rate in percent-mille\r\n    function getCurrentStakingRewardsRatePercentMille() external view returns (uint256 annualRate);\r\n\r\n    /// Notifies an expected change in the committee membership of the guardian\r\n    /// @dev Called only by: the Committee contract\r\n    /// @dev called upon expected change in the committee membership of the guardian\r\n    /// @dev triggers update of the global rewards state and the guardian rewards state\r\n    /// @dev updates the rewards state based on the committee state prior to the change\r\n    /// @param guardian is the guardian who's committee membership is updated\r\n    /// @param weight is the weight of the guardian prior to the change\r\n    /// @param totalCommitteeWeight is the total committee weight prior to the change\r\n    /// @param inCommittee indicates whether the guardian was in the committee prior to the change\r\n    /// @param inCommitteeAfter indicates whether the guardian is in the committee after the change\r\n    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external /* onlyCommitteeContract */;\r\n\r\n    /// Notifies an expected change in a delegator and his guardian delegation state\r\n    /// @dev Called only by: the Delegation contract\r\n    /// @dev called upon expected change in a delegator's delegation state\r\n    /// @dev triggers update of the global rewards state, the guardian rewards state and the delegator rewards state\r\n    /// @dev on delegation change, updates also the new guardian and the delegator's lastDelegatorRewardsPerToken accordingly\r\n    /// @param guardian is the delegator's guardian prior to the change\r\n    /// @param guardianDelegatedStake is the delegated stake of the delegator's guardian prior to the change\r\n    /// @param delegator is the delegator about to change delegation state\r\n    /// @param delegatorStake is the stake of the delegator\r\n    /// @param nextGuardian is the delegator's guardian after to the change\r\n    /// @param nextGuardianDelegatedStake is the delegated stake of the delegator's guardian after to the change\r\n    function delegationWillChange(address guardian, uint256 guardianDelegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external /* onlyDelegationsContract */;\r\n\r\n    /*\r\n     * Governance functions\r\n     */\r\n\r\n    event AnnualStakingRewardsRateChanged(uint256 annualRateInPercentMille, uint256 annualCap);\r\n    event DefaultDelegatorsStakingRewardsChanged(uint32 defaultDelegatorsStakingRewardsPercentMille);\r\n    event MaxDelegatorsStakingRewardsChanged(uint32 maxDelegatorsStakingRewardsPercentMille);\r\n    event RewardDistributionActivated(uint256 startTime);\r\n    event RewardDistributionDeactivated();\r\n    event StakingRewardsBalanceMigrated(address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards, address toRewardsContract);\r\n    event StakingRewardsBalanceMigrationAccepted(address from, address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards);\r\n    event EmergencyWithdrawal(address addr, address token);\r\n\r\n    /// Activates staking rewards allocation\r\n    /// @dev governance function called only by the initialization admin\r\n    /// @dev On migrations, startTime should be set to the previous contract deactivation time\r\n    /// @param startTime sets the last assignment time\r\n    function activateRewardDistribution(uint startTime) external /* onlyInitializationAdmin */;\r\n\r\n    /// Deactivates fees and bootstrap allocation\r\n    /// @dev governance function called only by the migration manager\r\n    /// @dev guardians updates remain active based on the current perMember value\r\n    function deactivateRewardDistribution() external /* onlyMigrationManager */;\r\n    \r\n    /// Sets the default delegators staking reward portion\r\n    /// @dev governance function called only by the functional manager\r\n    /// @param defaultDelegatorsStakingRewardsPercentMille is the default delegators portion in percent-mille(0 - maxDelegatorsStakingRewardsPercentMille)\r\n    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager */;\r\n\r\n    /// Returns the default delegators staking reward portion\r\n    /// @return defaultDelegatorsStakingRewardsPercentMille is the default delegators portion in percent-mille\r\n    function getDefaultDelegatorsStakingRewardsPercentMille() external view returns (uint32);\r\n\r\n    /// Sets the maximum delegators staking reward portion\r\n    /// @dev governance function called only by the functional manager\r\n    /// @param maxDelegatorsStakingRewardsPercentMille is the maximum delegators portion in percent-mille(0 - 100,000)\r\n    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager */;\r\n\r\n    /// Returns the default delegators staking reward portion\r\n    /// @return maxDelegatorsStakingRewardsPercentMille is the maximum delegators portion in percent-mille\r\n    function getMaxDelegatorsStakingRewardsPercentMille() external view returns (uint32);\r\n\r\n    /// Sets the annual rate and cap for the staking reward\r\n    /// @dev governance function called only by the functional manager\r\n    /// @param annualRateInPercentMille is the annual rate in percent-mille\r\n    /// @param annualCap is the annual staking rewards cap\r\n    function setAnnualStakingRewardsRate(uint32 annualRateInPercentMille, uint96 annualCap) external /* onlyFunctionalManager */;\r\n\r\n    /// Returns the annual staking reward rate\r\n    /// @return annualStakingRewardsRatePercentMille is the annual rate in percent-mille\r\n    function getAnnualStakingRewardsRatePercentMille() external view returns (uint32);\r\n\r\n    /// Returns the annual staking rewards cap\r\n    /// @return annualStakingRewardsCap is the annual rate in percent-mille\r\n    function getAnnualStakingRewardsCap() external view returns (uint256);\r\n\r\n    /// Checks if rewards allocation is active\r\n    /// @return rewardAllocationActive is a bool that indicates that rewards allocation is active\r\n    function isRewardAllocationActive() external view returns (bool);\r\n\r\n    /// Returns the contract's settings\r\n    /// @return annualStakingRewardsCap is the annual rate in percent-mille\r\n    /// @return annualStakingRewardsRatePercentMille is the annual rate in percent-mille\r\n    /// @return defaultDelegatorsStakingRewardsPercentMille is the default delegators portion in percent-mille\r\n    /// @return maxDelegatorsStakingRewardsPercentMille is the maximum delegators portion in percent-mille\r\n    /// @return rewardAllocationActive is a bool that indicates that rewards allocation is active\r\n    function getSettings() external view returns (\r\n        uint annualStakingRewardsCap,\r\n        uint32 annualStakingRewardsRatePercentMille,\r\n        uint32 defaultDelegatorsStakingRewardsPercentMille,\r\n        uint32 maxDelegatorsStakingRewardsPercentMille,\r\n        bool rewardAllocationActive\r\n    );\r\n\r\n    /// Migrates the staking rewards balance of the given addresses to a new staking rewards contract\r\n    /// @dev The new rewards contract is determined according to the contracts registry\r\n    /// @dev No impact of the calling contract if the currently configured contract in the registry\r\n    /// @dev may be called also while the contract is locked\r\n    /// @param addrs is the list of addresses to migrate\r\n    function migrateRewardsBalance(address[] calldata addrs) external;\r\n\r\n    /// Accepts addresses balance migration from a previous rewards contract\r\n    /// @dev the function may be called by any caller that approves the amounts provided for transfer\r\n    /// @param addrs is the list migrated addresses\r\n    /// @param migratedGuardianStakingRewards is the list of received guardian rewards balance for each address\r\n    /// @param migratedDelegatorStakingRewards is the list of received delegator rewards balance for each address\r\n    /// @param totalAmount is the total amount of staking rewards migrated for all addresses in the list. Must match the sum of migratedGuardianStakingRewards and migratedDelegatorStakingRewards lists.\r\n    function acceptRewardsBalanceMigration(address[] calldata addrs, uint256[] calldata migratedGuardianStakingRewards, uint256[] calldata migratedDelegatorStakingRewards, uint256 totalAmount) external;\r\n\r\n    /// Performs emergency withdrawal of the contract balance\r\n    /// @dev called with a token to withdraw, should be called twice with the fees and bootstrap tokens\r\n    /// @dev governance function called only by the migration manager\r\n    /// @param erc20 is the ERC20 token to withdraw\r\n    function emergencyWithdraw(address erc20) external /* onlyMigrationManager */;\r\n}\r\n\r\n// File: contracts/spec_interfaces/IManagedContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title managed contract interface, used by the contracts registry to notify the contract on updates\r\ninterface IManagedContract /* is ILockable, IContractRegistryAccessor, Initializable */ {\r\n\r\n    /// Refreshes the address of the other contracts the contract interacts with\r\n    /// @dev called by the registry contract upon an update of a contract in the registry\r\n    function refreshContracts() external;\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Contract registry contract interface\r\n/// @dev The contract registry holds Orbs PoS contracts and managers lists\r\n/// @dev The contract registry updates the managed contracts on changes in the contract list\r\n/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \r\n/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \r\n/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \r\ninterface IContractRegistry {\r\n\r\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\r\n\tevent ManagerChanged(string role, address newManager);\r\n\tevent ContractRegistryUpdated(address newContractRegistry);\r\n\r\n\t/*\r\n\t* External functions\r\n\t*/\r\n\r\n    /// Updates the contracts address and emits a corresponding event\r\n    /// @dev governance function called only by the migrationManager or registryAdmin\r\n    /// @param contractName is the contract name, used to identify it\r\n    /// @param addr is the contract updated address\r\n    /// @param managedContract indicates whether the contract is managed by the registry and notified on changes\r\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdminOrMigrationManager */;\r\n\r\n    /// Returns the current address of the given contracts\r\n    /// @param contractName is the contract name, used to identify it\r\n    /// @return addr is the contract updated address\r\n\tfunction getContract(string calldata contractName) external view returns (address);\r\n\r\n    /// Returns the list of contract addresses managed by the registry\r\n    /// @dev Managed contracts are updated on changes in the registry contracts addresses \r\n    /// @return addrs is the list of managed contracts\r\n\tfunction getManagedContracts() external view returns (address[] memory);\r\n\r\n    /// Locks all the managed contracts \r\n    /// @dev governance function called only by the migrationManager or registryAdmin\r\n    /// @dev When set all onlyWhenActive functions will revert\r\n\tfunction lockContracts() external /* onlyAdminOrMigrationManager */;\r\n\r\n    /// Unlocks all the managed contracts \r\n    /// @dev governance function called only by the migrationManager or registryAdmin\r\n\tfunction unlockContracts() external /* onlyAdminOrMigrationManager */;\r\n\t\r\n    /// Updates a manager address and emits a corresponding event\r\n    /// @dev governance function called only by the registryAdmin\r\n    /// @dev the managers list is a flexible list of role to the manager's address\r\n    /// @param role is the managers' role name, for example \"functionalManager\"\r\n    /// @param manager is the manager updated address\r\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\r\n\r\n    /// Returns the current address of the given manager\r\n    /// @param role is the manager name, used to identify it\r\n    /// @return addr is the manager updated address\r\n\tfunction getManager(string calldata role) external view returns (address);\r\n\r\n    /// Sets a new contract registry to migrate to\r\n    /// @dev governance function called only by the registryAdmin\r\n    /// @dev updates the registry address record in all the managed contracts\r\n    /// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\r\n    /// @param newRegistry is the new registry contract \r\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\r\n\r\n    /// Returns the previous contract registry address \r\n    /// @dev used when the setting the contract as a new registry to assure a valid registry\r\n    /// @return previousContractRegistry is the previous contract registry\r\n\tfunction getPreviousContractRegistry() external view returns (address);\r\n}\r\n\r\n// File: contracts/spec_interfaces/IContractRegistryAccessor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IContractRegistryAccessor {\r\n\r\n    /// Sets the contract registry address\r\n    /// @dev governance function called only by an admin\r\n    /// @param newRegistry is the new registry contract \r\n    function setContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\r\n\r\n    /// Returns the contract registry address\r\n    /// @return contractRegistry is the contract registry address\r\n    function getContractRegistry() external view returns (IContractRegistry contractRegistry);\r\n\r\n    function setRegistryAdmin(address _registryAdmin) external /* onlyInitializationAdmin */;\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/WithClaimableRegistryManagement.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract WithClaimableRegistryManagement is Context {\r\n    address private _registryAdmin;\r\n    address private _pendingRegistryAdmin;\r\n\r\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _registryAdmin = msgSender;\r\n        emit RegistryManagementTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current registryAdmin.\r\n     */\r\n    function registryAdmin() public view returns (address) {\r\n        return _registryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the registryAdmin.\r\n     */\r\n    modifier onlyRegistryAdmin() {\r\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current registryAdmin.\r\n     */\r\n    function isRegistryAdmin() public view returns (bool) {\r\n        return _msgSender() == _registryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\r\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\r\n     *\r\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\r\n     * thereby removing any functionality that is only available to the registryAdmin.\r\n     */\r\n    function renounceRegistryManagement() public onlyRegistryAdmin {\r\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\r\n        _registryAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\r\n     */\r\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\r\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\r\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\r\n        _registryAdmin = newRegistryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingManager.\r\n     */\r\n    modifier onlyPendingRegistryAdmin() {\r\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current registryAdmin to set the pendingManager address.\r\n     * @param newRegistryAdmin The address to transfer registryManagement to.\r\n     */\r\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\r\n        _pendingRegistryAdmin = newRegistryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\r\n     */\r\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\r\n        _transferRegistryManagement(_pendingRegistryAdmin);\r\n        _pendingRegistryAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current pendingRegistryAdmin\r\n    */\r\n    function pendingRegistryAdmin() public view returns (address) {\r\n       return _pendingRegistryAdmin;  \r\n    }\r\n}\r\n\r\n// File: contracts/Initializable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Initializable {\r\n\r\n    address private _initializationAdmin;\r\n\r\n    event InitializationComplete();\r\n\r\n    /// Constructor\r\n    /// Sets the initializationAdmin to the contract deployer\r\n    /// The initialization admin may call any manager only function until initializationComplete\r\n    constructor() public{\r\n        _initializationAdmin = msg.sender;\r\n    }\r\n\r\n    modifier onlyInitializationAdmin() {\r\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * External functions\r\n    */\r\n\r\n    /// Returns the initializationAdmin address\r\n    function initializationAdmin() public view returns (address) {\r\n        return _initializationAdmin;\r\n    }\r\n\r\n    /// Finalizes the initialization and revokes the initializationAdmin role \r\n    function initializationComplete() external onlyInitializationAdmin {\r\n        _initializationAdmin = address(0);\r\n        emit InitializationComplete();\r\n    }\r\n\r\n    /// Checks if the initialization was completed\r\n    function isInitializationComplete() public view returns (bool) {\r\n        return _initializationAdmin == address(0);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ContractRegistryAccessor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\ncontract ContractRegistryAccessor is IContractRegistryAccessor, WithClaimableRegistryManagement, Initializable {\r\n\r\n    IContractRegistry private contractRegistry;\r\n\r\n    /// Constructor\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\r\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\r\n        setContractRegistry(_contractRegistry);\r\n        _transferRegistryManagement(_registryAdmin);\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationManager {\r\n        require(isMigrationManager(), \"sender is not the migration manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyFunctionalManager {\r\n        require(isFunctionalManager(), \"sender is not the functional manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    /// Checks whether the caller is Admin: either the contract registry, the registry admin, or the initialization admin\r\n    function isAdmin() internal view returns (bool) {\r\n        return msg.sender == address(contractRegistry) || msg.sender == registryAdmin() || msg.sender == initializationAdmin();\r\n    }\r\n\r\n    /// Checks whether the caller is a specific manager role or and Admin\r\n    /// @dev queries the registry contract for the up to date manager assignment\r\n    function isManager(string memory role) internal view returns (bool) {\r\n        IContractRegistry _contractRegistry = contractRegistry;\r\n        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;\r\n    }\r\n\r\n    /// Checks whether the caller is the migration manager\r\n    function isMigrationManager() internal view returns (bool) {\r\n        return isManager('migrationManager');\r\n    }\r\n\r\n    /// Checks whether the caller is the functional manager\r\n    function isFunctionalManager() internal view returns (bool) {\r\n        return isManager('functionalManager');\r\n    }\r\n\r\n    /* \r\n     * Contract getters, return the address of a contract by calling the contract registry \r\n     */ \r\n\r\n    function getProtocolContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"protocol\");\r\n    }\r\n\r\n    function getStakingRewardsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingRewards\");\r\n    }\r\n\r\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\r\n    }\r\n\r\n    function getCommitteeContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"committee\");\r\n    }\r\n\r\n    function getElectionsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"elections\");\r\n    }\r\n\r\n    function getDelegationsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"delegations\");\r\n    }\r\n\r\n    function getGuardiansRegistrationContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"guardiansRegistration\");\r\n    }\r\n\r\n    function getCertificationContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"certification\");\r\n    }\r\n\r\n    function getStakingContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"staking\");\r\n    }\r\n\r\n    function getSubscriptionsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"subscriptions\");\r\n    }\r\n\r\n    function getStakingRewardsWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\r\n    }\r\n\r\n    function getBootstrapRewardsWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\r\n    }\r\n\r\n    function getGeneralFeesWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"generalFeesWallet\");\r\n    }\r\n\r\n    function getCertifiedFeesWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\r\n    }\r\n\r\n    function getStakingContractHandler() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingContractHandler\");\r\n    }\r\n\r\n    /*\r\n    * Governance functions\r\n    */\r\n\r\n    event ContractRegistryAddressUpdated(address addr);\r\n\r\n    /// Sets the contract registry address\r\n    /// @dev governance function called only by an admin\r\n    /// @param newContractRegistry is the new registry contract \r\n    function setContractRegistry(IContractRegistry newContractRegistry) public override onlyAdmin {\r\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\r\n        contractRegistry = newContractRegistry;\r\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\r\n    }\r\n\r\n    /// Returns the contract registry that the contract is set to use\r\n    /// @return contractRegistry is the registry contract address\r\n    function getContractRegistry() public override view returns (IContractRegistry) {\r\n        return contractRegistry;\r\n    }\r\n\r\n    function setRegistryAdmin(address _registryAdmin) external override onlyInitializationAdmin {\r\n        _transferRegistryManagement(_registryAdmin);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/ILockable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title lockable contract interface, allows to lock a contract\r\ninterface ILockable {\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    /// Locks the contract to external non-governance function calls\r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon locking all managed contracts\r\n    /// @dev getters and migration functions remain active also for locked contracts\r\n    /// @dev checked by the onlyWhenActive modifier\r\n    function lock() external /* onlyMigrationManager */;\r\n\r\n    /// Unlocks the contract \r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\r\n    function unlock() external /* onlyMigrationManager */;\r\n\r\n    /// Returns the contract locking status\r\n    /// @return isLocked is a bool indicating the contract is locked \r\n    function isLocked() view external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/Lockable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/// @title lockable contract\r\ncontract Lockable is ILockable, ContractRegistryAccessor {\r\n\r\n    bool public locked;\r\n\r\n    /// Constructor\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\r\n\r\n    /// Locks the contract to external non-governance function calls\r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon locking all managed contracts\r\n    /// @dev getters and migration functions remain active also for locked contracts\r\n    /// @dev checked by the onlyWhenActive modifier\r\n    function lock() external override onlyMigrationManager {\r\n        locked = true;\r\n        emit Locked();\r\n    }\r\n\r\n    /// Unlocks the contract \r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\r\n    function unlock() external override onlyMigrationManager {\r\n        locked = false;\r\n        emit Unlocked();\r\n    }\r\n\r\n    /// Returns the contract locking status\r\n    /// @return isLocked is a bool indicating the contract is locked \r\n    function isLocked() external override view returns (bool) {\r\n        return locked;\r\n    }\r\n\r\n    modifier onlyWhenActive() {\r\n        require(!locked, \"contract is locked for this operation\");\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/ManagedContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/// @title managed contract\r\ncontract ManagedContract is IManagedContract, Lockable {\r\n\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\r\n\r\n    /// Refreshes the address of the other contracts the contract interacts with\r\n    /// @dev called by the registry contract upon an update of a contract in the registry\r\n    function refreshContracts() virtual override external {}\r\n\r\n}\r\n\r\n// File: contracts/Delegations.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Delegations contract\r\ncontract Delegations is IDelegations, IStakeChangeNotifier, ManagedContract {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath96 for uint96;\r\n\r\n\taddress constant public VOID_ADDR = address(-1);\r\n\r\n\tstruct StakeOwnerData {\r\n\t\taddress delegation;\r\n\t\tuint96 stake;\r\n\t}\r\n\tmapping(address => StakeOwnerData) public stakeOwnersData;\r\n\tmapping(address => uint256) public uncappedDelegatedStake;\r\n\r\n\tuint256 totalDelegatedStake;\r\n\r\n\tstruct DelegateStatus {\r\n\t\taddress addr;\r\n\t\tuint256 uncappedDelegatedStake;\r\n\t\tbool isSelfDelegating;\r\n\t\tuint256 delegatedStake;\r\n\t\tuint96 selfDelegatedStake;\r\n\t}\r\n\r\n    /// Constructor\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n\tconstructor(IContractRegistry _contractRegistry, address _registryAdmin) ManagedContract(_contractRegistry, _registryAdmin) public {\r\n\t\taddress VOID_ADDRESS_DUMMY_DELEGATION = address(-2);\r\n\t\tassert(VOID_ADDR != VOID_ADDRESS_DUMMY_DELEGATION && VOID_ADDR != address(0) && VOID_ADDRESS_DUMMY_DELEGATION != address(0));\r\n\t\tstakeOwnersData[VOID_ADDR].delegation = VOID_ADDRESS_DUMMY_DELEGATION;\r\n\t}\r\n\r\n\tmodifier onlyStakingContractHandler() {\r\n\t\trequire(msg.sender == address(stakingContractHandler), \"caller is not the staking contract handler\");\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t/*\r\n\t* External functions\r\n\t*/\r\n\r\n    /// Delegate your stake\r\n    /// @dev updates the election contract on the changes in the delegated stake\r\n    /// @dev updates the rewards contract on the upcoming change in the delegator's delegation state\r\n    /// @param to is the address to delegate to\r\n\tfunction delegate(address to) external override onlyWhenActive {\r\n\t\tdelegateFrom(msg.sender, to);\r\n\t}\r\n\r\n    /// Refresh the address stake for delegation power based on the staking contract\r\n    /// @dev Disabled stake change update notifications from the staking contract may create mismatches\r\n    /// @dev refreshStake re-syncs the stake data with the staking contract\r\n    /// @param addr is the address to refresh its stake\r\n\tfunction refreshStake(address addr) external override onlyWhenActive {\r\n\t\t_stakeChange(addr, stakingContractHandler.getStakeBalanceOf(addr));\r\n\t}\r\n\r\n    /// Refresh the addresses stake for delegation power based on the staking contract\r\n    /// @dev Batched version of refreshStake\r\n    /// @dev Disabled stake change update notifications from the staking contract may create mismatches\r\n    /// @dev refreshStakeBatch re-syncs the stake data with the staking contract\r\n    /// @param addrs is the list of addresses to refresh their stake\r\n\tfunction refreshStakeBatch(address[] calldata addrs) external override onlyWhenActive {\r\n\t\tfor (uint i = 0; i < addrs.length; i++) {\r\n\t\t\t_stakeChange(addrs[i], stakingContractHandler.getStakeBalanceOf(addrs[i]));\r\n\t\t}\r\n\t}\r\n\r\n    /// Returns the delegate address of the given address\r\n    /// @param addr is the address to query\r\n    /// @return delegation is the address the addr delegated to\r\n\tfunction getDelegation(address addr) external override view returns (address) {\r\n\t\treturn getStakeOwnerData(addr).delegation;\r\n\t}\r\n\r\n    /// Returns a delegator info\r\n    /// @param addr is the address to query\r\n    /// @return delegation is the address the addr delegated to\r\n    /// @return delegatorStake is the stake of the delegator as reflected in the delegation contract\r\n\tfunction getDelegationInfo(address addr) external override view returns (address delegation, uint256 delegatorStake) {\r\n\t\tStakeOwnerData memory data = getStakeOwnerData(addr);\r\n\t\treturn (data.delegation, data.stake);\r\n\t}\r\n\r\n    /// Returns the delegated stake of an addr \r\n    /// @dev an address that is not self delegating has a 0 delegated stake\r\n    /// @param addr is the address to query\r\n    /// @return delegatedStake is the address delegated stake\r\n\tfunction getDelegatedStake(address addr) external override view returns (uint256) {\r\n\t\treturn getDelegateStatus(addr).delegatedStake;\r\n\t}\r\n\r\n    /// Returns the total delegated stake\r\n    /// @dev delegatedStake - the total stake delegated to an address that is self delegating\r\n    /// @dev the delegated stake of a non self-delegated address is 0\r\n    /// @return totalDelegatedStake is the total delegatedStake of all the addresses\r\n\tfunction getTotalDelegatedStake() external override view returns (uint256) {\r\n\t\treturn totalDelegatedStake;\r\n\t}\r\n\r\n\t/*\r\n\t* Notifications from staking contract (IStakeChangeNotifier)\r\n\t*/\r\n\r\n    /// Notifies of stake change event.\r\n    /// @param _stakeOwner is the address of the subject stake owner.\r\n    /// @param _updatedStake is the updated total staked amount.\r\n\tfunction stakeChange(address _stakeOwner, uint256, bool, uint256 _updatedStake) external override onlyStakingContractHandler onlyWhenActive {\r\n\t\t_stakeChange(_stakeOwner, _updatedStake);\r\n\t}\r\n\r\n    /// Notifies of multiple stake change events.\r\n    /// @param _stakeOwners is the addresses of subject stake owners.\r\n    /// @param _amounts is the differences in total staked amounts.\r\n    /// @param _signs is the signs of the added (true) or subtracted (false) amounts.\r\n    /// @param _updatedStakes is the updated total staked amounts.\r\n\tfunction stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs, uint256[] calldata _updatedStakes) external override onlyStakingContractHandler onlyWhenActive {\r\n\t\tuint batchLength = _stakeOwners.length;\r\n\t\trequire(batchLength == _amounts.length, \"_stakeOwners, _amounts - array length mismatch\");\r\n\t\trequire(batchLength == _signs.length, \"_stakeOwners, _signs - array length mismatch\");\r\n\t\trequire(batchLength == _updatedStakes.length, \"_stakeOwners, _updatedStakes - array length mismatch\");\r\n\r\n\t\tfor (uint i = 0; i < _stakeOwners.length; i++) {\r\n\t\t\t_stakeChange(_stakeOwners[i], _updatedStakes[i]);\r\n\t\t}\r\n\t}\r\n\r\n    /// Notifies of stake migration event.\r\n    /// @dev Empty function. A staking contract migration may be handled in the future in the StakingContractHandler \r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The migrated amount.\r\n\tfunction stakeMigration(address _stakeOwner, uint256 _amount) external override onlyStakingContractHandler onlyWhenActive {}\r\n\r\n\t/*\r\n\t* Governance functions\r\n\t*/\r\n\r\n    /// Imports delegations during initial migration\r\n    /// @dev initialization function called only by the initializationManager\r\n    /// @dev Does not update the Rewards or Election contracts\r\n    /// @dev assumes deactivated Rewards\r\n    /// @param from is a list of delegator addresses\r\n    /// @param to is the address the delegators delegate to\r\n\tfunction importDelegations(address[] calldata from, address to) external override onlyInitializationAdmin {\r\n\t\trequire(to != address(0), \"to must be a non zero address\");\r\n\t\trequire(from.length > 0, \"from array must contain at least one address\");\r\n\t\t(uint96 stakingRewardsPerWeight, ) = stakingRewardsContract.getStakingRewardsState();\r\n\t\trequire(stakingRewardsPerWeight == 0, \"no rewards may be allocated prior to importing delegations\");\r\n\r\n\t\tuint256 uncappedDelegatedStakeDelta = 0;\r\n\t\tStakeOwnerData memory data;\r\n\t\tuint256 newTotalDelegatedStake = totalDelegatedStake;\r\n\t\tDelegateStatus memory delegateStatus = getDelegateStatus(to);\r\n\t\tIStakingContractHandler _stakingContractHandler = stakingContractHandler;\r\n\t\tuint256 delegatorUncapped;\r\n\t\tuint256[] memory delegatorsStakes = new uint256[](from.length);\r\n\t\tfor (uint i = 0; i < from.length; i++) {\r\n\t\t\tdata = stakeOwnersData[from[i]];\r\n\t\t\trequire(data.delegation == address(0), \"import allowed only for uninitialized accounts. existing delegation detected\");\r\n\t\t\trequire(from[i] != to, \"import cannot be used for self-delegation (already self delegated)\");\r\n\t\t\trequire(data.stake == 0 , \"import allowed only for uninitialized accounts. existing stake detected\");\r\n\r\n\t\t\t// from[i] stops being self delegating. any uncappedDelegatedStake it has now stops being counted towards totalDelegatedStake\r\n\t\t\tdelegatorUncapped = uncappedDelegatedStake[from[i]];\r\n\t\t\tif (delegatorUncapped > 0) {\r\n\t\t\t\tnewTotalDelegatedStake = newTotalDelegatedStake.sub(delegatorUncapped);\r\n\t\t\t\temit DelegatedStakeChanged(\r\n\t\t\t\t\tfrom[i],\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\tfrom[i],\r\n\t\t\t\t\t0\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// update state\r\n\t\t\tdata.delegation = to;\r\n\t\t\tdata.stake = uint96(_stakingContractHandler.getStakeBalanceOf(from[i]));\r\n\t\t\tstakeOwnersData[from[i]] = data;\r\n\r\n\t\t\tuncappedDelegatedStakeDelta = uncappedDelegatedStakeDelta.add(data.stake);\r\n\r\n\t\t\t// store individual stake for event\r\n\t\t\tdelegatorsStakes[i] = data.stake;\r\n\r\n\t\t\temit Delegated(from[i], to);\r\n\r\n\t\t\temit DelegatedStakeChanged(\r\n\t\t\t\tto,\r\n\t\t\t\tdelegateStatus.selfDelegatedStake,\r\n\t\t\t\tdelegateStatus.isSelfDelegating ? delegateStatus.delegatedStake.add(uncappedDelegatedStakeDelta) : 0,\r\n\t\t\t\tfrom[i],\r\n\t\t\t\tdata.stake\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// update totals\r\n\t\tuncappedDelegatedStake[to] = uncappedDelegatedStake[to].add(uncappedDelegatedStakeDelta);\r\n\r\n\t\tif (delegateStatus.isSelfDelegating) {\r\n\t\t\tnewTotalDelegatedStake = newTotalDelegatedStake.add(uncappedDelegatedStakeDelta);\r\n\t\t}\r\n\t\ttotalDelegatedStake = newTotalDelegatedStake;\r\n\r\n\t\t// emit events\r\n\t\temit DelegationsImported(from, to);\r\n\t}\r\n\r\n    /// Initializes the delegation of an address during initial migration \r\n    /// @dev initialization function called only by the initializationManager\r\n    /// @dev behaves identically to a delegate transaction sent by the delegator\r\n    /// @param from is the delegator addresses\r\n    /// @param to is the delegator delegates to\r\n\tfunction initDelegation(address from, address to) external override onlyInitializationAdmin {\r\n\t\tdelegateFrom(from, to);\r\n\t\temit DelegationInitialized(from, to);\r\n\t}\r\n\r\n\t/*\r\n\t* Private functions\r\n\t*/\r\n\r\n    /// Generates and returns an internal memory structure with a Delegate status\r\n    /// @dev updated based on the up to date state\r\n    /// @dev status.addr is the queried address\r\n    /// @dev status.uncappedDelegatedStake is the amount delegated to address including self-delegated stake\r\n    /// @dev status.isSelfDelegating indicates whether the address is self-delegated\r\n    /// @dev status.selfDelegatedStake if the addr is self-delegated is  the addr self stake. 0 if not self-delegated\r\n    /// @dev status.delegatedStake if the addr is self-delegated is the mount delegated to address. 0 if not self-delegated\r\n\tfunction getDelegateStatus(address addr) private view returns (DelegateStatus memory status) {\r\n\t\tStakeOwnerData memory data = getStakeOwnerData(addr);\r\n\r\n\t\tstatus.addr = addr;\r\n\t\tstatus.uncappedDelegatedStake = uncappedDelegatedStake[addr];\r\n\t\tstatus.isSelfDelegating = data.delegation == addr;\r\n\t\tstatus.selfDelegatedStake = status.isSelfDelegating ? data.stake : 0;\r\n\t\tstatus.delegatedStake = status.isSelfDelegating ? status.uncappedDelegatedStake : 0;\r\n\r\n\t\treturn status;\r\n\t}\r\n\r\n    /// Returns an address stake and delegation data. \r\n    /// @dev implicitly self-delegated addresses (delegation = 0) return delegation to the address\r\n\tfunction getStakeOwnerData(address addr) private view returns (StakeOwnerData memory data) {\r\n\t\tdata = stakeOwnersData[addr];\r\n\t\tdata.delegation = (data.delegation == address(0)) ? addr : data.delegation;\r\n\t\treturn data;\r\n\t}\r\n\r\n\tstruct DelegateFromVars {\r\n\t\tDelegateStatus prevDelegateStatusBefore;\r\n\t\tDelegateStatus newDelegateStatusBefore;\r\n\t\tDelegateStatus prevDelegateStatusAfter;\r\n\t\tDelegateStatus newDelegateStatusAfter;\r\n\t}\r\n\r\n    /// Handles a delegation change\r\n    /// @dev notifies the rewards contract on the expected change (with data prior to the change)\r\n    /// @dev updates the impacted delegates delegated stake and the total stake\r\n    /// @dev notifies the election contract on changes in the impacted delegates delegated stake\r\n    /// @param from is the delegator address \r\n    /// @param to is the delegate address\r\n\tfunction delegateFrom(address from, address to) private {\r\n\t\trequire(to != address(0), \"cannot delegate to a zero address\");\r\n\r\n\t\tDelegateFromVars memory vars;\r\n\r\n\t\tStakeOwnerData memory delegatorData = getStakeOwnerData(from);\r\n\t\taddress prevDelegate = delegatorData.delegation;\r\n\r\n\t\tif (to == prevDelegate) return; // Delegation hasn't changed\r\n\r\n\t\t// Optimization - no need for the full flow in the case of a zero staked delegator with no delegations\r\n\t\tif (delegatorData.stake == 0 && uncappedDelegatedStake[from] == 0) {\r\n\t\t\tstakeOwnersData[from].delegation = to;\r\n\t\t\temit Delegated(from, to);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvars.prevDelegateStatusBefore = getDelegateStatus(prevDelegate);\r\n\t\tvars.newDelegateStatusBefore = getDelegateStatus(to);\r\n\r\n\t\tstakingRewardsContract.delegationWillChange(prevDelegate, vars.prevDelegateStatusBefore.delegatedStake, from, delegatorData.stake, to, vars.newDelegateStatusBefore.delegatedStake);\r\n\r\n\t\tstakeOwnersData[from].delegation = to;\r\n\r\n\t\tuint256 delegatorStake = delegatorData.stake;\r\n\r\n\t\tuncappedDelegatedStake[prevDelegate] = vars.prevDelegateStatusBefore.uncappedDelegatedStake.sub(delegatorStake);\r\n\t\tuncappedDelegatedStake[to] = vars.newDelegateStatusBefore.uncappedDelegatedStake.add(delegatorStake);\r\n\r\n\t\tvars.prevDelegateStatusAfter = getDelegateStatus(prevDelegate);\r\n\t\tvars.newDelegateStatusAfter = getDelegateStatus(to);\r\n\r\n\t\tuint256 _totalDelegatedStake = totalDelegatedStake.sub(\r\n\t\t\tvars.prevDelegateStatusBefore.delegatedStake\r\n\t\t).add(\r\n\t\t\tvars.prevDelegateStatusAfter.delegatedStake\r\n\t\t).sub(\r\n\t\t\tvars.newDelegateStatusBefore.delegatedStake\r\n\t\t).add(\r\n\t\t\tvars.newDelegateStatusAfter.delegatedStake\r\n\t\t);\r\n\r\n\t\ttotalDelegatedStake = _totalDelegatedStake;\r\n\r\n\t\temit Delegated(from, to);\r\n\r\n\t\tIElections _electionsContract = electionsContract;\r\n\r\n\t\tif (vars.prevDelegateStatusBefore.delegatedStake != vars.prevDelegateStatusAfter.delegatedStake) {\r\n\t\t\t_electionsContract.delegatedStakeChange(\r\n\t\t\t\tprevDelegate,\r\n\t\t\t\tvars.prevDelegateStatusAfter.selfDelegatedStake,\r\n\t\t\t\tvars.prevDelegateStatusAfter.delegatedStake,\r\n\t\t\t\t_totalDelegatedStake\r\n\t\t\t);\r\n\r\n\t\t\temit DelegatedStakeChanged(\r\n\t\t\t\tprevDelegate,\r\n\t\t\t\tvars.prevDelegateStatusAfter.selfDelegatedStake,\r\n\t\t\t\tvars.prevDelegateStatusAfter.delegatedStake,\r\n\t\t\t\tfrom,\r\n\t\t\t\t0\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (vars.newDelegateStatusBefore.delegatedStake != vars.newDelegateStatusAfter.delegatedStake) {\r\n\t\t\t_electionsContract.delegatedStakeChange(\r\n\t\t\t\tto,\r\n\t\t\t\tvars.newDelegateStatusAfter.selfDelegatedStake,\r\n\t\t\t\tvars.newDelegateStatusAfter.delegatedStake,\r\n\t\t\t\t_totalDelegatedStake\r\n\t\t\t);\r\n\r\n\t\t\temit DelegatedStakeChanged(\r\n\t\t\t\tto,\r\n\t\t\t\tvars.newDelegateStatusAfter.selfDelegatedStake,\r\n\t\t\t\tvars.newDelegateStatusAfter.delegatedStake,\r\n\t\t\t\tfrom,\r\n\t\t\t\tdelegatorStake\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n    /// Handles a change in a stake owner stake\r\n    /// @dev notifies the rewards contract on the expected change (with data prior to the change)\r\n    /// @dev updates the impacted delegate delegated stake and the total stake\r\n    /// @dev notifies the election contract on changes in the impacted delegate delegated stake\r\n    /// @param _stakeOwner is the stake owner\r\n    /// @param _updatedStake is the stake owner stake after the change\r\n\tfunction _stakeChange(address _stakeOwner, uint256 _updatedStake) private {\r\n\t\tStakeOwnerData memory stakeOwnerDataBefore = getStakeOwnerData(_stakeOwner);\r\n\t\tDelegateStatus memory delegateStatusBefore = getDelegateStatus(stakeOwnerDataBefore.delegation);\r\n\r\n\t\tuint256 prevUncappedStake = delegateStatusBefore.uncappedDelegatedStake;\r\n\t\tuint256 newUncappedStake = prevUncappedStake.sub(stakeOwnerDataBefore.stake).add(_updatedStake);\r\n\r\n\t\tstakingRewardsContract.delegationWillChange(stakeOwnerDataBefore.delegation, delegateStatusBefore.delegatedStake, _stakeOwner, stakeOwnerDataBefore.stake, stakeOwnerDataBefore.delegation, delegateStatusBefore.delegatedStake);\r\n\r\n\t\tuncappedDelegatedStake[stakeOwnerDataBefore.delegation] = newUncappedStake;\r\n\r\n\t\trequire(uint256(uint96(_updatedStake)) == _updatedStake, \"Delegations::updatedStakes value too big (>96 bits)\");\r\n\t\tstakeOwnersData[_stakeOwner].stake = uint96(_updatedStake);\r\n\r\n\t\tuint256 _totalDelegatedStake = totalDelegatedStake;\r\n\t\tif (delegateStatusBefore.isSelfDelegating) {\r\n\t\t\t_totalDelegatedStake = _totalDelegatedStake.sub(stakeOwnerDataBefore.stake).add(_updatedStake);\r\n\t\t\ttotalDelegatedStake = _totalDelegatedStake;\r\n\t\t}\r\n\r\n\t\tDelegateStatus memory delegateStatusAfter = getDelegateStatus(stakeOwnerDataBefore.delegation);\r\n\r\n\t\telectionsContract.delegatedStakeChange(\r\n\t\t\tstakeOwnerDataBefore.delegation,\r\n\t\t\tdelegateStatusAfter.selfDelegatedStake,\r\n\t\t\tdelegateStatusAfter.delegatedStake,\r\n\t\t\t_totalDelegatedStake\r\n\t\t);\r\n\r\n\t\tif (_updatedStake != stakeOwnerDataBefore.stake) {\r\n\t\t\temit DelegatedStakeChanged(\r\n\t\t\t\tstakeOwnerDataBefore.delegation,\r\n\t\t\t\tdelegateStatusAfter.selfDelegatedStake,\r\n\t\t\t\tdelegateStatusAfter.delegatedStake,\r\n\t\t\t\t_stakeOwner,\r\n\t\t\t\t_updatedStake\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n     * Contracts topology / registry interface\r\n     */\r\n\r\n\tIElections electionsContract;\r\n\tIStakingRewards stakingRewardsContract;\r\n\tIStakingContractHandler stakingContractHandler;\r\n\r\n    /// Refreshes the address of the other contracts the contract interacts with\r\n    /// @dev called by the registry contract upon an update of a contract in the registry\r\n\tfunction refreshContracts() external override {\r\n\t\telectionsContract = IElections(getElectionsContract());\r\n\t\tstakingContractHandler = IStakingContractHandler(getStakingContractHandler());\r\n\t\tstakingRewardsContract = IStakingRewards(getStakingRewardsContract());\r\n\t}\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Delegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"selfDelegatedStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegatorContributedStake\",\"type\":\"uint256\"}],\"name\":\"DelegatedStakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DelegationInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"from\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DelegationsImported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitializationComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRegistryAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"RegistryManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VOID_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractRegistry\",\"outputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDelegation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDelegationInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delegatorStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"from\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"importDelegations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"initDelegation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitializationComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRegistryAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRegistryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"refreshStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"refreshStakeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"newContractRegistry\",\"type\":\"address\"}],\"name\":\"setContractRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"}],\"name\":\"setRegistryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_updatedStake\",\"type\":\"uint256\"}],\"name\":\"stakeChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakeOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_signs\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_updatedStakes\",\"type\":\"uint256[]\"}],\"name\":\"stakeChangeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeOwnersData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegation\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"stake\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"transferRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uncappedDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Delegations","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000d859701c81119ab12a1e62af6270ad2ae05c7ab3000000000000000000000000f1fd5233e60e7ef797025fe9dd066d60d59bcb92","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://190f4d45b81ab198cc49e7d4a1fbb315f40402e0142e6481bfbe091e58ec8360"}]}