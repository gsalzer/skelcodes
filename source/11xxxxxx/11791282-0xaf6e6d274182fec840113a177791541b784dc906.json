{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TokenVestingPools {\r\n    using SafeMath for uint256;\r\n\r\n    struct UserInfo{\r\n        uint256 lockedAmount;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    struct PoolInfo{\r\n        uint256 startReleasingTime;\r\n        uint256 batchPeriod;\r\n        uint256 batchCount;\r\n        uint256 totalLocked;\r\n        uint8 index;\r\n        string name;\r\n    }\r\n    \r\n    IERC20 public lockedToken;\r\n    \r\n    PoolInfo[] public lockPools;\r\n    \r\n    mapping (uint8 => mapping (address => UserInfo)) internal userInfo;\r\n\r\n    event Claim(uint8 pid, address indexed beneficiary, uint value);\r\n\r\n\r\n    constructor(address _token) internal{\r\n        lockedToken = IERC20(_token);\r\n    }\r\n\r\n    function _addVestingPool(string memory _name, uint256 _startReleasingTime, uint256 _batchCount,  uint256 _batchPeriod) internal returns(uint8){\r\n        \r\n        lockPools.push(PoolInfo({\r\n            name: _name,\r\n            startReleasingTime: _startReleasingTime,\r\n            batchPeriod: _batchPeriod,\r\n            batchCount: _batchCount,\r\n            totalLocked:0,\r\n            index:(uint8)(lockPools.length)\r\n        }));\r\n\r\n        return (uint8)(lockPools.length) -1;\r\n    }\r\n\r\n    function _addBeneficiary(uint8 _pid, address _beneficiary, uint256 _lockedTokensCount) internal{\r\n\r\n        require(_pid < lockPools.length, \"non existing pool\");\r\n        require(userInfo[_pid][_beneficiary].lockedAmount == 0, \"existing beneficiary\"); //can add Beneficiary only once to a pool\r\n\r\n        userInfo[_pid][_beneficiary].lockedAmount = _lockedTokensCount * 1e18;\r\n        lockPools[_pid].totalLocked = lockPools[_pid].totalLocked.add(userInfo[_pid][_beneficiary].lockedAmount);\r\n    }\r\n\r\n     function claim(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n        emit Claim(_pid, msg.sender, amount);\r\n    }\r\n    \r\n    function claim2(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n       \r\n    }\r\n    \r\n    function claim3(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        if(amount >0){\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        emit Claim(_pid, msg.sender, amount);\r\n        }\r\n       \r\n    }\r\n    function claim4(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        if(amount >0){\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n        }\r\n       \r\n    }\r\n    \r\n    function claim5(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        //require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n        emit Claim(_pid, msg.sender, amount);\r\n    }\r\n    \r\n    function claim6(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        //require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n       \r\n    }\r\n\r\n    function getReleasableAmount(uint8 _pid, address _beneficiary) public  view returns(uint256){\r\n        return getVestedAmount(_pid, _beneficiary, getCurrentTime()).sub(userInfo[_pid][_beneficiary].withdrawn);\r\n    }\r\n\r\n\r\n    function getVestedAmount(uint8 _pid, address _beneficiary, uint256 _time) public  view returns(uint256){\r\n\r\n        if (_pid >= lockPools.length){\r\n            return 0;\r\n        }\r\n\r\n        // if time < StartReleasingTime: then return 0\r\n        if(_time < lockPools[_pid].startReleasingTime){\r\n            return 0;\r\n        }\r\n\r\n        uint256 lockedAmount = userInfo[_pid][_beneficiary].lockedAmount;\r\n\r\n        // if locked amount 0 return 0\r\n        if (lockedAmount == 0){\r\n            return 0;\r\n        }\r\n\r\n        // elapsedBatchCount = ((time - startReleasingTime) / batchPeriod) + 1\r\n        uint256 elapsedBatchCount =\r\n                    _time.sub(lockPools[_pid].startReleasingTime)\r\n                    .div(lockPools[_pid].batchPeriod)\r\n                    .add(1);\r\n\r\n        // vestedAmount = lockedAmount  * elapsedBatchCount / batchCount\r\n        uint256  vestedAmount =\r\n                    lockedAmount\r\n                    .mul(elapsedBatchCount)\r\n                    .div(lockPools[_pid].batchCount);\r\n\r\n        if(vestedAmount > lockedAmount){\r\n            vestedAmount = lockedAmount;\r\n        }\r\n\r\n        return vestedAmount;\r\n    }\r\n\r\n    function getBeneficiaryInfo(uint8 _pid, address _beneficiary) public view \r\n        returns(address beneficiary, \r\n                uint256 totalLocked, \r\n                uint256 withdrawn, \r\n                uint256 releasableAmount, \r\n                uint256 nextBatchTime, \r\n                uint256 currentTime){\r\n\r\n        beneficiary = _beneficiary;\r\n        currentTime = getCurrentTime();\r\n        if(_pid < lockPools.length){\r\n            totalLocked = userInfo[_pid][_beneficiary].lockedAmount;\r\n            withdrawn = userInfo[_pid][_beneficiary].withdrawn;\r\n            releasableAmount = getReleasableAmount(_pid, _beneficiary);\r\n            nextBatchTime = getNextBatchTime(_pid, _beneficiary, currentTime);\r\n        }\r\n    }\r\n\r\n    function getSenderInfo(uint8 _pid) external view returns(address beneficiary, uint256 totalLocked, uint256 withdrawaned, uint256 releasableAmount, uint256 nextBatchTime, uint256 currentTime){\r\n        return getBeneficiaryInfo(_pid, msg.sender);\r\n    }\r\n\r\n    function getNextBatchTime(uint8 _pid, address _beneficiary, uint256 _time) public view returns(uint256){\r\n\r\n        // if total vested equal to total locked then return 0\r\n        if(getVestedAmount(_pid, _beneficiary, _time) == userInfo[_pid][_beneficiary].lockedAmount){\r\n            return 0;\r\n        }\r\n\r\n        // if time less than startReleasingTime: then return sartReleasingTime\r\n        if(_time <= lockPools[_pid].startReleasingTime){\r\n            return lockPools[_pid].startReleasingTime;\r\n        }\r\n\r\n        // find the next batch time\r\n         uint256 elapsedBatchCount =\r\n                    _time.sub(lockPools[_pid].startReleasingTime)\r\n                    .div(lockPools[_pid].batchPeriod)\r\n                    .add(1);\r\n\r\n        uint256 nextBatchTime =\r\n                    elapsedBatchCount\r\n                    .mul(lockPools[_pid].batchPeriod)\r\n                    .add(lockPools[_pid].startReleasingTime);\r\n\r\n        return nextBatchTime;\r\n\r\n    }\r\n\r\n    function getPoolsCount() external view returns(uint256 poolsCount){\r\n        return lockPools.length;\r\n    }\r\n\r\n    function getPoolInfo(uint8 _pid) external view returns(\r\n                string memory name,\r\n                uint256 totalLocked,\r\n                uint256  startReleasingTime,\r\n                uint256  batchCount,\r\n                uint256  batchPeriodInDays){\r\n                    \r\n        if(_pid < lockPools.length){\r\n            name = lockPools[_pid].name;\r\n            totalLocked = lockPools[_pid].totalLocked;\r\n            startReleasingTime = lockPools[_pid].startReleasingTime;\r\n            batchCount = lockPools[_pid].batchCount;\r\n            batchPeriodInDays = lockPools[_pid].batchPeriod.div(1 days);\r\n        }\r\n    }\r\n\r\n    function getTotalLocked() external view returns(uint256 totalLocked){\r\n        totalLocked =0;\r\n\r\n        for(uint8 i=0; i<lockPools.length; i++){\r\n            totalLocked = totalLocked.add(lockPools[i].totalLocked);\r\n        }\r\n    }\r\n\r\n    function getCurrentTime() public view returns(uint256){\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\n\r\ncontract LockLock is TokenVestingPools{\r\n\r\n    constructor () public TokenVestingPools(0xE76CF1f9401079B8ddA4F98D914e0521846C2756){\r\n\r\n\t   // check https://www.epochconverter.com/ for timestamp\r\n\r\n\t   \r\n\t   uint8 pool_0 = _addVestingPool(\"pool0\" , 1640995200, 4, 90 days); \r\n\r\n\t  \r\n\t   _addBeneficiary(pool_0, 0xc06A06CeCB585Bb5247e1CC2a96263f59fC34613,1333333); // 1,333,333 Tokens\r\n\t   \r\n\t    uint8 pool_1 = _addVestingPool(\"pool1\" , 1612457122 , 4, 90 days); \r\n\r\n\t  \r\n\t   _addBeneficiary(pool_1, 0xc06A06CeCB585Bb5247e1CC2a96263f59fC34613,1333333); // 1,333,333 Tokens\r\n    }\r\n\t\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"pid\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"claim2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"claim3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"claim4\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"claim5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"claim6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getBeneficiaryInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextBatchTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getNextBatchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startReleasingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchPeriodInDays\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolsCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getReleasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"getSenderInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawaned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextBatchTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getVestedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startReleasingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LockLock","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c2e6e566b1d5394f70a489d030d9c0b78389b87191f2b73c3f1edda4c4b6257c"}]}