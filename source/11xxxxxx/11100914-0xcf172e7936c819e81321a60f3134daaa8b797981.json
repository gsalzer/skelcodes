{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.6;\r\n\r\ninterface UniswapPairContract {\r\n  \r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n        \r\n\r\ninterface xETHTokenInterface {\r\n   \r\n    //Public functions\r\n    function maxScalingFactor() external view returns (uint256);\r\n    function xETHScalingFactor() external view returns (uint256);\r\n    //rebase permissioned\r\n    function setTxFee(uint16 fee) external ;\r\n    function setSellFee(uint16 fee) external ;\r\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\r\n}\r\n\r\ncontract xETHRebaser {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyGov() {\r\n        require(msg.sender == gov, \"This function can only be called by the governance address\");\r\n        _;\r\n    }\r\n\r\n    /// @notice an event emitted when deviationThreshold is changed\r\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\r\n\r\n    /// @notice Governance address\r\n    address public gov;\r\n\r\n    /// @notice Spreads out getting to the target price\r\n    uint256 public rebaseLag;\r\n\r\n    /// @notice Peg target\r\n    uint256 public targetRate;\r\n  \r\n    // If the current exchange rate is within this fractional distance from the target, no supply\r\n    // update is performed. Fixed point number--same format as the rate.\r\n    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\r\n    uint256 public deviationThreshold;\r\n\r\n    /// @notice Min time between last rebase and the next one\r\n    uint256 public minRebaseTimeIntervalSec;\r\n\r\n    /// @notice Block timestamp of last rebase operation\r\n    uint256 public lastRebaseTimestampSec;\r\n\r\n    /// @notice The number of rebase cycles since inception\r\n    uint256 public epoch;\r\n\r\n    address public xETHAddress;\r\n   \r\n    address public uniswap_xeth_eth_pair;\r\n    \r\n    mapping(address => bool) public whitelistFrom;\r\n    \r\n    constructor(address xETHAddress_, address xEthEthPair_) public {\r\n          // First rebase can happen straight away\r\n          minRebaseTimeIntervalSec = 0;\r\n          lastRebaseTimestampSec = 0;\r\n       \r\n          // 0.01 ETH\r\n          targetRate = 10**16;\r\n\r\n          // daily rebase, with targeting reaching peg in 2 days\r\n          rebaseLag = 2;\r\n\r\n          // 0.5%\r\n          deviationThreshold = 5 * 10**15;\r\n\r\n          uniswap_xeth_eth_pair = xEthEthPair_;\r\n          xETHAddress = xETHAddress_;\r\n\r\n          gov = msg.sender;\r\n          whitelistFrom[msg.sender] = true;\r\n    }\r\n\r\n    function setGovernance(address _newGovernance) external onlyGov {\r\n        gov = _newGovernance;\r\n    }\r\n\r\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyGov {\r\n        whitelistFrom[_addr] = _whitelisted;\r\n    }\r\n    \r\n     function _isWhitelisted(address _from) internal view returns (bool) {\r\n        return whitelistFrom[_from];\r\n    }\r\n    \r\n    /**\r\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\r\n     *\r\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\r\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\r\n     *      and targetRate is 1e18\r\n     */\r\n    function rebase() public {\r\n        // Validate the address which triggered the rebase\r\n        // EOA only\r\n        require(msg.sender == tx.origin, \"Message sender is not where the tx originated!\");\r\n        require(_isWhitelisted(msg.sender), \"Message sender is not authorized for rebasing!\");\r\n\r\n        // Validate the gap since last rebase is big enough\r\n        uint256 elapsed = lastRebaseTimestampSec.add(minRebaseTimeIntervalSec);\r\n        require(elapsed < block.timestamp, \"Not enough time has elapsed since last rebase!\");\r\n\r\n        // Update rebase tracker parameters\r\n        epoch = epoch.add(1);\r\n        lastRebaseTimestampSec = block.timestamp;\r\n        minRebaseTimeIntervalSec = _computeTimeLeftUntilNextWindow();\r\n\r\n        // get price from uniswap v2;\r\n        uint256 exchangeRate = getPrice();\r\n\r\n        // calculates % change to supply\r\n        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\r\n\r\n        uint256 indexDelta = offPegPerc;\r\n\r\n        // Apply the Dampening factor.\r\n        indexDelta = indexDelta.div(rebaseLag);\r\n\r\n        xETHTokenInterface xETH = xETHTokenInterface(xETHAddress);\r\n\r\n        if (positive) {\r\n            require(xETH.xETHScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < xETH.maxScalingFactor(), \"new scaling factor will be too big\");\r\n        }\r\n\r\n        // rebase\r\n        xETH.rebase(epoch, indexDelta, positive);\r\n        assert(xETH.xETHScalingFactor() <= xETH.maxScalingFactor());\r\n    }\r\n\r\n    function _computeTimeLeftUntilNextWindow() private view returns (uint256) {\r\n        uint secsInDay = 1 days;\r\n        return secsInDay - (block.timestamp % secsInDay);\r\n    }\r\n\r\n    function getPrice() public view returns (uint256) {\r\n        (uint xethReserve, uint ethReserve, ) = UniswapPairContract(uniswap_xeth_eth_pair).getReserves();\r\n        uint xEthPrice = ethReserve.mul(10**18).div(xethReserve);\r\n        return xEthPrice;\r\n    }\r\n\r\n    function setDeviationThreshold(uint256 deviationThreshold_) external onlyGov {\r\n        require(deviationThreshold > 0);\r\n        uint256 oldDeviationThreshold = deviationThreshold;\r\n        deviationThreshold = deviationThreshold_;\r\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the rebase lag parameter.\r\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\r\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\r\n               correction is applied on each rebase cycle.\r\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\r\n     * @param rebaseLag_ The new rebase lag parameter.\r\n     */\r\n    function setRebaseLag(uint256 rebaseLag_) external onlyGov {\r\n        require(rebaseLag_ > 0);\r\n        rebaseLag = rebaseLag_;\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the targetRate parameter.\r\n     * @param targetRate_ The new target rate parameter.\r\n     */\r\n    function setTargetRate(uint256 targetRate_) external onlyGov {\r\n        require(targetRate_ > 0);\r\n        targetRate = targetRate_;\r\n    }\r\n\r\n    function setSellFee(uint16 _fee) external onlyGov {\r\n        require(_fee > 0);\r\n        xETHTokenInterface(xETHAddress).setSellFee(_fee);\r\n    }\r\n\r\n    function setTxFee(uint16 _fee) external onlyGov {\r\n        require(_fee > 0);\r\n        xETHTokenInterface(xETHAddress).setTxFee(_fee);\r\n    }\r\n\r\n    /**\r\n     * @return Computes in % how far off market is from peg\r\n     */\r\n    function computeOffPegPerc(uint256 rate) private view returns (uint256, bool) {\r\n        if (withinDeviationThreshold(rate)) {\r\n            return (0, false);\r\n        }\r\n\r\n        // indexDelta =  (rate - targetRate) / targetRate\r\n        if (rate > targetRate) {\r\n            return (rate.sub(targetRate).mul(10**18).div(targetRate), true);\r\n        } else {\r\n            return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param rate The current exchange rate, an 18 decimal fixed point number.\r\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\r\n     *         Otherwise, returns false.\r\n     */\r\n    function withinDeviationThreshold(uint256 rate) private view returns (bool) {\r\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\r\n            .div(10 ** 18);\r\n\r\n        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)\r\n            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\r\n    }\r\n}\r\n\r\n  library SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n \r\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n \r\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n  \r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n  \r\n  function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        uint256 r = x / y;\r\n        if (x % y != 0) {\r\n            r = r + 1;\r\n        }\r\n\r\n        return r;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xETHAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xEthEthPair_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeviationThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeviationThreshold\",\"type\":\"uint256\"}],\"name\":\"NewDeviationThreshold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deviationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviationThreshold_\",\"type\":\"uint256\"}],\"name\":\"setDeviationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseLag_\",\"type\":\"uint256\"}],\"name\":\"setRebaseLag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetRate_\",\"type\":\"uint256\"}],\"name\":\"setTargetRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"setTxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap_xeth_eth_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"xETHRebaser","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000105230de0fda5d7253db5e7770ba7fff851bb8e1000000000000000000000000ac0fe6c0b239eedcc12bc3e997e5492b04cc61c3","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://51ae16acd19b5a306dea60cc85602ed2d4d77bcd46f79677e9a35baf45f1b317"}]}