{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\nabstract contract Ownable {\r\n  address s_owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    s_owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == s_owner, \"Ownable: not owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner virtual {\r\n    require(newOwner != address(0), \"Ownable: 0 cannot be owner\");\r\n    emit OwnershipTransferred(s_owner, newOwner);\r\n    s_owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\nabstract contract Claimable is Ownable {\r\n  address s_pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == s_pendingOwner, \"Claimable: not pending owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner override {\r\n    s_pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(s_owner, s_pendingOwner);\r\n    s_owner = s_pendingOwner;\r\n    s_pendingOwner = address(0);\r\n  }\r\n}\r\n\r\nstruct Account {\r\n    uint256 nonce;  \r\n    uint256 balance;\r\n    uint256 issueBlock;\r\n    uint256 pending;\r\n    uint256 withdrawal;\r\n    uint256 releaseBlock;\r\n    bytes32 secretHash;\r\n}\r\n\r\nlibrary AccountUtils {\r\n    using SafeMath for uint256;\r\n\r\n    function initNonce(Account storage self) internal {\r\n        if (self.nonce == 0) {\r\n            self.nonce =\r\n                uint256(1) << 240 |\r\n                uint256(blockhash(block.number-1)) << 80 >> 32 |\r\n                now;\r\n        }\r\n    }\r\n\r\n    function updateNonce(Account storage self) internal {\r\n        uint256 count = self.nonce >> 240;\r\n        uint256 nonce = \r\n            ++count << 240 |\r\n            uint256(blockhash(block.number-1)) << 80 >> 32 |\r\n            now;\r\n        require(uint16(self.nonce) != uint16(nonce), \"Pool: too soon\");\r\n        self.nonce = nonce;\r\n    }\r\n    \r\n    function acceptPending(Account storage self, uint256 value) internal {\r\n        uint256 pending = self.pending;\r\n        require(pending > 0, \"Pool: no pending tokens\");\r\n        require(pending == value, \"Pool: value must equal issued tokens\");\r\n        self.secretHash = 0;\r\n        self.pending = 0;\r\n        self.balance = self.balance.add(pending);\r\n    }\r\n\r\n    function take(Account storage self, uint256 value) internal {\r\n        self.balance = self.balance.add(value);\r\n    }\r\n\r\n    function payment(Account storage self, uint256 value) internal {\r\n        self.balance = self.balance.sub(value);\r\n    }\r\n\r\n    function deposit(Account storage self, uint256 value) internal {\r\n        self.balance = self.balance.add(value);\r\n    }\r\n\r\n    function withdraw(Account storage self, uint256 value) internal {\r\n        self.withdrawal = 0;\r\n        self.releaseBlock = 0;\r\n        self.balance = self.balance.sub(value);\r\n    }\r\n}\r\n\r\nstruct Supply {\r\n    uint256 total;\r\n    uint256 minimum;\r\n    uint256 pending;\r\n}\r\n\r\nlibrary SupplyUtils {\r\n    using SafeMath for uint256;\r\n\r\n    // event MinimumReached(uint256 before, uint256 delta);\r\n\r\n    modifier checkAvailability(Supply storage self) {\r\n        _;\r\n        require(self.total >= self.minimum.add(self.pending), \"Pool: not enough available tokens\");\r\n    }\r\n\r\n    // modifier safeReduceMinimum(Supply storage self, uint256 value) {\r\n    //     self.minimum > value ? self.minimum -= value : self.minimum = 0; \r\n    //     if (self.minimum == 0) {\r\n    //       emit MinimumReached(self.minimum, value);\r\n    //     }\r\n    //     _;\r\n    // }\r\n\r\n    function updatePending(Supply storage self, uint256 from, uint256 to) internal checkAvailability(self) { \r\n        self.pending = self.pending.add(to).sub(from, \"Pool: not enough available tokens\");       \r\n    }\r\n\r\n    function acceptPending(Supply storage self, uint256 value) internal {\r\n        self.pending = self.pending.sub(value, \"Pool: not enough pending\");\r\n        self.minimum = self.minimum.add(value);\r\n    }\r\n\r\n    function give(Supply storage self, uint256 value) internal checkAvailability(self) {\r\n        self.minimum = self.minimum.add(value);\r\n    }\r\n\r\n    function payment(Supply storage self, uint256 value) internal /*safeReduceMinimum(self, value)*/ {\r\n        self.minimum = self.minimum.sub(value); // this line should be remove if using safeReduceMinimum modifier\r\n    }\r\n\r\n    function deposit(Supply storage self, uint256 value) internal {\r\n        self.minimum = self.minimum.add(value);\r\n        self.total = self.total.add(value);\r\n    }\r\n\r\n    function widthdraw(Supply storage self, uint256 value) internal /*safeReduceMinimum(self, value)*/ checkAvailability(self) {\r\n        self.minimum = self.minimum.sub(value); // this line should be remove if using safeReduceMinimum modifier\r\n        self.total = self.total.sub(value);\r\n    }\r\n\r\n    function decrease(Supply storage self, uint256 value) internal checkAvailability(self) {\r\n        self.total = self.total.sub(value, \"Pool: value larger than total\");\r\n    }\r\n\r\n    function update(Supply storage self, uint256 value) internal checkAvailability(self) {\r\n        self.total = value;\r\n    }\r\n\r\n    function available(Supply storage self) internal view returns (uint256) {\r\n        return self.total.sub(self.minimum.add(self.pending));\r\n    }\r\n}\r\n\r\nstruct Limits {\r\n    uint256 releaseDelay;\r\n    uint256 maxTokensPerIssue;\r\n    uint256 maxTokensPerBlock;\r\n}\r\n\r\nstruct Entities {\r\n    address manager;\r\n    address token;\r\n    address wallet;\r\n}\r\n\r\ncontract Pool is Claimable {\r\n    using AccountUtils for Account;\r\n    using SupplyUtils for Supply;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 private s_uid;\r\n    Supply private s_supply;\r\n    Limits private s_limits;\r\n    Entities private s_entities;\r\n    uint256 private s_lastIssuedBlock;\r\n    uint256 private s_totalIssuedInBlock;\r\n\r\n    mapping(address => Account) private s_accounts;\r\n\r\n    uint8 public constant VERSION_NUMBER = 0x1;\r\n    uint256 public constant MAX_RELEASE_DELAY = 11_520; // about 48h\r\n    string public constant NAME = \"Kirobo Pool\";\r\n    string public constant VERSION = \"1\";\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    bytes public DOMAIN_SEPARATOR_ASCII;\r\n    uint256 public CHAIN_ID;\r\n\r\n    // keccak256(\"acceptTokens(address recipient,uint256 value,bytes32 secretHash)\");\r\n    bytes32 public constant ACCEPT_TYPEHASH = 0xf728cfc064674dacd2ced2a03acd588dfd299d5e4716726c6d5ec364d16406eb;\r\n\r\n    // keccak256(\"payment(address from,uint256 value,uint256 nonce)\");\r\n    bytes32 public constant PAYMENT_TYPEHASH = 0x841d82f71fa4558203bb763733f6b3326ecaf324143e12fb9b6a9ed958fc4ee0;\r\n\r\n    // keccak256(\"buyTokens(address recipient,uint256 eth,uint256 kiro,uint256 expires)\");\r\n    bytes32 public constant BUY_TYPEHASH = 0x866880cdfbc2380b3f4581d70707601f3d190bc04c3ee9cfcdac070a5f87b758;\r\n\r\n    event TokensIssued(address indexed account, uint256 value, bytes32 secretHash);\r\n    event TokensAccepted(address indexed account, bool directCall);\r\n    event TokensDistributed(address indexed account, uint256 value);\r\n    event Payment(address indexed account, uint256 value);\r\n    event Deposit(address indexed account, uint256 value);\r\n    event WithdrawalRequested(address indexed account, uint256 value);\r\n    event WithdrawalCanceled(address indexed account);\r\n    event Withdrawal(address indexed account, uint256 value);\r\n    event EtherTransfered(address indexed to, uint256 value);\r\n    event TokensTransfered(address indexed to, uint256 value);\r\n    event ManagerChanged(address from, address to);\r\n    event WalletChanged(address from, address to);\r\n    event ReleaseDelayChanged(uint256 from, uint256 to);\r\n    event MaxTokensPerIssueChanged(uint256 from, uint256 to);\r\n    event MaxTokensPerBlockChanged(uint256 from, uint256 to);\r\n\r\n    modifier onlyAdmins() {\r\n        require(msg.sender == s_owner || msg.sender == s_entities.manager, \"Pool: not owner or manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(address tokenContract) public {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n     \r\n        s_entities.token = tokenContract;\r\n        s_limits = Limits({releaseDelay: 240, maxTokensPerIssue: 10*1000*(10**18), maxTokensPerBlock: 50*1000*(10**18)});\r\n        s_uid = bytes32(\r\n          uint256(VERSION_NUMBER) << 248 |\r\n          uint256(blockhash(block.number-1)) << 192 >> 16 |\r\n          uint256(address(this))\r\n        );\r\n\r\n        CHAIN_ID = chainId;\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"),\r\n                keccak256(bytes(NAME)),\r\n                keccak256(bytes(VERSION)),\r\n                chainId,\r\n                address(this),\r\n                s_uid\r\n            )\r\n        );\r\n        DOMAIN_SEPARATOR_ASCII = _hashToAscii(\r\n            DOMAIN_SEPARATOR\r\n        );\r\n    }\r\n\r\n    receive () external payable {\r\n        require(false, \"Pool: not accepting ether\");\r\n    }\r\n\r\n\r\n    // ----------- Owner Functions ------------\r\n\r\n\r\n    function setManager(address manager) external onlyOwner() {\r\n        require(manager != address(this), \"Pool: self cannot be mananger\");\r\n        require(manager != s_entities.token, \"Pool: token cannot be manager\");\r\n        emit ManagerChanged(s_entities.manager, manager);\r\n        s_entities.manager = manager;\r\n    }\r\n\r\n    function setWallet(address wallet) external onlyOwner() {\r\n        require(wallet != address(this), \"Pool: self cannot be wallet\");\r\n        require(wallet != s_entities.token, \"Pool: token cannot be wallt\");\r\n        emit WalletChanged(s_entities.wallet, wallet);\r\n        s_entities.wallet = wallet;\r\n    }\r\n\r\n    function setReleaseDelay(uint256 blocks) external onlyOwner() {\r\n        require(blocks <= MAX_RELEASE_DELAY, \"Pool: exeeds max release delay\");\r\n        emit ReleaseDelayChanged(s_limits.releaseDelay, blocks);\r\n        s_limits.releaseDelay = blocks;\r\n    }\r\n\r\n    function setMaxTokensPerIssue(uint256 tokens) external onlyOwner() {\r\n        emit MaxTokensPerIssueChanged(s_limits.maxTokensPerIssue, tokens);\r\n        s_limits.maxTokensPerIssue = tokens;\r\n    }\r\n\r\n    function setMaxTokensPerBlock(uint256 tokens) external onlyOwner() {\r\n        emit MaxTokensPerBlockChanged(s_limits.maxTokensPerBlock, tokens);\r\n        s_limits.maxTokensPerBlock = tokens;\r\n    }\r\n\r\n    function resyncTotalSupply(uint256 value) external onlyAdmins() returns (uint256) {\r\n        uint256 tokens = ownedTokens();\r\n        require(tokens >= s_supply.total, \"Pool: internal error, check contract logic\"); \r\n        require(value >= s_supply.total, \"Pool: only transferTokens can decrease total supply\");\r\n        require(value <= tokens, \"Pool: not enough tokens\");\r\n        s_supply.update(value);\r\n    }\r\n\r\n\r\n    // ----------- Admins Functions ------------\r\n\r\n\r\n    function transferEther(uint256 value) external onlyAdmins() {\r\n        require(s_entities.wallet != address(0), \"Pool: wallet not set\");\r\n        payable(s_entities.wallet).transfer(value);\r\n        emit EtherTransfered(s_entities.wallet, value);\r\n    }\r\n\r\n    function transferTokens(uint256 value) external onlyAdmins() {\r\n        require(s_entities.wallet != address(0), \"Pool: wallet not set\");\r\n        s_supply.decrease(value);\r\n        IERC20(s_entities.token).safeTransfer(s_entities.wallet, value);\r\n        emit TokensTransfered(s_entities.wallet, value);\r\n    }\r\n\r\n    function distributeTokens(address to, uint256 value) external onlyAdmins() {\r\n        _distributeTokens(to, value);\r\n    }\r\n    \r\n    function _distributeTokens(address to, uint256 value) private {\r\n        require(value <= s_limits.maxTokensPerIssue, \"Pool: exeeds max tokens per call\");\r\n        require(s_accounts[to].issueBlock < block.number, \"Pool: too soon\");\r\n        _validateTokensPerBlock(value);\r\n        Account storage sp_account = s_accounts[to];\r\n        sp_account.issueBlock = block.number;\r\n        sp_account.initNonce();\r\n        s_supply.give(value);\r\n        sp_account.take(value);\r\n        emit TokensDistributed(to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Issueing tokens for an address to be used for payments.\r\n     * The owner of the receiving address must accept via a signed message or a direct call.\r\n     * @param to The tokens recipient. \r\n     * @param value The number of tokens to issue.\r\n     * @param secretHash The keccak256 of the confirmation secret.\r\n    */\r\n    function issueTokens(address to, uint256 value, bytes32 secretHash) external onlyAdmins() {\r\n        require(value <= s_limits.maxTokensPerIssue, \"Pool: exeeds max tokens per call\");\r\n        _validateTokensPerBlock(value);\r\n        Account storage sp_account = s_accounts[to];\r\n        uint256 prevPending = sp_account.pending;\r\n        sp_account.initNonce();\r\n        sp_account.secretHash = secretHash;\r\n        sp_account.pending = value;\r\n        sp_account.issueBlock = block.number;\r\n        s_supply.updatePending(prevPending, value);\r\n        emit TokensIssued(to, value, secretHash);\r\n    }\r\n\r\n    function executeAcceptTokens(\r\n        address recipient,\r\n        uint256 value,\r\n        bytes calldata c_secret,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        bool eip712\r\n    )\r\n        external \r\n        onlyAdmins()\r\n    {\r\n        require(s_accounts[recipient].secretHash == keccak256(c_secret), \"Pool: wrong secret\");\r\n        require(\r\n            validateAcceptTokens(recipient, value, keccak256(c_secret), v, r ,s, eip712),\r\n            \"Pool: wrong signature or data\"\r\n        );\r\n        _acceptTokens(recipient, value);\r\n        emit TokensAccepted(recipient, false);\r\n    }\r\n\r\n    function executePayment(address from, uint256 value, uint8 v, bytes32 r, bytes32 s, bool eip712)\r\n        external\r\n        onlyAdmins()\r\n    {\r\n        require(validatePayment(from, value, v, r, s, eip712), \"Pool: wrong signature or data\");\r\n        Account storage sp_account = s_accounts[from];\r\n        sp_account.updateNonce();\r\n        sp_account.payment(value);\r\n        s_supply.payment(value);\r\n        emit Payment(from, value);\r\n    }\r\n  \r\n\r\n    // ----------- External Functions ------------\r\n\r\n\r\n    function executeBuyTokens(uint256 kiro, uint256 expires, uint8 v, bytes32 r, bytes32 s, bool eip712) \r\n        external\r\n        payable\r\n    {\r\n        require(validateBuyTokens(msg.sender, msg.value, kiro, expires, v, r, s, eip712), \"Pool: wrong signature or data\");\r\n        require(now <= expires, \"Pool: too late\");\r\n        _distributeTokens(msg.sender, kiro);\r\n    }\r\n\r\n    function acceptTokens(uint256 value, bytes calldata c_secret) external {\r\n        require(s_accounts[msg.sender].secretHash == keccak256(c_secret), \"Pool: wrong secret\");\r\n        _acceptTokens(msg.sender, value);\r\n        emit TokensAccepted(msg.sender, true);\r\n    }\r\n\r\n    function depositTokens(uint256 value) external {\r\n        // require(\r\n        //     IERC20(s_entities.token).allowance(msg.sender, address(this)) >= value,\r\n        //    \"IERC20 allowance too low\"\r\n        // );\r\n        Account storage sp_account = s_accounts[msg.sender]; \r\n        sp_account.initNonce();\r\n        sp_account.deposit(value);\r\n        s_supply.deposit(value);\r\n        IERC20(s_entities.token).safeTransferFrom(msg.sender, address(this), value);\r\n        emit Deposit(msg.sender, value);\r\n    }\r\n\r\n    function requestWithdrawal(uint256 value) external {\r\n        require(s_accounts[msg.sender].balance >= value, \"Pool: not enough tokens\");\r\n        require(value > 0, \"Pool: withdrawal value must be larger then 0\");\r\n        s_accounts[msg.sender].withdrawal = value;\r\n        s_accounts[msg.sender].releaseBlock = block.number + s_limits.releaseDelay;\r\n        emit WithdrawalRequested(msg.sender, value);\r\n    }\r\n\r\n    function cancelWithdrawal() external {\r\n        s_accounts[msg.sender].withdrawal = 0;\r\n        s_accounts[msg.sender].releaseBlock = 0;\r\n        emit WithdrawalCanceled(msg.sender);\r\n    }\r\n\r\n    function withdrawTokens() external {\r\n        Account storage sp_account = s_accounts[msg.sender];   \r\n        require(sp_account.withdrawal > 0, \"Pool: no withdraw request\");\r\n        require(sp_account.releaseBlock <= block.number, \"Pool: too soon\");\r\n        uint256 value = sp_account.withdrawal > sp_account.balance ? sp_account.balance : sp_account.withdrawal;\r\n        sp_account.withdraw(value);\r\n        s_supply.widthdraw(value);\r\n        IERC20(s_entities.token).safeTransfer(msg.sender, value);\r\n        emit Withdrawal(msg.sender, value);\r\n    }\r\n\r\n    function account(address addr) external view\r\n        returns (\r\n            uint256 nonce,  \r\n            uint256 balance,\r\n            uint256 issueBlock,\r\n            uint256 pending,\r\n            uint256 withdrawal,\r\n            uint256 releaseBlock,\r\n            bytes32 secretHash,\r\n            uint256 externalBalance\r\n        ) \r\n    {\r\n        Account storage sp_account = s_accounts[addr];\r\n        uint256 extBalance = IERC20(s_entities.token).balanceOf(addr);\r\n        return (\r\n            sp_account.nonce,\r\n            sp_account.balance,\r\n            sp_account.issueBlock,\r\n            sp_account.pending,\r\n            sp_account.withdrawal,\r\n            sp_account.releaseBlock,\r\n            sp_account.secretHash,\r\n            extBalance\r\n        );\r\n    }\r\n\r\n    function entities() view external\r\n        returns (\r\n            address manager,\r\n            address token,\r\n            address wallet\r\n        )\r\n    {\r\n        return (\r\n            s_entities.manager,\r\n            s_entities.token,\r\n            s_entities.wallet\r\n        );\r\n    }\r\n\r\n    function limits() external view\r\n        returns (\r\n            uint256 releaseDelay, \r\n            uint256 maxTokensPerIssue,\r\n            uint256 maxTokensPerBlock\r\n        )\r\n    {\r\n        return (\r\n            s_limits.releaseDelay,\r\n            s_limits.maxTokensPerIssue,\r\n            s_limits.maxTokensPerBlock\r\n        );\r\n    }\r\n\r\n    function supply() view external \r\n        returns (\r\n            uint256 total,\r\n            uint256 minimum,\r\n            uint256 pending,\r\n            uint256 available\r\n        ) \r\n    {\r\n        return (\r\n            s_supply.total,\r\n            s_supply.minimum,\r\n            s_supply.pending,\r\n            s_supply.available()\r\n        );\r\n    }\r\n\r\n    function uid() view external returns (bytes32) {\r\n        return s_uid;\r\n    }\r\n\r\n    function totalSupply() view external returns (uint256) {\r\n        return s_supply.total;\r\n    }\r\n\r\n    function availableSupply() view external returns (uint256) {\r\n        return s_supply.available();\r\n    }\r\n\r\n\r\n    // ----------- Public Functions ------------\r\n\r\n\r\n    function generateBuyTokensMessage(address recipient, uint256 eth, uint256 kiro, uint256 expires)\r\n        public view\r\n        returns (bytes memory)\r\n    {\r\n        Account storage sp_account = s_accounts[recipient]; \r\n    \r\n        return abi.encode(\r\n            BUY_TYPEHASH,\r\n            recipient,\r\n            eth,\r\n            kiro,\r\n            expires,\r\n            sp_account.issueBlock\r\n        );\r\n    }\r\n\r\n    function generateAcceptTokensMessage(address recipient, uint256 value, bytes32 secretHash)\r\n        public view \r\n        returns (bytes memory)\r\n    {\r\n        require(s_accounts[recipient].secretHash == secretHash, \"Pool: wrong secret hash\");\r\n        require(s_accounts[recipient].pending == value, \"Pool: value must equal pending(issued tokens)\");\r\n            \r\n        return abi.encode(\r\n            ACCEPT_TYPEHASH,\r\n            recipient,\r\n            value,\r\n            secretHash\r\n        );\r\n    }\r\n\r\n    function generatePaymentMessage(address from, uint256 value)\r\n        public view\r\n        returns (bytes memory)\r\n    {\r\n        Account storage sp_account = s_accounts[from]; \r\n        require(sp_account.balance >= value, \"Pool: account balnace too low\");\r\n        \r\n        return abi.encode(\r\n            PAYMENT_TYPEHASH,\r\n            from,\r\n            value,\r\n            sp_account.nonce\r\n        );\r\n    }\r\n\r\n    function validateBuyTokens(\r\n        address from,\r\n        uint256 eth,\r\n        uint256 kiro,\r\n        uint256 expires,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        bool eip712\r\n    )\r\n        public view \r\n        returns (bool)\r\n    {\r\n        bytes32 message = _messageToRecover(\r\n            keccak256(generateBuyTokensMessage(from, eth, kiro, expires)),\r\n            eip712\r\n        );\r\n        address addr = ecrecover(message, v, r, s);\r\n        return addr == s_entities.manager;      \r\n    }\r\n\r\n    function validateAcceptTokens(\r\n        address recipient,\r\n        uint256 value,\r\n        bytes32 secretHash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        bool eip712\r\n    )\r\n        public view \r\n        returns (bool)\r\n    {\r\n        bytes32 message = _messageToRecover(\r\n            keccak256(generateAcceptTokensMessage(recipient, value, secretHash)),\r\n            eip712\r\n        );\r\n        address addr = ecrecover(message, v, r, s);\r\n        return addr == recipient;\r\n    }\r\n\r\n    function validatePayment(address from, uint256 value, uint8 v, bytes32 r, bytes32 s, bool eip712)\r\n        public view \r\n        returns (bool)\r\n    {\r\n        bytes32 message = _messageToRecover(\r\n            keccak256(generatePaymentMessage(from, value)),\r\n            eip712\r\n        );\r\n        address addr = ecrecover(message, v, r, s);\r\n        return addr == from;      \r\n    }\r\n\r\n    function ownedTokens() view public returns (uint256) {\r\n        return IERC20(s_entities.token).balanceOf(address(this));\r\n    }\r\n\r\n\r\n    // ----------- Private Functions ------------\r\n\r\n\r\n    function _validateTokensPerBlock(uint256 value) private {\r\n        if (s_lastIssuedBlock < block.number) {\r\n            s_lastIssuedBlock = block.number;\r\n            s_totalIssuedInBlock = value;\r\n        } else {\r\n            s_totalIssuedInBlock.add(value);\r\n        }\r\n        require(s_totalIssuedInBlock <= s_limits.maxTokensPerBlock, \"Pool: exeeds max tokens per block\");\r\n    }\r\n\r\n    function _acceptTokens(address recipient, uint256 value) private {\r\n        require(s_accounts[recipient].issueBlock < block.number, \"Pool: too soon\");\r\n        s_accounts[recipient].acceptPending(value);\r\n        s_supply.acceptPending(value);\r\n    }\r\n\r\n    function _messageToRecover(bytes32 hashedUnsignedMessage, bool eip712)\r\n        private view \r\n        returns (bytes32)\r\n    {\r\n        if (eip712) {\r\n            return keccak256(abi.encodePacked\r\n            (\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                hashedUnsignedMessage\r\n            ));\r\n        }\r\n        return keccak256(abi.encodePacked\r\n        (\r\n            \"\\x19Ethereum Signed Message:\\n128\",\r\n            DOMAIN_SEPARATOR_ASCII,\r\n            _hashToAscii(hashedUnsignedMessage)\r\n        ));\r\n    }\r\n\r\n    function _hashToAscii(bytes32 hash) private pure returns (bytes memory) {\r\n        bytes memory s = new bytes(64);\r\n        for (uint i = 0; i < 32; i++) {\r\n            byte  b = hash[i];\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = _char(hi);\r\n            s[2*i+1] = _char(lo);\r\n        }\r\n        return s;\r\n    }\r\n\r\n    function _char(byte b) private pure returns (byte c) {\r\n        if (b < byte(uint8(10))) {\r\n            return byte(uint8(b) + 0x30);\r\n        } else {\r\n            return byte(uint8(b) + 0x57);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EtherTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"MaxTokensPerBlockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"MaxTokensPerIssueChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ReleaseDelayChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"directCall\",\"type\":\"bool\"}],\"name\":\"TokensAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"TokensIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"WalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WithdrawalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACCEPT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUY_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR_ASCII\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RELEASE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION_NUMBER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"c_secret\",\"type\":\"bytes\"}],\"name\":\"acceptTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"account\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"externalBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"distributeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"c_secret\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"eip712\",\"type\":\"bool\"}],\"name\":\"executeAcceptTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"kiro\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"eip712\",\"type\":\"bool\"}],\"name\":\"executeBuyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"eip712\",\"type\":\"bool\"}],\"name\":\"executePayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"generateAcceptTokensMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kiro\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"generateBuyTokensMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"generatePaymentMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"issueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"releaseDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensPerIssue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"resyncTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setMaxTokensPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setMaxTokensPerIssue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"setReleaseDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"eip712\",\"type\":\"bool\"}],\"name\":\"validateAcceptTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kiro\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"eip712\",\"type\":\"bool\"}],\"name\":\"validateBuyTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"eip712\",\"type\":\"bool\"}],\"name\":\"validatePayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Pool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b1191f691a355b43542bea9b8847bc73e7abb137","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6bd4a190f08b08f490a818648e24833a244361e6646baf8cd846ad6e84cccd40"}]}