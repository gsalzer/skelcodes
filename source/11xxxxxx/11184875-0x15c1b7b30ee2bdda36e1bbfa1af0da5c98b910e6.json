{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.6.10;\r\n\r\n\r\n// \r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// \r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// \r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract CardDistributor is ERC165 {\r\n    using SafeMath for uint;\r\n    bytes4 private constant TRANSFER_FROM_SELECTOR_721 = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    bytes4 private constant TRANSFER_FROM_SELECTOR_1155 = bytes4(keccak256(bytes('safeTransferFrom(address,address,uint256,uint256,bytes)')));\r\n\r\n    bytes4 private constant TRANSFER_SELECTOR_20 = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    bytes4 private constant TRANSFER_FROM_SELECTOR_20 = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    bytes4 private constant BALANCE_OF_SELECTOR_20 = bytes4(keccak256(bytes('balanceOf(address)')));\r\n\r\n    address public owner;\r\n\r\n    struct CardInfo {\r\n        uint256 price; // Card price over ymem\r\n        uint256 amount;\r\n        uint256 nftType; // It's 721 or 1155\r\n    }\r\n\r\n    mapping(address=>mapping(uint256=>CardInfo)) public cards;\r\n\r\n    address public acceptToken;\r\n    bool public claimable;\r\n\r\n    event ClaimNFT(address indexed staker, address indexed nftAddress, uint256 indexed nftId, uint256 price);\r\n    event AddCard(address _nftAddr, uint256 _nftId, uint256 _nftType, uint256 _amount, uint256 _price);\r\n    event WithdrawCard(address _nftAddr, uint256 _nftType, uint256 _amount);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyClaimable() {\r\n        require(claimable, \"Not claimable\");\r\n        _;\r\n    }\r\n\r\n    constructor (address _acceptTokenAddress) public {\r\n        owner = msg.sender;\r\n        acceptToken = _acceptTokenAddress;\r\n        _registerInterface(CardDistributor.onERC721Received.selector);\r\n        _registerInterface(CardDistributor.onERC1155Received.selector);\r\n        _registerInterface(CardDistributor.onERC1155BatchReceived.selector);\r\n    }\r\n\r\n    //////////////////////////\r\n    /// Operation functions\r\n    //////////////////////////\r\n    function changeOwner(address newOwner) public onlyOwner() {\r\n        require(newOwner != address(0), \"Owner address invalid\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function startClaim() public onlyOwner() {\r\n        claimable = true;\r\n    }\r\n\r\n    function stopClaim() public onlyOwner() {\r\n        claimable = false;\r\n    }\r\n\r\n    // Add card info\r\n    function addCard(address _nftAddr, uint256 _nftId, uint256 _nftType, uint256 _amount, uint256 _price) public onlyOwner() {\r\n        require((_nftType == 721 || _nftType == 1155), \"Card type must be 721 or 1155\");\r\n\r\n        CardInfo storage card = cards[_nftAddr][_nftId];\r\n\r\n        require(card.nftType == 0 || (card.nftType != 0 && card.nftType == _nftType) , \"Wrong NFT type\");\r\n\r\n        card.nftType = _nftType;\r\n        if (_nftType == 721) {\r\n            card.amount = 1;\r\n        } else {\r\n            card.amount = card.amount.add(_amount);\r\n        }\r\n        card.price = _price;\r\n\r\n        emit AddCard(_nftAddr, _nftId, _nftType, _amount, _price);\r\n    }\r\n\r\n    // Send card back to owner\r\n    function withdrawCard(address _nftAddr, uint256 _nftId) public onlyOwner() {\r\n        CardInfo storage c = cards[_nftAddr][_nftId];\r\n        uint256 amount = c.amount;\r\n        c.amount = 0;\r\n\r\n        require(c.nftType != 0, \"Card does not exist\");\r\n        require(amount > 0 , \"Card insufficient\");\r\n\r\n        _transferNft(_nftAddr, _nftId, c.nftType, msg.sender, amount);\r\n\r\n        emit WithdrawCard(_nftAddr, _nftId, amount);\r\n    }\r\n\r\n    function resetCard(address _nftAddr, uint256 _nftId) public onlyOwner() {\r\n        delete cards[_nftAddr][_nftId];\r\n    }\r\n\r\n    // Transfer all token to owner\r\n    function withdrawToken() public onlyOwner() returns (uint256) {\r\n        (bool success, bytes memory data) = acceptToken.call(abi.encodeWithSelector(BALANCE_OF_SELECTOR_20, address(this)));\r\n        require(success, \"Can not get balance\");\r\n\r\n        uint256 amount = abi.decode(data, (uint256));\r\n\r\n        _safeTransferERC20(acceptToken, msg.sender, amount);\r\n        return amount;\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Public functions\r\n    /////////////////////////////\r\n    function claimNft(address _nftAddress, uint256 _nftId) onlyClaimable public {\r\n        // Check nft info\r\n        CardInfo storage card = cards[_nftAddress][_nftId];\r\n        require(card.amount > 0, \"No card\");\r\n\r\n        // Reduce nft\r\n        card.amount = card.amount.sub(1);\r\n\r\n        // Transfer token to this contract\r\n        _safeTransferFromERC20(acceptToken, msg.sender, address(this), card.price);\r\n\r\n        // Transfer nft token\r\n        _transferNft(_nftAddress, _nftId, card.nftType, msg.sender, 1);\r\n\r\n        emit ClaimNFT(msg.sender, _nftAddress, _nftId, card.price);\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Utility functions\r\n    /////////////////////////////\r\n    function _transferNft(address _nftAddress, uint256 _nftId, uint256 _nftType, address _receiver,  uint256 _amount) internal {\r\n        // 721 function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n        // 1155   function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n        if (_nftType == 721) {\r\n            _transfer721(_nftAddress, _nftId, _receiver);\r\n        } else if(_nftType == 1155) {\r\n            _transfer1155(_nftAddress, _nftId, _receiver, _amount);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function _transfer721(address _nftAddress, uint256 _nftId, address _receiver) internal {\r\n        (bool success,) = _nftAddress.call(abi.encodeWithSelector(TRANSFER_FROM_SELECTOR_721, address(this), _receiver, _nftId));\r\n        require(success, 'TRANSFER_721_FAILED');\r\n    }\r\n\r\n    function _transfer1155(address _nftAddress, uint256 _nftId, address _receiver, uint256 _amount) internal {\r\n        (bool success,) = _nftAddress.call(abi.encodeWithSelector(TRANSFER_FROM_SELECTOR_1155, address(this), _receiver, _nftId, _amount, \"\"));\r\n        require(success, 'TRANSFER_1155_FAILED');\r\n    }\r\n\r\n\r\n    function _safeTransferERC20(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(TRANSFER_SELECTOR_20, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function _safeTransferFromERC20(address token, address from, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(TRANSFER_FROM_SELECTOR_20, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Implement onReceived function to receive NFT\r\n    /////////////////////////////\r\n\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4) {\r\n        return CardDistributor.onERC721Received.selector;\r\n    }\r\n\r\n     function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns(bytes4) {\r\n        return CardDistributor.onERC1155Received.selector;\r\n    }\r\n\r\n     function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns(bytes4) {\r\n        return CardDistributor.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_acceptTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nftAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nftType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"AddCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ClaimNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_nftAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nftType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawCard\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"claimNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"resetCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"withdrawCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CardDistributor","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004bb9af74eb494329a0c6049a0a4ab18d53b73acc","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://68a13f78ee0932c8a0db06ed5eb8adaac782d12d5866057749abfd897d9a020f"}]}