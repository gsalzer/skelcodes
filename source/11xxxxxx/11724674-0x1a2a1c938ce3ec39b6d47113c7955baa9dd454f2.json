{"status":"1","message":"OK","result":[{"SourceCode":"// File: @axie/contract-library/contracts/access/HasAdmin.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract HasAdmin {\r\n  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\r\n  event AdminRemoved(address indexed _oldAdmin);\r\n\r\n  address public admin;\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  constructor() internal {\r\n    admin = msg.sender;\r\n    emit AdminChanged(address(0), admin);\r\n  }\r\n\r\n  function changeAdmin(address _newAdmin) external onlyAdmin {\r\n    require(_newAdmin != address(0));\r\n    emit AdminChanged(admin, _newAdmin);\r\n    admin = _newAdmin;\r\n  }\r\n\r\n  function removeAdmin() external onlyAdmin {\r\n    emit AdminRemoved(admin);\r\n    admin = address(0);\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/proxy/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ProxyStorage\r\n * @dev Store the address of logic contact that the proxy should forward to.\r\n */\r\ncontract ProxyStorage is HasAdmin {\r\n  address internal _proxyTo;\r\n}\r\n\r\n// File: @axie/contract-library/contracts/proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy is ProxyStorage {\r\n\r\n  event ProxyUpdated(address indexed _new, address indexed _old);\r\n\r\n  constructor(address _proxyTo) public {\r\n    updateProxyTo(_proxyTo);\r\n  }\r\n\r\n  /**\r\n  * @dev Tells the address of the implementation where every call will be delegated.\r\n  * @return address of the implementation to which it will be delegated\r\n  */\r\n  function implementation() public view returns (address) {\r\n    return _proxyTo;\r\n  }\r\n\r\n  /**\r\n  * @dev See more at: https://eips.ethereum.org/EIPS/eip-897\r\n  * @return type of proxy - always upgradable\r\n  */\r\n  function proxyType() external pure returns (uint256) {\r\n      // Upgradeable proxy\r\n      return 2;\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable external {\r\n    address _impl = implementation();\r\n    require(_impl != address(0));\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n\r\n  function updateProxyTo(address _newProxyTo) public onlyAdmin {\r\n    require(_newProxyTo != address(0x0));\r\n\r\n    _proxyTo = _newProxyTo;\r\n    emit ProxyUpdated(_newProxyTo, _proxyTo);\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract Pausable is HasAdmin {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool public paused;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() public onlyAdmin whenNotPaused {\r\n    paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  function unpause() public onlyAdmin whenPaused {\r\n    paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    require(c / a == b);\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Since Solidity automatically asserts when dividing by 0,\r\n    // but we only need it to revert.\r\n    require(b > 0);\r\n    return a / b;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Same reason as `div`.\r\n    require(b > 0);\r\n    return a % b;\r\n  }\r\n\r\n  function ceilingDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    return add(div(a, b), mod(a, b) > 0 ? 1 : 0);\r\n  }\r\n\r\n  function subU64(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function addU8(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n}\r\n\r\n// File: contracts/chain/common/IValidator.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract IValidator {\r\n  event ValidatorAdded(uint256 indexed _id, address indexed _validator);\r\n  event ValidatorRemoved(uint256 indexed _id, address indexed _validator);\r\n  event ThresholdUpdated(\r\n    uint256 indexed _id,\r\n    uint256 indexed _numerator,\r\n    uint256 indexed _denominator,\r\n    uint256 _previousNumerator,\r\n    uint256 _previousDenominator\r\n  );\r\n\r\n  function isValidator(address _addr) public view returns (bool);\r\n  function getValidators() public view returns (address[] memory _validators);\r\n\r\n  function checkThreshold(uint256 _voteCount) public view returns (bool);\r\n}\r\n\r\n// File: contracts/chain/common/Validator.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\ncontract Validator is IValidator {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => bool) validatorMap;\r\n  address[] public validators;\r\n  uint256 public validatorCount;\r\n\r\n  uint256 public num;\r\n  uint256 public denom;\r\n\r\n  constructor(address[] memory _validators, uint256 _num, uint256 _denom)\r\n    public\r\n  {\r\n    validators = _validators;\r\n    validatorCount = _validators.length;\r\n\r\n    for (uint256 _i = 0; _i < validatorCount; _i++) {\r\n      address _validator = _validators[_i];\r\n      validatorMap[_validator] = true;\r\n    }\r\n\r\n    num = _num;\r\n    denom = _denom;\r\n  }\r\n\r\n  function isValidator(address _addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return validatorMap[_addr];\r\n  }\r\n\r\n  function getValidators()\r\n    public\r\n    view\r\n    returns (address[] memory _validators)\r\n  {\r\n    _validators = validators;\r\n  }\r\n\r\n  function checkThreshold(uint256 _voteCount)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _voteCount.mul(denom) >= num.mul(validatorCount);\r\n  }\r\n\r\n  function _addValidator(uint256 _id, address _validator)\r\n    internal\r\n  {\r\n    require(!validatorMap[_validator]);\r\n\r\n    validators.push(_validator);\r\n    validatorMap[_validator] = true;\r\n    validatorCount++;\r\n\r\n    emit ValidatorAdded(_id, _validator);\r\n  }\r\n\r\n  function _removeValidator(uint256 _id, address _validator)\r\n    internal\r\n  {\r\n    require(isValidator(_validator));\r\n\r\n    uint256 _index;\r\n    for (uint256 _i = 0; _i < validatorCount; _i++) {\r\n      if (validators[_i] == _validator) {\r\n        _index = _i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    validatorMap[_validator] = false;\r\n    validators[_index] = validators[validatorCount - 1];\r\n    validators.pop();\r\n\r\n    validatorCount--;\r\n\r\n    emit ValidatorRemoved(_id, _validator);\r\n  }\r\n\r\n  function _updateQuorum(uint256 _id, uint256 _numerator, uint256 _denominator)\r\n    internal\r\n  {\r\n    require(_numerator <= _denominator);\r\n    uint256 _previousNumerator = num;\r\n    uint256 _previousDenominator = denom;\r\n\r\n    num = _numerator;\r\n    denom = _denominator;\r\n\r\n    emit ThresholdUpdated(\r\n      _id,\r\n      _numerator,\r\n      _denominator,\r\n      _previousNumerator,\r\n      _previousDenominator\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/MainchainValidator.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Validator\r\n * @dev Simple validator contract\r\n */\r\ncontract MainchainValidator is Validator, HasAdmin {\r\n  uint256 nonce;\r\n\r\n  constructor(\r\n    address[] memory _validators,\r\n    uint256 _num,\r\n    uint256 _denom\r\n  ) Validator(_validators, _num, _denom) public {\r\n  }\r\n\r\n  function addValidators(address[] calldata _validators) external onlyAdmin {\r\n    for (uint256 _i; _i < _validators.length; ++_i) {\r\n      _addValidator(nonce++, _validators[_i]);\r\n    }\r\n  }\r\n\r\n  function removeValidator(address _validator) external onlyAdmin {\r\n    _removeValidator(nonce++, _validator);\r\n  }\r\n\r\n  function updateQuorum(uint256 _numerator, uint256 _denominator) external onlyAdmin {\r\n    _updateQuorum(nonce++, _numerator, _denominator);\r\n  }\r\n}\r\n\r\n// File: contracts/chain/common/Registry.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\ncontract Registry is HasAdmin {\r\n\r\n  event ContractAddressUpdated(\r\n    string indexed _name,\r\n    bytes32 indexed _code,\r\n    address indexed _newAddress\r\n  );\r\n\r\n  event TokenMapped(\r\n    address indexed _mainchainToken,\r\n    address indexed _sidechainToken,\r\n    uint32 _standard\r\n  );\r\n\r\n  string public constant GATEWAY = \"GATEWAY\";\r\n  string public constant WETH_TOKEN = \"WETH_TOKEN\";\r\n  string public constant VALIDATOR = \"VALIDATOR\";\r\n  string public constant ACKNOWLEDGEMENT = \"ACKNOWLEDGEMENT\";\r\n\r\n  struct TokenMapping {\r\n    address mainchainToken;\r\n    address sidechainToken;\r\n    uint32 standard; // 20, 721 or any other standards\r\n  }\r\n\r\n  mapping(bytes32 => address) public contractAddresses;\r\n  mapping(address => TokenMapping) public mainchainMap;\r\n  mapping(address => TokenMapping) public sidechainMap;\r\n\r\n  function getContract(string calldata _name)\r\n    external\r\n    view\r\n    returns (address _address)\r\n  {\r\n    bytes32 _code = getCode(_name);\r\n    _address = contractAddresses[_code];\r\n    require(_address != address(0));\r\n  }\r\n\r\n  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\r\n\r\n    return _mapping.mainchainToken != address(0) &&\r\n      _mapping.sidechainToken != address(0) &&\r\n      _mapping.standard == _standard;\r\n  }\r\n\r\n  function updateContract(string calldata _name, address _newAddress)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    bytes32 _code = getCode(_name);\r\n    contractAddresses[_code] = _newAddress;\r\n\r\n    emit ContractAddressUpdated(_name, _code, _newAddress);\r\n  }\r\n\r\n  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    TokenMapping memory _map = TokenMapping(\r\n      _mainchainToken,\r\n      _sidechainToken,\r\n      _standard\r\n    );\r\n\r\n    mainchainMap[_mainchainToken] = _map;\r\n    sidechainMap[_sidechainToken] = _map;\r\n\r\n    emit TokenMapped(\r\n      _mainchainToken,\r\n      _sidechainToken,\r\n      _standard\r\n    );\r\n  }\r\n\r\n  function clearMapToken(address _mainchainToken, address _sidechainToken)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    TokenMapping storage _mainchainMap = mainchainMap[_mainchainToken];\r\n    _clearMapEntry(_mainchainMap);\r\n\r\n    TokenMapping storage _sidechainMap = sidechainMap[_sidechainToken];\r\n    _clearMapEntry(_sidechainMap);\r\n  }\r\n\r\n  function getMappedToken(\r\n    address _token,\r\n    bool _isMainchain\r\n  )\r\n    external\r\n    view\r\n  returns (\r\n    address _mainchainToken,\r\n    address _sidechainToken,\r\n    uint32 _standard\r\n  )\r\n  {\r\n    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\r\n    _mainchainToken = _mapping.mainchainToken;\r\n    _sidechainToken = _mapping.sidechainToken;\r\n    _standard = _mapping.standard;\r\n  }\r\n\r\n  function getCode(string memory _name)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked(_name));\r\n  }\r\n\r\n  function _getTokenMapping(\r\n    address _token,\r\n    bool isMainchain\r\n  )\r\n    internal\r\n    view\r\n    returns (TokenMapping memory _mapping)\r\n  {\r\n    if (isMainchain) {\r\n      _mapping = mainchainMap[_token];\r\n    } else {\r\n      _mapping = sidechainMap[_token];\r\n    }\r\n  }\r\n\r\n  function _clearMapEntry(TokenMapping storage _entry)\r\n    internal\r\n  {\r\n    _entry.mainchainToken = address(0);\r\n    _entry.sidechainToken = address(0);\r\n    _entry.standard = 0;\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/MainchainGatewayStorage.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title GatewayStorage\r\n * @dev Storage of deposit and withdraw information.\r\n */\r\ncontract MainchainGatewayStorage is ProxyStorage, Pausable {\r\n\r\n  event TokenDeposited(\r\n    uint256 indexed _depositId,\r\n    address indexed _owner,\r\n    address indexed _tokenAddress,\r\n    address _sidechainAddress,\r\n    uint32  _standard,\r\n    uint256 _tokenNumber // ERC-20 amount or ERC721 tokenId\r\n  );\r\n\r\n  event TokenWithdrew(\r\n    uint256 indexed _withdrawId,\r\n    address indexed _owner,\r\n    address indexed _tokenAddress,\r\n    uint256 _tokenNumber\r\n  );\r\n\r\n  struct DepositEntry {\r\n    address owner;\r\n    address tokenAddress;\r\n    address sidechainAddress;\r\n    uint32  standard;\r\n    uint256 tokenNumber;\r\n  }\r\n\r\n  struct WithdrawalEntry {\r\n    address owner;\r\n    address tokenAddress;\r\n    uint256 tokenNumber;\r\n  }\r\n\r\n  Registry public registry;\r\n\r\n  uint256 public depositCount;\r\n  DepositEntry[] public deposits;\r\n  mapping(uint256 => WithdrawalEntry) public withdrawals;\r\n\r\n  function updateRegistry(address _registry) external onlyAdmin {\r\n    registry = Registry(_registry);\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/MainchainGatewayProxy.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MainchainGatewayProxy is Proxy, MainchainGatewayStorage {\r\n  constructor(address _proxyTo, address _registry)\r\n    public\r\n    Proxy(_proxyTo)\r\n  {\r\n    registry = Registry(_registry);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sidechainAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_standard\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenNumber\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_withdrawId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenNumber\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sidechainAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"standard\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"tokenNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProxyTo\",\"type\":\"address\"}],\"name\":\"updateProxyTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MainchainGatewayProxy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008407dc57739bcda7aa53ca6f12f82f9d51c2f21e00000000000000000000000033e71e649abdc09f650ad44139674828a2075ad2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2489cc87c94756bca4cb382b1aa499a969d11bc469ee7a3912746a14c5c7862a"}]}