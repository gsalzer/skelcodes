{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/UniswapPairInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/// SWC-103:  Floating Pragma\\npragma solidity 0.6.12;\\n\\ninterface UniswapPairInterface {\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\"\r\n    },\r\n    \"/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveEthereumInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface XplosiveEthereumInterface {\\n    //Public functions\\n    function maxScalingFactor() external view returns (uint256);\\n    function xETHScalingFactor() external view returns (uint256);\\n    //rebase permissioned\\n    function setTxFee(uint16 fee) external ;\\n    function setSellFee(uint16 fee) external ;\\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveGovenorable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract XplosiveGovenorable is Ownable {\\n  address private _governor;\\n\\n  event TransferredGovenorship(address indexed previousGovenor, address indexed newGovenor);\\n\\n  constructor()\\n  internal\\n  {\\n    address msgSender = _msgSender();\\n    _governor = msgSender;\\n    emit TransferredGovenorship(address(0), msgSender);\\n  }\\n\\n  function Governor() public view returns(address) {\\n    return _governor;\\n  }\\n\\n  modifier onlyGovenor() {\\n    require(_governor == _msgSender(), \\\"caller is not govenor\\\");\\n    _;\\n  }\\n\\n  function transferGovenorship(address newGovenor) public virtual onlyOwner {\\n    require(newGovenor != address(0), \\\"new rebaser is address zero\\\");\\n    emit TransferredGovenorship(_governor, newGovenor);\\n    _governor = newGovenor;\\n  }\\n}\\n\"\r\n    },\r\n    \"/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveRebaseOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n/**\\n *\\n * ██╗  ██╗███████╗████████╗██╗  ██╗\\n * ╚██╗██╔╝██╔════╝╚══██╔══╝██║  ██║\\n *  ╚███╔╝ █████╗     ██║   ███████║\\n *  ██╔██╗ ██╔══╝     ██║   ██╔══██║\\n * ██╔╝ ██╗███████╗   ██║   ██║  ██║\\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝\\n *\\n *    An Ethereum pegged\\n * base-down, burn-up currency.\\n *       Rebase-Oracle\\n *\\n *  https://xEth.finance\\n *\\n *\\n**/\\n\\n\\n/// SWC-103:  Floating Pragma\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./XplosiveSafeMath.sol\\\";\\nimport \\\"./XplosiveEthereumInterface.sol\\\";\\nimport \\\"./UniswapPairInterface.sol\\\";\\nimport './XplosiveGovenorable.sol';\\n\\ncontract XplosiveRebaseOracle is Ownable, XplosiveGovenorable\\n{\\n  using XplosiveSafeMath for uint256;\\n\\n  /// @notice an event emitted when deviationThreshold is changed\\n  event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\\n\\n  event TargetToleranceChanged(uint256 _newTolerance);\\n\\n  /// @notice Spreads out getting to the target price\\n  uint256 public rebaseLag;\\n\\n  /// @notice Peg target\\n  uint256 public targetRate;\\n\\n  uint256 private targetTolerance = 0.2 ether;\\n\\n  // If the current exchange rate is within this fractional distance from the target, no supply\\n  // update is performed. Fixed point number--same format as the rate.\\n  // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\\n  uint256 public deviationThreshold;\\n\\n  /// @notice More than this much time must pass between rebase operations.\\n  uint256 public minRebaseTimeIntervalSec;\\n\\n  /// @notice Block timestamp of last rebase operation\\n  uint256 public lastRebaseTimestampSec;\\n\\n  /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\\n  // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\\n  uint256 public rebaseWindowOffsetSec;\\n\\n  /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\\n  uint256 public rebaseWindowLengthSec;\\n\\n  /// @notice The number of rebase cycles since inception\\n  uint256 public epoch;\\n\\n  /// @notice delays rebasing activation to facilitate liquidity\\n  uint256 public constant rebaseDelay = 0;\\n\\n  address public xETHAddress;\\n\\n  address public uniswap_xeth_eth_pair;\\n\\n  mapping(address => bool) public whitelistFrom;\\n\\n  constructor(address _XplosiveTokenAddress, address _XplosiveUniswapPairAddress)\\n  public\\n  Ownable()\\n  XplosiveGovenorable()\\n  {\\n      minRebaseTimeIntervalSec = 1 days;\\n      rebaseWindowOffsetSec = 0; // 00:00 UTC rebases\\n      // Default Target Rate Set For 1 ETH\\n      targetRate = 10**18;\\n      // daily rebase, with targeting reaching peg\\n      rebaseLag = 1;\\n      // 5%\\n      // deviationThreshold = 5 * 10**15;\\n      // 20%\\n      deviationThreshold = 0.2 ether;\\n      // 24 hours\\n      rebaseWindowLengthSec = 24 hours;\\n      uniswap_xeth_eth_pair = _XplosiveUniswapPairAddress;\\n      xETHAddress = _XplosiveTokenAddress;\\n  }\\n\\n  function setWhitelistedRebaserAddress(address _addr, bool _whitelisted)\\n  external\\n  onlyGovenor\\n  {\\n      whitelistFrom[_addr] = _whitelisted;\\n  }\\n\\n\\n  function _isWhitelisted(address _from)\\n  internal\\n  view\\n  returns (bool)\\n  {\\n      return whitelistFrom[_from];\\n  }\\n\\n  /**\\n  * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\n  *\\n  * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\\n  *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\n  *      and targetRate is 1e18\\n  */\\n  function rebase()\\n  public\\n  {\\n    // EOA only\\n    require(msg.sender == tx.origin);\\n    require(_isWhitelisted(msg.sender));\\n    // ensure rebasing at correct time\\n    _inRebaseWindow();\\n\\n    require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\\n\\n    // Snap the rebase time to the start of this window.\\n    lastRebaseTimestampSec = now;\\n\\n    epoch = epoch.add(1);\\n\\n    // get price from uniswap v2;\\n    // uint256 exchangeRate = getPrice();\\n    (uint xethReserve, uint ethReserve, ) = UniswapPairInterface(uniswap_xeth_eth_pair).getReserves();\\n    uint uniPrice = ethReserve.mul(10e18).div(xethReserve);\\n\\n    // calculates % change to supply\\n    // (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\\n    (uint256 offPegPerc, bool positive) = computeOffPegPerc(uniPrice);\\n\\n    uint256 indexDelta;\\n    if(!positive)\\n    {\\n      indexDelta = uniPrice;\\n    }\\n    else\\n    {\\n      indexDelta = offPegPerc;\\n    }\\n\\n    // Apply the Dampening factor.\\n    indexDelta = indexDelta.div(rebaseLag);\\n\\n    XplosiveEthereumInterface xETH = XplosiveEthereumInterface(xETHAddress);\\n\\n    if (positive)\\n    {\\n      require(xETH.xETHScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < xETH.maxScalingFactor(), \\\"new scaling factor will be too big\\\");\\n    }\\n\\n    // rebase\\n    xETH.rebase(epoch, indexDelta, positive);\\n    assert(xETH.xETHScalingFactor() <= xETH.maxScalingFactor());\\n  }\\n\\n  /**\\n  * @dev Use Circuit Breakers (Prevents some un godly amount of XETHG to be minted)\\n  * 1.xETHG Price Marker\\n  * 2.Set Rebase 20% treashold\\n  * 3.Calculate Uni Pair Price\\n  * 4.Target Price + Circuit Breaker\\n  * 5.Accepted xETHprice Price For Rebase\\n  * 6.Is Uniswap Price Over Circuit Breaker?\\n  * 7.Yes, Use Rebase xETHCircuit Breaker Price\\n  * 8.No, Use Uniswap Price\\n  */\\n  // function getPrice()\\n  // public\\n  // view\\n  // onlyGovenor\\n  // returns (uint256)\\n  // {\\n  //   (uint xethReserve, uint ethReserve, ) = UniswapPairInterface(uniswap_xeth_eth_pair).getReserves();\\n  //   // uint xEthPrice;\\n  //   // uint ETHER = 1 ether;\\n  //   // uint ETHER_80 = 0.8 ether;\\n  //   // uint BASE_20 = ETHER.sub(ETHER_80);\\n  //   // uint BASE_20 = 0.2 ether;\\n\\n  //   // uint uniPrice = ethReserve.mul(ETHER).div(xethReserve);\\n  //   uint uniPrice = ethReserve.mul(10e18).div(xethReserve);\\n  //   // uint circuitBreaker = (targetRate.mul(BASE_20)).div(10e18);\\n  //   uint newTargetRate = targetRate.mul(targetTolerance).div(10e18);\\n  //   // uint xEthCircuitBreakerPrice = targetRate.add(circuitBreaker);\\n  //   uint expectedTargetRate = targetRate.add(newTargetRate);\\n  //   if (uniPrice > expectedTargetRate)\\n  //   {\\n  //     // return xEthPrice = xEthCircuitBreakerPrice;\\n  //     return expectedTargetRate;\\n  //   }\\n  //   else\\n  //   {\\n  //     // return xEthPrice = uniPrice;\\n  //     return uniPrice;\\n  //   }\\n\\n  // }\\n\\n  function setDeviationThreshold(uint256 deviationThreshold_)\\n  external\\n    onlyGovenor\\n\\n  {\\n    require(deviationThreshold > 0);\\n    uint256 oldDeviationThreshold = deviationThreshold;\\n    deviationThreshold = deviationThreshold_;\\n    emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\\n  }\\n\\n  /**\\n  * @notice Sets the rebase lag parameter.\\n  It is used to dampen the applied supply adjustment by 1 / rebaseLag\\n  If the rebase lag R, equals 1, the smallest value for R, then the full supply\\n  correction is applied on each rebase cycle.\\n  If it is greater than 1, then a correction of 1/R of is applied on each rebase.\\n  * @param rebaseLag_ The new rebase lag parameter.\\n  */\\n  function setRebaseLag(uint256 rebaseLag_)\\n  external\\n  onlyGovenor\\n  {\\n    require(rebaseLag_ > 0);\\n    rebaseLag = rebaseLag_;\\n  }\\n\\n  /**\\n  * @notice Sets the targetRate parameter.\\n  * @param targetRate_ The new target rate parameter.\\n  */\\n  function setTargetRate(uint256 targetRate_)\\n  external\\n  onlyGovenor\\n  {\\n    require(targetRate_ > 0);\\n    targetRate = targetRate_;\\n  }\\n\\n  /**\\n  * @notice Sets the parameters which control the timing and frequency of\\n  *         rebase operations.\\n  *         a) the minimum time period that must elapse between rebase cycles.\\n  *         b) the rebase window offset parameter.\\n  *         c) the rebase window length parameter.\\n  * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\\n  *        operations, in seconds.\\n  * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\\n  the rebase interval, where the rebase window begins.\\n  * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\\n  */\\n  function setRebaseTimingParameters(uint256 minRebaseTimeIntervalSec_, uint256 rebaseWindowOffsetSec_, uint256 rebaseWindowLengthSec_)\\n  external\\n  onlyGovenor\\n  {\\n    require(minRebaseTimeIntervalSec_ > 0);\\n    require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\\n\\n    minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\n    rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\\n    rebaseWindowLengthSec = rebaseWindowLengthSec_;\\n  }\\n\\n  /**\\n  * @return If the latest block timestamp is within the rebase time window it, returns true.\\n  *         Otherwise, returns false.\\n  */\\n  function inRebaseWindow()\\n  public\\n  view\\n  returns (bool)\\n  {\\n    // rebasing is delayed until there is a liquid market\\n    _inRebaseWindow();\\n    return true;\\n  }\\n\\n  function _inRebaseWindow()\\n  internal\\n  view\\n  {\\n    require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, \\\"too early\\\");\\n    require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \\\"too late\\\");\\n  }\\n\\n  // function testComputeOddPegPercent(uint256 _rate)\\n  // external\\n  // view\\n  // onlyOwner\\n  // returns (uint256, bool)\\n  // {\\n  //   (uint256 difference, bool overtarget) = computeOffPegPerc(_rate);\\n  //   return (difference, overtarget);\\n  // }\\n\\n  /**\\n  * @return Computes in % how far off market is from peg\\n  */\\n  function computeOffPegPerc(uint256 rate)\\n  private\\n  view\\n  returns (uint256, bool)\\n  {\\n    if (withinDeviationThreshold(rate))\\n    {\\n      return (0, false);\\n    }\\n\\n    // indexDelta =  (rate - targetRate) / targetRate\\n    if (rate > targetRate)\\n    {\\n      uint256 t = rate.sub(targetRate).mul(10**18).div(targetRate);\\n      if(t > deviationThreshold)\\n      {\\n        return (deviationThreshold, true);\\n      }\\n\\n      return (t, true);\\n    }\\n\\n    // return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\\n    return (0, false);\\n  }\\n\\n  // function testWithinDeviationThreshold(uint256 _rate)\\n  // external\\n  // view\\n  // onlyOwner\\n  // returns (bool)\\n  // {\\n  //   bool b = withinDeviationThreshold(_rate);\\n  //   return b;\\n  // }\\n\\n  /**\\n  * @param rate The current exchange rate, an 18 decimal fixed point number.\\n  * @return If the rate is within the deviation threshold from the target rate, returns true.\\n  *         Otherwise, returns false.\\n  */\\n  function withinDeviationThreshold(uint256 rate)\\n  private\\n  view\\n  returns (bool)\\n  {\\n    uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold).div(10 ** 18);\\n    return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold) || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\\n  }\\n\\n  // function getTargetTolerance()\\n  // public\\n  // view\\n  // returns (uint256)\\n  // {\\n  //   return targetTolerance;\\n  // }\\n\\n  // function setTargetTolerance(uint256 _newTolerance)\\n  // external\\n  // onlyGovenor\\n  // {\\n  //   targetTolerance = _newTolerance;\\n  //   emit TargetToleranceChanged(targetTolerance);\\n  // }\\n}\\n\"\r\n    },\r\n    \"/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary XplosiveSafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256)\\n    {\\n        uint256 c = add(a,m);\\n        uint256 d = sub(c,1);\\n        return mul(div(d,m),m);\\n    }\\n\\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\\n        require(y != 0, \\\"Div by zero\\\");\\n        uint256 r = x / y;\\n        if (x % y != 0) {\\n            r = r + 1;\\n        }\\n\\n        return r;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_XplosiveTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_XplosiveUniswapPairAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeviationThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeviationThreshold\",\"type\":\"uint256\"}],\"name\":\"NewDeviationThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newTolerance\",\"type\":\"uint256\"}],\"name\":\"TargetToleranceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovenor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovenor\",\"type\":\"address\"}],\"name\":\"TransferredGovenorship\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deviationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inRebaseWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseWindowLengthSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseWindowOffsetSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviationThreshold_\",\"type\":\"uint256\"}],\"name\":\"setDeviationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseLag_\",\"type\":\"uint256\"}],\"name\":\"setRebaseLag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRebaseTimeIntervalSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowOffsetSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowLengthSec_\",\"type\":\"uint256\"}],\"name\":\"setRebaseTimingParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetRate_\",\"type\":\"uint256\"}],\"name\":\"setTargetRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedRebaserAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovenor\",\"type\":\"address\"}],\"name\":\"transferGovenorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap_xeth_eth_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XplosiveRebaseOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000870a28efad4fe2964c810c644f05773248c203b9000000000000000000000000d3d2e2692501a5c9ca623199d38826e513033a17","EVMVersion":"petersburg","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}