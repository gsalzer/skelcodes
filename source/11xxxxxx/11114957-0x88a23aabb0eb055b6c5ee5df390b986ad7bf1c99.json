{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenVestingFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./TokenVesting.sol\\\";\\n\\n\\n/**\\n * @title TokenVestingFactory\\n * @dev A factory to deploy instances of TokenVesting for RSR, nothing more. \\n */\\ncontract TokenVestingFactory  {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  event TokenVestingDeployed(address indexed location, address indexed recipient);\\n\\n\\n  constructor() public {}\\n\\n  function deployVestingContract(address recipient, uint256 startVestingInThisManySeconds, uint256 vestForThisManySeconds) public returns (address) {\\n    TokenVesting vesting = new TokenVesting(\\n        recipient, \\n        block.timestamp, \\n        startVestingInThisManySeconds, \\n        vestForThisManySeconds\\n    );\\n\\n    emit TokenVestingDeployed(address(vesting), recipient);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/CrowdsaleMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../crowdsale/Crowdsale.sol\\\";\\n\\ncontract CrowdsaleMock is Crowdsale {\\n  constructor(uint256 rate, address wallet, IERC20 token) public\\n    Crowdsale(rate, wallet, token) {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/SignatureBouncerMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../drafts/SignatureBouncer.sol\\\";\\nimport \\\"./SignerRoleMock.sol\\\";\\n\\ncontract SignatureBouncerMock is SignatureBouncer, SignerRoleMock {\\n  function checkValidSignature(address account, bytes signature)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return _isValidSignature(account, signature);\\n  }\\n\\n  function onlyWithValidSignature(bytes signature)\\n    public\\n    onlyValidSignature(signature)\\n    view\\n  {\\n\\n  }\\n\\n  function checkValidSignatureAndMethod(address account, bytes signature)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return _isValidSignatureAndMethod(account, signature);\\n  }\\n\\n  function onlyWithValidSignatureAndMethod(bytes signature)\\n    public\\n    onlyValidSignatureAndMethod(signature)\\n    view\\n  {\\n\\n  }\\n\\n  function checkValidSignatureAndData(\\n    address account,\\n    bytes,\\n    uint,\\n    bytes signature\\n  )\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return _isValidSignatureAndData(account, signature);\\n  }\\n\\n  function onlyWithValidSignatureAndData(uint, bytes signature)\\n    public\\n    onlyValidSignatureAndData(signature)\\n    view\\n  {\\n\\n  }\\n\\n  function theWrongMethod(bytes)\\n    public\\n    pure\\n  {\\n\\n  }\\n\\n  function tooShortMsgData()\\n    public\\n    onlyValidSignatureAndData(\\\"\\\")\\n    view\\n  {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/AddressImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../utils/Address.sol\\\";\\n\\ncontract AddressImpl {\\n  function isContract(address account)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return Address.isContract(account); \\n  }\\n  \\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/SafeMathMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\ncontract SafeMathMock {\\n\\n  function mul(uint256 a, uint256 b) public pure returns (uint256) {\\n    return SafeMath.mul(a, b);\\n  }\\n\\n  function div(uint256 a, uint256 b) public pure returns (uint256) {\\n    return SafeMath.div(a, b);\\n  }\\n\\n  function sub(uint256 a, uint256 b) public pure returns (uint256) {\\n    return SafeMath.sub(a, b);\\n  }\\n\\n  function add(uint256 a, uint256 b) public pure returns (uint256) {\\n    return SafeMath.add(a, b);\\n  }\\n\\n  function mod(uint256 a, uint256 b) public pure returns (uint256) {\\n    return SafeMath.mod(a, b);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/MintedCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"../crowdsale/emission/MintedCrowdsale.sol\\\";\\n\\ncontract MintedCrowdsaleImpl is MintedCrowdsale {\\n\\n  constructor (\\n    uint256 rate,\\n    address wallet,\\n    ERC20Mintable token\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/MinterRoleMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/roles/MinterRole.sol\\\";\\n\\ncontract MinterRoleMock is MinterRole {\\n  function removeMinter(address account) public {\\n    _removeMinter(account);\\n  }\\n\\n  function onlyMinterMock() public view onlyMinter {\\n  }\\n\\n  // Causes a compilation error if super._removeMinter is not internal\\n  function _removeMinter(address account) internal {\\n    super._removeMinter(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ReentrancyAttack.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract ReentrancyAttack {\\n\\n  function callSender(bytes4 data) public {\\n    // solium-disable-next-line security/no-low-level-calls\\n    require(msg.sender.call(abi.encodeWithSelector(data)));\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/CappedCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../crowdsale/validation/CappedCrowdsale.sol\\\";\\n\\ncontract CappedCrowdsaleImpl is CappedCrowdsale {\\n\\n  constructor (\\n    uint256 rate,\\n    address wallet,\\n    IERC20 token,\\n    uint256 cap\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n    CappedCrowdsale(cap)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC20PausableMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20Pausable.sol\\\";\\nimport \\\"./PauserRoleMock.sol\\\";\\n\\n// mock class using ERC20Pausable\\ncontract ERC20PausableMock is ERC20Pausable, PauserRoleMock {\\n\\n  constructor(address initialAccount, uint initialBalance) public {\\n    _mint(initialAccount, initialBalance);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ArraysImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../utils/Arrays.sol\\\";\\n\\ncontract ArraysImpl {\\n\\n  using Arrays for uint256[];\\n\\n  uint256[] private array;\\n\\n  constructor(uint256[] _array) public {\\n    array = _array;\\n  }\\n\\n  function findUpperBound(uint256 _element) external view returns (uint256) {\\n    return array.findUpperBound(_element);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/SecondaryMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../ownership/Secondary.sol\\\";\\n\\ncontract SecondaryMock is Secondary {\\n  function onlyPrimaryMock() public view onlyPrimary {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/CounterImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../drafts/Counter.sol\\\";\\n\\ncontract CounterImpl {\\n  using Counter for Counter.Counter;\\n\\n  uint256 public theId;\\n\\n  // use whatever key you want to track your counters\\n  mapping(string => Counter.Counter) private _counters;\\n\\n  function doThing(string key)\\n    public\\n    returns (uint256)\\n  {\\n    theId = _counters[key].next();\\n    return theId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC165Mock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../introspection/ERC165.sol\\\";\\n\\ncontract ERC165Mock is ERC165 {\\n  function registerInterface(bytes4 interfaceId)\\n    public\\n  {\\n    _registerInterface(interfaceId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ECDSAMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../cryptography/ECDSA.sol\\\";\\n\\ncontract ECDSAMock {\\n  using ECDSA for bytes32;\\n\\n  function recover(bytes32 hash, bytes signature)\\n    public\\n    pure\\n    returns (address)\\n  {\\n    return hash.recover(signature);\\n  }\\n\\n  function toEthSignedMessageHash(bytes32 hash)\\n    public\\n    pure\\n    returns (bytes32)\\n  {\\n    return hash.toEthSignedMessageHash();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/IncreasingPriceCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../crowdsale/price/IncreasingPriceCrowdsale.sol\\\";\\nimport \\\"../math/SafeMath.sol\\\";\\n\\ncontract IncreasingPriceCrowdsaleImpl is IncreasingPriceCrowdsale {\\n\\n  constructor (\\n    uint256 openingTime,\\n    uint256 closingTime,\\n    address wallet,\\n    IERC20 token,\\n    uint256 initialRate,\\n    uint256 finalRate\\n  )\\n    public\\n    Crowdsale(initialRate, wallet, token)\\n    TimedCrowdsale(openingTime, closingTime)\\n    IncreasingPriceCrowdsale(initialRate, finalRate)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/PauserRoleMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/roles/PauserRole.sol\\\";\\n\\ncontract PauserRoleMock is PauserRole {\\n  function removePauser(address account) public {\\n    _removePauser(account);\\n  }\\n\\n  function onlyPauserMock() public view onlyPauser {\\n  }\\n\\n  // Causes a compilation error if super._removePauser is not internal\\n  function _removePauser(address account) internal {\\n    super._removePauser(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/OwnableMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../ownership/Ownable.sol\\\";\\n\\ncontract OwnableMock is Ownable {\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/TimedCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../crowdsale/validation/TimedCrowdsale.sol\\\";\\n\\ncontract TimedCrowdsaleImpl is TimedCrowdsale {\\n\\n  constructor (\\n    uint256 openingTime,\\n    uint256 closingTime,\\n    uint256 rate,\\n    address wallet,\\n    IERC20 token\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n    TimedCrowdsale(openingTime, closingTime)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ReentrancyMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\nimport \\\"./ReentrancyAttack.sol\\\";\\n\\ncontract ReentrancyMock is ReentrancyGuard {\\n\\n  uint256 public counter;\\n\\n  constructor() public {\\n    counter = 0;\\n  }\\n\\n  function callback() external nonReentrant {\\n    count();\\n  }\\n\\n  function countLocalRecursive(uint256 n) public nonReentrant {\\n    if (n > 0) {\\n      count();\\n      countLocalRecursive(n - 1);\\n    }\\n  }\\n\\n  function countThisRecursive(uint256 n) public nonReentrant {\\n    if (n > 0) {\\n      count();\\n      // solium-disable-next-line security/no-low-level-calls\\n      bool result = address(this).call(abi.encodeWithSignature(\\\"countThisRecursive(uint256)\\\", n - 1));\\n      require(result == true);\\n    }\\n  }\\n\\n  function countAndCall(ReentrancyAttack attacker) public nonReentrant {\\n    count();\\n    bytes4 func = bytes4(keccak256(\\\"callback()\\\"));\\n    attacker.callSender(func);\\n  }\\n\\n  function count() private {\\n    counter += 1;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC20Mock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\n\\n// mock class using ERC20\\ncontract ERC20Mock is ERC20 {\\n\\n  constructor(address initialAccount, uint256 initialBalance) public {\\n    _mint(initialAccount, initialBalance);\\n  }\\n\\n  function mint(address account, uint256 amount) public {\\n    _mint(account, amount);\\n  }\\n\\n  function burn(address account, uint256 amount) public {\\n    _burn(account, amount);\\n  }\\n\\n  function burnFrom(address account, uint256 amount) public {\\n    _burnFrom(account, amount);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/MerkleProofWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport { MerkleProof } from \\\"../cryptography/MerkleProof.sol\\\";\\n\\ncontract MerkleProofWrapper {\\n\\n  function verify(\\n    bytes32[] proof,\\n    bytes32 root,\\n    bytes32 leaf\\n  )\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    return MerkleProof.verify(proof, root, leaf);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC721Mock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC721/ERC721.sol\\\";\\n\\n/**\\n * @title ERC721Mock\\n * This mock just provides a public mint and burn functions for testing purposes\\n */\\ncontract ERC721Mock is ERC721 {\\n  function mint(address to, uint256 tokenId) public {\\n    _mint(to, tokenId);\\n  }\\n\\n  function burn(uint256 tokenId) public {\\n    _burn(ownerOf(tokenId), tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC20MintableMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"./MinterRoleMock.sol\\\";\\n\\ncontract ERC20MintableMock is ERC20Mintable, MinterRoleMock {\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/PullPaymentMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../payment/PullPayment.sol\\\";\\n\\n// mock class using PullPayment\\ncontract PullPaymentMock is PullPayment {\\n\\n  constructor() public payable { }\\n\\n  // test helper function to call asyncTransfer\\n  function callTransfer(address dest, uint256 amount) public {\\n    _asyncTransfer(dest, amount);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/PostDeliveryCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../crowdsale/distribution/PostDeliveryCrowdsale.sol\\\";\\n\\ncontract PostDeliveryCrowdsaleImpl is PostDeliveryCrowdsale {\\n\\n  constructor (\\n    uint256 openingTime,\\n    uint256 closingTime,\\n    uint256 rate,\\n    address wallet,\\n    IERC20 token\\n  )\\n    public\\n    TimedCrowdsale(openingTime, closingTime)\\n    Crowdsale(rate, wallet, token)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC721PausableMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC721/ERC721Pausable.sol\\\";\\nimport \\\"./PauserRoleMock.sol\\\";\\n\\n/**\\n * @title ERC721PausableMock\\n * This mock just provides a public mint, burn and exists functions for testing purposes\\n */\\ncontract ERC721PausableMock is ERC721Pausable, PauserRoleMock {\\n  function mint(address to, uint256 tokenId) public {\\n    super._mint(to, tokenId);\\n  }\\n\\n  function burn(uint256 tokenId) public {\\n    super._burn(ownerOf(tokenId), tokenId);\\n  }\\n\\n  function exists(uint256 tokenId) public view returns (bool) {\\n    return super._exists(tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC721FullMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC721/ERC721Full.sol\\\";\\nimport \\\"../token/ERC721/ERC721Mintable.sol\\\";\\nimport \\\"../token/ERC721/ERC721MetadataMintable.sol\\\";\\nimport \\\"../token/ERC721/ERC721Burnable.sol\\\";\\n\\n/**\\n * @title ERC721FullMock\\n * This mock just provides a public mint and burn functions for testing purposes,\\n * and a public setter for metadata URI\\n */\\ncontract ERC721FullMock\\n  is ERC721Full, ERC721Mintable, ERC721MetadataMintable, ERC721Burnable {\\n\\n  constructor(string name, string symbol) public\\n    ERC721Mintable()\\n    ERC721Full(name, symbol)\\n  {}\\n\\n  function exists(uint256 tokenId) public view returns (bool) {\\n    return _exists(tokenId);\\n  }\\n\\n  function setTokenURI(uint256 tokenId, string uri) public {\\n    _setTokenURI(tokenId, uri);\\n  }\\n\\n  function removeTokenFrom(address from, uint256 tokenId) public {\\n    _removeTokenFrom(from, tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC165/ERC165NotSupported.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract ERC165NotSupported {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC165/ERC165InterfacesSupported.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-214.md#specification\\n * > Any attempts to make state-changing operations inside an execution instance with STATIC set to true will instead throw an exception.\\n * > These operations include [...], LOG0, LOG1, LOG2, [...]\\n *\\n * therefore, because this contract is staticcall'd we need to not emit events (which is how solidity-coverage works)\\n * solidity-coverage ignores the /mocks folder, so we duplicate its implementation here to avoid instrumenting it\\n */\\ncontract SupportsInterfaceWithLookupMock is IERC165 {\\n\\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\\n  /**\\n   * 0x01ffc9a7 ===\\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\\n   */\\n\\n  /**\\n   * @dev a mapping of interface id to whether or not it's supported\\n   */\\n  mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n  /**\\n   * @dev A contract implementing SupportsInterfaceWithLookup\\n   * implement ERC165 itself\\n   */\\n  constructor()\\n    public\\n  {\\n    _registerInterface(InterfaceId_ERC165);\\n  }\\n\\n  /**\\n   * @dev implement supportsInterface(bytes4) using a lookup table\\n   */\\n  function supportsInterface(bytes4 interfaceId)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _supportedInterfaces[interfaceId];\\n  }\\n\\n  /**\\n   * @dev private method for registering an interface\\n   */\\n  function _registerInterface(bytes4 interfaceId)\\n    internal\\n  {\\n    require(interfaceId != 0xffffffff);\\n    _supportedInterfaces[interfaceId] = true;\\n  }\\n}\\n\\ncontract ERC165InterfacesSupported is SupportsInterfaceWithLookupMock {\\n  constructor (bytes4[] interfaceIds)\\n    public\\n  {\\n    for (uint256 i = 0; i < interfaceIds.length; i++) {\\n      _registerInterface(interfaceIds[i]);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/AllowanceCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../crowdsale/emission/AllowanceCrowdsale.sol\\\";\\n\\ncontract AllowanceCrowdsaleImpl is AllowanceCrowdsale {\\n\\n  constructor (\\n    uint256 rate,\\n    address wallet,\\n    IERC20 token,\\n    address tokenWallet\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n    AllowanceCrowdsale(tokenWallet)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/RolesMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/Roles.sol\\\";\\n\\ncontract RolesMock {\\n  using Roles for Roles.Role;\\n\\n  Roles.Role private dummyRole;\\n\\n  function add(address account) public {\\n    dummyRole.add(account);\\n  }\\n\\n  function remove(address account) public {\\n    dummyRole.remove(account);\\n  }\\n\\n  function has(address account) public view returns (bool) {\\n    return dummyRole.has(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/IndividuallyCappedCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../crowdsale/validation/IndividuallyCappedCrowdsale.sol\\\";\\nimport \\\"./CapperRoleMock.sol\\\";\\n\\ncontract IndividuallyCappedCrowdsaleImpl\\n  is IndividuallyCappedCrowdsale, CapperRoleMock {\\n\\n  constructor(\\n    uint256 rate,\\n    address wallet,\\n    IERC20 token\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n  {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ConditionalEscrowMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../payment/escrow/ConditionalEscrow.sol\\\";\\n\\n// mock class using ConditionalEscrow\\ncontract ConditionalEscrowMock is ConditionalEscrow {\\n  mapping(address => bool) private _allowed;\\n\\n  function setAllowed(address payee, bool allowed) public {\\n    _allowed[payee] = allowed;\\n  }\\n\\n  function withdrawalAllowed(address payee) public view returns (bool) {\\n    return _allowed[payee];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/DetailedERC20Mock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"../token/ERC20/ERC20Detailed.sol\\\";\\n\\ncontract ERC20DetailedMock is ERC20, ERC20Detailed {\\n  constructor(\\n    string name,\\n    string symbol,\\n    uint8 decimals\\n  )\\n    ERC20Detailed(name, symbol, decimals)\\n    public\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/SignerRoleMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/roles/SignerRole.sol\\\";\\n\\ncontract SignerRoleMock is SignerRole {\\n  function removeSigner(address account) public {\\n    _removeSigner(account);\\n  }\\n\\n  function onlySignerMock() public view onlySigner {\\n  }\\n\\n  // Causes a compilation error if super._removeSigner is not internal\\n  function _removeSigner(address account) internal {\\n    super._removeSigner(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/RefundableCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"../crowdsale/distribution/RefundableCrowdsale.sol\\\";\\n\\ncontract RefundableCrowdsaleImpl is RefundableCrowdsale {\\n\\n  constructor (\\n    uint256 openingTime,\\n    uint256 closingTime,\\n    uint256 rate,\\n    address wallet,\\n    ERC20Mintable token,\\n    uint256 goal\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n    TimedCrowdsale(openingTime, closingTime)\\n    RefundableCrowdsale(goal)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/EventEmitter.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract EventEmitter {\\n  event Argumentless();\\n  event ShortUint(uint8 value);\\n  event ShortInt(int8 value);\\n  event LongUint(uint256 value);\\n  event LongInt(int256 value);\\n  event Address(address value);\\n  event Boolean(bool value);\\n  event String(string value);\\n  event LongUintBooleanString(\\n    uint256 uintValue,\\n    bool booleanValue,\\n    string stringValue\\n  );\\n\\n  function emitArgumentless() public {\\n    emit Argumentless();\\n  }\\n\\n  function emitShortUint(uint8 value) public {\\n    emit ShortUint(value);\\n  }\\n\\n  function emitShortInt(int8 value) public {\\n    emit ShortInt(value);\\n  }\\n\\n  function emitLongUint(uint256 value) public {\\n    emit LongUint(value);\\n  }\\n\\n  function emitLongInt(int256 value) public {\\n    emit LongInt(value);\\n  }\\n\\n  function emitAddress(address value) public {\\n    emit Address(value);\\n  }\\n\\n  function emitBoolean(bool value) public {\\n    emit Boolean(value);\\n  }\\n\\n  function emitString(string value) public {\\n    emit String(value);\\n  }\\n\\n  function emitLongUintBooleanString(\\n    uint256 uintValue,\\n    bool booleanValue,\\n    string stringValue)\\n  public {\\n    emit LongUintBooleanString(uintValue, booleanValue, stringValue);\\n  }\\n\\n  function emitLongUintAndBoolean(uint256 uintValue, bool boolValue) public {\\n    emit LongUint(uintValue);\\n    emit Boolean(boolValue);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC20BurnableMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20Burnable.sol\\\";\\n\\ncontract ERC20BurnableMock is ERC20Burnable {\\n\\n  constructor(address initialAccount, uint256 initialBalance) public {\\n    _mint(initialAccount, initialBalance);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC165CheckerMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../introspection/ERC165Checker.sol\\\";\\n\\ncontract ERC165CheckerMock {\\n  using ERC165Checker for address;\\n\\n  function supportsERC165(address account)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return account._supportsERC165();\\n  }\\n\\n  function supportsInterface(address account, bytes4 interfaceId)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return account._supportsInterface(interfaceId);\\n  }\\n\\n  function supportsAllInterfaces(address account, bytes4[] interfaceIds)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return account._supportsAllInterfaces(interfaceIds);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/CapperRoleMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/roles/CapperRole.sol\\\";\\n\\ncontract CapperRoleMock is CapperRole {\\n  function removeCapper(address account) public {\\n    _removeCapper(account);\\n  }\\n\\n  function onlyCapperMock() public view onlyCapper {\\n  }\\n\\n  // Causes a compilation error if super._removeCapper is not internal\\n  function _removeCapper(address account) internal {\\n    super._removeCapper(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC20WithMetadataMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"../drafts/ERC1046/TokenMetadata.sol\\\";\\n\\ncontract ERC20WithMetadataMock is ERC20, ERC20WithMetadata {\\n  constructor(string tokenURI) public\\n    ERC20WithMetadata(tokenURI)\\n  {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/PausableMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../lifecycle/Pausable.sol\\\";\\nimport \\\"./PauserRoleMock.sol\\\";\\n\\n// mock class using Pausable\\ncontract PausableMock is Pausable, PauserRoleMock {\\n  bool public drasticMeasureTaken;\\n  uint256 public count;\\n\\n  constructor() public {\\n    drasticMeasureTaken = false;\\n    count = 0;\\n  }\\n\\n  function normalProcess() external whenNotPaused {\\n    count++;\\n  }\\n\\n  function drasticMeasure() external whenPaused {\\n    drasticMeasureTaken = true;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/SafeERC20Helper.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../token/ERC20/SafeERC20.sol\\\";\\n\\ncontract ERC20FailingMock {\\n  uint256 private _allowance;\\n\\n  function transfer(address, uint256) public returns (bool) {\\n    return false;\\n  }\\n\\n  function transferFrom(address, address, uint256) public returns (bool) {\\n    return false;\\n  }\\n\\n  function approve(address, uint256) public returns (bool) {\\n    return false;\\n  }\\n\\n  function allowance(address, address) public view returns (uint256) {\\n    return 0;\\n  }\\n}\\n\\ncontract ERC20SucceedingMock {\\n  uint256 private _allowance;\\n\\n  function transfer(address, uint256) public returns (bool) {\\n    return true;\\n  }\\n\\n  function transferFrom(address, address, uint256) public returns (bool) {\\n    return true;\\n  }\\n\\n  function approve(address, uint256) public returns (bool) {\\n    return true;\\n  }\\n\\n  function setAllowance(uint256 allowance_) public {\\n    _allowance = allowance_;\\n  }\\n\\n  function allowance(address, address) public view returns (uint256) {\\n    return _allowance;\\n  }\\n}\\n\\ncontract SafeERC20Helper {\\n  using SafeERC20 for IERC20;\\n\\n  IERC20 private _failing;\\n  IERC20 private _succeeding;\\n\\n  constructor() public {\\n    _failing = IERC20(new ERC20FailingMock());\\n    _succeeding = IERC20(new ERC20SucceedingMock());\\n  }\\n\\n  // Using _failing\\n\\n  function doFailingTransfer() public {\\n    _failing.safeTransfer(address(0), 0);\\n  }\\n\\n  function doFailingTransferFrom() public {\\n    _failing.safeTransferFrom(address(0), address(0), 0);\\n  }\\n\\n  function doFailingApprove() public {\\n    _failing.safeApprove(address(0), 0);\\n  }\\n\\n  function doFailingIncreaseAllowance() public {\\n    _failing.safeIncreaseAllowance(address(0), 0);\\n  }\\n\\n  function doFailingDecreaseAllowance() public {\\n    _failing.safeDecreaseAllowance(address(0), 0);\\n  }\\n\\n  // Using _succeeding\\n\\n  function doSucceedingTransfer() public {\\n    _succeeding.safeTransfer(address(0), 0);\\n  }\\n\\n  function doSucceedingTransferFrom() public {\\n    _succeeding.safeTransferFrom(address(0), address(0), 0);\\n  }\\n\\n  function doSucceedingApprove(uint256 amount) public {\\n    _succeeding.safeApprove(address(0), amount);\\n  }\\n\\n  function doSucceedingIncreaseAllowance(uint256 amount) public {\\n    _succeeding.safeIncreaseAllowance(address(0), amount);\\n  }\\n\\n  function doSucceedingDecreaseAllowance(uint256 amount) public {\\n    _succeeding.safeDecreaseAllowance(address(0), amount);\\n  }\\n\\n  function setAllowance(uint256 allowance_) public {\\n    ERC20SucceedingMock(_succeeding).setAllowance(allowance_);\\n  }\\n\\n  function allowance() public view returns (uint256) {\\n    return _succeeding.allowance(address(0), address(0));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/FinalizableCrowdsaleImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../crowdsale/distribution/FinalizableCrowdsale.sol\\\";\\n\\ncontract FinalizableCrowdsaleImpl is FinalizableCrowdsale {\\n\\n  constructor (\\n    uint256 openingTime,\\n    uint256 closingTime,\\n    uint256 rate,\\n    address wallet,\\n    IERC20 token\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n    TimedCrowdsale(openingTime, closingTime)\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC721ReceiverMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC721/IERC721Receiver.sol\\\";\\n\\ncontract ERC721ReceiverMock is IERC721Receiver {\\n  bytes4 private _retval;\\n  bool private _reverts;\\n\\n  event Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes data,\\n    uint256 gas\\n  );\\n\\n  constructor(bytes4 retval, bool reverts) public {\\n    _retval = retval;\\n    _reverts = reverts;\\n  }\\n\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes data\\n  )\\n    public\\n    returns(bytes4)\\n  {\\n    require(!_reverts);\\n    emit Received(\\n      operator,\\n      from,\\n      tokenId,\\n      data,\\n      gasleft() // msg.gas was deprecated in solidityv0.4.21\\n    );\\n    return _retval;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/MathMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../math/Math.sol\\\";\\n\\ncontract MathMock {\\n  function max(uint256 a, uint256 b) public pure returns (uint256) {\\n    return Math.max(a, b);\\n  }\\n\\n  function min(uint256 a, uint256 b) public pure returns (uint256) {\\n    return Math.min(a, b);\\n  }\\n\\n  function average(uint256 a, uint256 b) public pure returns (uint256) {\\n    return Math.average(a, b);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/mocks/ERC721MintableBurnableImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC721/ERC721Full.sol\\\";\\nimport \\\"../token/ERC721/ERC721Mintable.sol\\\";\\nimport \\\"../token/ERC721/ERC721MetadataMintable.sol\\\";\\nimport \\\"../token/ERC721/ERC721Burnable.sol\\\";\\n\\n/**\\n * @title ERC721MintableBurnableImpl\\n */\\ncontract ERC721MintableBurnableImpl\\n  is ERC721Full, ERC721Mintable, ERC721MetadataMintable, ERC721Burnable {\\n\\n  constructor()\\n    ERC721Mintable()\\n    ERC721Full(\\\"Test\\\", \\\"TEST\\\")\\n    public\\n  {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/TokenTimelock.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./SafeERC20.sol\\\";\\n\\n/**\\n * @title TokenTimelock\\n * @dev TokenTimelock is a token holder contract that will allow a\\n * beneficiary to extract the tokens after a given release time\\n */\\ncontract TokenTimelock {\\n  using SafeERC20 for IERC20;\\n\\n  // ERC20 basic token contract being held\\n  IERC20 private _token;\\n\\n  // beneficiary of tokens after they are released\\n  address private _beneficiary;\\n\\n  // timestamp when token release is enabled\\n  uint256 private _releaseTime;\\n\\n  constructor(\\n    IERC20 token,\\n    address beneficiary,\\n    uint256 releaseTime\\n  )\\n    public\\n  {\\n    // solium-disable-next-line security/no-block-members\\n    require(releaseTime > block.timestamp);\\n    _token = token;\\n    _beneficiary = beneficiary;\\n    _releaseTime = releaseTime;\\n  }\\n\\n  /**\\n   * @return the token being held.\\n   */\\n  function token() public view returns(IERC20) {\\n    return _token;\\n  }\\n\\n  /**\\n   * @return the beneficiary of the tokens.\\n   */\\n  function beneficiary() public view returns(address) {\\n    return _beneficiary;\\n  }\\n\\n  /**\\n   * @return the time when the tokens are released.\\n   */\\n  function releaseTime() public view returns(uint256) {\\n    return _releaseTime;\\n  }\\n\\n  /**\\n   * @notice Transfers tokens held by timelock to beneficiary.\\n   */\\n  function release() public {\\n    // solium-disable-next-line security/no-block-members\\n    require(block.timestamp >= _releaseTime);\\n\\n    uint256 amount = _token.balanceOf(address(this));\\n    require(amount > 0);\\n\\n    _token.safeTransfer(_beneficiary, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract ERC20 is IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address => uint256) private _balances;\\n\\n  mapping (address => mapping (address => uint256)) private _allowed;\\n\\n  uint256 private _totalSupply;\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param owner address The address which owns the funds.\\n   * @param spender address The address which will spend the funds.\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   * @param spender The address which will spend the funds.\\n   * @param value The amount of tokens to be spent.\\n   */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param from address The address which you want to send tokens from\\n   * @param to address The address which you want to transfer to\\n   * @param value uint256 the amount of tokens to be transferred\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(value <= _allowed[from][msg.sender]);\\n\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    _transfer(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\n   * approve should be called when allowed_[_spender] == 0. To increment\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param spender The address which will spend the funds.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n   * approve should be called when allowed_[_spender] == 0. To decrement\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param spender The address which will spend the funds.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified addresses\\n  * @param from The address to transfer from.\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address from, address to, uint256 value) internal {\\n    require(value <= _balances[from]);\\n    require(to != address(0));\\n\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n   * @dev Internal function that mints an amount of the token and assigns it to\\n   * an account. This encapsulates the modification of balances such that the\\n   * proper events are emitted.\\n   * @param account The account that will receive the created tokens.\\n   * @param value The amount that will be created.\\n   */\\n  function _mint(address account, uint256 value) internal {\\n    require(account != 0);\\n    _totalSupply = _totalSupply.add(value);\\n    _balances[account] = _balances[account].add(value);\\n    emit Transfer(address(0), account, value);\\n  }\\n\\n  /**\\n   * @dev Internal function that burns an amount of the token of a given\\n   * account.\\n   * @param account The account whose tokens will be burnt.\\n   * @param value The amount that will be burnt.\\n   */\\n  function _burn(address account, uint256 value) internal {\\n    require(account != 0);\\n    require(value <= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(value);\\n    _balances[account] = _balances[account].sub(value);\\n    emit Transfer(account, address(0), value);\\n  }\\n\\n  /**\\n   * @dev Internal function that burns an amount of the token of a given\\n   * account, deducting from the sender's allowance for said account. Uses the\\n   * internal burn function.\\n   * @param account The account whose tokens will be burnt.\\n   * @param value The amount that will be burnt.\\n   */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value <= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @title Burnable Token\\n * @dev Token that can be irreversibly burned (destroyed).\\n */\\ncontract ERC20Burnable is ERC20 {\\n\\n  /**\\n   * @dev Burns a specific amount of tokens.\\n   * @param value The amount of token to be burned.\\n   */\\n  function burn(uint256 value) public {\\n    _burn(msg.sender, value);\\n  }\\n\\n  /**\\n   * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n   * @param from address The address which you want to send tokens from\\n   * @param value uint256 The amount of token to be burned\\n   */\\n  function burnFrom(address from, uint256 value) public {\\n    _burnFrom(from, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n\\n  using SafeMath for uint256;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    require(token.transfer(to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    require(token.transferFrom(from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    // safeApprove should only be called when setting an initial allowance, \\n    // or when resetting it to zero. To increase and decrease it, use \\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require((value == 0) || (token.allowance(msg.sender, spender) == 0));\\n    require(token.approve(spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    require(token.approve(spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n    require(token.approve(spender, newAllowance));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/ERC20Pausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../lifecycle/Pausable.sol\\\";\\n\\n/**\\n * @title Pausable token\\n * @dev ERC20 modified with pausable transfers.\\n **/\\ncontract ERC20Pausable is ERC20, Pausable {\\n\\n  function transfer(\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    whenNotPaused\\n    returns (bool)\\n  {\\n    return super.transfer(to, value);\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    whenNotPaused\\n    returns (bool)\\n  {\\n    return super.transferFrom(from, to, value);\\n  }\\n\\n  function approve(\\n    address spender,\\n    uint256 value\\n  )\\n    public\\n    whenNotPaused\\n    returns (bool)\\n  {\\n    return super.approve(spender, value);\\n  }\\n\\n  function increaseAllowance(\\n    address spender,\\n    uint addedValue\\n  )\\n    public\\n    whenNotPaused\\n    returns (bool success)\\n  {\\n    return super.increaseAllowance(spender, addedValue);\\n  }\\n\\n  function decreaseAllowance(\\n    address spender,\\n    uint subtractedValue\\n  )\\n    public\\n    whenNotPaused\\n    returns (bool success)\\n  {\\n    return super.decreaseAllowance(spender, subtractedValue);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/ERC20Capped.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20Mintable.sol\\\";\\n\\n/**\\n * @title Capped token\\n * @dev Mintable token with a token cap.\\n */\\ncontract ERC20Capped is ERC20Mintable {\\n\\n  uint256 private _cap;\\n\\n  constructor(uint256 cap)\\n    public\\n  {\\n    require(cap > 0);\\n    _cap = cap;\\n  }\\n\\n  /**\\n   * @return the cap for the token minting.\\n   */\\n  function cap() public view returns(uint256) {\\n    return _cap;\\n  }\\n\\n  function _mint(address account, uint256 value) internal {\\n    require(totalSupply().add(value) <= _cap);\\n    super._mint(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../access/roles/MinterRole.sol\\\";\\n\\n/**\\n * @title ERC20Mintable\\n * @dev ERC20 minting logic\\n */\\ncontract ERC20Mintable is ERC20, MinterRole {\\n  /**\\n   * @dev Function to mint tokens\\n   * @param to The address that will receive the minted tokens.\\n   * @param value The amount of tokens to mint.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function mint(\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    onlyMinter\\n    returns (bool)\\n  {\\n    _mint(to, value);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\ncontract ERC20Detailed is IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string name, string symbol, uint8 decimals) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _decimals = decimals;\\n  }\\n\\n  /**\\n   * @return the name of the token.\\n   */\\n  function name() public view returns(string) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @return the symbol of the token.\\n   */\\n  function symbol() public view returns(string) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @return the number of decimals of the token.\\n   */\\n  function decimals() public view returns(uint8) {\\n    return _decimals;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721Enumerable is IERC721 {\\n  function totalSupply() public view returns (uint256);\\n  function tokenOfOwnerByIndex(\\n    address owner,\\n    uint256 index\\n  )\\n    public\\n    view\\n    returns (uint256 tokenId);\\n\\n  function tokenByIndex(uint256 index) public view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721Metadata is IERC721 {\\n  function name() external view returns (string);\\n  function symbol() external view returns (string);\\n  function tokenURI(uint256 tokenId) external view returns (string);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\nimport \\\"./ERC721Metadata.sol\\\";\\n\\n/**\\n * @title Full ERC721 Token\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\\n  constructor(string name, string symbol) ERC721Metadata(name, symbol)\\n    public\\n  {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Mintable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../../access/roles/MinterRole.sol\\\";\\n\\n/**\\n * @title ERC721Mintable\\n * @dev ERC721 minting logic\\n */\\ncontract ERC721Mintable is ERC721, MinterRole {\\n  /**\\n   * @dev Function to mint tokens\\n   * @param to The address that will receive the minted tokens.\\n   * @param tokenId The token id to mint.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function mint(\\n    address to,\\n    uint256 tokenId\\n  )\\n    public\\n    onlyMinter\\n    returns (bool)\\n  {\\n    _mint(to, tokenId);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n  /**\\n   * @notice Handle the receipt of an NFT\\n   * @dev The ERC721 smart contract calls this function on the recipient\\n   * after a `safeTransfer`. This function MUST return the function selector,\\n   * otherwise the caller will revert the transaction. The selector to be\\n   * returned can be obtained as `this.onERC721Received.selector`. This\\n   * function MAY throw to revert and reject the transfer.\\n   * Note: the ERC721 contract address is always the message sender.\\n   * @param operator The address which called `safeTransferFrom` function\\n   * @param from The address which previously owned the token\\n   * @param tokenId The NFT identifier which is being transferred\\n   * @param data Additional data with no specified format\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n   */\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes data\\n  )\\n    public\\n    returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\\n  // Token name\\n  string private _name;\\n\\n  // Token symbol\\n  string private _symbol;\\n\\n  // Optional mapping for token URIs\\n  mapping(uint256 => string) private _tokenURIs;\\n\\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\\n  /**\\n   * 0x5b5e139f ===\\n   *   bytes4(keccak256('name()')) ^\\n   *   bytes4(keccak256('symbol()')) ^\\n   *   bytes4(keccak256('tokenURI(uint256)'))\\n   */\\n\\n  /**\\n   * @dev Constructor function\\n   */\\n  constructor(string name, string symbol) public {\\n    _name = name;\\n    _symbol = symbol;\\n\\n    // register the supported interfaces to conform to ERC721 via ERC165\\n    _registerInterface(InterfaceId_ERC721Metadata);\\n  }\\n\\n  /**\\n   * @dev Gets the token name\\n   * @return string representing the token name\\n   */\\n  function name() external view returns (string) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Gets the token symbol\\n   * @return string representing the token symbol\\n   */\\n  function symbol() external view returns (string) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns an URI for a given token ID\\n   * Throws if the token ID does not exist. May return an empty string.\\n   * @param tokenId uint256 ID of the token to query\\n   */\\n  function tokenURI(uint256 tokenId) external view returns (string) {\\n    require(_exists(tokenId));\\n    return _tokenURIs[tokenId];\\n  }\\n\\n  /**\\n   * @dev Internal function to set the token URI for a given token\\n   * Reverts if the token ID does not exist\\n   * @param tokenId uint256 ID of the token to set its URI\\n   * @param uri string URI to assign\\n   */\\n  function _setTokenURI(uint256 tokenId, string uri) internal {\\n    require(_exists(tokenId));\\n    _tokenURIs[tokenId] = uri;\\n  }\\n\\n  /**\\n   * @dev Internal function to burn a specific token\\n   * Reverts if the token does not exist\\n   * @param owner owner of the token to burn\\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\\n   */\\n  function _burn(address owner, uint256 tokenId) internal {\\n    super._burn(owner, tokenId);\\n\\n    // Clear metadata (if any)\\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\\n      delete _tokenURIs[tokenId];\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Pausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../../lifecycle/Pausable.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Pausable token\\n * @dev ERC721 modified with pausable transfers.\\n **/\\ncontract ERC721Pausable is ERC721, Pausable {\\n  function approve(\\n    address to,\\n    uint256 tokenId\\n  )\\n    public\\n    whenNotPaused\\n  {\\n    super.approve(to, tokenId);\\n  }\\n\\n  function setApprovalForAll(\\n    address to,\\n    bool approved\\n  )\\n    public\\n    whenNotPaused\\n  {\\n    super.setApprovalForAll(to, approved);\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  )\\n    public\\n    whenNotPaused\\n  {\\n    super.transferFrom(from, to, tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721 is ERC165, IERC721 {\\n\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n  // Mapping from token ID to owner\\n  mapping (uint256 => address) private _tokenOwner;\\n\\n  // Mapping from token ID to approved address\\n  mapping (uint256 => address) private _tokenApprovals;\\n\\n  // Mapping from owner to number of owned token\\n  mapping (address => uint256) private _ownedTokensCount;\\n\\n  // Mapping from owner to operator approvals\\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\\n  /*\\n   * 0x80ac58cd ===\\n   *   bytes4(keccak256('balanceOf(address)')) ^\\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\\n   *   bytes4(keccak256('approve(address,uint256)')) ^\\n   *   bytes4(keccak256('getApproved(uint256)')) ^\\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\\n   */\\n\\n  constructor()\\n    public\\n  {\\n    // register the supported interfaces to conform to ERC721 via ERC165\\n    _registerInterface(_InterfaceId_ERC721);\\n  }\\n\\n  /**\\n   * @dev Gets the balance of the specified address\\n   * @param owner address to query the balance of\\n   * @return uint256 representing the amount owned by the passed address\\n   */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    require(owner != address(0));\\n    return _ownedTokensCount[owner];\\n  }\\n\\n  /**\\n   * @dev Gets the owner of the specified token ID\\n   * @param tokenId uint256 ID of the token to query the owner of\\n   * @return owner address currently marked as the owner of the given token ID\\n   */\\n  function ownerOf(uint256 tokenId) public view returns (address) {\\n    address owner = _tokenOwner[tokenId];\\n    require(owner != address(0));\\n    return owner;\\n  }\\n\\n  /**\\n   * @dev Approves another address to transfer the given token ID\\n   * The zero address indicates there is no approved address.\\n   * There can only be one approved address per token at a given time.\\n   * Can only be called by the token owner or an approved operator.\\n   * @param to address to be approved for the given token ID\\n   * @param tokenId uint256 ID of the token to be approved\\n   */\\n  function approve(address to, uint256 tokenId) public {\\n    address owner = ownerOf(tokenId);\\n    require(to != owner);\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n\\n    _tokenApprovals[tokenId] = to;\\n    emit Approval(owner, to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\n   * Reverts if the token ID does not exist.\\n   * @param tokenId uint256 ID of the token to query the approval of\\n   * @return address currently approved for the given token ID\\n   */\\n  function getApproved(uint256 tokenId) public view returns (address) {\\n    require(_exists(tokenId));\\n    return _tokenApprovals[tokenId];\\n  }\\n\\n  /**\\n   * @dev Sets or unsets the approval of a given operator\\n   * An operator is allowed to transfer all tokens of the sender on their behalf\\n   * @param to operator address to set the approval\\n   * @param approved representing the status of the approval to be set\\n   */\\n  function setApprovalForAll(address to, bool approved) public {\\n    require(to != msg.sender);\\n    _operatorApprovals[msg.sender][to] = approved;\\n    emit ApprovalForAll(msg.sender, to, approved);\\n  }\\n\\n  /**\\n   * @dev Tells whether an operator is approved by a given owner\\n   * @param owner owner address which you want to query the approval of\\n   * @param operator operator address which you want to query the approval of\\n   * @return bool whether the given operator is approved by the given owner\\n   */\\n  function isApprovedForAll(\\n    address owner,\\n    address operator\\n  )\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return _operatorApprovals[owner][operator];\\n  }\\n\\n  /**\\n   * @dev Transfers the ownership of a given token ID to another address\\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\n   * Requires the msg sender to be the owner, approved, or operator\\n   * @param from current owner of the token\\n   * @param to address to receive the ownership of the given token ID\\n   * @param tokenId uint256 ID of the token to be transferred\\n  */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  )\\n    public\\n  {\\n    require(_isApprovedOrOwner(msg.sender, tokenId));\\n    require(to != address(0));\\n\\n    _clearApproval(from, tokenId);\\n    _removeTokenFrom(from, tokenId);\\n    _addTokenTo(to, tokenId);\\n\\n    emit Transfer(from, to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Safely transfers the ownership of a given token ID to another address\\n   * If the target address is a contract, it must implement `onERC721Received`,\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   *\\n   * Requires the msg sender to be the owner, approved, or operator\\n   * @param from current owner of the token\\n   * @param to address to receive the ownership of the given token ID\\n   * @param tokenId uint256 ID of the token to be transferred\\n  */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  )\\n    public\\n  {\\n    // solium-disable-next-line arg-overflow\\n    safeTransferFrom(from, to, tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Safely transfers the ownership of a given token ID to another address\\n   * If the target address is a contract, it must implement `onERC721Received`,\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   * Requires the msg sender to be the owner, approved, or operator\\n   * @param from current owner of the token\\n   * @param to address to receive the ownership of the given token ID\\n   * @param tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes data to send along with a safe transfer check\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes _data\\n  )\\n    public\\n  {\\n    transferFrom(from, to, tokenId);\\n    // solium-disable-next-line arg-overflow\\n    require(_checkOnERC721Received(from, to, tokenId, _data));\\n  }\\n\\n  /**\\n   * @dev Returns whether the specified token exists\\n   * @param tokenId uint256 ID of the token to query the existence of\\n   * @return whether the token exists\\n   */\\n  function _exists(uint256 tokenId) internal view returns (bool) {\\n    address owner = _tokenOwner[tokenId];\\n    return owner != address(0);\\n  }\\n\\n  /**\\n   * @dev Returns whether the given spender can transfer a given token ID\\n   * @param spender address of the spender to query\\n   * @param tokenId uint256 ID of the token to be transferred\\n   * @return bool whether the msg.sender is approved for the given token ID,\\n   *  is an operator of the owner, or is the owner of the token\\n   */\\n  function _isApprovedOrOwner(\\n    address spender,\\n    uint256 tokenId\\n  )\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    address owner = ownerOf(tokenId);\\n    // Disable solium check because of\\n    // https://github.com/duaraghav8/Solium/issues/175\\n    // solium-disable-next-line operator-whitespace\\n    return (\\n      spender == owner ||\\n      getApproved(tokenId) == spender ||\\n      isApprovedForAll(owner, spender)\\n    );\\n  }\\n\\n  /**\\n   * @dev Internal function to mint a new token\\n   * Reverts if the given token ID already exists\\n   * @param to The address that will own the minted token\\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\\n   */\\n  function _mint(address to, uint256 tokenId) internal {\\n    require(to != address(0));\\n    _addTokenTo(to, tokenId);\\n    emit Transfer(address(0), to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to burn a specific token\\n   * Reverts if the token does not exist\\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\\n   */\\n  function _burn(address owner, uint256 tokenId) internal {\\n    _clearApproval(owner, tokenId);\\n    _removeTokenFrom(owner, tokenId);\\n    emit Transfer(owner, address(0), tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to add a token ID to the list of a given address\\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\\n   * @param to address representing the new owner of the given token ID\\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n   */\\n  function _addTokenTo(address to, uint256 tokenId) internal {\\n    require(_tokenOwner[tokenId] == address(0));\\n    _tokenOwner[tokenId] = to;\\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\\n  }\\n\\n  /**\\n   * @dev Internal function to remove a token ID from the list of a given address\\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\\n   * and doesn't clear approvals.\\n   * @param from address representing the previous owner of the given token ID\\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n   */\\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\\n    require(ownerOf(tokenId) == from);\\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\\n    _tokenOwner[tokenId] = address(0);\\n  }\\n\\n  /**\\n   * @dev Internal function to invoke `onERC721Received` on a target address\\n   * The call is not executed if the target address is not a contract\\n   * @param from address representing the previous owner of the given token ID\\n   * @param to target address that will receive the tokens\\n   * @param tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes optional data to send along with the call\\n   * @return whether the call correctly returned the expected magic value\\n   */\\n  function _checkOnERC721Received(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes _data\\n  )\\n    internal\\n    returns (bool)\\n  {\\n    if (!to.isContract()) {\\n      return true;\\n    }\\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\\n      msg.sender, from, tokenId, _data);\\n    return (retval == _ERC721_RECEIVED);\\n  }\\n\\n  /**\\n   * @dev Private function to clear current approval of a given token ID\\n   * Reverts if the given address is not indeed the owner of the token\\n   * @param owner owner of the token\\n   * @param tokenId uint256 ID of the token to be transferred\\n   */\\n  function _clearApproval(address owner, uint256 tokenId) private {\\n    require(ownerOf(tokenId) == owner);\\n    if (_tokenApprovals[tokenId] != address(0)) {\\n      _tokenApprovals[tokenId] = address(0);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721 is IERC165 {\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 indexed tokenId\\n  );\\n  event Approval(\\n    address indexed owner,\\n    address indexed approved,\\n    uint256 indexed tokenId\\n  );\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n\\n  function balanceOf(address owner) public view returns (uint256 balance);\\n  function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n  function approve(address to, uint256 tokenId) public;\\n  function getApproved(uint256 tokenId)\\n    public view returns (address operator);\\n\\n  function setApprovalForAll(address operator, bool _approved) public;\\n  function isApprovedForAll(address owner, address operator)\\n    public view returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 tokenId) public;\\n  function safeTransferFrom(address from, address to, uint256 tokenId)\\n    public;\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes data\\n  )\\n    public;\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721MetadataMintable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721Metadata.sol\\\";\\nimport \\\"../../access/roles/MinterRole.sol\\\";\\n\\n\\n/**\\n * @title ERC721MetadataMintable\\n * @dev ERC721 minting logic with metadata\\n */\\ncontract ERC721MetadataMintable is ERC721, ERC721Metadata, MinterRole {\\n  /**\\n   * @dev Function to mint tokens\\n   * @param to The address that will receive the minted tokens.\\n   * @param tokenId The token id to mint.\\n   * @param tokenURI The token URI of the minted token.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function mintWithTokenURI(\\n    address to,\\n    uint256 tokenId,\\n    string tokenURI\\n  )\\n    public\\n    onlyMinter\\n    returns (bool)\\n  {\\n    _mint(to, tokenId);\\n    _setTokenURI(tokenId, tokenURI);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\ncontract ERC721Holder is IERC721Receiver {\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes\\n  )\\n    public\\n    returns(bytes4)\\n  {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\\n  // Mapping from owner to list of owned token IDs\\n  mapping(address => uint256[]) private _ownedTokens;\\n\\n  // Mapping from token ID to index of the owner tokens list\\n  mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n  // Array with all token ids, used for enumeration\\n  uint256[] private _allTokens;\\n\\n  // Mapping from token id to position in the allTokens array\\n  mapping(uint256 => uint256) private _allTokensIndex;\\n\\n  bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\\n  /**\\n   * 0x780e9d63 ===\\n   *   bytes4(keccak256('totalSupply()')) ^\\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\\n   */\\n\\n  /**\\n   * @dev Constructor function\\n   */\\n  constructor() public {\\n    // register the supported interface to conform to ERC721 via ERC165\\n    _registerInterface(_InterfaceId_ERC721Enumerable);\\n  }\\n\\n  /**\\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\\n   * @param owner address owning the tokens list to be accessed\\n   * @param index uint256 representing the index to be accessed of the requested tokens list\\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n   */\\n  function tokenOfOwnerByIndex(\\n    address owner,\\n    uint256 index\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    require(index < balanceOf(owner));\\n    return _ownedTokens[owner][index];\\n  }\\n\\n  /**\\n   * @dev Gets the total amount of tokens stored by the contract\\n   * @return uint256 representing the total amount of tokens\\n   */\\n  function totalSupply() public view returns (uint256) {\\n    return _allTokens.length;\\n  }\\n\\n  /**\\n   * @dev Gets the token ID at a given index of all the tokens in this contract\\n   * Reverts if the index is greater or equal to the total number of tokens\\n   * @param index uint256 representing the index to be accessed of the tokens list\\n   * @return uint256 token ID at the given index of the tokens list\\n   */\\n  function tokenByIndex(uint256 index) public view returns (uint256) {\\n    require(index < totalSupply());\\n    return _allTokens[index];\\n  }\\n\\n  /**\\n   * @dev Internal function to add a token ID to the list of a given address\\n   * This function is internal due to language limitations, see the note in ERC721.sol.\\n   * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event.\\n   * @param to address representing the new owner of the given token ID\\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n   */\\n  function _addTokenTo(address to, uint256 tokenId) internal {\\n    super._addTokenTo(to, tokenId);\\n    uint256 length = _ownedTokens[to].length;\\n    _ownedTokens[to].push(tokenId);\\n    _ownedTokensIndex[tokenId] = length;\\n  }\\n\\n  /**\\n   * @dev Internal function to remove a token ID from the list of a given address\\n   * This function is internal due to language limitations, see the note in ERC721.sol.\\n   * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event,\\n   * and doesn't clear approvals.\\n   * @param from address representing the previous owner of the given token ID\\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n   */\\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\\n    super._removeTokenFrom(from, tokenId);\\n\\n    // To prevent a gap in the array, we store the last token in the index of the token to delete, and\\n    // then delete the last slot.\\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n    uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\n    uint256 lastToken = _ownedTokens[from][lastTokenIndex];\\n\\n    _ownedTokens[from][tokenIndex] = lastToken;\\n    // This also deletes the contents at the last position of the array\\n    _ownedTokens[from].length--;\\n\\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\\n    // be zero. Then we can make sure that we will remove tokenId from the ownedTokens list since we are first swapping\\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\\n\\n    _ownedTokensIndex[tokenId] = 0;\\n    _ownedTokensIndex[lastToken] = tokenIndex;\\n  }\\n\\n  /**\\n   * @dev Internal function to mint a new token\\n   * Reverts if the given token ID already exists\\n   * @param to address the beneficiary that will own the minted token\\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\\n   */\\n  function _mint(address to, uint256 tokenId) internal {\\n    super._mint(to, tokenId);\\n\\n    _allTokensIndex[tokenId] = _allTokens.length;\\n    _allTokens.push(tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to burn a specific token\\n   * Reverts if the token does not exist\\n   * @param owner owner of the token to burn\\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\\n   */\\n  function _burn(address owner, uint256 tokenId) internal {\\n    super._burn(owner, tokenId);\\n\\n    // Reorg all tokens array\\n    uint256 tokenIndex = _allTokensIndex[tokenId];\\n    uint256 lastTokenIndex = _allTokens.length.sub(1);\\n    uint256 lastToken = _allTokens[lastTokenIndex];\\n\\n    _allTokens[tokenIndex] = lastToken;\\n    _allTokens[lastTokenIndex] = 0;\\n\\n    _allTokens.length--;\\n    _allTokensIndex[tokenId] = 0;\\n    _allTokensIndex[lastToken] = tokenIndex;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721Full.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata {\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/token/ERC721/ERC721Burnable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721.sol\\\";\\n\\ncontract ERC721Burnable is ERC721 {\\n  function burn(uint256 tokenId)\\n    public\\n  {\\n    require(_isApprovedOrOwner(msg.sender, tokenId));\\n    _burn(ownerOf(tokenId), tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping (address => bool) bearer;\\n  }\\n\\n  /**\\n   * @dev give an account access to this role\\n   */\\n  function add(Role storage role, address account) internal {\\n    require(account != address(0));\\n    require(!has(role, account));\\n\\n    role.bearer[account] = true;\\n  }\\n\\n  /**\\n   * @dev remove an account's access to this role\\n   */\\n  function remove(Role storage role, address account) internal {\\n    require(account != address(0));\\n    require(has(role, account));\\n\\n    role.bearer[account] = false;\\n  }\\n\\n  /**\\n   * @dev check if an account has this role\\n   * @return bool\\n   */\\n  function has(Role storage role, address account)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    require(account != address(0));\\n    return role.bearer[account];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/access/roles/CapperRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../Roles.sol\\\";\\n\\ncontract CapperRole {\\n  using Roles for Roles.Role;\\n\\n  event CapperAdded(address indexed account);\\n  event CapperRemoved(address indexed account);\\n\\n  Roles.Role private cappers;\\n\\n  constructor() internal {\\n    _addCapper(msg.sender);\\n  }\\n\\n  modifier onlyCapper() {\\n    require(isCapper(msg.sender));\\n    _;\\n  }\\n\\n  function isCapper(address account) public view returns (bool) {\\n    return cappers.has(account);\\n  }\\n\\n  function addCapper(address account) public onlyCapper {\\n    _addCapper(account);\\n  }\\n\\n  function renounceCapper() public {\\n    _removeCapper(msg.sender);\\n  }\\n\\n  function _addCapper(address account) internal {\\n    cappers.add(account);\\n    emit CapperAdded(account);\\n  }\\n\\n  function _removeCapper(address account) internal {\\n    cappers.remove(account);\\n    emit CapperRemoved(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/access/roles/MinterRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../Roles.sol\\\";\\n\\ncontract MinterRole {\\n  using Roles for Roles.Role;\\n\\n  event MinterAdded(address indexed account);\\n  event MinterRemoved(address indexed account);\\n\\n  Roles.Role private minters;\\n\\n  constructor() internal {\\n    _addMinter(msg.sender);\\n  }\\n\\n  modifier onlyMinter() {\\n    require(isMinter(msg.sender));\\n    _;\\n  }\\n\\n  function isMinter(address account) public view returns (bool) {\\n    return minters.has(account);\\n  }\\n\\n  function addMinter(address account) public onlyMinter {\\n    _addMinter(account);\\n  }\\n\\n  function renounceMinter() public {\\n    _removeMinter(msg.sender);\\n  }\\n\\n  function _addMinter(address account) internal {\\n    minters.add(account);\\n    emit MinterAdded(account);\\n  }\\n\\n  function _removeMinter(address account) internal {\\n    minters.remove(account);\\n    emit MinterRemoved(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/access/roles/PauserRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../Roles.sol\\\";\\n\\ncontract PauserRole {\\n  using Roles for Roles.Role;\\n\\n  event PauserAdded(address indexed account);\\n  event PauserRemoved(address indexed account);\\n\\n  Roles.Role private pausers;\\n\\n  constructor() internal {\\n    _addPauser(msg.sender);\\n  }\\n\\n  modifier onlyPauser() {\\n    require(isPauser(msg.sender));\\n    _;\\n  }\\n\\n  function isPauser(address account) public view returns (bool) {\\n    return pausers.has(account);\\n  }\\n\\n  function addPauser(address account) public onlyPauser {\\n    _addPauser(account);\\n  }\\n\\n  function renouncePauser() public {\\n    _removePauser(msg.sender);\\n  }\\n\\n  function _addPauser(address account) internal {\\n    pausers.add(account);\\n    emit PauserAdded(account);\\n  }\\n\\n  function _removePauser(address account) internal {\\n    pausers.remove(account);\\n    emit PauserRemoved(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/access/roles/SignerRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../Roles.sol\\\";\\n\\ncontract SignerRole {\\n  using Roles for Roles.Role;\\n\\n  event SignerAdded(address indexed account);\\n  event SignerRemoved(address indexed account);\\n\\n  Roles.Role private signers;\\n\\n  constructor() internal {\\n    _addSigner(msg.sender);\\n  }\\n\\n  modifier onlySigner() {\\n    require(isSigner(msg.sender));\\n    _;\\n  }\\n\\n  function isSigner(address account) public view returns (bool) {\\n    return signers.has(account);\\n  }\\n\\n  function addSigner(address account) public onlySigner {\\n    _addSigner(account);\\n  }\\n\\n  function renounceSigner() public {\\n    _removeSigner(msg.sender);\\n  }\\n\\n  function _addSigner(address account) internal {\\n    signers.add(account);\\n    emit SignerAdded(account);\\n  }\\n\\n  function _removeSigner(address account) internal {\\n    signers.remove(account);\\n    emit SignerRemoved(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Elliptic curve signature operations\\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\\n * See https://github.com/ethereum/solidity/issues/864\\n */\\n\\nlibrary ECDSA {\\n\\n  /**\\n   * @dev Recover signer address from a message by using their signature\\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\\n   * @param signature bytes signature, the signature is generated using web3.eth.sign()\\n   */\\n  function recover(bytes32 hash, bytes signature)\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n\\n    // Check the signature length\\n    if (signature.length != 65) {\\n      return (address(0));\\n    }\\n\\n    // Divide the signature in r, s and v variables\\n    // ecrecover takes the signature parameters, and the only way to get them\\n    // currently is to use assembly.\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly {\\n      r := mload(add(signature, 0x20))\\n      s := mload(add(signature, 0x40))\\n      v := byte(0, mload(add(signature, 0x60)))\\n    }\\n\\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n    if (v < 27) {\\n      v += 27;\\n    }\\n\\n    // If the version is correct return the signer address\\n    if (v != 27 && v != 28) {\\n      return (address(0));\\n    } else {\\n      // solium-disable-next-line arg-overflow\\n      return ecrecover(hash, v, r, s);\\n    }\\n  }\\n\\n  /**\\n   * toEthSignedMessageHash\\n   * @dev prefix a bytes32 value with \\\"\\\\x19Ethereum Signed Message:\\\"\\n   * and hash the result\\n   */\\n  function toEthSignedMessageHash(bytes32 hash)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    // 32 is the length in bytes of hash,\\n    // enforced by the type signature above\\n    return keccak256(\\n      abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title MerkleProof\\n * @dev Merkle proof verification based on\\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\\n */\\nlibrary MerkleProof {\\n  /**\\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\\n   * and each pair of pre-images are sorted.\\n   * @param proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\\n   * @param root Merkle root\\n   * @param leaf Leaf of Merkle tree\\n   */\\n  function verify(\\n    bytes32[] proof,\\n    bytes32 root,\\n    bytes32 leaf\\n  )\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    bytes32 computedHash = leaf;\\n\\n    for (uint256 i = 0; i < proof.length; i++) {\\n      bytes32 proofElement = proof[i];\\n\\n      if (computedHash < proofElement) {\\n        // Hash(current computed hash + current element of the proof)\\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n      } else {\\n        // Hash(current element of the proof + current computed hash)\\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n      }\\n    }\\n\\n    // Check if the computed hash (root) is equal to the provided root\\n    return computedHash == root;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/payment/PaymentSplitter.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title PaymentSplitter\\n * @dev This contract can be used when payments need to be received by a group\\n * of people and split proportionately to some number of shares they own.\\n */\\ncontract PaymentSplitter {\\n  using SafeMath for uint256;\\n\\n  event PayeeAdded(address account, uint256 shares);\\n  event PaymentReleased(address to, uint256 amount);\\n  event PaymentReceived(address from, uint256 amount);\\n\\n  uint256 private _totalShares;\\n  uint256 private _totalReleased;\\n\\n  mapping(address => uint256) private _shares;\\n  mapping(address => uint256) private _released;\\n  address[] private _payees;\\n\\n  /**\\n   * @dev Constructor\\n   */\\n  constructor(address[] payees, uint256[] shares) public payable {\\n    require(payees.length == shares.length);\\n    require(payees.length > 0);\\n\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      _addPayee(payees[i], shares[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev payable fallback\\n   */\\n  function () external payable {\\n    emit PaymentReceived(msg.sender, msg.value);\\n  }\\n\\n  /**\\n   * @return the total shares of the contract.\\n   */\\n  function totalShares() public view returns(uint256) {\\n    return _totalShares;\\n  }\\n\\n  /**\\n   * @return the total amount already released.\\n   */\\n  function totalReleased() public view returns(uint256) {\\n    return _totalReleased;\\n  }\\n\\n  /**\\n   * @return the shares of an account.\\n   */\\n  function shares(address account) public view returns(uint256) {\\n    return _shares[account];\\n  }\\n\\n  /**\\n   * @return the amount already released to an account.\\n   */\\n  function released(address account) public view returns(uint256) {\\n    return _released[account];\\n  }\\n\\n  /**\\n   * @return the address of a payee.\\n   */\\n  function payee(uint256 index) public view returns(address) {\\n    return _payees[index];\\n  }\\n\\n  /**\\n   * @dev Release one of the payee's proportional payment.\\n   * @param account Whose payments will be released.\\n   */\\n  function release(address account) public {\\n    require(_shares[account] > 0);\\n\\n    uint256 totalReceived = address(this).balance.add(_totalReleased);\\n    uint256 payment = totalReceived.mul(\\n      _shares[account]).div(\\n        _totalShares).sub(\\n          _released[account]\\n    );\\n\\n    require(payment != 0);\\n\\n    _released[account] = _released[account].add(payment);\\n    _totalReleased = _totalReleased.add(payment);\\n\\n    account.transfer(payment);\\n    emit PaymentReleased(account, payment);\\n  }\\n\\n  /**\\n   * @dev Add a new payee to the contract.\\n   * @param account The address of the payee to add.\\n   * @param shares_ The number of shares owned by the payee.\\n   */\\n  function _addPayee(address account, uint256 shares_) private {\\n    require(account != address(0));\\n    require(shares_ > 0);\\n    require(_shares[account] == 0);\\n\\n    _payees.push(account);\\n    _shares[account] = shares_;\\n    _totalShares = _totalShares.add(shares_);\\n    emit PayeeAdded(account, shares_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/payment/PullPayment.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./escrow/Escrow.sol\\\";\\n\\n/**\\n * @title PullPayment\\n * @dev Base contract supporting async send for pull payments. Inherit from this\\n * contract and use _asyncTransfer instead of send or transfer.\\n */\\ncontract PullPayment {\\n  Escrow private _escrow;\\n\\n  constructor() internal {\\n    _escrow = new Escrow();\\n  }\\n\\n  /**\\n  * @dev Withdraw accumulated balance.\\n  * @param payee Whose balance will be withdrawn.\\n  */\\n  function withdrawPayments(address payee) public {\\n    _escrow.withdraw(payee);\\n  }\\n\\n  /**\\n  * @dev Returns the credit owed to an address.\\n  * @param dest The creditor's address.\\n  */\\n  function payments(address dest) public view returns (uint256) {\\n    return _escrow.depositsOf(dest);\\n  }\\n\\n  /**\\n  * @dev Called by the payer to store the sent amount as credit to be pulled.\\n  * @param dest The destination address of the funds.\\n  * @param amount The amount to transfer.\\n  */\\n  function _asyncTransfer(address dest, uint256 amount) internal {\\n    _escrow.deposit.value(amount)(dest);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/payment/escrow/Escrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../ownership/Secondary.sol\\\";\\n\\n /**\\n * @title Escrow\\n * @dev Base escrow contract, holds funds designated for a payee until they\\n * withdraw them.\\n * @dev Intended usage: This contract (and derived escrow contracts) should be a\\n * standalone contract, that only interacts with the contract that instantiated\\n * it. That way, it is guaranteed that all Ether will be handled according to\\n * the Escrow rules, and there is no need to check for payable functions or\\n * transfers in the inheritance tree. The contract that uses the escrow as its\\n * payment method should be its primary, and provide public methods redirecting\\n * to the escrow's deposit and withdraw.\\n */\\ncontract Escrow is Secondary {\\n  using SafeMath for uint256;\\n\\n  event Deposited(address indexed payee, uint256 weiAmount);\\n  event Withdrawn(address indexed payee, uint256 weiAmount);\\n\\n  mapping(address => uint256) private _deposits;\\n\\n  function depositsOf(address payee) public view returns (uint256) {\\n    return _deposits[payee];\\n  }\\n\\n  /**\\n  * @dev Stores the sent amount as credit to be withdrawn.\\n  * @param payee The destination address of the funds.\\n  */\\n  function deposit(address payee) public onlyPrimary payable {\\n    uint256 amount = msg.value;\\n    _deposits[payee] = _deposits[payee].add(amount);\\n\\n    emit Deposited(payee, amount);\\n  }\\n\\n  /**\\n  * @dev Withdraw accumulated balance for a payee.\\n  * @param payee The address whose funds will be withdrawn and transferred to.\\n  */\\n  function withdraw(address payee) public onlyPrimary {\\n    uint256 payment = _deposits[payee];\\n\\n    _deposits[payee] = 0;\\n\\n    payee.transfer(payment);\\n\\n    emit Withdrawn(payee, payment);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/payment/escrow/RefundEscrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./ConditionalEscrow.sol\\\";\\n\\n/**\\n * @title RefundEscrow\\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\\n * parties.\\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\\n * @dev The primary account (that is, the contract that instantiates this\\n * contract) may deposit, close the deposit period, and allow for either\\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\\n * with RefundEscrow will be made through the primary contract. See the\\n * RefundableCrowdsale contract for an example of RefundEscrow’s use.\\n */\\ncontract RefundEscrow is ConditionalEscrow {\\n  enum State { Active, Refunding, Closed }\\n\\n  event RefundsClosed();\\n  event RefundsEnabled();\\n\\n  State private _state;\\n  address private _beneficiary;\\n\\n  /**\\n   * @dev Constructor.\\n   * @param beneficiary The beneficiary of the deposits.\\n   */\\n  constructor(address beneficiary) public {\\n    require(beneficiary != address(0));\\n    _beneficiary = beneficiary;\\n    _state = State.Active;\\n  }\\n\\n  /**\\n   * @return the current state of the escrow.\\n   */\\n  function state() public view returns (State) {\\n    return _state;\\n  }\\n\\n  /**\\n   * @return the beneficiary of the escrow.\\n   */\\n  function beneficiary() public view returns (address) {\\n    return _beneficiary;\\n  }\\n\\n  /**\\n   * @dev Stores funds that may later be refunded.\\n   * @param refundee The address funds will be sent to if a refund occurs.\\n   */\\n  function deposit(address refundee) public payable {\\n    require(_state == State.Active);\\n    super.deposit(refundee);\\n  }\\n\\n  /**\\n   * @dev Allows for the beneficiary to withdraw their funds, rejecting\\n   * further deposits.\\n   */\\n  function close() public onlyPrimary {\\n    require(_state == State.Active);\\n    _state = State.Closed;\\n    emit RefundsClosed();\\n  }\\n\\n  /**\\n   * @dev Allows for refunds to take place, rejecting further deposits.\\n   */\\n  function enableRefunds() public onlyPrimary {\\n    require(_state == State.Active);\\n    _state = State.Refunding;\\n    emit RefundsEnabled();\\n  }\\n\\n  /**\\n   * @dev Withdraws the beneficiary's funds.\\n   */\\n  function beneficiaryWithdraw() public {\\n    require(_state == State.Closed);\\n    _beneficiary.transfer(address(this).balance);\\n  }\\n\\n  /**\\n   * @dev Returns whether refundees can withdraw their deposits (be refunded).\\n   */\\n  function withdrawalAllowed(address payee) public view returns (bool) {\\n    return _state == State.Refunding;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/payment/escrow/ConditionalEscrow.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./Escrow.sol\\\";\\n\\n/**\\n * @title ConditionalEscrow\\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\\n * @dev Intended usage: See Escrow.sol. Same usage guidelines apply here.\\n */\\ncontract ConditionalEscrow is Escrow {\\n  /**\\n  * @dev Returns whether an address is allowed to withdraw their funds. To be\\n  * implemented by derived contracts.\\n  * @param payee The destination address of the funds.\\n  */\\n  function withdrawalAllowed(address payee) public view returns (bool);\\n\\n  function withdraw(address payee) public {\\n    require(withdrawalAllowed(payee));\\n    super.withdraw(payee);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/drafts/ERC1046/TokenMetadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title ERC-1047 Token Metadata\\n * @dev See https://eips.ethereum.org/EIPS/eip-1046\\n * @dev tokenURI must respond with a URI that implements https://eips.ethereum.org/EIPS/eip-1047\\n * @dev TODO - update https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/IERC721.sol#L17 when 1046 is finalized\\n */\\ncontract ERC20TokenMetadata is IERC20 {\\n  function tokenURI() external view returns (string);\\n}\\n\\ncontract ERC20WithMetadata is ERC20TokenMetadata {\\n  string private _tokenURI;\\n\\n  constructor(string tokenURI)\\n    public\\n  {\\n    _tokenURI = tokenURI;\\n  }\\n\\n  function tokenURI() external view returns (string) {\\n    return _tokenURI;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/drafts/Counter.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Counter\\n * @author Matt Condon (@shrugs)\\n * @dev Provides an incrementing uint256 id acquired by the `Counter#next` getter.\\n * Use this for issuing ERC721 ids or keeping track of request ids, anything you want, really.\\n *\\n * Include with `using Counter for Counter.Counter;`\\n * @notice Does not allow an Id of 0, which is popularly used to signify a null state in solidity.\\n * Does not protect from overflows, but if you have 2^256 ids, you have other problems.\\n * (But actually, it's generally impossible to increment a counter this many times, energy wise\\n * so it's not something you have to worry about.)\\n */\\nlibrary Counter {\\n\\n  struct Counter {\\n    uint256 current; // default: 0\\n  }\\n\\n  function next(Counter storage index)\\n    internal\\n    returns (uint256)\\n  {\\n    index.current += 1;\\n    return index.current;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/drafts/ERC20Migrator.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"../token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../math/Math.sol\\\";\\n\\n/**\\n * @title ERC20Migrator\\n * @dev This contract can be used to migrate an ERC20 token from one\\n * contract to another, where each token holder has to opt-in to the migration.\\n * To opt-in, users must approve for this contract the number of tokens they\\n * want to migrate. Once the allowance is set up, anyone can trigger the\\n * migration to the new token contract. In this way, token holders \\\"turn in\\\"\\n * their old balance and will be minted an equal amount in the new token.\\n * The new token contract must be mintable. For the precise interface refer to\\n * OpenZeppelin's ERC20Mintable, but the only functions that are needed are\\n * `isMinter(address)` and `mint(address, amount)`. The migrator will check\\n * that it is a minter for the token.\\n * The balance from the legacy token will be transfered to the migrator, as it\\n * is migrated, and remain there forever.\\n * Although this contract can be used in many different scenarios, the main\\n * motivation was to provide a way to migrate ERC20 tokens into an upgradeable\\n * version of it using ZeppelinOS. To read more about how this can be done\\n * using this implementation, please follow the official documentation site of\\n * ZeppelinOS: https://docs.zeppelinos.org/docs/erc20_onboarding.html\\n * Example of usage:\\n * ```\\n * const migrator = await ERC20Migrator.new(legacyToken.address);\\n * await newToken.addMinter(migrator.address);\\n * await migrator.beginMigration(newToken.address);\\n * ```\\n */\\ncontract ERC20Migrator {\\n  using SafeERC20 for IERC20;\\n\\n  /// Address of the old token contract\\n  IERC20 private _legacyToken;\\n\\n  /// Address of the new token contract\\n  ERC20Mintable private _newToken;\\n\\n  /**\\n   * @param legacyToken address of the old token contract\\n   */\\n  constructor(IERC20 legacyToken) public {\\n    require(legacyToken != address(0));\\n    _legacyToken = legacyToken;\\n  }\\n\\n  /**\\n   * @dev Returns the legacy token that is being migrated.\\n   */\\n  function legacyToken() public view returns (IERC20) {\\n    return _legacyToken;\\n  }\\n\\n  /**\\n   * @dev Returns the new token to which we are migrating.\\n   */\\n  function newToken() public view returns (IERC20) {\\n    return _newToken;\\n  }\\n\\n  /**\\n   * @dev Begins the migration by setting which is the new token that will be\\n   * minted. This contract must be a minter for the new token.\\n   * @param newToken the token that will be minted\\n   */\\n  function beginMigration(ERC20Mintable newToken) public {\\n    require(_newToken == address(0));\\n    require(newToken != address(0));\\n    require(newToken.isMinter(this));\\n\\n    _newToken = newToken;\\n  }\\n\\n  /**\\n   * @dev Transfers part of an account's balance in the old token to this\\n   * contract, and mints the same amount of new tokens for that account.\\n   * @param account whose tokens will be migrated\\n   * @param amount amount of tokens to be migrated\\n   */\\n  function migrate(address account, uint256 amount) public {\\n    _legacyToken.safeTransferFrom(account, this, amount);\\n    _newToken.mint(account, amount);\\n  }\\n\\n  /**\\n   * @dev Transfers all of an account's allowed balance in the old token to\\n   * this contract, and mints the same amount of new tokens for that account.\\n   * @param account whose tokens will be migrated\\n   */\\n  function migrateAll(address account) public {\\n    uint256 balance = _legacyToken.balanceOf(account);\\n    uint256 allowance = _legacyToken.allowance(account, this);\\n    uint256 amount = Math.min(balance, allowance);\\n    migrate(account, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/drafts/SignatureBouncer.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/roles/SignerRole.sol\\\";\\nimport \\\"../cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @title SignatureBouncer\\n * @author PhABC, Shrugs and aflesher\\n * @dev SignatureBouncer allows users to submit a signature as a permission to\\n * do an action.\\n * If the signature is from one of the authorized signer addresses, the\\n * signature is valid.\\n * Note that SignatureBouncer offers no protection against replay attacks, users\\n * must add this themselves!\\n *\\n * Signer addresses can be individual servers signing grants or different\\n * users within a decentralized club that have permission to invite other\\n * members. This technique is useful for whitelists and airdrops; instead of\\n * putting all valid addresses on-chain, simply sign a grant of the form\\n * keccak256(abi.encodePacked(`:contractAddress` + `:granteeAddress`)) using a\\n * valid signer address.\\n * Then restrict access to your crowdsale/whitelist/airdrop using the\\n * `onlyValidSignature` modifier (or implement your own using _isValidSignature).\\n * In addition to `onlyValidSignature`, `onlyValidSignatureAndMethod` and\\n * `onlyValidSignatureAndData` can be used to restrict access to only a given\\n * method or a given method with given parameters respectively.\\n * See the tests in SignatureBouncer.test.js for specific usage examples.\\n *\\n * @notice A method that uses the `onlyValidSignatureAndData` modifier must make\\n * the _signature parameter the \\\"last\\\" parameter. You cannot sign a message that\\n * has its own signature in it so the last 128 bytes of msg.data (which\\n * represents the length of the _signature data and the _signaature data itself)\\n * is ignored when validating. Also non fixed sized parameters make constructing\\n * the data in the signature much more complex.\\n * See https://ethereum.stackexchange.com/a/50616 for more details.\\n */\\ncontract SignatureBouncer is SignerRole {\\n  using ECDSA for bytes32;\\n\\n  // Function selectors are 4 bytes long, as documented in\\n  // https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector\\n  uint256 private constant _METHOD_ID_SIZE = 4;\\n  // Signature size is 65 bytes (tightly packed v + r + s), but gets padded to 96 bytes\\n  uint256 private constant _SIGNATURE_SIZE = 96;\\n\\n  constructor() internal {}\\n\\n  /**\\n   * @dev requires that a valid signature of a signer was provided\\n   */\\n  modifier onlyValidSignature(bytes signature)\\n  {\\n    require(_isValidSignature(msg.sender, signature));\\n    _;\\n  }\\n\\n  /**\\n   * @dev requires that a valid signature with a specifed method of a signer was provided\\n   */\\n  modifier onlyValidSignatureAndMethod(bytes signature)\\n  {\\n    require(_isValidSignatureAndMethod(msg.sender, signature));\\n    _;\\n  }\\n\\n  /**\\n   * @dev requires that a valid signature with a specifed method and params of a signer was provided\\n   */\\n  modifier onlyValidSignatureAndData(bytes signature)\\n  {\\n    require(_isValidSignatureAndData(msg.sender, signature));\\n    _;\\n  }\\n\\n  /**\\n   * @dev is the signature of `this + sender` from a signer?\\n   * @return bool\\n   */\\n  function _isValidSignature(address account, bytes signature)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _isValidDataHash(\\n      keccak256(abi.encodePacked(address(this), account)),\\n      signature\\n    );\\n  }\\n\\n  /**\\n   * @dev is the signature of `this + sender + methodId` from a signer?\\n   * @return bool\\n   */\\n  function _isValidSignatureAndMethod(address account, bytes signature)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    bytes memory data = new bytes(_METHOD_ID_SIZE);\\n    for (uint i = 0; i < data.length; i++) {\\n      data[i] = msg.data[i];\\n    }\\n    return _isValidDataHash(\\n      keccak256(abi.encodePacked(address(this), account, data)),\\n      signature\\n    );\\n  }\\n\\n  /**\\n    * @dev is the signature of `this + sender + methodId + params(s)` from a signer?\\n    * @notice the signature parameter of the method being validated must be the \\\"last\\\" parameter\\n    * @return bool\\n    */\\n  function _isValidSignatureAndData(address account, bytes signature)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    require(msg.data.length > _SIGNATURE_SIZE);\\n    bytes memory data = new bytes(msg.data.length - _SIGNATURE_SIZE);\\n    for (uint i = 0; i < data.length; i++) {\\n      data[i] = msg.data[i];\\n    }\\n    return _isValidDataHash(\\n      keccak256(abi.encodePacked(address(this), account, data)),\\n      signature\\n    );\\n  }\\n\\n  /**\\n   * @dev internal function to convert a hash to an eth signed message\\n   * and then recover the signature and check it against the signer role\\n   * @return bool\\n   */\\n  function _isValidDataHash(bytes32 hash, bytes signature)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    address signer = hash\\n      .toEthSignedMessageHash()\\n      .recover(signature);\\n\\n    return signer != address(0) && isSigner(signer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/lifecycle/Pausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../access/roles/PauserRole.sol\\\";\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is PauserRole {\\n  event Paused(address account);\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  constructor() internal {\\n    _paused = false;\\n  }\\n\\n  /**\\n   * @return true if the contract is paused, false otherwise.\\n   */\\n  function paused() public view returns(bool) {\\n    return _paused;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!_paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(_paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() public onlyPauser whenNotPaused {\\n    _paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() public onlyPauser whenPaused {\\n    _paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../Crowdsale.sol\\\";\\nimport \\\"../../token/ERC20/ERC20Mintable.sol\\\";\\n\\n/**\\n * @title MintedCrowdsale\\n * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.\\n * Token ownership should be transferred to MintedCrowdsale for minting.\\n */\\ncontract MintedCrowdsale is Crowdsale {\\n  constructor() internal {}\\n\\n  /**\\n   * @dev Overrides delivery by minting tokens upon purchase.\\n   * @param beneficiary Token purchaser\\n   * @param tokenAmount Number of tokens to be minted\\n   */\\n  function _deliverTokens(\\n    address beneficiary,\\n    uint256 tokenAmount\\n  )\\n    internal\\n  {\\n    // Potentially dangerous assumption about the type of the token.\\n    require(\\n      ERC20Mintable(address(token())).mint(beneficiary, tokenAmount));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/emission/AllowanceCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../Crowdsale.sol\\\";\\nimport \\\"../../token/ERC20/IERC20.sol\\\";\\nimport \\\"../../token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../math/Math.sol\\\";\\n\\n/**\\n * @title AllowanceCrowdsale\\n * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\\n */\\ncontract AllowanceCrowdsale is Crowdsale {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  address private _tokenWallet;\\n\\n  /**\\n   * @dev Constructor, takes token wallet address.\\n   * @param tokenWallet Address holding the tokens, which has approved allowance to the crowdsale\\n   */\\n  constructor(address tokenWallet) internal {\\n    require(tokenWallet != address(0));\\n    _tokenWallet = tokenWallet;\\n  }\\n\\n  /**\\n   * @return the address of the wallet that will hold the tokens.\\n   */\\n  function tokenWallet() public view returns(address) {\\n    return _tokenWallet;\\n  }\\n\\n  /**\\n   * @dev Checks the amount of tokens left in the allowance.\\n   * @return Amount of tokens left in the allowance\\n   */\\n  function remainingTokens() public view returns (uint256) {\\n    return Math.min(\\n      token().balanceOf(_tokenWallet),\\n      token().allowance(_tokenWallet, this)\\n    );\\n  }\\n\\n  /**\\n   * @dev Overrides parent behavior by transferring tokens from wallet.\\n   * @param beneficiary Token purchaser\\n   * @param tokenAmount Amount of tokens purchased\\n   */\\n  function _deliverTokens(\\n    address beneficiary,\\n    uint256 tokenAmount\\n  )\\n    internal\\n  {\\n    token().safeTransferFrom(_tokenWallet, beneficiary, tokenAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"./FinalizableCrowdsale.sol\\\";\\nimport \\\"../../payment/escrow/RefundEscrow.sol\\\";\\n\\n/**\\n * @title RefundableCrowdsale\\n * @dev Extension of Crowdsale contract that adds a funding goal, and\\n * the possibility of users getting a refund if goal is not met.\\n * WARNING: note that if you allow tokens to be traded before the goal \\n * is met, then an attack is possible in which the attacker purchases \\n * tokens from the crowdsale and when they sees that the goal is \\n * unlikely to be met, they sell their tokens (possibly at a discount).\\n * The attacker will be refunded when the crowdsale is finalized, and\\n * the users that purchased from them will be left with worthless \\n * tokens. There are many possible ways to avoid this, like making the\\n * the crowdsale inherit from PostDeliveryCrowdsale, or imposing \\n * restrictions on token trading until the crowdsale is finalized.\\n * This is being discussed in \\n * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/877\\n * This contract will be updated when we agree on a general solution\\n * for this problem.\\n */\\ncontract RefundableCrowdsale is FinalizableCrowdsale {\\n  using SafeMath for uint256;\\n\\n  // minimum amount of funds to be raised in weis\\n  uint256 private _goal;\\n\\n  // refund escrow used to hold funds while crowdsale is running\\n  RefundEscrow private _escrow;\\n\\n  /**\\n   * @dev Constructor, creates RefundEscrow.\\n   * @param goal Funding goal\\n   */\\n  constructor(uint256 goal) internal {\\n    require(goal > 0);\\n    _escrow = new RefundEscrow(wallet());\\n    _goal = goal;\\n  }\\n\\n  /**\\n   * @return minimum amount of funds to be raised in wei.\\n   */\\n  function goal() public view returns(uint256) {\\n    return _goal;\\n  }\\n\\n  /**\\n   * @dev Investors can claim refunds here if crowdsale is unsuccessful\\n   * @param beneficiary Whose refund will be claimed.\\n   */\\n  function claimRefund(address beneficiary) public {\\n    require(finalized());\\n    require(!goalReached());\\n\\n    _escrow.withdraw(beneficiary);\\n  }\\n\\n  /**\\n   * @dev Checks whether funding goal was reached.\\n   * @return Whether funding goal was reached\\n   */\\n  function goalReached() public view returns (bool) {\\n    return weiRaised() >= _goal;\\n  }\\n\\n  /**\\n   * @dev escrow finalization task, called when finalize() is called\\n   */\\n  function _finalization() internal {\\n    if (goalReached()) {\\n      _escrow.close();\\n      _escrow.beneficiaryWithdraw();\\n    } else {\\n      _escrow.enableRefunds();\\n    }\\n\\n    super._finalization();\\n  }\\n\\n  /**\\n   * @dev Overrides Crowdsale fund forwarding, sending funds to escrow.\\n   */\\n  function _forwardFunds() internal {\\n    _escrow.deposit.value(msg.value)(msg.sender);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/distribution/PostDeliveryCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../validation/TimedCrowdsale.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @title PostDeliveryCrowdsale\\n * @dev Crowdsale that locks tokens from withdrawal until it ends.\\n */\\ncontract PostDeliveryCrowdsale is TimedCrowdsale {\\n  using SafeMath for uint256;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  constructor() internal {}\\n\\n  /**\\n   * @dev Withdraw tokens only after crowdsale ends.\\n   * @param beneficiary Whose tokens will be withdrawn.\\n   */\\n  function withdrawTokens(address beneficiary) public {\\n    require(hasClosed());\\n    uint256 amount = _balances[beneficiary];\\n    require(amount > 0);\\n    _balances[beneficiary] = 0;\\n    _deliverTokens(beneficiary, amount);\\n  }\\n\\n  /**\\n   * @return the balance of an account.\\n   */\\n  function balanceOf(address account) public view returns(uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Overrides parent by storing balances instead of issuing tokens right away.\\n   * @param beneficiary Token purchaser\\n   * @param tokenAmount Amount of tokens purchased\\n   */\\n  function _processPurchase(\\n    address beneficiary,\\n    uint256 tokenAmount\\n  )\\n    internal\\n  {\\n    _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/distribution/FinalizableCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../validation/TimedCrowdsale.sol\\\";\\n\\n/**\\n * @title FinalizableCrowdsale\\n * @dev Extension of Crowdsale with a one-off finalization action, where one\\n * can do extra work after finishing.\\n */\\ncontract FinalizableCrowdsale is TimedCrowdsale {\\n  using SafeMath for uint256;\\n\\n  bool private _finalized;\\n\\n  event CrowdsaleFinalized();\\n\\n  constructor() internal {\\n    _finalized = false;\\n  }\\n\\n  /**\\n   * @return true if the crowdsale is finalized, false otherwise.\\n   */\\n  function finalized() public view returns (bool) {\\n    return _finalized;\\n  }\\n\\n  /**\\n   * @dev Must be called after crowdsale ends, to do some extra finalization\\n   * work. Calls the contract's finalization function.\\n   */\\n  function finalize() public {\\n    require(!_finalized);\\n    require(hasClosed());\\n\\n    _finalized = true;\\n\\n    _finalization();\\n    emit CrowdsaleFinalized();\\n  }\\n\\n  /**\\n   * @dev Can be overridden to add finalization logic. The overriding function\\n   * should call super._finalization() to ensure the chain of finalization is\\n   * executed entirely.\\n   */\\n  function _finalization() internal {\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/price/IncreasingPriceCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../validation/TimedCrowdsale.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @title IncreasingPriceCrowdsale\\n * @dev Extension of Crowdsale contract that increases the price of tokens linearly in time.\\n * Note that what should be provided to the constructor is the initial and final _rates_, that is,\\n * the amount of tokens per wei contributed. Thus, the initial rate must be greater than the final rate.\\n */\\ncontract IncreasingPriceCrowdsale is TimedCrowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 private _initialRate;\\n  uint256 private _finalRate;\\n\\n  /**\\n   * @dev Constructor, takes initial and final rates of tokens received per wei contributed.\\n   * @param initialRate Number of tokens a buyer gets per wei at the start of the crowdsale\\n   * @param finalRate Number of tokens a buyer gets per wei at the end of the crowdsale\\n   */\\n  constructor(uint256 initialRate, uint256 finalRate) internal {\\n    require(finalRate > 0);\\n    require(initialRate > finalRate);\\n    _initialRate = initialRate;\\n    _finalRate = finalRate;\\n  }\\n\\n  /**\\n   * The base rate function is overridden to revert, since this crowdsale doens't use it, and\\n   * all calls to it are a mistake.\\n   */\\n  function rate() public view returns(uint256) {\\n    revert();\\n  }\\n\\n  /**\\n   * @return the initial rate of the crowdsale.\\n   */\\n  function initialRate() public view returns(uint256) {\\n    return _initialRate;\\n  }\\n\\n  /**\\n   * @return the final rate of the crowdsale.\\n   */\\n  function finalRate() public view returns (uint256) {\\n    return _finalRate;\\n  }\\n\\n  /**\\n   * @dev Returns the rate of tokens per wei at the present time.\\n   * Note that, as price _increases_ with time, the rate _decreases_.\\n   * @return The number of tokens a buyer gets per wei at a given time\\n   */\\n  function getCurrentRate() public view returns (uint256) {\\n    if (!isOpen()) {\\n      return 0;\\n    }\\n\\n    // solium-disable-next-line security/no-block-members\\n    uint256 elapsedTime = block.timestamp.sub(openingTime());\\n    uint256 timeRange = closingTime().sub(openingTime());\\n    uint256 rateRange = _initialRate.sub(_finalRate);\\n    return _initialRate.sub(elapsedTime.mul(rateRange).div(timeRange));\\n  }\\n\\n  /**\\n   * @dev Overrides parent method taking into account variable rate.\\n   * @param weiAmount The value in wei to be converted into tokens\\n   * @return The number of tokens _weiAmount wei will buy at present time\\n   */\\n  function _getTokenAmount(uint256 weiAmount)\\n    internal view returns (uint256)\\n  {\\n    uint256 currentRate = getCurrentRate();\\n    return currentRate.mul(weiAmount);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../math/SafeMath.sol\\\";\\nimport \\\"../token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title Crowdsale\\n * @dev Crowdsale is a base contract for managing a token crowdsale,\\n * allowing investors to purchase tokens with ether. This contract implements\\n * such functionality in its most fundamental form and can be extended to provide additional\\n * functionality and/or custom behavior.\\n * The external interface represents the basic interface for purchasing tokens, and conform\\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\\n * behavior.\\n */\\ncontract Crowdsale is ReentrancyGuard {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  // The token being sold\\n  IERC20 private _token;\\n\\n  // Address where funds are collected\\n  address private _wallet;\\n\\n  // How many token units a buyer gets per wei.\\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\\n  // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\\n  // 1 wei will give you 1 unit, or 0.001 TOK.\\n  uint256 private _rate;\\n\\n  // Amount of wei raised\\n  uint256 private _weiRaised;\\n\\n  /**\\n   * Event for token purchase logging\\n   * @param purchaser who paid for the tokens\\n   * @param beneficiary who got the tokens\\n   * @param value weis paid for purchase\\n   * @param amount amount of tokens purchased\\n   */\\n  event TokensPurchased(\\n    address indexed purchaser,\\n    address indexed beneficiary,\\n    uint256 value,\\n    uint256 amount\\n  );\\n\\n  /**\\n   * @param rate Number of token units a buyer gets per wei\\n   * @dev The rate is the conversion between wei and the smallest and indivisible\\n   * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\\n   * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\\n   * @param wallet Address where collected funds will be forwarded to\\n   * @param token Address of the token being sold\\n   */\\n  constructor(uint256 rate, address wallet, IERC20 token) internal {\\n    require(rate > 0);\\n    require(wallet != address(0));\\n    require(token != address(0));\\n\\n    _rate = rate;\\n    _wallet = wallet;\\n    _token = token;\\n  }\\n\\n  // -----------------------------------------\\n  // Crowdsale external interface\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev fallback function ***DO NOT OVERRIDE***\\n   * Note that other contracts will transfer fund with a base gas stipend\\n   * of 2300, which is not enough to call buyTokens. Consider calling\\n   * buyTokens directly when purchasing tokens from a contract.\\n   */\\n  function () external payable {\\n    buyTokens(msg.sender);\\n  }\\n\\n  /**\\n   * @return the token being sold.\\n   */\\n  function token() public view returns(IERC20) {\\n    return _token;\\n  }\\n\\n  /**\\n   * @return the address where funds are collected.\\n   */\\n  function wallet() public view returns(address) {\\n    return _wallet;\\n  }\\n\\n  /**\\n   * @return the number of token units a buyer gets per wei.\\n   */\\n  function rate() public view returns(uint256) {\\n    return _rate;\\n  }\\n\\n  /**\\n   * @return the amount of wei raised.\\n   */\\n  function weiRaised() public view returns (uint256) {\\n    return _weiRaised;\\n  }\\n\\n  /**\\n   * @dev low level token purchase ***DO NOT OVERRIDE***\\n   * This function has a non-reentrancy guard, so it shouldn't be called by\\n   * another `nonReentrant` function.\\n   * @param beneficiary Recipient of the token purchase\\n   */\\n  function buyTokens(address beneficiary) public nonReentrant payable {\\n\\n    uint256 weiAmount = msg.value;\\n    _preValidatePurchase(beneficiary, weiAmount);\\n\\n    // calculate token amount to be created\\n    uint256 tokens = _getTokenAmount(weiAmount);\\n\\n    // update state\\n    _weiRaised = _weiRaised.add(weiAmount);\\n\\n    _processPurchase(beneficiary, tokens);\\n    emit TokensPurchased(\\n      msg.sender,\\n      beneficiary,\\n      weiAmount,\\n      tokens\\n    );\\n\\n    _updatePurchasingState(beneficiary, weiAmount);\\n\\n    _forwardFunds();\\n    _postValidatePurchase(beneficiary, weiAmount);\\n  }\\n\\n  // -----------------------------------------\\n  // Internal interface (extensible)\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method:\\n   *   super._preValidatePurchase(beneficiary, weiAmount);\\n   *   require(weiRaised().add(weiAmount) <= cap);\\n   * @param beneficiary Address performing the token purchase\\n   * @param weiAmount Value in wei involved in the purchase\\n   */\\n  function _preValidatePurchase(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n    view\\n  {\\n    require(beneficiary != address(0));\\n    require(weiAmount != 0);\\n  }\\n\\n  /**\\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\\n   * @param beneficiary Address performing the token purchase\\n   * @param weiAmount Value in wei involved in the purchase\\n   */\\n  function _postValidatePurchase(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n    view\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\\n   * @param beneficiary Address performing the token purchase\\n   * @param tokenAmount Number of tokens to be emitted\\n   */\\n  function _deliverTokens(\\n    address beneficiary,\\n    uint256 tokenAmount\\n  )\\n    internal\\n  {\\n    _token.safeTransfer(beneficiary, tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send tokens.\\n   * @param beneficiary Address receiving the tokens\\n   * @param tokenAmount Number of tokens to be purchased\\n   */\\n  function _processPurchase(\\n    address beneficiary,\\n    uint256 tokenAmount\\n  )\\n    internal\\n  {\\n    _deliverTokens(beneficiary, tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\\n   * @param beneficiary Address receiving the tokens\\n   * @param weiAmount Value in wei involved in the purchase\\n   */\\n  function _updatePurchasingState(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Override to extend the way in which ether is converted to tokens.\\n   * @param weiAmount Value in wei to be converted into tokens\\n   * @return Number of tokens that can be purchased with the specified _weiAmount\\n   */\\n  function _getTokenAmount(uint256 weiAmount)\\n    internal view returns (uint256)\\n  {\\n    return weiAmount.mul(_rate);\\n  }\\n\\n  /**\\n   * @dev Determines how ETH is stored/forwarded on purchases.\\n   */\\n  function _forwardFunds() internal {\\n    _wallet.transfer(msg.value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/validation/IndividuallyCappedCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../Crowdsale.sol\\\";\\nimport \\\"../../access/roles/CapperRole.sol\\\";\\n\\n/**\\n * @title IndividuallyCappedCrowdsale\\n * @dev Crowdsale with per-beneficiary caps.\\n */\\ncontract IndividuallyCappedCrowdsale is Crowdsale, CapperRole {\\n  using SafeMath for uint256;\\n\\n  mapping(address => uint256) private _contributions;\\n  mapping(address => uint256) private _caps;\\n\\n  constructor() internal {}\\n\\n  /**\\n   * @dev Sets a specific beneficiary's maximum contribution.\\n   * @param beneficiary Address to be capped\\n   * @param cap Wei limit for individual contribution\\n   */\\n  function setCap(address beneficiary, uint256 cap) external onlyCapper {\\n    _caps[beneficiary] = cap;\\n  }\\n\\n  /**\\n   * @dev Returns the cap of a specific beneficiary.\\n   * @param beneficiary Address whose cap is to be checked\\n   * @return Current cap for individual beneficiary\\n   */\\n  function getCap(address beneficiary) public view returns (uint256) {\\n    return _caps[beneficiary];\\n  }\\n\\n  /**\\n   * @dev Returns the amount contributed so far by a specific beneficiary.\\n   * @param beneficiary Address of contributor\\n   * @return Beneficiary contribution so far\\n   */\\n  function getContribution(address beneficiary)\\n    public view returns (uint256)\\n  {\\n    return _contributions[beneficiary];\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior requiring purchase to respect the beneficiary's funding cap.\\n   * @param beneficiary Token purchaser\\n   * @param weiAmount Amount of wei contributed\\n   */\\n  function _preValidatePurchase(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n    view\\n  {\\n    super._preValidatePurchase(beneficiary, weiAmount);\\n    require(\\n      _contributions[beneficiary].add(weiAmount) <= _caps[beneficiary]);\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior to update beneficiary contributions\\n   * @param beneficiary Token purchaser\\n   * @param weiAmount Amount of wei contributed\\n   */\\n  function _updatePurchasingState(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n  {\\n    super._updatePurchasingState(beneficiary, weiAmount);\\n    _contributions[beneficiary] = _contributions[beneficiary].add(\\n      weiAmount);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../Crowdsale.sol\\\";\\n\\n/**\\n * @title TimedCrowdsale\\n * @dev Crowdsale accepting contributions only within a time frame.\\n */\\ncontract TimedCrowdsale is Crowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 private _openingTime;\\n  uint256 private _closingTime;\\n\\n  /**\\n   * @dev Reverts if not in crowdsale time range.\\n   */\\n  modifier onlyWhileOpen {\\n    require(isOpen());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor, takes crowdsale opening and closing times.\\n   * @param openingTime Crowdsale opening time\\n   * @param closingTime Crowdsale closing time\\n   */\\n  constructor(uint256 openingTime, uint256 closingTime) internal {\\n    // solium-disable-next-line security/no-block-members\\n    require(openingTime >= block.timestamp);\\n    require(closingTime > openingTime);\\n\\n    _openingTime = openingTime;\\n    _closingTime = closingTime;\\n  }\\n\\n  /**\\n   * @return the crowdsale opening time.\\n   */\\n  function openingTime() public view returns(uint256) {\\n    return _openingTime;\\n  }\\n\\n  /**\\n   * @return the crowdsale closing time.\\n   */\\n  function closingTime() public view returns(uint256) {\\n    return _closingTime;\\n  }\\n\\n  /**\\n   * @return true if the crowdsale is open, false otherwise.\\n   */\\n  function isOpen() public view returns (bool) {\\n    // solium-disable-next-line security/no-block-members\\n    return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\\n  }\\n\\n  /**\\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\\n   * @return Whether crowdsale period has elapsed\\n   */\\n  function hasClosed() public view returns (bool) {\\n    // solium-disable-next-line security/no-block-members\\n    return block.timestamp > _closingTime;\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior requiring to be within contributing period\\n   * @param beneficiary Token purchaser\\n   * @param weiAmount Amount of wei contributed\\n   */\\n  function _preValidatePurchase(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n    onlyWhileOpen\\n    view\\n  {\\n    super._preValidatePurchase(beneficiary, weiAmount);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../Crowdsale.sol\\\";\\n\\n/**\\n * @title CappedCrowdsale\\n * @dev Crowdsale with a limit for total contributions.\\n */\\ncontract CappedCrowdsale is Crowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 private _cap;\\n\\n  /**\\n   * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\\n   * @param cap Max amount of wei to be contributed\\n   */\\n  constructor(uint256 cap) internal {\\n    require(cap > 0);\\n    _cap = cap;\\n  }\\n\\n  /**\\n   * @return the cap of the crowdsale.\\n   */\\n  function cap() public view returns(uint256) {\\n    return _cap;\\n  }\\n\\n  /**\\n   * @dev Checks whether the cap has been reached.\\n   * @return Whether the cap was reached\\n   */\\n  function capReached() public view returns (bool) {\\n    return weiRaised() >= _cap;\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior requiring purchase to respect the funding cap.\\n   * @param beneficiary Token purchaser\\n   * @param weiAmount Amount of wei contributed\\n   */\\n  function _preValidatePurchase(\\n    address beneficiary,\\n    uint256 weiAmount\\n  )\\n    internal\\n    view\\n  {\\n    super._preValidatePurchase(beneficiary, weiAmount);\\n    require(weiRaised().add(weiAmount) <= _cap);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Helps contracts guard against reentrancy attacks.\\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\\n * @dev If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard {\\n\\n  /// @dev counter to allow mutex lock with only one SSTORE operation\\n  uint256 private _guardCounter;\\n\\n  constructor() internal {\\n    // The counter starts at one to prevent changing it from zero to a non-zero\\n    // value, which is a more expensive operation.\\n    _guardCounter = 1;\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `nonReentrant` function from another `nonReentrant`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `nonReentrant` function external, and make it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier nonReentrant() {\\n    _guardCounter += 1;\\n    uint256 localCounter = _guardCounter;\\n    _;\\n    require(localCounter == _guardCounter);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.23;\\n\\nimport \\\"../math/Math.sol\\\";\\n\\n\\n/**\\n * @title Arrays\\n * @dev Utility library of inline array functions\\n */\\nlibrary Arrays {\\n\\n  /**\\n   * @dev Upper bound search function which is kind of binary search algoritm. It searches sorted\\n   * array to find index of the element value. If element is found then returns it's index otherwise\\n   * it returns index of first element which is grater than searched value. If searched element is\\n   * bigger than any array element function then returns first index after last element (i.e. all\\n   * values inside the array are smaller than the target). Complexity O(log n).\\n   * @param array The array sorted in ascending order.\\n   * @param element The element's value to be find.\\n   * @return The calculated index value. Returns 0 for empty array.\\n   */\\n  function findUpperBound(\\n    uint256[] storage array,\\n    uint256 element\\n  ) \\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    if (array.length == 0) {\\n      return 0;\\n    }\\n    \\n    uint256 low = 0;\\n    uint256 high = array.length;\\n\\n    while (low < high) {\\n      uint256 mid = Math.average(low, high);\\n\\n      // Note that mid will always be strictly less than high (i.e. it will be a valid array index) \\n      // because Math.average rounds down (it does integer division with truncation).\\n      if (array[mid] > element) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n\\n    // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n    if (low > 0 && array[low - 1] == element) {\\n      return low - 1;\\n    } else {\\n      return low;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   * as the code is not actually created until after the constructor finishes.\\n   * @param account address of the account to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly { size := extcodesize(account) }\\n    return size > 0;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC165Checker\\n * @dev Use `using ERC165Checker for address`; to include this library\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\nlibrary ERC165Checker {\\n  // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n  bytes4 private constant _InterfaceId_Invalid = 0xffffffff;\\n\\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\\n  /**\\n   * 0x01ffc9a7 ===\\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\\n   */\\n\\n  /**\\n   * @notice Query if a contract supports ERC165\\n   * @param account The address of the contract to query for support of ERC165\\n   * @return true if the contract at account implements ERC165\\n   */\\n  function _supportsERC165(address account)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // Any contract that implements ERC165 must explicitly indicate support of\\n    // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n    return _supportsERC165Interface(account, _InterfaceId_ERC165) &&\\n      !_supportsERC165Interface(account, _InterfaceId_Invalid);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface, also checks support of ERC165\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return true if the contract at account indicates support of the interface with\\n   * identifier interfaceId, false otherwise\\n   * @dev Interface identification is specified in ERC-165.\\n   */\\n  function _supportsInterface(address account, bytes4 interfaceId)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // query support of both ERC165 as per the spec and support of _interfaceId\\n    return _supportsERC165(account) &&\\n      _supportsERC165Interface(account, interfaceId);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements interfaces, also checks support of ERC165\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceIds A list of interface identifiers, as specified in ERC-165\\n   * @return true if the contract at account indicates support all interfaces in the\\n   * interfaceIds list, false otherwise\\n   * @dev Interface identification is specified in ERC-165.\\n   */\\n  function _supportsAllInterfaces(address account, bytes4[] interfaceIds)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // query support of ERC165 itself\\n    if (!_supportsERC165(account)) {\\n      return false;\\n    }\\n\\n    // query support of each interface in _interfaceIds\\n    for (uint256 i = 0; i < interfaceIds.length; i++) {\\n      if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n        return false;\\n      }\\n    }\\n\\n    // all interfaces supported\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface, does not check ERC165 support\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return true if the contract at account indicates support of the interface with\\n   * identifier interfaceId, false otherwise\\n   * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n   * the behavior of this method is undefined. This precondition can be checked\\n   * with the `supportsERC165` method in this library.\\n   * Interface identification is specified in ERC-165.\\n   */\\n  function _supportsERC165Interface(address account, bytes4 interfaceId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    // success determines whether the staticcall succeeded and result determines\\n    // whether the contract at account indicates support of _interfaceId\\n    (bool success, bool result) = _callERC165SupportsInterface(\\n      account, interfaceId);\\n\\n    return (success && result);\\n  }\\n\\n  /**\\n   * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return success true if the STATICCALL succeeded, false otherwise\\n   * @return result true if the STATICCALL succeeded and the contract at account\\n   * indicates support of the interface with identifier interfaceId, false otherwise\\n   */\\n  function _callERC165SupportsInterface(\\n    address account,\\n    bytes4 interfaceId\\n  )\\n    private\\n    view\\n    returns (bool success, bool result)\\n  {\\n    bytes memory encodedParams = abi.encodeWithSelector(\\n      _InterfaceId_ERC165,\\n      interfaceId\\n    );\\n\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly {\\n      let encodedParams_data := add(0x20, encodedParams)\\n      let encodedParams_size := mload(encodedParams)\\n\\n      let output := mload(0x40)  // Find empty storage location using \\\"free memory pointer\\\"\\n      mstore(output, 0x0)\\n\\n      success := staticcall(\\n        30000,                 // 30k gas\\n        account,              // To addr\\n        encodedParams_data,\\n        encodedParams_size,\\n        output,\\n        0x20                   // Outputs are 32 bytes long\\n      )\\n\\n      result := mload(output)  // Load the result\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title ERC165\\n * @author Matt Condon (@shrugs)\\n * @dev Implements ERC165 using a lookup table.\\n */\\ncontract ERC165 is IERC165 {\\n\\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\\n  /**\\n   * 0x01ffc9a7 ===\\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\\n   */\\n\\n  /**\\n   * @dev a mapping of interface id to whether or not it's supported\\n   */\\n  mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n  /**\\n   * @dev A contract implementing SupportsInterfaceWithLookup\\n   * implement ERC165 itself\\n   */\\n  constructor()\\n    internal\\n  {\\n    _registerInterface(_InterfaceId_ERC165);\\n  }\\n\\n  /**\\n   * @dev implement supportsInterface(bytes4) using a lookup table\\n   */\\n  function supportsInterface(bytes4 interfaceId)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _supportedInterfaces[interfaceId];\\n  }\\n\\n  /**\\n   * @dev internal method for registering an interface\\n   */\\n  function _registerInterface(bytes4 interfaceId)\\n    internal\\n  {\\n    require(interfaceId != 0xffffffff);\\n    _supportedInterfaces[interfaceId] = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title IERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @dev Interface identification is specified in ERC-165. This function\\n   * uses less than 30,000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/math/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Math\\n * @dev Assorted math operations\\n */\\nlibrary Math {\\n  /**\\n  * @dev Returns the largest of two numbers.\\n  */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  /**\\n  * @dev Returns the smallest of two numbers.\\n  */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n  * @dev Calculates the average of two numbers. Since these are integers,\\n  * averages of an even and odd number cannot be represented, and will be\\n  * rounded down.\\n  */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow, so we distribute\\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() internal {\\n    _owner = msg.sender;\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /**\\n   * @return the address of the owner.\\n   */\\n  function owner() public view returns(address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(isOwner());\\n    _;\\n  }\\n\\n  /**\\n   * @return true if `msg.sender` is the owner of the contract.\\n   */\\n  function isOwner() public view returns(bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/ownership/Secondary.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Secondary\\n * @dev A Secondary contract can only be used by its primary account (the one that created it)\\n */\\ncontract Secondary {\\n  address private _primary;\\n\\n  event PrimaryTransferred(\\n    address recipient\\n  );\\n\\n  /**\\n   * @dev Sets the primary account to the one that is creating the Secondary contract.\\n   */\\n  constructor() internal {\\n    _primary = msg.sender;\\n    emit PrimaryTransferred(_primary);\\n  }\\n\\n  /**\\n   * @dev Reverts if called from any account other than the primary.\\n   */\\n  modifier onlyPrimary() {\\n    require(msg.sender == _primary);\\n    _;\\n  }\\n\\n  /**\\n   * @return the address of the primary.\\n   */\\n  function primary() public view returns (address) {\\n    return _primary;\\n  }\\n  \\n  /**\\n   * @dev Transfers contract to a new primary.\\n   * @param recipient The address of new primary. \\n   */\\n  function transferPrimary(address recipient) public onlyPrimary {\\n    require(recipient != address(0));\\n    _primary = recipient;\\n    emit PrimaryTransferred(_primary);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/examples/SampleCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../crowdsale/validation/CappedCrowdsale.sol\\\";\\nimport \\\"../crowdsale/distribution/RefundableCrowdsale.sol\\\";\\nimport \\\"../crowdsale/emission/MintedCrowdsale.sol\\\";\\nimport \\\"../token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"../token/ERC20/ERC20Detailed.sol\\\";\\n\\n/**\\n * @title SampleCrowdsaleToken\\n * @dev Very simple ERC20 Token that can be minted.\\n * It is meant to be used in a crowdsale contract.\\n */\\ncontract SampleCrowdsaleToken is ERC20Mintable, ERC20Detailed {\\n  constructor() public ERC20Detailed(\\\"Sample Crowdsale Token\\\", \\\"SCT\\\", 18) {}\\n}\\n\\n/**\\n * @title SampleCrowdsale\\n * @dev This is an example of a fully fledged crowdsale.\\n * The way to add new features to a base crowdsale is by multiple inheritance.\\n * In this example we are providing following extensions:\\n * CappedCrowdsale - sets a max boundary for raised funds\\n * RefundableCrowdsale - set a min goal to be reached and returns funds if it's not met\\n * MintedCrowdsale - assumes the token can be minted by the crowdsale, which does so\\n * when receiving purchases.\\n *\\n * After adding multiple features it's good practice to run integration tests\\n * to ensure that subcontracts works together as intended.\\n */\\n// XXX There doesn't seem to be a way to split this line that keeps solium\\n// happy. See:\\n// https://github.com/duaraghav8/Solium/issues/205\\n// --elopio - 2018-05-10\\n// solium-disable-next-line max-len\\ncontract SampleCrowdsale is CappedCrowdsale, RefundableCrowdsale, MintedCrowdsale {\\n\\n  constructor(\\n    uint256 openingTime,\\n    uint256 closingTime,\\n    uint256 rate,\\n    address wallet,\\n    uint256 cap,\\n    ERC20Mintable token,\\n    uint256 goal\\n  )\\n    public\\n    Crowdsale(rate, wallet, token)\\n    CappedCrowdsale(cap)\\n    TimedCrowdsale(openingTime, closingTime)\\n    RefundableCrowdsale(goal)\\n  {\\n    //As goal needs to be met for a successful crowdsale\\n    //the value needs to less or equal than a cap which is limit for accepted funds\\n    require(goal <= cap);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-solidity/contracts/examples/SimpleToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\n\\n/**\\n * @title SimpleToken\\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\\n * Note they can later distribute these tokens as they wish using `transfer` and other\\n * `ERC20` functions.\\n */\\ncontract SimpleToken is ERC20 {\\n\\n  string public constant name = \\\"SimpleToken\\\";\\n  string public constant symbol = \\\"SIM\\\";\\n  uint8 public constant decimals = 18;\\n\\n  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));\\n\\n  /**\\n   * @dev Constructor that gives msg.sender all of existing tokens.\\n   */\\n  constructor() public {\\n    _mint(msg.sender, INITIAL_SUPPLY);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/TokenVesting.sol\": {\r\n      \"content\": \"/* solium-disable security/no-block-members */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"./openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title TokenVesting\\n * @dev A token holder contract that can release its token balance gradually like a\\n * typical vesting scheme, with a cliff and vesting period.\\n *\\n * Note you do not want to transfer tokens you have withdrawn back to this contract. This will\\n * result in some fraction of your transferred tokens being locked up again.\\n *\\n * Code taken from OpenZeppelin/openzeppelin-solidity at commit 4115686b4f8c1abf29f1f855eb15308076159959.\\n * (Revocation options removed by Reserve.)\\n */\\ncontract TokenVesting is Ownable {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  event TokensReleased(address token, uint256 amount);\\n\\n  // beneficiary of tokens after they are released\\n  address private _beneficiary;\\n\\n  uint256 private _cliff;\\n  uint256 private _start;\\n  uint256 private _duration;\\n\\n  mapping (address => uint256) private _released;\\n  /**\\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n   * beneficiary, gradually in a linear fashion until start + duration. By then all\\n   * of the balance will have vested.\\n   * @param beneficiary address of the beneficiary to whom vested tokens are transferred\\n   * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\\n   * @param start the time (as Unix time) at which point vesting starts\\n   * @param duration duration in seconds of the period in which the tokens will vest\\n   */\\n  constructor(\\n    address beneficiary,\\n    uint256 start,\\n    uint256 cliffDuration,\\n    uint256 duration\\n  )\\n    public\\n  {\\n    require(beneficiary != address(0));\\n    require(cliffDuration <= duration);\\n    require(duration > 0);\\n    require(start.add(duration) > block.timestamp);\\n\\n    _beneficiary = beneficiary;\\n    _duration = duration;\\n    _cliff = start.add(cliffDuration);\\n    _start = start;\\n  }\\n\\n  /**\\n   * @return the beneficiary of the tokens.\\n   */\\n  function beneficiary() public view returns(address) {\\n    return _beneficiary;\\n  }\\n\\n  /**\\n   * @return the cliff time of the token vesting.\\n   */\\n  function cliff() public view returns(uint256) {\\n    return _cliff;\\n  }\\n\\n  /**\\n   * @return the start time of the token vesting.\\n   */\\n  function start() public view returns(uint256) {\\n    return _start;\\n  }\\n\\n  /**\\n   * @return the duration of the token vesting.\\n   */\\n  function duration() public view returns(uint256) {\\n    return _duration;\\n  }\\n\\n  /**\\n   * @return the amount of the token released.\\n   */\\n  function released(address token) public view returns(uint256) {\\n    return _released[token];\\n  }\\n\\n  /**\\n   * @return the amount of token that can be released at the current block timestamp.\\n   */\\n  function releasable(address token) public view returns(uint256) {\\n    return _releasableAmount(IERC20(token));\\n  }\\n\\n  /**\\n   * @notice Transfers vested tokens to beneficiary.\\n   * @param token ERC20 token which is being vested\\n   */\\n  function release(IERC20 token) public {\\n    uint256 unreleased = _releasableAmount(token);\\n\\n    require(unreleased > 0);\\n\\n    _released[token] = _released[token].add(unreleased);\\n\\n    token.safeTransfer(_beneficiary, unreleased);\\n\\n    emit TokensReleased(token, unreleased);\\n  }\\n\\n  /**\\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\\n   * @param token ERC20 token which is being vested\\n   */\\n  function _releasableAmount(IERC20 token) private view returns (uint256) {\\n    return _vestedAmount(token).sub(_released[token]);\\n  }\\n\\n  /**\\n   * @dev Calculates the amount that has already vested.\\n   * @param token ERC20 token which is being vested\\n   */\\n  function _vestedAmount(IERC20 token) private view returns (uint256) {\\n    uint256 currentBalance = token.balanceOf(this);\\n    uint256 totalBalance = currentBalance.add(_released[token]);\\n\\n    if (block.timestamp < _cliff) {\\n      return 0;\\n    } else if (block.timestamp >= _start.add(_duration)) {\\n      return totalBalance;\\n    } else {\\n      return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cliff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"releasable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"cliffDuration\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenVesting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"000000000000000000000000d70ae8cc22e66654f8704de0fec4d056e9c19d79000000000000000000000000000000000000000000000000000000005f934a0e00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000064","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9547142838c30a6f5f5a4d17fec2d43454ee9d83492743d779bf1a349cf7b381"}]}