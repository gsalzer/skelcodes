{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\\\";\\n// import \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Metadata.sol\\\";\\n// import \\\"@openzeppelin/contractss-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol\\\";\\n// import \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableMap.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Counters.sol\\\";\\nimport \\\"./interfaces/IERC721Receiver.sol\\\";\\nimport \\\"./interfaces/IERC721.sol\\\";\\nimport \\\"./libraries/AddressERC721.sol\\\";\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev Removed and added funtionality needed from the original.\\n */\\ncontract ERC721 is ContextUpgradeSafe, ERC165UpgradeSafe, IERC721, IERC721Metadata, IERC721Enumerable {\\n  using SafeMath for uint256;\\n  using AddressERC721 for address;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\\n  using Strings for uint256;\\n\\n  using Counters for Counters.Counter;\\n  Counters.Counter private _tokenIdTracker;\\n\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,uint256,address)\\\"))`\\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n  bytes4 private constant _ERC721_RECEIVED = bytes4(keccak256(\\\"onERC721Received(address,address,uint256,uint256,address)\\\"));\\n\\n  // Mapping from holder address to their (enumerable) set of owned tokens\\n  mapping(address => EnumerableSet.UintSet) private _holderTokens;\\n\\n  // Enumerable mapping from token ids to their owners\\n  EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n  // Mapping from token ID to approved address\\n  mapping(uint256 => address) private _tokenApprovals;\\n\\n  // Mapping from owner to operator approvals\\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n  // Token name\\n  string private _name;\\n  // Token symbol\\n  string private _symbol;\\n\\n  // Tokens will only have one URI.\\n  string public _tokenURI;\\n\\n  bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n  bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n  bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n  /**\\n   * @dev Initializes the contract by setting a `name` and a `symbol` and tokenURI to the token collection.\\n   */\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    string memory tokenURI\\n  ) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _tokenURI = tokenURI;\\n\\n    // register the supported interfaces to conform to ERC721 via ERC165\\n    _registerInterface(_INTERFACE_ID_ERC721);\\n    _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n  }\\n\\n  /**\\n   * @dev See {IERC721-balanceOf}.\\n   */\\n  function balanceOf(address owner) public view override returns (uint256) {\\n    require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n    return _holderTokens[owner].length();\\n  }\\n\\n  /**\\n   * @dev See {IERC721-ownerOf}.\\n   */\\n  function ownerOf(uint256 tokenId) public view override returns (address) {\\n    return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n  }\\n\\n  /**\\n   * @dev See {IERC721Metadata-name}.\\n   */\\n  function name() public view override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev See {IERC721Metadata-symbol}.\\n   */\\n  function symbol() public view override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev See {IERC721Metadata-tokenURI}.\\n   */\\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n    require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n    return _tokenURI;\\n  }\\n\\n  /**\\n   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n    return _holderTokens[owner].at(index);\\n  }\\n\\n  /**\\n   * @dev See {IERC721Enumerable-totalSupply}.\\n   */\\n  function totalSupply() public view override returns (uint256) {\\n    // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n    return _tokenOwners.length();\\n  }\\n\\n  /**\\n   * @dev See {IERC721Enumerable-tokenByIndex}.\\n   */\\n  function tokenByIndex(uint256 index) public view override returns (uint256) {\\n    (uint256 tokenId, ) = _tokenOwners.at(index);\\n    return tokenId;\\n  }\\n\\n  /**\\n   * @dev See {IERC721-approve}.\\n   */\\n  function approve(address to, uint256 tokenId) public virtual override {\\n    address owner = ownerOf(tokenId);\\n    require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n    require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \\\"ERC721: approve caller is not owner nor approved for all\\\");\\n\\n    _approve(to, tokenId);\\n  }\\n\\n  /**\\n   * @dev See {IERC721-getApproved}.\\n   */\\n  function getApproved(uint256 tokenId) public view override returns (address) {\\n    require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n    return _tokenApprovals[tokenId];\\n  }\\n\\n  /**\\n   * @dev See {IERC721-setApprovalForAll}.\\n   */\\n  function setApprovalForAll(address operator, bool approved) public virtual override {\\n    require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n    _operatorApprovals[_msgSender()][operator] = approved;\\n    emit ApprovalForAll(_msgSender(), operator, approved);\\n  }\\n\\n  /**\\n   * @dev See {IERC721-isApprovedForAll}.\\n   */\\n  function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n    return _operatorApprovals[owner][operator];\\n  }\\n\\n  /**\\n   * @dev See {IERC721-transferFrom}.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public virtual override {\\n    //solhint-disable-next-line max-line-length\\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n    _transfer(from, to, tokenId);\\n  }\\n\\n  /**\\n   * @dev See {IERC721-safeTransferFrom}.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public virtual override {\\n    safeTransferFrom(from, to, tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Safely transfers the ownership of a given token ID to another address\\n   * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   * Requires the _msgSender() to be the owner, approved, or operator\\n   * @param from current owner of the token\\n   * @param to address to receive the ownership of the given token ID\\n   * @param tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes data to send along with a safe transfer check\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes memory _data\\n  ) public virtual override {\\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n    _safeTransfer(from, to, tokenId, _data);\\n  }\\n\\n  /**\\n   * @dev Safely transfers the ownership of a given token ID to another address\\n   * If the target address is a contract, it must implement `onERC721Received`,\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   * Requires the msg.sender to be the owner, approved, or operator\\n   * @param from current owner of the token\\n   * @param to address to receive the ownership of the given token ID\\n   * @param tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes data to send along with a safe transfer check\\n   */\\n  function _safeTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes memory _data\\n  ) internal virtual {\\n    _transfer(from, to, tokenId);\\n    require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n  }\\n\\n  /**\\n   * @dev Returns whether `tokenId` exists.\\n   *\\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n   *\\n   * Tokens start existing when they are minted (`_mint`),\\n   * and stop existing when they are burned (`_burn`).\\n   */\\n  function _exists(uint256 tokenId) internal view returns (bool) {\\n    return _tokenOwners.contains(tokenId);\\n  }\\n\\n  /**\\n   * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n    require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n    address owner = ownerOf(tokenId);\\n    return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n  }\\n\\n  /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n  function _safeMint(address to, uint256 tokenId) internal virtual {\\n    _safeMint(to, tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Internal function to safely mint a new token.\\n   * Reverts if the given token ID already exists.\\n   * If the target address is a contract, it must implement `onERC721Received`,\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   * @param to The address that will own the minted token\\n   * @param tokenId uint256 ID of the token to be minted\\n   * @param _data bytes data to send along with a safe transfer check\\n   */\\n  function _safeMint(\\n    address to,\\n    uint256 tokenId,\\n    bytes memory _data\\n  ) internal virtual {\\n    _mint(to, tokenId);\\n    require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n  }\\n\\n  /**\\n   * @dev Mints `tokenId` and transfers it to `to`.\\n   *\\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must not exist.\\n   * - `to` cannot be the zero address.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function mint(address to) internal returns (uint256 tokenId) {\\n    uint256 currentId = _tokenIdTracker.current();\\n    _mint(to, currentId);\\n    _tokenIdTracker.increment();\\n    return currentId;\\n  }\\n\\n  function _mint(address to, uint256 tokenId) private {\\n    require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n    require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n    _beforeTokenTransfer(address(0), to, tokenId);\\n    _holderTokens[to].add(tokenId);\\n\\n    _tokenOwners.set(tokenId, to);\\n    emit Transfer(address(0), to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Destroys `tokenId`.\\n   * The approval is cleared when the token is burned.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function _burn(uint256 tokenId) internal virtual {\\n    address owner = ownerOf(tokenId);\\n    _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n    // Clear approvals\\n    _approve(address(0), tokenId);\\n    _holderTokens[owner].remove(tokenId);\\n    _tokenOwners.remove(tokenId);\\n\\n\\n\\n    emit Transfer(owner, address(0), tokenId);\\n  }\\n\\n  /**\\n   * @dev Transfers `tokenId` from `from` to `to`.\\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - `tokenId` token must be owned by `from`.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal virtual {\\n    require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n    require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n    _beforeTokenTransfer(from, to, tokenId);\\n\\n    // Clear approvals from the previous owner\\n    _approve(address(0), tokenId);\\n\\n    _holderTokens[from].remove(tokenId);\\n    _holderTokens[to].add(tokenId);\\n\\n    _tokenOwners.set(tokenId, to);\\n\\n    emit Transfer(from, to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n   * The call is not executed if the target address is not a contract.\\n   *\\n   * @param from address representing the previous owner of the given token ID\\n   * @param to target address that will receive the tokens\\n   * @param tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes optional data to send along with the call\\n   * @return bool whether the call correctly returned the expected magic value\\n   */\\n  function _checkOnERC721Received(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes memory _data\\n  ) private returns (bool) {\\n    if (!to.isContract()) {\\n      return true;\\n    }\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) =\\n      to.call(abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector, _msgSender(), from, tokenId, _data));\\n    if (!success) {\\n      if (returndata.length > 0) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n      }\\n    } else {\\n      bytes4 retval = abi.decode(returndata, (bytes4));\\n      return (retval == _ERC721_RECEIVED);\\n    }\\n  }\\n\\n  function _approve(address to, uint256 tokenId) private {\\n    _tokenApprovals[tokenId] = to;\\n    emit Approval(ownerOf(tokenId), to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any token transfer. This includes minting\\n   * and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n   * transferred to `to`.\\n   * - When `from` is zero, `tokenId` will be minted for `to`.\\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165UpgradeSafe is Initializable, IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n\\n\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        return _get(map, key, \\\"EnumerableMap: nonexistent key\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/Strings.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/Counters.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\\n     * otherwise the caller will revert the transaction. The selector to be\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\n     * function MAY throw to revert and reject the transfer.\\n     * Note: the ERC721 contract address is always the message sender.\\n     * @param operator The address which called `safeTransferFrom` function\\n     * @param from The address which previously owned the token\\n     * @param tokenId The NFT identifier which is being transferred\\n     * @param data Additional data with no specified format\\n     * @return bytes4 `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of NFTs in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AddressERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressERC721 {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.8.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logByte(byte p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(byte)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./YGYStorageV1.sol\\\";\\n\\n\\ncontract NFT is ERC721, AccessControlUpgradeSafe {\\n  bytes32 public constant SYSTEM_ROLE = keccak256(\\\"SYSTEM_ROLE\\\");\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  uint256 public contractId;\\n\\n  // Tradeable?\\n  bool allowTrade;\\n\\n  // Capped?\\n  bool isCapped;\\n  uint256 tokenCap;\\n  address ramVault;\\n\\n  // Props for unique token\\n  mapping(uint256 => YGYStorageV1.NFTProperty) public properties;\\n\\n  // How many choices available for this particular NFT\\n  uint256 propertyChoices;\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _tokenURI,\\n    uint256 _contractId,\\n    uint256 _propertyChoices,\\n    address _superAdmin,\\n    bool _allowTrade,\\n    bool _isCapped,\\n    uint256 _tokenCap,\\n    address _ramVault\\n  ) public ERC721(_name, _symbol, _tokenURI) {\\n    allowTrade = _allowTrade;\\n    isCapped = _isCapped;\\n    tokenCap = _tokenCap;\\n    contractId = _contractId;\\n    propertyChoices = _propertyChoices;\\n    __AccessControl_init();\\n    _setupRole(SYSTEM_ROLE, _msgSender());\\n    _setupRole(SYSTEM_ROLE, _ramVault);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _superAdmin);\\n  }\\n\\n  /**\\n   * @dev Used for tokens that are transferrable and non-delegating.\\n   */\\n  function burn(uint256 _tokenId) external {\\n    require(ownerOf(_tokenId) == _msgSender() || hasRole(SYSTEM_ROLE, _msgSender()), \\\"Not allowed\\\");\\n\\n    _burn(_tokenId);\\n  }\\n\\n  /**\\n   * @dev Mint a token and set it's property\\n   */\\n  function mint(\\n    address to,\\n    uint256 _randomness,\\n    YGYStorageV1 _storage\\n  ) public returns (uint256 _tokenId) {\\n    require(!isCapped || (isCapped && totalSupply() <= tokenCap), \\\"NFT Limit reached\\\");\\n    require(hasRole(SYSTEM_ROLE, _msgSender()), \\\"Not allowed\\\");\\n\\n    // Mint the token, get the unique id.\\n    uint256 tokenId = super.mint(to);\\n    // Get a random index for property selection\\n    uint256 propIndex;\\n    if (propertyChoices > 1) {\\n      propIndex = _randomness.mod(propertyChoices);\\n    }\\n    // Random properties got\\n    (string memory pType, uint256 pValue, bytes32 extra) = _storage.getNFTProperty(contractId.add(1), propIndex);\\n    properties[tokenId].pType = pType;\\n    properties[tokenId].pValue = pValue;\\n    properties[tokenId].extra = extra;\\n    return tokenId;\\n  }\\n\\n  function getTokenProperty(uint256 _tokenId) public view returns (YGYStorageV1.NFTProperty memory) {\\n    return properties[_tokenId];\\n  }\\n\\n  function setTokenURI(string memory uri) external {\\n    require(hasRole(SYSTEM_ROLE, _msgSender()), \\\"Bad caller!\\\");\\n    _tokenURI = uri;\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public override {\\n    _beforeTokenTransfer(from, to, tokenId);\\n    super.transferFrom(from, to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Used to halt transfers while maintaining minting ability for the delegator / minter.\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal override {\\n    require((allowTrade || hasRole(SYSTEM_ROLE, _msgSender())) || (!allowTrade && hasRole(SYSTEM_ROLE, to)), \\\"External trades not allowed\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/YGYStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED;\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/**\\nStorage contract for the YGY system\\n*/\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/INBUNIERC20.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IWETH.sol\\\";\\nimport \\\"./libraries/PoolHelper.sol\\\";\\n\\n\\ncontract YGYStorageV1 is AccessControlUpgradeSafe {\\n  /* STORAGE CONFIG */\\n  using SafeMath for uint256;\\n  using PoolHelper for PoolInfo;\\n\\n  bytes32 public constant MODIFIER_ROLE = keccak256(\\\"MODIFIER_ROLE\\\");\\n\\n  function setModifierContracts(\\n    address _vault,\\n    address _router,\\n    address _nftFactory\\n  ) external {\\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \\\"Nono\\\");\\n    _setupRole(MODIFIER_ROLE, _vault);\\n    _setupRole(MODIFIER_ROLE, _router);\\n    _setupRole(MODIFIER_ROLE, _nftFactory);\\n  }\\n\\n  function init() external initializer {\\n    __AccessControl_init();\\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    _setupRole(MODIFIER_ROLE, _msgSender());\\n  }\\n\\n  /* RAMVAULT */\\n\\n  // User properties per vault/pool.\\n  struct UserInfo {\\n    uint256 amount; // How many  tokens the user has provided.\\n    uint256 rewardDebt; // Reward debt. See explanation below.\\n    uint256 rewardDebtYGY;\\n    uint256 boostAmount;\\n    uint256 boostLevel;\\n    uint256 spentMultiplierTokens;\\n  }\\n\\n  struct NFTUsage {\\n    uint256 contractId;\\n    uint256 epoch;\\n  }\\n\\n  // Epoch -> User -> NFT ids in use.\\n  mapping(uint256 => mapping(address => NFTUsage[])) public NFTUsageInfo;\\n\\n  function setNFTInUse(uint256 _contractId, address _user) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    NFTUsageInfo[epoch][_user].push(NFTUsage({ contractId: _contractId, epoch: epoch }));\\n  }\\n\\n  function getNFTsInUse(address _user) external view returns (NFTUsage[] memory) {\\n    return NFTUsageInfo[epoch][_user];\\n  }\\n\\n  function getNFTBoost(address _user) external view returns (uint256) {\\n    uint256 NFTBoost;\\n    NFTUsage[] memory nftInfo = NFTUsageInfo[epoch][_user];\\n    for (uint256 i; i < nftInfo.length; i++) {\\n      if (epoch == nftInfo[i].epoch) {\\n        if (nftInfo[i].contractId == 5 || nftInfo[i].contractId == 6) {\\n          NFTBoost = NFTBoost.add(10);\\n        }\\n      }\\n    }\\n    return NFTBoost;\\n  }\\n\\n  // Pool/Vault/Whatever-id -> userrAddress -> userInfo\\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\n  function updateUserInfo(\\n    uint256 _poolId,\\n    address _userAddress,\\n    UserInfo memory _userInfo\\n  ) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    userInfo[_poolId][_userAddress] = _userInfo;\\n  }\\n\\n  // PoolId -> UserAddress -> Spender -> Allowance\\n  mapping(uint256 => mapping(address => mapping(address => uint256))) public poolAllowance;\\n\\n  function setPoolAllowance(\\n    uint256 _pid,\\n    address _user,\\n    address _spender,\\n    uint256 _allowance\\n  ) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    poolAllowance[_pid][_user][_spender] = _allowance;\\n  }\\n\\n  // Pool properties\\n  struct PoolInfo {\\n    IERC20 token; // Address of  token contract.\\n    uint256 allocPoint; // How many allocation points assigned to this pool. RAMs to distribute per block.\\n    uint256 accRAMPerShare; // Accumulated RAMs per share, times 1e12. See below.\\n    uint256 accYGYPerShare; // Accumulated YGYs per share, times 1e12. See below.\\n    bool withdrawable; // Is this pool withdrawable?\\n    uint256 effectiveAdditionalTokensFromBoosts; // Track the total additional accounting staked tokens from boosts.\\n  }\\n  // All pool properties\\n  PoolInfo[] public poolInfo;\\n\\n  function updatePoolInfo(uint256 _poolId, PoolInfo memory _userInfo) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    poolInfo[_poolId] = _userInfo;\\n  }\\n\\n  function setPool(\\n    uint256 _poolId,\\n    uint256 _allocPoint,\\n    bool _withdrawable\\n  ) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    totalAllocPoint.sub(poolInfo[_poolId].allocPoint).add(_allocPoint);\\n    poolInfo[_poolId].allocPoint = _allocPoint;\\n    poolInfo[_poolId].withdrawable = _withdrawable;\\n  }\\n\\n  function addPool(\\n    uint256 _allocPoint,\\n    IERC20 _token,\\n    bool _withdrawable\\n  ) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    for (uint256 pid = 0; pid < poolInfo.length; ++pid) {\\n      require(poolInfo[pid].token != _token, \\\"Error pool already added\\\");\\n    }\\n    totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n    poolInfo.push(\\n      YGYStorageV1.PoolInfo({\\n        token: _token,\\n        allocPoint: _allocPoint,\\n        accRAMPerShare: 0,\\n        accYGYPerShare: 0,\\n        withdrawable: _withdrawable,\\n        effectiveAdditionalTokensFromBoosts: 0\\n      })\\n    );\\n  }\\n\\n  function updatePoolRewards(uint256 allRewards, uint256 allYGYRewards) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    pendingRewards = pendingRewards.sub(allRewards);\\n    pendingYGYRewards = pendingYGYRewards.sub(allYGYRewards);\\n  }\\n\\n  function addPendingRewards(uint256 _amount) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()), \\\"Prohibited caller\\\");\\n    pendingRewards = pendingRewards.add(_amount);\\n    rewardsInThisEpoch = rewardsInThisEpoch.add(_amount);\\n\\n    if (YGYReserve > _amount) {\\n      pendingYGYRewards = pendingYGYRewards.add(_amount);\\n      YGYRewardsInThisEpoch = YGYRewardsInThisEpoch.add(_amount);\\n      YGYReserve = YGYReserve.sub(_amount);\\n    } else if (YGYReserve > 0) {\\n      YGYRewardsInThisEpoch = YGYRewardsInThisEpoch.add(_amount);\\n      pendingYGYRewards = pendingYGYRewards.add(YGYReserve);\\n      YGYReserve = 0;\\n    }\\n  }\\n\\n  function addAdditionalRewards(uint256 _amount, bool _ygy) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    if (_ygy) {\\n      YGYReserve = YGYReserve.add(_amount);\\n    } else {\\n      pendingRewards = pendingRewards.add(_amount);\\n      rewardsInThisEpoch = rewardsInThisEpoch.add(_amount);\\n    }\\n  }\\n\\n  function getPoolLength() external view returns (uint256) {\\n    return poolInfo.length;\\n  }\\n\\n  function getPoolInfo(uint256 _poolId)\\n    external\\n    view\\n    returns (\\n      IERC20 _token,\\n      uint256 _allocPointt,\\n      uint256 _accRAMPerShare,\\n      uint256 _accYGYPerShare,\\n      bool _withdrawable,\\n      uint256 _effectiveAdditionalTokensFromBoosts\\n    )\\n  {\\n    PoolInfo memory pool = poolInfo[_poolId];\\n    return (\\n      pool.token,\\n      pool.allocPoint,\\n      pool.accRAMPerShare,\\n      pool.accYGYPerShare,\\n      pool.withdrawable,\\n      pool.effectiveAdditionalTokensFromBoosts\\n    );\\n  }\\n\\n  // Total allocattion points for the whole contract\\n  uint256 public totalAllocPoint;\\n\\n  // Pending rewards.\\n  uint256 public pendingRewards;\\n  uint256 public pendingYGYRewards;\\n\\n  // Extra balance-keeping for extra-token rewards\\n  uint256 public YGYReserve;\\n\\n  function setYGYReserve(uint256 _amount) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    YGYReserve = _amount;\\n  }\\n\\n  // Reward token balance-keeping\\n  uint256 internal ramBalance;\\n\\n  function setRAMBalance(uint256 _amount) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    ramBalance = _amount;\\n  }\\n\\n  uint256 internal ygyBalance;\\n\\n  function setYGYBalance(uint256 _amount) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    ygyBalance = _amount;\\n  }\\n\\n  uint256 public RAMVaultStartBlock;\\n\\n  function setRAMVaultStartBlock() external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    RAMVaultStartBlock = block.number;\\n  }\\n\\n  uint256 public epochStartBlock;\\n\\n  function setEpochCalculationStartBlock() external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    epochStartBlock = block.number;\\n  }\\n\\n  uint256 public cumulativeRewardsSinceStart;\\n  uint256 public cumulativeYGYRewardsSinceStart;\\n\\n  function setCumulativeRewardsSinceStart() external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    cumulativeRewardsSinceStart = cumulativeRewardsSinceStart + rewardsInThisEpoch;\\n    cumulativeYGYRewardsSinceStart = cumulativeYGYRewardsSinceStart + YGYRewardsInThisEpoch;\\n  }\\n\\n  uint256 public rewardsInThisEpoch;\\n  uint256 public YGYRewardsInThisEpoch;\\n\\n  function setRewardsInThisEpoch(uint256 _amount, uint256 _ygyAmount) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    rewardsInThisEpoch = _amount;\\n    YGYRewardsInThisEpoch = _ygyAmount;\\n  }\\n\\n  uint256 public epoch;\\n\\n  // TOKENS\\n  INBUNIERC20 public ram; // The RAM token\\n  IERC20 public ygy; // The YGY token\\n  address public _YGYRAMPair;\\n  address public _YGYToken;\\n  address public _YGYWETHPair;\\n  address public _RAMToken;\\n  IWETH public _WETH;\\n  IERC20 public _dXIOTToken;\\n\\n  function initializeRAMVault() external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()) || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \\\"Prohibited caller\\\");\\n    RAMVaultStartBlock = block.number;\\n    epochStartBlock = block.number;\\n\\n    boostLevelCosts[1] = 5 * 1e18; // 5 RAM tokens\\n    boostLevelCosts[2] = 15 * 1e18; // 15 RAM tokens\\n    boostLevelCosts[3] = 30 * 1e18; // 30 RAM tokens\\n    boostLevelCosts[4] = 60 * 1e18; // 60 RAM tokens\\n    boostLevelMultipliers[1] = 5; // 5%\\n    boostLevelMultipliers[2] = 15; // 15%\\n    boostLevelMultipliers[3] = 30; // 30%\\n    boostLevelMultipliers[4] = 60; // 60%\\n  }\\n\\n  function setTokens(\\n    address RAMToken,\\n    address YGYToken,\\n    address WETH,\\n    address YGYRAMPair,\\n    address YGYWethPair,\\n    address[] memory nfts,\\n    address dXIOTToken\\n  ) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()) || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \\\"Prohibited caller\\\");\\n    ram = INBUNIERC20(RAMToken);\\n    ygy = IERC20(YGYToken);\\n    _RAMToken = RAMToken;\\n    _YGYToken = YGYToken;\\n    _WETH = IWETH(WETH);\\n    _YGYRAMPair = YGYRAMPair;\\n    _YGYWETHPair = YGYWethPair;\\n    _dXIOTToken = IERC20(dXIOTToken);\\n    for (uint256 i = 0; i < nfts.length; i++) {\\n      _NFTs[i + 1] = nfts[i];\\n    }\\n  }\\n\\n  // Boosts\\n  uint256 public boostFees;\\n\\n  function setBoostFees(uint256 _amount, bool _add) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    if (_add) {\\n      boostFees = boostFees.add(_amount);\\n    } else {\\n      boostFees = _amount;\\n    }\\n  }\\n\\n  mapping(uint256 => uint256) public boostLevelCosts;\\n\\n  function checkRewards(uint256 _pid, address _user) external view returns (uint256 pendingRAM, uint256 pendingYGY) {\\n    PoolInfo storage pool = poolInfo[_pid];\\n    UserInfo storage user = userInfo[_pid][_user];\\n\\n    uint256 effectiveAmount = user.amount.add(user.boostAmount);\\n    uint256 YGYRewards;\\n    if (pool.accYGYPerShare > 0) {\\n      YGYRewards = effectiveAmount.mul(pool.accYGYPerShare).div(1e12).sub(user.rewardDebtYGY);\\n    }\\n    return (effectiveAmount.mul(pool.accRAMPerShare).div(1e12).sub(user.rewardDebt), YGYRewards);\\n  }\\n\\n  function getBoostLevelCost(uint256 _level) external view returns (uint256) {\\n    return boostLevelCosts[_level];\\n  }\\n\\n  mapping(uint256 => uint256) public boostLevelMultipliers;\\n\\n  function getBoostLevelMultiplier(uint256 _level) external view returns (uint256) {\\n    return boostLevelMultipliers[_level];\\n  }\\n\\n  function updateBoosts(uint256[] memory _boostMultipliers, uint256[] memory _boostCosts) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    // Update boost costs\\n    for (uint8 i; i <= _boostMultipliers.length; i++) {\\n      boostLevelCosts[i + 1] = _boostCosts[i];\\n      boostLevelMultipliers[i + 1] = _boostMultipliers[i];\\n    }\\n  }\\n\\n  // For easy graphing historical epoch rewards\\n  mapping(uint256 => uint256) public epochRewards;\\n\\n  function setEpochRewards() external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    epochRewards[epoch] = rewardsInThisEpoch;\\n    epoch++;\\n  }\\n\\n  function averageFeesPerBlockSinceStart() external view returns (uint256 averagePerBlock, uint256 ygyPerBlock) {\\n    return (\\n      cumulativeRewardsSinceStart.add(rewardsInThisEpoch).div(block.number.sub(RAMVaultStartBlock)),\\n      cumulativeYGYRewardsSinceStart.add(YGYRewardsInThisEpoch).div(block.number.sub(RAMVaultStartBlock))\\n    );\\n  }\\n\\n  // Returns averge fees in this epoch\\n  function averageFeesPerBlockEpoch() external view returns (uint256 averagePerBlock, uint256 ygyPerBlock) {\\n    return (rewardsInThisEpoch.div(block.number.sub(epochStartBlock)), YGYRewardsInThisEpoch.div(block.number.sub(epochStartBlock)));\\n  }\\n\\n  /*\\n         ROUTER\\n    */\\n\\n  // Mapping of (user => last ticket level)\\n  mapping(address => uint256) public lastTicketLevel;\\n\\n  // Setter for contracts using\\n  function setLastTicketLevel(address _user, uint256 _level) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    lastTicketLevel[_user] = _level;\\n  }\\n\\n  // Total eth contributed to a vault.\\n  mapping(address => uint256) public liquidityContributedEthValue;\\n\\n  // Set value for mapping from external contracts\\n  function setLiquidityContributedEthValue(\\n    address _spender,\\n    uint256 _amount,\\n    bool _delete\\n  ) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    if (_delete) {\\n      delete liquidityContributedEthValue[_spender];\\n    } else {\\n      liquidityContributedEthValue[_spender] = liquidityContributedEthValue[_spender].add(_amount);\\n    }\\n  }\\n\\n  // NFT STUFF\\n  // Mapping of (level number => NFT address)\\n  mapping(uint256 => address) public _NFTs;\\n\\n  // Property object, extra field for arbirtrary values in future\\n  struct NFTProperty {\\n    string pType;\\n    uint256 pValue;\\n    bytes32 extra;\\n  }\\n\\n  mapping(address => NFTProperty[]) public nftPropertyChoices;\\n\\n  function setNFTPropertiesForContract(address _contractAddress, NFTProperty[] memory _properties) external {\\n    require(hasRole(MODIFIER_ROLE, _msgSender()));\\n    for (uint256 i; i < _properties.length; i++) {\\n      nftPropertyChoices[_contractAddress].push(_properties[i]);\\n    }\\n  }\\n\\n  function getNFTAddress(uint256 _contractId) external view returns (address) {\\n    return _NFTs[_contractId];\\n  }\\n\\n  function getNFTProperty(uint256 _contractId, uint256 _index)\\n    external\\n    view\\n    returns (\\n      string memory pType,\\n      uint256 pValue,\\n      bytes32 extra\\n    )\\n  {\\n    address NFTAddress = _NFTs[_contractId];\\n    NFTProperty memory properties = nftPropertyChoices[NFTAddress][_index];\\n\\n    return (properties.pType, properties.pValue, properties.extra);\\n  }\\n\\n  function getNFTPropertyCount(uint256 _contractId) external view returns (uint256) {\\n    address NFTAddress = _NFTs[_contractId];\\n    NFTProperty[] memory properties = nftPropertyChoices[NFTAddress];\\n    return properties.length;\\n  }\\n\\n  // General-purpose mappings\\n  mapping(bytes32 => mapping(address => bool)) booleanMapStorage;\\n  uint256[] public booleanMapStorageCount;\\n\\n  function getBooleanMapValue(string memory _key, address _address) external view returns (bool) {\\n    bytes32 key = stringToBytes32(_key);\\n    booleanMapStorage[key][_address];\\n  }\\n\\n  mapping(bytes32 => address) addressStorage;\\n  uint256[] public addressStorageCount;\\n\\n  function getAddressStorage(string memory _key) external view returns (address) {\\n    bytes32 key = stringToBytes32(_key);\\n    return addressStorage[key];\\n  }\\n\\n  mapping(bytes32 => uint256) uintStorage;\\n  uint256[] public uintStorageCount;\\n\\n  struct StateStruct {\\n    bytes32 name;\\n    mapping(bytes32 => bytes32) value;\\n  }\\n\\n  struct ObjectStruct {\\n    StateStruct state;\\n    address owner;\\n    bool isObject;\\n  }\\n\\n  function stringToBytes32(string memory source) public pure returns (bytes32 result) {\\n    bytes memory tempEmptyStringTest = bytes(source);\\n    if (tempEmptyStringTest.length == 0) {\\n      return 0x0;\\n    }\\n\\n    assembly {\\n      result := mload(add(source, 32))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, _msgSender()));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n */\\nabstract contract AccessControlUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INBUNIERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface INBUNIERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event Log(string log);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/libraries/PoolHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED;\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../YGYStorageV1.sol\\\";\\n\\nlibrary PoolHelper {\\n  using SafeMath for uint256;\\n\\n  function getPool(uint256 _poolId, YGYStorageV1 _storage) internal view returns (YGYStorageV1.PoolInfo memory) {\\n    (\\n      IERC20 token,\\n      uint256 allocPoint,\\n      uint256 accRAMPerShare,\\n      uint256 accYGYPerShare,\\n      bool withdrawable,\\n      uint256 effectiveAdditionalTokensFromBoosts\\n    ) = _storage.poolInfo(_poolId);\\n    return\\n      YGYStorageV1.PoolInfo({\\n        token: token,\\n        allocPoint: allocPoint,\\n        accRAMPerShare: accRAMPerShare,\\n        accYGYPerShare: accYGYPerShare,\\n        withdrawable: withdrawable,\\n        effectiveAdditionalTokensFromBoosts: effectiveAdditionalTokensFromBoosts\\n      });\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RAMV1router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\n// import \\\"@chainlink/contracts/src/v0.6/VRFConsumerBase.sol\\\";\\nimport \\\"./uniswapv2/libraries/Math.sol\\\";\\nimport \\\"./uniswapv2/libraries/UniswapV2Library.sol\\\";\\nimport \\\"./interfaces/INFT.sol\\\";\\nimport \\\"./VRFConsumerBase.sol\\\";\\nimport \\\"./interfaces/INFTFactory.sol\\\";\\nimport \\\"./interfaces/IFeeApprover.sol\\\";\\nimport \\\"./interfaces/IRAMVault.sol\\\";\\nimport \\\"./NFT.sol\\\";\\nimport \\\"./StorageState.sol\\\";\\n\\n// This contract is supposed to streamline liquidity additions\\n// By allowing people to put in any amount of ETH or YGY and get LP tokens back\\ncontract RAMv1Router is StorageState, OwnableUpgradeSafe, VRFConsumerBase {\\n  // RAM protocol variable\\n  IFeeApprover public _feeApprover;\\n  IRAMVault public _RAMVault;\\n  address public _uniV2Factory;\\n\\n  // Governance and regenerator tax\\n  bool governanceSet;\\n  address public governance;\\n  address payable public regenerator;\\n  uint256 public regeneratorTax;\\n\\n  // RNG\\n  uint256 public constant MAX = 2**256 - 1;\\n  uint256 public constant SCALE = 100;\\n  uint256 public constant SCALIFIER = MAX / SCALE;\\n  uint256 public constant OFFSET = 1;\\n  uint256 public rngLinkFee;\\n  bytes32 internal keyHash;\\n\\n  address public _YGYRAMPair;\\n  address public _YGYToken;\\n  address public _YGYWETHPair;\\n  address public _RAMToken;\\n  IWETH public _WETH;\\n  IERC20 public _dXIOTToken;\\n\\n  // Lottery tracking\\n  struct LotteryTicket {\\n    address owner;\\n    uint256 roundNumber;\\n    uint256 levelOneChance;\\n    uint256 levelTwoChance;\\n    uint256 levelThreeChance;\\n    uint256 levelFourChance;\\n    uint256 levelFiveChance;\\n  }\\n  uint256 public ticketCount;\\n  uint256 public lotteryRoundCounter;\\n  mapping(uint256 => uint256) public lotteryResults;\\n\\n  // Mapping of user address => ticket number => ticket\\n  mapping(address => mapping(uint256 => LotteryTicket)) public userTickets;\\n  mapping(address => uint256) public userTicketCount;\\n  mapping(address => uint256) public userTopTicketStack;\\n\\n  // NFT\\n  INFTFactory public _NFTFactory;\\n\\n  constructor(\\n    address uniV2Factory,\\n    address feeApprover,\\n    address RAMVault,\\n    address nftFactory,\\n    address payable _regenerator,\\n    address __storage,\\n    address linkAddr,\\n    address vrfAddr\\n  )\\n    public\\n    VRFConsumerBase(\\n      vrfAddr,\\n      linkAddr\\n    )\\n  {\\n    __Ownable_init();\\n    _uniV2Factory = uniV2Factory;\\n    _feeApprover = IFeeApprover(feeApprover);\\n    _RAMVault = IRAMVault(RAMVault);\\n    _NFTFactory = INFTFactory(nftFactory);\\n    _storage = YGYStorageV1(__storage);\\n\\n    regenerator = _regenerator;\\n    keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\\n    rngLinkFee = 2 * 10**18;\\n    regeneratorTax = 1;\\n  }\\n\\n  function setTokens() external onlyOwner {\\n    _YGYRAMPair = _storage._YGYRAMPair();\\n    _YGYToken = _storage._YGYToken();\\n    _YGYWETHPair = _storage._YGYWETHPair();\\n    _RAMToken = _storage._RAMToken();\\n    _WETH = IWETH(_storage._WETH());\\n    _dXIOTToken = IERC20(_storage._dXIOTToken());\\n    refreshApproval();\\n  }\\n\\n  function setGovernance(address _governance) public {\\n    require(!governanceSet, \\\"Governance contract has already been set\\\");\\n    governanceSet = true;\\n    governance = _governance;\\n  }\\n\\n  function setRegenerator(address payable _regeneratoraddr) external onlyOwner {\\n    regenerator = _regeneratoraddr;\\n  }\\n\\n  function setRegeneratorTax(uint256 _regeneratorTax) public {\\n    require(msg.sender == governance, \\\"Locked to governance\\\");\\n    regeneratorTax = _regeneratorTax;\\n  }\\n\\n  function refreshApproval() public {\\n    IUniswapV2Pair(_YGYRAMPair).approve(address(_RAMVault), uint256(-1));\\n  }\\n\\n  event FeeApproverChanged(address indexed newAddress, address indexed oldAddress);\\n\\n  fallback() external payable {\\n    if (msg.sender != address(_WETH)) {\\n      addLiquidityETHOnly(msg.sender, false);\\n    }\\n  }\\n\\n  // Markets buys YGY with 100% of the ETH deposited, then calls _swapYGYForRAMAndAddLiquidity\\n  function addLiquidityETHOnly(address payable to, bool autoStake) public payable {\\n    require(to != address(0), \\\"Invalid address\\\");\\n\\n    uint256 buyAmount = msg.value;\\n    require(buyAmount > 0, \\\"Insufficient ETH amount\\\");\\n    _WETH.deposit{ value: msg.value }();\\n\\n    (uint256 reserveWeth, uint256 reserveYGY) = getYGYWETHPairReserves();\\n    uint256 outYGY = UniswapV2Library.getAmountOut(buyAmount, reserveWeth, reserveYGY);\\n\\n    _WETH.transfer(_YGYWETHPair, buyAmount);\\n\\n    _storage.setLiquidityContributedEthValue(to, buyAmount, false);\\n\\n    (address token0, address token1) = UniswapV2Library.sortTokens(address(_WETH), _YGYToken);\\n    IUniswapV2Pair(_YGYWETHPair).swap(_YGYToken == token0 ? outYGY : 0, _YGYToken == token1 ? outYGY : 0, address(this), \\\"\\\");\\n\\n    // Calculate tax and send directly to regenerator\\n    _swapYGYForRAMAndAddLiquidity(outYGY.div(2), to, autoStake);\\n  }\\n\\n  // addLiquidityYGYOnly transfers approved YGY tokens to the contract and calls _swapYGYForRAMAndAddLiquidity\\n  function addLiquidityYGYOnly(uint256 amount, bool autoStake) public payable {\\n    require(amount > 0, \\\"Insufficient token amount\\\");\\n    require(IERC20(_YGYToken).transferFrom(msg.sender, address(this), amount), \\\"Approve tokens first\\\");\\n\\n    // Calculate value of YGY in ETH for liquidity value tracking\\n    (uint256 reserveWeth, uint256 reserveYGY) = getYGYWETHPairReserves();\\n    uint256 outETH = UniswapV2Library.getAmountOut(amount, reserveYGY, reserveWeth);\\n\\n    // Calculate tax and send directly to regenerator\\n    uint256 taxedAmount = amount.mul(regeneratorTax).div(100);\\n\\n    _storage.setLiquidityContributedEthValue(msg.sender, outETH, false);\\n\\n    uint256 outAmount = amount.sub(taxedAmount);\\n    _swapYGYForRAMAndAddLiquidity(outAmount.div(2), msg.sender, autoStake);\\n  }\\n\\n  // With buyAmount*2 amount of YGY tokens on the contract, this function market buys RAM with buyAmount\\n  // of YGY and then calls _addLiquidity\\n  function _swapYGYForRAMAndAddLiquidity(\\n    uint256 buyAmount,\\n    address payable to,\\n    bool autoStake\\n  ) internal {\\n    (uint256 reserveYGY, uint256 reserveRAM) = getYGYRAMPairReserves();\\n    uint256 outRAM = UniswapV2Library.getAmountOut(buyAmount, reserveYGY, reserveRAM);\\n\\n    require(IERC20(_YGYToken).transfer(_YGYRAMPair, buyAmount), \\\"Transfer failed\\\");\\n\\n    (address token0, address token1) = UniswapV2Library.sortTokens(_YGYToken, _RAMToken);\\n\\n    IUniswapV2Pair(_YGYRAMPair).swap(_RAMToken == token0 ? outRAM : 0, _RAMToken == token1 ? outRAM : 0, address(this), \\\"\\\");\\n\\n    uint256 taxedAmount = outRAM.mul(regeneratorTax).div(100);\\n    IERC20(_RAMToken).transfer(regenerator, taxedAmount);\\n\\n    _addLiquidity(outRAM.sub(taxedAmount), buyAmount, to, autoStake);\\n    generateLotteryTickets(to);\\n    sync();\\n  }\\n\\n  // _addLiquidity sends RAM, YGY tokens to the _YGYRAMPair contract and mints _YGYRAMPair LP tokens.\\n  // It either auto stakes the LP tokens to the pool or sends them to the sender's address\\n  function _addLiquidity(\\n    uint256 RAMAmount,\\n    uint256 YGYAmount,\\n    address payable to,\\n    bool autoStake\\n  ) internal {\\n    (uint256 YGYReserve, uint256 RAMReserve) = getYGYRAMPairReserves();\\n\\n    uint256 optimalRAMAmount = UniswapV2Library.quote(YGYAmount, YGYReserve, RAMReserve);\\n\\n    uint256 optimalYGYAmount;\\n    if (optimalRAMAmount > RAMAmount) {\\n      optimalYGYAmount = UniswapV2Library.quote(RAMAmount, RAMReserve, YGYReserve);\\n      optimalRAMAmount = RAMAmount;\\n    } else optimalYGYAmount = YGYAmount;\\n\\n    assert(IERC20(_YGYToken).transfer(_YGYRAMPair, optimalYGYAmount));\\n    assert(IERC20(_RAMToken).transfer(_YGYRAMPair, optimalRAMAmount));\\n\\n    if (autoStake) {\\n      IUniswapV2Pair(_YGYRAMPair).mint(address(this));\\n      _RAMVault.depositFor(to, 0, IUniswapV2Pair(_YGYRAMPair).balanceOf(address(this)));\\n    } else IUniswapV2Pair(_YGYRAMPair).mint(to);\\n\\n    // Refund dust to sender\\n    if (RAMAmount > optimalRAMAmount) IERC20(_RAMToken).transfer(to, RAMAmount.sub(optimalRAMAmount));\\n\\n    if (YGYAmount > optimalYGYAmount) IERC20(_YGYToken).transfer(to, YGYAmount.sub(optimalYGYAmount));\\n  }\\n\\n  function getLPTokenPerYGYUnit(uint256 ygyAmt) public view returns (uint256 liquidity) {\\n    (uint256 reserveYGY, uint256 reserveRAM) = getYGYRAMPairReserves();\\n    uint256 outRAM = UniswapV2Library.getAmountOut(ygyAmt.div(2), reserveYGY, reserveRAM);\\n    uint256 _totalSupply = IUniswapV2Pair(_YGYRAMPair).totalSupply();\\n\\n    (address token0, ) = UniswapV2Library.sortTokens(_YGYToken, _RAMToken);\\n    (uint256 amount0, uint256 amount1) = token0 == _RAMToken ? (outRAM, ygyAmt.div(2)) : (ygyAmt.div(2), outRAM);\\n    (uint256 _reserve0, uint256 _reserve1) = token0 == _RAMToken ? (reserveRAM, reserveYGY) : (reserveYGY, reserveRAM);\\n    liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n  }\\n\\n  function getYGYWETHPairReserves() internal view returns (uint256 wethReserves, uint256 YGYReserves) {\\n    (address token0, ) = UniswapV2Library.sortTokens(address(_WETH), _YGYToken);\\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_YGYWETHPair).getReserves();\\n    (wethReserves, YGYReserves) = token0 == _YGYToken ? (reserve1, reserve0) : (reserve0, reserve1);\\n  }\\n\\n  function getYGYRAMPairReserves() internal view returns (uint256 YGYReserves, uint256 RAMReserves) {\\n    (address token0, ) = UniswapV2Library.sortTokens(_YGYToken, _RAMToken);\\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_YGYRAMPair).getReserves();\\n    (YGYReserves, RAMReserves) = token0 == _RAMToken ? (reserve1, reserve0) : (reserve0, reserve1);\\n  }\\n\\n  // Function sync fee approver\\n  function sync() public {\\n    _feeApprover.sync();\\n  }\\n\\n  // sets fee approver in case fee approver gets chaned.\\n  function setFeeApprover(address feeApproverAddress) public onlyOwner {\\n    _feeApprover = IFeeApprover(feeApproverAddress);\\n  }\\n\\n  function changeFeeApprover(address feeApprover) external onlyOwner {\\n    address oldAddress = address(_feeApprover);\\n    _feeApprover = IFeeApprover(feeApprover);\\n\\n    emit FeeApproverChanged(feeApprover, oldAddress);\\n  }\\n\\n  // -------------------------------------------------\\n  //              NFT Lottery + Chainlink RNG\\n  // -------------------------------------------------\\n\\n  /**\\n   * Requests randomness from a user-provided seed\\n   */\\n  function getRandomNumber(uint256 userProvidedSeed) public returns (bytes32 requestId) {\\n    require(LINK.balanceOf(address(this)) >= rngLinkFee, \\\"Not enough LINK on contract\\\");\\n    return requestRandomness(keyHash, rngLinkFee, userProvidedSeed);\\n  }\\n\\n  // Bookkeep the NFT claims\\n  mapping(address => uint256) public linkNFTsToBeClaimed;\\n  mapping(address => uint256) public robotNFTsToBeClaimed;\\n\\n  /**\\n   * Requests randomness from a user-provided seed\\n   */\\n  function selfRequestRandomNumber(uint256 userProvidedSeed) public returns (bytes32 requestId) {\\n    require(LINK.transferFrom(msg.sender, address(this), rngLinkFee), \\\"Not enough LINK approved to contract\\\");\\n    linkNFTsToBeClaimed[msg.sender] = linkNFTsToBeClaimed[msg.sender].add(1);\\n    return requestRandomness(keyHash, rngLinkFee, userProvidedSeed);\\n  }\\n\\n  /**\\n   * Callback function used by VRF Coordinator\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\n    uint256 randomResult = rand(randomness);\\n    lotteryResults[lotteryRoundCounter] = randomResult;\\n    lotteryRoundCounter = lotteryRoundCounter.add(1);\\n  }\\n\\n  function claimLink() external {\\n    require(linkNFTsToBeClaimed[msg.sender] > 0, \\\"No link provided\\\");\\n    INFT LinkNFT = INFT(_storage._NFTs(7));\\n    // Mint a LINK NFT to caller\\n    _NFTFactory.mint(LinkNFT, msg.sender, lotteryResults[lotteryRoundCounter]);\\n    linkNFTsToBeClaimed[msg.sender] = linkNFTsToBeClaimed[msg.sender].sub(1);\\n  }\\n\\n  function claimRobot() external {\\n    require(robotNFTsToBeClaimed[msg.sender] > 0, \\\"No ROBOTs for user available\\\");\\n    INFT RobotNFT = INFT(_storage._NFTs(6));\\n\\n    // Mint a ROBOT NFT to user.\\n    if (RobotNFT.totalSupply() < 50) {\\n      _NFTFactory.mint(RobotNFT, msg.sender, lotteryResults[lotteryRoundCounter]);\\n      robotNFTsToBeClaimed[msg.sender] = robotNFTsToBeClaimed[msg.sender].sub(1);\\n    }\\n  }\\n\\n  function rand(uint256 randomness) private pure returns (uint256 result) {\\n    uint256 factor = (randomness * 100) / 100;\\n    return factor % 100;\\n  }\\n\\n  function claimTickets() public {\\n    require(userTicketCount[msg.sender] > 0, \\\"No tickets to claim\\\");\\n    applyRandomNumberToTickets(msg.sender);\\n  }\\n\\n  function claimTicketsForAddr(address user) public {\\n    require(userTicketCount[user] > 0, \\\"No tickets to claim\\\");\\n    applyRandomNumberToTickets(user);\\n  }\\n\\n  function applyRandomNumberToTickets(address user) internal {\\n    uint256 topStackMem = userTopTicketStack[user];\\n    uint256 ticketCountMem = userTicketCount[user];\\n    for (uint256 i = topStackMem; i < topStackMem.add(ticketCountMem); i++) {\\n      LotteryTicket memory ticket = userTickets[user][i];\\n      uint256 ticketRoundNumber = ticket.roundNumber;\\n\\n      // Can't process active tickets, we need a round result first\\n      if (lotteryRoundCounter == ticketRoundNumber) {\\n        return;\\n      }\\n\\n      uint256 roundResult = lotteryResults[ticketRoundNumber];\\n      if (roundResult <= ticket.levelOneChance) {\\n        _NFTFactory.mint(INFT(_storage._NFTs(1)), ticket.owner, roundResult);\\n      }\\n      if (roundResult <= ticket.levelTwoChance) {\\n        _NFTFactory.mint(INFT(_storage._NFTs(2)), ticket.owner, roundResult);\\n      }\\n      if (roundResult <= ticket.levelThreeChance) {\\n        _NFTFactory.mint(INFT(_storage._NFTs(3)), ticket.owner, roundResult);\\n      }\\n      if (roundResult <= ticket.levelFourChance) {\\n        _NFTFactory.mint(INFT(_storage._NFTs(4)), ticket.owner, roundResult);\\n      }\\n      if (roundResult <= ticket.levelFiveChance) {\\n        _NFTFactory.mint(INFT(_storage._NFTs(5)), ticket.owner, roundResult);\\n      }\\n      // Increment top of user's ticket stack\\n      topStackMem = topStackMem.add(1);\\n      userTopTicketStack[user] = topStackMem;\\n\\n      // Decrement size of user's ticket stack\\n      ticketCountMem = ticketCountMem.sub(1);\\n      userTicketCount[user] = ticketCountMem;\\n\\n      // Delete ticket\\n      delete userTickets[user][i];\\n    }\\n  }\\n\\n  function getUserLotteryLevel(address user) public view returns (uint256) {\\n    uint256 liquidityEthValue = _storage.liquidityContributedEthValue(user);\\n    if (liquidityEthValue < 1e18) {\\n      return 0;\\n    } else if (liquidityEthValue >= 1e18 && liquidityEthValue < 5e18) {\\n      return 1;\\n    } else if (liquidityEthValue >= 5e18 && liquidityEthValue < 10e18) {\\n      return 2;\\n    } else if (liquidityEthValue >= 10e18 && liquidityEthValue < 20e18) {\\n      return 3;\\n    } else if (liquidityEthValue >= 20e18 && liquidityEthValue < 30e18) {\\n      return 4;\\n    } else if (liquidityEthValue >= 30e18 && liquidityEthValue < 40e18) {\\n      return 5;\\n    } else if (liquidityEthValue >= 40e18 && liquidityEthValue < 50e18) {\\n      return 6;\\n    } else if (liquidityEthValue >= 50e18) {\\n      return 7;\\n    }\\n  }\\n\\n  // Generates lottery tickets for users based on their current level and new level\\n  function generateLotteryTickets(address user) internal {\\n    uint256 currentLevel = _storage.lastTicketLevel(user);\\n    uint256 newLevel = getUserLotteryLevel(user);\\n    uint256 endStack = userTopTicketStack[user];\\n    for (uint256 i = currentLevel; i < newLevel; i++) {\\n      LotteryTicket memory ticket;\\n      if (i == 0) {\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 50,\\n          levelTwoChance: 0,\\n          levelThreeChance: 0,\\n          levelFourChance: 0,\\n          levelFiveChance: 0\\n        });\\n      } else if (i == 1) {\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 75,\\n          levelTwoChance: 50,\\n          levelThreeChance: 0,\\n          levelFourChance: 0,\\n          levelFiveChance: 0\\n        });\\n      } else if (i == 2) {\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 100,\\n          levelTwoChance: 75,\\n          levelThreeChance: 50,\\n          levelFourChance: 0,\\n          levelFiveChance: 0\\n        });\\n      } else if (i == 3) {\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 100,\\n          levelTwoChance: 100,\\n          levelThreeChance: 75,\\n          levelFourChance: 50,\\n          levelFiveChance: 0\\n        });\\n      } else if (i == 4) {\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 100,\\n          levelTwoChance: 100,\\n          levelThreeChance: 100,\\n          levelFourChance: 75,\\n          levelFiveChance: 50\\n        });\\n        // Level 6 is an automatic winning ticket at every level except level 5, which is 50%\\n      } else if (i == 5) {\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 100,\\n          levelTwoChance: 100,\\n          levelThreeChance: 100,\\n          levelFourChance: 100,\\n          levelFiveChance: 50\\n        });\\n        // Level 7 is a winning ticket for each level + another winning ticket for levels 1-4\\n      } else if (i == 6) {\\n        // Winning ticket (levels 1-5)\\n        uint256 currUserTicketCount = userTicketCount[user];\\n        uint256 insertAt = endStack.add(currUserTicketCount);\\n        userTickets[user][insertAt] = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 100,\\n          levelTwoChance: 100,\\n          levelThreeChance: 100,\\n          levelFourChance: 100,\\n          levelFiveChance: 100\\n        });\\n        userTicketCount[user] = currUserTicketCount.add(1);\\n\\n        // Winning ticket (levels 1-4)\\n        ticket = LotteryTicket({\\n          owner: user,\\n          roundNumber: lotteryRoundCounter,\\n          levelOneChance: 100,\\n          levelTwoChance: 100,\\n          levelThreeChance: 100,\\n          levelFourChance: 100,\\n          levelFiveChance: 0\\n        });\\n      }\\n\\n      // Add the ticket to the lottery\\n      if (ticket.owner != address(0)) {\\n        uint256 currUserTicketCount = userTicketCount[user];\\n        uint256 insertAt = endStack.add(currUserTicketCount);\\n        userTickets[user][insertAt] = ticket;\\n        userTicketCount[user] = currUserTicketCount.add(1);\\n      }\\n    }\\n\\n    if (newLevel >= 3 && _dXIOTToken.balanceOf(user) >= 20 * 1e18) {\\n      robotNFTsToBeClaimed[user] = robotNFTsToBeClaimed[user].add(1);\\n    }\\n    _storage.setLastTicketLevel(user, newLevel);\\n  }\\n\\n  // Chainlink VRF mainnet functionality will change in the future: dynamic pricing\\n  function updateRngLinkFee(uint256 _rngLinkFee) public onlyOwner {\\n    rngLinkFee = _rngLinkFee;\\n  }\\n\\n  function updateKeyHash(bytes32 _keyHash) public onlyOwner {\\n    keyHash = _keyHash;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n\\n\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\n\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint256;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB)\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        factory,\\n                        keccak256(abi.encodePacked(token0, token1)),\\n                        hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\\n            IUniswapV2Factory(factory).getPair(tokenA, tokenB)\\n        )\\n            .getReserves();\\n        (reserveA, reserveB) = tokenA == token0\\n            ? (reserve0, reserve1)\\n            : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\\n                factory,\\n                path[i],\\n                path[i + 1]\\n            );\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\\n                factory,\\n                path[i - 1],\\n                path[i]\\n            );\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\nimport \\\"../YGYStorageV1.sol\\\";\\n\\ninterface INFT {\\n  function mint(\\n    address _to,\\n    uint256 _randomness,\\n    YGYStorageV1 _storage\\n  ) external returns (uint256);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function _tokenURI() external view returns (string memory);\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n\\n  function name() external view returns (string memory);\\n\\n  function contractId() external view returns (uint256);\\n\\n  function balanceOf(address owner) external view returns (uint256);\\n\\n  function getTokenProperty(uint256 _tokenId) external view returns (YGYStorageV1.NFTProperty memory);\\n}\\n\"\r\n    },\r\n    \"contracts/VRFConsumerBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerInterface, and can\\n * @dev initialize VRFConsumerInterface's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness()\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls fulfillRandomness().\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @notice fulfillRandomness handles the VRF response. Your contract must\\n     * @notice implement it.\\n     *\\n     * @dev The VRFCoordinator expects a calling contract to have a method with\\n     * @dev this signature, and will trigger it once it has verified the proof\\n     * @dev associated with the randomness (It is triggered via a call to\\n     * @dev rawFulfillRandomness, below.)\\n     *\\n     * @param requestId The Id initially returned by requestRandomness\\n     * @param randomness the VRF output\\n     */\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\\n        internal\\n        virtual;\\n\\n    /**\\n     * @notice requestRandomness initiates a request for VRF output given _seed\\n     *\\n     * @dev See \\\"SECURITY CONSIDERATIONS\\\" above for more information on _seed.\\n     *\\n     * @dev The fulfillRandomness method receives the output, once it's provided\\n     * @dev by the Oracle, and verified by the vrfCoordinator.\\n     *\\n     * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n     * @dev the _fee must exceed the fee specified during registration of the\\n     * @dev _keyHash.\\n     *\\n     * @param _keyHash ID of public key against which randomness is generated\\n     * @param _fee The amount of LINK to send with the request\\n     * @param _seed seed mixed into the input of the VRF\\n     *\\n     * @return requestId unique ID for this request\\n     *\\n     * @dev The returned requestId can be used to distinguish responses to *\\n     * @dev concurrent requests. It is passed as the first argument to\\n     * @dev fulfillRandomness.\\n     */\\n    function requestRandomness(\\n        bytes32 _keyHash,\\n        uint256 _fee,\\n        uint256 _seed\\n    ) internal returns (bytes32 requestId) {\\n        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n        // the hash of the block containing this request to obtain the seed/input\\n        // which is finally passed to the VRF cryptographic machinery.\\n        uint256 vRFSeed = makeVRFInputSeed(\\n            _keyHash,\\n            _seed,\\n            address(this),\\n            nonces[_keyHash]\\n        );\\n        // nonces[_keyHash] must stay in sync with\\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n        // This provides protection against the user repeating their input\\n        // seed, which would result in a predictable/duplicate output.\\n        nonces[_keyHash] = nonces[_keyHash].add(1);\\n        return makeRequestId(_keyHash, vRFSeed);\\n    }\\n\\n    LinkTokenInterface internal immutable LINK;\\n    address private immutable vrfCoordinator;\\n\\n    // Nonces for each VRF key from which randomness has been requested.\\n    //\\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\\n    /* keyHash */\\n    /* nonce */\\n    mapping(bytes32 => uint256) public nonces;\\n\\n    constructor(address _vrfCoordinator, address _link) public {\\n        vrfCoordinator = _vrfCoordinator;\\n        LINK = LinkTokenInterface(_link);\\n    }\\n\\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n    // the origin of the call\\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness)\\n        external\\n    {\\n        require(\\n            msg.sender == vrfCoordinator,\\n            \\\"Only VRFCoordinator can fulfill\\\"\\n        );\\n        fulfillRandomness(requestId, randomness);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFTFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"../NFT.sol\\\";\\nimport \\\"./INFT.sol\\\";\\n\\ninterface INFTFactory {\\n    function deployNFT(\\n        string memory name,\\n        string memory symbol,\\n        string memory tokenURI\\n    ) external returns (NFT newContract);\\n\\n    function mint(\\n        INFT _nft,\\n        address recipient,\\n        uint256 _randomness\\n    ) external;\\n\\n    function bondContract(address addr) external returns (bool);\\n\\n    function balanceOf(INFT _nft, address _of) external returns (uint256);\\n\\n    function burn(INFT _nft, uint256 _tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeApprover.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\ninterface IFeeApprover {\\n\\n    function check(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function setFeeMultiplier(uint _feeMultiplier) external;\\n    function feePercentX100() external view returns (uint);\\n\\n    function setTokenUniswapPair(address _tokenUniswapPair) external;\\n\\n    function setRamTokenAddress(address _ramTokenAddress) external;\\n    function setYgyTokenAddress(address _ygyTokenAddress) external;\\n    function sync() external returns (bool lastIsMint, bool lpTokenBurn);\\n    function calculateAmountsAfterFee(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external  returns (uint256 transferToAmount, uint256 transferToFeeBearerAmount);\\n\\n    function setPaused() external;\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAMVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IRAMVault {\\n    function addPendingRewards(uint256 _amount) external;\\n\\n    function depositFor(\\n        address _depositFor,\\n        uint256 _pid,\\n        uint256 _amount\\n    ) external;\\n\\n    function NFTUsage(\\n        address _user,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _poolId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/StorageState.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./YGYStorageV1.sol\\\";\\n\\ncontract StorageState {\\n    YGYStorageV1 _storage;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n  function approve(address spender, uint256 value) external returns (bool success);\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n  function decimals() external view returns (uint8 decimalPlaces);\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n  function name() external view returns (string memory tokenName);\\n  function symbol() external view returns (string memory tokenSymbol);\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n  function transfer(address to, uint256 value) external returns (bool success);\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/VRFRequestIDBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract VRFRequestIDBase {\\n\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\\n    address _requester, uint256 _nonce)\\n    internal pure returns (uint256)\\n  {\\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(\\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/VaultProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nimport \\\"./StorageState.sol\\\";\\n\\ncontract VaultProxy is StorageState {\\n  bytes32 private constant implementationPosition = bytes32(uint256(keccak256(\\\"ygy.proxy.implementation\\\")) - 1);\\n  bytes32 private constant proxyOwnerPosition = bytes32(uint256(keccak256(\\\"ygy.proxy.owner\\\")) - 1);\\n\\n  constructor() public {\\n    _setUpgradeabilityOwner(msg.sender);\\n  }\\n\\n  function setup(address _implementation, YGYStorageV1 __storage) external {\\n    require(msg.sender == proxyOwner());\\n    _setImplementation(_implementation, __storage);\\n  }\\n\\n  function setupOwner(address _newOwner) external {\\n    require(msg.sender == proxyOwner());\\n    _setUpgradeabilityOwner(_newOwner);\\n  }\\n\\n  // setter to set the position of an implementation from the implementation position onwards\\n  function _setImplementation(address _newImplementation, YGYStorageV1 __storage) internal {\\n    require(msg.sender == proxyOwner());\\n    _storage = __storage;\\n    bytes32 position = implementationPosition;\\n\\n    assembly {\\n      sstore(position, _newImplementation)\\n    }\\n  }\\n\\n  // retrieving the address at the implementation position\\n  function implementation() public view returns (address impl) {\\n    bytes32 position = implementationPosition;\\n    assembly {\\n      impl := sload(position)\\n    }\\n  }\\n\\n  function proxyOwner() public view returns (address owner) {\\n    bytes32 position = proxyOwnerPosition;\\n    assembly {\\n      owner := sload(position)\\n    }\\n  }\\n\\n  function _setUpgradeabilityOwner(address _newProxyOwner) private {\\n    bytes32 position = proxyOwnerPosition;\\n    assembly {\\n      sstore(position, _newProxyOwner)\\n    }\\n  }\\n\\n  fallback() external payable {\\n    address addr = implementation();\\n\\n    assembly {\\n      calldatacopy(0, 0, calldatasize())\\n      let result := delegatecall(gas(), addr, 0, calldatasize(), 0, 0)\\n      returndatacopy(0, 0, returndatasize())\\n      switch result\\n        case 0 {\\n          revert(0, returndatasize())\\n        }\\n        default {\\n          return(0, returndatasize())\\n        }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\nimport \\\"./UniswapV2ERC20.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Callee.sol\\\";\\n\\n\\ninterface IMigrator {\\n    // Return the desired amount of liquidity token that the migrator wants.\\n    function desiredLiquidity() external view returns (uint256);\\n}\\n\\ncontract UniswapV2Pair is UniswapV2ERC20 {\\n    using SafeMathUniswap for uint256;\\n    using UQ112x112 for uint224;\\n\\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(\\n        keccak256(bytes(\\\"transfer(address,uint256)\\\"))\\n    );\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n\\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, \\\"UniswapV2: LOCKED\\\");\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(SELECTOR, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"UniswapV2: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    constructor() public {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, \\\"UniswapV2: FORBIDDEN\\\"); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    ) private {\\n        require(\\n            balance0 <= uint112(-1) && balance1 <= uint112(-1),\\n            \\\"UniswapV2: OVERFLOW\\\"\\n        );\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast +=\\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\\n                timeElapsed;\\n            price1CumulativeLast +=\\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\\n                timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\\n        private\\n        returns (bool feeOn)\\n    {\\n        address feeTo = IUniswapV2Factory(factory).feeTo();\\n        feeOn = feeTo != address(0);\\n        uint256 _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\\n                    uint256 liquidity = numerator / denominator;\\n                    if (liquidity > 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external lock returns (uint256 liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20Uniswap(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20Uniswap(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0.sub(_reserve0);\\n        uint256 amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            address migrator = IUniswapV2Factory(factory).migrator();\\n            if (msg.sender == migrator) {\\n                liquidity = IMigrator(migrator).desiredLiquidity();\\n                require(\\n                    liquidity > 0 && liquidity != uint256(-1),\\n                    \\\"Bad desired liquidity\\\"\\n                );\\n            } else {\\n                require(migrator == address(0), \\\"Must not have migrator\\\");\\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(\\n                    MINIMUM_LIQUIDITY\\n                );\\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            }\\n        } else {\\n            liquidity = Math.min(\\n                amount0.mul(_totalSupply) / _reserve0,\\n                amount1.mul(_totalSupply) / _reserve1\\n            );\\n        }\\n        require(liquidity > 0, \\\"UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to)\\n        external\\n        lock\\n        returns (uint256 amount0, uint256 amount1)\\n    {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(\\n            amount0 > 0 && amount1 > 0,\\n            \\\"UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n\\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external lock {\\n        require(\\n            amount0Out > 0 || amount1Out > 0,\\n            \\\"UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n\\n        require(\\n            amount0Out < _reserve0 && amount1Out < _reserve1,\\n            \\\"UniswapV2: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(to != _token0 && to != _token1, \\\"UniswapV2: INVALID_TO\\\");\\n\\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n\\n            if (data.length > 0)\\n                IUniswapV2Callee(to).uniswapV2Call(\\n                    msg.sender,\\n                    amount0Out,\\n                    amount1Out,\\n                    data\\n                );\\n            balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n            balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        }\\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\\n            ? balance0 - (_reserve0 - amount0Out)\\n            : 0;\\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\\n            ? balance1 - (_reserve1 - amount1Out)\\n            : 0;\\n        require(\\n            amount0In > 0 || amount1In > 0,\\n            \\\"UniswapV2: INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n        {\\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n            require(\\n                balance0Adjusted.mul(balance1Adjusted) >=\\n                    uint256(_reserve0).mul(_reserve1).mul(1000**2),\\n                \\\"UniswapV2: K\\\"\\n            );\\n        }\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(\\n            _token0,\\n            to,\\n            IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0)\\n        );\\n        _safeTransfer(\\n            _token1,\\n            to,\\n            IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1)\\n        );\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(\\n            IERC20Uniswap(token0).balanceOf(address(this)),\\n            IERC20Uniswap(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2ERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\n\\ncontract UniswapV2ERC20 {\\n    using SafeMathUniswap for uint256;\\n\\n    string public constant name = \\\" LP Token\\\";\\n    string public constant symbol = \\\"LP\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public nonces;\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    constructor() public {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\\n                value\\n            );\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, \\\"UniswapV2: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"UniswapV2: INVALID_SIGNATURE\\\"\\n        );\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20Uniswap {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Callee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMathUniswap {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal view returns (uint256 z) {\\n        //\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.12;\\n\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './UniswapV2Pair.sol';\\n\\ncontract UniswapV2Factory is IUniswapV2Factory {\\n    address public override feeTo;\\n    address public override feeToSetter;\\n    address public override migrator;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    constructor(address _feeToSetter) public {\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    function allPairsLength() external override view returns (uint) {\\n        return allPairs.length;\\n    }\\n\\n    function pairCodeHash() external pure returns (bytes32) {\\n        return keccak256(type(UniswapV2Pair).creationCode);\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        UniswapV2Pair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setFeeTo(address _feeTo) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeTo = _feeTo;\\n    }\\n\\n    function setMigrator(address _migrator) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        migrator = _migrator;\\n    }\\n\\n    function setFeeToSetter(address _feeToSetter) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NBUNIERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"./interfaces/INBUNIERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/IFeeApprover.sol\\\";\\nimport \\\"./interfaces/IRAMVault.sol\\\";\\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\"; // for WETH\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Factory.sol\\\"; // interface factorys\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Router02.sol\\\"; // interface factorys\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IWETH.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// import \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract NBUNIERC20 is Context, INBUNIERC20, Ownable {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  event LiquidityAddition(address indexed dst, uint256 value);\\n  event LPTokenClaimed(address dst, uint256 value);\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  uint256 public constant tokenCap = 100000e18; // 100k\\n  uint256 public contractStartTimestamp;\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function initialSetup(\\n    address _factory,\\n    address _ygy,\\n    address _treasury\\n  ) internal {\\n    _name = \\\"RAM\\\";\\n    _symbol = \\\"RAM\\\";\\n    _decimals = 18;\\n    _mint(_msgSender(), tokenCap);\\n\\n    contractStartTimestamp = block.timestamp;\\n    uniswapFactory = IUniswapV2Factory(_factory);\\n    createUniswapPair(_ygy);\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n   *\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n   * called.\\n   *\\n   * NOTE: This information is only used for _display_ purposes: it in\\n   * no way affects any of the arithmetic of the contract, including\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\n   */\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-totalSupply}.\\n   */\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-balanceOf}.\\n   */\\n  // function balanceOf(address account) public override returns (uint256) {\\n  //     return _balances[account];\\n  // }\\n  function balanceOf(address _owner) public view override returns (uint256) {\\n    return _balances[_owner];\\n  }\\n\\n  IUniswapV2Factory public uniswapFactory;\\n\\n  address public tokenUniswapPair;\\n\\n  function createUniswapPair(address _YGY) internal {\\n    require(tokenUniswapPair == address(0), \\\"Token: pool already created\\\");\\n    tokenUniswapPair = uniswapFactory.createPair(_YGY, address(this));\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `recipient` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-allowance}.\\n   */\\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-approve}.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {ERC20};\\n   *\\n   * Requirements:\\n   * - `sender` and `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   * - the caller must have allowance for ``sender``'s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n    return true;\\n  }\\n\\n  function setShouldTransferChecker(address _transferCheckerAddress) public onlyOwner {\\n    transferCheckerAddress = _transferCheckerAddress;\\n  }\\n\\n  address public transferCheckerAddress;\\n\\n  function setFeeDistributor(address _feeDistributor) public onlyOwner {\\n    feeDistributor = _feeDistributor;\\n  }\\n\\n  address public feeDistributor;\\n\\n  /**\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\n   *\\n   * This is internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `sender` cannot be the zero address.\\n   * - `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   */\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {\\n    require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n    require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n    _beforeTokenTransfer(sender, recipient, amount);\\n\\n    _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\n    (uint256 transferToAmount, uint256 transferToFeeDistributorAmount) =\\n      IFeeApprover(transferCheckerAddress).calculateAmountsAfterFee(sender, recipient, amount);\\n    //\\n    //\\n\\n    // Addressing a broken checker contract\\n    require(transferToAmount.add(transferToFeeDistributorAmount) == amount, \\\"Math broke, does gravity still work?\\\");\\n\\n    _balances[recipient] = _balances[recipient].add(transferToAmount);\\n    emit Transfer(sender, recipient, transferToAmount);\\n\\n    if (transferToFeeDistributorAmount > 0 && feeDistributor != address(0)) {\\n      _balances[feeDistributor] = _balances[feeDistributor].add(transferToFeeDistributorAmount);\\n      emit Transfer(sender, feeDistributor, transferToFeeDistributorAmount);\\n      if (feeDistributor != address(0)) {\\n        IRAMVault(feeDistributor).addPendingRewards(transferToFeeDistributorAmount);\\n      }\\n    }\\n  }\\n\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n   * the total supply.\\n   *\\n   * Emits a {Transfer} event with `from` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `to` cannot be the zero address.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n   *\\n   * This is internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Sets {decimals} to a value other than the default one of 18.\\n   *\\n   * WARNING: This function should only be called from the constructor. Most\\n   * applications that interact with token contracts will not expect\\n   * {decimals} to ever change, and may work incorrectly if it does.\\n   */\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n   * will be to transferred to `to`.\\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal view {\\n    // if(tokenUniswapPair != address(0)) {\\n    //\\n    // require(from != tokenUniswapPair, \\\"Cannot unwrap liquidity\\\");\\n    // }\\n    if (from == address(0)) {\\n      require(_totalSupply.add(amount) <= tokenCap, \\\"Token cap reached\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/testing/ERC20Preset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\nimport \\\"./ERC20Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC20Preset is Context, AccessControl, ERC20Burnable, ERC20Pausable {\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  /**\\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n   * account that deploys the contract.\\n   *\\n   * See {ERC20-constructor}.\\n   */\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    uint8 decimals\\n  ) public ERC20(name, symbol, decimals) {\\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n    _setupRole(MINTER_ROLE, _msgSender());\\n    _setupRole(PAUSER_ROLE, _msgSender());\\n  }\\n\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   *\\n   * See {ERC20-_mint}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `MINTER_ROLE`.\\n   */\\n  function mint(address to, uint256 amount) public virtual {\\n    require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have minter role to mint\\\");\\n    _mint(to, amount);\\n  }\\n\\n  /**\\n   * @dev Pauses all token transfers.\\n   *\\n   * See {ERC20Pausable} and {Pausable-_pause}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `PAUSER_ROLE`.\\n   */\\n  function pause() public virtual {\\n    require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to pause\\\");\\n    _pause();\\n  }\\n\\n  /**\\n   * @dev Unpauses all token transfers.\\n   *\\n   * See {ERC20Pausable} and {Pausable-_unpause}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `PAUSER_ROLE`.\\n   */\\n  function unpause() public virtual {\\n    require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to unpause\\\");\\n    _unpause();\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20, ERC20Pausable) {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals\\n    ) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/testing/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/ERC20Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20Pausable is ERC20, Pausable {\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/YGY.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20Preset.sol\\\";\\n\\ncontract YGY is ERC20Preset {\\n  constructor(uint256 _initialSupply) public ERC20Preset(\\\"YGY\\\", \\\"YGY\\\", 6) {\\n    _mint(msg.sender, _initialSupply);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../utils/Pausable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20Pausable is ERC20, Pausable {\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"../token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"../token/ERC20/ERC20Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC20PresetMinterPauser is Context, AccessControl, ERC20Burnable, ERC20Pausable {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * See {ERC20-constructor}.\\n     */\\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have minter role to mint\\\");\\n        _mint(to, amount);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/dXIOT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\\\";\\n\\ncontract dXIOT is ERC20PresetMinterPauser {\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _initialSupply\\n    ) public ERC20PresetMinterPauser(_name, _symbol) {\\n        _mint(msg.sender, _initialSupply);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/ChainLinkToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IReceiverMock.sol\\\";\\nimport \\\"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\\\";\\n\\ncontract ChainLinkToken is ERC20PresetMinterPauser {\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _initialSupply\\n    ) public ERC20PresetMinterPauser(_name, _symbol) {\\n        _mint(msg.sender, _initialSupply);\\n    }\\n\\n    /**\\n     * @dev transfer token to a contract address with additional data if the recipient is a contact.\\n     * @param _to The address to transfer to.\\n     * @param _value The amount to be transferred.\\n     * @param _data The extra data to be passed to the receiving contract.\\n     */\\n    function transferAndCall(\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data\\n    ) public returns (bool success) {\\n        super.transfer(_to, _value);\\n        if (isContract(_to)) {\\n            contractFallback(_to, _value, _data);\\n        }\\n        return true;\\n    }\\n\\n    // PRIVATE\\n\\n    function contractFallback(\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data\\n    ) private {\\n        IReceiverMock receiver = IReceiverMock(_to);\\n        receiver.onTokenTransfer(msg.sender, _value, _data);\\n    }\\n\\n    function isContract(address _addr) private view returns (bool hasCode) {\\n        uint256 length;\\n        assembly {\\n            length := extcodesize(_addr)\\n        }\\n        return length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/IReceiverMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IReceiverMock {\\n    function onTokenTransfer(\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"./interfaces/IUniswapV2Router02.sol\\\";\\n\\nimport \\\"./libraries/UniswapV2Library.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\ncontract UniswapV2Router02 is IUniswapV2Router02 {\\n    using SafeMathUniswap for uint256;\\n\\n    address public immutable override factory;\\n    address public immutable override WETH;\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, \\\"UniswapV2Router: EXPIRED\\\");\\n        _;\\n    }\\n\\n    constructor(address _factory, address _WETH) public {\\n        factory = _factory;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\\n        // create the pair if it doesn't exist yet\\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\\n        }\\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(\\n            factory,\\n            tokenA,\\n            tokenB\\n        );\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = UniswapV2Library.quote(\\n                amountADesired,\\n                reserveA,\\n                reserveB\\n            );\\n            if (amountBOptimal <= amountBDesired) {\\n                require(\\n                    amountBOptimal >= amountBMin,\\n                    \\\"UniswapV2Router: INSUFFICIENT_B_AMOUNT\\\"\\n                );\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = UniswapV2Library.quote(\\n                    amountBDesired,\\n                    reserveB,\\n                    reserveA\\n                );\\n                assert(amountAOptimal <= amountADesired);\\n                require(\\n                    amountAOptimal >= amountAMin,\\n                    \\\"UniswapV2Router: INSUFFICIENT_A_AMOUNT\\\"\\n                );\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountA, amountB) = _addLiquidity(\\n            tokenA,\\n            tokenB,\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin\\n        );\\n        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n        liquidity = IUniswapV2Pair(pair).mint(to);\\n    }\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        )\\n    {\\n        (amountToken, amountETH) = _addLiquidity(\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = IUniswapV2Factory(factory).getPair(token, WETH);\\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(pair, amountETH));\\n        liquidity = IUniswapV2Pair(pair).mint(to);\\n        // refund dust eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    // **** REMOVE LIQUIDITY ****\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        public\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256 amountA, uint256 amountB)\\n    {\\n        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);\\n        (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0\\n            ? (amount0, amount1)\\n            : (amount1, amount0);\\n        require(\\n            amountA >= amountAMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_A_AMOUNT\\\"\\n        );\\n        require(\\n            amountB >= amountBMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_B_AMOUNT\\\"\\n        );\\n    }\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        public\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256 amountToken, uint256 amountETH)\\n    {\\n        (amountToken, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, amountToken);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountA, uint256 amountB) {\\n        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IUniswapV2Pair(pair).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n        (amountA, amountB) = removeLiquidity(\\n            tokenA,\\n            tokenB,\\n            liquidity,\\n            amountAMin,\\n            amountBMin,\\n            to,\\n            deadline\\n        );\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n        virtual\\n        override\\n        returns (uint256 amountToken, uint256 amountETH)\\n    {\\n        address pair = IUniswapV2Factory(factory).getPair(token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IUniswapV2Pair(pair).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n        (amountToken, amountETH) = removeLiquidityETH(\\n            token,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            to,\\n            deadline\\n        );\\n    }\\n\\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) public virtual override ensure(deadline) returns (uint256 amountETH) {\\n        (, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(\\n            token,\\n            to,\\n            IERC20Uniswap(token).balanceOf(address(this))\\n        );\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override returns (uint256 amountETH) {\\n        address pair = IUniswapV2Factory(factory).getPair(token, WETH);\\n        uint256 value = approveMax ? uint256(-1) : liquidity;\\n        IUniswapV2Pair(pair).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n            token,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            to,\\n            deadline\\n        );\\n    }\\n\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory path,\\n        address _to\\n    ) internal virtual {\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\\n            uint256 amountOut = amounts[i + 1];\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint256(0), amountOut)\\n                : (amountOut, uint256(0));\\n            address to = i < path.length - 2\\n                ? UniswapV2Library.pairFor(factory, output, path[i + 2])\\n                : _to;\\n            IUniswapV2Pair(IUniswapV2Factory(factory).getPair(input, output))\\n                .swap(amount0Out, amount1Out, to, new bytes(0));\\n        }\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n        require(\\n            amounts[amounts.length - 1] >= amountOutMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n        require(\\n            amounts[0] <= amountInMax,\\n            \\\"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(path[0] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\\n        require(\\n            amounts[amounts.length - 1] >= amountOutMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(\\n            IWETH(WETH).transfer(\\n                IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n                amounts[0]\\n            )\\n        );\\n        _swap(amounts, path, to);\\n    }\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(path[path.length - 1] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n        require(\\n            amounts[0] <= amountInMax,\\n            \\\"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(path[path.length - 1] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n        require(\\n            amounts[amounts.length - 1] >= amountOutMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n            amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (uint256[] memory amounts)\\n    {\\n        require(path[0] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n        require(\\n            amounts[0] <= msg.value,\\n            \\\"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(\\n            IWETH(WETH).transfer(\\n                IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n                amounts[0]\\n            )\\n        );\\n        _swap(amounts, path, to);\\n        // refund dust eth, if any\\n        if (msg.value > amounts[0])\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swapSupportingFeeOnTransferTokens(\\n        address[] memory path,\\n        address _to\\n    ) internal virtual {\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\\n            IUniswapV2Pair pair = IUniswapV2Pair(\\n                IUniswapV2Factory(factory).getPair(input, output)\\n            );\\n            uint256 amountInput;\\n            uint256 amountOutput;\\n            {\\n                // scope to avoid stack too deep errors\\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\\n                    ? (reserve0, reserve1)\\n                    : (reserve1, reserve0);\\n                amountInput = IERC20Uniswap(input).balanceOf(address(pair)).sub(\\n                    reserveInput\\n                );\\n                amountOutput = UniswapV2Library.getAmountOut(\\n                    amountInput,\\n                    reserveInput,\\n                    reserveOutput\\n                );\\n            }\\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\\n                ? (uint256(0), amountOutput)\\n                : (amountOutput, uint256(0));\\n            address to = i < path.length - 2\\n                ? UniswapV2Library.pairFor(factory, output, path[i + 2])\\n                : _to;\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n        }\\n    }\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) {\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n            amountIn\\n        );\\n        uint256 balanceBefore = IERC20Uniswap(path[path.length - 1]).balanceOf(\\n            to\\n        );\\n        _swapSupportingFeeOnTransferTokens(path, to);\\n        require(\\n            IERC20Uniswap(path[path.length - 1]).balanceOf(to).sub(\\n                balanceBefore\\n            ) >= amountOutMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n    }\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override payable ensure(deadline) {\\n        require(path[0] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n        uint256 amountIn = msg.value;\\n        IWETH(WETH).deposit{value: amountIn}();\\n        assert(\\n            IWETH(WETH).transfer(\\n                IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n                amountIn\\n            )\\n        );\\n        uint256 balanceBefore = IERC20Uniswap(path[path.length - 1]).balanceOf(\\n            to\\n        );\\n        _swapSupportingFeeOnTransferTokens(path, to);\\n        require(\\n            IERC20Uniswap(path[path.length - 1]).balanceOf(to).sub(\\n                balanceBefore\\n            ) >= amountOutMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n    }\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) {\\n        require(path[path.length - 1] == WETH, \\\"UniswapV2Router: INVALID_PATH\\\");\\n        TransferHelper.safeTransferFrom(\\n            path[0],\\n            msg.sender,\\n            IUniswapV2Factory(factory).getPair(path[0], path[1]),\\n            amountIn\\n        );\\n        _swapSupportingFeeOnTransferTokens(path, address(this));\\n        uint256 amountOut = IERC20Uniswap(WETH).balanceOf(address(this));\\n        require(\\n            amountOut >= amountOutMin,\\n            \\\"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(to, amountOut);\\n    }\\n\\n    // **** LIBRARY FUNCTIONS ****\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) public virtual override pure returns (uint256 amountB) {\\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) public virtual override pure returns (uint256 amountOut) {\\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\\n    }\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) public virtual override pure returns (uint256 amountIn) {\\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\\n    }\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        public\\n        virtual\\n        override\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n    }\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\n        public\\n        virtual\\n        override\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/VRFCoordinator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/VRFRequestIDBase.sol\\\";\\nimport \\\"./VRF.sol\\\";\\nimport \\\"../VRFConsumerBase.sol\\\";\\n\\n\\ninterface BlockHashStoreInterface {\\n    function getBlockhash(uint256 number) external view returns (bytes32);\\n}\\n\\n/**\\n * @title VRFCoordinator coordinates on-chain verifiable-randomness requests\\n * @title with off-chain responses\\n */\\ncontract VRFCoordinator is VRF, VRFRequestIDBase {\\n    using SafeMath for uint256;\\n\\n    LinkTokenInterface internal LINK;\\n    BlockHashStoreInterface internal blockHashStore;\\n\\n    constructor(address _link, address _blockHashStore) public {\\n        LINK = LinkTokenInterface(_link);\\n        blockHashStore = BlockHashStoreInterface(_blockHashStore);\\n    }\\n\\n    struct Callback {\\n        // Tracks an ongoing request\\n        address callbackContract; // Requesting contract, which will receive response\\n        // Amount of LINK paid at request time. Total LINK = 1e9 * 1e18 < 2^96, so\\n        // this representation is adequate, and saves a word of storage when this\\n        // field follows the 160-bit callbackContract address.\\n        uint96 randomnessFee;\\n        // Commitment to seed passed to oracle by this contract, and the number of\\n        // the block in which the request appeared. This is the keccak256 of the\\n        // concatenation of those values. Storing this commitment saves a word of\\n        // storage.\\n        bytes32 seedAndBlockNum;\\n    }\\n\\n    struct ServiceAgreement {\\n        // Tracks oracle commitments to VRF service\\n        address vRFOracle; // Oracle committing to respond with VRF service\\n        uint96 fee; // Minimum payment for oracle response. Total LINK=1e9*1e18<2^96\\n        bytes32 jobID; // ID of corresponding chainlink job in oracle's DB\\n    }\\n\\n    /* (provingKey, seed) */\\n    mapping(bytes32 => Callback) public callbacks;\\n    /* provingKey */\\n    mapping(bytes32 => ServiceAgreement) public serviceAgreements;\\n    /* oracle */\\n    /* LINK balance */\\n    mapping(address => uint256) public withdrawableTokens;\\n    /* provingKey */\\n    /* consumer */\\n    mapping(bytes32 => mapping(address => uint256)) private nonces;\\n\\n    // The oracle only needs the jobID to look up the VRF, but specifying public\\n    // key as well prevents a malicious oracle from inducing VRF outputs from\\n    // another oracle by reusing the jobID.\\n    event RandomnessRequest(\\n        bytes32 keyHash,\\n        uint256 seed,\\n        bytes32 indexed jobID,\\n        address sender,\\n        uint256 fee,\\n        bytes32 requestID\\n    );\\n\\n    event NewServiceAgreement(bytes32 keyHash, uint256 fee);\\n\\n    event RandomnessRequestFulfilled(bytes32 requestId, uint256 output);\\n\\n    /**\\n     * @notice Commits calling address to serve randomness\\n     * @param _fee minimum LINK payment required to serve randomness\\n     * @param _oracle the address of the Chainlink node with the proving key and job\\n     * @param _publicProvingKey public key used to prove randomness\\n     * @param _jobID ID of the corresponding chainlink job in the oracle's db\\n     */\\n    function registerProvingKey(\\n        uint256 _fee,\\n        address _oracle,\\n        uint256[2] calldata _publicProvingKey,\\n        bytes32 _jobID\\n    ) external {\\n        bytes32 keyHash = hashOfKey(_publicProvingKey);\\n        address oldVRFOracle = serviceAgreements[keyHash].vRFOracle;\\n        require(oldVRFOracle == address(0), \\\"please register a new key\\\");\\n        require(_oracle != address(0), \\\"_oracle must not be 0x0\\\");\\n        serviceAgreements[keyHash].vRFOracle = _oracle;\\n        serviceAgreements[keyHash].jobID = _jobID;\\n        // Yes, this revert message doesn't fit in a word\\n        require(\\n            _fee <= 1e9 ether,\\n            \\\"you can't charge more than all the LINK in the world, greedy\\\"\\n        );\\n        serviceAgreements[keyHash].fee = uint96(_fee);\\n        emit NewServiceAgreement(keyHash, _fee);\\n    }\\n\\n    /**\\n     * @notice Called by LINK.transferAndCall, on successful LINK transfer\\n     *\\n     * @dev To invoke this, use the requestRandomness method in VRFConsumerBase.\\n     *\\n     * @dev The VRFCoordinator will call back to the calling contract when the\\n     * @dev oracle responds, on the method fulfillRandomness. See\\n     * @dev VRFConsumerBase.fulfilRandomness for its signature. Your consuming\\n     * @dev contract should inherit from VRFConsumerBase, and implement\\n     * @dev fulfilRandomness.\\n     *\\n     * @param _sender address: who sent the LINK (must be a contract)\\n     * @param _fee amount of LINK sent\\n     * @param _data abi-encoded call to randomnessRequest\\n     */\\n    function onTokenTransfer(\\n        address _sender,\\n        uint256 _fee,\\n        bytes memory _data\\n    ) public onlyLINK {\\n        (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\\n        randomnessRequest(keyHash, seed, _fee, _sender);\\n    }\\n\\n    /**\\n     * @notice creates the chainlink request for randomness\\n     *\\n     * @param _keyHash ID of the VRF public key against which to generate output\\n     * @param _consumerSeed Input to the VRF, from which randomness is generated\\n     * @param _feePaid Amount of LINK sent with request. Must exceed fee for key\\n     * @param _sender Requesting contract; to be called back with VRF output\\n     *\\n     * @dev _consumerSeed is mixed with key hash, sender address and nonce to\\n     * @dev obtain preSeed, which is passed to VRF oracle, which mixes it with the\\n     * @dev hash of the block containing this request, to compute the final seed.\\n     *\\n     * @dev The requestId used to store the request data is constructed from the\\n     * @dev preSeed and keyHash.\\n     */\\n    function randomnessRequest(\\n        bytes32 _keyHash,\\n        uint256 _consumerSeed,\\n        uint256 _feePaid,\\n        address _sender\\n    ) internal sufficientLINK(_feePaid, _keyHash) {\\n        uint256 nonce = nonces[_keyHash][_sender];\\n        uint256 preSeed = makeVRFInputSeed(\\n            _keyHash,\\n            _consumerSeed,\\n            _sender,\\n            nonce\\n        );\\n        bytes32 requestId = makeRequestId(_keyHash, preSeed);\\n\\n        // Cryptographically guaranteed by preSeed including an increasing nonce\\n        assert(callbacks[requestId].callbackContract == address(0));\\n        callbacks[requestId].callbackContract = _sender;\\n        fulfillRandomnessRequest(\\n            requestId,\\n            uint256(blockhash(block.number - 1))\\n        );\\n    }\\n\\n    // Offsets into fulfillRandomnessRequest's _proof of various values\\n    //\\n    // Public key. Skips byte array's length prefix.\\n    uint256 public constant PUBLIC_KEY_OFFSET = 0x20;\\n    // Seed is 7th word in proof, plus word for length, (6+1)*0x20=0xe0\\n    uint256 public constant PRESEED_OFFSET = 0xe0;\\n\\n    /**\\n     *\\n     * @dev The structure of _proof corresponds to vrf.MarshaledOnChainResponse,\\n     * @dev in the node source code. I.e., it is a vrf.MarshaledProof with the\\n     * @dev seed replaced by the preSeed, followed by the hash of the requesting\\n     * @dev block.\\n     */\\n    function fulfillRandomnessRequest(bytes32 requestId, uint256 randomness)\\n        public\\n    {\\n        // Forget request. Must precede callback (prevents reentrancy)\\n        callBackWithRandomness(\\n            requestId,\\n            randomness,\\n            callbacks[requestId].callbackContract\\n        );\\n\\n        emit RandomnessRequestFulfilled(requestId, randomness);\\n    }\\n\\n    function callBackWithRandomness(\\n        bytes32 requestId,\\n        uint256 randomness,\\n        address consumerContract\\n    ) internal {\\n        // Dummy variable; allows access to method selector in next line. See\\n        // https://github.com/ethereum/solidity/issues/3506#issuecomment-553727797\\n        VRFConsumerBase v;\\n        bytes memory resp = abi.encodeWithSelector(\\n            v.rawFulfillRandomness.selector,\\n            requestId,\\n            randomness\\n        );\\n        // The bound b here comes from https://eips.ethereum.org/EIPS/eip-150. The\\n        // actual gas available to the consuming contract will be b-floor(b/64).\\n        // This is chosen to leave the consuming contract ~200k gas, after the cost\\n        // of the call itself.\\n        uint256 b = 206000;\\n        require(gasleft() >= b, \\\"not enough gas for consumer\\\");\\n        // A low-level call is necessary, here, because we don't want the consuming\\n        // contract to be able to revert this execution, and thus deny the oracle\\n        // payment for a valid randomness response. This also necessitates the above\\n        // check on the gasleft, as otherwise there would be no indication if the\\n        // callback method ran out of gas.\\n        //\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = consumerContract.call(resp);\\n        // Avoid unused-local-variable warning. (success is only present to prevent\\n        // a warning that the return value of consumerContract.call is unused.)\\n        (success);\\n    }\\n\\n    function getRandomnessFromProof(bytes memory _proof)\\n        internal\\n        view\\n        returns (\\n            bytes32 currentKeyHash,\\n            Callback memory callback,\\n            bytes32 requestId,\\n            uint256 randomness\\n        )\\n    {\\n        // blockNum follows proof, which follows length word (only direct-number\\n        // constants are allowed in assembly, so have to compute this in code)\\n        uint256 BLOCKNUM_OFFSET = 0x20 + PROOF_LENGTH;\\n        // _proof.length skips the initial length word, so not including the\\n        // blocknum in this length check balances out.\\n        uint256[2] memory publicKey;\\n        uint256 preSeed;\\n        uint256 blockNum;\\n        assembly {\\n            // solhint-disable-line no-inline-assembly\\n            publicKey := add(_proof, PUBLIC_KEY_OFFSET)\\n            preSeed := mload(add(_proof, PRESEED_OFFSET))\\n            blockNum := mload(add(_proof, BLOCKNUM_OFFSET))\\n        }\\n        currentKeyHash = hashOfKey(publicKey);\\n        requestId = makeRequestId(currentKeyHash, preSeed);\\n        callback = callbacks[requestId];\\n        require(\\n            callback.callbackContract != address(0),\\n            \\\"no corresponding request\\\"\\n        );\\n        require(\\n            callback.seedAndBlockNum ==\\n                keccak256(abi.encodePacked(preSeed, blockNum)),\\n            \\\"wrong preSeed or block num\\\"\\n        );\\n\\n        bytes32 blockHash = blockhash(blockNum);\\n        if (blockHash == bytes32(0)) {\\n            blockHash = blockHashStore.getBlockhash(blockNum);\\n            require(blockHash != bytes32(0), \\\"please prove blockhash\\\");\\n        }\\n        // The seed actually used by the VRF machinery, mixing in the blockhash\\n        uint256 actualSeed = uint256(\\n            keccak256(abi.encodePacked(preSeed, blockHash))\\n        );\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Construct the actual proof from the remains of _proof\\n            mstore(add(_proof, PRESEED_OFFSET), actualSeed)\\n            mstore(_proof, PROOF_LENGTH)\\n        }\\n        randomness = VRF.randomValueFromVRFProof(_proof); // Reverts on failure\\n    }\\n\\n    /**\\n     * @dev Allows the oracle operator to withdraw their LINK\\n     * @param _recipient is the address the funds will be sent to\\n     * @param _amount is the amount of LINK transferred from the Coordinator contract\\n     */\\n    function withdraw(address _recipient, uint256 _amount)\\n        external\\n        hasAvailableFunds(_amount)\\n    {\\n        withdrawableTokens[msg.sender] = withdrawableTokens[msg.sender].sub(\\n            _amount\\n        );\\n        assert(LINK.transfer(_recipient, _amount));\\n    }\\n\\n    /**\\n     * @notice Returns the serviceAgreements key associated with this public key\\n     * @param _publicKey the key to return the address for\\n     */\\n    function hashOfKey(uint256[2] memory _publicKey)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(_publicKey));\\n    }\\n\\n    /**\\n     * @dev Reverts if amount is not at least what was agreed upon in the service agreement\\n     * @param _feePaid The payment for the request\\n     * @param _keyHash The key which the request is for\\n     */\\n    modifier sufficientLINK(uint256 _feePaid, bytes32 _keyHash) {\\n        require(\\n            _feePaid >= serviceAgreements[_keyHash].fee,\\n            \\\"Below agreed payment\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if not sent from the LINK token\\n     */\\n    modifier onlyLINK() {\\n        require(msg.sender == address(LINK), \\\"Must use LINK token\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if amount requested is greater than withdrawable balance\\n     * @param _amount The given amount to compare to `withdrawableTokens`\\n     */\\n    modifier hasAvailableFunds(uint256 _amount) {\\n        require(\\n            withdrawableTokens[msg.sender] >= _amount,\\n            \\\"can't withdraw more than balance\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/VRF.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/** ****************************************************************************\\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\\n\\n  * @dev Bibliographic references:\\n\\n  * @dev Goldberg, et al., \\\"Verifiable Random Functions (VRFs)\\\", Internet Draft\\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\\n\\n  * @dev Papadopoulos, et al., \\\"Making NSEC5 Practical for DNSSEC\\\", Cryptology\\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\\n  * ****************************************************************************\\n  * @dev USAGE\\n\\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\\n  * ****************************************************************************\\n  * @dev PURPOSE\\n\\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\\n  * @dev Reggie, he gives back a value which is computed completely\\n  * @dev deterministically from the seed and the secret key.\\n\\n  * @dev Reggie provides a proof by which Vera can verify that the output was\\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\\n  * @dev the output is computationally indistinguishable to her from a uniform\\n  * @dev random sample from the output space.\\n\\n  * @dev The purpose of this contract is to perform that verification.\\n  * ****************************************************************************\\n  * @dev DESIGN NOTES\\n\\n  * @dev The VRF algorithm verified here satisfies the full unqiqueness, full\\n  * @dev collision resistance, and full pseudorandomness security properties.\\n  * @dev See \\\"SECURITY PROPERTIES\\\" below, and\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\\n\\n  * @dev An elliptic curve point is generally represented in the solidity code\\n  * @dev as a uint256[2], corresponding to its affine coordinates in\\n  * @dev GF(FIELD_SIZE).\\n\\n  * @dev For the sake of efficiency, this implementation deviates from the spec\\n  * @dev in some minor ways:\\n\\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\\n\\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\\n\\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\\n  * @dev   nonce updated until a valid x-ordinate is found.\\n\\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\\n  * @dev   in the hash message, as recommended in step 5.B of the draft\\n  * @dev   standard. They are unnecessary here because no variation in the\\n  * @dev   cipher suite is allowed.\\n\\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\\n  * @dev   points, not the compressed points as recommended in step 3.\\n\\n  * @dev - In the calculation of the challenge value \\\"c\\\", the \\\"u\\\" value (i.e.\\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\\n  * @dev   generator point, see steps 5 and 7 of\\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\\n  * @dev   keccak hash of the original u. This is because we only verify the\\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\\n  * ****************************************************************************\\n  * @dev   SECURITY PROPERTIES\\n\\n  * @dev Here are the security properties for this VRF:\\n\\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\\n  * @dev   the sense that the proof will pass verifyVRFProof.\\n\\n  * @dev Full collision resistance: It's cryptographically infeasible to find\\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\\n\\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\\n  * @dev   derived from a given seed, the outputs are computationally\\n  * @dev   indistinguishable from randomness.\\n\\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\\n  * @dev for these properties.\\n\\n  * @dev For secp256k1, the key validation described in section\\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\\n  * @dev representation of the public key used here (affine x- and y-ordinates\\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\\n  * @dev the point at infinity.\\n  * ****************************************************************************\\n  * @dev OTHER SECURITY CONSIDERATIONS\\n  *\\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\\n  * @dev However, under the Random Oracle Model the probability of choosing a\\n  * @dev point which forces n extra rounds in hashToCurve is 2⁻ⁿ. The base cost\\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\\n  * @dev try, in expectation, about 2¹²⁸ seeds, which is infeasible for any\\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\\n\\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\\n  * @dev this means it is infeasible for an adversary to prevent correct\\n  * @dev operation of this contract by choosing an adverse seed.\\n\\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\\n  * @dev hashToCurve.)\\n\\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\\n  * @dev See notes in hashToCurve docstring.\\n*/\\ncontract VRF {\\n    // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\\n    uint256\\n        private constant GROUP_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141; // solium-disable-next-line indentation // Number of points in Secp256k1\\n    // Prime characteristic of the galois field over which Secp256k1 is defined\\n    uint256\\n        private constant FIELD_SIZE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F; // solium-disable-next-line indentation\\n    uint256 private constant WORD_LENGTH_BYTES = 0x20;\\n\\n    // (base^exponent) % FIELD_SIZE\\n    // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\\n    function bigModExp(uint256 base, uint256 exponent)\\n        internal\\n        view\\n        returns (uint256 exponentiation)\\n    {\\n        uint256 callResult;\\n        uint256[6] memory bigModExpContractInputs;\\n        bigModExpContractInputs[0] = WORD_LENGTH_BYTES; // Length of base\\n        bigModExpContractInputs[1] = WORD_LENGTH_BYTES; // Length of exponent\\n        bigModExpContractInputs[2] = WORD_LENGTH_BYTES; // Length of modulus\\n        bigModExpContractInputs[3] = base;\\n        bigModExpContractInputs[4] = exponent;\\n        bigModExpContractInputs[5] = FIELD_SIZE;\\n        uint256[1] memory output;\\n        assembly {\\n            // solhint-disable-line no-inline-assembly\\n            callResult := staticcall(\\n                not(0), // Gas cost: no limit\\n                0x05, // Bigmodexp contract address\\n                bigModExpContractInputs,\\n                0xc0, // Length of input segment: 6*0x20-bytes\\n                output,\\n                0x20 // Length of output segment\\n            )\\n        }\\n        if (callResult == 0) {\\n            revert(\\\"bigModExp failure!\\\");\\n        }\\n        return output[0];\\n    }\\n\\n    // Let q=FIELD_SIZE. q % 4 = 3, ∴ x≡r^2 mod q ⇒ x^SQRT_POWER≡±r mod q.  See\\n    // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\\n    uint256 private constant SQRT_POWER = (FIELD_SIZE + 1) >> 2;\\n\\n    // Computes a s.t. a^2 = x in the field. Assumes a exists\\n    function squareRoot(uint256 x) internal view returns (uint256) {\\n        return bigModExp(x, SQRT_POWER);\\n    }\\n\\n    // The value of y^2 given that (x,y) is on secp256k1.\\n    function ySquared(uint256 x) internal pure returns (uint256) {\\n        // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\\n        uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\\n        return addmod(xCubed, 7, FIELD_SIZE);\\n    }\\n\\n    // True iff p is on secp256k1\\n    function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\\n        return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\\n    }\\n\\n    // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\\n    function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\\n        x_ = uint256(keccak256(b));\\n        // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\\n        // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\\n        // string_to_point in the IETF draft\\n        while (x_ >= FIELD_SIZE) {\\n            x_ = uint256(keccak256(abi.encodePacked(x_)));\\n        }\\n    }\\n\\n    // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\\n    // is always even, due to\\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\\n    // step 5.C, which references arbitrary_string_to_point, defined in\\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\\n    // returning the point with given x ordinate, and even y ordinate.\\n    function newCandidateSecp256k1Point(bytes memory b)\\n        internal\\n        view\\n        returns (uint256[2] memory p)\\n    {\\n        p[0] = fieldHash(b);\\n        p[1] = squareRoot(ySquared(p[0]));\\n        if (p[1] % 2 == 1) {\\n            p[1] = FIELD_SIZE - p[1];\\n        }\\n    }\\n\\n    // Domain-separation tag for initial hash in hashToCurve. Corresponds to\\n    // vrf.go/hashToCurveHashPrefix\\n    uint256 constant HASH_TO_CURVE_HASH_PREFIX = 1;\\n\\n    // Cryptographic hash function onto the curve.\\n    //\\n    // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\\n    // DESIGN NOTES above for slight differences.)\\n    //\\n    // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\\n    // \\\"Construction of Rational Points on Elliptic Curves over Finite Fields\\\"\\n    // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\\n    // and suggested by\\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\\n    // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\\n    //\\n    // This would greatly simplify the analysis in \\\"OTHER SECURITY CONSIDERATIONS\\\"\\n    // https://www.pivotaltracker.com/story/show/171120900\\n    function hashToCurve(uint256[2] memory pk, uint256 input)\\n        internal\\n        view\\n        returns (uint256[2] memory rv)\\n    {\\n        rv = newCandidateSecp256k1Point(\\n            abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX, pk, input)\\n        );\\n        while (!isOnCurve(rv)) {\\n            rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\\n        }\\n    }\\n\\n    /** *********************************************************************\\n     * @notice Check that product==scalar*multiplicand\\n     *\\n     * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\\n     *\\n     * @param multiplicand: secp256k1 point\\n     * @param scalar: non-zero GF(GROUP_ORDER) scalar\\n     * @param product: secp256k1 expected to be multiplier * multiplicand\\n     * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\\n     */\\n    function ecmulVerify(\\n        uint256[2] memory multiplicand,\\n        uint256 scalar,\\n        uint256[2] memory product\\n    ) internal pure returns (bool verifies) {\\n        require(scalar != 0); // Rules out an ecrecover failure case\\n        uint256 x = multiplicand[0]; // x ordinate of multiplicand\\n        uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\\n        // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n        // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\\n        // (x⁻¹ mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\\n        // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\\n        bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\\n        address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\\n        // Explicit conversion to address takes bottom 160 bits\\n        address expected = address(\\n            uint256(keccak256(abi.encodePacked(product)))\\n        );\\n        return (actual == expected);\\n    }\\n\\n    // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P¹(𝔽ₙ)\\n    function projectiveSub(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    ) internal pure returns (uint256 x3, uint256 z3) {\\n        uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\\n        uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\\n        (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n    }\\n\\n    // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P¹(𝔽ₙ)\\n    function projectiveMul(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    ) internal pure returns (uint256 x3, uint256 z3) {\\n        (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\\n    }\\n\\n    /** **************************************************************************\\n      @notice Computes elliptic-curve sum, in projective co-ordinates\\n\\n      @dev Using projective coordinates avoids costly divisions\\n\\n      @dev To use this with p and q in affine coordinates, call\\n      @dev projectiveECAdd(px, py, qx, qy). This will return\\n      @dev the addition of (px, py, 1) and (qx, qy, 1), in the\\n      @dev secp256k1 group.\\n\\n      @dev This can be used to calculate the z which is the inverse to zInv\\n      @dev in isValidVRFOutput. But consider using a faster\\n      @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\\n\\n      @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\\n           coordinates of secp256k1 points. That is safe in this contract,\\n           because this method is only used by linearCombination, which checks\\n           points are on the curve via ecrecover.\\n      **************************************************************************\\n      @param px The first affine coordinate of the first summand\\n      @param py The second affine coordinate of the first summand\\n      @param qx The first affine coordinate of the second summand\\n      @param qy The second affine coordinate of the second summand\\n\\n      (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\\n      **************************************************************************\\n      Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\\n      on secp256k1, in P²(𝔽ₙ)\\n      @return sx\\n      @return sy\\n      @return sz\\n  */\\n    function projectiveECAdd(\\n        uint256 px,\\n        uint256 py,\\n        uint256 qx,\\n        uint256 qy\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 sx,\\n            uint256 sy,\\n            uint256 sz\\n        )\\n    {\\n        // See \\\"Group law for E/K : y^2 = x^3 + ax + b\\\", in section 3.1.2, p. 80,\\n        // \\\"Guide to Elliptic Curve Cryptography\\\" by Hankerson, Menezes and Vanstone\\n        // We take the equations there for (sx,sy), and homogenize them to\\n        // projective coordinates. That way, no inverses are required, here, and we\\n        // only need the one inverse in affineECAdd.\\n\\n        // We only need the \\\"point addition\\\" equations from Hankerson et al. Can\\n        // skip the \\\"point doubling\\\" equations because p1 == p2 is cryptographically\\n        // impossible, and require'd not to be the case in linearCombination.\\n\\n        // Add extra \\\"projective coordinate\\\" to the two points\\n        (uint256 z1, uint256 z2) = (1, 1);\\n\\n        // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\\n        uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\\n        uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\\n\\n        uint256 dx; // Accumulates denominator from sx calculation\\n        // sx=((qy-py)/(qx-px))^2-px-qx\\n        (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\\n        (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\\n        (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\\n\\n        uint256 dy; // Accumulates denominator from sy calculation\\n        // sy=((qy-py)/(qx-px))(px-sx)-py\\n        (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\\n        (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\\n        (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\\n\\n        if (dx != dy) {\\n            // Cross-multiply to put everything over a common denominator\\n            sx = mulmod(sx, dy, FIELD_SIZE);\\n            sy = mulmod(sy, dx, FIELD_SIZE);\\n            sz = mulmod(dx, dy, FIELD_SIZE);\\n        } else {\\n            // Already over a common denominator, use that for z ordinate\\n            sz = dx;\\n        }\\n    }\\n\\n    // p1+p2, as affine points on secp256k1.\\n    //\\n    // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\\n    // It is computed off-chain to save gas.\\n    //\\n    // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\\n    // point doubling.\\n    function affineECAdd(\\n        uint256[2] memory p1,\\n        uint256[2] memory p2,\\n        uint256 invZ\\n    ) internal pure returns (uint256[2] memory) {\\n        uint256 x;\\n        uint256 y;\\n        uint256 z;\\n        (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\\n        require(mulmod(z, invZ, FIELD_SIZE) == 1, \\\"invZ must be inverse of z\\\");\\n        // Clear the z ordinate of the projective representation by dividing through\\n        // by it, to obtain the affine representation\\n        return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\\n    }\\n\\n    // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\\n    // cryptographically high probability.)\\n    function verifyLinearCombinationWithGenerator(\\n        uint256 c,\\n        uint256[2] memory p,\\n        uint256 s,\\n        address lcWitness\\n    ) internal pure returns (bool) {\\n        // Rule out ecrecover failure modes which return address 0.\\n        require(lcWitness != address(0), \\\"bad witness\\\");\\n        uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\\n        bytes32 pseudoHash = bytes32(\\n            GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)\\n        ); // -s*p[0]\\n        bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\\n        // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n        // The point corresponding to the address returned by\\n        // ecrecover(-s*p[0],v,p[0],c*p[0]) is\\n        // (p[0]⁻¹ mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\\n        // See https://crypto.stackexchange.com/a/18106\\n        // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\\n        address computed = ecrecover(\\n            pseudoHash,\\n            v,\\n            bytes32(p[0]),\\n            pseudoSignature\\n        );\\n        return computed == lcWitness;\\n    }\\n\\n    // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\\n    // requires cp1Witness != sp2Witness (which is fine for this application,\\n    // since it is cryptographically impossible for them to be equal. In the\\n    // (cryptographically impossible) case that a prover accidentally derives\\n    // a proof with equal c*p1 and s*p2, they should retry with a different\\n    // proof nonce.) Assumes that all points are on secp256k1\\n    // (which is checked in verifyVRFProof below.)\\n    function linearCombination(\\n        uint256 c,\\n        uint256[2] memory p1,\\n        uint256[2] memory cp1Witness,\\n        uint256 s,\\n        uint256[2] memory p2,\\n        uint256[2] memory sp2Witness,\\n        uint256 zInv\\n    ) internal pure returns (uint256[2] memory) {\\n        require(\\n            (cp1Witness[0] - sp2Witness[0]) % FIELD_SIZE != 0,\\n            \\\"points in sum must be distinct\\\"\\n        );\\n        require(\\n            ecmulVerify(p1, c, cp1Witness),\\n            \\\"First multiplication check failed\\\"\\n        );\\n        require(\\n            ecmulVerify(p2, s, sp2Witness),\\n            \\\"Second multiplication check failed\\\"\\n        );\\n        return affineECAdd(cp1Witness, sp2Witness, zInv);\\n    }\\n\\n    // Domain-separation tag for the hash taken in scalarFromCurvePoints.\\n    // Corresponds to scalarFromCurveHashPrefix in vrf.go\\n    uint256 constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\\n\\n    // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\\n    // The draft calls (in step 7, via the definition of string_to_int, in\\n    // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\\n    // first hash without checking that it corresponds to a number less than the\\n    // group order, which will lead to a slight bias in the sample.\\n    //\\n    // TODO(alx): We could save a bit of gas by following the standard here and\\n    // using the compressed representation of the points, if we collated the y\\n    // parities into a single bytes32.\\n    // https://www.pivotaltracker.com/story/show/171120588\\n    function scalarFromCurvePoints(\\n        uint256[2] memory hash,\\n        uint256[2] memory pk,\\n        uint256[2] memory gamma,\\n        address uWitness,\\n        uint256[2] memory v\\n    ) internal pure returns (uint256 s) {\\n        return\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        SCALAR_FROM_CURVE_POINTS_HASH_PREFIX,\\n                        hash,\\n                        pk,\\n                        gamma,\\n                        v,\\n                        uWitness\\n                    )\\n                )\\n            );\\n    }\\n\\n    // True if (gamma, c, s) is a correctly constructed randomness proof from pk\\n    // and seed. zInv must be the inverse of the third ordinate from\\n    // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\\n    // section 5.3 of the IETF draft.\\n    //\\n    // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\\n    // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\\n    // (which I could make a uint256 without using any extra space.) Would save\\n    // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\\n    function verifyVRFProof(\\n        uint256[2] memory pk,\\n        uint256[2] memory gamma,\\n        uint256 c,\\n        uint256 s,\\n        uint256 seed,\\n        address uWitness,\\n        uint256[2] memory cGammaWitness,\\n        uint256[2] memory sHashWitness,\\n        uint256 zInv\\n    ) internal view {\\n        require(isOnCurve(pk), \\\"public key is not on curve\\\");\\n        require(isOnCurve(gamma), \\\"gamma is not on curve\\\");\\n        require(isOnCurve(cGammaWitness), \\\"cGammaWitness is not on curve\\\");\\n        require(isOnCurve(sHashWitness), \\\"sHashWitness is not on curve\\\");\\n        // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\\n        // we use the address of u instead of u itself. Also, here we add the\\n        // terms instead of taking the difference, and in the proof consruction in\\n        // vrf.GenerateProof, we correspondingly take the difference instead of\\n        // taking the sum as they do in step 7 of section 5.1.)\\n        require(\\n            verifyLinearCombinationWithGenerator(c, pk, s, uWitness),\\n            \\\"addr(c*pk+s*g)≠_uWitness\\\"\\n        );\\n        // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\\n        uint256[2] memory hash = hashToCurve(pk, seed);\\n        // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\\n        uint256[2] memory v = linearCombination(\\n            c,\\n            gamma,\\n            cGammaWitness,\\n            s,\\n            hash,\\n            sHashWitness,\\n            zInv\\n        );\\n        // Steps 7. and 8. of IETF draft section 5.3\\n        uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\\n        require(c == derivedC, \\\"invalid proof\\\");\\n    }\\n\\n    // Domain-separation tag for the hash used as the final VRF output.\\n    // Corresponds to vrfRandomOutputHashPrefix in vrf.go\\n    uint256 constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\\n\\n    // Length of proof marshaled to bytes array. Shows layout of proof\\n    uint256 public constant PROOF_LENGTH = 64 + // PublicKey (uncompressed format.)\\n        64 + // Gamma\\n        32 + // C\\n        32 + // S\\n        32 + // Seed\\n        0 + // Dummy entry: The following elements are included for gas efficiency:\\n        32 + // uWitness (gets padded to 256 bits, even though it's only 160)\\n        64 + // cGammaWitness\\n        64 + // sHashWitness\\n        32; // zInv  (Leave Output out, because that can be efficiently calculated)\\n\\n    /* ***************************************************************************\\n   * @notice Returns proof's output, if proof is valid. Otherwise reverts\\n\\n   * @param proof A binary-encoded proof, as output by vrf.Proof.MarshalForSolidityVerifier\\n   *\\n   * Throws if proof is invalid, otherwise:\\n   * @return output i.e., the random output implied by the proof\\n   * ***************************************************************************\\n   * @dev See the calculation of PROOF_LENGTH for the binary layout of proof.\\n   */\\n    function randomValueFromVRFProof(bytes memory proof)\\n        internal\\n        view\\n        returns (uint256 output)\\n    {\\n        require(proof.length == PROOF_LENGTH, \\\"wrong proof length\\\");\\n\\n        uint256[2] memory pk; // parse proof contents into these variables\\n        uint256[2] memory gamma;\\n        // c, s and seed combined (prevents \\\"stack too deep\\\" compilation error)\\n        uint256[3] memory cSSeed;\\n        address uWitness;\\n        uint256[2] memory cGammaWitness;\\n        uint256[2] memory sHashWitness;\\n        uint256 zInv;\\n        (pk, gamma, cSSeed, uWitness, cGammaWitness, sHashWitness, zInv) = abi\\n            .decode(\\n            proof,\\n            (\\n                uint256[2],\\n                uint256[2],\\n                uint256[3],\\n                address,\\n                uint256[2],\\n                uint256[2],\\n                uint256\\n            )\\n        );\\n        verifyVRFProof(\\n            pk,\\n            gamma,\\n            cSSeed[0], // c\\n            cSSeed[1], // s\\n            cSSeed[2], // seed\\n            uWitness,\\n            cGammaWitness,\\n            sHashWitness,\\n            zInv\\n        );\\n        output = uint256(\\n            keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, gamma))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RAMVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./libraries/Bytes.sol\\\";\\nimport \\\"./libraries/PoolHelper.sol\\\";\\nimport \\\"./libraries/UserHelper.sol\\\";\\nimport \\\"./interfaces/INFT.sol\\\";\\nimport \\\"./StorageState.sol\\\";\\n\\n\\n// Ram Vault distributes fees equally amongst staked pools\\ncontract RAMVault is StorageState, OwnableUpgradeSafe {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using Bytes for bytes;\\n  using UserHelper for YGYStorageV1.UserInfo;\\n  using PoolHelper for YGYStorageV1.PoolInfo;\\n\\n  event NewEpoch(uint256);\\n  event RewardPaid(uint256 pid, address to);\\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n  event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n  event Approval(address indexed owner, address indexed spender, uint256 _pid, uint256 value);\\n  event Boost(address indexed user, uint256 indexed pid, uint256 indexed level, bool fromNFT);\\n\\n  address private devaddr;\\n  address private teamaddr;\\n  address private regeneratoraddr;\\n  address private nftFactory;\\n\\n  function initialize(\\n    address __superAdmin,\\n    address _regeneratoraddr,\\n    address _devaddr,\\n    address _teamaddr,\\n    address _nftFactory\\n  ) public initializer {\\n    OwnableUpgradeSafe.__Ownable_init();\\n    DEV_FEE = 724;\\n    _superAdmin = __superAdmin;\\n    regeneratoraddr = _regeneratoraddr;\\n    devaddr = _devaddr;\\n    teamaddr = _teamaddr;\\n    nftFactory = _nftFactory;\\n  }\\n\\n  function NFTUsage(\\n    address _user,\\n    address _tokenAddress,\\n    uint256 _tokenId,\\n    uint256 _poolId\\n  ) external {\\n    require(msg.sender == nftFactory, \\\"Prohibited caller\\\");\\n    INFT nft = INFT(_tokenAddress);\\n    YGYStorageV1.NFTProperty memory properties = nft.getTokenProperty(_tokenId);\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_poolId, _user, _storage);\\n\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_poolId, _storage);\\n    if (keccak256(abi.encodePacked(properties.pType)) == keccak256(\\\"boost\\\")) {\\n      _storage.setNFTInUse(nft.contractId(), _user);\\n      user.adjustEffectiveStake(pool, _user, 0, false, _storage);\\n    }\\n    nft.burn(_tokenId);\\n    _storage.updateUserInfo(_poolId, _user, user);\\n    _storage.updatePoolInfo(_poolId, pool);\\n    emit Boost(_user, _poolId, 0, true);\\n  }\\n\\n  // --------------------------------------------\\n  //                  EPOCH\\n  // --------------------------------------------\\n\\n  // Starts a new calculation epoch\\n  // Also dismisses NFT boost effects\\n  // Because averge since start will not be accurate\\n  function startNewEpoch() public {\\n    require(_storage.epochStartBlock() + 5760 < block.number); // about 3 days.\\n    _storage.setEpochRewards();\\n    _storage.setCumulativeRewardsSinceStart();\\n    _storage.setRewardsInThisEpoch(0, 0);\\n    _storage.setEpochCalculationStartBlock();\\n    emit NewEpoch(_storage.epoch());\\n  }\\n\\n  // --------------------------------------------\\n  //                OWNER\\n  // --------------------------------------------\\n\\n  // Adds additional RAM rewards\\n  function addRAMRewardsOwner(uint256 _amount) public onlyOwner {\\n    require(_storage.ram().transferFrom(msg.sender, address(this), _amount) && _amount > 0);\\n    _storage.addAdditionalRewards(_amount, false);\\n  }\\n\\n  // Adds additional YGY rewards\\n  function addYGYRewardsOwner(uint256 _amount) public onlyOwner {\\n    require(_storage.ygy().transferFrom(msg.sender, address(this), _amount) && _amount > 0);\\n    _storage.addAdditionalRewards(_amount, true);\\n  }\\n\\n  // --------------------------------------------\\n  //                  POOL\\n  // --------------------------------------------\\n\\n  // Add a new token pool. Can only be called by the owner.\\n  // Note contract owner is meant to be a governance contract allowing RAM governance consensus\\n  function addPool(\\n    uint256 _allocPoint,\\n    IERC20 _token,\\n    bool _withdrawable\\n  ) public onlyOwner {\\n    massUpdatePools();\\n    _storage.addPool(_allocPoint, _token, _withdrawable);\\n  }\\n\\n  // Update the given pool's RAMs allocation point. Can only be called by the owner.\\n  // Note contract owner is meant to be a governance contract allowing RAM governance consensus\\n  function set(\\n    uint256 _pid,\\n    uint256 _allocPoint,\\n    bool _withdrawable\\n  ) public onlyOwner {\\n    massUpdatePools();\\n    _storage.setPool(_pid, _allocPoint, _withdrawable);\\n  }\\n\\n  // Function that adds pending rewards, called by the RAM token.\\n  function addPendingRewards(uint256 _amount) external {\\n    require(msg.sender == address(_storage.ram()));\\n    _storage.addPendingRewards(_amount);\\n  }\\n\\n  // Update reward variables of the given pool to be up-to-date.\\n  function updatePool(uint256 _pid) internal returns (uint256 ramRewardsWhole, uint256 ygyRewardsWhole) {\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n\\n    uint256 tokenSupply = pool.token.balanceOf(address(this));\\n    if (tokenSupply == 0) {\\n      return (0, 0);\\n    }\\n    uint256 effectivePoolStakedSupply = tokenSupply.add(pool.effectiveAdditionalTokensFromBoosts);\\n\\n    ramRewardsWhole = _storage.pendingRewards().mul(pool.allocPoint).div(_storage.totalAllocPoint());\\n\\n    // Ram rewards\\n    uint256 ramRewardFee = ramRewardsWhole.mul(DEV_FEE).div(10000);\\n    pending_DEV_rewards = pending_DEV_rewards.add(ramRewardFee);\\n\\n    // Ygy rewards should be zero most of the time running.\\n    uint256 pendingYGYRewards = _storage.pendingYGYRewards();\\n    if (pendingYGYRewards > 0) {\\n      ygyRewardsWhole = pendingYGYRewards.mul(pool.allocPoint).div(_storage.totalAllocPoint());\\n      uint256 ygyRewardFee = ygyRewardsWhole.mul(DEV_FEE).div(10000);\\n      pending_DEV_YGY_rewards = pending_DEV_YGY_rewards.add(ygyRewardFee);\\n      pool.accYGYPerShare = pool.accYGYPerShare.add(ygyRewardsWhole.sub(ygyRewardFee).mul(1e12).div(effectivePoolStakedSupply));\\n    }\\n\\n    // Update shares\\n    pool.accRAMPerShare = pool.accRAMPerShare.add(ramRewardsWhole.sub(ramRewardFee).mul(1e12).div(effectivePoolStakedSupply));\\n    _storage.updatePoolInfo(_pid, pool);\\n  }\\n\\n  // Deposit tokens to RamVault for RAM allocation.\\n  function deposit(uint256 _pid, uint256 _amount) public {\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_pid, msg.sender, _storage);\\n    // Pay the user\\n    updateAndPayOutPending(_pid, msg.sender);\\n\\n    // save gas\\n    if (_amount > 0) {\\n      pool.token.transferFrom(address(msg.sender), address(this), _amount);\\n      user.amount = user.amount.add(_amount);\\n\\n      // Users that have bought multipliers will have an extra balance added to their stake according to the boost multiplier.\\n      if (user.boostAmount > 0 || user.boostLevel > 0) {\\n        user.adjustEffectiveStake(pool, msg.sender, 0, false, _storage);\\n      }\\n    }\\n\\n    user.updateDebts(pool);\\n    _storage.updateUserInfo(_pid, msg.sender, user);\\n    _storage.updatePoolInfo(_pid, pool);\\n    emit Deposit(msg.sender, _pid, _amount);\\n  }\\n\\n  function claimRewards(uint256 _pid) external {\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_pid, msg.sender, _storage);\\n\\n    // Adjust the stake since user might have not acted after an epoch change and got boost amounts reduced\\n    if (user.boostAmount > 0) {\\n      user.adjustEffectiveStake(pool, msg.sender, 0, false, _storage);\\n    }\\n    updateAndPayOutPending(_pid, msg.sender);\\n\\n    user.updateDebts(pool);\\n    _storage.updateUserInfo(_pid, msg.sender, user);\\n    _storage.updatePoolInfo(_pid, pool);\\n    emit RewardPaid(_pid, msg.sender);\\n  }\\n\\n  // Test coverage\\n  // [x] Does user get the deposited amounts?\\n  // [x] Does user that its deposited for update correcty?\\n  // [x] Does the depositor get their tokens decreased\\n  function depositFor(\\n    address _depositFor,\\n    uint256 _pid,\\n    uint256 _amount\\n  ) public {\\n    // requires no allowances\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_pid, _depositFor, _storage);\\n\\n    // Pay the user\\n    updateAndPayOutPending(_pid, _depositFor);\\n\\n    // Update the balances of person that amount is being deposited for\\n    if (_amount > 0) {\\n      pool.token.transferFrom(msg.sender, address(this), _amount);\\n      user.amount = user.amount.add(_amount); // This is depositedFor address\\n\\n      // Users that have bought multipliers will have an extra balance added to their stake according to the boost multiplier.\\n      if (user.boostAmount > 0 || user.boostLevel > 0) {\\n        user.adjustEffectiveStake(pool, _depositFor, 0, false, _storage);\\n      }\\n    }\\n\\n    user.updateDebts(pool);\\n    _storage.updateUserInfo(_pid, _depositFor, user);\\n    _storage.updatePoolInfo(_pid, pool);\\n    emit Deposit(_depositFor, _pid, _amount);\\n  }\\n\\n  // Test coverage\\n  // [x] Does allowance update correctly?\\n  function setAllowanceForPoolToken(\\n    address spender,\\n    uint256 _pid,\\n    uint256 value\\n  ) public {\\n    _storage.setPoolAllowance(_pid, msg.sender, spender, value);\\n    emit Approval(msg.sender, spender, _pid, value);\\n  }\\n\\n  // Test coverage\\n  // [x] Does allowance decrease?\\n  // [x] Do oyu need allowance\\n  // [x] Withdraws to correct address\\n  function withdrawFrom(\\n    address owner,\\n    uint256 _pid,\\n    uint256 _amount\\n  ) public {\\n    uint256 allowance = _storage.poolAllowance(_pid, owner, msg.sender);\\n    require(allowance >= _amount, \\\"No allowance\\\");\\n    _storage.setPoolAllowance(_pid, owner, msg.sender, allowance.sub(_amount));\\n    _withdraw(_pid, _amount, owner, msg.sender);\\n  }\\n\\n  // Withdraw  tokens from RamVault.\\n  function withdraw(uint256 _pid, uint256 _amount) public {\\n    _withdraw(_pid, _amount, msg.sender, msg.sender);\\n  }\\n\\n  // Low level withdraw function\\n  function _withdraw(\\n    uint256 _pid,\\n    uint256 _amount,\\n    address from,\\n    address to\\n  ) internal {\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n    require(pool.withdrawable, \\\"Not withdrawable\\\");\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_pid, from, _storage);\\n\\n    require(user.amount >= _amount, \\\"Withdraw amount exceeds balance\\\");\\n    updateAndPayOutPending(_pid, from); // Update balances of from, this is not withdrawal but claiming RAM farmed\\n\\n    if (_amount > 0) {\\n      user.amount = user.amount.sub(_amount);\\n      pool.token.safeTransfer(address(to), _amount);\\n\\n      // Users who have bought multipliers will have their accounting balances readjusted.\\n      if (user.boostAmount > 0 || user.boostLevel > 0) {\\n        user.adjustEffectiveStake(pool, from, 0, true, _storage);\\n      }\\n    }\\n\\n    user.updateDebts(pool);\\n    _storage.updateUserInfo(_pid, msg.sender, user);\\n    _storage.updatePoolInfo(_pid, pool);\\n    emit Withdraw(to, _pid, _amount);\\n  }\\n\\n  function massUpdatePools() public {\\n    uint256 allRewards;\\n    uint256 allYGYRewards;\\n    for (uint256 pid = 0; pid < _storage.getPoolLength(); ++pid) {\\n      (uint256 ramWholeReward, uint256 ygyWholeReward) = updatePool(pid);\\n      allRewards = allRewards.add(ramWholeReward);\\n      allYGYRewards = allYGYRewards.add(ygyWholeReward);\\n    }\\n\\n    _storage.updatePoolRewards(allRewards, allYGYRewards);\\n  }\\n\\n  function checkRewards(uint256 _pid, address _user) public view returns (uint256 pendingRAM, uint256 pendingYGY) {\\n    return _storage.checkRewards(_pid, _user);\\n  }\\n\\n  function updateAndPayOutPending(uint256 _pid, address _from) internal {\\n    massUpdatePools();\\n\\n    (uint256 pendingRAM, uint256 pendingYGY) = checkRewards(_pid, _from);\\n    if (pendingRAM > 0) {\\n      safeRamTransfer(_from, pendingRAM);\\n    }\\n    if (pendingYGY > 0) {\\n      safeYgyTransfer(_from, pendingYGY);\\n    }\\n  }\\n\\n  // Withdraw without caring about rewards. EMERGENCY ONLY.\\n  // !Caution this will remove all your pending rewards!\\n  function emergencyWithdraw(uint256 _pid) public {\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n    require(pool.withdrawable, \\\"Pool not withdrawable\\\");\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_pid, msg.sender, _storage);\\n    pool.token.safeTransfer(address(msg.sender), user.amount);\\n    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n    user.amount = 0;\\n    user.boostAmount = 0;\\n    user.rewardDebt = 0;\\n    user.rewardDebtYGY = 0;\\n    _storage.updateUserInfo(_pid, msg.sender, user);\\n    _storage.updatePoolInfo(_pid, pool);\\n    // No mass update dont update pending rewards\\n  }\\n\\n  // --------------------------------------------\\n  //                  BOOST\\n  // --------------------------------------------\\n\\n  // Purchase a multiplier level for an individual user for an individual pool, same level cannot be purchased twice.\\n  function purchase(uint256 _pid, uint256 _level) external {\\n    YGYStorageV1.PoolInfo memory pool = PoolHelper.getPool(_pid, _storage);\\n    YGYStorageV1.UserInfo memory user = UserHelper.getUser(_pid, msg.sender, _storage);\\n\\n    require(_level > user.boostLevel && _level <= 4);\\n\\n    // Cost will be reduced by the amount already spent on multipliers.\\n    uint256 cost = _storage.getBoostLevelCost(_level);\\n    uint256 finalCost = cost.sub(user.spentMultiplierTokens);\\n\\n    // Transfer RAM tokens to the contract\\n    require(_storage.ram().transferFrom(msg.sender, address(this), finalCost));\\n\\n    // Update balances and level\\n    user.spentMultiplierTokens = user.spentMultiplierTokens.add(finalCost);\\n    user.boostLevel = _level;\\n\\n    // If user has staked balances, then set their new accounting balance\\n    if (user.amount > 0) {\\n      // Get the new multiplier\\n      user.adjustEffectiveStake(pool, msg.sender, _level, false, _storage);\\n    }\\n\\n    _storage.updateUserInfo(_pid, msg.sender, user);\\n    _storage.updatePoolInfo(_pid, pool);\\n    _storage.setBoostFees(finalCost, true);\\n    emit Boost(msg.sender, _pid, _level, false);\\n  }\\n\\n  // Distributes boost fees to devs and protocol\\n  function distributeFees() public {\\n    // Reset taxes to 0 before distributing any funds\\n    _storage.setBoostFees(0, false);\\n\\n    // Distribute taxes to regenerator and team 50/50%\\n    uint256 halfDistAmt = _storage.boostFees().div(2);\\n    if (halfDistAmt > 0) {\\n      // 50% to regenerator\\n      require(_storage.ram().transfer(regeneratoraddr, halfDistAmt));\\n      // 70% of the other 50% to devs\\n      uint256 devDistAmt = halfDistAmt.mul(70).div(100);\\n      if (devDistAmt > 0) {\\n        require(_storage.ram().transfer(devaddr, devDistAmt));\\n      }\\n      // 30% of the other 50% to team\\n      uint256 teamDistAmt = halfDistAmt.mul(30).div(100);\\n      if (teamDistAmt > 0) {\\n        require(_storage.ram().transfer(teamaddr, teamDistAmt));\\n      }\\n    }\\n  }\\n\\n  // --------------------------------------------\\n  //                  Utils\\n  // --------------------------------------------\\n\\n  // Sets the dev fee for this contract\\n  // defaults at 7.24%\\n  // Note contract owner is meant to be a governance contract allowing RAM governance consensus\\n  uint16 DEV_FEE;\\n\\n  function setDevFee(uint16 _DEV_FEE) public onlyOwner {\\n    require(_DEV_FEE <= 1000, \\\"Max 10%\\\");\\n    DEV_FEE = _DEV_FEE;\\n  }\\n\\n  uint256 pending_DEV_rewards;\\n  uint256 pending_DEV_YGY_rewards;\\n\\n  // function that lets owner/governance contract\\n  // approve allowance for any token inside this contract\\n  // This means all future UNI like airdrops are covered\\n  // And at the same time allows us to give allowance to strategy contracts.\\n  // Upcoming cYFI etc vaults strategy contracts will  se this function to manage and farm yield on value locked\\n  function setStrategyContractOrDistributionContractAllowance(\\n    address tokenAddress,\\n    uint256 _amount,\\n    address contractAddress\\n  ) external {\\n    require(isContract(contractAddress) && _superAdmin == _msgSender());\\n    require(block.number > _storage.RAMVaultStartBlock().add(95_000), \\\"Gov not ready\\\");\\n    IERC20(tokenAddress).approve(contractAddress, _amount);\\n  }\\n\\n  function isContract(address addr) internal view returns (bool) {\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(addr)\\n    }\\n    return size > 0;\\n  }\\n\\n  function safeRamTransfer(address _to, uint256 _amount) internal {\\n    uint256 ramBal = _storage.ram().balanceOf(address(this));\\n\\n    if (_amount > ramBal) {\\n      _storage.ram().transfer(_to, ramBal);\\n    } else {\\n      _storage.ram().transfer(_to, _amount);\\n    }\\n    transferRAMDevFee();\\n    _storage.setRAMBalance(_storage.ram().balanceOf(address(this)));\\n  }\\n\\n  function safeYgyTransfer(address _to, uint256 _amount) internal {\\n    uint256 ygyBal = _storage.ygy().balanceOf(address(this));\\n\\n    if (_amount > ygyBal) {\\n      _storage.ygy().transfer(_to, ygyBal);\\n    } else {\\n      _storage.ygy().transfer(_to, _amount);\\n    }\\n    _storage.setYGYBalance(_storage.ygy().balanceOf(address(this)));\\n    transferYGYDevFee();\\n  }\\n\\n  function transferRAMDevFee() public {\\n    if (pending_DEV_rewards > 0) {\\n      uint256 devDistAmt;\\n      uint256 teamDistAmt;\\n      uint256 ramBal = _storage.ram().balanceOf(address(this));\\n      if (pending_DEV_rewards > ramBal) {\\n        devDistAmt = ramBal.mul(70).div(100);\\n        teamDistAmt = ramBal.mul(30).div(100);\\n      } else {\\n        devDistAmt = pending_DEV_rewards.mul(70).div(100);\\n        teamDistAmt = pending_DEV_rewards.mul(30).div(100);\\n      }\\n\\n      if (devDistAmt > 0) {\\n        _storage.ram().transfer(devaddr, devDistAmt);\\n      }\\n      if (teamDistAmt > 0) {\\n        _storage.ram().transfer(teamaddr, teamDistAmt);\\n      }\\n\\n      _storage.setRAMBalance(_storage.ram().balanceOf(address(this)));\\n      pending_DEV_rewards = 0;\\n    }\\n  }\\n\\n  function transferYGYDevFee() public {\\n    if (pending_DEV_YGY_rewards > 0) {\\n      uint256 devDistAmt;\\n      uint256 teamDistAmt;\\n      uint256 ygyBal = _storage.ygy().balanceOf(address(this));\\n      if (pending_DEV_YGY_rewards > ygyBal) {\\n        devDistAmt = ygyBal.mul(70).div(100);\\n        teamDistAmt = ygyBal.mul(30).div(100);\\n      } else {\\n        devDistAmt = pending_DEV_YGY_rewards.mul(70).div(100);\\n        teamDistAmt = pending_DEV_YGY_rewards.mul(30).div(100);\\n      }\\n\\n      if (devDistAmt > 0) {\\n        _storage.ygy().transfer(devaddr, devDistAmt);\\n      }\\n      if (teamDistAmt > 0) {\\n        _storage.ygy().transfer(teamaddr, teamDistAmt);\\n      }\\n\\n      _storage.setYGYBalance(_storage.ygy().balanceOf(address(this)));\\n      pending_DEV_YGY_rewards = 0;\\n    }\\n  }\\n\\n  function setAddresses(\\n    address _devaddr,\\n    address _teamaddr,\\n    address _regeneratoraddr\\n  ) external onlyOwner {\\n    devaddr = _devaddr;\\n    teamaddr = _teamaddr;\\n    regeneratoraddr = _regeneratoraddr;\\n  }\\n\\n  address private _superAdmin;\\n\\n  event SuperAdminTransfered(address previousOwner, address newOwner);\\n\\n  function superAdmin() public view returns (address) {\\n    return _superAdmin;\\n  }\\n\\n  function burnSuperAdmin() public virtual {\\n    require(_superAdmin == _msgSender());\\n    _superAdmin = address(0);\\n    emit SuperAdminTransfered(_superAdmin, address(0));\\n  }\\n\\n  function newSuperAdmin(address newOwner) public virtual {\\n    require(_superAdmin == _msgSender());\\n    require(newOwner != address(0));\\n    _superAdmin = newOwner;\\n    emit SuperAdminTransfered(_superAdmin, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED;\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Bytes {\\n    using SafeMath for uint256;\\n\\n    function toUint256(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        assembly {\\n            value := mload(add(_bytes, 0x20))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UserHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"../StorageState.sol\\\";\\n\\nlibrary UserHelper {\\n  using SafeMath for uint256;\\n\\n  function effectiveAmount(YGYStorageV1.UserInfo memory self) internal pure returns (uint256) {\\n    return self.amount.add(self.boostAmount);\\n  }\\n\\n  function getUser(\\n    uint256 _poolId,\\n    address _user,\\n    YGYStorageV1 _storage\\n  ) internal view returns (YGYStorageV1.UserInfo memory) {\\n    (uint256 amount, uint256 rewardDebt, uint256 rewardDebtYGY, uint256 boostAmount, uint256 boostLevel, uint256 spentMultiplierTokens) =\\n      _storage.userInfo(_poolId, _user);\\n\\n    return\\n      YGYStorageV1.UserInfo({\\n        amount: amount,\\n        rewardDebt: rewardDebt,\\n        rewardDebtYGY: rewardDebtYGY,\\n        boostAmount: boostAmount,\\n        boostLevel: boostLevel,\\n        spentMultiplierTokens: spentMultiplierTokens\\n      });\\n  }\\n\\n  function userRewards(\\n    YGYStorageV1.UserInfo memory self,\\n    uint256 _poolId,\\n    YGYStorageV1 _storage\\n  ) internal view returns (uint256 RAMRewards, uint256 YGYRewards) {\\n    (, , uint256 accRAMPerShare, uint256 accYGYPerShare, , ) = YGYStorageV1(_storage).getPoolInfo(_poolId);\\n    return (\\n      effectiveAmount(self).mul(accRAMPerShare).div(1e12).sub(self.rewardDebt),\\n      effectiveAmount(self).mul(accYGYPerShare).div(1e12).sub(self.rewardDebtYGY)\\n    );\\n  }\\n\\n  // Returns the multiplier for user.\\n  function getTotalMultiplier(\\n    YGYStorageV1.UserInfo memory self,\\n    uint256 _level,\\n    address _user,\\n    YGYStorageV1 _storage\\n  ) internal view returns (uint256) {\\n    uint256 NFTBoost = _storage.getNFTBoost(_user);\\n    return _storage.getBoostLevelMultiplier(_level).add(NFTBoost);\\n  }\\n\\n  function updateDebts(YGYStorageV1.UserInfo memory self, YGYStorageV1.PoolInfo memory _pool) internal pure {\\n    self.rewardDebt = effectiveAmount(self).mul(_pool.accRAMPerShare).div(1e12);\\n    self.rewardDebtYGY = effectiveAmount(self).mul(_pool.accYGYPerShare).div(1e12);\\n  }\\n\\n  function adjustEffectiveStake(\\n    YGYStorageV1.UserInfo memory self,\\n    YGYStorageV1.PoolInfo memory _pool,\\n    address _user,\\n    uint256 _newLevel,\\n    bool _isWithdraw,\\n    YGYStorageV1 _storage\\n  ) internal view {\\n    uint256 prevBalancesAccounting = self.boostAmount;\\n    // Calculate and set self's new accounting balance\\n    uint256 accTotalMultiplier = getTotalMultiplier(self, _newLevel > 0 ? _newLevel : self.boostLevel, _user, _storage);\\n\\n    uint256 newBalancesAccounting = self.amount.mul(accTotalMultiplier).div(100);\\n    self.boostAmount = newBalancesAccounting;\\n\\n    // Adjust total accounting supply accordingly\\n    if (_isWithdraw) {\\n      _pool.effectiveAdditionalTokensFromBoosts = _pool.effectiveAdditionalTokensFromBoosts.sub(\\n        prevBalancesAccounting.sub(newBalancesAccounting)\\n      );\\n    } else {\\n      if (prevBalancesAccounting > newBalancesAccounting) {\\n        _pool.effectiveAdditionalTokensFromBoosts = _pool.effectiveAdditionalTokensFromBoosts.sub(prevBalancesAccounting).add(\\n          newBalancesAccounting\\n        );\\n      } else {\\n        _pool.effectiveAdditionalTokensFromBoosts = _pool.effectiveAdditionalTokensFromBoosts.add(newBalancesAccounting).sub(\\n          prevBalancesAccounting\\n        );\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/NFTFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/INFT.sol\\\";\\nimport \\\"./interfaces/IRAMVault.sol\\\";\\nimport \\\"./NFT.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"./StorageState.sol\\\";\\n\\ncontract NFTFactory is StorageState, OwnableUpgradeSafe {\\n  address[] public contracts;\\n  address public bondedContract;\\n  IRAMVault ramVault;\\n  // address public lastContractAddress;\\n  mapping(address => bool) public inUse;\\n\\n  event NFTMinted(string tokenName, address to, uint256 tokenId);\\n  event NFTBurned(string tokenName, address from, uint256 tokenId);\\n\\n  constructor(YGYStorageV1 __storage) public {\\n    __Ownable_init();\\n    _storage = __storage;\\n  }\\n\\n  function deployNFT(\\n    string memory name,\\n    string memory symbol,\\n    string memory tokenURI,\\n    uint256 contractId,\\n    uint256 propertyChoices,\\n    address admin,\\n    bool allowTrade,\\n    bool isCapped,\\n    uint256 capAmount,\\n    address _ramVault\\n  ) public returns (NFT newContract) {\\n    require(_msgSender() == owner() || _msgSender() == bondedContract, \\\"Invalid caller: can't deploy NFT\\\");\\n    ramVault = IRAMVault(_ramVault);\\n\\n    // Deploy new NFT\\n    NFT nft = new NFT(name, symbol, tokenURI, contractId, propertyChoices, admin, allowTrade, isCapped, capAmount, _ramVault);\\n\\n    address addressNFT = address(nft);\\n\\n    // Add to owned NFTs\\n    contracts.push(addressNFT);\\n\\n    return nft;\\n  }\\n\\n  function balanceOf(INFT _nft, address _who) external view returns (uint256) {\\n    return _nft.balanceOf(_who);\\n  }\\n\\n  function isOwner(\\n    INFT _nft,\\n    address _who,\\n    uint256 _tokenId\\n  ) external view returns (bool) {\\n    return _nft.ownerOf(_tokenId) == _who;\\n  }\\n\\n  function mint(\\n    INFT _nft,\\n    address _to,\\n    uint256 _randomness\\n  ) external returns (uint256) {\\n    require(_msgSender() == bondedContract || _msgSender() == owner());\\n    uint256 tokenId = _nft.mint(_to, _randomness, _storage);\\n\\n    emit NFTMinted(_nft.name(), _to, tokenId);\\n    return tokenId;\\n  }\\n\\n  function burn(INFT _nft, uint256 _tokenId) external {\\n    require(_nft.ownerOf(_tokenId) == _msgSender() || _msgSender() == bondedContract);\\n    _nft.burn(_tokenId);\\n    emit NFTBurned(_nft.name(), _msgSender(), _tokenId);\\n  }\\n\\n  function setNFTProperties(address _nft, YGYStorageV1.NFTProperty[] memory _properties) external {\\n    require(msg.sender == owner());\\n    _storage.setNFTPropertiesForContract(_nft, _properties);\\n  }\\n\\n  function useNFT(\\n    INFT _nft,\\n    uint256 _tokenId,\\n    uint256 _poolId\\n  ) public {\\n    require(_nft.ownerOf(_tokenId) == msg.sender, \\\"User not owner\\\");\\n    YGYStorageV1.NFTUsage[] memory nftUsage = _storage.getNFTsInUse(msg.sender);\\n\\n    uint256 contractId = _nft.contractId();\\n    bool alreadyInUse;\\n\\n    // check if nft instance is already in use for the user\\n    for (uint256 i; i < nftUsage.length; i++) {\\n      if (nftUsage[i].contractId == contractId) {\\n\\n        alreadyInUse = true;\\n        break;\\n      }\\n    }\\n    require(!alreadyInUse, \\\"NFT already in use\\\");\\n\\n    _nft.transferFrom(msg.sender, address(ramVault), _tokenId);\\n    ramVault.NFTUsage(msg.sender, address(_nft), _tokenId, _poolId);\\n  }\\n\\n  function setNFTUsage(address _nft, bool _inUse) external onlyOwner {\\n    inUse[_nft] = _inUse;\\n  }\\n\\n  function bondContract(address _addr) external returns (bool) {\\n    require(msg.sender == owner());\\n    bondedContract = _addr;\\n    return true;\\n  }\\n\\n  function getContractCount() external view returns (uint256 contractCount) {\\n    return contracts.length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/testing/FeeGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n// Contract that sends tokens it gets to itself\\n// Making it generate fees with fee on transfer tokens\\ncontract FeeGenerator {\\n\\n    function transferToSelf(address tokenAddress, uint256 loopCount) public {\\n         for (uint256 counter = 0; counter < loopCount; ++counter) {\\n            IERC20(tokenAddress).transfer(address(this), IERC20(tokenAddress).balanceOf(address(this)));\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IRAMv1Router.sol\\\";\\n\\ncontract Governance {\\n  using SafeMath for uint256;\\n\\n  IERC20 public YGYToken;\\n  IRAMv1Router public RAMRouter;\\n\\n  uint256 public weightedNumber; // Number 1-8 weighted by total user numbers\\n  uint256 public votingShares; // Includes voting shares generated fromimelocked YGY\\n\\n  uint256 public lastRAMRouterUpdateTime; // Last time the regenerator tax on the router was updated\\n  bool public updateStagingMode;\\n  uint256 public updateStagingReadyTime;\\n  address public owner;\\n\\n  struct User {\\n    uint256 number; // Number from 1-8 indicating the desired LGE regenerator tax %\\n    uint256 timelockedYGY;\\n    // The timelocks are stack data structure implemented via hashmaps,\\n    // there's a stack at each level (1-4)\\n    mapping(uint256 => mapping(uint256 => TimeLock)) timelocks; // mapping(level => timelock ID => timelock object)\\n    mapping(uint256 => uint256) timelockTop; // mapping (level => top of stack at this level)\\n    mapping(uint256 => uint256) timelockCount; // mapping (level => current number timelocks at this level)\\n  }\\n\\n  struct TimeLock {\\n    uint256 multipliedAmount;\\n    uint256 level;\\n    uint256 unlockTime;\\n  }\\n\\n  mapping(address => User) public users;\\n\\n  constructor(address _YGYToken, address _RAMRouter) public {\\n    YGYToken = IERC20(_YGYToken);\\n    RAMRouter = IRAMv1Router(_RAMRouter);\\n    weightedNumber = 1; // start at 1%\\n    owner = msg.sender;\\n  }\\n\\n  function updateRouter(address _RAMRouter) external {\\n    require(msg.sender == owner, \\\"!Owner\\\");\\n    RAMRouter = IRAMv1Router(_RAMRouter);\\n  }\\n\\n  function hasTimeLockAtLevel(address user, uint256 level)\\n    external\\n    view\\n    returns (\\n      bool _hasTimelock,\\n      uint256 _level,\\n      uint256 _unlockTime\\n    )\\n  {\\n    User storage userMem = users[user];\\n    uint256 timeLocks = userMem.timelockCount[level];\\n    if (timeLocks > 0) {\\n      uint256 top = userMem.timelockTop[level];\\n      uint256 unlockTime = userMem.timelocks[level][top].unlockTime;\\n      return (true, level, unlockTime);\\n    } else {\\n      return (false, level, 0);\\n    }\\n  }\\n\\n  function setUserNumber(uint256 _number) public {\\n    require(_number >= 1 && _number <= 8, \\\"Number must be in range 1-8\\\");\\n    User storage user = users[msg.sender];\\n    user.number = _number;\\n\\n    calcWeightedNumber(msg.sender);\\n  }\\n\\n  function enterRegeneratorUpdateStagingMode() public {\\n    // 1 day mandatory wait time after last router regenerator tax update\\n    require(block.timestamp >= lastRAMRouterUpdateTime.add(1 days), \\\"Must wait 1 day since last update\\\");\\n    updateStagingMode = true;\\n    updateStagingReadyTime = block.timestamp.add(10 minutes);\\n  }\\n\\n  function updateRAMRouterRegeneratorTax() public {\\n    require(updateStagingMode, \\\"Must be in update staging mode\\\");\\n    require(block.timestamp >= updateStagingReadyTime, \\\"Must wait 10 minutes since update staged\\\");\\n    updateStagingMode = false;\\n    lastRAMRouterUpdateTime = block.timestamp;\\n\\n    // Update the RAM router's regenerator tax\\n    RAMRouter.setRegeneratorTax(weightedNumber);\\n  }\\n\\n  // users can lock YGY for time durations to get multipliers on their YGY\\n  function timelockYGY(\\n    uint256 _amount,\\n    uint256 _level,\\n    uint256 _number\\n  ) public {\\n    require(_number >= 1 && _number <= 8, \\\"Number must be in range 1-8\\\");\\n    require(YGYToken.transferFrom(msg.sender, address(this), _amount), \\\"Have tokens been approved?\\\");\\n\\n    User storage user = users[msg.sender];\\n\\n    // Calculate effective voting power and create new timelock\\n    uint256 effectiveAmount = _amount.mul(getMultiplierForLevel(_level)).div(100);\\n    TimeLock memory timelock =\\n      TimeLock({ multipliedAmount: effectiveAmount, level: _level, unlockTime: block.timestamp.add(getDurationForLevel(_level)) });\\n\\n    if (user.timelockTop[_level] == 0) {\\n      user.timelockTop[_level] = user.timelockTop[_level].add(1);\\n    }\\n\\n    uint256 newTimelockCount = user.timelockCount[_level].add(1);\\n    user.timelocks[_level][newTimelockCount] = timelock;\\n    user.timelockCount[_level] = newTimelockCount;\\n\\n    // Add the new voting power to user and the total voting power\\n    user.timelockedYGY = user.timelockedYGY.add(effectiveAmount);\\n    votingShares = votingShares.add(effectiveAmount);\\n\\n    // Update number and calc new weighted number\\n    user.number = _number;\\n    calcWeightedNumber(msg.sender);\\n  }\\n\\n  // User unlocks their oldest timelock, receiving all the YGY tokens directly to their address\\n  function unlockOldestTimelock(uint256 _level) public {\\n    User storage user = users[msg.sender];\\n    uint256 levelTimelockTop = user.timelockTop[_level];\\n    TimeLock storage timelock = user.timelocks[_level][levelTimelockTop];\\n    require(block.timestamp >= timelock.unlockTime, \\\"Tokens are still timelocked\\\");\\n\\n    // Update user's timelocked balances and the total YGY balance\\n    user.timelockedYGY = user.timelockedYGY.sub(timelock.multipliedAmount);\\n    votingShares = votingShares.sub(timelock.multipliedAmount);\\n\\n    // Send underlying amount of tokens to user\\n    uint256 underlyingAmount = timelock.multipliedAmount.div(getMultiplierForLevel(timelock.level).div(100));\\n    YGYToken.transfer(msg.sender, underlyingAmount);\\n\\n    // Delete the timelock and update user's timelock stack\\n    delete user.timelocks[_level][levelTimelockTop];\\n    user.timelockTop[_level] = levelTimelockTop.add(1);\\n    user.timelockCount[_level] = user.timelockCount[_level].sub(1);\\n\\n    calcWeightedNumber(msg.sender);\\n  }\\n\\n  function calcWeightedNumber(address addr) internal {\\n    User storage user = users[addr];\\n\\n    // Calculate the sum of all weights\\n    uint256 otherTotalYGY = votingShares.sub(user.timelockedYGY);\\n\\n    // Calculate the sum of all weighing factors\\n    uint256 userWeighingFactor = user.timelockedYGY.mul(user.number);\\n    uint256 otherWeighingFactor = otherTotalYGY.mul(weightedNumber);\\n    uint256 sumOfWeighingFactors = userWeighingFactor.add(otherWeighingFactor);\\n\\n    // Weighted average = (sum weighing factors / sum of weight)\\n    if (votingShares > 0 && user.timelockedYGY > 0) {\\n      weightedNumber = sumOfWeighingFactors.div(votingShares);\\n    }\\n  }\\n\\n  function getDurationForLevel(uint256 _level) public pure returns (uint256) {\\n    if (_level == 1) {\\n      return 2 weeks;\\n    } else if (_level == 2) {\\n      return 4 weeks;\\n    } else if (_level == 3) {\\n      return 12 weeks;\\n    } else if (_level == 4) {\\n      return 24 weeks;\\n    }\\n    return 2 weeks;\\n  }\\n\\n  function getMultiplierForLevel(uint256 _level) public pure returns (uint256) {\\n    if (_level == 1) {\\n      return 150; // 1.5x\\n    } else if (_level == 2) {\\n      return 300; // 3x\\n    } else if (_level == 3) {\\n      return 1000; // 10x\\n    } else if (_level == 4) {\\n      return 2500; // 25x\\n    } else {\\n      return 150;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAMv1Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IRAMv1Router {\\n    function setRegeneratorTax(uint256 _regeneratorTax) external;\\n}\\n\"\r\n    },\r\n    \"contracts/FeeApprover.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\"; // for WETH\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\\\";\\n\\n\\ncontract FeeApprover is OwnableUpgradeSafe {\\n    using SafeMath for uint256;\\n\\n    function initialize(\\n        address _RAMAddress,\\n        address _YGYAddress,\\n        address _uniswapFactory,\\n        address _ramVault\\n    ) public initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n\\n        // Setup system addresses\\n        ramTokenAddress = _RAMAddress;\\n        ygyTokenAddress = _YGYAddress;\\n        tokenUniswapPair = IUniswapV2Factory(_uniswapFactory).getPair(\\n            ygyTokenAddress,\\n            ramTokenAddress\\n        );\\n\\n        // Fee perrcents\\n        feePercentX100 = 10; // 1%\\n        paused = true; // We start paused until sync post LGE happens.\\n\\n        _editNoFeeList(_ramVault, true); // ramvault proxy\\n        _editNoFeeList(tokenUniswapPair, true);\\n\\n        sync();\\n        minFinney = 5000;\\n    }\\n\\n    address tokenUniswapPair;\\n    IUniswapV2Factory public uniswapFactory;\\n    address ramTokenAddress;\\n    address ygyTokenAddress;\\n    address ramVaultAddress;\\n    uint8 public feePercentX100; // max 255 = 25.5% artificial clamp\\n    uint256 public lastTotalSupplyOfLPTokens;\\n    bool paused;\\n    uint256 private lastSupplyOfRamInPair;\\n    uint256 private lastSupplyOfYgyInPair;\\n    mapping(address => bool) public noFeeList;\\n\\n    // RAM token is pausable\\n    function setPaused(bool _pause) public onlyOwner {\\n        paused = _pause;\\n        sync();\\n    }\\n\\n    function setFeeMultiplier(uint8 _feeMultiplier) public onlyOwner {\\n        feePercentX100 = _feeMultiplier;\\n    }\\n\\n    function setRamVaultAddress(address _ramVaultAddress) public onlyOwner {\\n        ramVaultAddress = _ramVaultAddress;\\n        noFeeList[ramVaultAddress] = true;\\n    }\\n\\n    function editNoFeeList(address _address, bool noFee) public onlyOwner {\\n        _editNoFeeList(_address, noFee);\\n    }\\n\\n    function _editNoFeeList(address _address, bool noFee) internal {\\n        noFeeList[_address] = noFee;\\n    }\\n\\n    uint256 minFinney; // 2x for $ liq amount\\n\\n    function setMinimumLiquidityToTriggerStop(uint256 finneyAmnt)\\n        public\\n        onlyOwner\\n    {\\n        // 1000 = 1eth\\n        minFinney = finneyAmnt;\\n    }\\n\\n    function sync() public returns (bool lastIsMint, bool lpTokenBurn) {\\n        // This will update the state of lastIsMint, when called publically\\n        // So we have to sync it before to the last LP token value.\\n        uint256 _LPSupplyOfPairTotal = IERC20(tokenUniswapPair).totalSupply();\\n        lpTokenBurn = lastTotalSupplyOfLPTokens > _LPSupplyOfPairTotal;\\n        lastTotalSupplyOfLPTokens = _LPSupplyOfPairTotal;\\n\\n        uint256 _balanceYGY = IERC20(ygyTokenAddress).balanceOf(\\n            tokenUniswapPair\\n        );\\n        uint256 _balanceRAM = IERC20(ramTokenAddress).balanceOf(\\n            tokenUniswapPair\\n        );\\n\\n        // Do not block after small liq additions\\n        // you can only withdraw 350$ now with front running\\n        // And cant front run buys with liq add ( adversary drain )\\n        lastIsMint =\\n            _balanceRAM > lastSupplyOfRamInPair &&\\n            _balanceYGY > lastSupplyOfYgyInPair.add(minFinney.mul(1 finney));\\n\\n        lastSupplyOfRamInPair = _balanceRAM;\\n        lastSupplyOfYgyInPair = _balanceYGY;\\n    }\\n\\n    function calculateAmountsAfterFee(\\n        address sender,\\n        address recipient, // unusued maybe use din future\\n        uint256 amount\\n    )\\n        public\\n        returns (\\n            uint256 transferToAmount,\\n            uint256 transferToFeeDistributorAmount\\n        )\\n    {\\n        require(paused == false, \\\"FEE APPROVER: Transfers Paused\\\");\\n        (bool lastIsMint, bool lpTokenBurn) = sync();\\n\\n        if (sender == tokenUniswapPair) {\\n            // This will block buys that are immidietly after a mint. Before sync is called/\\n            // Deployment of this should only happen after router deployment\\n            // And addition of sync to all RamVault transactions to remove 99.99% of the cases.\\n            require(lastIsMint == false, \\\"Liquidity withdrawals forbidden\\\");\\n            require(lpTokenBurn == false, \\\"Liquidity withdrawals forbidden\\\");\\n        }\\n\\n        if (noFeeList[sender]) {\\n            // Dont have a fee when ramvault is sending, or infinite loop\\n // And when pair is sending ( buys are happening, no tax on it)\\n            transferToFeeDistributorAmount = 0;\\n            transferToAmount = amount;\\n        } else {\\n            transferToFeeDistributorAmount = amount.mul(feePercentX100).div(\\n                1000\\n            );\\n            transferToAmount = amount.sub(transferToFeeDistributorAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RAM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./NBUNIERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\n// RAM-Token with Governance.\\ncontract RAM is NBUNIERC20 {\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(address factory, address _ygy, address _treasury) public {\\n        initialSetup(factory, _ygy, _treasury);\\n    }\\n\\n    /// @notice A record of each accounts delegate\\n    mapping(address => address) internal _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping(address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\n        \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\n        \\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\"\\n    );\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping(address => uint256) public nonces;\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(\\n        address indexed delegator,\\n        address indexed fromDelegate,\\n        address indexed toDelegate\\n    );\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegator The address to get delegatee for\\n     */\\n    function delegates(address delegator) external view returns (address) {\\n        return _delegates[delegator];\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name())),\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(\\n            signatory != address(0),\\n            \\\"RAM::delegateBySig: invalid signature\\\"\\n        );\\n        require(\\n            nonce == nonces[signatory]++,\\n            \\\"RAM::delegateBySig: invalid nonce\\\"\\n        );\\n        require(now <= expiry, \\\"RAM::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint256) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return\\n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(\\n            blockNumber < block.number,\\n            \\\"RAM::getPriorVotes: not yet determined\\\"\\n        );\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        address currentDelegate = _delegates[delegator];\\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying RAM tokens (not scaled);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(\\n        address srcRep,\\n        address dstRep,\\n        uint256 amount\\n    ) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                // decrease old representative\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum > 0\\n                    ? checkpoints[srcRep][srcRepNum - 1].votes\\n                    : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                // increase new representative\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum > 0\\n                    ? checkpoints[dstRep][dstRepNum - 1].votes\\n                    : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    ) internal {\\n        uint32 blockNumber = safe32(\\n            block.number,\\n            \\\"RAM::_writeCheckpoint: block number exceeds 32 bits\\\"\\n        );\\n\\n        if (\\n            nCheckpoints > 0 &&\\n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\\n        ) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(\\n                blockNumber,\\n                newVotes\\n            );\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage)\\n        internal\\n        pure\\n        returns (uint32)\\n    {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint256) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GovernorAlpha.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\n// Copyright 2020 Compound Labs, Inc.\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n//\\n// Ctrl+f for XXX to see all the modifications.\\n// uint96s are changed to uint256s for simplicity and safety.\\n\\n// XXX: pragma solidity ^0.5.16;\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./RAM.sol\\\";\\n\\ncontract GovernorAlpha {\\n    /// @notice The name of this contract\\n    // XXX: string public constant name = \\\"Compound Governor Alpha\\\";\\n    string public constant name = \\\"Ram Governor Alpha\\\";\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    // XXX: function quorumVotes() public pure returns (uint) { return 400000e18; } // 400,000 = 4% of Comp\\n    function quorumVotes() public view returns (uint) { return ram.totalSupply() / 25; } // 4% of Supply\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    // function proposalThreshold() public pure returns (uint) { return 100000e18; } // 100,000 = 1% of Comp\\n    function proposalThreshold() public view returns (uint) { return ram.totalSupply() / 100; } // 1% of Supply\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    function votingPeriod() public pure returns (uint) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\\n\\n    /// @notice The address of the Compound Protocol Timelock\\n    TimelockInterface public timelock;\\n\\n    /// @notice The address of the Compound governance token\\n    // XXX: CompInterface public comp;\\n    RAM public ram;\\n\\n    /// @notice The address of the Governor Guardian\\n    address public guardian;\\n\\n    /// @notice The total number of proposals\\n    uint public proposalCount;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint id;\\n\\n        /// @notice Creator of the proposal\\n        address proposer;\\n\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint eta;\\n\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint[] values;\\n\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint startBlock;\\n\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint endBlock;\\n\\n        /// @notice Current number of votes in favor of this proposal\\n        uint forVotes;\\n\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint againstVotes;\\n\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping (address => Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        /// @notice Whether or not the voter supports the proposal\\n        bool support;\\n\\n        /// @notice The number of votes the voter had, which were cast\\n        uint256 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping (uint => Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping (address => uint) public latestProposalIds;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint id, uint eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint id);\\n\\n    constructor(address timelock_, address ram_, address guardian_) public {\\n        timelock = TimelockInterface(timelock_);\\n        ram = RAM(ram_);\\n        guardian = guardian_;\\n    }\\n\\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\\n        require(ram.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\");\\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"GovernorAlpha::propose: must provide actions\\\");\\n        require(targets.length <= proposalMaxOperations(), \\\"GovernorAlpha::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = add256(block.number, votingDelay());\\n        uint endBlock = add256(startBlock, votingPeriod());\\n\\n        proposalCount++;\\n        Proposal memory newProposal = Proposal({\\n            id: proposalCount,\\n            proposer: msg.sender,\\n            eta: 0,\\n            targets: targets,\\n            values: values,\\n            signatures: signatures,\\n            calldatas: calldatas,\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            forVotes: 0,\\n            againstVotes: 0,\\n            canceled: false,\\n            executed: false\\n        });\\n\\n        proposals[newProposal.id] = newProposal;\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    function queue(uint proposalId) public {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint eta = add256(block.timestamp, timelock.delay());\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\");\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    function execute(uint proposalId) public payable {\\n        require(state(proposalId) == ProposalState.Queued, \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.executeTransaction{value: (proposal.values[i])}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    function cancel(uint proposalId) public {\\n        ProposalState state = state(proposalId);\\n        require(state != ProposalState.Executed, \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        require(msg.sender == guardian || ram.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \\\"GovernorAlpha::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    function state(uint proposalId) public view returns (ProposalState) {\\n        require(proposalCount >= proposalId && proposalId > 0, \\\"GovernorAlpha::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number <= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    function castVote(uint proposalId, bool support) public {\\n        return _castVote(msg.sender, proposalId, support);\\n    }\\n\\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"GovernorAlpha::castVoteBySig: invalid signature\\\");\\n        return _castVote(signatory, proposalId, support);\\n    }\\n\\n    function _castVote(address voter, uint proposalId, bool support) internal {\\n        require(state(proposalId) == ProposalState.Active, \\\"GovernorAlpha::_castVote: voting is closed\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"GovernorAlpha::_castVote: voter already voted\\\");\\n        uint256 votes = ram.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support) {\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\n        } else {\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(voter, proposalId, support, votes);\\n    }\\n\\n    function __acceptAdmin() public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__acceptAdmin: sender must be gov guardian\\\");\\n        timelock.acceptAdmin();\\n    }\\n\\n    function __abdicate() public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__abdicate: sender must be gov guardian\\\");\\n        guardian = address(0);\\n    }\\n\\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\\ninterface TimelockInterface {\\n    function delay() external view returns (uint);\\n    function GRACE_PERIOD() external view returns (uint);\\n    function acceptAdmin() external;\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/testing/WETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Copyright (C) 2015, 2016, 2017 Dapphub\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n\\npragma solidity 0.6.12;\\n\\ncontract WETH9 {\\n    string public name = \\\"Wrapped Ether\\\";\\n    string public symbol = \\\"WETH\\\";\\n    uint8 public decimals = 18;\\n\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    // function() public payable {\\n    //     deposit();\\n    // }\\n    mapping(address => uint256) public balanceOf;\\n\\n    function deposit() public payable {\\n\\n        balanceOf[msg.sender] += msg.value;\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 wad) public {\\n        require(balanceOf[msg.sender] >= wad, \\\"\\\");\\n        balanceOf[msg.sender] -= wad;\\n        msg.sender.transfer(wad);\\n        emit Withdrawal(msg.sender, wad);\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function approve(address guy, uint256 wad) public returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n        emit Approval(msg.sender, guy, wad);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint256 wad) public returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) public returns (bool) {\\n        require(balanceOf[src] >= wad, \\\"2@?\\\");\\n\\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\\n            require(allowance[src][msg.sender] >= wad, \\\"knock knock\\\");\\n            allowance[src][msg.sender] -= wad;\\n        }\\n\\n        balanceOf[src] -= wad;\\n        balanceOf[dst] += wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n}\\n\\n/*\\n                    GNU GENERAL PUBLIC LICENSE\\n                       Version 3, 29 June 2007\\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\\n Everyone is permitted to copy and distribute verbatim copies\\n of this license document, but changing it is not allowed.\\n                            Preamble\\n  The GNU General Public License is a free, copyleft license for\\nsoftware and other kinds of works.\\n  The licenses for most software and other practical works are designed\\nto take away your freedom to share and change the works.  By contrast,\\nthe GNU General Public License is intended to guarantee your freedom to\\nshare and change all versions of a program--to make sure it remains free\\nsoftware for all its users.  We, the Free Software Foundation, use the\\nGNU General Public License for most of our software; it applies also to\\nany other work released this way by its authors.  You can apply it to\\nyour programs, too.\\n  When we speak of free software, we are referring to freedom, not\\nprice.  Our General Public Licenses are designed to make sure that you\\nhave the freedom to distribute copies of free software (and charge for\\nthem if you wish), that you receive source code or can get it if you\\nwant it, that you can change the software or use pieces of it in new\\nfree programs, and that you know you can do these things.\\n  To protect your rights, we need to prevent others from denying you\\nthese rights or asking you to surrender the rights.  Therefore, you have\\ncertain responsibilities if you distribute copies of the software, or if\\nyou modify it: responsibilities to respect the freedom of others.\\n  For example, if you distribute copies of such a program, whether\\ngratis or for a fee, you must pass on to the recipients the same\\nfreedoms that you received.  You must make sure that they, too, receive\\nor can get the source code.  And you must show them these terms so they\\nknow their rights.\\n  Developers that use the GNU GPL protect your rights with two steps:\\n(1) assert copyright on the software, and (2) offer you this License\\ngiving you legal permission to copy, distribute and/or modify it.\\n  For the developers' and authors' protection, the GPL clearly explains\\nthat there is no warranty for this free software.  For both users' and\\nauthors' sake, the GPL requires that modified versions be marked as\\nchanged, so that their problems will not be attributed erroneously to\\nauthors of previous versions.\\n  Some devices are designed to deny users access to install or run\\nmodified versions of the software inside them, although the manufacturer\\ncan do so.  This is fundamentally incompatible with the aim of\\nprotecting users' freedom to change the software.  The systematic\\npattern of such abuse occurs in the area of products for individuals to\\nuse, which is precisely where it is most unacceptable.  Therefore, we\\nhave designed this version of the GPL to prohibit the practice for those\\nproducts.  If such problems arise substantially in other domains, we\\nstand ready to extend this provision to those domains in future versions\\nof the GPL, as needed to protect the freedom of users.\\n  Finally, every program is threatened constantly by software patents.\\nStates should not allow patents to restrict development and use of\\nsoftware on general-purpose computers, but in those that do, we wish to\\navoid the special danger that patents applied to a free program could\\nmake it effectively proprietary.  To prevent this, the GPL assures that\\npatents cannot be used to render the program non-free.\\n  The precise terms and conditions for copying, distribution and\\nmodification follow.\\n                       TERMS AND CONDITIONS\\n  0. Definitions.\\n  \\\"This License\\\" refers to version 3 of the GNU General Public License.\\n  \\\"Copyright\\\" also means copyright-like laws that apply to other kinds of\\nworks, such as semiconductor masks.\\n  \\\"The Program\\\" refers to any copyrightable work licensed under this\\nLicense.  Each licensee is addressed as \\\"you\\\".  \\\"Licensees\\\" and\\n\\\"recipients\\\" may be individuals or organizations.\\n  To \\\"modify\\\" a work means to copy from or adapt all or part of the work\\nin a fashion requiring copyright permission, other than the making of an\\nexact copy.  The resulting work is called a \\\"modified version\\\" of the\\nearlier work or a work \\\"based on\\\" the earlier work.\\n  A \\\"covered work\\\" means either the unmodified Program or a work based\\non the Program.\\n  To \\\"propagate\\\" a work means to do anything with it that, without\\npermission, would make you directly or secondarily liable for\\ninfringement under applicable copyright law, except executing it on a\\ncomputer or modifying a private copy.  Propagation includes copying,\\ndistribution (with or without modification), making available to the\\npublic, and in some countries other activities as well.\\n  To \\\"convey\\\" a work means any kind of propagation that enables other\\nparties to make or receive copies.  Mere interaction with a user through\\na computer network, with no transfer of a copy, is not conveying.\\n  An interactive user interface displays \\\"Appropriate Legal Notices\\\"\\nto the extent that it includes a convenient and prominently visible\\nfeature that (1) displays an appropriate copyright notice, and (2)\\ntells the user that there is no warranty for the work (except to the\\nextent that warranties are provided), that licensees may convey the\\nwork under this License, and how to view a copy of this License.  If\\nthe interface presents a list of user commands or options, such as a\\nmenu, a prominent item in the list meets this criterion.\\n  1. Source Code.\\n  The \\\"source code\\\" for a work means the preferred form of the work\\nfor making modifications to it.  \\\"Object code\\\" means any non-source\\nform of a work.\\n  A \\\"Standard Interface\\\" means an interface that either is an official\\nstandard defined by a recognized standards body, or, in the case of\\ninterfaces specified for a particular programming language, one that\\nis widely used among developers working in that language.\\n  The \\\"System Libraries\\\" of an executable work include anything, other\\nthan the work as a whole, that (a) is included in the normal form of\\npackaging a Major Component, but which is not part of that Major\\nComponent, and (b) serves only to enable use of the work with that\\nMajor Component, or to implement a Standard Interface for which an\\nimplementation is available to the public in source code form.  A\\n\\\"Major Component\\\", in this context, means a major essential component\\n(kernel, window system, and so on) of the specific operating system\\n(if any) on which the executable work runs, or a compiler used to\\nproduce the work, or an object code interpreter used to run it.\\n  The \\\"Corresponding Source\\\" for a work in object code form means all\\nthe source code needed to generate, install, and (for an executable\\nwork) run the object code and to modify the work, including scripts to\\ncontrol those activities.  However, it does not include the work's\\nSystem Libraries, or general-purpose tools or generally available free\\nprograms which are used unmodified in performing those activities but\\nwhich are not part of the work.  For example, Corresponding Source\\nincludes interface definition files associated with source files for\\nthe work, and the source code for shared libraries and dynamically\\nlinked subprograms that the work is specifically designed to require,\\nsuch as by intimate data communication or control flow between those\\nsubprograms and other parts of the work.\\n  The Corresponding Source need not include anything that users\\ncan regenerate automatically from other parts of the Corresponding\\nSource.\\n  The Corresponding Source for a work in source code form is that\\nsame work.\\n  2. Basic Permissions.\\n  All rights granted under this License are granted for the term of\\ncopyright on the Program, and are irrevocable provided the stated\\nconditions are met.  This License explicitly affirms your unlimited\\npermission to run the unmodified Program.  The output from running a\\ncovered work is covered by this License only if the output, given its\\ncontent, constitutes a covered work.  This License acknowledges your\\nrights of fair use or other equivalent, as provided by copyright law.\\n  You may make, run and propagate covered works that you do not\\nconvey, without conditions so long as your license otherwise remains\\nin force.  You may convey covered works to others for the sole purpose\\nof having them make modifications exclusively for you, or provide you\\nwith facilities for running those works, provided that you comply with\\nthe terms of this License in conveying all material for which you do\\nnot control copyright.  Those thus making or running the covered works\\nfor you must do so exclusively on your behalf, under your direction\\nand control, on terms that prohibit them from making any copies of\\nyour copyrighted material outside their relationship with you.\\n  Conveying under any other circumstances is permitted solely under\\nthe conditions stated below.  Sublicensing is not allowed; section 10\\nmakes it unnecessary.\\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\\n  No covered work shall be deemed part of an effective technological\\nmeasure under any applicable law fulfilling obligations under article\\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\\nsimilar laws prohibiting or restricting circumvention of such\\nmeasures.\\n  When you convey a covered work, you waive any legal power to forbid\\ncircumvention of technological measures to the extent such circumvention\\nis effected by exercising rights under this License with respect to\\nthe covered work, and you disclaim any intention to limit operation or\\nmodification of the work as a means of enforcing, against the work's\\nusers, your or third parties' legal rights to forbid circumvention of\\ntechnological measures.\\n  4. Conveying Verbatim Copies.\\n  You may convey verbatim copies of the Program's source code as you\\nreceive it, in any medium, provided that you conspicuously and\\nappropriately publish on each copy an appropriate copyright notice;\\nkeep intact all notices stating that this License and any\\nnon-permissive terms added in accord with section 7 apply to the code;\\nkeep intact all notices of the absence of any warranty; and give all\\nrecipients a copy of this License along with the Program.\\n  You may charge any price or no price for each copy that you convey,\\nand you may offer support or warranty protection for a fee.\\n  5. Conveying Modified Source Versions.\\n  You may convey a work based on the Program, or the modifications to\\nproduce it from the Program, in the form of source code under the\\nterms of section 4, provided that you also meet all of these conditions:\\n    a) The work must carry prominent notices stating that you modified\\n    it, and giving a relevant date.\\n    b) The work must carry prominent notices stating that it is\\n    released under this License and any conditions added under section\\n    7.  This requirement modifies the requirement in section 4 to\\n    \\\"keep intact all notices\\\".\\n    c) You must license the entire work, as a whole, under this\\n    License to anyone who comes into possession of a copy.  This\\n    License will therefore apply, along with any applicable section 7\\n    additional terms, to the whole of the work, and all its parts,\\n    regardless of how they are packaged.  This License gives no\\n    permission to license the work in any other way, but it does not\\n    invalidate such permission if you have separately received it.\\n    d) If the work has interactive user interfaces, each must display\\n    Appropriate Legal Notices; however, if the Program has interactive\\n    interfaces that do not display Appropriate Legal Notices, your\\n    work need not make them do so.\\n  A compilation of a covered work with other separate and independent\\nworks, which are not by their nature extensions of the covered work,\\nand which are not combined with it such as to form a larger program,\\nin or on a volume of a storage or distribution medium, is called an\\n\\\"aggregate\\\" if the compilation and its resulting copyright are not\\nused to limit the access or legal rights of the compilation's users\\nbeyond what the individual works permit.  Inclusion of a covered work\\nin an aggregate does not cause this License to apply to the other\\nparts of the aggregate.\\n  6. Conveying Non-Source Forms.\\n  You may convey a covered work in object code form under the terms\\nof sections 4 and 5, provided that you also convey the\\nmachine-readable Corresponding Source under the terms of this License,\\nin one of these ways:\\n    a) Convey the object code in, or embodied in, a physical product\\n    (including a physical distribution medium), accompanied by the\\n    Corresponding Source fixed on a durable physical medium\\n    customarily used for software interchange.\\n    b) Convey the object code in, or embodied in, a physical product\\n    (including a physical distribution medium), accompanied by a\\n    written offer, valid for at least three years and valid for as\\n    long as you offer spare parts or customer support for that product\\n    model, to give anyone who possesses the object code either (1) a\\n    copy of the Corresponding Source for all the software in the\\n    product that is covered by this License, on a durable physical\\n    medium customarily used for software interchange, for a price no\\n    more than your reasonable cost of physically performing this\\n    conveying of source, or (2) access to copy the\\n    Corresponding Source from a network server at no charge.\\n    c) Convey individual copies of the object code with a copy of the\\n    written offer to provide the Corresponding Source.  This\\n    alternative is allowed only occasionally and noncommercially, and\\n    only if you received the object code with such an offer, in accord\\n    with subsection 6b.\\n    d) Convey the object code by offering access from a designated\\n    place (gratis or for a charge), and offer equivalent access to the\\n    Corresponding Source in the same way through the same place at no\\n    further charge.  You need not require recipients to copy the\\n    Corresponding Source along with the object code.  If the place to\\n    copy the object code is a network server, the Corresponding Source\\n    may be on a different server (operated by you or a third party)\\n    that supports equivalent copying facilities, provided you maintain\\n    clear directions next to the object code saying where to find the\\n    Corresponding Source.  Regardless of what server hosts the\\n    Corresponding Source, you remain obligated to ensure that it is\\n    available for as long as needed to satisfy these requirements.\\n    e) Convey the object code using peer-to-peer transmission, provided\\n    you inform other peers where the object code and Corresponding\\n    Source of the work are being offered to the general public at no\\n    charge under subsection 6d.\\n  A separable portion of the object code, whose source code is excluded\\nfrom the Corresponding Source as a System Library, need not be\\nincluded in conveying the object code work.\\n  A \\\"User Product\\\" is either (1) a \\\"consumer product\\\", which means any\\ntangible personal property which is normally used for personal, family,\\nor household purposes, or (2) anything designed or sold for incorporation\\ninto a dwelling.  In determining whether a product is a consumer product,\\ndoubtful cases shall be resolved in favor of coverage.  For a particular\\nproduct received by a particular user, \\\"normally used\\\" refers to a\\ntypical or common use of that class of product, regardless of the status\\nof the particular user or of the way in which the particular user\\nactually uses, or expects or is expected to use, the product.  A product\\nis a consumer product regardless of whether the product has substantial\\ncommercial, industrial or non-consumer uses, unless such uses represent\\nthe only significant mode of use of the product.\\n  \\\"Installation Information\\\" for a User Product means any methods,\\nprocedures, authorization keys, or other information required to install\\nand execute modified versions of a covered work in that User Product from\\na modified version of its Corresponding Source.  The information must\\nsuffice to ensure that the continued functioning of the modified object\\ncode is in no case prevented or interfered with solely because\\nmodification has been made.\\n  If you convey an object code work under this section in, or with, or\\nspecifically for use in, a User Product, and the conveying occurs as\\npart of a transaction in which the right of possession and use of the\\nUser Product is transferred to the recipient in perpetuity or for a\\nfixed term (regardless of how the transaction is characterized), the\\nCorresponding Source conveyed under this section must be accompanied\\nby the Installation Information.  But this requirement does not apply\\nif neither you nor any third party retains the ability to install\\nmodified object code on the User Product (for example, the work has\\nbeen installed in ROM).\\n  The requirement to provide Installation Information does not include a\\nrequirement to continue to provide support service, warranty, or updates\\nfor a work that has been modified or installed by the recipient, or for\\nthe User Product in which it has been modified or installed.  Access to a\\nnetwork may be denied when the modification itself materially and\\nadversely affects the operation of the network or violates the rules and\\nprotocols for communication across the network.\\n  Corresponding Source conveyed, and Installation Information provided,\\nin accord with this section must be in a format that is publicly\\ndocumented (and with an implementation available to the public in\\nsource code form), and must require no special password or key for\\nunpacking, reading or copying.\\n  7. Additional Terms.\\n  \\\"Additional permissions\\\" are terms that supplement the terms of this\\nLicense by making exceptions from one or more of its conditions.\\nAdditional permissions that are applicable to the entire Program shall\\nbe treated as though they were included in this License, to the extent\\nthat they are valid under applicable law.  If additional permissions\\napply only to part of the Program, that part may be used separately\\nunder those permissions, but the entire Program remains governed by\\nthis License without regard to the additional permissions.\\n  When you convey a copy of a covered work, you may at your option\\nremove any additional permissions from that copy, or from any part of\\nit.  (Additional permissions may be written to require their own\\nremoval in certain cases when you modify the work.)  You may place\\nadditional permissions on material, added by you to a covered work,\\nfor which you have or can give appropriate copyright permission.\\n  Notwithstanding any other provision of this License, for material you\\nadd to a covered work, you may (if authorized by the copyright holders of\\nthat material) supplement the terms of this License with terms:\\n    a) Disclaiming warranty or limiting liability differently from the\\n    terms of sections 15 and 16 of this License; or\\n    b) Requiring preservation of specified reasonable legal notices or\\n    author attributions in that material or in the Appropriate Legal\\n    Notices displayed by works containing it; or\\n    c) Prohibiting misrepresentation of the origin of that material, or\\n    requiring that modified versions of such material be marked in\\n    reasonable ways as different from the original version; or\\n    d) Limiting the use for publicity purposes of names of licensors or\\n    authors of the material; or\\n    e) Declining to grant rights under trademark law for use of some\\n    trade names, trademarks, or service marks; or\\n    f) Requiring indemnification of licensors and authors of that\\n    material by anyone who conveys the material (or modified versions of\\n    it) with contractual assumptions of liability to the recipient, for\\n    any liability that these contractual assumptions directly impose on\\n    those licensors and authors.\\n  All other non-permissive additional terms are considered \\\"further\\nrestrictions\\\" within the meaning of section 10.  If the Program as you\\nreceived it, or any part of it, contains a notice stating that it is\\ngoverned by this License along with a term that is a further\\nrestriction, you may remove that term.  If a license document contains\\na further restriction but permits relicensing or conveying under this\\nLicense, you may add to a covered work material governed by the terms\\nof that license document, provided that the further restriction does\\nnot survive such relicensing or conveying.\\n  If you add terms to a covered work in accord with this section, you\\nmust place, in the relevant source files, a statement of the\\nadditional terms that apply to those files, or a notice indicating\\nwhere to find the applicable terms.\\n  Additional terms, permissive or non-permissive, may be stated in the\\nform of a separately written license, or stated as exceptions;\\nthe above requirements apply either way.\\n  8. Termination.\\n  You may not propagate or modify a covered work except as expressly\\nprovided under this License.  Any attempt otherwise to propagate or\\nmodify it is void, and will automatically terminate your rights under\\nthis License (including any patent licenses granted under the third\\nparagraph of section 11).\\n  However, if you cease all violation of this License, then your\\nlicense from a particular copyright holder is reinstated (a)\\nprovisionally, unless and until the copyright holder explicitly and\\nfinally terminates your license, and (b) permanently, if the copyright\\nholder fails to notify you of the violation by some reasonable means\\nprior to 60 days after the cessation.\\n  Moreover, your license from a particular copyright holder is\\nreinstated permanently if the copyright holder notifies you of the\\nviolation by some reasonable means, this is the first time you have\\nreceived notice of violation of this License (for any work) from that\\ncopyright holder, and you cure the violation prior to 30 days after\\nyour receipt of the notice.\\n  Termination of your rights under this section does not terminate the\\nlicenses of parties who have received copies or rights from you under\\nthis License.  If your rights have been terminated and not permanently\\nreinstated, you do not qualify to receive new licenses for the same\\nmaterial under section 10.\\n  9. Acceptance Not Required for Having Copies.\\n  You are not required to accept this License in order to receive or\\nrun a copy of the Program.  Ancillary propagation of a covered work\\noccurring solely as a consequence of using peer-to-peer transmission\\nto receive a copy likewise does not require acceptance.  However,\\nnothing other than this License grants you permission to propagate or\\nmodify any covered work.  These actions infringe copyright if you do\\nnot accept this License.  Therefore, by modifying or propagating a\\ncovered work, you indicate your acceptance of this License to do so.\\n  10. Automatic Licensing of Downstream Recipients.\\n  Each time you convey a covered work, the recipient automatically\\nreceives a license from the original licensors, to run, modify and\\npropagate that work, subject to this License.  You are not responsible\\nfor enforcing compliance by third parties with this License.\\n  An \\\"entity transaction\\\" is a transaction transferring control of an\\norganization, or substantially all assets of one, or subdividing an\\norganization, or merging organizations.  If propagation of a covered\\nwork results from an entity transaction, each party to that\\ntransaction who receives a copy of the work also receives whatever\\nlicenses to the work the party's predecessor in interest had or could\\ngive under the previous paragraph, plus a right to possession of the\\nCorresponding Source of the work from the predecessor in interest, if\\nthe predecessor has it or can get it with reasonable efforts.\\n  You may not impose any further restrictions on the exercise of the\\nrights granted or affirmed under this License.  For example, you may\\nnot impose a license fee, royalty, or other charge for exercise of\\nrights granted under this License, and you may not initiate litigation\\n(including a cross-claim or counterclaim in a lawsuit) alleging that\\nany patent claim is infringed by making, using, selling, offering for\\nsale, or importing the Program or any portion of it.\\n  11. Patents.\\n  A \\\"contributor\\\" is a copyright holder who authorizes use under this\\nLicense of the Program or a work on which the Program is based.  The\\nwork thus licensed is called the contributor's \\\"contributor version\\\".\\n  A contributor's \\\"essential patent claims\\\" are all patent claims\\nowned or controlled by the contributor, whether already acquired or\\nhereafter acquired, that would be infringed by some manner, permitted\\nby this License, of making, using, or selling its contributor version,\\nbut do not include claims that would be infringed only as a\\nconsequence of further modification of the contributor version.  For\\npurposes of this definition, \\\"control\\\" includes the right to grant\\npatent sublicenses in a manner consistent with the requirements of\\nthis License.\\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\\npatent license under the contributor's essential patent claims, to\\nmake, use, sell, offer for sale, import and otherwise run, modify and\\npropagate the contents of its contributor version.\\n  In the following three paragraphs, a \\\"patent license\\\" is any express\\nagreement or commitment, however denominated, not to enforce a patent\\n(such as an express permission to practice a patent or covenant not to\\nsue for patent infringement).  To \\\"grant\\\" such a patent license to a\\nparty means to make such an agreement or commitment not to enforce a\\npatent against the party.\\n  If you convey a covered work, knowingly relying on a patent license,\\nand the Corresponding Source of the work is not available for anyone\\nto copy, free of charge and under the terms of this License, through a\\npublicly available network server or other readily accessible means,\\nthen you must either (1) cause the Corresponding Source to be so\\navailable, or (2) arrange to deprive yourself of the benefit of the\\npatent license for this particular work, or (3) arrange, in a manner\\nconsistent with the requirements of this License, to extend the patent\\nlicense to downstream recipients.  \\\"Knowingly relying\\\" means you have\\nactual knowledge that, but for the patent license, your conveying the\\ncovered work in a country, or your recipient's use of the covered work\\nin a country, would infringe one or more identifiable patents in that\\ncountry that you have reason to believe are valid.\\n  If, pursuant to or in connection with a single transaction or\\narrangement, you convey, or propagate by procuring conveyance of, a\\ncovered work, and grant a patent license to some of the parties\\nreceiving the covered work authorizing them to use, propagate, modify\\nor convey a specific copy of the covered work, then the patent license\\nyou grant is automatically extended to all recipients of the covered\\nwork and works based on it.\\n  A patent license is \\\"discriminatory\\\" if it does not include within\\nthe scope of its coverage, prohibits the exercise of, or is\\nconditioned on the non-exercise of one or more of the rights that are\\nspecifically granted under this License.  You may not convey a covered\\nwork if you are a party to an arrangement with a third party that is\\nin the business of distributing software, under which you make payment\\nto the third party based on the extent of your activity of conveying\\nthe work, and under which the third party grants, to any of the\\nparties who would receive the covered work from you, a discriminatory\\npatent license (a) in connection with copies of the covered work\\nconveyed by you (or copies made from those copies), or (b) primarily\\nfor and in connection with specific products or compilations that\\ncontain the covered work, unless you entered into that arrangement,\\nor that patent license was granted, prior to 28 March 2007.\\n  Nothing in this License shall be construed as excluding or limiting\\nany implied license or other defenses to infringement that may\\notherwise be available to you under applicable patent law.\\n  12. No Surrender of Others' Freedom.\\n  If conditions are imposed on you (whether by court order, agreement or\\notherwise) that contradict the conditions of this License, they do not\\nexcuse you from the conditions of this License.  If you cannot convey a\\ncovered work so as to satisfy simultaneously your obligations under this\\nLicense and any other pertinent obligations, then as a consequence you may\\nnot convey it at all.  For example, if you agree to terms that obligate you\\nto collect a royalty for further conveying from those to whom you convey\\nthe Program, the only way you could satisfy both those terms and this\\nLicense would be to refrain entirely from conveying the Program.\\n  13. Use with the GNU Affero General Public License.\\n  Notwithstanding any other provision of this License, you have\\npermission to link or combine any covered work with a work licensed\\nunder version 3 of the GNU Affero General Public License into a single\\ncombined work, and to convey the resulting work.  The terms of this\\nLicense will continue to apply to the part which is the covered work,\\nbut the special requirements of the GNU Affero General Public License,\\nsection 13, concerning interaction through a network will apply to the\\ncombination as such.\\n  14. Revised Versions of this License.\\n  The Free Software Foundation may publish revised and/or new versions of\\nthe GNU General Public License from time to time.  Such new versions will\\nbe similar in spirit to the present version, but may differ in detail to\\naddress new problems or concerns.\\n  Each version is given a distinguishing version number.  If the\\nProgram specifies that a certain numbered version of the GNU General\\nPublic License \\\"or any later version\\\" applies to it, you have the\\noption of following the terms and conditions either of that numbered\\nversion or of any later version published by the Free Software\\nFoundation.  If the Program does not specify a version number of the\\nGNU General Public License, you may choose any version ever published\\nby the Free Software Foundation.\\n  If the Program specifies that a proxy can decide which future\\nversions of the GNU General Public License can be used, that proxy's\\npublic statement of acceptance of a version permanently authorizes you\\nto choose that version for the Program.\\n  Later license versions may give you additional or different\\npermissions.  However, no additional obligations are imposed on any\\nauthor or copyright holder as a result of your choosing to follow a\\nlater version.\\n  15. Disclaimer of Warranty.\\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \\\"AS IS\\\" WITHOUT WARRANTY\\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\\n  16. Limitation of Liability.\\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\\nSUCH DAMAGES.\\n  17. Interpretation of Sections 15 and 16.\\n  If the disclaimer of warranty and limitation of liability provided\\nabove cannot be given local legal effect according to their terms,\\nreviewing courts shall apply local law that most closely approximates\\nan absolute waiver of all civil liability in connection with the\\nProgram, unless a warranty or assumption of liability accompanies a\\ncopy of the Program in return for a fee.\\n                     END OF TERMS AND CONDITIONS\\n            How to Apply These Terms to Your New Programs\\n  If you develop a new program, and you want it to be of the greatest\\npossible use to the public, the best way to achieve this is to make it\\nfree software which everyone can redistribute and change under these terms.\\n  To do so, attach the following notices to the program.  It is safest\\nto attach them to the start of each source file to most effectively\\nstate the exclusion of warranty; and each file should have at least\\nthe \\\"copyright\\\" line and a pointer to where the full notice is found.\\n    <one line to give the program's name and a brief idea of what it does.>\\n    Copyright (C) <year>  <name of author>\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n    This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\\nAlso add information on how to contact you by electronic and paper mail.\\n  If the program does terminal interaction, make it output a short\\nnotice like this when it starts in an interactive mode:\\n    <program>  Copyright (C) <year>  <name of author>\\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\\n    This is free software, and you are welcome to redistribute it\\n    under certain conditions; type `show c' for details.\\nThe hypothetical commands `show w' and `show c' should show the appropriate\\nparts of the General Public License.  Of course, your program's commands\\nmight be different; for a GUI interface, you would use an \\\"about box\\\".\\n  You should also get your employer (if you work as a programmer) or school,\\nif any, to sign a \\\"copyright disclaimer\\\" for the program, if necessary.\\nFor more information on this, and how to apply and follow the GNU GPL, see\\n<http://www.gnu.org/licenses/>.\\n  The GNU General Public License does not permit incorporating your program\\ninto proprietary programs.  If your program is a subroutine library, you\\nmay consider it more useful to permit linking proprietary applications with\\nthe library.  If this is what you want to do, use the GNU Lesser General\\nPublic License instead of this License.  But first, please read\\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\\n*/\\n\"\r\n    },\r\n    \"contracts/testing/Delegator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\n\\ncontract Delegator {\\n    address payable owner;\\n    address implementation;\\n\\n    constructor(address _implementation) public {\\n        owner = msg.sender;\\n        implementation = _implementation;\\n    }\\n\\n    function setOwner(address payable _newOwner) external {\\n        require(msg.sender == owner);\\n        owner = _newOwner;\\n    }\\n\\n    function upgrade(address _newImplementation) external {\\n        require(msg.sender == owner);\\n        implementation = _newImplementation;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"\": {\r\n        \"__CACHE_BREAKER__\": \"0x00000000d41867734bbee4c6863d9255b2b06ac1\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_contractId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_propertyChoices\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_superAdmin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowTrade\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isCapped\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_tokenCap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ramVault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYSTEM_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenProperty\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"pType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"pValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extra\",\"type\":\"bytes32\"}],\"internalType\":\"struct YGYStorageV1.NFTProperty\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_randomness\",\"type\":\"uint256\"},{\"internalType\":\"contract YGYStorageV1\",\"name\":\"_storage\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"properties\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"pType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"pValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extra\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NFT","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000010000000000000000000000005d742b781822d4fe075ddeb40d7821b04c51a48100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000199999999999999999999999999999999999999999999999999999999999999900000000000000000000000091420d8cbedabf9778680708a7092bb4812e54d300000000000000000000000000000000000000000000000000000000000000044c494e4b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044c494e4b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003c68747470733a2f2f72756e2e6d6f636b792e696f2f76332f33646135326465312d316534662d346537652d386165372d62363862653432373838333500000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e9859680dd9e58194c778cd2231cc0af485a711d657a743318d6da0c333d9417"}]}