{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/Card.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\nlibrary Card {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function make(uint256 x, uint256 y, uint256 z, uint256 u, uint256 unit) internal pure returns (uint256) {\\r\\n        return x.mul(unit**3).add(y.mul(unit**2)).add(z.mul(unit)).add(u);\\r\\n    }\\r\\n\\r\\n    function num(uint256 x, uint256 y, uint256 unit) internal pure returns (uint256) {\\r\\n        return x.div(unit**(uint256(3).sub(y))) % unit;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 x, uint256 y, uint256 z, uint256 unit) internal pure returns (uint256) {\\r\\n        return x.sub(z.mul(unit**(uint256(3).sub(y))));\\r\\n    }\\r\\n\\r\\n    function merge(uint256 x, uint256 y, uint256 unit) internal pure returns (uint256) {\\r\\n        uint256 a = num(x, 0, unit).add(num(y, 0, unit));\\r\\n        uint256 b = num(x, 1, unit).add(num(y, 1, unit));\\r\\n        uint256 c = num(x, 2, unit).add(num(y, 2, unit));\\r\\n        uint256 d = num(x, 3, unit).add(num(y, 3, unit));\\r\\n        return make(a, b, c, d, unit);\\r\\n    }\\r\\n\\r\\n    function min(uint256 x, uint256 unit) internal pure returns (uint256) {\\r\\n        uint256 _min = num(x, 0, unit);\\r\\n        for (uint256 i = 1; i < 4; i++) {\\r\\n            uint256 _num = num(x, i, unit);\\r\\n            if (_num < _min) _min = _num;\\r\\n        }\\r\\n        return _min;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\r\\n    }\\r\\n    \\r\\n    function div(uint a, uint b) internal pure returns (uint z) {\\r\\n        require(b > 0);\\r\\n        return a / b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MonetV1Router.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\nimport \\\"./libraries/Math.sol\\\";\\r\\nimport \\\"./libraries/Card.sol\\\";\\r\\nimport './Ownable.sol';\\r\\n\\r\\ncontract MonetV1Router is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public tokenCard;\\r\\n    address public tokenLucky;\\r\\n    address public tokenMonet;\\r\\n\\r\\n    uint256 public cardsReward = 1575e18;\\r\\n\\r\\n    uint256 public startTime;\\r\\n    uint256 public lotteryPrice = 1e18;\\r\\n\\r\\n    uint256 public rate = 8;\\r\\n    uint256 public ratePeriodFinish;\\r\\n\\r\\n    uint256 public laveCards = 8e3;\\r\\n    uint256 public lavePeriodFinish;\\r\\n\\r\\n    uint256 public unit = 1e10;\\r\\n\\r\\n    constructor(address lucky, address card, address monet) public {\\r\\n        tokenCard = card;\\r\\n        tokenLucky = lucky;\\r\\n        tokenMonet = monet;\\r\\n    }\\r\\n\\r\\n\\r\\n    // VIEW\\r\\n    function cardsNumOf(address from, uint256 level) public view returns (uint256) {\\r\\n        return ICardERC(tokenCard).cardsNumOf(from, level, unit);\\r\\n    }\\r\\n\\r\\n    function cardsNumOfAll(address from) public view returns (uint256[10] memory) {\\r\\n        return ICardERC(tokenCard).cardsNumOfAll(from, unit);\\r\\n    }\\r\\n\\r\\n    // PRIVATE\\r\\n    function _pkgCards( uint256 umax, uint256 mmax, uint256[] memory unums, uint256[] memory mnums, uint256 level ) private view returns (uint256[] memory ucards, uint256[] memory mcards) {\\r\\n        require( unums.length == mnums.length, \\\"nnums size not equal to mnums\\\");\\r\\n        ucards = new uint256[](umax);\\r\\n        mcards = new uint256[](mmax);\\r\\n        uint256 upos;\\r\\n        uint256 mpos;\\r\\n        for (uint256 i = 0; i < unums.length; i++) {\\r\\n            if (unums[i] > 0) (upos, ) = _makeCards(level.sub(i), unums[i], upos, ucards);\\r\\n            if (mnums[i] > 0) (mpos, ) = _makeCards(level.sub(i).sub(1), mnums[i], mpos, mcards);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calcLevelCardsMerge( address from, uint256 level, uint256 num ) private view returns (uint256[] memory, uint256[] memory) {\\r\\n        uint256 nums = cardsNumOf(from, level);\\r\\n        uint256 min = Card.min(nums, unit);\\r\\n        require(num <= min, \\\"insufficient card resources\\\");\\r\\n\\r\\n        uint256[] memory unums = new uint256[](1);\\r\\n        uint256[] memory mnums = new uint256[](1);\\r\\n        (uint256 mmax, uint256 merge) = _randCards(0, num);\\r\\n        unums[0] = Card.make(num, num, num, num, unit);\\r\\n        mnums[0] = merge;\\r\\n        return _pkgCards(4, mmax, unums, mnums, level);\\r\\n    }\\r\\n\\r\\n    function _calcCardsMerge(address from) private view returns (uint256[] memory, uint256[] memory) {\\r\\n        uint256 colorMax = 4;\\r\\n        uint256[10] memory nums = cardsNumOfAll(from);\\r\\n        uint256[] memory mnums = new uint256[](10);\\r\\n        uint256[] memory unums = new uint256[](10);\\r\\n        uint256 umax;\\r\\n        uint256 mmax;\\r\\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.difficulty, now)));\\r\\n        for (uint256 i = 0; i < 9; i++) {\\r\\n            uint256 _num = nums[i];\\r\\n            if (i > 0 && mnums[i.sub(1)] > 0) _num = Card.merge(_num, mnums[i.sub(1)], unit);\\r\\n            uint256 min = Card.min(_num, unit);\\r\\n            if (min == 0) continue;\\r\\n            (uint256 num, uint256 merge) = _randCards((seed = seed >> 1), min);\\r\\n            mnums[i] = merge;\\r\\n            mmax = mmax.add(num);\\r\\n            umax = umax.add(colorMax);\\r\\n\\r\\n            uint256 ucard = Card.make(min, min, min, min, unit);\\r\\n            if (i > 0 && mnums[i.sub(1)] > 0) {\\r\\n                uint256 cards = mnums[i.sub(1)];\\r\\n                if (cards == 0) {\\r\\n                    continue;\\r\\n                }\\r\\n                for (uint256 j = 0; j < colorMax; j++) {\\r\\n                    uint256 cnum = Card.num(cards, j, unit);\\r\\n                    uint256 mnum = Math.min(cnum, min);\\r\\n                    if (mnum > 0) {\\r\\n                        cards = Card.sub(cards, j, mnum, unit);\\r\\n                        ucard = Card.sub(ucard, j, mnum, unit);\\r\\n                        if (mnum == min) umax = umax.sub(1);\\r\\n                        if (mnum == cnum) mmax = mmax.sub(1);\\r\\n                    }\\r\\n                }\\r\\n                mnums[i.sub(1)] = cards;\\r\\n            }\\r\\n            unums[i] = ucard;\\r\\n        }\\r\\n        return _pkgCards(umax, mmax, unums, mnums, 10);\\r\\n    }\\r\\n\\r\\n    function _makeCards( uint256 level, uint256 nums, uint256 pos, uint256[] memory cards ) private view returns (uint256, uint256[] memory) {\\r\\n        for (uint256 i = 0; i < 4; i++) {\\r\\n            uint256 num = Card.num(nums, i, unit);\\r\\n            if (num > 0) {\\r\\n                require(pos < cards.length, \\\"pos gt array size\\\");\\r\\n                cards[pos] = num.mul(1000).add(level.mul(10)).add(i);\\r\\n                pos = pos.add(1);\\r\\n            }\\r\\n        }\\r\\n        return (pos, cards);\\r\\n    }\\r\\n\\r\\n    function _randCards(uint256 seed, uint256 total) private view returns (uint256 num, uint256) {\\r\\n        uint256[4] memory nums = [uint256(0), 0, 0, 0];\\r\\n        if (seed == 0)\\r\\n            seed = uint256(keccak256(abi.encodePacked(block.difficulty, now)));\\r\\n\\r\\n        uint256 left = total.sub(total % 4);\\r\\n        uint256 avg = left.div(4).add(1);\\r\\n        uint256 va = Math.sqrt(avg);\\r\\n        for (uint256 i = 0; i < 3; i++) {\\r\\n            nums[i] = Math.min(total, avg.add(seed % va.mul(2).add(1)).sub(va));\\r\\n            total = total.sub(nums[i]);\\r\\n            seed = seed / 10 - seed;\\r\\n            if (nums[i] > 0) num = num.add(1);\\r\\n        }\\r\\n        nums[3] = total;\\r\\n        if (nums[3] > 0) num = num.add(1);\\r\\n\\r\\n        for (uint256 i = 0; i < 4; i++) {\\r\\n            uint256 j = (seed = seed / 10 - seed) % 4;\\r\\n            (nums[i], nums[j]) = (nums[j], nums[i]);\\r\\n        }\\r\\n        return (num, Card.make(nums[0], nums[1], nums[2], nums[3], unit));\\r\\n    }\\r\\n\\r\\n    function _transferCards( address from, uint256[] memory ucards, uint256[] memory mcards ) private {\\r\\n        require(ucards.length > 0 && mcards.length > 0, \\\"merge error\\\");\\r\\n\\r\\n        ICardERC(tokenCard).cardsBatchBurnFrom(from, ucards);\\r\\n        ICardERC(tokenCard).cardsBatchMint(from, mcards);\\r\\n        emit TransferCards(from, ucards, mcards);\\r\\n    }\\r\\n\\r\\n    function merge(uint256 level, uint256 num) external validateSender(msg.sender) {\\r\\n        require(level > 1 && level <= 10, \\\"illegal level\\\");\\r\\n\\r\\n        uint256[] memory ucards;\\r\\n        uint256[] memory mcards;\\r\\n        (ucards, mcards) = _calcLevelCardsMerge(msg.sender, level, num);\\r\\n        _transferCards(msg.sender, ucards, mcards);\\r\\n    }\\r\\n\\r\\n    function oneKeyMerge() external validateSender(msg.sender) {\\r\\n        uint256[] memory ucards;\\r\\n        uint256[] memory mcards;\\r\\n        (ucards, mcards) = _calcCardsMerge(msg.sender);\\r\\n        _transferCards(msg.sender, ucards, mcards);\\r\\n    }\\r\\n\\r\\n    function lottery(uint256 num) external validateSender(msg.sender) rateRevise laveCardsReset {\\r\\n        require(startTime <= block.timestamp, \\\"startTime gt block.timestamp\\\");\\r\\n        require(num > 0, \\\"num equals zero\\\");\\r\\n        require(IERC20(tokenLucky).burnFrom(msg.sender, num.mul(lotteryPrice)), \\\"lucky burn fail\\\");     \\r\\n\\r\\n        uint256 obtain;\\r\\n        uint256 one = uint256(1000).div(rate);\\r\\n        uint256 seed = uint256(\\r\\n            keccak256(abi.encodePacked(block.difficulty, now))\\r\\n        );\\r\\n\\r\\n        if (one > 0) {\\r\\n            uint256 avg = num.div(one);\\r\\n            uint256 va = Math.sqrt(avg);\\r\\n            uint256 rand = seed % 100;\\r\\n            if (rand <= 76) {\\r\\n                obtain = avg.add(seed % va.mul(2).add(1)).sub(va);\\r\\n            } else if (rand <= 88) {\\r\\n                obtain = avg.add(seed % va.add(1)).add(va);\\r\\n            } else {\\r\\n                obtain = avg.sub(seed % va.add(1)).sub(va);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (num % one >= (seed % one).add(1)) {\\r\\n            obtain = obtain.add(1);\\r\\n        }\\r\\n        obtain = Math.min(obtain, laveCards);\\r\\n        laveCards = laveCards.sub(obtain);\\r\\n\\r\\n\\r\\n        uint256[] memory cards;\\r\\n        if (obtain > 0) {\\r\\n            (uint256 cnum, uint256 mnums) = _randCards(seed, obtain);\\r\\n            cards = new uint256[](cnum);\\r\\n            _makeCards(10, mnums, 0, cards);\\r\\n\\r\\n            ICardERC(tokenCard).cardsBatchMint(msg.sender, cards);\\r\\n        }\\r\\n        emit Lottery(msg.sender, cards);\\r\\n    }\\r\\n\\r\\n    function reward(uint256 color, uint256 num) external validateSender(msg.sender) {\\r\\n        require(color < 4 && num > 0, \\\"color gt 4\\\");\\r\\n\\r\\n        uint256[] memory cards = new uint256[](1);\\r\\n        cards[0] = color.add(10).add(num.mul(1000));\\r\\n\\r\\n        ICardERC(tokenCard).cardsBatchBurnFrom(msg.sender, cards);\\r\\n        IERC20(tokenMonet).transfer(msg.sender, num.mul(cardsReward));\\r\\n\\r\\n        emit Reward(msg.sender, cards);\\r\\n    }\\r\\n\\r\\n    function setUnit(uint256 _unit) external onlyOwner {\\r\\n        unit = _unit;\\r\\n    }\\r\\n\\r\\n    function notify(uint256 unixtime) external onlyOwner {\\r\\n        require(startTime == 0, 'startTime not equal zero');\\r\\n        startTime = unixtime;\\r\\n        lavePeriodFinish = unixtime.add(1 days);\\r\\n        ratePeriodFinish = unixtime.add(30 days);\\r\\n    }\\r\\n\\r\\n    // MODIFIER\\r\\n    modifier rateRevise(){\\r\\n        if (rate != 1 && block.timestamp > ratePeriodFinish) {\\r\\n            rate = rate.div(2);\\r\\n            ratePeriodFinish = ratePeriodFinish.add(30 days);\\r\\n        }\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier laveCardsReset() {\\r\\n        if (lavePeriodFinish <= block.timestamp) {\\r\\n            laveCards = rate.mul(1e3);\\r\\n            lavePeriodFinish = lavePeriodFinish.add(1 days);\\r\\n        }  \\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validateSender(address account) {\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(account) }\\r\\n        require(size == 0, \\\"account is contract\\\");\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // EVENT\\r\\n    event Reward(address indexed sender, uint256[] cards);\\r\\n    event Lottery(address indexed sender, uint256[] cards);\\r\\n    event TransferCards(address indexed sender, uint256[] burnCards, uint256[] issueCards);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function burnFrom(address from, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface ICardERC {\\r\\n    function cardsBatchMint(address _to, uint256[] calldata _cards) external;\\r\\n    function cardsBatchBurnFrom(address _from, uint256[] calldata _cards) external;\\r\\n    function cardsNumOf(address _owner, uint256 _level, uint256 _carry) external view returns (uint256);\\r\\n    function cardsNumOfAll(address _owner, uint256 _carry) external view returns (uint256[10] memory);\\r\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n// a library for performing various math operations\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x < y ? x : y;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lucky\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"card\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"cards\",\"type\":\"uint256[]\"}],\"name\":\"Lottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"cards\",\"type\":\"uint256[]\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"burnCards\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"issueCards\",\"type\":\"uint256[]\"}],\"name\":\"TransferCards\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"cardsNumOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"cardsNumOfAll\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cardsReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"laveCards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lavePeriodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"lottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"merge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unixtime\",\"type\":\"uint256\"}],\"name\":\"notify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"oneKeyMerge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratePeriodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"color\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unit\",\"type\":\"uint256\"}],\"name\":\"setUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLucky\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMonet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MonetV1Router","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bd504158e56a895108312767b0bc2609468c818e0000000000000000000000001014cf898383d275da1c2ed970d0b2cd5ffef3c2000000000000000000000000f51d48b4554862604d3e69a424c2b68afe3bb968","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}