{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IEpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IEpochUtils {\r\n    function epochPeriodInSeconds() external view returns (uint256);\r\n\r\n    function firstEpochStartTimestamp() external view returns (uint256);\r\n\r\n    function getCurrentEpochNumber() external view returns (uint256);\r\n\r\n    function getEpochNumber(uint256 timestamp) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/IKyberDao.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberDao is IEpochUtils {\r\n    event Voted(address indexed staker, uint indexed epoch, uint indexed campaignID, uint option);\r\n\r\n    function getLatestNetworkFeeDataWithCache()\r\n        external\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function getLatestBRRDataWithCache()\r\n        external\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function handleWithdrawal(address staker, uint256 penaltyAmount) external;\r\n\r\n    function vote(uint256 campaignID, uint256 option) external;\r\n\r\n    function getLatestNetworkFeeData()\r\n        external\r\n        view\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function shouldBurnRewardForEpoch(uint256 epoch) external view returns (bool);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for a past epoch only\r\n     *       fee handler should call this function when a staker wants to claim reward\r\n     *       return 0 if staker has no votes or stakes\r\n     */\r\n    function getPastEpochRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for the current epoch\r\n     *       reward percentage is not finalized until the current epoch is ended\r\n     */\r\n    function getCurrentEpochRewardPercentageInPrecision(address staker)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: @kyber.network/utils-sc/contracts/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n// File: contracts/IKyberFeeHandler.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberFeeHandler {\r\n    event RewardPaid(address indexed staker, uint256 indexed epoch, IERC20 indexed token, uint256 amount);\r\n    event RebatePaid(address indexed rebateWallet, IERC20 indexed token, uint256 amount);\r\n    event PlatformFeePaid(address indexed platformWallet, IERC20 indexed token, uint256 amount);\r\n    event KncBurned(uint256 kncTWei, IERC20 indexed token, uint256 amount);\r\n\r\n    function handleFees(\r\n        IERC20 token,\r\n        address[] calldata eligibleWallets,\r\n        uint256[] calldata rebatePercentages,\r\n        address platformWallet,\r\n        uint256 platformFee,\r\n        uint256 networkFee\r\n    ) external payable;\r\n\r\n    function claimReserveRebate(address rebateWallet) external returns (uint256);\r\n\r\n    function claimPlatformFee(address platformWallet) external returns (uint256);\r\n\r\n    function claimStakerReward(\r\n        address staker,\r\n        uint256 epoch\r\n    ) external returns(uint amount);\r\n}\r\n\r\n// File: contracts/wrappers/IMultipleEpochRewardsClaimer.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IFeeHandler is IKyberFeeHandler {\r\n    function hasClaimedReward(address, uint256) external view returns (bool);\r\n}\r\n\r\ninterface IMultipleEpochRewardsClaimer {\r\n    function claimMultipleRewards(\r\n        IFeeHandler feeHandler,\r\n        uint256[] calldata unclaimedEpochs\r\n    ) external;\r\n\r\n    function getUnclaimedEpochs(IFeeHandler feeHandler, address staker)\r\n        external\r\n        view\r\n        returns (uint256[] memory unclaimedEpochs);\r\n}\r\n\r\n// File: @kyber.network/utils-sc/contracts/PermissionGroups.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ncontract PermissionGroups {\r\n    uint256 internal constant MAX_GROUP_SIZE = 50;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address => bool) internal operators;\r\n    mapping(address => bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n\r\n    event AdminClaimed(address newAdmin, address previousAdmin);\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    event AlerterAdded(address newAlerter, bool isAdd);\r\n\r\n    constructor(address _admin) public {\r\n        require(_admin != address(0), \"admin 0\");\r\n        admin = _admin;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender], \"only operator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender], \"only alerter\");\r\n        _;\r\n    }\r\n\r\n    function getOperators() external view returns (address[] memory) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters() external view returns (address[] memory) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0), \"new admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0), \"admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender, \"not pending\");\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter], \"alerter exists\"); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE, \"max alerters\");\r\n\r\n        emit AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter(address alerter) public onlyAdmin {\r\n        require(alerters[alerter], \"not alerter\");\r\n        alerters[alerter] = false;\r\n\r\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.pop();\r\n                emit AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator], \"operator exists\"); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \"max operators\");\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator(address operator) public onlyAdmin {\r\n        require(operators[operator], \"not operator\");\r\n        operators[operator] = false;\r\n\r\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.pop();\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @kyber.network/utils-sc/contracts/Withdrawable.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\r\n    event EtherWithdraw(uint256 amount, address sendTo);\r\n\r\n    constructor(address _admin) public PermissionGroups(_admin) {}\r\n\r\n    /**\r\n     * @dev Withdraw all IERC20 compatible tokens\r\n     * @param token IERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address sendTo\r\n    ) external onlyAdmin {\r\n        token.transfer(sendTo, amount);\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyAdmin {\r\n        (bool success, ) = sendTo.call{value: amount}(\"\");\r\n        require(success, \"withdraw failed\");\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/wrappers/MultipleEpochRewardsClaimer.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\ncontract MultipleEpochRewardsClaimer is IMultipleEpochRewardsClaimer, Withdrawable {\r\n    IKyberDao public immutable kyberDao;\r\n\r\n    constructor(IKyberDao _kyberDao, address _admin) public Withdrawable(_admin) {\r\n        kyberDao = _kyberDao;\r\n    }\r\n\r\n    /// @dev unclaimedEpochs is asusumed to be of reasonable length\r\n    /// otherwise txns might run out of gas\r\n    function claimMultipleRewards(\r\n        IFeeHandler feeHandler,\r\n        uint256[] calldata unclaimedEpochs\r\n    ) external override {\r\n        for (uint256 i = 0; i < unclaimedEpochs.length; i++) {\r\n            feeHandler.claimStakerReward(msg.sender, unclaimedEpochs[i]);\r\n        }\r\n    }\r\n\r\n    function getUnclaimedEpochs(IFeeHandler feeHandler, address staker)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256[] memory unclaimedEpochs)\r\n    {\r\n        uint256 currentEpoch = kyberDao.getCurrentEpochNumber();\r\n        uint256[] memory tempArray = new uint256[](currentEpoch);\r\n        uint256 i;\r\n        uint256 j;\r\n        // full array size is expected to be of reasonable length\r\n        // for the next 1-2 years\r\n        // we thus start iterating from epoch 0\r\n        for (i = 0; i < currentEpoch; i++) {\r\n            if (\r\n                !feeHandler.hasClaimedReward(staker, i) &&\r\n                kyberDao.getPastEpochRewardPercentageInPrecision(staker, i) != 0\r\n            ) {\r\n                tempArray[j]= i;\r\n                j++;\r\n            }\r\n        }\r\n        unclaimedEpochs = new uint256[](j);\r\n        for (i = 0; i < j; i++) {\r\n            unclaimedEpochs[i] = tempArray[i];\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"_kyberDao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFeeHandler\",\"name\":\"feeHandler\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"unclaimedEpochs\",\"type\":\"uint256[]\"}],\"name\":\"claimMultipleRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFeeHandler\",\"name\":\"feeHandler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUnclaimedEpochs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"unclaimedEpochs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberDao\",\"outputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MultipleEpochRewardsClaimer","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"00000000000000000000000039e507f4f7c3e85ed799fdbdf04e42104a8f6b9a000000000000000000000000bdd33f411da0b40018922a3bc69001b458227f5c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a3e676eb676fa22e688bfbedfa9b0aa45cf0d8ba82075b1c1b445492e18005e9"}]}