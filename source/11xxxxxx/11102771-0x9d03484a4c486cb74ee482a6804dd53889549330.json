{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/ApyOracle.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\ncontract IUniswapRouterV2 {\r\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function totalSupply() external view returns (uint256);\r\n}\r\n\r\ncontract ApyOracle {\r\n\r\n  address public constant oracle = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n  address public constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n  address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n  constructor () public {\r\n  }\r\n\r\n  function getApy(\r\n    address stakeToken,\r\n    bool isUni,\r\n    address ausc,\r\n    uint256 incentive,\r\n    uint256 howManyWeeks,\r\n    address pool) public view returns (uint256) {\r\n    address[] memory p = new address[](3);\r\n    p[0] = stakeToken;\r\n    p[1] = weth;\r\n    p[2] = usdc;\r\n    p[0] = ausc;\r\n    uint256[] memory auscPriceAmounts = IUniswapRouterV2(oracle).getAmountsOut(1e18, p);\r\n    uint256 poolBalance = IERC20(stakeToken).balanceOf(pool);\r\n    uint256 stakeTokenPrice = 1000000;\r\n    if (stakeToken != usdc) {\r\n      if (isUni) {\r\n        stakeTokenPrice = getUniPrice(IUniswapV2Pair(stakeToken));\r\n      } else {\r\n        uint256[] memory stakePriceAmounts = IUniswapRouterV2(oracle).getAmountsOut(1e18, p);\r\n        stakeTokenPrice = stakePriceAmounts[2];\r\n      }\r\n    }\r\n    return 1e8 * (\r\n      auscPriceAmounts[2] * incentive * (52 / howManyWeeks)\r\n    ) / (poolBalance * stakeTokenPrice);\r\n  }\r\n\r\n  function getUniPrice(IUniswapV2Pair unipair) public view returns (uint256) {\r\n    // find the token that is not weth\r\n    (uint112 r0, uint112 r1, ) = unipair.getReserves();\r\n    uint256 total = 0;\r\n    if (unipair.token0() == weth) {\r\n      total = uint256(r0) * 2;\r\n    } else {\r\n      total = uint256(r1) * 2;\r\n    }\r\n    uint256 singlePriceInWeth = 1e18 * total / unipair.totalSupply();\r\n    address[] memory p = new address[](2);\r\n    p[0] = weth;\r\n    p[1] = usdc;\r\n    uint256[] memory prices = IUniswapRouterV2(oracle).getAmountsOut(1e18, p);\r\n    return prices[1] * singlePriceInWeth / 1e18; // price of single token in USDC\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUni\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ausc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"incentive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howManyWeeks\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getApy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"unipair\",\"type\":\"address\"}],\"name\":\"getUniPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ApyOracle","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"150","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b20d932d1586efcde492cc5133e332ba8f561d900cc339ab8c0ed0e41dacd123"}]}