{"status":"1","message":"OK","result":[{"SourceCode":"# Created by interfinex.io\r\n# - The Greeks\r\n\r\ninterface ERC20:\r\n    def approve(_spender : address, _value : uint256) -> bool: nonpayable\r\n    def allowance(_owner: address, _spender: address) -> uint256: view\r\n    def transferFrom(_from : address, _to : address, _value : uint256) -> bool: nonpayable\r\n    def initializeERC20(_name: String[64], _symbol: String[32], _decimals: uint256, _supply: uint256, _mintable: bool): nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n    def mint(_to: address, _value: uint256): nonpayable\r\n    def transfer(_to : address, _value : uint256) -> bool: nonpayable\r\n\r\ninterface DividendERC20:\r\n    def initializeERC20(\r\n        _name: String[64], \r\n        _symbol: String[32], \r\n        _decimals: uint256, \r\n        _supply: uint256, \r\n        _dividend_token: address,\r\n        _mintable: bool\r\n    ): nonpayable\r\n    def burnFrom(_to: address, _value: uint256): nonpayable\r\n    def distributeDividends(_value: uint256): nonpayable\r\n\r\ninterface Exchange:\r\n    def swap(\r\n        input_token: address,\r\n        input_token_amount: uint256,\r\n        recipient: address,\r\n        min_output_token_amount: uint256,\r\n        max_output_token_amount: uint256,\r\n        deadline: uint256,\r\n        referral: address\r\n    ) -> uint256: nonpayable\r\n\r\ninterface Factory:\r\n    def pair_to_exchange(token0: address, token1: address) -> address: view\r\n\r\nbase_token: public(address)\r\nasset_token: public(address)\r\nliquidity_token: public(address)\r\nifex_token_contract: public(address)\r\n\r\nfactory_contract: public(address)\r\n\r\nfee_rate: public(uint256) # fee * 10**18\r\nMIN_LIQUIDITY: constant(uint256) = 10 ** 3\r\nMULTIPLIER: constant(uint256) = 10 ** 18\r\n\r\nevent MintLiquidity:\r\n    base_token_amount: uint256\r\n    asset_token_amount: uint256\r\n    liquidity_tokens_minted: uint256\r\n    user: indexed(address)\r\n\r\nevent BurnLiquidity:\r\n    base_token_amount: uint256\r\n    asset_token_amount: uint256\r\n    liquidity_tokens_burned: uint256\r\n    user: indexed(address)\r\n\r\nevent Swap:\r\n    base_token_amount: uint256\r\n    asset_token_amount: uint256\r\n    is_buy: indexed(bool)\r\n    user: indexed(address)\r\n\r\n@internal\r\ndef safeApprove(_token: address, _spender: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"approve(address,uint256)\"),\r\n            convert(_spender, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token approval failed!\"\r\n\r\n    return True\r\n\r\n@internal\r\ndef safeTransferFrom(_token: address, _from: address, _to: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(_from, bytes32),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token transferFrom failed!\"\r\n\r\n    return True\r\n\r\n@internal\r\ndef safeTransfer(_token: address, _to: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token transfer failed!\"\r\n\r\n    return True\r\n\r\n@external\r\ndef initialize_exchange(\r\n    _base_token: address, \r\n    _asset_token: address, \r\n    _fee_rate: uint256, \r\n    _erc20_dividend_template: address, \r\n    _factory_contract: address,\r\n    _ifex_token_contract: address\r\n):\r\n    assert _base_token != ZERO_ADDRESS and _asset_token != ZERO_ADDRESS, \"_base_token and _asset_token must be valid addresses\"\r\n    assert self.base_token == ZERO_ADDRESS and self.asset_token == ZERO_ADDRESS, \"base_token and asset_token can only be initialised once\"\r\n    self.base_token = _base_token\r\n    self.asset_token = _asset_token\r\n    self.fee_rate = _fee_rate\r\n    self.liquidity_token = create_forwarder_to(_erc20_dividend_template)\r\n    self.ifex_token_contract = _ifex_token_contract\r\n    self.factory_contract = _factory_contract\r\n\r\n    asset_token_ifex_token_exchange: address = Factory(self.factory_contract).pair_to_exchange(_asset_token, _ifex_token_contract)\r\n    base_token_ifex_token_exchange: address = Factory(self.factory_contract).pair_to_exchange(_base_token, _ifex_token_contract)\r\n    self.safeApprove(self.asset_token, asset_token_ifex_token_exchange, MAX_UINT256)\r\n    self.safeApprove(self.base_token, base_token_ifex_token_exchange, MAX_UINT256)\r\n\r\n    self.safeApprove(self.ifex_token_contract, self.ifex_token_contract, MAX_UINT256)\r\n    self.safeApprove(self.ifex_token_contract, self.liquidity_token, MAX_UINT256)\r\n    DividendERC20(self.liquidity_token).initializeERC20(\"LiquidityToken\", \"LT\", 18, 0, self.ifex_token_contract, True)\r\n    return\r\n\r\n@external\r\ndef mint_liquidity(base_token_amount: uint256, min_asset_token_amount: uint256, max_asset_token_amount: uint256, recipient: address, deadline: uint256):\r\n    assert base_token_amount > 0\r\n    assert block.timestamp <= deadline or deadline == 0\r\n\r\n    base_token_balance: uint256 = ERC20(self.base_token).balanceOf(self)\r\n    asset_token_balance: uint256 = ERC20(self.asset_token).balanceOf(self)\r\n    total_liquidity_token_balance: uint256 = ERC20(self.liquidity_token).totalSupply()\r\n\r\n    # Initialisation case\r\n    if total_liquidity_token_balance == 0:\r\n        assert base_token_amount > MIN_LIQUIDITY * 2\r\n        liquidity_tokens_minted: uint256 = base_token_amount\r\n        asset_token_amount: uint256 = min_asset_token_amount\r\n        self.safeTransferFrom(self.asset_token, msg.sender, self, asset_token_amount)\r\n        self.safeTransferFrom(self.base_token, msg.sender, self, base_token_amount)\r\n        ERC20(self.liquidity_token).mint(self, liquidity_tokens_minted)\r\n        ERC20(self.liquidity_token).transfer(recipient, liquidity_tokens_minted - MIN_LIQUIDITY)\r\n        log MintLiquidity(base_token_amount, asset_token_amount, liquidity_tokens_minted, msg.sender)\r\n        return\r\n\r\n    liquidity_tokens_minted: uint256 = total_liquidity_token_balance * base_token_amount / base_token_balance \r\n    asset_token_amount: uint256 = base_token_amount * asset_token_balance / base_token_balance\r\n    assert asset_token_amount >= min_asset_token_amount and asset_token_amount <= max_asset_token_amount\r\n    self.safeTransferFrom(self.asset_token, msg.sender, self, asset_token_amount)\r\n    self.safeTransferFrom(self.base_token, msg.sender, self, base_token_amount)\r\n    ERC20(self.liquidity_token).mint(recipient, liquidity_tokens_minted)\r\n    log MintLiquidity(base_token_amount, asset_token_amount, liquidity_tokens_minted, msg.sender)\r\n\r\n@external\r\ndef burn_liquidity(liquidity_token_amount: uint256, deadline: uint256):\r\n    assert liquidity_token_amount > 0\r\n    assert block.timestamp <= deadline or deadline == 0\r\n    \r\n    total_liquidity_token_balance: uint256 = ERC20(self.liquidity_token).totalSupply()\r\n    base_token_amount: uint256 = ERC20(self.base_token).balanceOf(self) * liquidity_token_amount / total_liquidity_token_balance\r\n    asset_token_amount: uint256 = ERC20(self.asset_token).balanceOf(self) * liquidity_token_amount / total_liquidity_token_balance\r\n\r\n    DividendERC20(self.liquidity_token).burnFrom(msg.sender, liquidity_token_amount)\r\n    self.safeTransfer(self.base_token, msg.sender, base_token_amount)\r\n    self.safeTransfer(self.asset_token, msg.sender, asset_token_amount)\r\n    log BurnLiquidity(base_token_amount, asset_token_amount, liquidity_token_amount, msg.sender)\r\n\r\n@view\r\n@internal\r\ndef _getInputToOutputAmount(input_token: address, input_token_amount: uint256, fee: uint256) -> uint256:\r\n    output_token: address = self.asset_token\r\n    if input_token == self.asset_token:\r\n        output_token = self.base_token\r\n\r\n    input_token_balance: uint256 = ERC20(input_token).balanceOf(self)\r\n    output_token_balance: uint256 = ERC20(output_token).balanceOf(self)\r\n    return ((input_token_amount - fee) * output_token_balance) / (input_token_balance + input_token_amount - fee)\r\n\r\n@view\r\n@external\r\ndef getInputToOutputAmount(input_token: address, input_token_amount: uint256) -> uint256:\r\n    assert input_token == self.base_token or input_token == self.asset_token, \"input_token is not part of this contract\"\r\n    return self._getInputToOutputAmount(input_token, input_token_amount, input_token_amount * self.fee_rate / MULTIPLIER)    \r\n\r\n@external\r\ndef swap(\r\n    input_token: address,\r\n    input_token_amount: uint256,\r\n    recipient: address,\r\n    min_output_token_amount: uint256,\r\n    max_output_token_amount: uint256,\r\n    deadline: uint256,\r\n    referral: address\r\n) -> uint256:\r\n    assert input_token_amount > 0 and ERC20(self.liquidity_token).totalSupply() != 0, \"input_token_amount must be greater than 0\"\r\n    assert input_token == self.base_token or input_token == self.asset_token, \"input_token is not part of this contract\"\r\n    assert deadline == 0 or block.timestamp <= deadline, \"Deadline for this transaction has passed\"\r\n\r\n    output_token: address = self.asset_token\r\n    if input_token == self.asset_token:\r\n        output_token = self.base_token\r\n\r\n    input_token_fee: uint256 = input_token_amount * self.fee_rate / MULTIPLIER\r\n    if referral != ZERO_ADDRESS:\r\n        input_token_fee = input_token_fee * 49 / 100\r\n        self.safeTransfer(input_token, referral, input_token_fee * 10 / 100)\r\n\r\n    output_token_amount: uint256 = self._getInputToOutputAmount(input_token, input_token_amount, input_token_fee)\r\n    self.safeTransferFrom(input_token, msg.sender, self, input_token_amount)\r\n\r\n    assert (output_token_amount >= min_output_token_amount and output_token_amount <= max_output_token_amount) or min_output_token_amount == 0, \"Buying output_token amount is greater than slippage\"\r\n\r\n    if self.base_token != self.ifex_token_contract and self.asset_token != self.ifex_token_contract:\r\n        input_token_ifex_token_exchange: address = Factory(self.factory_contract).pair_to_exchange(input_token, self.ifex_token_contract)\r\n        dividend: uint256 = Exchange(input_token_ifex_token_exchange).swap(input_token, input_token_fee / 10, self, 0, 0, 0, ZERO_ADDRESS)\r\n        DividendERC20(self.liquidity_token).distributeDividends(dividend * 10 / 100)\r\n        DividendERC20(self.ifex_token_contract).distributeDividends(dividend * 90 / 100)\r\n\r\n    self.safeTransfer(output_token, recipient, output_token_amount)\r\n\r\n    base_token_amount: uint256 = input_token_amount\r\n    asset_token_amount: uint256 = output_token_amount\r\n    is_buy: bool = True\r\n    if input_token != self.base_token:\r\n        base_token_amount = output_token_amount\r\n        asset_token_amount = input_token_amount\r\n        is_buy = False\r\n\r\n    log Swap(base_token_amount, asset_token_amount, is_buy, msg.sender)\r\n    return output_token_amount","ABI":"[{\"name\":\"MintLiquidity\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_token_amount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"asset_token_amount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"liquidity_tokens_minted\",\"indexed\":false},{\"type\":\"address\",\"name\":\"user\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BurnLiquidity\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_token_amount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"asset_token_amount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"liquidity_tokens_burned\",\"indexed\":false},{\"type\":\"address\",\"name\":\"user\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Swap\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_token_amount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"asset_token_amount\",\"indexed\":false},{\"type\":\"bool\",\"name\":\"is_buy\",\"indexed\":true},{\"type\":\"address\",\"name\":\"user\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"initialize_exchange\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_base_token\"},{\"type\":\"address\",\"name\":\"_asset_token\"},{\"type\":\"uint256\",\"name\":\"_fee_rate\"},{\"type\":\"address\",\"name\":\"_erc20_dividend_template\"},{\"type\":\"address\",\"name\":\"_factory_contract\"},{\"type\":\"address\",\"name\":\"_ifex_token_contract\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":288907},{\"name\":\"mint_liquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_token_amount\"},{\"type\":\"uint256\",\"name\":\"min_asset_token_amount\"},{\"type\":\"uint256\",\"name\":\"max_asset_token_amount\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":43100},{\"name\":\"burn_liquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"liquidity_token_amount\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":22570},{\"name\":\"getInputToOutputAmount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"input_token\"},{\"type\":\"uint256\",\"name\":\"input_token_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8428},{\"name\":\"swap\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"input_token\"},{\"type\":\"uint256\",\"name\":\"input_token_amount\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"uint256\",\"name\":\"min_output_token_amount\"},{\"type\":\"uint256\",\"name\":\"max_output_token_amount\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"referral\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":45994},{\"name\":\"base_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421},{\"name\":\"asset_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451},{\"name\":\"liquidity_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1481},{\"name\":\"ifex_token_contract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1511},{\"name\":\"factory_contract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1541},{\"name\":\"fee_rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1571}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}