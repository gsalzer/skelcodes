{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.6;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'HAPPYHOUR' Staking smart contract\r\n//\r\n// Enter our universe : cocktailbar.finance\r\n//\r\n// Come join the disscussion: https://t.me/cocktailbar_discussion\r\n//\r\n//                                          Sincerely, Mr. Martini\r\n// ----------------------------------------------------------------------------\r\n// ----------------------------------------------------------------------------\r\n// SafeMath library\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n* @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n* checks.\r\n*\r\n* Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n* in bugs, because programmers usually assume that an overflow raises an\r\n* error, which is the standard behavior in high level programming languages.\r\n* `SafeMath` restores this intuition by reverting the transaction when an\r\n* operation overflows.\r\n*\r\n* Using this library instead of the unchecked operations eliminates an entire\r\n* class of bugs, so it's recommended to use it always.\r\n*/\r\nlibrary SafeMath {\r\n   /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Addition cannot overflow.\r\n    */\r\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       uint256 c = a + b;\r\n       require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n       return c;\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Subtraction cannot overflow.\r\n    */\r\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       return sub(a, b, \"SafeMath: subtraction overflow\");\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Subtraction cannot overflow.\r\n    */\r\n   function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n       require(b <= a, errorMessage);\r\n       uint256 c = a - b;\r\n\r\n       return c;\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Multiplication cannot overflow.\r\n    */\r\n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n       // benefit is lost if 'b' is also tested.\r\n       // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n       if (a == 0) {\r\n           return 0;\r\n       }\r\n\r\n       uint256 c = a * b;\r\n       require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n       return c;\r\n   }\r\n\r\n\r\n   /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       return div(a, b, \"SafeMath: division by zero\");\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n   function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n       require(b > 0, errorMessage);\r\n       uint256 c = a / b;\r\n       // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n       return c;\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n   function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       return mod(a, b, \"SafeMath: modulo by zero\");\r\n   }\r\n\r\n   /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts with custom message when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n       require(b != 0, errorMessage);\r\n       return a % b;\r\n   }\r\n\r\n   function ceil(uint a, uint m) internal pure returns (uint r) {\r\n       return (a + m - 1) / m * m;\r\n   }\r\n\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n   bool private _notEntered;\r\n\r\n   constructor () {\r\n       // Storing an initial non-zero value makes deployment a bit more\r\n       // expensive, but in exchange the refund on every call to nonReentrant\r\n       // will be lower in amount. Since refunds are capped to a percetange of\r\n       // the total transaction's gas, it is best to keep them low in cases\r\n       // like this one, to increase the likelihood of the full refund coming\r\n       // into effect.\r\n       _notEntered = true;\r\n   }\r\n\r\n   /**\r\n    * @dev Prevents a contract from calling itself, directly or indirectly.\r\n    * Calling a `nonReentrant` function from another `nonReentrant`\r\n    * function is not supported. It is possible to prevent this from happening\r\n    * by making the `nonReentrant` function external, and make it call a\r\n    * `private` function that does the actual work.\r\n    */\r\n   modifier nonReentrant() {\r\n       // On the first call to nonReentrant, _notEntered will be true\r\n       require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n       // Any calls to nonReentrant after this point will fail\r\n       _notEntered = false;\r\n\r\n       _;\r\n\r\n       // By storing the original value once again, a refund is triggered (see\r\n       // https://eips.ethereum.org/EIPS/eip-2200)\r\n       _notEntered = true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Owned {\r\n   modifier onlyOwner() virtual{\r\n       require(msg.sender==owner);\r\n       _;\r\n   }\r\n   address payable owner;\r\n   address payable newOwner;\r\n   function changeOwner(address payable _newOwner) external onlyOwner {\r\n       require(_newOwner!=address(0));\r\n       newOwner = _newOwner;\r\n   }\r\n   function acceptOwnership() external {\r\n       if (msg.sender==newOwner) {\r\n           owner = newOwner;\r\n       }\r\n   }\r\n}\r\n\r\ninterface ERC20 {\r\n   function balanceOf(address _owner) view external  returns (uint256 balance);\r\n   function transfer(address _to, uint256 _value) external  returns (bool success);\r\n   function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);\r\n   function approve(address _spender, uint256 _value) external returns (bool success);\r\n   function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\r\n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ncontract Token is Owned, ERC20 {\r\n   using SafeMath for uint256;\r\n   uint256 public totalSupply;\r\n   string public symbol;\r\n   string public name;\r\n   uint8 public decimals;\r\n   mapping (address=>uint256) balances;\r\n   mapping (address=>mapping (address=>uint256)) allowed;\r\n   uint256 public rewardfee;\r\n\r\n   event TransferFee(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n   function balanceOf(address _owner) view public override   returns (uint256 balance) {return balances[_owner];}\r\n\r\n   function transfer(address _to, uint256 _amount) public override  returns (bool success) {\r\n       require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\r\n       balances[msg.sender]-=_amount;\r\n\r\n\r\n       uint256 fee = onehalfPercent(_amount);\r\n       uint256 amountto = _amount.sub(fee);\r\n       rewardfee = rewardfee.add(fee);\r\n\r\n       balances[address(this)]+=fee;\r\n       balances[_to]+=amountto;\r\n\r\n\r\n       emit Transfer(msg.sender,_to,amountto);\r\n       emit TransferFee(msg.sender,address(this),fee);\r\n       return true;\r\n   }\r\n\r\n\r\n\r\n   function transferFrom(address _from,address _to,uint256 _amount) public override  returns (bool success) {\r\n       require (balances[_from]>=_amount&&allowed[_from][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\r\n       balances[_from]-=_amount;\r\n       allowed[_from][msg.sender]-=_amount;\r\n\r\n       uint256 fee = onehalfPercent(_amount);\r\n       uint256 amountto = _amount.sub(fee);\r\n\r\n\r\n       rewardfee = rewardfee.add(fee);\r\n       balances[address(this)]+=fee;\r\n       balances[_to]+=amountto;\r\n\r\n\r\n       emit Transfer(msg.sender,_to,amountto);\r\n       emit TransferFee(msg.sender,address(this),fee);\r\n       return true;\r\n   }\r\n\r\n   function approve(address _spender, uint256 _amount) public override  returns (bool success) {\r\n       allowed[msg.sender][_spender]=_amount;\r\n       emit Approval(msg.sender, _spender, _amount);\r\n       return true;\r\n   }\r\n\r\n   function allowance(address _owner, address _spender) view public override  returns (uint256 remaining) {\r\n     return allowed[_owner][_spender];\r\n   }\r\n\r\n       function onehalfPercent(uint256 _tokens) private pure returns (uint256){\r\n       uint256 roundValue = _tokens.ceil(100);\r\n       uint onehalfofTokens = roundValue.mul(100).div(100 * 10**uint(2));\r\n       return onehalfofTokens;\r\n   }\r\n\r\n}\r\n\r\n\r\ncontract Mojito is Token{\r\n   using SafeMath for uint256;\r\n   constructor() {\r\n       symbol = \"MOJITO\";\r\n       name = \"Mojito\";\r\n       decimals = 18;\r\n       totalSupply = 5000000000000000000000;\r\n       owner = msg.sender;\r\n       balances[owner] = totalSupply;\r\n\r\n   }\r\n\r\n   receive () payable external {\r\n       require(msg.value>0);\r\n       owner.transfer(msg.value);\r\n   }\r\n\r\n}\r\n\r\ninterface REWARDTOKEN {\r\n   function balanceOf(address _owner) view external  returns (uint256 balance);\r\n   function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\r\n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n   function transfer(address _to, uint256 _amount) external  returns (bool success);\r\n   function transferFrom(address _from,address _to,uint256 _amount) external  returns (bool success);\r\n   function approve(address _to, uint256 _amount) external  returns (bool success);\r\n   function _mint(address account, uint256 amount) external ;\r\n\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract Stake is Mojito, ReentrancyGuard {\r\n   using SafeMath for uint256;\r\n   address public rewtkn= 0x39FB7AF42ef12D92A0d577ca44cd54a0f24c4915;\r\n   uint256 public totalStakes = 0;\r\n   uint256 stakingFee = 10; // 1%\r\n   uint256 unstakingFee = 30; // 3%\r\n   uint256 public prevreward = 0;\r\n   REWARD  public reward;\r\n\r\n\r\n   struct REWARD\r\n   {\r\n       uint256 rewardstart;\r\n       uint256 rewardend;\r\n       uint256 totalreward;\r\n   }\r\n\r\n   struct USER{\r\n       uint256 stakedTokens;\r\n       uint256 remainder;\r\n       uint256 creationTime;\r\n       uint256 lastClaim;\r\n       uint256 totalEarned;\r\n   }\r\n\r\n   mapping(address => USER) public stakers;\r\n\r\n\r\n   event STAKED(address staker, uint256 tokens, uint256 stakingFee);\r\n   event UNSTAKED(address staker, uint256 tokens, uint256 unstakingFee);\r\n\r\n   event CLAIMEDREWARD(address staker, uint256 reward);\r\n\r\n     constructor() {\r\n       owner=msg.sender;\r\n       reward = REWARD(block.timestamp,block.timestamp + 24 hours,0);\r\n\r\n   }\r\n      modifier onlyOwner() override{\r\n       require(msg.sender==owner,\"only owner can run this\");\r\n       _;\r\n   }\r\n\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Token holders can stake their tokens using this function\r\n   // @param tokens number of tokens to stake\r\n   // ------------------------------------------------------------------------\r\n   function STAKE(uint256 tokens) external nonReentrant {\r\n       require(REWARDTOKEN(rewtkn).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from user account\");\r\n       uint256 _stakingFee = (onePercent(tokens).mul(stakingFee)).div(10);\r\n       reward.totalreward = (reward.totalreward).add(stakingFee);\r\n       stakers[msg.sender].stakedTokens = (tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedTokens);\r\n       stakers[msg.sender].creationTime = block.timestamp;\r\n       totalStakes = totalStakes.add(tokens.sub(_stakingFee));\r\n       emit STAKED(msg.sender, tokens.sub(_stakingFee), _stakingFee);\r\n   }\r\n\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Stakers can claim their pending rewards using this function\r\n   // ------------------------------------------------------------------------\r\n   // ------------------------------------------------------------------------\r\n   // Stakers can unstake the staked tokens using this function\r\n   // @param tokens the number of tokens to withdraw\r\n   // ------------------------------------------------------------------------\r\n   function WITHDRAW(uint256 tokens) external nonReentrant {\r\n\r\n       require(stakers[msg.sender].stakedTokens >= tokens && tokens > 0, \"Invalid token amount to withdraw\");\r\n\r\n       uint256 _unstakingFee = (onePercent(tokens).mul(unstakingFee)).div(10);\r\n\r\n       // add pending rewards to remainder to be claimed by user later, if there is any existing stake\r\n\r\n\r\n       reward.totalreward = (reward.totalreward).add(_unstakingFee);\r\n       require(REWARDTOKEN(rewtkn).transfer(msg.sender, tokens.sub(_unstakingFee)), \"Error in un-staking tokens\");\r\n\r\n       stakers[msg.sender].stakedTokens = stakers[msg.sender].stakedTokens.sub(tokens);\r\n\r\n       if (stakers[msg.sender].stakedTokens == 0)\r\n       {\r\n           stakers[msg.sender].creationTime = block.timestamp ;\r\n       }\r\n       totalStakes = totalStakes.sub(tokens);\r\n       emit UNSTAKED(msg.sender, tokens.sub(_unstakingFee), _unstakingFee);\r\n\r\n\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Private function to calculate 1% percentage\r\n   // ------------------------------------------------------------------------\r\n   function onePercent(uint256 _tokens) private pure returns (uint256){\r\n       uint256 roundValue = _tokens.ceil(100);\r\n       uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2));\r\n       return onePercentofTokens;\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Get the number of tokens staked by a staker\r\n   // @param _staker the address of the staker\r\n   // ------------------------------------------------------------------------\r\n   function yourStakedREWARDTOKEN(address staker) external view returns(uint256 stakedTOKEN){\r\n       return stakers[staker].stakedTokens;\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Get the TOKEN balance of the token holder\r\n   // @param user the address of the token holder\r\n   // ------------------------------------------------------------------------\r\n   function yourREWARDTOKENBalance(address user) external view returns(uint256 TOKENBalance){\r\n       return REWARDTOKEN(rewtkn).balanceOf(user);\r\n   }\r\n\r\n   function CurrEsstematedRew(address user) external view returns (uint256 MojitoReward)\r\n   {\r\n\r\n       if(stakers[user].stakedTokens >0)\r\n       {\r\n\r\n          uint256 time = block.timestamp - reward.rewardstart;\r\n          uint256 hour=time.div(3600);\r\n          uint256 newrewardstarttime=reward.rewardstart;\r\n\r\n       while(hour >= 24) //alligning days with outer clock\r\n       {\r\n           newrewardstarttime = newrewardstarttime.add(24 hours) ;\r\n           time = block.timestamp - newrewardstarttime;\r\n           hour=time.div(3600);\r\n\r\n       }\r\n\r\n         if(stakers[user].lastClaim == newrewardstarttime)\r\n         {\r\n             return 0;\r\n         }else{\r\n\r\n           uint256 prevrewards=0;\r\n            if(prevreward == 0 )\r\n           {\r\n               prevrewards = rewardfee;\r\n           }\r\n\r\n           uint256 Cstaked = (stakers[user].stakedTokens).mul(10000000000);\r\n           uint256 CTS = totalStakes.mul(10000000000);\r\n           uint256 percent = (Cstaked.mul(prevrewards));\r\n           uint256 rewardcal =  percent.div(CTS);\r\n\r\n\r\n            if(newrewardstarttime < stakers[user].creationTime) //how mch difference\r\n            {\r\n\r\n           time =  stakers[user].creationTime - newrewardstarttime;\r\n           uint256 stketime = time.div(3600);\r\n\r\n            if(stketime < 20)\r\n           {\r\n            uint256 a = (stketime.mul(10**uint(2))).div(20);\r\n            uint256 finalreward =  (a.mul(rewardcal)).div(10**uint(2));\r\n\r\n            if(rewardfee >= rewardcal)\r\n            {\r\n\r\n                return finalreward;\r\n            }else{\r\n                return 0;\r\n            }\r\n\r\n\r\n           }else\r\n           {\r\n               if(rewardfee >= rewardcal )\r\n               {\r\n                    return rewardcal;\r\n               }\r\n               else\r\n               {\r\n                   return 0;\r\n               }\r\n\r\n           }\r\n\r\n\r\n            }else{\r\n                  if(rewardfee >= rewardcal )\r\n               {\r\n                    return rewardcal;\r\n               }else\r\n               {\r\n                   return 0;\r\n               }\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n         }\r\n\r\n\r\n\r\n\r\n\r\n\r\n       }else\r\n       {\r\n           return 0;\r\n       }\r\n\r\n   }\r\n\r\n\r\n\r\n   function CLAIMREWARD() external  {\r\n\r\n\r\n       uint256 time = block.timestamp - reward.rewardstart;\r\n       uint256 hour=time.div(3600);\r\n\r\n\r\n\r\n       if(hour >= 24)\r\n       {\r\n           prevreward = 0;\r\n       }\r\n       while(hour >= 24) //alligning days with outer clock\r\n       {\r\n           reward.rewardstart = reward.rewardstart.add(24 hours) ;\r\n           time = block.timestamp - reward.rewardstart;\r\n           hour=time.div(3600);\r\n\r\n       }\r\n\r\n       require(stakers[msg.sender].lastClaim != reward.rewardstart,\"You have Already Claimed\");\r\n       {\r\n\r\n       //this line is basically  checking which hour is currently user trying to claim (can only claim at hour 20 - 24 )\r\n       time  = (block.timestamp).sub(reward.rewardstart) ;  //now can be greater than rewardend\r\n       uint256 rewhour = time.div(3600);\r\n       if((rewhour < 24) && (rewhour >= 20))  // checking if person is illigebal for reward\r\n       {\r\n\r\n           if(prevreward == 0 )\r\n           {\r\n               prevreward = rewardfee;\r\n           }\r\n\r\n\r\n           //calculating percent of staked tokens user has in the total pool\r\n           uint256 Cstaked = (stakers[msg.sender].stakedTokens).mul(10000000000);\r\n           uint256 CTS = totalStakes.mul(10000000000);\r\n           uint256 percent = (Cstaked.mul(prevreward));\r\n           uint256 rewardcal =  percent.div(CTS);\r\n\r\n\r\n            if(reward.rewardstart < stakers[msg.sender].creationTime) //how mch difference\r\n            {\r\n\r\n           time =  stakers[msg.sender].creationTime - reward.rewardstart;\r\n           uint256 stketime = time.div(3600);\r\n\r\n           //checking what was the stake time of the user. User should not get all amount if his stake time is less than 20 hours\r\n           //will change wif we go with starttime\r\n\r\n           //checktime\r\n           if(stketime < 20)\r\n           {\r\n            uint256 a = (stketime.mul(10**uint(2))).div(20);\r\n            uint256 finalreward =  (a.mul(rewardcal)).div(10**uint(2));\r\n\r\n            if(rewardfee >= rewardcal)\r\n            {\r\n              Mojito(address(this)).transfer(msg.sender,finalreward);\r\n             rewardfee = rewardfee.sub(finalreward);\r\n             stakers[msg.sender].lastClaim = reward.rewardstart;\r\n             stakers[msg.sender].totalEarned = (stakers[msg.sender].totalEarned).add(finalreward);\r\n             emit CLAIMEDREWARD(msg.sender,finalreward);\r\n            }\r\n\r\n\r\n           }else\r\n           {\r\n               if(rewardfee >= rewardcal )\r\n               {\r\n                    Mojito(address(this)).transfer(msg.sender,rewardcal);\r\n                      rewardfee = rewardfee.sub(rewardcal);\r\n                       stakers[msg.sender].lastClaim = reward.rewardstart;\r\n                        stakers[msg.sender].totalEarned = (stakers[msg.sender].totalEarned).add(rewardcal);\r\n                      emit CLAIMEDREWARD(msg.sender,rewardcal);\r\n\r\n               }\r\n\r\n           }\r\n\r\n\r\n            }else{\r\n                  if(rewardfee >= rewardcal )\r\n               {\r\n                    Mojito(address(this)).transfer(msg.sender,rewardcal);\r\n                      rewardfee = rewardfee.sub(rewardcal);\r\n                        stakers[msg.sender].lastClaim = reward.rewardstart ;\r\n                           stakers[msg.sender].totalEarned = (stakers[msg.sender].totalEarned).add(rewardcal);\r\n                     emit CLAIMEDREWARD(msg.sender,rewardcal);\r\n\r\n               }\r\n\r\n            }\r\n\r\n\r\n\r\n       }\r\n\r\n       }\r\n\r\n       reward.rewardend = reward.rewardstart + 24 hours;\r\n\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   function WatchClaimTime() public  view  returns (uint ClaimTimeHours)\r\n   {\r\n\r\n\r\n\r\n       uint256 time  = block.timestamp - reward.rewardstart;\r\n       uint rewhour = time.div(3600);\r\n       return rewhour;\r\n\r\n\r\n   }\r\n\r\n\r\n\r\n    function WatchClaimTimeMins() public view returns (uint ClaimTimeHours)\r\n   {\r\n\r\n           uint256 time  = block.timestamp - reward.rewardstart;\r\n           uint rewhour = time.div(1);\r\n           return rewhour;\r\n\r\n\r\n   }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CLAIMEDREWARD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingFee\",\"type\":\"uint256\"}],\"name\":\"STAKED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakingFee\",\"type\":\"uint256\"}],\"name\":\"UNSTAKED\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLAIMREWARD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"CurrEsstematedRew\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"MojitoReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"STAKE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"WITHDRAW\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WatchClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ClaimTimeHours\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WatchClaimTimeMins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ClaimTimeHours\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prevreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardstart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalreward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewtkn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"yourREWARDTOKENBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"TOKENBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"yourStakedREWARDTOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedTOKEN\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Stake","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6ca75905dd6a63cb654e5c58e9e9659912d79066a7b8c1b9c3b3c7c41a4c67b3"}]}