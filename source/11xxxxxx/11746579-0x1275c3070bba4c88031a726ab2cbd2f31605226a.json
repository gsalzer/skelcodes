{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"approve\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"transfer\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"transferFrom\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"symbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"decimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"name\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"balanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"allowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\\"send\\\");\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"No payable\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOPool2.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\nimport \\u0027./ACOAssetHelper.sol\\u0027;\\r\\nimport \\u0027./ACOPoolLib.sol\\u0027;\\r\\nimport \\u0027./ERC20.sol\\u0027;\\r\\nimport \\u0027./IACOFactory.sol\\u0027;\\r\\nimport \\u0027./IACOAssetConverterHelper.sol\\u0027;\\r\\nimport \\u0027./IACOToken.sol\\u0027;\\r\\nimport \\u0027./IChiToken.sol\\u0027;\\r\\nimport \\u0027./IACOPool2.sol\\u0027;\\r\\nimport \\u0027./ILendingPool.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOPool2\\r\\n * @dev A pool contract to trade ACO tokens.\\r\\n * \\r\\n * The SC errors are defined as code to shrunk the SC bytes size and work around the EIP170.\\r\\n * The codes are explained in the table below:\\r\\n ********************************************************************************************\\r\\n * CODE | FUNCTION                            | DESCRIPTION\\t\\t\\t\\t\\t\\t            *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E00  | init                                | SC is already initialized                   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E01  | init                                | Invalid ACO Factory address                 *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E02  | init                                | Invalid Chi Token address                   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E03  | init                                | Invalid lending pool address                *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E04  | init                                | Underlying and strike asset are the same    *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E05  | init                                | Invalid underlying address                  *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E06  | init                                | Invalid strike asset address                *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E10  | _deposit                            | Invalid collateral amount                   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E11  | _deposit                            | Invalid destination address                 *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E12  | _deposit                            | Invalid deposit for lending pool token      *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E13  | _deposit                            | The minimum shares were not satisfied       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E20  | _withdrawWithLocked                 | Invalid shares amount                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E21  | _withdrawWithLocked                 | Invalid withdraw for lending pool token     *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E30  | _withdrawNoLocked                   | Invalid shares amount                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E31  | _withdrawNoLocked                   | Invalid withdraw for lending pool token     *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E40  | _swap                               | Swap deadline reached                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E41  | _swap                               | Invalid destination address                 *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E42  | _internalSelling                    | The maximum payment restriction was reached *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E43  | _internalSelling                    | The maximum number of open ACOs was reached *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E50  | _quote                              | Invalid token amount                        *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E51  | _quote                              | Invalid ACO token                           *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E60  | restoreCollateral                   | No balance to restore                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E70  | lendCollateral                      | Lend is not available for this pool         *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E80  | withdrawStuckToken                  | The token is forbidden to withdraw          *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E81  | _setStrategy                        | Invalid strategy address                    *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E82  | _setBaseVolatility                  | Invalid base volatility                     *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E83  | _setAssetConverter                  | No price on the Oracle                      *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E84  | _setPoolDataForAcoPermission        | Invalid below tolerance percentage          *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E85  | _setPoolDataForAcoPermission        | Invalid above tolerance percentage          *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E86  | _setPoolDataForAcoPermission        | Invalid expiration range                    *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E87  | _setFeeData                         | Invalid fee destination address             *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E88  | _setFeeData                         | Invalid fee value                           *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E89  | _setWithdrawOpenPositionPenalty     | Invalid penalty percentage                  *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E90  | _setUnderlyingPriceAdjustPercentage | Invalid underlying price adjust percentage  *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E91  | _setMaximumOpenAco                  | Invalid maximum number of open ACOs allowed *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E99  | onlyFactory                         | Only the pool factory can call the method   *\\r\\n ********************************************************************************************\\r\\n */\\r\\ncontract ACOPool2 is Ownable, ERC20 {\\r\\n    using Address for address;\\r\\n    \\r\\n    uint256 internal constant PERCENTAGE_PRECISION = 100000;\\r\\n\\r\\n    event SetLendingPoolReferral(uint256 indexed oldLendingPoolReferral, uint256 indexed newLendingPoolReferral);\\r\\n\\r\\n    event SetAssetConverter(address indexed oldAssetConverter, address indexed newAssetConverter);\\r\\n    \\r\\n    event SetPoolDataForAcoPermission(uint256 oldTolerancePriceBelow, uint256 oldTolerancePriceAbove, uint256 oldMinExpiration, uint256 oldMaxExpiration, uint256 newTolerancePriceBelow, uint256 newTolerancePriceAbove, uint256 newMinExpiration, uint256 newMaxExpiration);\\r\\n\\r\\n\\tevent SetWithdrawOpenPositionPenalty(uint256 indexed oldWithdrawOpenPositionPenalty, uint256 indexed newWithdrawOpenPositionPenalty);\\r\\n\\r\\n\\tevent SetUnderlyingPriceAdjustPercentage(uint256 indexed oldUnderlyingPriceAdjustPercentage, uint256 indexed newUnderlyingPriceAdjustPercentage);\\r\\n\\r\\n\\tevent SetMaximumOpenAco(uint256 indexed oldMaximumOpenAco, uint256 indexed newMaximumOpenAco);\\r\\n\\r\\n    event SetFeeData(address oldFeeDestination, uint256 oldFee, address newFeeDestination, uint256 newFee);\\r\\n\\r\\n    event SetValidAcoCreator(address indexed creator, bool indexed previousPermission, bool indexed newPermission);\\r\\n\\r\\n\\tevent SetStrategy(address indexed oldStrategy, address indexed newStrategy);\\r\\n\\r\\n    event SetBaseVolatility(uint256 indexed oldBaseVolatility, uint256 indexed newBaseVolatility);\\r\\n\\r\\n    event RestoreCollateral(uint256 amountOut, uint256 collateralRestored);\\r\\n\\r\\n    event LendCollateral(uint256 collateralAmount);\\r\\n\\r\\n\\tevent ACORedeem(address indexed acoToken, uint256 valueSold, uint256 collateralLocked, uint256 collateralRedeemed);\\r\\n\\r\\n    event Deposit(address indexed account, uint256 shares, uint256 collateralAmount);\\r\\n\\r\\n    event Withdraw(\\r\\n\\t\\taddress indexed account, \\r\\n\\t\\tuint256 shares, \\r\\n\\t\\tbool noLocked, \\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\taddress[] acos, \\r\\n\\t\\tuint256[] acosAmount\\r\\n\\t);\\r\\n\\r\\n\\tevent Swap(\\r\\n        address indexed account, \\r\\n        address indexed acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 price, \\r\\n        uint256 protocolFee,\\r\\n        uint256 underlyingPrice,\\r\\n\\t\\tuint256 volatility\\r\\n    );\\r\\n\\r\\n    IACOFactory public acoFactory;\\r\\n\\tIChiToken public chiToken;\\r\\n\\tILendingPool public lendingPool;\\r\\n    address public underlying;\\r\\n    address public strikeAsset;\\r\\n    bool public isCall;\\r\\n\\r\\n    IACOAssetConverterHelper public assetConverter;\\r\\n\\taddress public strategy;\\r\\n\\tuint16 public lendingPoolReferral;\\r\\n\\taddress public feeDestination;\\r\\n    uint256 public baseVolatility;\\r\\n    uint256 public tolerancePriceAbove;\\r\\n    uint256 public tolerancePriceBelow;\\r\\n    uint256 public minExpiration;\\r\\n    uint256 public maxExpiration;\\r\\n    uint256 public fee;\\r\\n\\tuint256 public withdrawOpenPositionPenalty;\\r\\n\\tuint256 public underlyingPriceAdjustPercentage;\\r\\n\\tuint256 public maximumOpenAco;\\r\\n\\r\\n    address[] public acoTokens;\\r\\n    address[] public openAcos;\\r\\n\\r\\n    mapping(address =\\u003e bool) public validAcoCreators;\\r\\n    mapping(address =\\u003e IACOPool2.AcoData) public acoData;\\r\\n\\r\\n    address internal lendingToken;\\r\\n\\tuint256 internal underlyingPrecision;\\r\\n\\r\\n\\tmodifier discountCHI {\\r\\n        uint256 gasStart = gasleft();\\r\\n        _;\\r\\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\\r\\n        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\\r\\n    }\\r\\n\\r\\n    function init(IACOPool2.InitData calldata initData) external {\\r\\n\\t\\trequire(underlying == address(0) \\u0026\\u0026 strikeAsset == address(0), \\\"E00\\\");\\r\\n        \\r\\n        require(initData.acoFactory.isContract(), \\\"E01\\\");\\r\\n        require(initData.chiToken.isContract(), \\\"E02\\\");\\r\\n        require(initData.lendingPool.isContract(), \\\"E03\\\");\\r\\n        require(initData.underlying != initData.strikeAsset, \\\"E04\\\");\\r\\n        require(ACOAssetHelper._isEther(initData.underlying) || initData.underlying.isContract(), \\\"E05\\\");\\r\\n        require(ACOAssetHelper._isEther(initData.strikeAsset) || initData.strikeAsset.isContract(), \\\"E06\\\");\\r\\n        \\r\\n        super.init();\\r\\n\\r\\n        acoFactory = IACOFactory(initData.acoFactory);\\r\\n        chiToken = IChiToken(initData.chiToken);\\r\\n        lendingPool = ILendingPool(initData.lendingPool);\\r\\n        underlying = initData.underlying;\\r\\n        strikeAsset = initData.strikeAsset;\\r\\n        isCall = initData.isCall;\\r\\n\\t\\t\\r\\n\\t\\t_setLendingPoolReferral(initData.lendingPoolReferral);\\r\\n        _setAssetConverter(initData.assetConverter);\\r\\n        _setFeeData(initData.feeDestination, initData.fee);\\r\\n\\t\\t_setWithdrawOpenPositionPenalty(initData.withdrawOpenPositionPenalty);\\r\\n\\t\\t_setUnderlyingPriceAdjustPercentage(initData.underlyingPriceAdjustPercentage);\\r\\n\\t\\t_setPoolDataForAcoPermission(initData.tolerancePriceBelow, initData.tolerancePriceAbove, initData.minExpiration, initData.maxExpiration);\\r\\n        _setMaximumOpenAco(initData.maximumOpenAco);\\r\\n        _setStrategy(initData.strategy);\\r\\n        _setBaseVolatility(initData.baseVolatility);\\r\\n\\t\\t\\r\\n\\t\\tif (!initData.isCall) {\\r\\n\\t\\t    lendingToken = ILendingPool(initData.lendingPool).getReserveData(initData.strikeAsset).aTokenAddress;\\r\\n            _setAuthorizedSpender(initData.strikeAsset, initData.lendingPool);\\r\\n        }\\r\\n\\t\\tunderlyingPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(initData.underlying));\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n    }\\r\\n\\r\\n    function name() public override view returns(string memory) {\\r\\n        return ACOPoolLib.name(underlying, strikeAsset, isCall);\\r\\n    }\\r\\n\\r\\n\\tfunction symbol() public override view returns(string memory) {\\r\\n        return name();\\r\\n    }\\r\\n\\r\\n    function decimals() public override view returns(uint8) {\\r\\n        return ACOAssetHelper._getAssetDecimals(collateral());\\r\\n    }\\r\\n\\r\\n    function numberOfAcoTokensNegotiated() external view returns(uint256) {\\r\\n        return acoTokens.length;\\r\\n    }\\r\\n\\r\\n    function numberOfOpenAcoTokens() external view returns(uint256) {\\r\\n        return openAcos.length;\\r\\n    }\\r\\n\\r\\n\\tfunction collateral() public view returns(address) {\\r\\n        return (isCall ? underlying : strikeAsset);\\r\\n    }\\r\\n\\r\\n    function canSwap(address acoToken) external view returns(bool) {\\r\\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime) = acoFactory.acoTokenData(acoToken);\\r\\n\\t\\tif (_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall) \\u0026\\u0026 \\r\\n\\t\\t    ACOPoolLib.acoExpirationIsValid(_expiryTime, minExpiration, maxExpiration)) {\\r\\n            uint256 price = _getPrice(_underlying, _strikeAsset);\\r\\n            return ACOPoolLib.acoStrikePriceIsValid(tolerancePriceBelow, tolerancePriceAbove, _strikePrice, price);\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n\\tfunction quote(address acoToken, uint256 tokenAmount) external view returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 underlyingPrice, \\r\\n        uint256 volatility\\r\\n    ) {\\r\\n        (swapPrice, protocolFee, underlyingPrice, volatility,) = _quote(acoToken, tokenAmount);\\r\\n    }\\r\\n\\r\\n\\tfunction getDepositShares(uint256 collateralAmount) external view returns(uint256) {\\r\\n        (,,uint256 collateralBalance,) = _getCollateralNormalized(true);\\r\\n\\r\\n        if (collateralBalance == 0) {\\r\\n            return collateralAmount;\\r\\n        } else {\\r\\n            return collateralAmount.mul(totalSupply()).div(collateralBalance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\tfunction getWithdrawNoLockedData(uint256 shares) external view returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\tbool isPossible\\r\\n    ) {\\r\\n        uint256 _totalSupply = totalSupply();\\r\\n\\t\\tif (shares \\u003e 0 \\u0026\\u0026 shares \\u003c= _totalSupply) {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t(uint256 underlyingBalance, \\r\\n             uint256 strikeAssetBalance, \\r\\n             uint256 collateralBalance, \\r\\n             uint256 collateralLockedRedeemable) = _getCollateralNormalized(false);\\r\\n             \\r\\n            (underlyingWithdrawn, strikeAssetWithdrawn, isPossible) = ACOPoolLib.getBaseWithdrawNoLockedData(\\r\\n                shares,\\r\\n                _totalSupply,\\r\\n                isCall,\\r\\n                underlyingBalance, \\r\\n                strikeAssetBalance, \\r\\n                collateralBalance, \\r\\n                collateralLockedRedeemable\\r\\n            );\\r\\n\\t\\t}\\r\\n    }\\r\\n\\r\\n\\tfunction getWithdrawWithLocked(uint256 shares) external view returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n    ) {\\r\\n        uint256 _totalSupply = totalSupply();\\t\\r\\n        if (shares \\u003e 0 \\u0026\\u0026 shares \\u003c= _totalSupply) {\\r\\n        \\r\\n            (underlyingWithdrawn, strikeAssetWithdrawn) = ACOPoolLib.getBaseAssetsWithdrawWithLocked(shares, underlying, strikeAsset, isCall, _totalSupply, lendingToken);\\r\\n\\t\\t\\r\\n            acos = new address[](openAcos.length);\\r\\n            acosAmount = new uint256[](openAcos.length);\\r\\n\\t\\t\\tfor (uint256 i = 0; i \\u003c openAcos.length; ++i) {\\r\\n\\t\\t\\t\\taddress acoToken = openAcos[i];\\r\\n\\t\\t\\t\\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tacos[i] = acoToken;\\r\\n\\t\\t\\t\\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n    }\\r\\n\\r\\n\\tfunction getGeneralData() external view returns(\\r\\n        uint256 underlyingBalance,\\r\\n\\t\\tuint256 strikeAssetBalance,\\r\\n\\t\\tuint256 collateralLocked,\\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        (underlyingBalance, strikeAssetBalance,, collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _getCollateralData(true);\\r\\n    }\\r\\n\\r\\n    function setLendingPoolReferral(uint16 newLendingPoolReferral) external {\\r\\n        onlyFactory();\\r\\n        _setLendingPoolReferral(newLendingPoolReferral);\\r\\n    }\\r\\n\\r\\n    function setAssetConverter(address newAssetConverter) external {\\r\\n        onlyFactory();\\r\\n        _setAssetConverter(newAssetConverter);\\r\\n    }\\r\\n    \\r\\n    function setPoolDataForAcoPermission(\\r\\n        uint256 newTolerancePriceBelow, \\r\\n        uint256 newTolerancePriceAbove,\\r\\n        uint256 newMinExpiration,\\r\\n        uint256 newMaxExpiration\\r\\n    ) external {\\r\\n        onlyFactory();\\r\\n        _setPoolDataForAcoPermission(newTolerancePriceBelow, newTolerancePriceAbove, newMinExpiration, newMaxExpiration);\\r\\n    }\\r\\n\\r\\n    function setFeeData(address newFeeDestination, uint256 newFee) external {\\r\\n        onlyFactory();\\r\\n        _setFeeData(newFeeDestination, newFee);\\r\\n    }\\r\\n\\r\\n\\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external {\\r\\n        onlyFactory();\\r\\n\\t\\t_setWithdrawOpenPositionPenalty(newWithdrawOpenPositionPenalty);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external {\\r\\n        onlyFactory();\\r\\n\\t\\t_setUnderlyingPriceAdjustPercentage(newUnderlyingPriceAdjustPercentage);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external {\\r\\n        onlyFactory();\\r\\n\\t\\t_setMaximumOpenAco(newMaximumOpenAco);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setStrategy(address newStrategy) external {\\r\\n        onlyFactory();\\r\\n\\t\\t_setStrategy(newStrategy);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setBaseVolatility(uint256 newBaseVolatility) external {\\r\\n        onlyFactory();\\r\\n\\t\\t_setBaseVolatility(newBaseVolatility);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setValidAcoCreator(address newAcoCreator, bool newPermission) external {\\r\\n        onlyFactory();\\r\\n        _setValidAcoCreator(newAcoCreator, newPermission);\\r\\n    }\\r\\n\\r\\n    function withdrawStuckToken(address token, address destination) external {\\r\\n        onlyFactory();\\r\\n        require(token != underlying \\u0026\\u0026 token != strikeAsset \\u0026\\u0026 !acoData[token].open \\u0026\\u0026 (isCall || token != lendingToken), \\\"E80\\\");\\r\\n        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\\r\\n        if (_balance \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(token, destination, _balance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\tfunction deposit(\\r\\n\\t    uint256 collateralAmount, \\r\\n\\t    uint256 minShares, \\r\\n\\t    address to, \\r\\n\\t    bool isLendingToken\\r\\n    ) external payable returns(uint256) {\\r\\n        return _deposit(collateralAmount, minShares, to, isLendingToken);\\r\\n    }\\r\\n\\r\\n\\tfunction depositWithGasToken(\\r\\n\\t    uint256 collateralAmount, \\r\\n\\t    uint256 minShares, \\r\\n\\t    address to, \\r\\n\\t    bool isLendingToken\\r\\n    ) discountCHI external payable returns(uint256) {\\r\\n        return _deposit(collateralAmount, minShares, to, isLendingToken);\\r\\n    }\\r\\n\\r\\n\\tfunction withdrawNoLocked(\\r\\n\\t    uint256 shares, \\r\\n\\t    uint256 minCollateral, \\r\\n\\t    address account, \\r\\n\\t    bool withdrawLendingToken\\r\\n    ) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account, withdrawLendingToken);\\r\\n    }\\r\\n\\r\\n\\tfunction withdrawNoLockedWithGasToken(\\r\\n\\t    uint256 shares, \\r\\n\\t    uint256 minCollateral, \\r\\n\\t    address account, \\r\\n\\t    bool withdrawLendingToken\\r\\n    ) discountCHI external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account, withdrawLendingToken);\\r\\n    }\\r\\n\\r\\n    function withdrawWithLocked(uint256 shares, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account, withdrawLendingToken);\\r\\n    }\\r\\n\\r\\n\\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account, bool withdrawLendingToken) discountCHI external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account, withdrawLendingToken);\\r\\n    }\\r\\n\\r\\n\\tfunction swap(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) external {\\r\\n        _swap(acoToken, tokenAmount, restriction, to, deadline);\\r\\n    }\\r\\n\\r\\n    function swapWithGasToken(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) discountCHI external {\\r\\n        _swap(acoToken, tokenAmount, restriction, to, deadline);\\r\\n    }\\r\\n\\r\\n    function redeemACOTokens() public {\\r\\n        for (uint256 i = openAcos.length; i \\u003e 0; --i) {\\r\\n            address acoToken = openAcos[i - 1];\\r\\n            redeemACOToken(acoToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\tfunction redeemACOToken(address acoToken) public {\\r\\n\\t\\tIACOPool2.AcoData storage data = acoData[acoToken];\\r\\n\\t\\tif (data.open \\u0026\\u0026 IACOToken(acoToken).expiryTime() \\u003c= block.timestamp) {\\r\\n\\t\\t\\t\\r\\n            data.open = false;\\r\\n\\t\\t\\tuint256 lastIndex = openAcos.length - 1;\\r\\n    \\t\\tuint256 index = data.openIndex;\\r\\n    \\t\\tif (lastIndex != index) {\\r\\n    \\t\\t    address last = openAcos[lastIndex];\\r\\n    \\t\\t\\topenAcos[index] = last;\\r\\n    \\t\\t\\tacoData[last].openIndex = index;\\r\\n    \\t\\t}\\r\\n    \\t\\tdata.openIndex = 0;\\r\\n            openAcos.pop();\\r\\n\\r\\n            if (IACOToken(acoToken).currentCollateralizedTokens(address(this)) \\u003e 0) {\\t\\r\\n\\t\\t\\t    data.collateralRedeemed = IACOToken(acoToken).redeem();\\r\\n\\t\\t\\t    if (!isCall) {\\r\\n\\t\\t\\t        _depositOnLendingPool(data.collateralRedeemed);\\r\\n\\t\\t\\t    }\\r\\n            }\\r\\n\\t\\t\\t\\r\\n\\t\\t\\temit ACORedeem(acoToken, data.valueSold, data.collateralLocked, data.collateralRedeemed);\\r\\n\\t\\t}\\r\\n    }\\r\\n\\r\\n\\tfunction restoreCollateral() external {\\r\\n        uint256 balanceOut;\\r\\n        address assetIn;\\r\\n        address assetOut;\\r\\n        if (isCall) {\\r\\n            balanceOut = _getPoolBalanceOf(strikeAsset);\\r\\n            assetIn = underlying;\\r\\n            assetOut = strikeAsset;\\r\\n        } else {\\r\\n            balanceOut = _getPoolBalanceOf(underlying);\\r\\n            assetIn = strikeAsset;\\r\\n            assetOut = underlying;\\r\\n        }\\r\\n        require(balanceOut \\u003e 0, \\\"E60\\\");\\r\\n        \\r\\n\\t\\tuint256 etherAmount = 0;\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n\\t\\t\\tetherAmount = balanceOut;\\r\\n        }\\r\\n        uint256 collateralRestored = assetConverter.swapExactAmountOut{value: etherAmount}(assetOut, assetIn, balanceOut);\\r\\n        if (!isCall) {\\r\\n            _depositOnLendingPool(collateralRestored);\\r\\n        }\\r\\n\\r\\n        emit RestoreCollateral(balanceOut, collateralRestored);\\r\\n    }\\r\\n\\r\\n\\tfunction lendCollateral() external {\\r\\n\\t\\trequire(!isCall, \\\"E70\\\");\\r\\n\\t    uint256 strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t    if (strikeAssetBalance \\u003e 0) {\\r\\n\\t        _depositOnLendingPool(strikeAssetBalance);\\r\\n\\t        emit LendCollateral(strikeAssetBalance);\\r\\n\\t    }\\r\\n    }\\r\\n\\r\\n\\tfunction _deposit(\\r\\n\\t    uint256 collateralAmount, \\r\\n\\t    uint256 minShares, \\r\\n\\t    address to,\\r\\n\\t    bool isLendingToken\\r\\n    ) internal returns(uint256 shares) {\\r\\n        require(collateralAmount \\u003e 0, \\\"E10\\\");\\r\\n        require(to != address(0) \\u0026\\u0026 to != address(this), \\\"E11\\\");\\r\\n        require(!isLendingToken || !isCall, \\\"E12\\\");\\r\\n\\t\\t\\r\\n\\t\\t(,,uint256 collateralBalance,) = _getCollateralNormalized(true);\\r\\n\\r\\n\\t\\taddress _collateral = collateral();\\r\\n\\t\\tif (ACOAssetHelper._isEther(_collateral)) {\\r\\n            collateralBalance = collateralBalance.sub(msg.value);\\r\\n\\t\\t}\\r\\n        \\r\\n        if (collateralBalance == 0) {\\r\\n            shares = collateralAmount;\\r\\n        } else {\\r\\n            shares = collateralAmount.mul(totalSupply()).div(collateralBalance);\\r\\n        }\\r\\n        require(shares \\u003e= minShares, \\\"E13\\\");\\r\\n\\r\\n        if (isLendingToken) {\\r\\n            ACOAssetHelper._receiveAsset(lendingToken, collateralAmount);\\r\\n        } else {\\r\\n            ACOAssetHelper._receiveAsset(_collateral, collateralAmount);\\r\\n            if (!isCall) {\\r\\n                _depositOnLendingPool(collateralAmount);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        super._mintAction(to, shares);\\r\\n        \\r\\n        emit Deposit(to, shares, collateralAmount);\\r\\n    }\\r\\n\\r\\n    function _withdrawNoLocked(\\r\\n        uint256 shares, \\r\\n        uint256 minCollateral, \\r\\n        address account, \\r\\n        bool withdrawLendingToken\\r\\n    ) internal returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        require(shares \\u003e 0, \\\"E30\\\");\\r\\n        bool _isCall = isCall;\\r\\n        require(!withdrawLendingToken || !_isCall, \\\"E31\\\");\\r\\n        \\r\\n\\t\\tredeemACOTokens();\\r\\n\\t\\t\\r\\n        uint256 _totalSupply = totalSupply();\\r\\n        _callBurn(account, shares);\\r\\n        \\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _getAmountToNoLockedWithdraw(shares, _totalSupply, minCollateral, _isCall);\\r\\n        \\r\\n        _transferWithdrawnAssets(underlyingWithdrawn, strikeAssetWithdrawn, withdrawLendingToken);\\r\\n\\t\\t\\r\\n        emit Withdraw(account, shares, true, underlyingWithdrawn, strikeAssetWithdrawn, new address[](0), new uint256[](0));\\r\\n    }\\r\\n\\r\\n\\tfunction _withdrawWithLocked(uint256 shares, address account, bool withdrawLendingToken) internal returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        require(shares \\u003e 0, \\\"E20\\\");\\r\\n        require(!withdrawLendingToken || !isCall, \\\"E21\\\");\\r\\n        \\r\\n\\t\\tredeemACOTokens();\\r\\n\\t\\t\\r\\n        uint256 _totalSupply = totalSupply();\\r\\n        _callBurn(account, shares);\\r\\n        \\r\\n\\t\\t(underlyingWithdrawn, strikeAssetWithdrawn) = ACOPoolLib.getAmountToLockedWithdraw(shares, _totalSupply, lendingToken, underlying, strikeAsset, isCall);\\r\\n\\t\\t\\r\\n\\t\\t(acos, acosAmount) = _transferOpenPositions(shares, _totalSupply);\\r\\n\\r\\n\\t\\t_transferWithdrawnAssets(underlyingWithdrawn, strikeAssetWithdrawn, withdrawLendingToken);\\r\\n\\r\\n        emit Withdraw(account, shares, false, underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount);\\r\\n    }\\r\\n\\r\\n    function _transferWithdrawnAssets(\\r\\n        uint256 underlyingWithdrawn, \\r\\n        uint256 strikeAssetWithdrawn, \\r\\n        bool withdrawLendingToken\\r\\n    ) internal {\\r\\n        if (strikeAssetWithdrawn \\u003e 0) {\\r\\n            if (withdrawLendingToken) {\\r\\n    \\t\\t    ACOAssetHelper._transferAsset(lendingToken, msg.sender, strikeAssetWithdrawn);\\r\\n    \\t\\t} else if (isCall) {\\r\\n    \\t\\t    ACOAssetHelper._transferAsset(strikeAsset, msg.sender, strikeAssetWithdrawn);\\r\\n    \\t\\t} else {\\r\\n    \\t\\t    _withdrawOnLendingPool(strikeAssetWithdrawn, msg.sender);\\r\\n    \\t\\t}\\r\\n        }\\r\\n        if (underlyingWithdrawn \\u003e 0) {\\r\\n\\t\\t    ACOAssetHelper._transferAsset(underlying, msg.sender, underlyingWithdrawn);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\tfunction _getCollateralNormalized(bool isDeposit) internal view returns(\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        uint256 collateralLocked;\\r\\n        uint256 collateralOnOpenPosition;\\r\\n        (underlyingBalance, strikeAssetBalance, collateralBalance, collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _getCollateralData(isDeposit);\\r\\n        collateralBalance = collateralBalance.add(collateralLocked).sub(collateralOnOpenPosition);\\r\\n    }\\r\\n\\r\\n\\tfunction _getCollateralData(bool isDeposit) internal view returns(\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance,\\r\\n        uint256 collateralLocked,\\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n\\t\\tuint256 underlyingPrice = _getPrice(underlying, strikeAsset);\\r\\n\\t\\t(underlyingBalance, strikeAssetBalance, collateralBalance) = _getBaseCollateralData(underlyingPrice, isDeposit);\\r\\n\\t\\t(collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _poolOpenPositionCollateralBalance(underlyingPrice, isDeposit);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _getBaseCollateralData(\\r\\n\\t    uint256 underlyingPrice,\\r\\n\\t    bool isDeposit\\r\\n\\t) internal view returns(\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance\\r\\n    ) {\\r\\n        (underlyingBalance, strikeAssetBalance, collateralBalance) = ACOPoolLib.getBaseCollateralData(\\r\\n            lendingToken,\\r\\n            underlying, \\r\\n            strikeAsset, \\r\\n            isCall, \\r\\n            underlyingPrice, \\r\\n            underlyingPriceAdjustPercentage, \\r\\n            underlyingPrecision, \\r\\n            isDeposit\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\tfunction _poolOpenPositionCollateralBalance(uint256 underlyingPrice, bool isDeposit) internal view returns(\\r\\n        uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        ACOPoolLib.OpenPositionData memory openPositionData = ACOPoolLib.OpenPositionData(\\r\\n            underlyingPrice,\\r\\n            baseVolatility,\\r\\n            underlyingPriceAdjustPercentage,\\r\\n            underlyingPrecision,\\r\\n            strategy,\\r\\n            address(acoFactory),\\r\\n            address(0)\\r\\n        );\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c openAcos.length; ++i) {\\r\\n\\t\\t\\taddress acoToken = openAcos[i];\\r\\n            \\r\\n            openPositionData.acoToken = acoToken;\\r\\n            (uint256 locked, uint256 openPosition, uint256 lockedRedeemable) = ACOPoolLib.getOpenPositionCollateralBalance(openPositionData);\\r\\n            \\r\\n            collateralLocked = collateralLocked.add(locked);\\r\\n            collateralOnOpenPosition = collateralOnOpenPosition.add(openPosition);\\r\\n            collateralLockedRedeemable = collateralLockedRedeemable.add(lockedRedeemable);\\r\\n\\t\\t}\\r\\n\\t\\tif (!isDeposit) {\\r\\n\\t\\t\\tcollateralOnOpenPosition = collateralOnOpenPosition.mul(PERCENTAGE_PRECISION.add(withdrawOpenPositionPenalty)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n    \\r\\n    function _getAmountToNoLockedWithdraw(\\r\\n        uint256 shares, \\r\\n        uint256 _totalSupply, \\r\\n        uint256 minCollateral,\\r\\n        bool _isCall\\r\\n    ) internal view returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        (uint256 underlyingBalance, \\r\\n         uint256 strikeAssetBalance, \\r\\n         uint256 collateralBalance,) = _getCollateralNormalized(false);\\r\\n\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn) = ACOPoolLib.getAmountToNoLockedWithdraw(shares, _totalSupply, underlyingBalance, strikeAssetBalance, collateralBalance, minCollateral, _isCall);\\r\\n    }\\r\\n\\r\\n\\tfunction _callBurn(address account, uint256 tokenAmount) internal {\\r\\n        if (account == msg.sender) {\\r\\n            super._burnAction(account, tokenAmount);\\r\\n        } else {\\r\\n            super._burnFrom(account, tokenAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\tfunction _swap(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        require(block.timestamp \\u003c= deadline, \\\"E40\\\");\\r\\n        require(to != address(0) \\u0026\\u0026 to != acoToken \\u0026\\u0026 to != address(this), \\\"E41\\\");\\r\\n        \\r\\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice, uint256 volatility, uint256 collateralAmount) = _quote(acoToken, tokenAmount);\\r\\n        \\r\\n        _internalSelling(to, acoToken, collateralAmount, tokenAmount, restriction, swapPrice, protocolFee);\\r\\n\\r\\n        if (protocolFee \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(strikeAsset, feeDestination, protocolFee);\\r\\n        }\\r\\n        \\r\\n        emit Swap(msg.sender, acoToken, tokenAmount, swapPrice, protocolFee, underlyingPrice, volatility);\\r\\n    }\\r\\n\\r\\n\\tfunction _quote(address acoToken, uint256 tokenAmount) internal view returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 underlyingPrice, \\r\\n        uint256 volatility, \\r\\n        uint256 collateralAmount\\r\\n    ) {\\r\\n        require(tokenAmount \\u003e 0, \\\"E50\\\");\\r\\n        \\r\\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 strikePrice, uint256 expiryTime) = acoFactory.acoTokenData(acoToken);\\r\\n        \\r\\n\\t\\trequire(_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall), \\\"E51\\\");\\r\\n\\t\\t\\r\\n\\t\\tunderlyingPrice = _getPrice(_underlying, _strikeAsset);\\r\\n\\t\\t\\r\\n        (swapPrice, protocolFee, volatility, collateralAmount) = ACOPoolLib.quote(ACOPoolLib.QuoteData(\\r\\n    \\t\\t_isCall,\\r\\n            tokenAmount, \\r\\n    \\t\\t_underlying,\\r\\n    \\t\\t_strikeAsset,\\r\\n    \\t\\tstrikePrice, \\r\\n    \\t\\texpiryTime, \\r\\n    \\t\\tlendingToken,\\r\\n    \\t\\tstrategy,\\r\\n    \\t\\tbaseVolatility,\\r\\n    \\t\\tfee,\\r\\n    \\t\\tminExpiration,\\r\\n    \\t\\tmaxExpiration,\\r\\n    \\t\\ttolerancePriceBelow,\\r\\n    \\t\\ttolerancePriceAbove,\\r\\n    \\t\\tunderlyingPrice,\\r\\n    \\t\\tunderlyingPrecision));\\r\\n    }\\r\\n\\r\\n    function _internalSelling(\\r\\n        address to,\\r\\n        address acoToken, \\r\\n        uint256 collateralAmount, \\r\\n        uint256 tokenAmount,\\r\\n        uint256 maxPayment,\\r\\n        uint256 swapPrice,\\r\\n        uint256 protocolFee\\r\\n    ) internal {\\r\\n        require(swapPrice \\u003c= maxPayment, \\\"E42\\\");\\r\\n        \\r\\n        ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), swapPrice);\\r\\n        uint256 remaining = swapPrice.sub(protocolFee);\\r\\n        \\r\\n        if (!isCall) {\\r\\n            _withdrawOnLendingPool(collateralAmount.sub(remaining), address(this));\\r\\n        }\\r\\n        \\r\\n\\t\\taddress _collateral = collateral();\\r\\n        IACOPool2.AcoData storage data = acoData[acoToken];\\r\\n\\t\\tif (ACOAssetHelper._isEther(_collateral)) {\\r\\n\\t\\t\\ttokenAmount = IACOToken(acoToken).mintPayable{value: collateralAmount}();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (!data.open) {\\r\\n\\t\\t\\t\\t_setAuthorizedSpender(_collateral, acoToken);    \\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ttokenAmount = IACOToken(acoToken).mint(collateralAmount);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!data.open) {\\r\\n            require(openAcos.length \\u003c maximumOpenAco, \\\"E43\\\");\\r\\n\\t\\t\\tacoData[acoToken] = IACOPool2.AcoData(true, remaining, collateralAmount, 0, acoTokens.length, openAcos.length);\\r\\n            acoTokens.push(acoToken);    \\r\\n            openAcos.push(acoToken);   \\r\\n        } else {\\r\\n\\t\\t\\tdata.collateralLocked = collateralAmount.add(data.collateralLocked);\\r\\n\\t\\t\\tdata.valueSold = remaining.add(data.valueSold);\\r\\n\\t\\t}\\r\\n        \\r\\n        ACOAssetHelper._callTransferERC20(acoToken, to, tokenAmount);\\r\\n    }\\r\\n\\r\\n\\tfunction _transferOpenPositions(uint256 shares, uint256 _totalSupply) internal returns(\\r\\n        address[] memory acos, \\r\\n        uint256[] memory acosAmount\\r\\n    ) {\\r\\n        uint256 size = openAcos.length;\\r\\n        acos = new address[](size);\\r\\n        acosAmount = new uint256[](size);\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c size; ++i) {\\r\\n\\t\\t\\taddress acoToken = openAcos[i];\\r\\n\\t\\t\\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tacos[i] = acoToken;\\r\\n\\t\\t\\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\t\\r\\n            if (acosAmount[i] \\u003e 0) {\\r\\n\\t\\t\\t    IACOToken(acoToken).transferCollateralOwnership(msg.sender, acosAmount[i]);\\r\\n            }\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    function _depositOnLendingPool(uint256 amount) internal {\\r\\n        lendingPool.deposit(strikeAsset, amount, address(this), lendingPoolReferral);\\r\\n    }\\r\\n\\r\\n    function _withdrawOnLendingPool(uint256 amount, address to) internal {\\r\\n        lendingPool.withdraw(strikeAsset, amount, to);\\r\\n    }\\r\\n\\r\\n\\tfunction _acoBasicDataIsValid(address acoToken, address _underlying, address _strikeAsset, bool _isCall) internal view returns(bool) {\\r\\n\\t\\treturn _underlying == underlying \\u0026\\u0026 _strikeAsset == strikeAsset \\u0026\\u0026 _isCall == isCall \\u0026\\u0026 validAcoCreators[acoFactory.creators(acoToken)];\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getPoolBalanceOf(address asset) internal view returns(uint256) {\\r\\n        return ACOAssetHelper._getAssetBalanceOf(asset, address(this));\\r\\n    }\\r\\n\\t\\r\\n\\tfunction _getPrice(address _underlying, address _strikeAsset) internal view returns(uint256) {\\r\\n\\t    return assetConverter.getPrice(_underlying, _strikeAsset);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setAuthorizedSpender(address asset, address spender) internal {\\r\\n        ACOAssetHelper._callApproveERC20(asset, spender, ACOAssetHelper.MAX_UINT);\\r\\n    }\\r\\n\\r\\n\\tfunction _setStrategy(address newStrategy) internal {\\r\\n        require(newStrategy.isContract(), \\\"E81\\\");\\r\\n        emit SetStrategy(address(strategy), newStrategy);\\r\\n        strategy = newStrategy;\\r\\n    }\\r\\n\\r\\n    function _setBaseVolatility(uint256 newBaseVolatility) internal {\\r\\n        require(newBaseVolatility \\u003e 0, \\\"E82\\\");\\r\\n        emit SetBaseVolatility(baseVolatility, newBaseVolatility);\\r\\n        baseVolatility = newBaseVolatility;\\r\\n    }\\r\\n    \\r\\n    function _setLendingPoolReferral(uint16 newLendingPoolReferral) internal {\\r\\n        emit SetLendingPoolReferral(lendingPoolReferral, newLendingPoolReferral);\\r\\n        lendingPoolReferral = newLendingPoolReferral;\\r\\n    }\\r\\n\\r\\n    function _setAssetConverter(address newAssetConverter) internal {\\r\\n        address _underlying = underlying;\\r\\n        address _strikeAsset = strikeAsset;\\r\\n\\t\\trequire(IACOAssetConverterHelper(newAssetConverter).getPrice(_underlying, _strikeAsset) \\u003e 0, \\\"E83\\\");\\r\\n\\t\\t\\r\\n\\t\\tif (isCall) {\\r\\n            if (!ACOAssetHelper._isEther(_strikeAsset)) {\\r\\n                _setAuthorizedSpender(_strikeAsset, newAssetConverter);\\r\\n            }\\r\\n        } else if (!ACOAssetHelper._isEther(_underlying)) {\\r\\n            _setAuthorizedSpender(_underlying, newAssetConverter);\\r\\n        }\\r\\n\\t\\t\\r\\n        emit SetAssetConverter(address(assetConverter), newAssetConverter);\\r\\n        assetConverter = IACOAssetConverterHelper(newAssetConverter);\\r\\n    }\\r\\n\\r\\n    function _setPoolDataForAcoPermission(\\r\\n        uint256 newTolerancePriceBelow, \\r\\n        uint256 newTolerancePriceAbove,\\r\\n        uint256 newMinExpiration,\\r\\n        uint256 newMaxExpiration\\r\\n    ) internal {\\r\\n        require(newTolerancePriceBelow \\u003c PERCENTAGE_PRECISION, \\\"E84\\\");\\r\\n        require(newTolerancePriceAbove \\u003c PERCENTAGE_PRECISION, \\\"E85\\\");\\r\\n        require(newMaxExpiration \\u003e= newMinExpiration, \\\"E86\\\");\\r\\n        \\r\\n        emit SetPoolDataForAcoPermission(tolerancePriceBelow, tolerancePriceAbove, minExpiration, maxExpiration, newTolerancePriceBelow, newTolerancePriceAbove, newMinExpiration, newMaxExpiration);\\r\\n        \\r\\n        tolerancePriceBelow = newTolerancePriceBelow;\\r\\n        tolerancePriceAbove = newTolerancePriceAbove;\\r\\n        minExpiration = newMinExpiration;\\r\\n        maxExpiration = newMaxExpiration;\\r\\n    }\\r\\n\\r\\n    function _setFeeData(address newFeeDestination, uint256 newFee) internal {\\r\\n        require(newFeeDestination != address(0), \\\"E87\\\");\\r\\n        require(newFee \\u003c= 12500, \\\"E88\\\");\\r\\n        \\r\\n        emit SetFeeData(feeDestination, fee, newFeeDestination, newFee);\\r\\n        \\r\\n        feeDestination = newFeeDestination;\\r\\n        fee = newFee;\\r\\n    }\\r\\n\\r\\n    function _setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) internal {\\r\\n        require(newWithdrawOpenPositionPenalty \\u003c= PERCENTAGE_PRECISION, \\\"E89\\\");\\r\\n        emit SetWithdrawOpenPositionPenalty(withdrawOpenPositionPenalty, newWithdrawOpenPositionPenalty);\\r\\n        withdrawOpenPositionPenalty = newWithdrawOpenPositionPenalty;\\r\\n    }\\r\\n\\r\\n\\tfunction _setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) internal {\\r\\n        require(newUnderlyingPriceAdjustPercentage \\u003c PERCENTAGE_PRECISION, \\\"E90\\\");\\r\\n        emit SetUnderlyingPriceAdjustPercentage(underlyingPriceAdjustPercentage, newUnderlyingPriceAdjustPercentage);\\r\\n        underlyingPriceAdjustPercentage = newUnderlyingPriceAdjustPercentage;\\r\\n    }\\r\\n\\r\\n\\tfunction _setMaximumOpenAco(uint256 newMaximumOpenAco) internal {\\r\\n        require(newMaximumOpenAco \\u003e 0, \\\"E91\\\");\\r\\n        emit SetMaximumOpenAco(maximumOpenAco, newMaximumOpenAco);\\r\\n        maximumOpenAco = newMaximumOpenAco;\\r\\n    }\\r\\n\\r\\n    function _setValidAcoCreator(address creator, bool newPermission) internal {\\r\\n        emit SetValidAcoCreator(creator, validAcoCreators[creator], newPermission);\\r\\n        validAcoCreators[creator] = newPermission;\\r\\n    }\\r\\n\\r\\n    function onlyFactory() internal view {\\r\\n        require(owner() == msg.sender, \\\"E99\\\");\\r\\n    }\\r\\n}\"},\"ACOPoolLib.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IACOPoolStrategy.sol\\\";\\r\\nimport \\\"./IACOFactory.sol\\\";\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\nimport \\\"./ILendingPool.sol\\\";\\r\\n\\r\\nlibrary ACOPoolLib {\\r\\n\\tusing SafeMath for uint256;\\r\\n\\t\\r\\n\\tstruct OpenPositionData {\\r\\n        uint256 underlyingPrice;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 underlyingPriceAdjustPercentage;\\r\\n        uint256 underlyingPrecision;\\r\\n        address strategy;\\r\\n        address acoFactory;\\r\\n\\t    address acoToken;\\r\\n\\t}\\r\\n\\t\\r\\n\\tstruct QuoteData {\\r\\n\\t\\tbool isCall;\\r\\n        uint256 tokenAmount; \\r\\n\\t\\taddress underlying;\\r\\n\\t\\taddress strikeAsset;\\r\\n\\t\\tuint256 strikePrice; \\r\\n\\t\\tuint256 expiryTime;\\r\\n\\t\\taddress lendingToken;\\r\\n\\t\\taddress strategy;\\r\\n\\t\\tuint256 baseVolatility;\\r\\n\\t\\tuint256 fee;\\r\\n\\t\\tuint256 minExpiration;\\r\\n\\t\\tuint256 maxExpiration;\\r\\n\\t\\tuint256 tolerancePriceBelow;\\r\\n\\t\\tuint256 tolerancePriceAbove;\\r\\n\\t\\tuint256 underlyingPrice;\\r\\n\\t\\tuint256 underlyingPrecision;\\r\\n\\t}\\r\\n\\t\\r\\n\\tstruct OpenPositionExtraData {\\r\\n        bool isCall;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 tokenAmount;\\r\\n\\t    address underlying;\\r\\n        address strikeAsset; \\r\\n\\t}\\r\\n\\t\\r\\n\\tuint256 public constant PERCENTAGE_PRECISION = 100000;\\r\\n\\t\\r\\n\\tfunction name(address underlying, address strikeAsset, bool isCall) public view returns(string memory) {\\r\\n        return string(abi.encodePacked(\\r\\n            \\\"ACO POOL WRITE \\\",\\r\\n            _getAssetSymbol(underlying),\\r\\n            \\\"-\\\",\\r\\n            _getAssetSymbol(strikeAsset),\\r\\n            \\\"-\\\",\\r\\n            (isCall ? \\\"CALL\\\" : \\\"PUT\\\")\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n\\tfunction acoStrikePriceIsValid(\\r\\n\\t\\tuint256 tolerancePriceBelow,\\r\\n\\t\\tuint256 tolerancePriceAbove,\\r\\n\\t\\tuint256 strikePrice, \\r\\n\\t\\tuint256 price\\r\\n\\t) public pure returns(bool) {\\r\\n\\t\\treturn (tolerancePriceBelow == 0 \\u0026\\u0026 tolerancePriceAbove == 0) ||\\r\\n\\t\\t\\t(tolerancePriceBelow == 0 \\u0026\\u0026 strikePrice \\u003e price.mul(PERCENTAGE_PRECISION.add(tolerancePriceAbove)).div(PERCENTAGE_PRECISION)) ||\\r\\n\\t\\t\\t(tolerancePriceAbove == 0 \\u0026\\u0026 strikePrice \\u003c price.mul(PERCENTAGE_PRECISION.sub(tolerancePriceBelow)).div(PERCENTAGE_PRECISION)) ||\\r\\n\\t\\t\\t(strikePrice \\u003e= price.mul(PERCENTAGE_PRECISION.sub(tolerancePriceBelow)).div(PERCENTAGE_PRECISION) \\u0026\\u0026 \\r\\n\\t\\t\\t strikePrice \\u003c= price.mul(PERCENTAGE_PRECISION.add(tolerancePriceAbove)).div(PERCENTAGE_PRECISION));\\r\\n\\t}\\r\\n\\r\\n\\tfunction acoExpirationIsValid(uint256 acoExpiryTime, uint256 minExpiration, uint256 maxExpiration) public view returns(bool) {\\r\\n\\t\\treturn acoExpiryTime \\u003e= block.timestamp.add(minExpiration) \\u0026\\u0026 acoExpiryTime \\u003c= block.timestamp.add(maxExpiration);\\r\\n\\t}\\r\\n\\r\\n    function getBaseAssetsWithdrawWithLocked(\\r\\n        uint256 shares,\\r\\n        address underlying,\\r\\n        address strikeAsset,\\r\\n        bool isCall,\\r\\n        uint256 totalSupply,\\r\\n        address lendingToken\\r\\n    ) public view returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n    ) {\\r\\n\\t\\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\tuint256 strikeAssetBalance;\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t} else {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n    }\\r\\n    \\r\\n    function getBaseWithdrawNoLockedData(\\r\\n        uint256 shares,\\r\\n        uint256 totalSupply,\\r\\n        bool isCall,\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance, \\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) public pure returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\tbool isPossible\\r\\n    ) {\\r\\n\\t\\tuint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);\\r\\n\\t\\t\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t\\tunderlyingWithdrawn = collateralAmount;\\r\\n\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n\\t\\t\\tisPossible = (collateralAmount \\u003c= underlyingBalance.add(collateralLockedRedeemable));\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tstrikeAssetWithdrawn = collateralAmount;\\r\\n\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\t\\tisPossible = (collateralAmount \\u003c= strikeAssetBalance.add(collateralLockedRedeemable));\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n    function getAmountToLockedWithdraw(\\r\\n        uint256 shares, \\r\\n        uint256 totalSupply, \\r\\n        address lendingToken,\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall\\r\\n    ) public view returns(\\r\\n        uint256 underlyingWithdrawn, \\r\\n        uint256 strikeAssetWithdrawn\\r\\n    ) {\\r\\n\\t\\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\tuint256 strikeAssetBalance;\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t} else {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n    }\\r\\n    \\r\\n    function getAmountToNoLockedWithdraw(\\r\\n        uint256 shares, \\r\\n        uint256 totalSupply,\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance,\\r\\n        uint256 collateralBalance,\\r\\n        uint256 minCollateral,\\r\\n        bool isCall\\r\\n    ) public pure returns(\\r\\n        uint256 underlyingWithdrawn, \\r\\n        uint256 strikeAssetWithdrawn\\r\\n    ) {\\r\\n\\t\\tuint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);\\r\\n\\t\\trequire(collateralAmount \\u003e= minCollateral, \\\"ACOPoolLib: The minimum collateral was not satisfied\\\");\\r\\n\\r\\n        if (isCall) {\\r\\n\\t\\t\\trequire(collateralAmount \\u003c= underlyingBalance, \\\"ACOPoolLib: Collateral balance is not sufficient\\\");\\r\\n\\t\\t\\tunderlyingWithdrawn = collateralAmount;\\r\\n\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n        } else {\\r\\n\\t\\t\\trequire(collateralAmount \\u003c= strikeAssetBalance, \\\"ACOPoolLib: Collateral balance is not sufficient\\\");\\r\\n\\t\\t\\tstrikeAssetWithdrawn = collateralAmount;\\r\\n\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n\\tfunction getBaseCollateralData(\\r\\n\\t    address lendingToken,\\r\\n\\t    address underlying,\\r\\n\\t    address strikeAsset,\\r\\n\\t    bool isCall,\\r\\n\\t    uint256 underlyingPrice,\\r\\n\\t    uint256 underlyingPriceAdjustPercentage,\\r\\n\\t    uint256 underlyingPrecision,\\r\\n\\t    bool isDeposit\\r\\n    ) public view returns(\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance\\r\\n    ) {\\r\\n\\t\\tunderlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\t\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t\\tcollateralBalance = underlyingBalance;\\r\\n\\t\\t\\tif (isDeposit \\u0026\\u0026 strikeAssetBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, false); \\r\\n\\t\\t\\t\\tcollateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\\r\\n\\t\\t\\tcollateralBalance = strikeAssetBalance;\\r\\n\\t\\t\\tif (isDeposit \\u0026\\u0026 underlyingBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, true); \\r\\n\\t\\t\\t\\tcollateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction getOpenPositionCollateralBalance(OpenPositionData memory data) public view returns(\\r\\n        uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        OpenPositionExtraData memory extraData = _getOpenPositionCollateralExtraData(data.acoToken, data.acoFactory);\\r\\n        (collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _getOpenPositionCollateralBalance(data, extraData);\\r\\n    }\\r\\n    \\r\\n    function quote(QuoteData memory data) public view returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 volatility, \\r\\n        uint256 collateralAmount\\r\\n    ) {\\r\\n        require(data.expiryTime \\u003e block.timestamp, \\\"ACOPoolLib: ACO token expired\\\");\\r\\n        require(acoExpirationIsValid(data.expiryTime, data.minExpiration, data.maxExpiration), \\\"ACOPoolLib: Invalid ACO token expiration\\\");\\r\\n\\t\\trequire(acoStrikePriceIsValid(data.tolerancePriceBelow, data.tolerancePriceAbove, data.strikePrice, data.underlyingPrice), \\\"ACOPoolLib: Invalid ACO token strike price\\\");\\r\\n\\r\\n        uint256 collateralAvailable;\\r\\n        (collateralAmount, collateralAvailable) = _getOrderSizeData(data.tokenAmount, data.underlying, data.isCall, data.strikePrice, data.lendingToken, data.underlyingPrecision);\\r\\n        uint256 calcPrice;\\r\\n        (calcPrice, volatility) = _strategyQuote(data.strategy, data.underlying, data.strikeAsset, data.isCall, data.strikePrice, data.expiryTime, data.underlyingPrice, data.baseVolatility, collateralAmount, collateralAvailable);\\r\\n        (swapPrice, protocolFee) = _setSwapPriceAndFee(calcPrice, data.tokenAmount, data.fee, data.underlyingPrecision);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function _getCollateralAmount(\\r\\n\\t\\tuint256 tokenAmount,\\r\\n\\t\\tuint256 strikePrice,\\r\\n\\t\\tbool isCall,\\r\\n\\t\\tuint256 underlyingPrecision\\r\\n\\t) private pure returns(uint256) {\\r\\n        if (isCall) {\\r\\n            return tokenAmount;\\r\\n        } else if (tokenAmount \\u003e 0) {\\r\\n            return tokenAmount.mul(strikePrice).div(underlyingPrecision);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getOrderSizeData(\\r\\n        uint256 tokenAmount,\\r\\n        address underlying,\\r\\n        bool isCall,\\r\\n        uint256 strikePrice,\\r\\n        address lendingToken,\\r\\n        uint256 underlyingPrecision\\r\\n    ) private view returns(\\r\\n        uint256 collateralAmount, \\r\\n        uint256 collateralAvailable\\r\\n    ) {\\r\\n        if (isCall) {\\r\\n            collateralAvailable = _getPoolBalanceOf(underlying);\\r\\n            collateralAmount = tokenAmount; \\r\\n        } else {\\r\\n            collateralAvailable = _getPoolBalanceOf(lendingToken);\\r\\n            collateralAmount = _getCollateralAmount(tokenAmount, strikePrice, isCall, underlyingPrecision);\\r\\n            require(collateralAmount \\u003e 0, \\\"ACOPoolLib: The token amount is too small\\\");\\r\\n        }\\r\\n        require(collateralAmount \\u003c= collateralAvailable, \\\"ACOPoolLib: Insufficient liquidity\\\");\\r\\n    }\\r\\n    \\r\\n\\tfunction _strategyQuote(\\r\\n        address strategy,\\r\\n\\t\\taddress underlying,\\r\\n\\t\\taddress strikeAsset,\\r\\n\\t\\tbool isCall,\\r\\n\\t\\tuint256 strikePrice,\\r\\n        uint256 expiryTime,\\r\\n        uint256 underlyingPrice,\\r\\n\\t\\tuint256 baseVolatility,\\r\\n        uint256 collateralAmount,\\r\\n        uint256 collateralAvailable\\r\\n    ) private view returns(uint256 swapPrice, uint256 volatility) {\\r\\n        (swapPrice, volatility) = IACOPoolStrategy(strategy).quote(IACOPoolStrategy.OptionQuote(\\r\\n\\t\\t\\tunderlyingPrice,\\r\\n            underlying, \\r\\n            strikeAsset, \\r\\n            isCall, \\r\\n            strikePrice, \\r\\n            expiryTime, \\r\\n            baseVolatility, \\r\\n            collateralAmount, \\r\\n            collateralAvailable\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n    function _setSwapPriceAndFee(\\r\\n        uint256 calcPrice, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 fee,\\r\\n        uint256 underlyingPrecision\\r\\n    ) private pure returns(uint256 swapPrice, uint256 protocolFee) {\\r\\n        \\r\\n        swapPrice = calcPrice.mul(tokenAmount).div(underlyingPrecision);\\r\\n        \\r\\n        if (fee \\u003e 0) {\\r\\n            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t\\tswapPrice = swapPrice.add(protocolFee);\\r\\n        }\\r\\n        require(swapPrice \\u003e 0, \\\"ACOPoolLib: Invalid quoted price\\\");\\r\\n    }\\r\\n    \\r\\n    function _getOpenPositionCollateralExtraData(address acoToken, address acoFactory) private view returns(OpenPositionExtraData memory extraData) {\\r\\n        (address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) = IACOFactory(acoFactory).acoTokenData(acoToken);\\r\\n        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n        extraData = OpenPositionExtraData(isCall, strikePrice, expiryTime, tokenAmount, underlying, strikeAsset);\\r\\n    }\\r\\n    \\r\\n\\tfunction _getOpenPositionCollateralBalance(\\r\\n\\t\\tOpenPositionData memory data,\\r\\n\\t\\tOpenPositionExtraData memory extraData\\r\\n\\t) private view returns(\\r\\n\\t    uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        collateralLocked = _getCollateralAmount(extraData.tokenAmount, extraData.strikePrice, extraData.isCall, data.underlyingPrecision);\\r\\n        \\r\\n        if (extraData.expiryTime \\u003e block.timestamp) {\\r\\n    \\t\\t(uint256 price,) = _strategyQuote(data.strategy, extraData.underlying, extraData.strikeAsset, extraData.isCall, extraData.strikePrice, extraData.expiryTime, data.underlyingPrice, data.baseVolatility, 0, 1);\\r\\n    \\t\\tif (extraData.isCall) {\\r\\n    \\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(data.underlyingPrice, data.underlyingPriceAdjustPercentage, false); \\r\\n    \\t\\t\\tcollateralOnOpenPosition = price.mul(extraData.tokenAmount).div(priceAdjusted);\\r\\n    \\t\\t} else {\\r\\n    \\t\\t\\tcollateralOnOpenPosition = price.mul(extraData.tokenAmount).div(data.underlyingPrecision);\\r\\n    \\t\\t}\\r\\n        } else {\\r\\n            collateralLockedRedeemable = collateralLocked;\\r\\n        }\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _getUnderlyingPriceAdjusted(uint256 underlyingPrice, uint256 underlyingPriceAdjustPercentage, bool isMaximum) private pure returns(uint256) {\\r\\n\\t\\tif (isMaximum) {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n    function _getPoolBalanceOf(address asset) private view returns(uint256) {\\r\\n        if (asset == address(0)) {\\r\\n            return address(this).balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, address(this)));\\r\\n            require(success, \\\"ACOPoolLib::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getAssetSymbol(address asset) private view returns(string memory) {\\r\\n        if (asset == address(0)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOPoolLib::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20\\r\\n * @dev Base implementation of ERC20 token.\\r\\n */\\r\\nabstract contract ERC20 is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 private _totalSupply;\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    function name() public view virtual returns(string memory);\\r\\n    function symbol() public view virtual returns(string memory);\\r\\n    function decimals() public view virtual returns(uint8);\\r\\n\\r\\n    function totalSupply() public view override virtual returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override virtual returns(uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns(uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {\\r\\n        _approveAction(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\r\\n        _transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns(bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(amount));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        _transferAction(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        _approveAction(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _approveAction(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\r\\n        _burnAction(account, amount);\\r\\n    }\\r\\n\\r\\n    function _transferAction(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"ERC20::_transferAction: Invalid sender\\\");\\r\\n        require(recipient != address(0), \\\"ERC20::_transferAction: Invalid recipient\\\");\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        \\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    \\r\\n    function _approveAction(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"ERC20::_approveAction: Invalid owner\\\");\\r\\n        require(spender != address(0), \\\"ERC20::_approveAction: Invalid spender\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        \\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _mintAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_mintAction: Invalid account\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        \\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burnAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_burnAction: Invalid account\\\");\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount);\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        \\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n}    \\r\\n\"},\"IACOAssetConverterHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOAssetConverterHelper {\\r\\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\\r\\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\\r\\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\\r\\n    function withdrawStuckAsset(address asset, address destination) external;\\r\\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\\r\\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\\r\\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\\r\\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\\r\\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\\r\\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\\r\\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\\r\\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\\r\\n}\"},\"IACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFactory {\\r\\n\\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\\r\\n    function acoFee() external view returns(uint256);\\r\\n    function factoryAdmin() external view returns(address);\\r\\n    function acoTokenImplementation() external view returns(address);\\r\\n    function acoFeeDestination() external view returns(address);\\r\\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\\r\\n    function creators(address acoToken) external view returns(address);\\r\\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\\r\\n    function setFactoryAdmin(address newFactoryAdmin) external;\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\\r\\n    function setAcoFee(uint256 newAcoFee) external;\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\\r\\n}\"},\"IACOPool2.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IACOPool2 is IERC20 {\\r\\n\\r\\n    struct InitData {\\r\\n        address acoFactory;\\r\\n        address chiToken;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCall; \\r\\n        address lendingPool;\\r\\n        uint16 lendingPoolReferral;\\r\\n\\t\\taddress assetConverter;\\r\\n        uint256 fee;\\r\\n        address feeDestination;\\r\\n        uint256 withdrawOpenPositionPenalty;\\r\\n        uint256 underlyingPriceAdjustPercentage;\\r\\n\\t\\tuint256 maximumOpenAco;\\r\\n        uint256 tolerancePriceBelow;\\r\\n        uint256 tolerancePriceAbove; \\r\\n        uint256 minExpiration;\\r\\n        uint256 maxExpiration;\\r\\n        address strategy;\\r\\n        uint256 baseVolatility;    \\r\\n    }\\r\\n\\r\\n\\tstruct AcoData {\\r\\n        bool open;\\r\\n        uint256 valueSold;\\r\\n        uint256 collateralLocked;\\r\\n        uint256 collateralRedeemed;\\r\\n        uint256 index;\\r\\n\\t\\tuint256 openIndex;\\r\\n    }\\r\\n    \\r\\n\\tfunction init(InitData calldata initData) external;\\r\\n\\tfunction numberOfAcoTokensNegotiated() external view returns(uint256);\\r\\n    function numberOfOpenAcoTokens() external view returns(uint256);\\r\\n    function collateral() external view returns(address);\\r\\n\\tfunction canSwap(address acoToken) external view returns(bool);\\r\\n\\tfunction quote(address acoToken, uint256 tokenAmount) external view returns(\\r\\n\\t\\tuint256 swapPrice, \\r\\n\\t\\tuint256 protocolFee, \\r\\n\\t\\tuint256 underlyingPrice, \\r\\n\\t\\tuint256 volatility\\r\\n\\t);\\r\\n\\tfunction getDepositShares(uint256 collateralAmount) external view returns(uint256 shares);\\r\\n\\tfunction getWithdrawNoLockedData(uint256 shares) external view returns(\\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\tbool isPossible\\r\\n\\t);\\r\\n\\tfunction getWithdrawWithLocked(uint256 shares) external view returns(\\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\taddress[] memory acos, \\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n\\tfunction getGeneralData() external view returns(\\r\\n        uint256 underlyingBalance,\\r\\n\\t\\tuint256 strikeAssetBalance,\\r\\n\\t\\tuint256 collateralLocked,\\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    );\\r\\n\\tfunction setLendingPoolReferral(uint16 newLendingPoolReferral) external;\\r\\n\\tfunction setPoolDataForAcoPermission(uint256 newTolerancePriceBelow, uint256 newTolerancePriceAbove, uint256 newMinExpiration, uint256 newMaxExpiration) external;\\r\\n\\tfunction setFeeData(address newFeeDestination, uint256 newFee) external;\\r\\n\\tfunction setAssetConverter(address newAssetConverter) external;\\r\\n    function setTolerancePriceBelow(uint256 newTolerancePriceBelow) external;\\r\\n    function setTolerancePriceAbove(uint256 newTolerancePriceAbove) external;\\r\\n    function setMinExpiration(uint256 newMinExpiration) external;\\r\\n    function setMaxExpiration(uint256 newMaxExpiration) external;\\r\\n    function setFee(uint256 newFee) external;\\r\\n    function setFeeDestination(address newFeeDestination) external;\\r\\n\\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external;\\r\\n\\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external;\\r\\n\\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external;\\r\\n\\tfunction setStrategy(address newStrategy) external;\\r\\n\\tfunction setBaseVolatility(uint256 newBaseVolatility) external;\\r\\n\\tfunction setValidAcoCreator(address newAcoCreator, bool newPermission) external;\\r\\n    function withdrawStuckToken(address token, address destination) external;\\r\\n    function deposit(uint256 collateralAmount, uint256 minShares, address to, bool isLendingToken) external payable returns(uint256 acoPoolTokenAmount);\\r\\n\\tfunction depositWithGasToken(uint256 collateralAmount, uint256 minShares, address to, bool isLendingToken) external payable returns(uint256 acoPoolTokenAmount);\\r\\n\\tfunction withdrawNoLocked(uint256 shares, uint256 minCollateral, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t);\\r\\n\\tfunction withdrawNoLockedWithGasToken(uint256 shares, uint256 minCollateral, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t);\\r\\n    function withdrawWithLocked(uint256 shares, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n\\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n    function swap(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external;\\r\\n    function swapWithGasToken(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external;\\r\\n    function redeemACOTokens() external;\\r\\n\\tfunction redeemACOToken(address acoToken) external;\\r\\n    function restoreCollateral() external;\\r\\n    function lendCollateral() external;\\r\\n}\"},\"IACOPoolStrategy.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IACOPoolStrategy {\\r\\n    \\r\\n    struct OptionQuote {\\r\\n        uint256 underlyingPrice;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 collateralOrderAmount;\\r\\n        uint256 collateralAvailable;\\r\\n    }\\r\\n\\r\\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 volatility);\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\\r\\n}\"},\"IChiToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IChiToken is IERC20 {\\r\\n    function mint(uint256 value) external;\\r\\n    function computeAddress2(uint256 salt) external view returns(address);\\r\\n    function free(uint256 value) external returns(uint256);\\r\\n    function freeUpTo(uint256 value) external returns(uint256);\\r\\n    function freeFrom(address from, uint256 value) external returns(uint256);\\r\\n    function freeFromUpTo(address from, uint256 value) external returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"ILendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nlibrary DataTypes {\\r\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\r\\n  struct ReserveData {\\r\\n    //stores the reserve configuration\\r\\n    ReserveConfigurationMap configuration;\\r\\n    //the liquidity index. Expressed in ray\\r\\n    uint128 liquidityIndex;\\r\\n    //variable borrow index. Expressed in ray\\r\\n    uint128 variableBorrowIndex;\\r\\n    //the current supply rate. Expressed in ray\\r\\n    uint128 currentLiquidityRate;\\r\\n    //the current variable borrow rate. Expressed in ray\\r\\n    uint128 currentVariableBorrowRate;\\r\\n    //the current stable borrow rate. Expressed in ray\\r\\n    uint128 currentStableBorrowRate;\\r\\n    uint40 lastUpdateTimestamp;\\r\\n    //tokens addresses\\r\\n    address aTokenAddress;\\r\\n    address stableDebtTokenAddress;\\r\\n    address variableDebtTokenAddress;\\r\\n    //address of the interest rate strategy\\r\\n    address interestRateStrategyAddress;\\r\\n    //the id of the reserve. Represents the position in the list of the active reserves\\r\\n    uint8 id;\\r\\n  }\\r\\n\\r\\n  struct ReserveConfigurationMap {\\r\\n    //bit 0-15: LTV\\r\\n    //bit 16-31: Liq. threshold\\r\\n    //bit 32-47: Liq. bonus\\r\\n    //bit 48-55: Decimals\\r\\n    //bit 56: Reserve is active\\r\\n    //bit 57: reserve is frozen\\r\\n    //bit 58: borrowing is enabled\\r\\n    //bit 59: stable rate borrowing enabled\\r\\n    //bit 60-63: reserved\\r\\n    //bit 64-79: reserve factor\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  struct UserConfigurationMap {\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title LendingPoolAddressesProvider contract\\r\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\r\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\r\\n * - Owned by the Aave Governance\\r\\n * @author Aave\\r\\n **/\\r\\ninterface ILendingPoolAddressesProvider {\\r\\n  event MarketIdSet(string newMarketId);\\r\\n  event LendingPoolUpdated(address indexed newAddress);\\r\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\r\\n  event EmergencyAdminUpdated(address indexed newAddress);\\r\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\r\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\r\\n  event PriceOracleUpdated(address indexed newAddress);\\r\\n  event LendingRateOracleUpdated(address indexed newAddress);\\r\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\r\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\r\\n\\r\\n  function getMarketId() external view returns (string memory);\\r\\n\\r\\n  function setMarketId(string calldata marketId) external;\\r\\n\\r\\n  function setAddress(bytes32 id, address newAddress) external;\\r\\n\\r\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\r\\n\\r\\n  function getAddress(bytes32 id) external view returns (address);\\r\\n\\r\\n  function getLendingPool() external view returns (address);\\r\\n\\r\\n  function setLendingPoolImpl(address pool) external;\\r\\n\\r\\n  function getLendingPoolConfigurator() external view returns (address);\\r\\n\\r\\n  function setLendingPoolConfiguratorImpl(address configurator) external;\\r\\n\\r\\n  function getLendingPoolCollateralManager() external view returns (address);\\r\\n\\r\\n  function setLendingPoolCollateralManager(address manager) external;\\r\\n\\r\\n  function getPoolAdmin() external view returns (address);\\r\\n\\r\\n  function setPoolAdmin(address admin) external;\\r\\n\\r\\n  function getEmergencyAdmin() external view returns (address);\\r\\n\\r\\n  function setEmergencyAdmin(address admin) external;\\r\\n\\r\\n  function getPriceOracle() external view returns (address);\\r\\n\\r\\n  function setPriceOracle(address priceOracle) external;\\r\\n\\r\\n  function getLendingRateOracle() external view returns (address);\\r\\n\\r\\n  function setLendingRateOracle(address lendingRateOracle) external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface ILendingPool {\\r\\n  /**\\r\\n   * @dev Emitted on deposit()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address initiating the deposit\\r\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\r\\n   * @param amount The amount deposited\\r\\n   * @param referral The referral code used\\r\\n   **/\\r\\n  event Deposit(\\r\\n    address indexed reserve,\\r\\n    address user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint16 indexed referral\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on withdraw()\\r\\n   * @param reserve The address of the underlyng asset being withdrawn\\r\\n   * @param user The address initiating the withdrawal, owner of aTokens\\r\\n   * @param to Address that will receive the underlying\\r\\n   * @param amount The amount to be withdrawn\\r\\n   **/\\r\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\r\\n   * @param reserve The address of the underlying asset being borrowed\\r\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\r\\n   * initiator of the transaction on flashLoan()\\r\\n   * @param onBehalfOf The address that will be getting the debt\\r\\n   * @param amount The amount borrowed out\\r\\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\r\\n   * @param borrowRate The numeric rate at which the user has borrowed\\r\\n   * @param referral The referral code used\\r\\n   **/\\r\\n  event Borrow(\\r\\n    address indexed reserve,\\r\\n    address user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint256 borrowRateMode,\\r\\n    uint256 borrowRate,\\r\\n    uint16 indexed referral\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on repay()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\r\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\r\\n   * @param amount The amount repaid\\r\\n   **/\\r\\n  event Repay(\\r\\n    address indexed reserve,\\r\\n    address indexed user,\\r\\n    address indexed repayer,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on swapBorrowRateMode()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user swapping his rate mode\\r\\n   * @param rateMode The rate mode that the user wants to swap to\\r\\n   **/\\r\\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on rebalanceStableBorrowRate()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user for which the rebalance has been executed\\r\\n   **/\\r\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on flashLoan()\\r\\n   * @param target The address of the flash loan receiver contract\\r\\n   * @param initiator The address initiating the flash loan\\r\\n   * @param asset The address of the asset being flash borrowed\\r\\n   * @param amount The amount flash borrowed\\r\\n   * @param premium The fee flash borrowed\\r\\n   * @param referralCode The referral code used\\r\\n   **/\\r\\n  event FlashLoan(\\r\\n    address indexed target,\\r\\n    address indexed initiator,\\r\\n    address indexed asset,\\r\\n    uint256 amount,\\r\\n    uint256 premium,\\r\\n    uint16 referralCode\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is triggered.\\r\\n   */\\r\\n  event Paused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is lifted.\\r\\n   */\\r\\n  event Unpaused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\r\\n   * LendingPoolCollateral manager using a DELEGATECALL\\r\\n   * This allows to have the events in the generated ABI for LendingPool.\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\r\\n   * @param liquidator The address of the liquidator\\r\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n   * to receive the underlying collateral asset directly\\r\\n   **/\\r\\n  event LiquidationCall(\\r\\n    address indexed collateralAsset,\\r\\n    address indexed debtAsset,\\r\\n    address indexed user,\\r\\n    uint256 debtToCover,\\r\\n    uint256 liquidatedCollateralAmount,\\r\\n    address liquidator,\\r\\n    bool receiveAToken\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\r\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\r\\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\\r\\n   * gets added to the LendingPool ABI\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param liquidityRate The new liquidity rate\\r\\n   * @param stableBorrowRate The new stable borrow rate\\r\\n   * @param variableBorrowRate The new variable borrow rate\\r\\n   * @param liquidityIndex The new liquidity index\\r\\n   * @param variableBorrowIndex The new variable borrow index\\r\\n   **/\\r\\n  event ReserveDataUpdated(\\r\\n    address indexed reserve,\\r\\n    uint256 liquidityRate,\\r\\n    uint256 stableBorrowRate,\\r\\n    uint256 variableBorrowRate,\\r\\n    uint256 liquidityIndex,\\r\\n    uint256 variableBorrowIndex\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\r\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to deposit\\r\\n   * @param amount The amount to be deposited\\r\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n   *   is a different wallet\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function deposit(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\r\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to withdraw\\r\\n   * @param amount The underlying amount to be withdrawn\\r\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\r\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\r\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n   *   different wallet\\r\\n   * @return The final amount withdrawn\\r\\n   **/\\r\\n  function withdraw(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address to\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\r\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\r\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\r\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\r\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\r\\n   * @param asset The address of the underlying asset to borrow\\r\\n   * @param amount The amount to be borrowed\\r\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\r\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\r\\n   * if he has been given credit delegation allowance\\r\\n   **/\\r\\n  function borrow(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 interestRateMode,\\r\\n    uint16 referralCode,\\r\\n    address onBehalfOf\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\r\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\r\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n   * @param amount The amount to repay\\r\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\r\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n   * other borrower whose debt should be removed\\r\\n   * @return The final amount repaid\\r\\n   **/\\r\\n  function repay(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 rateMode,\\r\\n    address onBehalfOf\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\r\\n   * @param asset The address of the underlying asset borrowed\\r\\n   * @param rateMode The rate mode that the user wants to swap to\\r\\n   **/\\r\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\r\\n   * - Users can be rebalanced if the following conditions are satisfied:\\r\\n   *     1. Usage ratio is above 95%\\r\\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\\r\\n   *        borrowed at a stable rate and depositors are not earning enough\\r\\n   * @param asset The address of the underlying asset borrowed\\r\\n   * @param user The address of the user to be rebalanced\\r\\n   **/\\r\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\r\\n   * @param asset The address of the underlying asset deposited\\r\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\r\\n   **/\\r\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\r\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\r\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n   * to receive the underlying collateral asset directly\\r\\n   **/\\r\\n  function liquidationCall(\\r\\n    address collateralAsset,\\r\\n    address debtAsset,\\r\\n    address user,\\r\\n    uint256 debtToCover,\\r\\n    bool receiveAToken\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\r\\n   * as long as the amount taken plus a fee is returned.\\r\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\r\\n   * For further details please visit https://developers.aave.com\\r\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\r\\n   * @param assets The addresses of the assets being flash-borrowed\\r\\n   * @param amounts The amounts amounts being flash-borrowed\\r\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\r\\n   *   0 -\\u003e Don\\u0027t open any debt, just revert if funds can\\u0027t be transferred from the receiver\\r\\n   *   1 -\\u003e Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n   *   2 -\\u003e Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\r\\n   * @param params Variadic packed params to pass to the receiver as extra information\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function flashLoan(\\r\\n    address receiverAddress,\\r\\n    address[] calldata assets,\\r\\n    uint256[] calldata amounts,\\r\\n    uint256[] calldata modes,\\r\\n    address onBehalfOf,\\r\\n    bytes calldata params,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the user account data across all the reserves\\r\\n   * @param user The address of the user\\r\\n   * @return totalCollateralETH the total collateral in ETH of the user\\r\\n   * @return totalDebtETH the total debt in ETH of the user\\r\\n   * @return availableBorrowsETH the borrowing power left of the user\\r\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\r\\n   * @return ltv the loan to value of the user\\r\\n   * @return healthFactor the current health factor of the user\\r\\n   **/\\r\\n  function getUserAccountData(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 totalCollateralETH,\\r\\n      uint256 totalDebtETH,\\r\\n      uint256 availableBorrowsETH,\\r\\n      uint256 currentLiquidationThreshold,\\r\\n      uint256 ltv,\\r\\n      uint256 healthFactor\\r\\n    );\\r\\n\\r\\n  function initReserve(\\r\\n    address reserve,\\r\\n    address aTokenAddress,\\r\\n    address stableDebtAddress,\\r\\n    address variableDebtAddress,\\r\\n    address interestRateStrategyAddress\\r\\n  ) external;\\r\\n\\r\\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\\r\\n    external;\\r\\n\\r\\n  function setConfiguration(address reserve, uint256 configuration) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The configuration of the reserve\\r\\n   **/\\r\\n  function getConfiguration(address asset)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.ReserveConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the user across all the reserves\\r\\n   * @param user The user address\\r\\n   * @return The configuration of the user\\r\\n   **/\\r\\n  function getUserConfiguration(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.UserConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized income normalized income of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve\\u0027s normalized income\\r\\n   */\\r\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized variable debt per unit of asset\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve normalized variable debt\\r\\n   */\\r\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the state and configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The state of the reserve\\r\\n   **/\\r\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\r\\n\\r\\n  function finalizeTransfer(\\r\\n    address asset,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount,\\r\\n    uint256 balanceFromAfter,\\r\\n    uint256 balanceToBefore\\r\\n  ) external;\\r\\n\\r\\n  function getReservesList() external view returns (address[] memory);\\r\\n\\r\\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\\r\\n\\r\\n  function setPause(bool val) external;\\r\\n\\r\\n  function paused() external view returns (bool);\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Adapted from OpenZeppelin\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function init() internal {\\r\\n        require(_owner == address(0), \\\"Ownable: Contract initialized\\\");\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralLocked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralRedeemed\",\"type\":\"uint256\"}],\"name\":\"ACORedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"LendCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralRestored\",\"type\":\"uint256\"}],\"name\":\"RestoreCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAssetConverter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAssetConverter\",\"type\":\"address\"}],\"name\":\"SetAssetConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldBaseVolatility\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newBaseVolatility\",\"type\":\"uint256\"}],\"name\":\"SetBaseVolatility\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeDestination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeDestination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"SetFeeData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldLendingPoolReferral\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newLendingPoolReferral\",\"type\":\"uint256\"}],\"name\":\"SetLendingPoolReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldMaximumOpenAco\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMaximumOpenAco\",\"type\":\"uint256\"}],\"name\":\"SetMaximumOpenAco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTolerancePriceBelow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTolerancePriceAbove\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTolerancePriceBelow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTolerancePriceAbove\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxExpiration\",\"type\":\"uint256\"}],\"name\":\"SetPoolDataForAcoPermission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldStrategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"SetStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"}],\"name\":\"SetUnderlyingPriceAdjustPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"previousPermission\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newPermission\",\"type\":\"bool\"}],\"name\":\"SetValidAcoCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldWithdrawOpenPositionPenalty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newWithdrawOpenPositionPenalty\",\"type\":\"uint256\"}],\"name\":\"SetWithdrawOpenPositionPenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"noLocked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"acoData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"valueSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoFactory\",\"outputs\":[{\"internalType\":\"contract IACOFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"acoTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetConverter\",\"outputs\":[{\"internalType\":\"contract IACOAssetConverterHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseVolatility\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"canSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chiToken\",\"outputs\":[{\"internalType\":\"contract IChiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLendingToken\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLendingToken\",\"type\":\"bool\"}],\"name\":\"depositWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"getDepositShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGeneralData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralOnOpenPosition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLockedRedeemable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getWithdrawNoLockedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPossible\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getWithdrawWithLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"acoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chiToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"lendingPool\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"lendingPoolReferral\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"assetConverter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawOpenPositionPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumOpenAco\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseVolatility\",\"type\":\"uint256\"}],\"internalType\":\"struct IACOPool2.InitData\",\"name\":\"initData\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPoolReferral\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumOpenAco\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfAcoTokensNegotiated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfOpenAcoTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"openAcos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"redeemACOToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemACOTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restoreCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAssetConverter\",\"type\":\"address\"}],\"name\":\"setAssetConverter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseVolatility\",\"type\":\"uint256\"}],\"name\":\"setBaseVolatility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFeeData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newLendingPoolReferral\",\"type\":\"uint16\"}],\"name\":\"setLendingPoolReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaximumOpenAco\",\"type\":\"uint256\"}],\"name\":\"setMaximumOpenAco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTolerancePriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTolerancePriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxExpiration\",\"type\":\"uint256\"}],\"name\":\"setPoolDataForAcoPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"setStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"}],\"name\":\"setUnderlyingPriceAdjustPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAcoCreator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newPermission\",\"type\":\"bool\"}],\"name\":\"setValidAcoCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWithdrawOpenPositionPenalty\",\"type\":\"uint256\"}],\"name\":\"setWithdrawOpenPositionPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapWithGasToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tolerancePriceAbove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tolerancePriceBelow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingPriceAdjustPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validAcoCreators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawLendingToken\",\"type\":\"bool\"}],\"name\":\"withdrawNoLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawLendingToken\",\"type\":\"bool\"}],\"name\":\"withdrawNoLockedWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawOpenPositionPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawLendingToken\",\"type\":\"bool\"}],\"name\":\"withdrawWithLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawLendingToken\",\"type\":\"bool\"}],\"name\":\"withdrawWithLockedWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOPool2","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"ACOPoolLib:20252d0ff102ee9f97c5045913841d4b211984d2","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://237e48990f610819c2667dcc374ba01ffd1f2b823fe033f9e24bac9177a0f8f6"}]}