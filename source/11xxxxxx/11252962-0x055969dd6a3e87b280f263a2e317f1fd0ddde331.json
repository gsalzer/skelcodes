{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/adapters/assets/curve/CurveAdapter.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { CurveAdapterLib } from \\\"./CurveAdapterLib.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { ICurve } from \\\"../../../interfaces/ICurve.sol\\\";\\n\\ncontract CurveAdapter {\\n  using ModuleLib for *;\\n  using CurveAdapterLib for *;\\n  using BorrowProxyLib for *;\\n  using TokenUtils for *;\\n  constructor(address curveAddress) public {\\n    CurveAdapterLib.Isolate storage isolate = CurveAdapterLib.getIsolatePointer(address(this));\\n    isolate.curveAddress = curveAddress;\\n  }\\n  function getExternalIsolateHandler() external view returns (CurveAdapterLib.Isolate memory isolate) {\\n    isolate = CurveAdapterLib.getIsolatePointer(address(this));\\n  }\\n  function handle(ModuleLib.AssetSubmodulePayload memory payload) public payable {\\n    require(payload.to == CurveAdapter(payload.moduleAddress).getExternalIsolateHandler().curveAddress, \\\"CurveAdapter instance must map one to one with a live curve.fi instance\\\");\\n    (bytes4 sig, bytes memory args) = payload.callData.splitPayload();\\n    address newToken;\\n    /* not sure how to handle these unless \\\"token\\\" is exposed on curve as a public variable ...\\n    if (sig == ICurve.add_liquidity.selector) payload.liquidationSubmodule.delegateNotify(abi.encode(address(0x0)));\\n    else if (sig == ICurve.remove_liquidity.selector) {}\\n    */\\n    if (sig == ICurve.exchange.selector) {\\n      CurveAdapterLib.ExchangeInputs memory inputs = args.decodeExchangeInputs();\\n      require(ICurve(payload.to).coins(uint256(uint128(inputs.i))).approveForMaxIfNeeded(payload.to), \\\"token approval failed\\\");\\n      newToken = ICurve(payload.to).coins(uint256(uint128(inputs.j)));\\n    } else if (sig == ICurve.exchange_underlying.selector) {\\n      CurveAdapterLib.ExchangeInputs memory inputs = args.decodeExchangeInputs();\\n      require(ICurve(payload.to).underlying_coins(uint256(uint128(inputs.i))).approveForMaxIfNeeded(payload.to), \\\"token approval failed\\\");\\n      newToken = ICurve(payload.to).underlying_coins(uint256(uint128(inputs.j)));\\n    } else revert(\\\"unsupported contract call\\\");\\n    if (newToken != address(0x0)) require(payload.liquidationSubmodule.delegateNotify(abi.encode(newToken)), \\\"failed to notify liquidation module\\\");\\n    (bool success, bytes memory retval) = payload.to.call{ gas: gasleft(), value: payload.value }(payload.callData);\\n    ModuleLib.bubbleResult(success, retval);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/lib/ModuleLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"../../utils/SliceLib.sol\\\";\\n\\ninterface IModule {\\n  function handle(ModuleLib.AssetSubmodulePayload calldata) external payable;\\n}\\n\\nlibrary ModuleLib {\\n  address payable constant ETHER_ADDRESS = 0x0000000000000000000000000000000000000000;\\n  function GET_ETHER_ADDRESS() internal pure returns (address payable) {\\n    return ETHER_ADDRESS;\\n  }\\n  function cast(uint256 v) internal pure returns (uint256) {\\n    return v;\\n  }\\n  function splitPayload(bytes memory payload) internal pure returns (bytes4 sig, bytes memory args) {\\n    sig = bytes4(uint32(uint256(SliceLib.asWord(SliceLib.toSlice(payload, 0, 4)))));\\n    args = SliceLib.copy(SliceLib.toSlice(payload, 4));\\n  }\\n  struct AssetSubmodulePayload {\\n    address payable moduleAddress;\\n    address liquidationSubmodule;\\n    address repaymentSubmodule;\\n    address payable token;\\n    address payable txOrigin;\\n    address payable to;\\n    uint256 value;\\n    bytes callData;\\n  }\\n  function encodeWithSelector(AssetSubmodulePayload memory input) internal pure returns (bytes memory result) {\\n    result = abi.encodeWithSelector(IModule.handle.selector, input);\\n  }\\n  function bubbleResult(bool success, bytes memory retval) internal pure {\\n    assembly {\\n      if iszero(success) {\\n        revert(add(0x20, retval), mload(retval))\\n      }\\n      return(add(0x20, retval), mload(retval))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SliceLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { MemcpyLib } from \\\"./MemcpyLib.sol\\\";\\n\\nlibrary SliceLib {\\n  struct Slice {\\n    uint256 data;\\n    uint256 length;\\n    uint256 offset;\\n  }\\n  function toPtr(bytes memory input, uint256 offset) internal pure returns (uint256 data) {\\n    assembly {\\n      data := add(input, add(offset, 0x20))\\n    }\\n  }\\n  function toSlice(bytes memory input, uint256 offset, uint256 length) internal pure returns (Slice memory retval) {\\n    retval.data = toPtr(input, offset);\\n    retval.length = length;\\n    retval.offset = offset;\\n  }\\n  function toSlice(bytes memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function toSlice(bytes memory input, uint256 offset) internal pure returns (Slice memory) {\\n    if (input.length < offset) offset = input.length;\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input, uint256 offset, uint256 length) internal pure returns (Slice memory) {\\n    return Slice({\\n      data: input.data + offset,\\n      offset: input.offset + offset,\\n      length: length\\n    });\\n  }\\n  function toSlice(Slice memory input, uint256 offset) internal pure returns (Slice memory) {\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function maskLastByteOfWordAt(uint256 data) internal pure returns (uint8 lastByte) {\\n    assembly {\\n      lastByte := and(mload(data), 0xff)\\n    }\\n  }\\n  function get(Slice memory slice, uint256 index) internal pure returns (bytes1 result) {\\n    return bytes1(maskLastByteOfWordAt(slice.data - 0x1f + index));\\n  }\\n  function setByteAt(uint256 ptr, uint8 value) internal pure {\\n    assembly {\\n      mstore8(ptr, value)\\n    }\\n  }\\n  function set(Slice memory slice, uint256 index, uint8 value) internal pure {\\n    setByteAt(slice.data + index, value);\\n  }\\n  function wordAt(uint256 ptr, uint256 length) internal pure returns (bytes32 word) {\\n    assembly {\\n      let mask := sub(shl(mul(length, 0x8), 0x1), 0x1)\\n      word := and(mload(sub(ptr, sub(0x20, length))), mask)\\n    }\\n  }\\n  function asWord(Slice memory slice) internal pure returns (bytes32 word) {\\n    uint256 data = slice.data;\\n    uint256 length = slice.length;\\n    return wordAt(data, length);\\n  }\\n  function toDataStart(bytes memory input) internal pure returns (bytes32 start) {\\n    assembly {\\n      start := add(input, 0x20)\\n    }\\n  }\\n  function copy(Slice memory slice) internal pure returns (bytes memory retval) {\\n    uint256 length = slice.length;\\n    retval = new bytes(length);\\n    bytes32 src = bytes32(slice.data);\\n    bytes32 dest = toDataStart(retval);\\n    MemcpyLib.memcpy(dest, src, length);\\n  }\\n  function keccakAt(uint256 data, uint256 length) internal pure returns (bytes32 result) {\\n    assembly {\\n      result := keccak256(data, length)\\n    }\\n  }\\n  function toKeccak(Slice memory slice) internal pure returns (bytes32 result) {\\n    return keccakAt(slice.data, slice.length);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/MemcpyLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary MemcpyLib {\\n  function memcpy(bytes32 dest, bytes32 src, uint256 len) internal pure {\\n    assembly {\\n      for {} iszero(lt(len, 0x20)) { len := sub(len, 0x20) } {\\n        mstore(dest, mload(src))\\n        dest := add(dest, 0x20)\\n        src := add(src, 0x20)\\n      }\\n      let mask := sub(shl(mul(sub(32, len), 8), 1), 1)\\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/assets/curve/CurveAdapterLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\n\\nlibrary CurveAdapterLib {\\n  struct Isolate {\\n    address curveAddress;\\n  }\\n  function getCastStorageType() internal pure returns (function (uint256) internal pure returns (Isolate storage) swap) {\\n    function (uint256) internal returns (uint256) cast = ModuleLib.cast;\\n    assembly {\\n      swap := cast\\n    }\\n  }\\n  function toIsolatePointer(uint256 key) internal pure returns (Isolate storage) {\\n    return getCastStorageType()(key);\\n  }\\n  function computeIsolatePointer(address instance) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(\\\"isolate.curve-adapter\\\", instance)));\\n  }\\n  function getIsolatePointer(address instance) internal pure returns (Isolate storage) {\\n    return toIsolatePointer(computeIsolatePointer(instance));\\n  }\\n  struct ExchangeInputs {\\n    int128 i;\\n    int128 j;\\n    uint256 dx;\\n    uint256 min_dy;\\n  }\\n  function decodeExchangeInputs(bytes memory args) internal pure returns (ExchangeInputs memory) {\\n    (int128 i, int128 j, uint256 dx, uint256 min_dy) = abi.decode(args, (int128, int128, uint256, uint256));\\n    return ExchangeInputs({\\n      i: i,\\n      j: j,\\n      dx: dx,\\n      min_dy: min_dy\\n    });\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TokenUtils.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary TokenUtils {\\n  function encodeTransfer(address target, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.transfer.selector, target, amount);\\n  }\\n  function sendToken(address token, address target, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeTransfer(target, amount));\\n    return success;\\n  }\\n  function encodeTransferFrom(address from, address to, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount);\\n  }\\n  function transferTokenFrom(address token, address from, address to, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeTransferFrom(from, to, amount));\\n    return success;\\n  }\\n  function encodeApproval(address target, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.approve.selector, target, amount);\\n  }\\n  function approveToken(address token, address target, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeApproval(target, amount));\\n    return success;\\n  }\\n  uint256 constant THRESHOLD = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint256 constant MAX_UINT256 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  function approveForMaxIfNeeded(address token, address target) internal returns (bool) {\\n    uint256 approved = getApproved(token, address(this), target);\\n    if (approved > THRESHOLD) return true;\\n    if (approved != 0 && !approveToken(token, address(this), 0)) return false;\\n    return approveToken(token, target, MAX_UINT256);\\n  }\\n  function encodeAllowance(address source, address target) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.allowance.selector, source, target);\\n  }\\n  function decodeUint(bytes memory input) internal pure returns (uint256 retval) {\\n    (retval) = abi.decode(input, (uint256));\\n  }\\n  function getApproved(address token, address source, address target) internal returns (uint256) {\\n    (bool success, bytes memory retval) = token.call(encodeAllowance(source, target));\\n    if (!success || retval.length != 0x20) return 0x1;\\n    return decodeUint(retval);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/BorrowProxyLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { IModuleRegistryProvider } from \\\"./interfaces/IModuleRegistryProvider.sol\\\";\\nimport { AddressSetLib } from \\\"./utils/AddressSetLib.sol\\\";\\nimport { ExtLib } from \\\"./utils/ExtLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { ModuleLib } from \\\"./adapters/lib/ModuleLib.sol\\\";\\n\\nlibrary BorrowProxyLib {\\n  using ModuleLib for *;\\n  struct ProxyIsolate {\\n    address payable masterAddress;\\n    bool unbound;\\n    address owner;\\n    address token;\\n    uint256 actualizedShift;\\n    uint256 liquidationIndex;\\n    uint256 repaymentIndex;\\n    bool isRepaying;\\n    bool isLiquidating;\\n    AddressSetLib.AddressSet liquidationSet;\\n    AddressSetLib.AddressSet repaymentSet;\\n  }\\n  struct ControllerIsolate {\\n    mapping (address => bytes32) proxyInitializerRecord;\\n    mapping (address => address) ownerByProxy;\\n    mapping (address => address) tokenByProxy;\\n    mapping (address => bool) isKeeper;\\n  }\\n  struct Module {\\n    bool isPrecompiled;\\n    address assetSubmodule;\\n    address liquidationSubmodule;\\n    address repaymentSubmodule;\\n  }\\n  struct ModuleDetails {\\n    ModuleRegistrationType moduleType;\\n    address target;\\n    bytes4[] sigs;\\n  }\\n  struct ModuleRegistration {\\n    ModuleRegistrationType moduleType;\\n    address target;\\n    bytes4[] sigs;\\n    Module module;\\n  }\\n  enum ModuleRegistrationType {\\n    UNINITIALIZED,\\n    BY_CODEHASH,\\n    BY_ADDRESS\\n  }\\n  struct ModuleExecution {\\n    address to;\\n    address token;\\n    Module encapsulated;\\n  }\\n  function registryRegisterModule(ModuleRegistry storage registry, ModuleRegistration memory registration) internal {\\n    if (registration.moduleType == ModuleRegistrationType.BY_CODEHASH) for (uint256 i = 0; i < registration.sigs.length; i++) {\\n      registerModuleByCodeHash(registry, registration.target, registration.sigs[i], registration.module);\\n    } else if (registration.moduleType == ModuleRegistrationType.BY_ADDRESS) for (uint256 i = 0; i < registration.sigs.length; i++) {\\n      registerModuleByAddress(registry, registration.target, registration.sigs[i], registration.module);\\n    }\\n  }\\n  function encodeLiquidate(address liquidationSubmodule) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"liquidate(address)\\\", liquidationSubmodule);\\n  }\\n  function decodeBool(bytes memory input) internal pure returns (bool retval) {\\n    (retval) = abi.decode(input, (bool));\\n  }\\n  function delegateLiquidate(address liquidationSubmodule) internal returns (bool) {\\n    (bool success, bytes memory retval) = liquidationSubmodule.delegatecall(encodeLiquidate(liquidationSubmodule));\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    return decodeBool(retval);\\n  }\\n  function encodeRepay(address repaymentSubmodule) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"repay(address)\\\", repaymentSubmodule);\\n  }\\n  function delegateRepay(address repaymentSubmodule) internal returns (bool) {\\n    (bool success, bytes memory retval) = repaymentSubmodule.delegatecall(encodeRepay(repaymentSubmodule));\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    return decodeBool(retval);\\n  }\\n  function encodeNotify(address liquidationSubmodule, bytes memory payload) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"notify(address,bytes)\\\", liquidationSubmodule, payload);\\n  }\\n  function delegateNotify(address liquidationSubmodule, bytes memory payload) internal returns (bool) {\\n    (bool success,) = liquidationSubmodule.delegatecall(encodeNotify(liquidationSubmodule, payload));\\n    return success;\\n  }\\n  function delegate(ModuleExecution memory module, bytes memory payload, uint256 value) internal returns (bool, bytes memory) {\\n    (bool success, bytes memory retval) = module.encapsulated.assetSubmodule.delegatecall{ gas: gasleft() }(ModuleLib.AssetSubmodulePayload({\\n      moduleAddress: address(uint160(module.encapsulated.assetSubmodule)),\\n      liquidationSubmodule: module.encapsulated.liquidationSubmodule,\\n      repaymentSubmodule: module.encapsulated.repaymentSubmodule,\\n      token: address(uint160(module.token)),\\n      txOrigin: tx.origin,\\n      to: address(uint160(module.to)),\\n      value: value,\\n      callData: payload\\n    }).encodeWithSelector());\\n    return (success, retval);\\n  }\\n  function isDefined(Module memory module) internal pure returns (bool) {\\n    return module.assetSubmodule != address(0x0);\\n  }\\n  function isInitialized(ControllerIsolate storage isolate, address proxyAddress) internal view returns (bool) {\\n    return isolate.proxyInitializerRecord[proxyAddress] != bytes32(uint256(0x0));\\n  }\\n  struct ModuleRegistry {\\n    mapping (bytes32 => Module) modules;\\n  }\\n  function isDisbursing(ProxyIsolate storage isolate) internal view returns (bool) {\\n    return isolate.isLiquidating && isolate.liquidationIndex != isolate.liquidationSet.set.length;\\n  }\\n  event BorrowProxyMade(address indexed user, address indexed proxyAddress, bytes record);\\n  function emitBorrowProxyMade(address user, address proxyAddress, bytes memory record) internal {\\n    emit BorrowProxyMade(user, proxyAddress, record);\\n  }\\n  function computeModuleKeyPreimage(address to, bytes4 signature) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(to, signature);\\n  }\\n  function computeModuleKey(address to, bytes4 signature) internal pure returns (bytes32) {\\n    return keccak256(computeModuleKeyPreimage(to, signature));\\n  }\\n  function computeCodeResolverKeyPreimage(bytes32 codehash, bytes4 signature) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(codehash, signature);\\n  }\\n  function computeCodeResolverKey(address to, bytes4 signature) internal view returns (bytes32) {\\n    bytes32 exthash = ExtLib.getExtCodeHash(to);\\n    return keccak256(computeCodeResolverKeyPreimage(exthash, signature));\\n  }\\n  function resolveModule(ModuleRegistry storage registry, address to, bytes4 sig) internal view returns (Module memory) {\\n    Module memory module = registry.modules[computeCodeResolverKey(to, sig)];\\n    if (!isDefined(module)) module = registry.modules[computeModuleKey(to, sig)];\\n    return module;\\n  }\\n  function getModuleExecution(ModuleRegistry storage registry, address to, bytes4 signature) internal view returns (ModuleExecution memory) {\\n    Module memory encapsulated = resolveModule(registry, to, signature);\\n    return ModuleExecution({\\n      encapsulated: encapsulated,\\n      token: address(0x0), // fill in in the proxy call\\n      to: to\\n    });\\n  }\\n  function validateProxyRecord(ControllerIsolate storage isolate, address proxyAddress, bytes memory data) internal view returns (bool) {\\n    return isolate.proxyInitializerRecord[proxyAddress] == keccak256(data);\\n  }\\n  function mapProxyRecord(ControllerIsolate storage isolate, address proxyAddress, bytes memory data) internal {\\n    isolate.proxyInitializerRecord[proxyAddress] = keccak256(data);\\n  }\\n  function setProxyOwner(ControllerIsolate storage isolate, address proxyAddress, address identity) internal {\\n    isolate.ownerByProxy[proxyAddress] = identity;\\n  }\\n  function setProxyToken(ControllerIsolate storage isolate, address proxyAddress, address token) internal {\\n    isolate.tokenByProxy[proxyAddress] = token;\\n  }\\n  function getProxyToken(ControllerIsolate storage isolate, address proxyAddress) internal view returns (address) {\\n    return isolate.tokenByProxy[proxyAddress];\\n  }\\n  function getProxyOwner(ControllerIsolate storage isolate, address proxyAddress) internal view returns (address) {\\n    return isolate.ownerByProxy[proxyAddress];\\n  }\\n  function registerModuleByAddress(ModuleRegistry storage registry, address to, bytes4 signature, Module memory module) internal {\\n    registry.modules[computeModuleKey(to, signature)] = module;\\n  }\\n  function registerModuleByCodeHash(ModuleRegistry storage registry, address to, bytes4 signature, Module memory module) internal {\\n    registry.modules[computeCodeResolverKey(to, signature)] = module;\\n  }\\n  function fetchModule(ProxyIsolate storage isolate, address to, bytes4 signature) internal returns (ModuleExecution memory) {\\n    return ModuleExecution({\\n      encapsulated: IModuleRegistryProvider(isolate.masterAddress).fetchModuleHandler(to, signature),\\n      token: isolate.token,\\n      to: to\\n    });\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint256(_data));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleRegistryProvider.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\n\\ninterface IModuleRegistryProvider {\\n  function fetchModuleHandler(address to, bytes4 sig) external returns (BorrowProxyLib.Module memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AddressSetLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary AddressSetLib {\\n  struct AddressSet {\\n    mapping (address => bool) uniq;\\n    address[] set;\\n  }\\n  function insert(AddressSet storage addressSet, address item) internal {\\n    if (addressSet.uniq[item]) return;\\n    addressSet.set.push(item);\\n  }\\n  function get(AddressSet storage addressSet, uint256 i) internal view returns (address) {\\n    return addressSet.set[i];\\n  }\\n  function size(AddressSet storage addressSet) internal view returns (uint256) {\\n    return addressSet.set.length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ExtLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary ExtLib {\\n  function getExtCodeHash(address target) internal view returns (bytes32 result) {\\n    assembly {\\n      result := extcodehash(target)\\n    }\\n  }\\n  function isContract(address target) internal view returns (bool result) {\\n    assembly {\\n      result := iszero(iszero(extcodesize(target)))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RevertCaptureLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"./SliceLib.sol\\\";\\n\\nlibrary RevertCaptureLib {\\n  using SliceLib for *;\\n  uint32 constant REVERT_WITH_REASON_MAGIC = 0x08c379a0; // keccak256(\\\"Error(string)\\\")\\n  function decodeString(bytes memory input) internal pure returns (string memory retval) {\\n    (retval) = abi.decode(input, (string));\\n  }\\n  function decodeError(bytes memory buffer) internal pure returns (string memory) {\\n    if (buffer.length == 0) return \\\"captured empty revert buffer\\\";\\n    if (uint32(uint256(bytes32(buffer.toSlice(0, 4).asWord()))) != REVERT_WITH_REASON_MAGIC) return \\\"captured a revert error, but it doesn't conform to the standard\\\";\\n    bytes memory revertMessageEncoded = buffer.toSlice(4).copy();\\n    if (revertMessageEncoded.length == 0) return \\\"captured empty revert message\\\";\\n    (string memory revertMessage) = decodeString(revertMessageEncoded);\\n    return revertMessage;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sandbox/SandboxLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"../SliceLib.sol\\\";\\nimport { SafeViewLib } from \\\"./SafeViewLib.sol\\\";\\nimport { BorrowProxy } from \\\"../../BorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../ShifterBorrowProxyLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"../../utils/RevertCaptureLib.sol\\\";\\nimport { PreprocessorLib } from \\\"../../preprocessors/lib/PreprocessorLib.sol\\\";\\nimport { StringLib } from \\\"../../utils/StringLib.sol\\\";\\n\\nlibrary SandboxLib {\\n  using SafeViewLib for *;\\n  using SliceLib for *;\\n  using StringLib for *;\\n  using PreprocessorLib for *;\\n  struct ProtectedExecution {\\n    address to;\\n    bytes txData;\\n    bool success;\\n    bytes returnData;\\n  }\\n  function applyExecutionResult(ProtectedExecution[][] memory trace, uint256 index, ShifterBorrowProxyLib.InitializationAction[] memory preprocessed) internal pure returns (bool) {\\n    ProtectedExecution[] memory execution = new ProtectedExecution[](preprocessed.length);\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      execution[i].txData = preprocessed[i].txData;\\n      execution[i].to = preprocessed[i].to;\\n    }\\n    trace[index] = execution;\\n    return execution.length != 0;\\n  }\\n  struct Context {\\n    address preprocessorAddress;\\n    ProtectedExecution[][] trace;\\n  }\\n  function encodeContext(ExecutionContext memory input) internal pure returns (bytes memory context) {\\n    context = abi.encode(input);\\n  }\\n  function toContext(bytes memory input) internal pure returns (ExecutionContext memory context) {\\n    (context) = abi.decode(input, (ExecutionContext));\\n  }\\n  function _write(ProtectedExecution[][] memory trace, uint256 newSize) internal pure {\\n    assembly {\\n      mstore(trace, newSize)\\n    }\\n  }\\n  function _restrict(Context memory context) internal pure {\\n    _write(context.trace, 0);\\n  }\\n  function _grow(Context memory context) internal pure {\\n    ProtectedExecution[][] memory trace = context.trace;\\n    uint256 newSize = trace.length;\\n    _write(trace, newSize + 1);\\n  }\\n  function toInitializationActions(bytes memory input) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory action) {\\n    (action) = abi.decode(input, (ShifterBorrowProxyLib.InitializationAction[]));\\n  }\\n  function encodeInitializationActions(ShifterBorrowProxyLib.InitializationAction[] memory input) internal pure returns (bytes memory result) {\\n    result = abi.encode(input);\\n  }\\n  function _shrink(Context memory context) internal pure {\\n    _write(context.trace, context.trace.length - 1);\\n  }\\n  function encodeProxyCall(ProtectedExecution memory execution) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(BorrowProxy.proxy.selector, execution.to, 0, execution.txData);\\n  }\\n  function toFlat(ProtectedExecution[][] memory execution) internal pure returns (ProtectedExecution[] memory trace) {\\n    uint256 total = 0;\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      total += execution[i].length;\\n    }\\n    trace = new ProtectedExecution[](total);\\n    uint256 seen = 0;\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      for (uint256 j = 0; j < execution[i].length; j++) {\\n        trace[seen] = execution[i][j];\\n      }\\n    }\\n  }\\n  function getNewContext(ShifterBorrowProxyLib.InitializationAction[] memory actions) internal pure returns (Context memory context) {\\n    ProtectedExecution[][] memory trace = new ProtectedExecution[][](actions.length);\\n    for (uint256 i = 0; i < actions.length; i++) {\\n      trace[i] = new ProtectedExecution[](1);\\n      trace[i][0].to = actions[i].to;\\n      trace[i][0].txData = actions[i].txData;\\n    }\\n    context = Context({\\n      trace: trace,\\n      preprocessorAddress: address(0)\\n    });\\n  }\\n  struct ExecutionContext {\\n    ProtectedExecution last;\\n    address preprocessorAddress;\\n  }\\n  function executeSafeView(bytes memory creationCode, uint256 index, Context memory context) internal returns (SafeViewLib.SafeViewResult memory result) {\\n    ExecutionContext memory executionContext;\\n    executionContext.preprocessorAddress = context.preprocessorAddress;\\n    if (index != 0) {\\n      ProtectedExecution[] memory lastBatch = context.trace[index];\\n      if (lastBatch.length != 0) executionContext.last = lastBatch[lastBatch.length - 1];\\n    }\\n    result = creationCode.safeView(encodeContext(executionContext));\\n  }\\n  function processActions(ShifterBorrowProxyLib.InitializationAction[] memory actions) internal returns (ProtectedExecution[] memory trace) {\\n    Context memory context = getNewContext(actions);\\n    for (uint256 i = 0; i < actions.length; i++) {\\n      ProtectedExecution[] memory execution = context.trace[i];\\n      if (execution[0].to == address(0x0)) {\\n        context.preprocessorAddress = execution[0].txData.deriveViewAddress();\\n        SafeViewLib.SafeViewResult memory safeViewResult = executeSafeView(execution[0].txData, i, context);\\n        execution[0].txData = new bytes(0x0);\\n        if (safeViewResult.success) {\\n          if (!applyExecutionResult(context.trace, i, toInitializationActions(safeViewResult.data))) break;\\n        } else {\\n          execution[0].returnData = safeViewResult.data;\\n          execution[0].success = safeViewResult.success;\\n// for debugging\\n          bytes memory data = execution[0].returnData;\\n          assembly {\\n            revert(add(data, 0x20), mload(data))\\n          }\\n// end\\n          continue;\\n        }\\n      }\\n      execution = context.trace[i];\\n      for (uint256 j = 0; j < execution.length; j++) {\\n        (bool success, bytes memory returnData) = address(this).call(encodeProxyCall(execution[j]));\\n        execution[j].success = success;\\n// for debugging\\n        if (!execution[j].success) {\\n          assembly {\\n            revert(add(0x20, returnData), mload(returnData))\\n          }\\n        }\\n// end\\n        execution[j].returnData = returnData;\\n      }\\n    }\\n    return toFlat(context.trace);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sandbox/SafeViewLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ISafeView } from \\\"./ISafeView.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary SafeViewLib {\\n  struct SafeViewResult {\\n    bool success;\\n    bytes data;\\n  }\\n  function executeLogic(address viewLayer, bytes memory context) internal returns (SafeViewResult memory) {\\n    (bool success, bytes memory retval) = viewLayer.delegatecall(encodeExecute(context));\\n    return SafeViewResult({\\n      success: success,\\n      data: retval\\n    });\\n  }\\n  function encodeResult(SafeViewResult memory input) internal pure returns (bytes memory retval) {\\n    retval = abi.encode(input);\\n  }\\n  function revertWithData(bytes memory input) internal pure {\\n    assembly {\\n      revert(add(input, 0x20), mload(input))\\n    }\\n  }\\n  function decodeViewResult(bytes memory data) internal pure returns (SafeViewResult memory result) {\\n     (result) = abi.decode(data, (SafeViewResult));\\n   }\\n   function encodeExecuteSafeView(bytes memory creationCode, bytes memory context) internal pure returns (bytes memory retval) {\\n     retval = abi.encodeWithSelector(ISafeView._executeSafeView.selector, creationCode, context);\\n   }\\n   function encodeExecute(bytes memory context) internal pure returns (bytes memory retval) {\\n     retval = abi.encodeWithSelector(ISafeView.execute.selector, context);\\n   }\\n  function safeView(bytes memory creationCode, bytes memory context) internal returns (SafeViewLib.SafeViewResult memory) {\\n    (/* bool success */, bytes memory retval) = address(this).call(encodeExecuteSafeView(creationCode, context));\\n    return decodeViewResult(retval);\\n  }\\n  bytes32 constant STEALTH_VIEW_DEPLOY_SALT = 0xad53495153c7c363e98a26920ec679e0e687636458f6908c91cf6deadb190801;\\n  function GET_STEALTH_VIEW_DEPLOY_SALT() internal pure returns (bytes32) {\\n    return STEALTH_VIEW_DEPLOY_SALT;\\n  }\\n  function deriveViewAddress(bytes memory creationCode) internal view returns (address) {\\n    return Create2.computeAddress(STEALTH_VIEW_DEPLOY_SALT, keccak256(creationCode));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sandbox/ISafeView.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface ISafeView {\\n  function execute(bytes calldata) external;\\n  function _executeSafeView(bytes calldata, bytes calldata) external;\\n}\\n\"\r\n    },\r\n    \"contracts/BorrowProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.0;\\n\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SliceLib } from \\\"./utils/SliceLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IBorrowProxyController } from \\\"./interfaces/IBorrowProxyController.sol\\\";\\nimport { AddressSetLib } from \\\"./utils/AddressSetLib.sol\\\";\\nimport { ModuleLib } from \\\"./adapters/lib/ModuleLib.sol\\\";\\n\\ncontract BorrowProxy {\\n  using SliceLib for *;\\n  using BorrowProxyLib for *;\\n  using AddressSetLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  modifier onlyOwnerOrPool {\\n   require(msg.sender == isolate.owner || msg.sender == isolate.masterAddress || msg.sender == address(this), \\\"borrow proxy can only be used by borrower\\\");\\n    _;\\n  }\\n  function setup(address owner, address token, bool unbound) public returns (bool) {\\n    require(isolate.owner == address(0x0), \\\"can't initialize twice\\\");\\n    isolate.masterAddress = msg.sender;\\n    isolate.owner = owner;\\n    isolate.unbound = unbound;\\n    isolate.token = token;\\n    return true;\\n  }\\n  function validateProxyRecord(bytes memory record) internal returns (bool) {\\n    return IBorrowProxyController(isolate.masterAddress).validateProxyRecordHandler(record);\\n  }\\n  function proxy(address to, uint256 value, bytes memory payload) public onlyOwnerOrPool {\\n    require(to != isolate.masterAddress, \\\"can't target the ShifterPool\\\");\\n    bytes4 sig = bytes4(uint32(uint256(payload.toSlice(0, 4).asWord())));\\n    BorrowProxyLib.ModuleExecution memory module = isolate.fetchModule(to, sig);\\n    module.token = isolate.token;\\n    if (isolate.unbound && !module.encapsulated.isPrecompiled) {\\n      (bool success, bytes memory retval) = to.call{\\n        value: value\\n      }(payload);\\n      if (!success) revert(RevertCaptureLib.decodeError(retval));\\n      ModuleLib.bubbleResult(success, retval);\\n      return;\\n    }\\n    require(module.encapsulated.isDefined(), \\\"function handler not registered\\\");\\n    (bool success, bytes memory retval) = module.delegate(payload, value);\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    if (module.encapsulated.liquidationSubmodule != address(0x0)) isolate.liquidationSet.insert(module.encapsulated.liquidationSubmodule);\\n    if (module.encapsulated.repaymentSubmodule != address(0x0)) {\\n      isolate.repaymentSet.insert(module.encapsulated.repaymentSubmodule);\\n    }\\n    ModuleLib.bubbleResult(success, retval);\\n  }\\n  receive() external payable virtual {\\n    // just receive ether, do nothing\\n  } \\n  fallback() external payable virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShifter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IShifter {\\n  function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\\n  function mintFee() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBorrowProxyController.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IBorrowProxyController {\\n  function getProxyOwnerHandler() external returns (address);\\n  function validateProxyRecordHandler(bytes calldata) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ShifterBorrowProxyLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IInitializationActionsReceiver } from \\\"./interfaces/IInitializationActionsReceiver.sol\\\";\\nimport { ECDSA } from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IShifterERC20 } from \\\"./interfaces/IShifterERC20.sol\\\";\\n\\nlibrary ShifterBorrowProxyLib {\\n  using SafeMath for *;\\n  using TokenUtils for *;\\n  struct ProxyRecord {\\n    LiquidityRequest request;\\n    LenderRecord loan;\\n    uint256 expected;\\n  }\\n  struct LiquidityRequest {\\n    address payable borrower;\\n    address token;\\n    bytes32 nonce;\\n    uint256 amount;\\n    bool forbidLoan;\\n    InitializationAction[] actions;\\n  }\\n  struct InitializationAction {\\n    address to;\\n    bytes txData;\\n  }\\n  event BorrowProxyInitialization(address indexed proxyAddress, SandboxLib.ProtectedExecution[]);\\n  function emitBorrowProxyInitialization(address /* proxyAddress */, SandboxLib.ProtectedExecution[] memory /* trace */) internal {\\n//    emit BorrowProxyInitialization(proxyAddress, trace);\\n  }\\n    \\n  function encodeProxyRecord(ProxyRecord memory record) internal pure returns (bytes memory result) {\\n    result = abi.encode(record);\\n  }\\n  function decodeProxyRecord(bytes memory record) internal pure returns (ProxyRecord memory result) {\\n    (result) = abi.decode(record, (ProxyRecord));\\n  }\\n  struct LiquidityRequestParcel {\\n    LiquidityRequest request;\\n    uint256 gasRequested;\\n    bytes signature;\\n  }\\n  function computeDepositAddress(LiquidityRequestParcel memory /* parcel */, address /* mpkh */, bool /* btcTestnet */) internal pure returns (string memory result) {\\n    result = \\\"\\\";\\n  }\\n  struct LenderParams {\\n    uint256 timeoutExpiry;\\n    uint256 bond;\\n    uint256 poolFee;\\n    uint256 keeperFee;\\n  }\\n  struct LenderRecord {\\n    address keeper;\\n    LenderParams params;\\n  }\\n  event ShifterBorrowProxyRepaid(address indexed user, ProxyRecord record);\\n  function emitShifterBorrowProxyRepaid(address user, ProxyRecord memory record) internal {\\n    emit ShifterBorrowProxyRepaid(user, record);\\n  }\\n  function encodeBorrowerMessage(LiquidityRequest memory params, bytes memory parcelActionsEncoded) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(params.borrower, params.token, params.nonce, params.amount, params.forbidLoan, parcelActionsEncoded);\\n  }\\n  function computeBorrowerSalt(LiquidityRequest memory params) internal pure returns (bytes32 result) {\\n    result = keccak256(computeBorrowerSaltPreimage(params));\\n  }\\n  function computeBorrowerSaltPreimage(LiquidityRequest memory params) internal pure returns (bytes memory result) {\\n    bytes memory parcelActionsEncoded = encodeParcelActions(params.actions);\\n    result = encodeBorrowerMessage(params, parcelActionsEncoded);\\n  }\\n  function encodeParcelActions(InitializationAction[] memory actions) internal pure returns (bytes memory retval) {\\n    retval = abi.encode(actions);\\n  }\\n  function computeLiquidityRequestParcelMessage(LiquidityRequestParcel memory parcel, bytes memory parcelActionsEncoded) internal view returns (bytes memory retval) {\\n    retval = abi.encodePacked(address(this), parcel.request.token, parcel.request.nonce, parcel.request.amount, parcel.gasRequested, parcel.request.forbidLoan, parcelActionsEncoded);\\n  }\\n  function computeLiquidityRequestPreimage(LiquidityRequestParcel memory parcel) internal view returns (bytes memory result) {\\n    bytes memory parcelActionsEncoded = encodeParcelActions(parcel.request.actions);\\n    result = computeLiquidityRequestParcelMessage(parcel, parcelActionsEncoded);\\n  }\\n  function computeLiquidityRequestHash(LiquidityRequestParcel memory parcel) internal view returns (bytes32 result) {\\n    result = keccak256(computeLiquidityRequestPreimage(parcel));\\n  }\\n  function validateSignature(LiquidityRequestParcel memory parcel, bytes32 hash) internal pure returns (bool) {\\n    return parcel.request.borrower == ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), parcel.signature);\\n  }\\n  function validateSignature(LiquidityRequestParcel memory parcel) internal view returns (bool) {\\n    return parcel.request.borrower == ECDSA.recover(ECDSA.toEthSignedMessageHash(computeLiquidityRequestHash(parcel)), parcel.signature);\\n  }\\n  struct ShiftParameters {\\n    bytes32 txhash;\\n    uint256 vout;\\n    bytes32 pHash;\\n    uint256 amount;\\n    bytes darknodeSignature;\\n  }\\n  struct TriggerParcel {\\n    ProxyRecord record;\\n    ShiftParameters shiftParameters;\\n  }\\n  struct SansBorrowShiftParcel {\\n    LiquidityRequestParcel liquidityRequestParcel;\\n    ShiftParameters shiftParameters;\\n    InitializationAction[] actions;\\n  }\\n  function decodeTriggerParcel(bytes memory parcel) internal pure returns (TriggerParcel memory result) {\\n    (result) = abi.decode(parcel, (TriggerParcel));\\n  }\\n  function encodeNPreimage(TriggerParcel memory parcel) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(parcel.record.request.nonce, parcel.shiftParameters.txhash, parcel.shiftParameters.vout);\\n  }\\n  function computeNHash(TriggerParcel memory parcel) internal pure returns (bytes32) {\\n    return keccak256(encodeNPreimage(parcel));\\n  }\\n  uint256 constant BIPS_DENOMINATOR = 10000;\\n  function computeExpectedAmount(uint256 amount, address shifter, address token) internal returns (uint256 expected) {\\n    uint256 mintFee = getMintFee(shifter);\\n    uint256 underlyingAmount = getUnderlyingAmount(token, amount);\\n    uint256 fee = underlyingAmount.mul(mintFee).div(BIPS_DENOMINATOR);\\n    expected = underlyingAmount.sub(fee);\\n  }\\n  function getMintFee(address shifter) internal view returns (uint256 mintFee) {\\n    mintFee = uint256(IShifter(shifter).mintFee());\\n  }\\n  function getUnderlyingAmount(address token, uint256 amount) internal returns (uint256 underlyingAmount) {\\n    underlyingAmount = IShifterERC20(token).fromUnderlying(amount);\\n  }\\n  function computePostFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.sub(computePoolFee(record).add(computeKeeperFee(record)));\\n  }\\n  function computePoolFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.mul(record.loan.params.poolFee).div(uint256(1 ether));\\n  }\\n  function computeKeeperFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.mul(record.loan.params.keeperFee).div(uint256(1 ether));\\n  }\\n  function computeAdjustedKeeperFee(ProxyRecord memory record, uint256 actual) internal pure returns (uint256) {\\n    return actual.mul(record.loan.params.keeperFee).div(uint256(1 ether));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInitializationActionsReceiver.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\n\\ninterface IInitializationActionsReceiver {\\n  function receiveInitializationActions(ShifterBorrowProxyLib.InitializationAction[] calldata actions) external returns (SandboxLib.Context memory context);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShifterERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IShifterERC20 {\\n  function fromUnderlying(uint256 amount) external returns (uint256);\\n}\\n  \\n\"\r\n    },\r\n    \"contracts/preprocessors/lib/PreprocessorLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SandboxLib } from \\\"../../utils/sandbox/SandboxLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../ShifterBorrowProxyLib.sol\\\";\\n\\nlibrary PreprocessorLib {\\n  function toContext(bytes memory input) internal pure returns (SandboxLib.ExecutionContext memory) {\\n    return SandboxLib.toContext(input);\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction memory action, ShifterBorrowProxyLib.InitializationAction memory nextAction) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](2);\\n    result[0] = action;\\n    result[1] = nextAction;\\n  }\\n  function getLastExecution(SandboxLib.Context memory context) internal pure returns (bool foundLast, SandboxLib.ProtectedExecution memory execution) {\\n    if (context.trace.length == 0) return (foundLast, execution);\\n    SandboxLib.ProtectedExecution[] memory lastBatch = context.trace[context.trace.length - 1];\\n    execution = lastBatch[lastBatch.length - 1];\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction[] memory actions, ShifterBorrowProxyLib.InitializationAction[] memory nextActions) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](actions.length + nextActions.length);\\n    uint256 i = 0;\\n    for (; i < actions.length; i++) {\\n      result[i] = actions[i];\\n    }\\n    for (uint256 j = 0; j < nextActions.length; j++) {\\n      result[i] = nextActions[j];\\n      i++;\\n    }\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction[] memory actions, ShifterBorrowProxyLib.InitializationAction memory nextAction) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = then(actions, toList(nextAction));\\n  }\\n  function toList(ShifterBorrowProxyLib.InitializationAction memory input) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](1);\\n    result[0] = input;\\n  }\\n  function sendTransaction(address to, bytes memory txData) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    return toList(ShifterBorrowProxyLib.InitializationAction({\\n      to: to,\\n      txData: txData\\n    }));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/StringLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary StringLib {\\n    /// @notice Convert a uint value to its decimal string representation\\n    // solium-disable-next-line security/no-assign-params\\n    function toString(uint256 _i) internal pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @notice Convert a bytes32 value to its hex string representation\\n    function toString(bytes32 _value) internal pure returns (string memory) {\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(32 * 2 + 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 32; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n\\n    /// @notice Convert an address to its hex string representation\\n    function toString(address _addr) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(_addr));\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(20 * 2 + 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 20; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n    function toString(bytes memory input) internal pure returns (string memory) {\\n      return string(input);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurve.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract ICurve {\\n  uint256 constant N_COINS = 4;\\n  function add_liquidity(uint256[N_COINS] calldata amounts, uint256 min_mint_amount) external virtual;\\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external virtual;\\n  function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external virtual;\\n  function remove_liquidity(uint256 _amount, uint256[N_COINS] calldata min_amounts) external virtual;\\n  function remove_liquidity_imbalance(uint256[N_COINS] calldata amounts, uint256 max_burn_amount) external virtual;\\n  function coins(uint256 i) external virtual returns (address payable);\\n  function underlying_coins(uint256 i) external virtual returns (address payable);\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/assets/erc20/ERC20Adapter.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { ERC20AdapterLib } from \\\"./ERC20AdapterLib.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\n\\ncontract ERC20Adapter {\\n  using ERC20AdapterLib for *;\\n  using ModuleLib for *;\\n  using TokenUtils for *;\\n  BorrowProxyLib.ProxyIsolate proxyIsolate;\\n  function getExternalIsolateHandler() external pure returns (ERC20AdapterLib.Isolate memory) {\\n    return ERC20AdapterLib.getIsolatePointer();\\n  }\\n  function repay(address /* moduleAddress */)  public returns (bool) {\\n    return proxyIsolate.processEscrowForwards();\\n  }\\n  function handle(ModuleLib.AssetSubmodulePayload memory payload) public payable {\\n    (bytes4 sig, bytes memory args) = payload.callData.splitPayload();\\n    if (sig == ERC20.transfer.selector) {\\n       ERC20AdapterLib.TransferInputs memory inputs = args.decodeTransferInputs();\\n       require(proxyIsolate.sendToEscrow(inputs.recipient, payload.to, inputs.amount), \\\"token transfer to escrow wallet failed\\\");\\n    } else if (sig == ERC20.approve.selector) {\\n      // do nothing\\n    } else revert(\\\"unsupported token call\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/assets/erc20/ERC20AdapterLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { AssetForwarder } from \\\"../../lib/AssetForwarder.sol\\\";\\nimport { AssetForwarderLib } from \\\"../../lib/AssetForwarderLib.sol\\\";\\nimport { ERC20Adapter } from \\\"./ERC20Adapter.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { StringLib } from \\\"../../../utils/StringLib.sol\\\";\\nimport { ShifterPoolLib } from \\\"../../../ShifterPoolLib.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { FactoryLib } from \\\"../../../FactoryLib.sol\\\";\\nimport { ShifterPool } from \\\"../../../ShifterPool.sol\\\";\\n\\nlibrary ERC20AdapterLib {\\n  using ShifterPoolLib for *;\\n  using TokenUtils for *;\\n  using StringLib for *;\\n  struct EscrowRecord {\\n    address recipient;\\n    address token;\\n  }\\n  struct Isolate {\\n    EscrowRecord[] payments;\\n    bool isProcessing;\\n    uint256 processed;\\n  }\\n  function isDone(Isolate storage isolate) internal view returns (bool) {\\n    return !isolate.isProcessing && isolate.payments.length == isolate.processed;\\n  }\\n  function computeIsolatePointer() public pure returns (uint256) {\\n    return uint256(keccak256(\\\"isolate.erc20-adapter\\\"));\\n  }\\n  function computeForwarderSalt(uint256 index) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(index));\\n  }\\n  function computeForwarderAddress(BorrowProxyLib.ProxyIsolate storage proxyIsolate, uint256 index) internal view returns (address) {\\n    return FactoryLib.deriveInstanceAddress(proxyIsolate.masterAddress, ShifterPool(proxyIsolate.masterAddress).getAssetForwarderImplementationHandler(), keccak256(abi.encodePacked(AssetForwarderLib.GET_ASSET_FORWARDER_IMPLEMENTATION_SALT(), address(this), computeForwarderSalt(index))));\\n  }\\n  function liquidate(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal returns (bool) {\\n    return processEscrowReturns(proxyIsolate);\\n  }\\n  struct TransferInputs {\\n    address recipient;\\n    uint256 amount;\\n  }\\n  function decodeTransferInputs(bytes memory args) internal pure returns (TransferInputs memory) {\\n    (address recipient, uint256 amount) = abi.decode(args, (address, uint256));\\n    return TransferInputs({\\n      recipient: recipient,\\n      amount: amount\\n    });\\n  }\\n  event Log(address indexed data);\\n  function forwardEscrow(BorrowProxyLib.ProxyIsolate storage proxyIsolate, EscrowRecord memory record, uint256 index) internal {\\n    address forwarder = proxyIsolate.deployAssetForwarder(computeForwarderSalt(index));\\n    emit Log(forwarder);\\n    emit Log(computeForwarderAddress(proxyIsolate, index));\\n    AssetForwarder(forwarder).forwardAsset(address(uint160(record.recipient)), record.token);\\n  }\\n  function returnEscrow(BorrowProxyLib.ProxyIsolate storage proxyIsolate, EscrowRecord memory record, uint256 index) internal {\\n    address forwarder = proxyIsolate.deployAssetForwarder(computeForwarderSalt(index));\\n    AssetForwarder(forwarder).forwardAsset(address(uint160(address(this))), record.token);\\n  }\\n  uint256 constant MINIMUM_GAS_TO_PROCESS = 5e5;\\n  uint256 constant MAX_RECORDS = 100;\\n  function processEscrowForwards(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal returns (bool) {\\n    Isolate storage isolate = getIsolatePointer();\\n    if (!isolate.isProcessing) isolate.isProcessing = true;\\n    for (uint256 i = isolate.processed; i < isolate.payments.length; i++) {\\n      if (gasleft() < MINIMUM_GAS_TO_PROCESS) {\\n        isolate.processed = i;\\n        return false;\\n      } else {\\n        forwardEscrow(proxyIsolate, isolate.payments[i], i);\\n      }\\n    }\\n    return true;\\n  }\\n  function processEscrowReturns(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal returns (bool) {\\n    Isolate storage isolate = getIsolatePointer();\\n    if (!isolate.isProcessing) isolate.isProcessing = true;\\n    for (uint256 i = isolate.processed; i < isolate.payments.length; i++) {\\n      if (gasleft() < MINIMUM_GAS_TO_PROCESS) {\\n        isolate.processed = i;\\n        return false;\\n      } else {\\n        returnEscrow(proxyIsolate, isolate.payments[i], i);\\n      }\\n    }\\n    return true;\\n  }\\n  function sendToEscrow(BorrowProxyLib.ProxyIsolate storage proxyIsolate, address recipient, address token, uint256 amount) internal returns (bool) {\\n     Isolate storage isolate = getIsolatePointer();\\n     address escrowWallet = computeForwarderAddress(proxyIsolate, isolate.payments.length);\\n     installEscrowRecord(recipient, token);\\n     return token.sendToken(escrowWallet, amount);\\n  }\\n  function installEscrowRecord(address recipient, address token) internal {\\n    Isolate storage isolate = getIsolatePointer();\\n    isolate.payments.push(EscrowRecord({\\n      recipient: recipient,\\n      token: token\\n    }));\\n  }\\n  function deriveNextForwarderAddress(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal view returns (address) {\\n    Isolate storage isolate = getIsolatePointer();\\n    return computeForwarderAddress(proxyIsolate, isolate.payments.length);\\n  }\\n  function getCastStorageType() internal pure returns (function (uint256) internal pure returns (Isolate storage) swap) {\\n    function (uint256) internal returns (uint256) cast = ModuleLib.cast;\\n    assembly {\\n      swap := cast\\n    }\\n  }\\n  function toIsolatePointer(uint256 key) internal pure returns (Isolate storage) {\\n    return getCastStorageType()(key);\\n  }\\n  function getIsolatePointer() internal pure returns (Isolate storage) {\\n    return toIsolatePointer(computeIsolatePointer());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/lib/AssetForwarder.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenUtils } from \\\"../../utils/TokenUtils.sol\\\";\\n\\ncontract AssetForwarder {\\n  using TokenUtils for *;\\n  bool public locked;\\n  function lock() public {\\n    locked = true;\\n  }\\n  function forwardAsset(address payable target, address token) public payable {\\n    require(!locked);\\n    if (token != address(0x0)) require(token.sendToken(target, IERC20(token).balanceOf(address(this))), \\\"erc20 forward failure\\\");\\n    selfdestruct(target);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/lib/AssetForwarderLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { AssetForwarder } from \\\"./AssetForwarder.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { FactoryLib } from \\\"../../FactoryLib.sol\\\";\\nimport { ShifterPool } from \\\"../../ShifterPool.sol\\\";\\n\\nlibrary AssetForwarderLib {\\n  bytes32 constant ASSET_FORWARDER_IMPLEMENTATION_SALT = 0x6b6f6b75258f8f4cdb6ef275682bc2be3e8b970e5e4417113bd1ea53622d907e; // keccak(\\\"asset-forwarder-implementation\\\")\\n  function GET_ASSET_FORWARDER_IMPLEMENTATION_SALT() internal pure returns (bytes32) {\\n    return ASSET_FORWARDER_IMPLEMENTATION_SALT;\\n  }\\n  function deployAssetForwarder() internal returns (address output) {\\n    output = Create2.deploy(0, ASSET_FORWARDER_IMPLEMENTATION_SALT, type(AssetForwarder).creationCode);\\n  }\\n  function deployAssetForwarderClone(address target, bytes32 salt) internal returns (address output) {\\n    output = FactoryLib.create2Clone(target, uint256(salt));\\n  }\\n  function deriveAssetForwarderAddress(address payable shifterPool, address from, bytes32 salt) internal view returns (address) {\\n    return FactoryLib.deriveInstanceAddress(shifterPool, ShifterPool(shifterPool).getAssetForwarderImplementationHandler(), keccak256(abi.encodePacked(GET_ASSET_FORWARDER_IMPLEMENTATION_SALT(), from, salt)));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/FactoryLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary FactoryLib {\\n  function computeCreationCode(address target) internal view returns (bytes memory clone) {\\n    clone = computeCreationCode(address(this), target);\\n  }\\n  function computeCreationCode(address deployer, address target) internal pure returns (bytes memory clone) {\\n      bytes memory consData = abi.encodeWithSignature(\\\"cloneConstructor(bytes)\\\", new bytes(0));\\n      clone = new bytes(99 + consData.length);\\n      assembly {\\n        mstore(add(clone, 0x20),\\n           0x3d3d606380380380913d393d73bebebebebebebebebebebebebebebebebebebe)\\n        mstore(add(clone, 0x2d),\\n           mul(deployer, 0x01000000000000000000000000))\\n        mstore(add(clone, 0x41),\\n           0x5af4602a57600080fd5b602d8060366000396000f3363d3d373d3d3d363d73be)\\n           mstore(add(clone, 0x60),\\n           mul(target, 0x01000000000000000000000000))\\n        mstore(add(clone, 116),\\n           0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      }\\n      for (uint256 i = 0; i < consData.length; i++) {\\n        clone[i + 99] = consData[i];\\n      }\\n  }\\n  function deriveInstanceAddress(address target, bytes32 salt) internal view returns (address) {\\n    return Create2.computeAddress(salt, keccak256(computeCreationCode(target)));\\n  }\\n  function deriveInstanceAddress(address from, address target, bytes32 salt) internal pure returns (address) {\\n     return Create2.computeAddress(salt, keccak256(computeCreationCode(from, target)), from);\\n  }\\n  function create2Clone(address target, uint saltNonce) internal returns (address result) {\\n    bytes memory clone = computeCreationCode(target);\\n    bytes32 salt = bytes32(saltNonce);\\n      \\n    assembly {\\n      let len := mload(clone)\\n      let data := add(clone, 0x20)\\n      result := create2(0, data, len, salt)\\n    }\\n      \\n    require(result != address(0), \\\"create2 failed\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ShifterPool.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IShifterRegistry } from \\\"./interfaces/IShifterRegistry.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { ShifterPoolLib } from \\\"./ShifterPoolLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\nimport { ShifterBorrowProxyFactoryLib } from \\\"./ShifterBorrowProxyFactoryLib.sol\\\";\\nimport { ShifterBorrowProxy } from \\\"./ShifterBorrowProxy.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { ViewExecutor } from \\\"./utils/ViewExecutor.sol\\\";\\nimport { LiquidityToken } from \\\"./LiquidityToken.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { SafeViewExecutor } from \\\"./utils/sandbox/SafeViewExecutor.sol\\\";\\nimport { FactoryLib } from \\\"./FactoryLib.sol\\\";\\nimport { NullCloneConstructor } from \\\"./NullCloneConstructor.sol\\\";\\nimport { AssetForwarderLib } from \\\"./adapters/lib/AssetForwarderLib.sol\\\";\\nimport { AssetForwarder } from \\\"./adapters/lib/AssetForwarder.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { StringLib } from \\\"./utils/StringLib.sol\\\";\\nimport { ExtLib } from \\\"./utils/ExtLib.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\ncontract ShifterPool is Ownable, SafeViewExecutor, NullCloneConstructor {\\n  using SandboxLib for *;\\n  using SafeMath for *;\\n  using ShifterPoolLib for *;\\n  using TokenUtils for *;\\n  using StringLib for *;\\n  using ExtLib for *;\\n  using ShifterBorrowProxyLib for *;\\n  using ShifterBorrowProxyFactoryLib for *;\\n  using BorrowProxyLib for *;\\n  ShifterPoolLib.Isolate isolate;\\n  constructor() Ownable() public {\\n    isolate.genesis = block.number;\\n  }\\n  function setup(ShifterPoolLib.SetupParams memory params, BorrowProxyLib.ModuleDetails[] memory moduleDetails, BorrowProxyLib.Module[] memory modules, ShifterPoolLib.LiquidityTokenLaunch[] memory tokenLaunches) public onlyOwner {\\n    require(modules.length == moduleDetails.length, \\\"can't zip module registations: modules.length != moduleDetails.length\\\");\\n    isolate.shifterRegistry = params.shifterRegistry;\\n    isolate.maxLoan = params.maxLoan;\\n    isolate.minTimeout = params.minTimeout;\\n    isolate.poolFee = params.poolFee;\\n    isolate.daoFee = params.daoFee;\\n    isolate.gasEstimate = params.gasEstimate;\\n    isolate.maxGasPriceForRefund = params.maxGasPriceForRefund;\\n    for (uint256 i = 0; i < modules.length; i++) {\\n      BorrowProxyLib.ModuleRegistration memory registration = BorrowProxyLib.ModuleRegistration({\\n        module: modules[i],\\n        target: moduleDetails[i].target,\\n        sigs: moduleDetails[i].sigs,\\n        moduleType: moduleDetails[i].moduleType\\n      });\\n      isolate.registry.registryRegisterModule(registration);\\n    }\\n    for (uint256 i = 0; i < tokenLaunches.length; i++) {\\n      ShifterPoolLib.LiquidityTokenLaunch memory launch = tokenLaunches[i];\\n      isolate.tokenToLiquidityToken[launch.token] = launch.liqToken;\\n      isolate.tokenToBaseFee[launch.token] = launch.baseFee;\\n    }\\n  }\\n  function getGasReserved(address proxyAddress) view public returns (uint256) {\\n    return isolate.gasReserved[proxyAddress];\\n  }\\n  function payoutCallbackGas(address payable borrower, uint256 amountBorrower, uint256 amountOrigin) public {\\n    if (amountOrigin != 0) tx.origin.send(amountOrigin);\\n    if (amountBorrower != 0) borrower.send(amountBorrower);\\n  }\\n  function getLiquidityTokenForTokenHandler(address token) public view returns (address) {\\n    return isolate.tokenToLiquidityToken[token];\\n  }\\n  bytes32 constant BORROW_PROXY_IMPLEMENTATION_SALT = 0xfe1e3164ba4910db3c9afd049cd8feb4552390569c846692e6df4ac68aeaa90e;\\n  function deployBorrowProxyImplementation() public {\\n    require(isolate.borrowProxyImplementation == address(0x0), \\\"already deployed\\\");\\n    isolate.borrowProxyImplementation = isolate.makeBorrowProxy(BORROW_PROXY_IMPLEMENTATION_SALT);\\n    address payable borrowProxyImplementation = address(uint160(isolate.borrowProxyImplementation));\\n//    borrowProxyImplementation.setupBorrowProxy(address(0x1), address(0x1), false);\\n  }\\n  function computeProxyAddress(bytes32 salt) public view returns (address) {\\n    return isolate.borrowProxyImplementation.deriveBorrowerAddress(salt);\\n  }\\n  function deployAssetForwarderImplementation() public {\\n    require(isolate.assetForwarderImplementation == address(0x0), \\\"already deployed\\\");\\n    isolate.assetForwarderImplementation = AssetForwarderLib.deployAssetForwarder();\\n    AssetForwarder(isolate.assetForwarderImplementation).lock();\\n  }\\n\\n  function deployAssetForwarderClone(bytes32 salt) public returns (address created) {\\n\\n    created = FactoryLib.create2Clone(isolate.assetForwarderImplementation, uint256(keccak256(abi.encodePacked(AssetForwarderLib.GET_ASSET_FORWARDER_IMPLEMENTATION_SALT(), msg.sender, salt))));\\n\\n  }\\n  function getAssetForwarderImplementationHandler() public view returns (address implementation) {\\n    return isolate.assetForwarderImplementation;\\n  }\\n  function deployBorrowProxyClone(bytes32 salt) internal returns (address payable created) {\\n    created = address(uint160(FactoryLib.create2Clone(isolate.borrowProxyImplementation, uint256(salt))));\\n  }\\n  function validateUnderMaxLoan(ShifterBorrowProxyLib.LiquidityRequestParcel memory parcel) internal view returns (bool) {\\n    uint8 decimals = ERC20(parcel.request.token).decimals();\\n    require(decimals <= 18, \\\"the token supplied is not a shifter token -- decimals too high\\\");\\n    require(parcel.request.amount / 10**(18 - uint256(decimals)) <= isolate.maxLoan, \\\"loan exceeds maximum\\\");\\n  }\\n  function _executeBorrow(ShifterPoolLib.BorrowState memory state, ShifterBorrowProxyLib.LiquidityRequestParcel memory liquidityRequestParcel, uint256 bond, uint256 timeoutExpiry) internal returns (address payable proxyAddress) {\\n    require(liquidityRequestParcel.request.forbidLoan == false, \\\"is not a loan request, try using executeShiftSansBorrow\\\");\\n    require(\\n      liquidityRequestParcel.gasRequested == msg.value,\\n      \\\"supplied ether is not equal to gas requested\\\"\\n  \\n    );\\n    require(\\n      liquidityRequestParcel.validateSignature(\\n        liquidityRequestParcel.computeLiquidityRequestHash()\\n      ),\\n      \\\"liquidity request signature rejected\\\"\\n    );\\n    ShifterBorrowProxyLib.LiquidityRequest memory liquidityRequest = liquidityRequestParcel.request;\\n    bytes32 borrowerSalt = liquidityRequest.computeBorrowerSalt();\\n    liquidityRequest.actions = new ShifterBorrowProxyLib.InitializationAction[](0);\\n    ShifterBorrowProxyLib.ProxyRecord memory proxyRecord = ShifterBorrowProxyLib.ProxyRecord({\\n      request: liquidityRequest,\\n      loan: ShifterBorrowProxyLib.LenderRecord(\\n        msg.sender,\\n        isolate.computeLoanParams(liquidityRequest.amount, bond, timeoutExpiry)\\n      ),\\n      expected: liquidityRequest.amount.computeExpectedAmount(address(isolate.getShifter(liquidityRequest.token)), liquidityRequest.token).sub(isolate.tokenToBaseFee[liquidityRequest.token])\\n    });\\n    proxyAddress = address(uint160(deployBorrowProxyClone(borrowerSalt)));\\n    ShifterPoolLib.mapBorrowProxy(isolate, proxyAddress, proxyRecord);\\n    isolate.issueLoan(liquidityRequest.token, proxyAddress, proxyRecord.computePostFee(), state.refundAmount);\\n    require(liquidityRequest.token.transferTokenFrom(msg.sender, address(this), bond), \\\"bond submission failed\\\");\\n  }\\n  function executeBorrow(ShifterBorrowProxyLib.LiquidityRequestParcel memory liquidityRequestParcel, uint256 bond, uint256 timeoutExpiry) public payable {\\n    ShifterPoolLib.BorrowState memory state = ShifterPoolLib.BorrowState({\\n      refundAmount: 0,\\n      gasPrice: Math.min(isolate.maxGasPriceForRefund, tx.gasprice),\\n      startGas: gasleft()\\n    });\\n    state.refundAmount = state.gasPrice*isolate.gasEstimate;\\n    require(isolate.isKeeper[msg.sender], \\\"only can be called by keeper\\\");\\n    ShifterBorrowProxyLib.InitializationAction[] memory actions = liquidityRequestParcel.request.actions;\\n    validateUnderMaxLoan(liquidityRequestParcel);\\n    address payable proxyAddress = _executeBorrow(state, liquidityRequestParcel, bond, timeoutExpiry);\\n    proxyAddress.setupBorrowProxy(liquidityRequestParcel.request.borrower, liquidityRequestParcel.request.token, false);\\n    proxyAddress.sendInitializationActions(actions);\\n    state.startGas = Math.min(state.refundAmount, (state.startGas - gasleft()  + 8600)*state.gasPrice); // estimate 10000 for additional gas, should be close\\n    tx.origin.transfer(state.startGas); // just reuse this memory loc, startGas becomes total amount refunded\\n    isolate.gasReserved[proxyAddress] = state.refundAmount - state.startGas;\\n  }\\n  function setKeeper(address user, bool isKeeper) public onlyOwner {\\n    isolate.isKeeper[user] = isKeeper;\\n  }\\n  function executeShiftSansBorrow(ShifterBorrowProxyLib.SansBorrowShiftParcel memory parcel) public payable {\\n    (address payable proxyAddress, ShifterBorrowProxyLib.InitializationAction[] memory actions) = _executeShiftSansBorrow(parcel);\\n    if (actions.length != 0) proxyAddress.sendInitializationActions(actions);\\n  }\\n  function _executeShiftSansBorrow(ShifterBorrowProxyLib.SansBorrowShiftParcel memory parcel) internal returns (address payable proxyAddress, ShifterBorrowProxyLib.InitializationAction[] memory actions) {\\n    ShifterBorrowProxyLib.TriggerParcel memory triggerParcel = ShifterBorrowProxyLib.TriggerParcel({\\n      record: ShifterBorrowProxyLib.ProxyRecord({\\n        expected: parcel.liquidityRequestParcel.request.amount,\\n        request: parcel.liquidityRequestParcel.request,\\n        loan: ShifterBorrowProxyLib.LenderRecord({\\n          keeper: msg.sender,\\n          params: isolate.computeLoanParams(parcel.liquidityRequestParcel.request.amount, parcel.liquidityRequestParcel.request.amount / 10, 1000)\\n        })\\n      }),\\n      shiftParameters: ShifterBorrowProxyLib.ShiftParameters({\\n        txhash: parcel.shiftParameters.txhash,\\n        amount: parcel.shiftParameters.amount,\\n        vout: parcel.shiftParameters.vout,\\n        pHash: parcel.shiftParameters.pHash,\\n        darknodeSignature: parcel.shiftParameters.darknodeSignature\\n      })\\n    });\\n    require(\\n      parcel.liquidityRequestParcel.validateSignature(\\n        parcel.liquidityRequestParcel.computeLiquidityRequestHash()\\n      ),\\n      \\\"liquidity request signature rejected\\\"\\n    );\\n    bytes32 borrowerSalt = parcel.liquidityRequestParcel.request.computeBorrowerSalt();\\n    proxyAddress = address(uint160(isolate.borrowProxyImplementation.deriveBorrowerAddress(borrowerSalt)));\\n    require(!proxyAddress.isContract(), \\\"proxy has already been initialized\\\");\\n    isolate.borrowProxyController.mapProxyRecord(proxyAddress, abi.encodePacked(uint256(1)));\\n    uint256 fee = triggerParcel.record.computeAdjustedKeeperFee(parcel.shiftParameters.amount);\\n    deployBorrowProxyClone(borrowerSalt);\\n    proxyAddress.setupBorrowProxy(parcel.liquidityRequestParcel.request.borrower, parcel.liquidityRequestParcel.request.token, true);\\n    if (parcel.liquidityRequestParcel.request.borrower != msg.sender && msg.value == parcel.liquidityRequestParcel.gasRequested) {\\n      parcel.liquidityRequestParcel.request.borrower.transfer(msg.value);\\n      ShifterPoolLib.sendMint(proxyAddress, address(isolate.getShifter(parcel.liquidityRequestParcel.request.token)), parcel, triggerParcel.computeNHash(), fee);\\n      require(parcel.liquidityRequestParcel.request.token.sendToken(msg.sender, fee), \\\"keeper payout failed\\\");\\n      actions = parcel.liquidityRequestParcel.request.actions;\\n    } else if (parcel.liquidityRequestParcel.request.borrower == msg.sender) {\\n      ShifterPoolLib.sendMint(proxyAddress, address(isolate.getShifter(parcel.liquidityRequestParcel.request.token)), parcel, triggerParcel.computeNHash(), 0);\\n      actions = parcel.actions;\\n    }\\n\\n    else revert(\\\"incorrect gas supplied with gas requested\\\");\\n  }\\n  function validateProxyRecordHandler(bytes memory proxyRecord) public view returns (bool) {\\n    return isolate.borrowProxyController.validateProxyRecord(msg.sender, proxyRecord);\\n  }\\n  function getProxyTokenHandler(address proxyAddress) public view returns (address) {\\n    return isolate.borrowProxyController.getProxyToken(proxyAddress);\\n  }\\n  function getProxyOwnerHandler(address user) public view returns (address) {\\n    return isolate.borrowProxyController.getProxyOwner(user);\\n  }\\n  function getShifterHandler(address token) public view returns (IShifter) {\\n    return isolate.getShifter(token);\\n  }\\n  function getLiquidityTokenHandler(address token) public view returns (LiquidityToken) {\\n    return LiquidityToken(isolate.getLiquidityToken(token));\\n  }\\n  function fetchModuleHandler(address to, bytes4 sig) public view returns (BorrowProxyLib.Module memory) {\\n    return isolate.registry.resolveModule(to, sig);\\n  }\\n  function relayResolveLoan(address token, address liquidityToken, address keeper, uint256 bond, uint256 repay, uint256 originalAmount) public returns (bool) {\\n    require(isolate.borrowProxyController.proxyInitializerRecord[msg.sender] != bytes32(0x0), \\\"not a registered borrow proxy\\\");\\n    if (repay < originalAmount) {\\n      if (repay + bond < originalAmount) {\\n        repay = repay + bond;\\n        bond = 0;\\n      } else {\\n        bond -= originalAmount - repay;\\n        repay = originalAmount;\\n      }\\n    }\\n    if (bond != 0) require(token.sendToken(keeper, bond), \\\"failed to return bond to keeper\\\");\\n    if (repay != 0) {\\n       (uint256 amount, uint256 daoAmount) = ShifterPoolLib.splitForDAO(repay, isolate.daoFee);\\n       require(token.sendToken(liquidityToken, amount), \\\"failed to repay lost funds\\\");\\n       require(token.sendToken(owner(), daoAmount), \\\"failed to repay the governing DAO\\\");\\n    }\\n    require(LiquidityToken(liquidityToken).resolveLoan(msg.sender), \\\"loan resolution failure\\\");\\n    return true;\\n  }\\n  receive() external payable { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShifterRegistry.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IShifter } from \\\"./IShifter.sol\\\";\\n\\ninterface IShifterRegistry {\\n  function getGatewayByToken(address _tokenAddress) external view returns (IShifter);\\n}\\n\"\r\n    },\r\n    \"contracts/ShifterPoolLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IShifterRegistry } from \\\"./interfaces/IShifterRegistry.sol\\\";\\nimport { LiquidityToken } from \\\"./LiquidityToken.sol\\\";\\nimport { ShifterBorrowProxy } from \\\"./ShifterBorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\nimport { ShifterBorrowProxyFactoryLib } from \\\"./ShifterBorrowProxyFactoryLib.sol\\\";\\nimport { FactoryLib } from \\\"./FactoryLib.sol\\\";\\nimport { ShifterPool } from \\\"./ShifterPool.sol\\\";\\nimport { AssetForwarderLib } from \\\"./adapters/lib/AssetForwarderLib.sol\\\";\\n\\nlibrary ShifterPoolLib {\\n  using BorrowProxyLib for *;\\n  using TokenUtils for *;\\n  using ShifterBorrowProxyLib for *;\\n  using ShifterBorrowProxyFactoryLib for *;\\n  using SafeMath for *;\\n  struct SetupParams {\\n    address shifterRegistry;\\n    uint256 minTimeout;\\n    uint256 poolFee;\\n    uint256 daoFee;\\n    uint256 maxLoan;\\n    uint256 gasEstimate;\\n    uint256 maxGasPriceForRefund;\\n  }\\n  struct BorrowState {\\n    uint256 startGas;\\n    uint256 gasPrice;\\n    uint256 refundAmount;\\n  }\\n  struct Isolate {\\n    uint256 genesis;\\n    address borrowProxyImplementation;\\n    address assetForwarderImplementation;\\n    address shifterRegistry;\\n    uint256 minTimeout;\\n    uint256 poolFee;\\n    uint256 daoFee;\\n    uint256 maxLoan;\\n    uint256 gasEstimate;\\n    uint256 maxGasPriceForRefund;\\n    mapping (address => uint256) gasReserved;\\n    mapping (address => bool) isKeeper;\\n    mapping (bytes32 => bool) provisionExecuted;\\n    mapping (address => address) tokenToLiquidityToken;\\n    mapping (address => uint256) tokenToBaseFee;\\n    BorrowProxyLib.ControllerIsolate borrowProxyController;\\n    BorrowProxyLib.ModuleRegistry registry;\\n  }\\n  function splitForDAO(uint256 actualAmount, uint256 daoFee) internal pure returns (uint256 amount, uint256 daoAmount) {\\n    daoAmount = actualAmount.mul(uint256(daoFee)).div(uint256(1 ether));\\n    if (daoAmount < actualAmount) {\\n      amount = actualAmount - daoAmount;\\n    } else daoAmount = actualAmount;\\n  }\\n  function deployAssetForwarder(BorrowProxyLib.ProxyIsolate storage isolate, bytes32 salt) internal returns (address created) {\\n    return ShifterPool(isolate.masterAddress).deployAssetForwarderClone(salt);\\n  }\\n  function sendMint(address proxyAddress, address shifter, ShifterBorrowProxyLib.SansBorrowShiftParcel memory parcel, bytes32 nHash, uint256 fee) internal  {\\n    ShifterBorrowProxy(address(uint160(proxyAddress))).relayMint(shifter, parcel.liquidityRequestParcel.request.token, parcel.shiftParameters.pHash, parcel.shiftParameters.amount, nHash, parcel.shiftParameters.darknodeSignature, fee);\\n  }\\n  function makeBorrowProxy(Isolate storage isolate, bytes32 salt) internal returns (address payable proxyAddress) {\\n    proxyAddress = address(uint160(isolate.deployBorrowProxy(salt)));\\n  }\\n  function issueLoan(Isolate storage isolate, address token, address payable proxyAddress, uint256 fee, uint256 getGas) internal {\\n    require(LiquidityToken(getLiquidityToken(isolate, token)).loan(proxyAddress, fee, getGas), \\\"insufficient funds in liquidity pool\\\");\\n  }\\n  function setupBorrowProxy(address payable proxyAddress, address borrower, address token, bool unbound) internal {\\n    require(ShifterBorrowProxy(proxyAddress).setup(borrower, token, unbound), \\\"setup phase failure\\\");\\n  }\\n  function sendInitializationActions(address payable proxyAddress, ShifterBorrowProxyLib.InitializationAction[] memory actions) internal {\\n    ShifterBorrowProxy(proxyAddress).receiveInitializationActions(actions);\\n  }\\n  function computeLoanParams(Isolate storage isolate, uint256 amount, uint256 bond, uint256 timeoutExpiry) internal view returns (ShifterBorrowProxyLib.LenderParams memory) {\\n    require(timeoutExpiry >= isolate.minTimeout, \\\"timeout insufficient\\\");\\n    uint256 baseKeeperFee = uint256(1 ether).div(100); // 1%\\n    require(bond.mul(uint256(1 ether)).div(amount) > uint256(1 ether).div(100), \\\"bond below minimum\\\");\\n    uint256 keeperFee = amount < bond ? baseKeeperFee : uint256(baseKeeperFee).mul(bond).div(amount);\\n    return ShifterBorrowProxyLib.LenderParams({\\n      keeperFee: keeperFee,\\n      poolFee: isolate.poolFee,\\n      timeoutExpiry: block.number + timeoutExpiry,\\n      bond: bond\\n    });\\n  }\\n  struct LiquidityProvisionMessage {\\n    uint256 amount;\\n    uint256 nonce;\\n    uint256 keeperFee;\\n    uint256 timeoutExpiry;\\n    bytes signature;\\n  }\\n  struct LiquidityTokenLaunch {\\n    address token;\\n    address liqToken;\\n    uint256 baseFee;\\n  }\\n  function launchLiquidityToken(Isolate storage isolate, address weth, address router, address token, string memory name, string memory symbol, uint8 decimals) internal returns (address) {\\n    require(isolate.tokenToLiquidityToken[token] == address(0x0), \\\"already deployed liquidity token for target token\\\");\\n    address liquidityToken = address(new LiquidityToken(weth, router, address(uint160(address(this))), token, name, symbol, decimals));\\n    isolate.tokenToLiquidityToken[token] = liquidityToken;\\n    return liquidityToken;\\n  }\\n  function getLiquidityToken(Isolate storage isolate, address token) internal view returns (address) {\\n    address retval = isolate.tokenToLiquidityToken[token];\\n    require(retval != address(0x0), \\\"not a registered liquidity token\\\");\\n    return retval;\\n  }\\n  function lendLiquidity(Isolate storage isolate, address provider, address token, address target, uint256 amount) internal returns (bool) {\\n    if (!isolate.isKeeper[provider]) return false;\\n    return token.transferTokenFrom(provider, target, amount);\\n  }\\n  function getShifter(Isolate storage isolate, address token) internal view returns (IShifter) {\\n    return IShifterRegistry(isolate.shifterRegistry).getGatewayByToken(token);\\n  }\\n  function provisionHashAlreadyUsed(Isolate storage isolate, bytes32 provisionHash) internal view returns (bool) {\\n    return isolate.provisionExecuted[provisionHash];\\n  }\\n  function preventProvisionReplay(Isolate storage isolate, bytes32 provisionHash) internal returns (bool) {\\n    isolate.provisionExecuted[provisionHash] = true;\\n    return true;\\n  }\\n  function mapBorrowProxy(Isolate storage isolate, address proxyAddress, ShifterBorrowProxyLib.ProxyRecord memory record) internal {\\n    bytes memory data = record.encodeProxyRecord();\\n    isolate.borrowProxyController.setProxyToken(proxyAddress, record.request.token);\\n    isolate.borrowProxyController.setProxyOwner(proxyAddress, record.request.borrower);\\n    record.request.borrower.transfer(msg.value);\\n    isolate.borrowProxyController.mapProxyRecord(proxyAddress, data);\\n    BorrowProxyLib.emitBorrowProxyMade(record.request.borrower, proxyAddress, data);\\n  }\\n}   \\n\"\r\n    },\r\n    \"contracts/LiquidityToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.0;\\n\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ERC20Burnable } from \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract LiquidityToken is ERC20, ERC20Burnable {\\n  using TokenUtils for *;\\n  address payable public pool;\\n  address public asset;\\n  address public router;\\n  address public weth;\\n  uint256 public offset;\\n  mapping (address => uint256) public outstandingLoans;\\n  constructor(address _weth, address _router, address payable shifterPool, address underlyingAsset, string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) public {\\n    weth = _weth;\\n    router = _router;\\n    pool = shifterPool;\\n    asset = underlyingAsset;\\n    require(weth.approveForMaxIfNeeded(router) && asset.approveForMaxIfNeeded(router), \\\"failed to approve router for asset\\\");\\n    _setupDecimals(decimals);\\n  }\\n  modifier onlyPool {\\n    require(msg.sender == pool, \\\"must be called by pool manager\\\");\\n    _;\\n  }\\n  function loan(address proxy, uint256 amount, uint256 getGas) public onlyPool returns (bool) {\\n    offset += amount;\\n    outstandingLoans[proxy] = amount;\\n    address[] memory path = new address[](2);\\n    path[0] = asset;\\n    path[1] = weth;\\n    uint256[] memory amounts = IUniswapV2Router01(router).swapTokensForExactETH(getGas, amount, path, pool, block.timestamp + 1);\\n    require(asset.sendToken(proxy, amount - amounts[0]), \\\"loan transfer failed\\\");\\n    return true;\\n  }\\n  function resolveLoan(address proxy) public onlyPool returns (bool) {\\n    offset -= outstandingLoans[proxy];\\n    outstandingLoans[proxy] = 0;\\n    return true;\\n  }\\n  function getReserve() internal view returns (uint256) {\\n    return offset + IERC20(asset).balanceOf(address(this));\\n  }\\n  function addLiquidity(uint256 value) public returns (uint256) {\\n    uint256 totalLiquidity = totalSupply();\\n    uint256 reserve = getReserve();\\n    uint256 totalMinted = value * (totalLiquidity == 0 ? 1 : totalLiquidity) / (reserve + 1);\\n    require(asset.transferTokenFrom(msg.sender, address(this), value), \\\"transfer token failed\\\");\\n    _mint(msg.sender, totalMinted);\\n    return totalMinted;\\n  }\\n  function removeLiquidity(uint256 value) public returns (uint256) {\\n    uint256 totalLiquidity = totalSupply();\\n    uint256 reserve = getReserve();\\n    uint256 totalReturned = value * (reserve + 1) / (totalLiquidity == 0 ? 1 : totalLiquidity);\\n    _burn(msg.sender, value);\\n    require(asset.sendToken(msg.sender, totalReturned), \\\"failed to send back token\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/ShifterBorrowProxy.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { LiquidityToken } from \\\"./LiquidityToken.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeViewExecutor } from \\\"./utils/sandbox/SafeViewExecutor.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { StringLib } from \\\"./utils/StringLib.sol\\\";\\nimport { NullCloneConstructor } from \\\"./NullCloneConstructor.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\nimport { ShifterPool } from \\\"./ShifterPool.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\ncontract ShifterBorrowProxy is BorrowProxy, SafeViewExecutor, NullCloneConstructor {\\n  using ShifterBorrowProxyLib for *;\\n  using StringLib for *;\\n  using SandboxLib for *;\\n  using TokenUtils for *;\\n  uint256 constant MINIMUM_GAS_CONTINUE = 5e5;\\n  function getShifter(address token) internal view returns (IShifter shifter) {\\n    shifter = ShifterPool(isolate.masterAddress).getShifterHandler(token);\\n  }\\n  function mint(ShifterBorrowProxyLib.TriggerParcel memory parcel) internal returns (uint256 amount) {\\n    amount = getShifter(parcel.record.request.token).mint(parcel.shiftParameters.pHash, parcel.shiftParameters.amount, parcel.computeNHash(), parcel.shiftParameters.darknodeSignature);\\n  }\\n  function _getGasReserved() internal view returns (uint256 result) {\\n    result = ShifterPool(isolate.masterAddress).getGasReserved(address(this));\\n  }\\n  function _payoutCallbackGas(address payable borrower, uint256 amount, uint256 originAmount) internal {\\n    if (amount != 0) ShifterPool(isolate.masterAddress).payoutCallbackGas(borrower, amount - originAmount, originAmount);\\n  }\\n  function repayLoan(bytes memory data) public returns (bool) {\\n    uint256 startGas = gasleft();\\n    (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 repayAmount) = _repayLoan(data);\\n    if (maybeRelayResolveLoan(success, record, pool, repayAmount)) {\\n      ShifterBorrowProxyLib.emitShifterBorrowProxyRepaid(record.request.borrower, record);\\n      uint256 amount = _getGasReserved();\\n      uint256 originAmount = Math.min((gasleft() - startGas + 20000)*tx.gasprice, amount); // another estimate\\n      _payoutCallbackGas(record.request.borrower, amount, originAmount);\\n      return true;\\n    } else return false;\\n  }\\n  function _repayLoan(bytes memory data) internal returns (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 repayAmount) {\\n    (ShifterBorrowProxyLib.TriggerParcel memory parcel) = data.decodeTriggerParcel();\\n    record = parcel.record;\\n    parcel.record.request.actions = new ShifterBorrowProxyLib.InitializationAction[](0);\\n    require(validateProxyRecord(parcel.record.encodeProxyRecord()), \\\"proxy record invalid\\\");\\n    require(!isolate.isLiquidating, \\\"proxy is being liquidated\\\");\\n    uint256 fee = parcel.record.computeAdjustedKeeperFee(parcel.record.expected);\\n    pool = isolate.masterAddress;\\n    uint256 amount;\\n    if (!isolate.isRepaying) {\\n      isolate.isRepaying = true;\\n      isolate.actualizedShift = amount = mint(parcel);\\n    } else amount = isolate.actualizedShift;\\n    address[] memory set = isolate.repaymentSet.set;\\n    for (uint256 i = isolate.repaymentIndex; i < set.length; i++) {\\n      if (gasleft() < MINIMUM_GAS_CONTINUE || !set[i].delegateRepay()) {\\n        isolate.repaymentIndex = i;\\n        return (false, record, pool, 0);\\n      }\\n    }\\n    isolate.unbound = true;\\n    require(parcel.record.request.token.sendToken(parcel.record.loan.keeper, fee), \\\"keeper payout failed\\\");\\n    record.request.amount = amount;\\n    repayAmount = amount - fee;\\n    success = true;\\n  }\\n  function relayMint(address shifter, address token, bytes32 pHash, uint256 amount, bytes32 nHash, bytes memory darknodeSignature, uint256 fee) public returns (bool) {\\n    require(isolate.masterAddress == msg.sender, \\\"must be called by shifter pool\\\");\\n    IShifter(shifter).mint(pHash, amount, nHash, darknodeSignature);\\n    if (fee != 0) require(token.sendToken(msg.sender, fee), \\\"failed to send token\\\");\\n    isolate.unbound = true;\\n  }\\n  function getBalanceOf(address token, address user) internal view returns (uint256) {\\n    return IERC20(token).balanceOf(user);\\n  }\\n  function getLiquidityToken(address payable pool, address token) internal view returns (address liqToken) {\\n    liqToken = address(ShifterPool(pool).getLiquidityTokenHandler(token));\\n  }\\n  function maybeRelayResolveLoan(bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 repayPool) internal returns (bool) {\\n    if (success) {\\n      address liqToken = getLiquidityToken(pool, record.request.token);\\n      require(record.request.token.sendToken(pool, repayPool), \\\"failed to approve pool for token transfer\\\");\\n      require(ShifterPool(pool).relayResolveLoan(record.request.token, liqToken, record.loan.keeper, record.loan.params.bond, repayPool, record.expected), \\\"loan resolution failure\\\");\\n      return true;\\n    }\\n    return false;\\n  }\\n  function defaultLoan(bytes memory data) public {\\n    (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 postBalance) = _defaultLoan(data);\\n    maybeRelayResolveLoan(success, record, pool, postBalance);\\n    _payoutCallbackGas(record.request.borrower, 0, _getGasReserved());\\n    selfdestruct(msg.sender);\\n  }\\n  function _defaultLoan(bytes memory data) internal returns (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 postBalance) {\\n    require(!isolate.isRepaying, \\\"loan being repaid\\\");\\n    require(!isolate.unbound, \\\"loan already repaid\\\");\\n    require(validateProxyRecord(data), \\\"proxy record invalid\\\");\\n    record = data.decodeProxyRecord();\\n    address[] memory set = isolate.liquidationSet.set;\\n    if (record.loan.params.timeoutExpiry >= block.number) {\\n      isolate.isLiquidating = true;\\n      for (uint256 i = isolate.liquidationIndex; i < set.length; i++) {\\n        if (gasleft() < MINIMUM_GAS_CONTINUE || !set[i].delegateLiquidate()) {\\n          isolate.liquidationIndex = i;\\n          return (false, record, pool, postBalance);\\n        }\\n      }\\n      isolate.liquidationIndex = set.length;\\n      pool = isolate.masterAddress;\\n      postBalance = getBalanceOf(record.request.token, address(this));\\n      success = true;\\n    } else {\\n      success = false;\\n    }\\n  }\\n  function receiveInitializationActions(ShifterBorrowProxyLib.InitializationAction[] memory actions) public {\\n    require(msg.sender == address(isolate.masterAddress), \\\"must be called from shifter pool\\\");\\n    actions.processActions();\\n  }\\n  fallback() external payable override {}\\n  receive() external payable override {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sandbox/SafeViewExecutor.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SafeViewLib } from \\\"./SafeViewLib.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\ncontract SafeViewExecutor {\\n  using SafeViewLib for *;\\n  bytes32 constant STEALTH_VIEW_DEPLOY_SALT = 0xad53495153c7c363e98a26920ec679e0e687636458f6908c91cf6deadb190801;\\n  function _executeSafeView(bytes memory creationCode, bytes memory context) public {\\n    address viewLayer = Create2.deploy(0, SafeViewLib.GET_STEALTH_VIEW_DEPLOY_SALT(), creationCode);\\n    bytes memory result = viewLayer.executeLogic(context).encodeResult();\\n    result.revertWithData();\\n  }\\n  function query(bytes memory creationCode, bytes memory context) public returns (SafeViewLib.SafeViewResult memory) {\\n    return creationCode.safeView(context);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/NullCloneConstructor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ncontract NullCloneConstructor {\\n  function cloneConstructor(bytes memory consData) public {\\n    // do nothing\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShifterBorrowProxyFactoryLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { ShifterBorrowProxy } from \\\"./ShifterBorrowProxy.sol\\\";\\nimport { ShifterPoolLib } from \\\"./ShifterPoolLib.sol\\\";\\nimport { FactoryLib } from \\\"./FactoryLib.sol\\\";\\n\\nlibrary ShifterBorrowProxyFactoryLib {\\n  function deployBorrowProxy(ShifterPoolLib.Isolate storage /* isolate */, bytes32 salt) external returns (address output) {\\n    output = Create2.deploy(0, salt, type(ShifterBorrowProxy).creationCode);\\n  }\\n  function deriveBorrowerAddress(address target, bytes32 salt) internal view returns (address) {\\n    return FactoryLib.deriveInstanceAddress(target, salt);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ViewExecutor.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ncontract ViewExecutor {\\n  function encodeExecuteQuery(address viewLogic, bytes memory payload) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"_executeQuery(address,bytes)\\\", viewLogic, payload);\\n  }\\n  function query(address viewLogic, bytes memory payload) public view returns (bytes memory) {\\n    (bool success, bytes memory response) = viewLogic.staticcall(encodeExecuteQuery(viewLogic, payload));\\n    require(success, string(response));\\n    return response;\\n  }\\n  function _executeQuery(address delegateTo, bytes memory callData) public returns (bytes memory) {\\n    require(msg.sender == address(this), \\\"unauthorized view layer delegation\\\");\\n    (bool success, bytes memory retval) = delegateTo.delegatecall(callData);\\n    require(success);\\n    return retval;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { UniswapV2AdapterLib } from \\\"./UniswapV2AdapterLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { ERC20AdapterLib } from \\\"../erc20/ERC20AdapterLib.sol\\\";\\nimport { ShifterPool } from \\\"../../../ShifterPool.sol\\\";\\n\\ncontract UniswapV2Adapter {\\n  using TokenUtils for *;\\n  using ModuleLib for *;\\n  using BorrowProxyLib for *;\\n  using UniswapV2AdapterLib for *;\\n  using ERC20AdapterLib for *;\\n  BorrowProxyLib.ProxyIsolate proxyIsolate;\\n  constructor(address erc20Module) public {\\n    UniswapV2AdapterLib.Isolate storage isolate = UniswapV2AdapterLib.getIsolatePointer(address(this));\\n    isolate.erc20Module = erc20Module;\\n  }\\n  function validateIsERC20Module(ModuleLib.AssetSubmodulePayload memory payload, address token) internal view returns (bool) {\\n    UniswapV2AdapterLib.Isolate memory externalIsolate = UniswapV2AdapterLib.getExternalIsolate(payload.moduleAddress);\\n    require(ShifterPool(proxyIsolate.masterAddress).fetchModuleHandler(token, IERC20.transfer.selector).assetSubmodule == externalIsolate.erc20Module, \\\"asset is not associated with the ERC20 module\\\");\\n  }\\n  function getExternalIsolateHandler() external view returns (UniswapV2AdapterLib.Isolate memory) {\\n    return UniswapV2AdapterLib.getIsolatePointer(address(this));\\n  }\\n  function getWETH(ModuleLib.AssetSubmodulePayload memory payload) internal pure returns (address) {\\n    return IUniswapV2Router01(payload.to).WETH();\\n  }\\n  function handle(ModuleLib.AssetSubmodulePayload memory payload) public payable {\\n    (bytes4 sig, bytes memory args) = payload.callData.splitPayload();\\n    bool shouldTriggerERC20Handlers = false;\\n    address escrowWallet = proxyIsolate.deriveNextForwarderAddress();\\n    address newToken = address(0x0);\\n    address startToken = address(0x0);\\n    if (sig == IUniswapV2Router01.swapExactTokensForTokens.selector) {\\n      UniswapV2AdapterLib.SwapExactTokensForTokensInputs memory inputs = args.decodeSwapExactTokensForTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapTokensForExactTokens.selector) {\\n      UniswapV2AdapterLib.SwapTokensForExactTokensInputs memory inputs = args.decodeSwapTokensForExactTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapExactETHForTokens.selector) {\\n      UniswapV2AdapterLib.SwapExactETHForTokensInputs memory inputs = args.decodeSwapExactETHForTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapTokensForExactETH.selector) {\\n      UniswapV2AdapterLib.SwapExactETHForTokensInputs memory inputs = args.decodeSwapExactETHForTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapExactTokensForETH.selector) {\\n      UniswapV2AdapterLib.SwapExactTokensForETHInputs memory inputs = args.decodeSwapExactTokensForETHInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapETHForExactTokens.selector) {\\n      UniswapV2AdapterLib.SwapETHForExactTokensInputs memory inputs = args.decodeSwapETHForExactTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else revert(\\\"unsupported contract call\\\");\\n    if (newToken != address(0x0)) {\\n      require(payload.liquidationSubmodule.delegateNotify(newToken.encodeLiquidationNotify()), \\\"liquidation module notification failure\\\");\\n    }\\n    require(startToken.approveForMaxIfNeeded(payload.to), \\\"failed to approve start token\\\");\\n    if (shouldTriggerERC20Handlers) proxyIsolate.triggerERC20Handlers(payload.moduleAddress);\\n    (bool success, bytes memory retval) = payload.to.call{ gas: gasleft(), value: payload.value }(payload.callData);\\n    ModuleLib.bubbleResult(success, retval);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/assets/uniswap-v2/UniswapV2AdapterLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { UniswapV2Adapter } from \\\"./UniswapV2Adapter.sol\\\";\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../../ShifterBorrowProxyLib.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { AddressSetLib } from \\\"../../../utils/AddressSetLib.sol\\\";\\n\\nlibrary UniswapV2AdapterLib {\\n  using BorrowProxyLib for *;\\n  using AddressSetLib for *;\\n  using ShifterBorrowProxyLib for *;\\n  bytes32 constant ETHER_FORWARDER_SALT = 0x3e8d8e49b9a35f50b96f6ba4b93e0fc6c1d66a2e1c04975ef848d7031c8158a4; // keccak(\\\"uniswap-adapter.ether-forwarder\\\")\\n  struct Isolate {\\n    uint256 liquidityMinimum;\\n    address erc20Module;\\n  }\\n  struct SwapExactTokensForTokensInputs {\\n    uint256 amountIn;\\n    uint256 amountOutMin;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapExactTokensForTokensInputs(bytes memory args) internal pure returns (SwapExactTokensForTokensInputs memory) {\\n    (uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapExactTokensForTokensInputs({\\n      amountIn: amountIn,\\n      amountOutMin: amountOutMin,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapExactTokensForTokensInputs memory inputs, address newRecipient) internal pure returns (SwapExactTokensForTokensInputs memory) {\\n    return SwapExactTokensForTokensInputs({\\n      amountIn: inputs.amountIn,\\n      amountOutMin: inputs.amountOutMin,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapExactTokensForTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapExactTokensForTokens.selector, inputs.amountIn, inputs.amountOutMin, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapTokensForExactTokensInputs {\\n    uint256 amountOut;\\n    uint256 amountInMax;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapTokensForExactTokensInputs(bytes memory args) internal pure returns (SwapTokensForExactTokensInputs memory) {\\n    (uint256 amountOut, uint256 amountInMax, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapTokensForExactTokensInputs({\\n      amountOut: amountOut,\\n      amountInMax: amountInMax,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapTokensForExactTokensInputs memory inputs, address newRecipient) internal pure returns (SwapTokensForExactTokensInputs memory) {\\n    return SwapTokensForExactTokensInputs({\\n      amountOut: inputs.amountOut,\\n      amountInMax: inputs.amountInMax,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapTokensForExactTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapTokensForExactTokens.selector, inputs.amountOut, inputs.amountInMax, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapExactETHForTokensInputs {\\n    uint256 amountOutMin;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapExactETHForTokensInputs(bytes memory args) internal pure returns (SwapExactETHForTokensInputs memory) {\\n    (uint256 amountOutMin, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, address[], address, uint256));\\n    return SwapExactETHForTokensInputs({\\n      amountOutMin: amountOutMin,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapExactETHForTokensInputs memory inputs, address newRecipient) internal pure returns (SwapExactETHForTokensInputs memory) {\\n    return SwapExactETHForTokensInputs({\\n      amountOutMin: inputs.amountOutMin,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapExactETHForTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapExactETHForTokens.selector, inputs.amountOutMin, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapTokensForExactETHInputs {\\n    uint256 amountOut;\\n    uint256 amountInMax;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapTokensForExactETHInputs(bytes memory args) internal pure returns (SwapTokensForExactETHInputs memory) {\\n    (uint256 amountOut, uint256 amountInMax, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapTokensForExactETHInputs({\\n      amountOut: amountOut,\\n      amountInMax: amountInMax,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapTokensForExactETHInputs memory inputs, address newRecipient) internal pure returns (SwapTokensForExactETHInputs memory) {\\n    return SwapTokensForExactETHInputs({\\n      amountOut: inputs.amountOut,\\n      amountInMax: inputs.amountInMax,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapTokensForExactETHInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapTokensForExactETH.selector, inputs.amountOut, inputs.amountInMax, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapExactTokensForETHInputs {\\n    uint256 amountIn;\\n    uint256 amountOutMin;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapExactTokensForETHInputs(bytes memory args) internal pure returns (SwapExactTokensForETHInputs memory) {\\n    (uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapExactTokensForETHInputs({\\n      amountIn: amountIn,\\n      amountOutMin: amountOutMin,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapExactTokensForETHInputs memory inputs, address newRecipient) internal pure returns (SwapExactTokensForETHInputs memory) {\\n    return SwapExactTokensForETHInputs({\\n      amountIn: inputs.amountIn,\\n      amountOutMin: inputs.amountOutMin,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapExactTokensForETHInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapExactTokensForETH.selector, inputs.amountIn, inputs.amountOutMin, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapETHForExactTokensInputs {\\n    uint256 amountOut;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapETHForExactTokensInputs(bytes memory args) internal pure returns (SwapETHForExactTokensInputs memory) {\\n    (uint256 amountOut, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, address[], address, uint256));\\n    return SwapETHForExactTokensInputs({\\n      amountOut: amountOut,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapETHForExactTokensInputs memory inputs, address newRecipient) internal pure returns (SwapETHForExactTokensInputs memory) {\\n    return SwapETHForExactTokensInputs({\\n      amountOut: inputs.amountOut,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapETHForExactTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapETHForExactTokens.selector, inputs.amountOut, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  function computeIsolatePointer(address instance) public pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(\\\"isolate.uniswap-v2-adapter\\\", instance)));\\n  }\\n  function validatePath(address[] memory path, address WETH) internal pure returns (address begin, address destination) {\\n    if (path.length < 2) revert(\\\"path too short, must be 3 elements\\\");\\n    if (path.length > 3 || !(path[0] == WETH || path[1] == WETH)) revert(\\\"path must be 2 or 3 items and include WETH\\\");\\n    return (path[0], path[path.length - 1]);\\n  }\\n  function generatePathForToken(address startToken, address WETH, address token) internal pure returns (address[] memory path) {\\n    path = new address[](3);\\n    path[0] = startToken;\\n    path[1] = WETH;\\n    path[2] = token;\\n  }\\n  function getCastStorageType() internal pure returns (function (uint256) internal pure returns (Isolate storage) swap) {\\n    function (uint256) internal returns (uint256) cast = ModuleLib.cast;\\n    assembly {\\n      swap := cast\\n    }\\n  }\\n  function toIsolatePointer(uint256 key) internal pure returns (Isolate storage) {\\n    return getCastStorageType()(key);\\n  }\\n  function getIsolatePointer(address instance) internal pure returns (Isolate storage) {\\n    return toIsolatePointer(computeIsolatePointer(instance));\\n  }\\n  function getExternalIsolate(address payable moduleAddress) internal view returns (Isolate memory) {\\n    return UniswapV2Adapter(moduleAddress).getExternalIsolateHandler();\\n  }\\n  function encodeLiquidationNotify(address newToken) internal pure returns (bytes memory result) {\\n    result = abi.encode(newToken);\\n  }\\n  function triggerERC20Handlers(BorrowProxyLib.ProxyIsolate storage proxyIsolate, address moduleAddress) internal {\\n    Isolate memory isolate = UniswapV2Adapter(moduleAddress).getExternalIsolateHandler();\\n    proxyIsolate.repaymentSet.insert(isolate.erc20Module);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/liquidity/SimpleBurnLiquidationModule.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { AddressSetLib } from \\\"../../utils/AddressSetLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../BorrowProxyLib.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenUtils } from \\\"../../utils/TokenUtils.sol\\\";\\nimport { SimpleBurnLiquidationModuleLib } from \\\"./SimpleBurnLiquidationModuleLib.sol\\\";\\nimport { ERC20AdapterLib } from \\\"../assets/erc20/ERC20AdapterLib.sol\\\";\\nimport { UniswapV2AdapterLib } from \\\"../assets/uniswap-v2/UniswapV2AdapterLib.sol\\\";\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { ShifterPool } from \\\"../../ShifterPool.sol\\\";\\nimport { StringLib } from \\\"../../utils/StringLib.sol\\\";\\n\\ncontract SimpleBurnLiquidationModule {\\n  using StringLib for *;\\n  using AddressSetLib for *;\\n  using TokenUtils for *;\\n  using UniswapV2AdapterLib for *;\\n  BorrowProxyLib.ProxyIsolate proxyIsolate;\\n  constructor(address routerAddress, address erc20Module) public {\\n    SimpleBurnLiquidationModuleLib.Isolate storage isolate = SimpleBurnLiquidationModuleLib.getIsolatePointer();\\n    isolate.routerAddress = routerAddress;\\n    isolate.erc20Module = erc20Module;\\n  }\\n  function notify(address /* moduleAddress */, bytes memory payload) public returns (bool) {\\n    (address token) = abi.decode(payload, (address));\\n    SimpleBurnLiquidationModuleLib.Isolate storage isolate = SimpleBurnLiquidationModuleLib.getIsolatePointer();\\n    isolate.toLiquidate.insert(token);\\n    return true;\\n  }\\n  function fetchExternals(address moduleAddress) internal view returns (address routerAddress, address erc20Module) {\\n    (routerAddress, erc20Module) = SimpleBurnLiquidationModule(moduleAddress).getExternalIsolateHandler();\\n  }\\n  function fetchLiquidityToken(address liquidateTo) internal view returns (address) {\\n    return ShifterPool(proxyIsolate.masterAddress).getLiquidityTokenForTokenHandler(liquidateTo);\\n  }\\n  function getWETH(IUniswapV2Router01 router) internal pure returns (address) {\\n    return router.WETH();\\n  }\\n  function liquidate(address moduleAddress) public returns (bool) {\\n    if (!ERC20AdapterLib.liquidate(proxyIsolate)) return false;\\n    SimpleBurnLiquidationModuleLib.Isolate storage isolate = SimpleBurnLiquidationModuleLib.getIsolatePointer();\\n    address liquidateTo = address(uint160(proxyIsolate.token));\\n    (address routerAddress, /* address erc20Module */) = fetchExternals(moduleAddress);\\n    IUniswapV2Router01 router = IUniswapV2Router01(routerAddress);\\n    address WETH = getWETH(router);\\n    uint256 i;\\n    for (i = isolate.liquidated; i < isolate.toLiquidate.set.length; i++) {\\n      address tokenAddress = isolate.toLiquidate.set[i];\\n      if (liquidateTo == tokenAddress) continue;\\n      if (gasleft() < 3e5) {\\n        isolate.liquidated = i;\\n        return false;\\n      }\\n      uint256 tokenBalance = IERC20(tokenAddress).balanceOf(address(this));\\n      address[] memory path = UniswapV2AdapterLib.generatePathForToken(tokenAddress, WETH, liquidateTo);\\n      tokenAddress.approveForMaxIfNeeded(address(router));\\n      router.swapExactTokensForTokens(tokenBalance, 1, path, address(this), block.timestamp + 1);\\n    }\\n    isolate.liquidated = i;\\n    return true;\\n  }\\n  function getExternalIsolateHandler() external view returns (address, address) {\\n    SimpleBurnLiquidationModuleLib.Isolate storage isolate = SimpleBurnLiquidationModuleLib.getIsolatePointer();\\n    return (isolate.routerAddress, isolate.erc20Module);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/liquidity/SimpleBurnLiquidationModuleLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { AddressSetLib } from \\\"../../utils/AddressSetLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../BorrowProxyLib.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenUtils } from \\\"../../utils/TokenUtils.sol\\\";\\nimport { ModuleLib } from \\\"../lib/ModuleLib.sol\\\";\\nimport { SimpleBurnLiquidationModule } from \\\"./SimpleBurnLiquidationModule.sol\\\";\\n\\nlibrary SimpleBurnLiquidationModuleLib {\\n  struct Isolate {\\n    address routerAddress;\\n    address erc20Module;\\n    uint256 liquidated;\\n    AddressSetLib.AddressSet toLiquidate;\\n  }\\n  struct ExternalIsolate {\\n    address routerAddress;\\n    address erc20Module;\\n  }\\n  function computeIsolatePointer() public pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(\\\"isolate.simple-burn\\\")));\\n  }\\n  function getCastStorageType() internal pure returns (function (uint256) internal pure returns (Isolate storage) swap) {\\n    function (uint256) internal returns (uint256) cast = ModuleLib.cast;\\n    assembly {\\n      swap := cast\\n    }\\n  }\\n  function toIsolatePointer(uint256 key) internal pure returns (Isolate storage) {\\n    return getCastStorageType()(key);\\n  }\\n  function getIsolatePointer() internal pure returns (Isolate storage) {\\n    return toIsolatePointer(computeIsolatePointer());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Exports.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\n\\ncontract Exports {\\n  event InitializationActionsExport(ShifterBorrowProxyLib.InitializationAction[] actions);\\n  event ProxyRecordExport(ShifterBorrowProxyLib.ProxyRecord record);\\n  event TriggerParcelExport(ShifterBorrowProxyLib.TriggerParcel record);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidationModule.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface ILiquidationModule {\\n  function notify(address moduleAddress, bytes calldata payload) external returns (bool);\\n  function liquidate(address moduleAddress) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IUniswapExchange {\\n  event TokenPurchase(address indexed buyer, uint256 indexed eth_sold, uint256 indexed tokens_bought);\\n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought);\\n  event AddLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\\n  event RemoveLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\\n\\n   /**\\n   * @notice Convert ETH to Tokens.\\n   * @dev User specifies exact input (msg.value).\\n   * @dev User cannot specify minimum output or deadline.\\n   */\\n  receive() payable external;\\n  \\n\\n /**\\n   * @dev Pricing function for converting between ETH && Tokens.\\n   * @param input_amount Amount of ETH or Tokens being sold.\\n   * @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\\n   * @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\\n   * @return Amount of ETH or Tokens bought.\\n   */\\n  function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) external view returns (uint256);\\n\\n /**\\n   * @dev Pricing function for converting between ETH && Tokens.\\n   * @param output_amount Amount of ETH or Tokens being bought.\\n   * @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\\n   * @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\\n   * @return Amount of ETH or Tokens sold.\\n   */\\n  function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) external view returns (uint256);\\n\\n\\n  /** \\n   * @notice Convert ETH to Tokens.\\n   * @dev User specifies exact input (msg.value) && minimum output.\\n   * @param min_tokens Minimum Tokens bought.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @return Amount of Tokens bought.\\n   */ \\n  function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256);\\n\\n  /** \\n   * @notice Convert ETH to Tokens && transfers Tokens to recipient.\\n   * @dev User specifies exact input (msg.value) && minimum output\\n   * @param min_tokens Minimum Tokens bought.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output Tokens.\\n   * @return  Amount of Tokens bought.\\n   */\\n  function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns(uint256);\\n\\n\\n  /** \\n   * @notice Convert ETH to Tokens.\\n   * @dev User specifies maximum input (msg.value) && exact output.\\n   * @param tokens_bought Amount of tokens bought.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @return Amount of ETH sold.\\n   */\\n  function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns(uint256);\\n  /** \\n   * @notice Convert ETH to Tokens && transfers Tokens to recipient.\\n   * @dev User specifies maximum input (msg.value) && exact output.\\n   * @param tokens_bought Amount of tokens bought.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output Tokens.\\n   * @return Amount of ETH sold.\\n   */\\n  function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256);\\n\\n  /** \\n   * @notice Convert Tokens to ETH.\\n   * @dev User specifies exact input && minimum output.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @param min_eth Minimum ETH purchased.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @return Amount of ETH bought.\\n   */\\n  function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256);\\n\\n  /** \\n   * @notice Convert Tokens to ETH && transfers ETH to recipient.\\n   * @dev User specifies exact input && minimum output.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @param min_eth Minimum ETH purchased.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output ETH.\\n   * @return  Amount of ETH bought.\\n   */\\n  function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256);\\n\\n  /** \\n   * @notice Convert Tokens to ETH.\\n   * @dev User specifies maximum input && exact output.\\n   * @param eth_bought Amount of ETH purchased.\\n   * @param max_tokens Maximum Tokens sold.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @return Amount of Tokens sold.\\n   */\\n  function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens to ETH && transfers ETH to recipient.\\n   * @dev User specifies maximum input && exact output.\\n   * @param eth_bought Amount of ETH purchased.\\n   * @param max_tokens Maximum Tokens sold.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output ETH.\\n   * @return Amount of Tokens sold.\\n   */\\n  function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (token_addr).\\n   * @dev User specifies exact input && minimum output.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param token_addr The address of the token being purchased.\\n   * @return Amount of Tokens (token_addr) bought.\\n   */\\n  function tokenToTokenSwapInput(\\n    uint256 tokens_sold, \\n    uint256 min_tokens_bought, \\n    uint256 min_eth_bought, \\n    uint256 deadline, \\n    address token_addr) \\n    external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (token_addr) && transfers\\n   *         Tokens (token_addr) to recipient.\\n   * @dev User specifies exact input && minimum output.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output ETH.\\n   * @param token_addr The address of the token being purchased.\\n   * @return Amount of Tokens (token_addr) bought.\\n   */\\n  function tokenToTokenTransferInput(\\n    uint256 tokens_sold, \\n    uint256 min_tokens_bought, \\n    uint256 min_eth_bought, \\n    uint256 deadline, \\n    address recipient, \\n    address token_addr) \\n    external returns (uint256);\\n\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (token_addr).\\n   * @dev User specifies maximum input && exact output.\\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\\n   * @param max_tokens_sold Maximum Tokens (token) sold.\\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param token_addr The address of the token being purchased.\\n   * @return Amount of Tokens (token) sold.\\n   */\\n  function tokenToTokenSwapOutput(\\n    uint256 tokens_bought, \\n    uint256 max_tokens_sold, \\n    uint256 max_eth_sold, \\n    uint256 deadline, \\n    address token_addr) \\n    external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (token_addr) && transfers\\n   *         Tokens (token_addr) to recipient.\\n   * @dev User specifies maximum input && exact output.\\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\\n   * @param max_tokens_sold Maximum Tokens (token) sold.\\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output ETH.\\n   * @param token_addr The address of the token being purchased.\\n   * @return Amount of Tokens (token) sold.\\n   */\\n  function tokenToTokenTransferOutput(\\n    uint256 tokens_bought, \\n    uint256 max_tokens_sold, \\n    uint256 max_eth_sold, \\n    uint256 deadline, \\n    address recipient, \\n    address token_addr) \\n    external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token).\\n   * @dev Allows trades through contracts that were not deployed from the same factory.\\n   * @dev User specifies exact input && minimum output.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param exchange_addr The address of the exchange for the token being purchased.\\n   * @return Amount of Tokens (exchange_addr.token) bought.\\n   */\\n  function tokenToExchangeSwapInput(\\n    uint256 tokens_sold, \\n    uint256 min_tokens_bought, \\n    uint256 min_eth_bought, \\n    uint256 deadline, \\n    address exchange_addr) \\n    external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token) && transfers\\n   *         Tokens (exchange_addr.token) to recipient.\\n   * @dev Allows trades through contracts that were not deployed from the same factory.\\n   * @dev User specifies exact input && minimum output.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output ETH.\\n   * @param exchange_addr The address of the exchange for the token being purchased.\\n   * @return Amount of Tokens (exchange_addr.token) bought.\\n   */\\n  function tokenToExchangeTransferInput(\\n    uint256 tokens_sold, \\n    uint256 min_tokens_bought, \\n    uint256 min_eth_bought, \\n    uint256 deadline, \\n    address recipient, \\n    address exchange_addr) \\n    external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token).\\n   * @dev Allows trades through contracts that were not deployed from the same factory.\\n   * @dev User specifies maximum input && exact output.\\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\\n   * @param max_tokens_sold Maximum Tokens (token) sold.\\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param exchange_addr The address of the exchange for the token being purchased.\\n   * @return Amount of Tokens (token) sold.\\n   */\\n  function tokenToExchangeSwapOutput(\\n    uint256 tokens_bought, \\n    uint256 max_tokens_sold, \\n    uint256 max_eth_sold, \\n    uint256 deadline, \\n    address exchange_addr) \\n    external returns (uint256);\\n\\n  /**\\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token) && transfers\\n   *         Tokens (exchange_addr.token) to recipient.\\n   * @dev Allows trades through contracts that were not deployed from the same factory.\\n   * @dev User specifies maximum input && exact output.\\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\\n   * @param max_tokens_sold Maximum Tokens (token) sold.\\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @param recipient The address that receives output ETH.\\n   * @param exchange_addr The address of the exchange for the token being purchased.\\n   * @return Amount of Tokens (token) sold.\\n   */\\n  function tokenToExchangeTransferOutput(\\n    uint256 tokens_bought, \\n    uint256 max_tokens_sold, \\n    uint256 max_eth_sold, \\n    uint256 deadline, \\n    address recipient, \\n    address exchange_addr) \\n    external returns (uint256);\\n\\n\\n  /***********************************|\\n  |         Getter Functions          |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice external price function for ETH to Token trades with an exact input.\\n   * @param eth_sold Amount of ETH sold.\\n   * @return Amount of Tokens that can be bought with input ETH.\\n   */\\n  function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256);\\n\\n  /**\\n   * @notice external price function for ETH to Token trades with an exact output.\\n   * @param tokens_bought Amount of Tokens bought.\\n   * @return Amount of ETH needed to buy output Tokens.\\n   */\\n  function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256);\\n\\n  /**\\n   * @notice external price function for Token to ETH trades with an exact input.\\n   * @param tokens_sold Amount of Tokens sold.\\n   * @return Amount of ETH that can be bought with input Tokens.\\n   */\\n  function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256);\\n\\n  /**\\n   * @notice external price function for Token to ETH trades with an exact output.\\n   * @param eth_bought Amount of output ETH.\\n   * @return Amount of Tokens needed to buy output ETH.\\n   */\\n  function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256);\\n\\n  /** \\n   * @return Address of Token that is sold on this exchange.\\n   */\\n  function tokenAddress() external view returns (address);\\n\\n  /**\\n   * @return Address of factory that created this exchange.\\n   */\\n  function factoryAddress() external view returns (address);\\n\\n\\n  /***********************************|\\n  |        Liquidity Functions        |\\n  |__________________________________*/\\n\\n  /** \\n   * @notice Deposit ETH && Tokens (token) at current ratio to mint UNI tokens.\\n   * @dev min_liquidity does nothing when total UNI supply is 0.\\n   * @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\\n   * @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @return The amount of UNI minted.\\n   */\\n  function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\\n\\n  /**\\n   * @dev Burn UNI tokens to withdraw ETH && Tokens at current ratio.\\n   * @param amount Amount of UNI burned.\\n   * @param min_eth Minimum ETH withdrawn.\\n   * @param min_tokens Minimum Tokens withdrawn.\\n   * @param deadline Time after which this transaction can no longer be executed.\\n   * @return The amount of ETH && Tokens withdrawn.\\n   */\\n  function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IUniswapFactory {\\n  event NewExchange(address indexed token, address indexed exchange);\\n\\n  function initializeFactory(address template) external;\\n  function createExchange(address token) external returns (address payable);\\n  function getExchange(address token) external view returns (address payable);\\n  function getToken(address token) external view returns (address);\\n  function getTokenWihId(uint256 token_id) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/mock/DAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { TestToken } from \\\"./TestToken.sol\\\";\\n\\ncontract DAI is TestToken {\\n  constructor() TestToken(\\\"DAI\\\", \\\"DAI\\\", 18) public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/TestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ERC20Burnable } from \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract TestToken is ERC20, ERC20Burnable {\\n  constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) public {\\n    _setupDecimals(decimals);\\n  }\\n  function mint(address user, uint256 amount) public {\\n    _mint(user, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { TestToken } from \\\"./TestToken.sol\\\";\\n\\ncontract MockWETH is TestToken {\\n  constructor() TestToken(\\\"WETH\\\", \\\"WETH\\\", 18) public {}\\n  function deposit() public {}\\n  function withdraw(uint256 amount) public {\\n    _burn(msg.sender, amount);\\n    msg.sender.transfer(amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/ShifterERC20Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { TestToken } from \\\"./TestToken.sol\\\";\\n\\ncontract ShifterERC20Mock is TestToken {\\n  constructor() TestToken(\\\"zBTC\\\", \\\"zBTC\\\", 8) public {}\\n  function fromUnderlying(uint256 amount) public pure returns (uint256) {\\n    return amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/ShifterMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ShifterERC20Mock } from \\\"./ShifterERC20Mock.sol\\\";\\n\\ncontract ShifterMock {\\n  address public token;\\n  uint256 constant BIPS_DENOMINATOR = 10000;\\n  uint256 constant FEE = 5000;\\n  constructor() public {\\n    token = address(new ShifterERC20Mock());\\n  }\\n  function mint(bytes32 /* pHash */, uint256 amount , bytes32 /* nHash */, bytes memory /* darknode signature */) public returns (uint256) {\\n    ShifterERC20Mock(token).mint(msg.sender, amount / 2);\\n    return amount *FEE / BIPS_DENOMINATOR;\\n  }\\n  function mintFee() public pure returns (uint256) {\\n    return FEE;\\n  }\\n}\\n    \\n\"\r\n    },\r\n    \"contracts/mock/ShifterRegistryMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ShifterMock } from \\\"./ShifterMock.sol\\\";\\n\\ncontract ShifterRegistryMock {\\n  mapping (address => address) public getGatewayByToken;\\n  address public token;\\n  address public shifter;\\n  constructor() public {\\n    shifter = address(new ShifterMock());\\n    token = ShifterMock(shifter).token();\\n    getGatewayByToken[token] = shifter;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/WBTC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { TestToken } from \\\"./TestToken.sol\\\";\\n\\ncontract WBTC is TestToken {\\n  constructor() TestToken(\\\"WBTC\\\", \\\"WBTC\\\", 8) public {}\\n}\\n\"\r\n    },\r\n    \"contracts/preprocessors/lib/Preprocessor.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { PreprocessorLib } from \\\"./PreprocessorLib.sol\\\";\\n\\ncontract Preprocessor {\\n  using PreprocessorLib for *;\\n  function destroy() external {\\n    selfdestruct(msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/preprocessors/SwapEntireLoan.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { PreprocessorLib } from \\\"./lib/PreprocessorLib.sol\\\";\\nimport { IUniswapExchange } from \\\"../interfaces/IUniswapExchange.sol\\\";\\nimport { IUniswapFactory } from \\\"../interfaces/IUniswapFactory.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { StringLib } from \\\"../utils/StringLib.sol\\\";\\n\\ncontract SwapEntireLoan {\\n  using PreprocessorLib for *;\\n  using StringLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  address public factory;\\n  address public target;\\n  function setup(bytes memory consData) public {\\n    (factory, target) = abi.decode(consData, (address, address));\\n  }\\n  function execute(bytes memory data) view public returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    SandboxLib.ExecutionContext memory context = data.toContext();\\n    result = IUniswapFactory(SwapEntireLoan(context.preprocessorAddress).factory())\\n      .getExchange(isolate.token)\\n      .sendTransaction(abi.encodeWithSelector(\\n        IUniswapExchange.tokenToTokenSwapInput.selector,\\n        IERC20(isolate.token).balanceOf(address(this)),\\n        1,\\n        1,\\n        block.timestamp + 1,\\n        SwapEntireLoan(context.preprocessorAddress).target()));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/preprocessors/TransferAll.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { PreprocessorLib } from \\\"./lib/PreprocessorLib.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\n\\ncontract TransferAll {\\n  using PreprocessorLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  address public target;\\n  function setup(bytes memory consData) public {\\n    (target) = abi.decode(consData, (address));\\n  }\\n  function execute(bytes memory data) view public returns (ShifterBorrowProxyLib.InitializationAction[] memory) {\\n    SandboxLib.ExecutionContext memory context = data.toContext();\\n    address token = isolate.token;\\n    return isolate.token.sendTransaction(abi.encodeWithSelector(IERC20.transfer.selector, TransferAll(context.preprocessorAddress).target(), IERC20(token).balanceOf(address(this))));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/preprocessors/V2SwapAndDrop.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { PreprocessorLib } from \\\"./lib/PreprocessorLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { StringLib } from \\\"../utils/StringLib.sol\\\";\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { IUniswapV2Pair } from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport { UniswapV2AdapterLib } from \\\"../adapters/assets/uniswap-v2/UniswapV2AdapterLib.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract V2SwapAndDrop {\\n  using SafeMath for uint256;\\n  using UniswapV2AdapterLib for *;\\n  using PreprocessorLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  address public router;\\n  address public token;\\n  address public recipient;\\n  function setup(bytes memory consData) public {\\n    (router, token, recipient) = abi.decode(consData, (address, address, address));\\n  }\\n  function execute(bytes memory data) view public returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    SandboxLib.ExecutionContext memory context = data.toContext();\\n    V2SwapAndDrop self = V2SwapAndDrop(context.preprocessorAddress);\\n    IUniswapV2Router01 selfRouter = IUniswapV2Router01(self.router());\\n    address borrowToken = isolate.token;\\n    address[] memory path = UniswapV2AdapterLib.generatePathForToken(borrowToken, selfRouter.WETH(), self.token());\\n    return address(selfRouter).sendTransaction(UniswapV2AdapterLib.SwapExactTokensForTokensInputs({\\n      amountIn: IERC20(borrowToken).balanceOf(address(this)),\\n      amountOutMin: 1,\\n      path: path,\\n      to: self.recipient(),\\n      deadline: block.timestamp + 1\\n    }).encodeWithSelector());\\n  }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/queries/GenesisQuery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ShifterPoolQuery } from \\\"./ShifterPoolQuery.sol\\\";\\n\\ncontract GenesisQuery is ShifterPoolQuery {\\n  function execute(bytes memory /* context */) view public returns (uint256) {\\n    return isolate.genesis;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/queries/ShifterPoolQuery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ShifterPoolLib } from \\\"../ShifterPoolLib.sol\\\";\\n\\ncontract ShifterPoolQuery is Ownable {\\n  ShifterPoolLib.Isolate isolate;\\n}\\n\"\r\n    },\r\n    \"contracts/queries/lib/QueryLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary QueryLib {\\n  function returnBytes(bytes memory buffer) internal pure {\\n    assembly {\\n      return(add(0x20, buffer), mload(buffer))\\n    }\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/queries/pending-transfers/PendingTransfersQuery.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ERC20AdapterLib } from \\\"../../adapters/assets/erc20/ERC20AdapterLib.sol\\\";\\n\\ncontract PendingTransfersQuery {\\n  function execute(bytes memory) public view returns (ERC20AdapterLib.EscrowRecord[] memory) {\\n    return ERC20AdapterLib.getIsolatePointer().payments;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/queries/ShifterPoolIsolateQuery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport { ShifterPoolQuery } from \\\"./ShifterPoolQuery.sol\\\";\\nimport {ShifterPoolLib} from \\\"../ShifterPoolLib.sol\\\";\\n\\ncontract ShifterPoolIsolateQuery is ShifterPoolQuery {\\n  struct ExternalIsolate {\\n    uint256 genesis;\\n    address borrowProxyImplementation;\\n    address assetForwarderImplementation;\\n    address shifterRegistry;\\n    uint256 minTimeout;\\n    uint256 poolFee;\\n    uint256 daoFee;\\n    uint256 maxLoan;\\n  }\\n  function execute(bytes memory /* context */) public view returns (ExternalIsolate memory) {\\n    return ExternalIsolate({\\n      genesis: isolate.genesis,\\n      borrowProxyImplementation: isolate.borrowProxyImplementation,\\n      assetForwarderImplementation: isolate.assetForwarderImplementation,\\n      shifterRegistry: isolate.shifterRegistry,\\n      minTimeout: isolate.minTimeout,\\n      poolFee: isolate.poolFee,\\n      daoFee: isolate.daoFee,\\n      maxLoan: isolate.maxLoan\\n    });\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Base58Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary Base58Lib {\\n    bytes constant ALPHABET = \\\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\\";\\n\\n    /// @dev Converts hex string to base 58\\n    function toBase58(bytes memory source) internal pure returns (string memory) {\\n        if (source.length == 0) return new string(0);\\n        uint8[] memory digits = new uint8[](40); //TODO: figure out exactly how much is needed\\n        digits[0] = 0;\\n        uint8 digitlength = 1;\\n        for (uint256 i = 0; i < source.length; ++i) {\\n            uint256 carry = uint8(source[i]);\\n            for (uint256 j = 0; j < digitlength; ++j) {\\n                carry += uint256(digits[j]) * 256;\\n                digits[j] = uint8(carry % 58);\\n                carry = carry / 58;\\n            }\\n\\n            while (carry > 0) {\\n                digits[digitlength] = uint8(carry % 58);\\n                digitlength++;\\n                carry = carry / 58;\\n            }\\n        }\\n        //return digits;\\n        return string(toAlphabet(reverse(truncate(digits, digitlength))));\\n    }\\n\\n    function truncate(uint8[] memory array, uint8 length)\\n        internal pure returns (uint8[] memory)\\n    {\\n        uint8[] memory output = new uint8[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            output[i] = array[i];\\n        }\\n        return output;\\n    }\\n\\n    function reverse(uint8[] memory input) internal pure returns (uint8[] memory) {\\n        uint8[] memory output = new uint8[](input.length);\\n        for (uint256 i = 0; i < input.length; i++) {\\n            output[i] = input[input.length - 1 - i];\\n        }\\n        return output;\\n    }\\n\\n    function toAlphabet(uint8[] memory indices) internal pure returns (bytes memory) {\\n        bytes memory output = new bytes(indices.length);\\n        for (uint256 i = 0; i < indices.length; i++) {\\n            output[i] = ALPHABET[indices[i]];\\n        }\\n        return output;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/BitcoinScriptLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { LELib } from \\\"./LELib.sol\\\";\\nimport { SliceLib } from \\\"./SliceLib.sol\\\";\\nimport { MemcpyLib } from \\\"./MemcpyLib.sol\\\";\\n\\nlibrary BitcoinScriptLib {\\n  using LELib for *;\\n  using SliceLib for *;\\n  struct Script {\\n    bytes buffer;\\n    uint256 len;\\n  }\\n  function newScript(uint256 hint) internal pure returns (Script memory script) {\\n    script.buffer = new bytes(hint);\\n  }\\n  function newScript() internal pure returns (Script memory) {\\n    return newScript(0x400);\\n  }\\n  // push value\\n  uint8 constant _OP_FALSE = 0;\\n  uint8 constant _OP_0 = 0;\\n  uint8 constant _OP_PUSHDATA1 = 76;\\n  uint8 constant _OP_PUSHDATA2 = 77;\\n  uint8 constant _OP_PUSHDATA4 = 78;\\n  uint8 constant _OP_1NEGATE = 79;\\n  uint8 constant _OP_RESERVED = 80;\\n  uint8 constant _OP_TRUE = 81;\\n  uint8 constant _OP_1 = 81;\\n  uint8 constant _OP_2 = 82;\\n  uint8 constant _OP_3 = 83;\\n  uint8 constant _OP_4 = 84;\\n  uint8 constant _OP_5 = 85;\\n  uint8 constant _OP_6 = 86;\\n  uint8 constant _OP_7 = 87;\\n  uint8 constant _OP_8 = 88;\\n  uint8 constant _OP_9 = 89;\\n  uint8 constant _OP_10 = 90;\\n  uint8 constant _OP_11 = 91;\\n  uint8 constant _OP_12 = 92;\\n  uint8 constant _OP_13 = 93;\\n  uint8 constant _OP_14 = 94;\\n  uint8 constant _OP_15 = 95;\\n  uint8 constant _OP_16 = 96;\\n\\n  // control\\n  uint8 constant _OP_NOP = 97;\\n  uint8 constant _OP_VER = 98;\\n  uint8 constant _OP_IF = 99;\\n  uint8 constant _OP_NOTIF = 100;\\n  uint8 constant _OP_VERIF = 101;\\n  uint8 constant _OP_VERNOTIF = 102;\\n  uint8 constant _OP_ELSE = 103;\\n  uint8 constant _OP_ENDIF = 104;\\n  uint8 constant _OP_VERIFY = 105;\\n  uint8 constant _OP_RETURN = 106;\\n  // stack ops\\n  uint8 constant _OP_TOALTSTACK = 107;\\n  uint8 constant _OP_FROMALTSTACK = 108;\\n  uint8 constant _OP_2DROP = 109;\\n  uint8 constant _OP_2DUP = 110;\\n  uint8 constant _OP_3DUP = 111;\\n  uint8 constant _OP_2OVER = 112;\\n  uint8 constant _OP_2ROT = 113;\\n  uint8 constant _OP_2SWAP = 114;\\n  uint8 constant _OP_IFDUP = 115;\\n  uint8 constant _OP_DEPTH = 116;\\n  uint8 constant _OP_DROP = 117;\\n  uint8 constant _OP_DUP = 118;\\n  uint8 constant _OP_NIP = 119;\\n  uint8 constant _OP_OVER = 120;\\n  uint8 constant _OP_PICK = 121;\\n  uint8 constant _OP_ROLL = 122;\\n  uint8 constant _OP_ROT = 123;\\n  uint8 constant _OP_SWAP = 124;\\n  uint8 constant _OP_TUCK = 125;\\n\\n  // splice ops\\n  uint8 constant _OP_CAT = 126;\\n  uint8 constant _OP_SUBSTR = 127;\\n  uint8 constant _OP_LEFT = 128;\\n  uint8 constant _OP_RIGHT = 129;\\n  uint8 constant _OP_SIZE = 130;\\n\\n  // bit logic\\n  uint8 constant _OP_INVERT = 131;\\n  uint8 constant _OP_AND = 132;\\n  uint8 constant _OP_OR = 133;\\n  uint8 constant _OP_XOR = 134;\\n  uint8 constant _OP_EQUAL = 135;\\n  uint8 constant _OP_EQUALVERIFY = 136;\\n  uint8 constant _OP_RESERVED1 = 137;\\n  uint8 constant _OP_RESERVED2 = 138;\\n\\n  // numeric\\n  uint8 constant _OP_1ADD = 139;\\n  uint8 constant _OP_1SUB = 140;\\n  uint8 constant _OP_2MUL = 141;\\n  uint8 constant _OP_2DIV = 142;\\n  uint8 constant _OP_NEGATE = 143;\\n  uint8 constant _OP_ABS = 144;\\n  uint8 constant _OP_NOT = 145;\\n  uint8 constant _OP_0NOTEQUAL = 146;\\n\\n  uint8 constant _OP_ADD = 147;\\n  uint8 constant _OP_SUB = 148;\\n  uint8 constant _OP_MUL = 149;\\n  uint8 constant _OP_DIV = 150;\\n  uint8 constant _OP_MOD = 151;\\n  uint8 constant _OP_LSHIFT = 152;\\n  uint8 constant _OP_RSHIFT = 153;\\n\\n  uint8 constant _OP_BOOLAND = 154;\\n  uint8 constant _OP_BOOLOR = 155;\\n  uint8 constant _OP_NUMEQUAL = 156;\\n  uint8 constant _OP_NUMEQUALVERIFY = 157;\\n  uint8 constant _OP_NUMNOTEQUAL = 158;\\n  uint8 constant _OP_LESSTHAN = 159;\\n  uint8 constant _OP_GREATERTHAN = 160;\\n  uint8 constant _OP_LESSTHANOREQUAL = 161;\\n  uint8 constant _OP_GREATERTHANOREQUAL = 162;\\n  uint8 constant _OP_MIN = 163;\\n  uint8 constant _OP_MAX = 164;\\n\\n  uint8 constant _OP_WITHIN = 165;\\n\\n  // crypto\\n  uint8 constant _OP_RIPEMD160 = 166;\\n  uint8 constant _OP_SHA1 = 167;\\n  uint8 constant _OP_SHA256 = 168;\\n  uint8 constant _OP_HASH160 = 169;\\n  uint8 constant _OP_HASH256 = 170;\\n  uint8 constant _OP_CODESEPARATOR = 171;\\n  uint8 constant _OP_CHECKSIG = 172;\\n  uint8 constant _OP_CHECKSIGVERIFY = 173;\\n  uint8 constant _OP_CHECKMULTISIG = 174;\\n  uint8 constant _OP_CHECKMULTISIGVERIFY = 175;\\n\\n  uint8 constant _OP_CHECKLOCKTIMEVERIFY = 177;\\n  uint8 constant _OP_CHECKSEQUENCEVERIFY = 178;\\n\\n  // expansion\\n  uint8 constant _OP_NOP1 = 176;\\n  uint8 constant _OP_NOP2 = 177;\\n  uint8 constant _OP_NOP3 = 178;\\n  uint8 constant _OP_NOP4 = 179;\\n  uint8 constant _OP_NOP5 = 180;\\n  uint8 constant _OP_NOP6 = 181;\\n  uint8 constant _OP_NOP7 = 182;\\n  uint8 constant _OP_NOP8 = 183;\\n  uint8 constant _OP_NOP9 = 184;\\n  uint8 constant _OP_NOP10 = 185;\\n\\n  // template matching params\\n  uint8 constant _OP_PUBKEYHASH = 253;\\n  uint8 constant _OP_PUBKEY = 254;\\n  uint8 constant _OP_INVALIDOPCODE = 255;\\n  function OP_FALSE() internal pure returns (uint8) {\\n    return _OP_FALSE;\\n  }\\n  function OP_0() internal pure returns (uint8) {\\n    return _OP_0;\\n  }\\n  function OP_PUSHDATA1() internal pure returns (uint8) {\\n    return _OP_PUSHDATA1;\\n  }\\n  function OP_PUSHDATA2() internal pure returns (uint8) {\\n    return _OP_PUSHDATA2;\\n  }\\n  function OP_PUSHDATA4() internal pure returns (uint8) {\\n    return _OP_PUSHDATA4;\\n  }\\n  function OP_1NEGATE() internal pure returns (uint8) {\\n    return _OP_1NEGATE;\\n  }\\n  function OP_RESERVED() internal pure returns (uint8) {\\n    return _OP_RESERVED;\\n  }\\n  function OP_TRUE() internal pure returns (uint8) {\\n    return _OP_TRUE;\\n  }\\n  function OP_1() internal pure returns (uint8) {\\n    return _OP_1;\\n  }\\n  function OP_2() internal pure returns (uint8) {\\n    return _OP_2;\\n  }\\n  function OP_3() internal pure returns (uint8) {\\n    return _OP_3;\\n  }\\n  function OP_4() internal pure returns (uint8) {\\n    return _OP_4;\\n  }\\n  function OP_5() internal pure returns (uint8) {\\n    return _OP_5;\\n  }\\n  function OP_6() internal pure returns (uint8) {\\n    return _OP_6;\\n  }\\n  function OP_7() internal pure returns (uint8) {\\n    return _OP_7;\\n  }\\n  function OP_8() internal pure returns (uint8) {\\n    return _OP_8;\\n  }\\n  function OP_9() internal pure returns (uint8) {\\n    return _OP_9;\\n  }\\n  function OP_10() internal pure returns (uint8) {\\n    return _OP_10;\\n  }\\n  function OP_11() internal pure returns (uint8) {\\n    return _OP_11;\\n  }\\n  function OP_12() internal pure returns (uint8) {\\n    return _OP_12;\\n  }\\n  function OP_13() internal pure returns (uint8) {\\n    return _OP_13;\\n  }\\n  function OP_14() internal pure returns (uint8) {\\n    return _OP_14;\\n  }\\n  function OP_15() internal pure returns (uint8) {\\n    return _OP_15;\\n  }\\n  function OP_16() internal pure returns (uint8) {\\n    return _OP_16;\\n  }\\n  function OP_NOP() internal pure returns (uint8) {\\n    return _OP_NOP;\\n  }\\n  function OP_VER() internal pure returns (uint8) {\\n    return _OP_VER;\\n  }\\n  function OP_IF() internal pure returns (uint8) {\\n    return _OP_IF;\\n  }\\n  function OP_NOTIF() internal pure returns (uint8) {\\n    return _OP_NOTIF;\\n  }\\n  function OP_VERIF() internal pure returns (uint8) {\\n    return _OP_VERIF;\\n  }\\n  function OP_VERNOTIF() internal pure returns (uint8) {\\n    return _OP_VERNOTIF;\\n  }\\n  function OP_ELSE() internal pure returns (uint8) {\\n    return _OP_ELSE;\\n  }\\n  function OP_ENDIF() internal pure returns (uint8) {\\n    return _OP_ENDIF;\\n  }\\n  function OP_VERIFY() internal pure returns (uint8) {\\n    return _OP_VERIFY;\\n  }\\n  function OP_RETURN() internal pure returns (uint8) {\\n    return _OP_RETURN;\\n  }\\n  function OP_TOALTSTACK() internal pure returns (uint8) {\\n    return _OP_TOALTSTACK;\\n  }\\n  function OP_FROMALTSTACK() internal pure returns (uint8) {\\n    return _OP_FROMALTSTACK;\\n  }\\n  function OP_2DROP() internal pure returns (uint8) {\\n    return _OP_2DROP;\\n  }\\n  function OP_2DUP() internal pure returns (uint8) {\\n    return _OP_2DUP;\\n  }\\n  function OP_3DUP() internal pure returns (uint8) {\\n    return _OP_3DUP;\\n  }\\n  function OP_2OVER() internal pure returns (uint8) {\\n    return _OP_2OVER;\\n  }\\n  function OP_2ROT() internal pure returns (uint8) {\\n    return _OP_2ROT;\\n  }\\n  function OP_2SWAP() internal pure returns (uint8) {\\n    return _OP_2SWAP;\\n  }\\n  function OP_IFDUP() internal pure returns (uint8) {\\n    return _OP_IFDUP;\\n  }\\n  function OP_DEPTH() internal pure returns (uint8) {\\n    return _OP_DEPTH;\\n  }\\n  function OP_DROP() internal pure returns (uint8) {\\n    return _OP_DROP;\\n  }\\n  function OP_DUP() internal pure returns (uint8) {\\n    return _OP_DUP;\\n  }\\n  function OP_NIP() internal pure returns (uint8) {\\n    return _OP_NIP;\\n  }\\n  function OP_OVER() internal pure returns (uint8) {\\n    return _OP_OVER;\\n  }\\n  function OP_PICK() internal pure returns (uint8) {\\n    return _OP_PICK;\\n  }\\n  function OP_ROLL() internal pure returns (uint8) {\\n    return _OP_ROLL;\\n  }\\n  function OP_ROT() internal pure returns (uint8) {\\n    return _OP_ROT;\\n  }\\n  function OP_SWAP() internal pure returns (uint8) {\\n    return _OP_SWAP;\\n  }\\n  function OP_TUCK() internal pure returns (uint8) {\\n    return _OP_TUCK;\\n  }\\n  function OP_CAT() internal pure returns (uint8) {\\n    return _OP_CAT;\\n  }\\n  function OP_SUBSTR() internal pure returns (uint8) {\\n    return _OP_SUBSTR;\\n  }\\n  function OP_LEFT() internal pure returns (uint8) {\\n    return _OP_LEFT;\\n  }\\n  function OP_RIGHT() internal pure returns (uint8) {\\n    return _OP_RIGHT;\\n  }\\n  function OP_SIZE() internal pure returns (uint8) {\\n    return _OP_SIZE;\\n  }\\n  function OP_INVERT() internal pure returns (uint8) {\\n    return _OP_INVERT;\\n  }\\n  function OP_AND() internal pure returns (uint8) {\\n    return _OP_AND;\\n  }\\n  function OP_OR() internal pure returns (uint8) {\\n    return _OP_OR;\\n  }\\n  function OP_XOR() internal pure returns (uint8) {\\n    return _OP_XOR;\\n  }\\n  function OP_EQUAL() internal pure returns (uint8) {\\n    return _OP_EQUAL;\\n  }\\n  function OP_EQUALVERIFY() internal pure returns (uint8) {\\n    return _OP_EQUALVERIFY;\\n  }\\n  function OP_RESERVED1() internal pure returns (uint8) {\\n    return _OP_RESERVED1;\\n  }\\n  function OP_RESERVED2() internal pure returns (uint8) {\\n    return _OP_RESERVED2;\\n  }\\n  function OP_1ADD() internal pure returns (uint8) {\\n    return _OP_1ADD;\\n  }\\n  function OP_1SUB() internal pure returns (uint8) {\\n    return _OP_1SUB;\\n  }\\n  function OP_2MUL() internal pure returns (uint8) {\\n    return _OP_2MUL;\\n  }\\n  function OP_2DIV() internal pure returns (uint8) {\\n    return _OP_2DIV;\\n  }\\n  function OP_NEGATE() internal pure returns (uint8) {\\n    return _OP_NEGATE;\\n  }\\n  function OP_ABS() internal pure returns (uint8) {\\n    return _OP_ABS;\\n  }\\n  function OP_NOT() internal pure returns (uint8) {\\n    return _OP_NOT;\\n  }\\n  function OP_0NOTEQUAL() internal pure returns (uint8) {\\n    return _OP_0NOTEQUAL;\\n  }\\n  function OP_ADD() internal pure returns (uint8) {\\n    return _OP_ADD;\\n  }\\n  function OP_SUB() internal pure returns (uint8) {\\n    return _OP_SUB;\\n  }\\n  function OP_MUL() internal pure returns (uint8) {\\n    return _OP_MUL;\\n  }\\n  function OP_DIV() internal pure returns (uint8) {\\n    return _OP_DIV;\\n  }\\n  function OP_MOD() internal pure returns (uint8) {\\n    return _OP_MOD;\\n  }\\n  function OP_LSHIFT() internal pure returns (uint8) {\\n    return _OP_LSHIFT;\\n  }\\n  function OP_RSHIFT() internal pure returns (uint8) {\\n    return _OP_RSHIFT;\\n  }\\n  function OP_BOOLAND() internal pure returns (uint8) {\\n    return _OP_BOOLAND;\\n  }\\n  function OP_BOOLOR() internal pure returns (uint8) {\\n    return _OP_BOOLOR;\\n  }\\n  function OP_NUMEQUAL() internal pure returns (uint8) {\\n    return _OP_NUMEQUAL;\\n  }\\n  function OP_NUMEQUALVERIFY() internal pure returns (uint8) {\\n    return _OP_NUMEQUALVERIFY;\\n  }\\n  function OP_NUMNOTEQUAL() internal pure returns (uint8) {\\n    return _OP_NUMNOTEQUAL;\\n  }\\n  function OP_LESSTHAN() internal pure returns (uint8) {\\n    return _OP_LESSTHAN;\\n  }\\n  function OP_GREATERTHAN() internal pure returns (uint8) {\\n    return _OP_GREATERTHAN;\\n  }\\n  function OP_LESSTHANOREQUAL() internal pure returns (uint8) {\\n    return _OP_LESSTHANOREQUAL;\\n  }\\n  function OP_GREATERTHANOREQUAL() internal pure returns (uint8) {\\n    return _OP_GREATERTHANOREQUAL;\\n  }\\n  function OP_MIN() internal pure returns (uint8) {\\n    return _OP_MIN;\\n  }\\n  function OP_MAX() internal pure returns (uint8) {\\n    return _OP_MAX;\\n  }\\n  function OP_WITHIN() internal pure returns (uint8) {\\n    return _OP_WITHIN;\\n  }\\n  function OP_RIPEMD160() internal pure returns (uint8) {\\n    return _OP_RIPEMD160;\\n  }\\n  function OP_SHA1() internal pure returns (uint8) {\\n    return _OP_SHA1;\\n  }\\n  function OP_SHA256() internal pure returns (uint8) {\\n    return _OP_SHA256;\\n  }\\n  function OP_HASH160() internal pure returns (uint8) {\\n    return _OP_HASH160;\\n  }\\n  function OP_HASH256() internal pure returns (uint8) {\\n    return _OP_HASH256;\\n  }\\n  function OP_CODESEPARATOR() internal pure returns (uint8) {\\n    return _OP_CODESEPARATOR;\\n  }\\n  function OP_CHECKSIG() internal pure returns (uint8) {\\n    return _OP_CHECKSIG;\\n  }\\n  function OP_CHECKSIGVERIFY() internal pure returns (uint8) {\\n    return _OP_CHECKSIGVERIFY;\\n  }\\n  function OP_CHECKMULTISIG() internal pure returns (uint8) {\\n    return _OP_CHECKMULTISIG;\\n  }\\n  function OP_CHECKMULTISIGVERIFY() internal pure returns (uint8) {\\n    return _OP_CHECKMULTISIGVERIFY;\\n  }\\n  function OP_CHECKLOCKTIMEVERIFY() internal pure returns (uint8) {\\n    return _OP_CHECKLOCKTIMEVERIFY;\\n  }\\n  function OP_CHECKSEQUENCEVERIFY() internal pure returns (uint8) {\\n    return _OP_CHECKSEQUENCEVERIFY;\\n  }\\n  function OP_NOP1() internal pure returns (uint8) {\\n    return _OP_NOP1;\\n  }\\n  function OP_NOP2() internal pure returns (uint8) {\\n    return _OP_NOP2;\\n  }\\n  function OP_NOP3() internal pure returns (uint8) {\\n    return _OP_NOP3;\\n  }\\n  function OP_NOP4() internal pure returns (uint8) {\\n    return _OP_NOP4;\\n  }\\n  function OP_NOP5() internal pure returns (uint8) {\\n    return _OP_NOP5;\\n  }\\n  function OP_NOP6() internal pure returns (uint8) {\\n    return _OP_NOP6;\\n  }\\n  function OP_NOP7() internal pure returns (uint8) {\\n    return _OP_NOP7;\\n  }\\n  function OP_NOP8() internal pure returns (uint8) {\\n    return _OP_NOP8;\\n  }\\n  function OP_NOP9() internal pure returns (uint8) {\\n    return _OP_NOP9;\\n  }\\n  function OP_NOP10() internal pure returns (uint8) {\\n    return _OP_NOP10;\\n  }\\n  function OP_PUBKEYHASH() internal pure returns (uint8) {\\n    return _OP_PUBKEYHASH;\\n  }\\n  function OP_PUBKEY() internal pure returns (uint8) {\\n    return _OP_PUBKEY;\\n  }\\n  function OP_INVALIDOPCODE() internal pure returns (uint8) {\\n    return _OP_INVALIDOPCODE;\\n  }\\n  function _maybeRealloc(Script memory script, uint256 size) internal pure {\\n    if (script.len + size > script.buffer.length) {\\n      _realloc(script, script.buffer.length << 0x1);\\n    }\\n  }\\n  function _realloc(Script memory script, uint256 newLength) internal pure {\\n    bytes memory newBuffer = new bytes(newLength);\\n    bytes memory buffer = script.buffer;\\n    bytes32 newPtr;\\n    bytes32 ptr;\\n    assembly {\\n      newPtr := add(0x20, newBuffer)\\n      ptr := add(0x20, buffer)\\n    }\\n    MemcpyLib.memcpy(newPtr, ptr, script.len);\\n    script.buffer = newBuffer;\\n  }\\n  function addScript(Script memory script, uint8 op) internal pure returns (Script memory) {\\n    _maybeRealloc(script, 0x1);\\n    script.buffer[op] = byte(op);\\n    script.len++;\\n  } \\n  function addScript(Script memory script, bytes memory buffer) internal pure returns (Script memory) {\\n    uint256 length = buffer.length;\\n    uint256 sz;\\n    bytes memory lengthBuffer;\\n    uint256 lenPtr;\\n    uint256 ptr;\\n    uint256 newPtr;\\n    byte op; \\n    if (length < 0x100) {\\n      lengthBuffer = new bytes(1);\\n      sz = 1;\\n      op = byte(bytes1(_OP_PUSHDATA1));\\n      lengthBuffer[0] = byte(uint8(length));\\n    } else if (length < 0x10000) {\\n      lengthBuffer = uint16(length).toLE16();\\n      sz = 2;\\n      op = byte(bytes1(_OP_PUSHDATA2));\\n    } else if (length < 0x100000000) {\\n      lengthBuffer = uint32(length).toLE32();\\n      sz = 4;\\n      op = byte(bytes1(_OP_PUSHDATA4));\\n    } else revert(\\\"script pushdata overflow\\\");\\n    _maybeRealloc(script, sz + 1 + buffer.length);\\n    bytes memory scriptBuffer = script.buffer;\\n    scriptBuffer[script.len] = op;\\n    assembly {\\n      lenPtr := add(0x20, lengthBuffer)\\n      ptr := add(0x21, scriptBuffer)\\n      newPtr := add(0x20, buffer)\\n    }\\n    MemcpyLib.memcpy(bytes32(ptr), bytes32(newPtr), sz);\\n    MemcpyLib.memcpy(bytes32(ptr + sz), bytes32(newPtr), buffer.length);\\n    return script;\\n  }\\n  function toBuffer(Script memory script) internal pure returns (bytes memory buffer) {\\n    buffer = script.buffer.toSlice(0, script.len).copy();\\n  }\\n  function hashBuffer(Script memory script) internal pure returns (bytes memory result) {\\n    bytes20 word = ripemd160(abi.encodePacked(keccak256(toBuffer(script))));\\n    result = new bytes(20);\\n    assembly {\\n      mstore(add(0x20, result), word)\\n    }\\n  }\\n  function toScriptHashOut(Script memory script) internal pure returns (Script memory output) {\\n    output = newScript(24);\\n    addScript(output, _OP_HASH160);\\n    addScript(output, hashBuffer(script));\\n    addScript(output, _OP_EQUAL);\\n  }\\n  function toAddress(Script memory script, bool isTestnet) internal pure returns (bytes memory buffer) {\\n    buffer = new bytes(21);\\n    buffer[0] = byte(uint8(isTestnet ? 0xc4 : 0x05));\\n    bytes memory scriptHash = hashBuffer(script);\\n    assembly {\\n      mstore(add(buffer, 0x21), mload(add(0x20, scriptHash)))\\n    }\\n  }\\n  function addressToBytes(address input) internal pure returns (bytes memory buffer) {\\n    buffer = new bytes(20);\\n    bytes20 word = bytes20(uint160(input));\\n    assembly {\\n      mstore(add(0x20, buffer), word)\\n    }\\n  }\\n  function bytes32ToBytes(bytes32 input) internal pure returns (bytes memory buffer) {\\n    buffer = new bytes(32);\\n    assembly {\\n      mstore(add(0x20, buffer), input)\\n    }\\n  }\\n  function assembleMintScript(bytes32 gHash, address mpkh) internal pure returns (Script memory script) {\\n    script = newScript(0x3d);\\n    addScript(script, bytes32ToBytes(gHash));\\n    addScript(script, _OP_DROP);\\n    addScript(script, _OP_DUP);\\n    addScript(script, _OP_HASH160);\\n    addScript(script, addressToBytes(mpkh));\\n    addScript(script, _OP_EQUALVERIFY);\\n    addScript(script, _OP_CHECKSIG);\\n    return toScriptHashOut(script);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LELib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary LELib {\\n  function toLE16(uint16 sz) internal pure returns (bytes memory buffer) {\\n    bytes2 casted = bytes2(sz);\\n    buffer = new bytes(2);\\n    assembly {\\n      mstore(add(0x20, buffer), casted)\\n    }\\n    byte tmp = buffer[0];\\n    buffer[0] = buffer[1];\\n    buffer[1] = tmp;\\n  }\\n  function toLE32(uint32 sz) internal pure returns (bytes memory buffer) {\\n    bytes4 casted = bytes4(sz);\\n    buffer = new bytes(4);\\n    assembly {\\n      mstore(add(0x20, buffer), casted)\\n    }\\n    byte tmp = buffer[0];\\n    buffer[0] = buffer[3];\\n    buffer[3] = tmp;\\n    tmp = buffer[1];\\n    buffer[1] = buffer[2];\\n    buffer[2] = tmp;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RStoreLib.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { MemcpyLib } from \\\"./MemcpyLib.sol\\\";\\n\\nlibrary RStoreLib {\\n  bytes32 constant ZERO_SALT = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n  function store(bytes memory data) internal returns (address) {\\n    bytes memory segment = hex\\\"7f000000000000000000000000000000000000000000000000000000000000000080602a6000396000f3\\\";\\n    uint256 length = data.length;\\n    bytes32 dest;\\n    bytes32 src;\\n    assembly {\\n      mstore(add(segment, 0x21), length)\\n      mstore(segment, add(0x2a, length))\\n      dest := add(segment, 0x4a)\\n      src := add(data, 0x20)\\n    }\\n    MemcpyLib.memcpy(dest, src, length);\\n    return Create2.deploy(0, ZERO_SALT, segment);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sandbox/ISafeViewExecutor.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SafeViewLib } from \\\"./SafeViewLib.sol\\\";\\n\\ncontract ISafeViewExecutor {\\n  function query(bytes memory /* creationCode */, bytes memory /* context */) public view returns (SafeViewLib.SafeViewResult memory) {\\n   // stub\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/ShifterBorrowProxyFactoryLib.sol\": {\r\n        \"ShifterBorrowProxyFactoryLib\": \"0xb1cc0520649bfd8282cffbb6c57b63642419c26f\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"creationCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"_executeSafeView\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"consData\",\"type\":\"bytes\"}],\"name\":\"cloneConstructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"computeProxyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployAssetForwarderClone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"created\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployAssetForwarderImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployBorrowProxyImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"forbidLoan\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.InitializationAction[]\",\"name\":\"actions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ShifterBorrowProxyLib.LiquidityRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"gasRequested\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.LiquidityRequestParcel\",\"name\":\"liquidityRequestParcel\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeoutExpiry\",\"type\":\"uint256\"}],\"name\":\"executeBorrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"forbidLoan\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.InitializationAction[]\",\"name\":\"actions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ShifterBorrowProxyLib.LiquidityRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"gasRequested\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.LiquidityRequestParcel\",\"name\":\"liquidityRequestParcel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"txhash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"vout\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"pHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"darknodeSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.ShiftParameters\",\"name\":\"shiftParameters\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.InitializationAction[]\",\"name\":\"actions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ShifterBorrowProxyLib.SansBorrowShiftParcel\",\"name\":\"parcel\",\"type\":\"tuple\"}],\"name\":\"executeShiftSansBorrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"fetchModuleHandler\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPrecompiled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"assetSubmodule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationSubmodule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"repaymentSubmodule\",\"type\":\"address\"}],\"internalType\":\"struct BorrowProxyLib.Module\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssetForwarderImplementationHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyAddress\",\"type\":\"address\"}],\"name\":\"getGasReserved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLiquidityTokenForTokenHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLiquidityTokenHandler\",\"outputs\":[{\"internalType\":\"contract LiquidityToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getProxyOwnerHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyAddress\",\"type\":\"address\"}],\"name\":\"getProxyTokenHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getShifterHandler\",\"outputs\":[{\"internalType\":\"contract IShifter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountBorrower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrigin\",\"type\":\"uint256\"}],\"name\":\"payoutCallbackGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"creationCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"query\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SafeViewLib.SafeViewResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalAmount\",\"type\":\"uint256\"}],\"name\":\"relayResolveLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isKeeper\",\"type\":\"bool\"}],\"name\":\"setKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"shifterRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasEstimate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPriceForRefund\",\"type\":\"uint256\"}],\"internalType\":\"struct ShifterPoolLib.SetupParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum BorrowProxyLib.ModuleRegistrationType\",\"name\":\"moduleType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"sigs\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct BorrowProxyLib.ModuleDetails[]\",\"name\":\"moduleDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPrecompiled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"assetSubmodule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationSubmodule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"repaymentSubmodule\",\"type\":\"address\"}],\"internalType\":\"struct BorrowProxyLib.Module[]\",\"name\":\"modules\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liqToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ShifterPoolLib.LiquidityTokenLaunch[]\",\"name\":\"tokenLaunches\",\"type\":\"tuple[]\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proxyRecord\",\"type\":\"bytes\"}],\"name\":\"validateProxyRecordHandler\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ShifterPool","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}