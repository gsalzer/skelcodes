{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/legacy/actions/ActionGelatoV1.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.8.0;\\n\\nimport {\\n    Address\\n} from \\\"../../vendor/openzeppelin/contracts/utils/Address.sol\\\";\\n\\n// Gelato Data Types\\nstruct Provider {\\n    address addr;  //  if msg.sender == provider => self-Provider\\n    address module;  //  e.g. DSA Provider Module\\n}\\n\\nstruct Condition {\\n    address inst;  // can be AddressZero for self-conditional Actions\\n    bytes data;  // can be bytes32(0) for self-conditional Actions\\n}\\n\\nenum Operation { Call, Delegatecall }\\n\\nenum DataFlow { None, In, Out, InAndOut }\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions;  // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\\n}\\n\\nstruct TaskReceipt {\\n    uint256 id;\\n    address userProxy;\\n    Provider provider;\\n    uint256 index;\\n    Task[] tasks;\\n    uint256 expiryDate;\\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\\n    uint256 submissionsLeft;\\n}\\n\\nstruct TaskSpec {\\n    address[] conditions;   // Address: optional AddressZero for self-conditional actions\\n    Action[] actions;\\n    uint256 gasPriceCeil;\\n}\\n\\n// Gelato Interface\\ninterface IGelatoCore {\\n\\n    /**\\n     * @dev API to submit a single Task.\\n    */\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external;\\n\\n\\n    /**\\n     * @dev A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n     * the next one, after they have been executed, where the total number of tasks can\\n     * be only be an even number\\n    */\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    )\\n        external;\\n\\n\\n    /**\\n     * @dev A Gelato Task Chain consists of 1 or more Tasks that automatically submit\\n     * the next one, after they have been executed, where the total number of tasks can\\n     * be an odd number\\n    */\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    )\\n        external;\\n\\n    /**\\n     * @dev Cancel multiple tasks at once\\n    */\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\\n\\n    /**\\n     * @dev Whitelist new executor, TaskSpec(s) and Module(s) in one tx\\n    */\\n    function multiProvide(\\n        address _executor,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules\\n    )\\n        external\\n        payable;\\n\\n\\n    /**\\n     * @dev De-Whitelist TaskSpec(s), Module(s) and withdraw funds from gelato in one tx\\n    */\\n    function multiUnprovide(\\n        uint256 _withdrawAmount,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules\\n    )\\n        external;\\n\\n\\n    /**\\n     * @dev Deposits funds on Gelato Core\\n    */\\n    function provideFunds(address _provider) external payable;\\n\\n    /**\\n     * @dev Withdraws funds on Gelato Core\\n    */\\n    function unprovideFunds(uint256 _withdrawAmount) external returns(uint256);\\n}\\n\\n\\n/// @title ActionGelatoV1\\n/// @author Hilmar Orth\\n/// @notice Gelato Action that\\ncontract ActionGelatoV1 {\\n\\n    using Address for address payable;\\n    address constant GELATO_CORE = 0x025030BdAa159f281cAe63873E68313a703725A5;\\n\\n    // ===== Gelato ENTRY APIs ======\\n\\n    /**\\n     * @dev Enables first time users to  pre-fund eth, whitelist an executor & register the\\n     * ProviderModuleDSA.sol to be able to use Gelato\\n     * @param _executor address of single execot node or gelato'S decentralized execution market\\n     * @param _taskSpecs enables external providers to whitelist TaskSpecs on gelato\\n     * @param _modules address of ProviderModuleDSA\\n     * @param _ethToDeposit amount of eth to deposit on Gelato, only for self-providers\\n     */\\n    function multiProvide(\\n        address _executor,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules,\\n        uint256 _ethToDeposit\\n    ) external payable {\\n        uint256 ethToDeposit = _ethToDeposit == type(uint256).max\\n            ? address(this).balance\\n            : _ethToDeposit;\\n\\n        IGelatoCore(GELATO_CORE).multiProvide{value: ethToDeposit}(\\n            _executor,\\n            _taskSpecs,\\n            _modules\\n        );\\n    }\\n\\n    /**\\n     * @dev Deposit Funds on Gelato to a given address\\n     * @param _provider address of balance to top up on Gelato\\n     * @param _ethToDeposit amount of eth to deposit on Gelato\\n     */\\n    function provideFunds(\\n        address _provider,\\n        uint256 _ethToDeposit\\n    ) external payable {\\n        uint256 ethToDeposit = _ethToDeposit == type(uint256).max\\n            ? address(this).balance\\n            : _ethToDeposit;\\n\\n        IGelatoCore(GELATO_CORE).provideFunds{value: ethToDeposit}(\\n            _provider\\n        );\\n    }\\n\\n    /**\\n     * @dev Withdraw funds previously deposited on Gelato\\n     * @param _ethToWithdraw amount of eth to withdraw from Gelato\\n     */\\n    function unprovideFunds(\\n        uint256 _ethToWithdraw,\\n        address payable _receiver\\n    ) external payable {\\n        uint256 withdrawAmount = IGelatoCore(GELATO_CORE).unprovideFunds(\\n            _ethToWithdraw\\n        );\\n        if (_receiver != address(0) && _receiver != address(this))\\n            _receiver.sendValue(withdrawAmount);\\n    }\\n\\n    /**\\n     * @dev Submits a single, one-time task to Gelato\\n     * @param _provider Consists of proxy module address (DSA) and provider address ()\\n     * who will pay for the transaction execution\\n     * @param _task Task specifying the condition and the action connectors\\n     * @param _expiryDate Default 0, othweise timestamp after which the task expires\\n     */\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    ) external payable {\\n        IGelatoCore(GELATO_CORE).submitTask(_provider, _task, _expiryDate);\\n    }\\n\\n    /**\\n     * @dev Submits single or mulitple Task Sequences to Gelato\\n     * @param _provider Consists of proxy module address (DSA) and provider address ()\\n     * who will pay for the transaction execution\\n     * @param _tasks A sequence of Tasks, can be a single or multiples\\n     * @param _expiryDate Default 0, othweise timestamp after which the task expires\\n     * @param _cycles How often the Task List should be executed, e.g. 5 times\\n     */\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    ) external payable {\\n        IGelatoCore(GELATO_CORE).submitTaskCycle(\\n            _provider,\\n            _tasks,\\n            _expiryDate,\\n            _cycles\\n        );\\n    }\\n\\n    /**\\n     * @dev Submits single or mulitple Task Chains to Gelato\\n     * @param _provider Consists of proxy module address (DSA) and provider address ()\\n     * who will pay for the transaction execution\\n     * @param _tasks A sequence of Tasks, can be a single or multiples\\n     * @param _expiryDate Default 0, othweise timestamp after which the task expires\\n     * @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\\n     * that should have occured once the cycle is complete\\n     */\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    ) external payable {\\n        IGelatoCore(GELATO_CORE).submitTaskChain(\\n            _provider,\\n            _tasks,\\n            _expiryDate,\\n            _sumOfRequestedTaskSubmits\\n        );\\n    }\\n\\n    // ===== Gelato EXIT APIs ======\\n\\n    /**\\n     * @dev Withdraws funds from Gelato, de-whitelists TaskSpecs and Provider Modules\\n     * in one tx\\n     * @param _withdrawAmount Amount of ETH to withdraw from Gelato\\n     * @param _taskSpecs List of Task Specs to de-whitelist, default empty []\\n     * @param _modules List of Provider Modules to de-whitelist, default empty []\\n     */\\n    function multiUnprovide(\\n        uint256 _withdrawAmount,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules\\n    ) external payable {\\n\\n        IGelatoCore(GELATO_CORE).multiUnprovide(\\n            _withdrawAmount,\\n            _taskSpecs,\\n            _modules\\n        );\\n    }\\n\\n    /**\\n     * @dev Cancels outstanding Tasks\\n     * @param _taskReceipts List of Task Receipts to cancel\\n     */\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts)\\n        external payable\\n    {\\n        IGelatoCore(GELATO_CORE).multiCancelTasks(_taskReceipts);\\n    }\\n}\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) =\\n            target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userProxy\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"internalType\":\"struct Provider\",\"name\":\"provider\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task[]\",\"name\":\"tasks\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submissionsLeft\",\"type\":\"uint256\"}],\"internalType\":\"struct TaskReceipt[]\",\"name\":\"_taskReceipts\",\"type\":\"tuple[]\"}],\"name\":\"multiCancelTasks\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"conditions\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct TaskSpec[]\",\"name\":\"_taskSpecs\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_ethToDeposit\",\"type\":\"uint256\"}],\"name\":\"multiProvide\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"conditions\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct TaskSpec[]\",\"name\":\"_taskSpecs\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"}],\"name\":\"multiUnprovide\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethToDeposit\",\"type\":\"uint256\"}],\"name\":\"provideFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"internalType\":\"struct Provider\",\"name\":\"_provider\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task\",\"name\":\"_task\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_expiryDate\",\"type\":\"uint256\"}],\"name\":\"submitTask\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"internalType\":\"struct Provider\",\"name\":\"_provider\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task[]\",\"name\":\"_tasks\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sumOfRequestedTaskSubmits\",\"type\":\"uint256\"}],\"name\":\"submitTaskChain\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"internalType\":\"struct Provider\",\"name\":\"_provider\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task[]\",\"name\":\"_tasks\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cycles\",\"type\":\"uint256\"}],\"name\":\"submitTaskCycle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"unprovideFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ActionGelatoV1","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}