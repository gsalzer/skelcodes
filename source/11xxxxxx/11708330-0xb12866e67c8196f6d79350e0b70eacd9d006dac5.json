{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/PollenParams.sol\r\n\r\n// This file is generated for the \"mainnet\" network\r\n// by the 'generate-PollenAddresses_sol.js' script.\r\n// Do not edit it directly - updates will be lost.\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/// @dev Network-dependant params (i.e. addresses, block numbers, etc..)\r\ncontract PollenParams {\r\n\r\n    // Pollen contracts addresses\r\n    address internal constant pollenDaoAddress = 0x99c0268759d26616AeC761c28336eccd72CCa39A;\r\n    address internal constant plnTokenAddress = 0xF4db951000acb9fdeA6A9bCB4afDe42dd52311C7;\r\n    address internal constant stemTokenAddress = 0xd12ABa72Cad68a63D9C5c6EBE5461fe8fA774B60;\r\n    address internal constant rateQuoterAddress = 0xB7692BBC55C0a8B768E5b523d068B5552fbF7187;\r\n\r\n    // STEM minting params\r\n    uint32 internal constant mintStartBlock = 11565019; // Jan-01-2021 00:00:00 +UTC\r\n    uint32 internal constant mintBlocks = 9200000; // ~ 46 months\r\n    uint32 internal constant extraMintBlocks = 600000; // ~ 92 days\r\n\r\n    // STEM vesting pools\r\n    address internal constant rewardsPoolAddress = 0x99c0268759d26616AeC761c28336eccd72CCa39A;\r\n    address internal constant foundationPoolAddress = 0x30dDD235bEd94fdbCDc197513a638D6CAa261EC7;\r\n    address internal constant reservePoolAddress = 0xf8617006b4CD2db7385c1cb613885f1292e51b2e;\r\n    address internal constant marketPoolAddress = 0x256d986bc1d994C36f412b9ED8A269314bA93bc9;\r\n    address internal constant foundersPoolAddress = 0xd7Cc88bB603DceAFB5E8290d8188C8BF36fD742B;\r\n\r\n    // Min STEM vesting rewarded by `PollenDAO.updateRewardPool()`\r\n    uint256 internal constant minVestedStemRewarded = 2e4 * 1e18;\r\n\r\n    // Default voting terms\r\n    uint32 internal constant defaultVotingExpiryDelay = 12 * 3600;\r\n    uint32 internal constant defaultExecutionOpenDelay = 6 * 3600;\r\n    uint32 internal constant defaultExecutionExpiryDelay = 24 * 3600;\r\n}\r\n\r\n// File: contracts/interfaces/IPollenTypes.sol\r\n\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/// @dev Definition of common types\r\ninterface IPollenTypes {\r\n    /**\r\n    * @notice Type for representing a proposal type\r\n    */\r\n    enum ProposalType {Invest, Divest}\r\n\r\n    /**\r\n    * @notice If the proposal be executed at any or limited market rate\r\n    */\r\n    enum OrderType {Market, Limit}\r\n\r\n    /**\r\n    * @notice If the asset amount or Pollen amount is fixed\r\n    * (while the other amount will be updated according to the rate)\r\n    */\r\n    enum BaseCcyType {Asset, Pollen}\r\n\r\n    /**\r\n    * @notice Type for representing a token proposal status\r\n    */\r\n    enum ProposalStatus {Null, Submitted, Executed, Rejected, Passed, Pended, Expired}\r\n\r\n    /**\r\n    * @notice Type for representing the state of a vote on a proposal\r\n    */\r\n    enum VoterState {Null, VotedYes, VotedNo}\r\n\r\n    /**\r\n    * @notice Type for representing a token type\r\n    */\r\n    enum TokenType {ERC20}\r\n\r\n    enum RewardKind {ForVoting, ForProposal, ForExecution, ForStateUpdate, ForPlnHeld}\r\n\r\n    /// @dev Terms and parameters of a proposal\r\n    struct Proposal {\r\n        ProposalState state;\r\n        ProposalParams params;\r\n        ProposalTerms terms;\r\n    }\r\n\r\n    /// @dev Current (mutable) params of a proposal\r\n    struct ProposalState {\r\n        ProposalStatus status;\r\n        uint96 yesVotes;\r\n        uint96 noVotes;\r\n    }\r\n\r\n    /// @dev Derived terms (immutable params) of a proposal\r\n    struct ProposalParams {\r\n        uint32 votingOpen;\r\n        uint32 votingExpiry;\r\n        uint32 executionOpen;\r\n        uint32 executionExpiry;\r\n        uint32 snapshotId;\r\n        uint96 passVotes; // lowest bit used for `isExclPools` flag\r\n    }\r\n\r\n    /// @dev Original terms (immutable params) of a proposal\r\n    struct ProposalTerms {\r\n        ProposalType proposalType;\r\n        OrderType orderType;\r\n        BaseCcyType baseCcyType;\r\n        TokenType assetTokenType;\r\n        uint8 votingTermsId; // must be 0 (reserved for upgrades)\r\n        uint64 __reserved1; // reserved for upgrades\r\n        address submitter;\r\n        address executor;\r\n        uint96 __reserved2;\r\n        address assetTokenAddress;\r\n        uint96 pollenAmount;\r\n        uint256 assetTokenAmount;\r\n    }\r\n\r\n    /// @dev Data on user voting\r\n    struct VoteData {\r\n        VoterState state;\r\n        uint96 votesNum;\r\n    }\r\n\r\n    /// @dev Proposal execution details\r\n    struct Execution {\r\n        uint32 timestamp;\r\n        uint224 quoteCcyAmount;\r\n    }\r\n\r\n    /// @dev Voting terms\r\n    struct VotingTerms {\r\n        // If new proposals may be submitted with this terms\r\n        bool isEnabled;\r\n        // If Vesting Pools are excluded from voting and quorum\r\n        bool isExclPools;\r\n        // The quorum required to pass a proposal vote in % points\r\n        uint8 quorum;\r\n        // Seconds after proposal submission until voting expires\r\n        uint32 votingExpiryDelay;\r\n        // Seconds after proposal voting expires until execution opens\r\n        uint32 executionOpenDelay;\r\n        // Seconds after proposal execution opens until execution expires\r\n        uint32 executionExpiryDelay;\r\n    }\r\n\r\n    /// @dev \"Reward points\" for members' actions\r\n    struct RewardParams {\r\n        uint16 forVotingPoints;\r\n        uint16 forProposalPoints;\r\n        uint16 forExecutionPoints;\r\n        uint16 forStateUpdPoints;\r\n        uint16 forPlnDayPoints;\r\n        uint176 __reserved;\r\n    }\r\n\r\n    // @dev Data on rewards accruals for all members\r\n    struct RewardTotals {\r\n        uint32 lastAccumBlock;\r\n        uint112 accStemPerPoint;\r\n        uint112 totalPoints;\r\n    }\r\n\r\n    // @dev Data on a reward\r\n    struct Reward {\r\n        address member;\r\n        RewardKind kind;\r\n        uint256 points;\r\n    }\r\n\r\n    // @dev Data on rewards of a member\r\n    struct MemberRewards {\r\n        uint32 lastUpdateBlock;\r\n        uint64 points;\r\n        uint64 entitled;\r\n        uint96 adjustment;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IStemGrantor.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n/**\r\n* @title IPollenDAO Interface\r\n* @notice Interface for the Pollen DAO\r\n*/\r\ninterface IStemGrantor is IPollenTypes {\r\n\r\n    function getMemberPoints(address member) external view returns(uint256);\r\n\r\n    function getMemberRewards(address member) external view  returns(MemberRewards memory);\r\n\r\n    function getPendingStem(address member) external view returns(uint256);\r\n\r\n    function getRewardTotals() external view  returns(RewardTotals memory);\r\n\r\n    function withdrawRewards(address member) external;\r\n\r\n    event PointsRewarded(address indexed member, RewardKind indexed kind, uint256 points);\r\n\r\n    event RewardWithdrawal(address indexed member, uint256 amount);\r\n\r\n    event StemAllocation(uint256 amount);\r\n}\r\n\r\n// File: contracts/lib/SafeUint.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\nlibrary SafeUint {\r\n    function safe112(uint256 n) internal pure returns(uint112) {\r\n        require(n < 2**112, \"SafeUint:UNSAFE_UINT112\");\r\n        return uint112(n);\r\n    }\r\n\r\n    function safe96(uint256 n) internal pure returns(uint96) {\r\n        require(n < 2**96, \"SafeUint:UNSAFE_UINT96\");\r\n        return uint96(n);\r\n    }\r\n\r\n    function safe64(uint256 n) internal pure returns(uint64) {\r\n        require(n < 2**64, \"SafeUint:UNSAFE_UINT64\");\r\n        return uint64(n);\r\n    }\r\n\r\n    function safe32(uint256 n) internal pure returns(uint32) {\r\n        require(n < 2**32, \"SafeUint:UNSAFE_UINT32\");\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe16(uint256 n) internal pure returns(uint16) {\r\n        require(n < 2**16, \"SafeUint:UNSAFE_UINT16\");\r\n        return uint16(n);\r\n    }\r\n\r\n    function safe8(uint256 n) internal pure returns(uint8) {\r\n        require(n < 256, \"SafeUint:UNSAFE_UINT8\");\r\n        return uint8(n);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/PollenDAO/StemGrantor.sol\r\n\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title StemGrantor Contract\r\n* @notice STEM token reward distribution logic\r\n*/\r\nabstract contract StemGrantor is IStemGrantor {\r\n    using SafeMath for uint256;\r\n    using SafeUint for uint256;\r\n\r\n    /**\r\n    * @dev PollenDAO vests STEM tokens to the \"Reward pool\" for distribution between members\r\n    * as rewards for members' actions.\r\n    * Tokens distributed in proportion to accumulated \"reward points\" given to a member for\r\n    * actions. The contract vest STEM tokens to a member when the latest \"withdraws\" them.\r\n    *\r\n    * STEM amount pending to be vested to a member is calculated as:\r\n    *   pendingStem = alreadyEntitled + notYetEntitled                                    (3)\r\n    *   alreadyEntitled = memberRewards.entitled                                          (4)\r\n    *   notYetEntitled = forGivenPointsAmount - memberRewards.adjustment                  (5)\r\n    *   forGivenPointsAmount = memberRewards.points * _rewardTotals.accStemPerPoint       (6)\r\n    * ( memberRewards.entitled and _rewardTotals.accStemPerPoint are scaled for gas savings )\r\n    *\r\n    * Whenever some \"reward points\" are given to a member, the following happens:\r\n    * 1. If it's the 1st reward in the block, STEM for all members get minted to the contract;\r\n    * 2. `accStemPerPoint` gets updated (w/o yet accounting the new points - newly rewarded\r\n    * points MUST not affect STEM distributions for the past blocks);\r\n    * 2. STEM amount \"not yet entitled\" to the member up until now gets calculated;\r\n    * 3. \"pendingStem\" amount is calculated, the value is stored in `memberRewards.entitled`;\r\n    * 4. `memberRewards.points` gets increased by the newly rewarded \"points\" (affecting\r\n    * distributions in the future).\r\n    */\r\n\r\n    // Reserved for possible storage structure changes\r\n    uint256[50] private __gap;\r\n\r\n    // Totals for all members\r\n    RewardTotals private _rewardTotals;\r\n\r\n    // Mapping from member address to member rewards data\r\n    mapping(address => MemberRewards) private _membersRewards;\r\n\r\n    function getMemberPoints(address member) public view override returns(uint256)\r\n    {\r\n        return _membersRewards[member].points;\r\n    }\r\n\r\n    function getMemberRewards(\r\n        address member\r\n    ) external view  override returns(MemberRewards memory) {\r\n        return _membersRewards[member];\r\n    }\r\n\r\n    function getPendingStem(\r\n        address member\r\n    ) external view override returns(uint256 stemAmount)\r\n    {\r\n        MemberRewards memory memberRewards = _membersRewards[member];\r\n        if (memberRewards.points == 0 && memberRewards.entitled == 0 ) return 0;\r\n\r\n        uint256 pendingStem = _getPendingRewardStem();\r\n        RewardTotals memory forecastedTotals = _rewardTotals;\r\n        if (forecastedTotals.totalPoints != 0) {\r\n            _computeRewardTotals(forecastedTotals, 0, pendingStem, block.number);\r\n        }\r\n\r\n        stemAmount = _computeMemberRewards(\r\n            memberRewards,\r\n            forecastedTotals.accStemPerPoint,\r\n            0,\r\n            block.number\r\n        );\r\n    }\r\n\r\n    function getRewardTotals() external view  override returns(RewardTotals memory) {\r\n        return _rewardTotals;\r\n    }\r\n\r\n    function withdrawRewards(address member) external override\r\n    {\r\n        (uint256 accStemPerPoint, ) = _updateRewardTotals(0);\r\n\r\n        MemberRewards memory memberRewards = _membersRewards[member];\r\n        uint256 stemAmount = _computeMemberRewards(\r\n            memberRewards,\r\n            accStemPerPoint,\r\n            0,\r\n            block.number\r\n        );\r\n        require(stemAmount != 0, \"nothing to withdraw\");\r\n        _membersRewards[member] = memberRewards;\r\n\r\n        _sendStemTo(member, stemAmount);\r\n        emit RewardWithdrawal(member, stemAmount);\r\n    }\r\n\r\n    /**** Internal functions follow ****/\r\n\r\n    // Inheriting contract must implement following 3 functions\r\n    /// @dev Get amount of STEMs pending to be vested (sent) to the Rewards Pool\r\n    function _getPendingRewardStem() internal view virtual returns (uint256 amount);\r\n    /// @dev Withdraw pending STEMs to the Rewards Pool (once a block only)\r\n    function _withdrawRewardStem() internal virtual returns(uint256 amount);\r\n    /// @dev Send STEMs to a member (as a reward)\r\n    function _sendStemTo(address member, uint256 amount) internal virtual;\r\n\r\n    function _rewardMember(Reward memory reward) internal\r\n    {\r\n        (uint256 accStemPerPoint, bool isFirstGrant) = _updateRewardTotals(reward.points);\r\n        _bookReward(reward, accStemPerPoint, isFirstGrant);\r\n    }\r\n\r\n    function _rewardMembers(Reward[2] memory rewards) internal\r\n    {\r\n        uint256 totalPoints = rewards[0].points + rewards[1].points;\r\n        (uint256 accStemPerPoint, bool isFirstGrant) = _updateRewardTotals(totalPoints);\r\n        _bookReward(rewards[0], accStemPerPoint, isFirstGrant);\r\n        if (rewards[1].points != 0) {\r\n            _bookReward(rewards[1], accStemPerPoint, isFirstGrant);\r\n        }\r\n    }\r\n\r\n    /**** Private functions follow ****/\r\n\r\n    function _updateRewardTotals(\r\n        uint256 pointsToAdd\r\n    ) private returns (uint256 accStemPerPoint, bool isFirstGrant)\r\n    {\r\n        uint256 stemToAdd = 0;\r\n        RewardTotals memory totals = _rewardTotals;\r\n\r\n        uint256 blockNow = block.number;\r\n        {\r\n            bool isNeverGranted = totals.accStemPerPoint == 0;\r\n            bool isDistributable = (blockNow > totals.lastAccumBlock) && (// once a block\r\n                (totals.totalPoints != 0) || // there are points to distribute between\r\n                (isNeverGranted && pointsToAdd != 0) // it may be the 1st distribution\r\n            );\r\n            if (isDistributable) {\r\n                stemToAdd = _withdrawRewardStem();\r\n                if (stemToAdd != 0) emit StemAllocation(stemToAdd);\r\n            }\r\n        }\r\n\r\n        isFirstGrant = _computeRewardTotals(totals, pointsToAdd, stemToAdd, blockNow);\r\n        _rewardTotals = totals;\r\n        accStemPerPoint = totals.accStemPerPoint;\r\n    }\r\n\r\n    function _bookReward(Reward memory reward, uint256 accStemPerPoint, bool isFirstGrant)\r\n    private\r\n    {\r\n        MemberRewards memory memberRewards = _membersRewards[reward.member];\r\n\r\n        uint256 pointsToAdd = reward.points;\r\n        if (isFirstGrant) {\r\n            memberRewards.points = (pointsToAdd + memberRewards.points).safe64();\r\n            pointsToAdd = 0;\r\n        }\r\n\r\n        uint256 stemRewarded = _computeMemberRewards(\r\n            memberRewards,\r\n            accStemPerPoint,\r\n            pointsToAdd,\r\n            block.number\r\n        );\r\n        memberRewards.entitled = _stemToEntitledAmount(\r\n            stemRewarded,\r\n            uint256(memberRewards.entitled)\r\n        );\r\n        _membersRewards[reward.member] = memberRewards;\r\n\r\n        emit PointsRewarded(reward.member, reward.kind, reward.points);\r\n    }\r\n\r\n    // Made `internal` for testing (call it from this contract only)\r\n    function _computeRewardTotals(\r\n        RewardTotals memory totals,\r\n        uint256 pointsToAdd,\r\n        uint256 stemToAdd,\r\n        uint256 blockNow\r\n    ) internal pure returns(bool isFirstGrant)\r\n    {\r\n        // Make sure, this function is NEVER called:\r\n        // - for passed \"accumulated\" blocks\r\n        //  i.e. `require(blockNow >= totals.lastAccumBlock)`\r\n        // - to add STEM if no points have been yet rewarded\r\n        //  i.e. `require(stemToAdd == 0 || totals.totalPoints != 0)`\r\n        // - to add STEM for the 2nd time in a block ('pure|view' calls are OK)\r\n        //  i.e. `require(stemToAdd == 0 || blockNow > totals.lastAccumBlock)`\r\n\r\n        isFirstGrant = (totals.accStemPerPoint == 0) && (stemToAdd != 0);\r\n\r\n        uint256 oldPoints = totals.totalPoints;\r\n        if (pointsToAdd != 0) {\r\n            totals.totalPoints = pointsToAdd.add(totals.totalPoints).safe112();\r\n            if (isFirstGrant) oldPoints = pointsToAdd.add(oldPoints);\r\n        }\r\n\r\n        if (stemToAdd != 0) {\r\n            uint256 accStemPerPoint = uint256(totals.accStemPerPoint).add(\r\n                stemToAdd.mul(1e6).div(oldPoints) // divider can't be 0\r\n            );\r\n            totals.accStemPerPoint = accStemPerPoint.safe112();\r\n            totals.lastAccumBlock = blockNow.safe32();\r\n        }\r\n    }\r\n\r\n    // Made `internal` for testing (call it from this contract only)\r\n    function _computeMemberRewards(\r\n        MemberRewards memory memberRewards,\r\n        uint256 accStemPerPoint,\r\n        uint256 pointsToAdd,\r\n        uint256 blockNow\r\n    ) internal pure returns(uint256 stemAmount)\r\n    {\r\n        // Make sure, this function is NEVER called for \"past\" blocks\r\n        // i.e. `require(blockNow >= memberRewards.lastUpdateBlock)\r\n\r\n        stemAmount = _entitledAmountToStemAmount(memberRewards.entitled);\r\n        memberRewards.entitled = 0;\r\n        uint256 oldPoints = memberRewards.points;\r\n        if (pointsToAdd != 0) {\r\n            memberRewards.points = oldPoints.add(pointsToAdd).safe64();\r\n        }\r\n\r\n        memberRewards.lastUpdateBlock = blockNow.safe32();\r\n        if (oldPoints != 0) {\r\n            stemAmount = stemAmount.add(\r\n                (accStemPerPoint.mul(oldPoints) / 1e6)\r\n                .sub(memberRewards.adjustment)\r\n            );\r\n        }\r\n\r\n        memberRewards.adjustment = (\r\n            accStemPerPoint.mul(memberRewards.points) / 1e6\r\n        ).safe96();\r\n    }\r\n\r\n    function _entitledAmountToStemAmount(\r\n        uint64 entitled\r\n    ) private pure returns(uint256 stemAmount) {\r\n        stemAmount = uint256(entitled) * 1e6;\r\n    }\r\n\r\n    function _stemToEntitledAmount(\r\n        uint256 stemAmount,\r\n        uint256 prevEntitled\r\n    ) private pure returns(uint64 entitledAmount) {\r\n        uint256 _entitled = prevEntitled.add(stemAmount / 1e6);\r\n        // Max amount is limited by ~18.45e6 STEM tokens (for a member)\r\n        entitledAmount = _entitled < 2**64 ? uint64(_entitled) : 2*64 - 1;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IPollenDAO.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title IPollenDAO Interface\r\n* @notice Interface for the Pollen DAO\r\n*/\r\ninterface IPollenDAO is IPollenTypes, IStemGrantor {\r\n    /**\r\n    * @notice Returns the current version of the DAO\r\n    * @return The current version of the Pollen DAO\r\n    */\r\n    function version() external pure returns (string memory);\r\n\r\n    /**\r\n    * @notice Get the Pollen token (proxy) contract address\r\n    * @return The Pollen contract address\r\n    */\r\n    function getPollenAddress() external pure returns(address);\r\n\r\n    /**\r\n    * @notice Get the STEM token (proxy) contract address\r\n    * @return The STEM contract address\r\n    */\r\n    function getStemAddress() external pure returns(address);\r\n\r\n    /**\r\n    * @notice Get the address of the RateQuoter contract\r\n    * @return The RateQuoter (proxy) contract address\r\n    */\r\n    function getRateQuoterAddress() external pure returns(address);\r\n\r\n    /**\r\n    * @notice Get the price of PLN in ETH based on the price of assets held\r\n    * Example: 0.0004 (expressed in ETH/PLN)  ==>  2500 PLN = 1 ETH\r\n    * @return The price\r\n    */\r\n    function getPollenPrice() external returns(uint256);\r\n\r\n    /**\r\n    * @notice Get total proposal count\r\n    * @return The total proposal count\r\n    */\r\n    function getProposalCount() external view returns(uint256);\r\n\r\n    /**\r\n    * @notice Get terms, params and the state for a proposal\r\n    * @param proposalId The proposal ID\r\n    * @return terms The terms\r\n    * @return params The params\r\n    * @return descriptionCid The CId of the proposal description\r\n    */\r\n    function getProposal(uint256 proposalId) external view returns(\r\n        ProposalTerms memory terms,\r\n        ProposalParams memory params,\r\n        string memory descriptionCid\r\n    );\r\n\r\n    /**\r\n    * @notice Get the state for a proposal\r\n    * @param proposalId The proposal ID\r\n    * @return state The state\r\n    */\r\n    function getProposalState(uint256 proposalId) external view returns(\r\n        ProposalState memory state\r\n    );\r\n\r\n    /**\r\n    * @notice Get the state and number of votes of a voter on a specified proposal\r\n    * @param voter The voter address\r\n    * @param proposalId The proposal ID\r\n    * @return The state of the vote\r\n    */\r\n    function getVoteData(address voter, uint256 proposalId) external view returns(VoteData memory);\r\n\r\n    /**\r\n    * @notice Get the assets that the DAO holds\r\n    * @return The set of asset token addresses\r\n    */\r\n    function getAssets() external view returns (address[] memory);\r\n\r\n    /**\r\n    * @notice Get (a set of) voting terms\r\n    * @param termsId The ID of the voting terms\r\n    * @return The (set of) voting terms\r\n    */\r\n    function getVotingTerms(uint256 termsId) external view returns(VotingTerms memory);\r\n\r\n    /**\r\n    * @notice Submit a proposal\r\n    * @param proposalType The type of proposal (e.g., Invest, Divest)\r\n    * @param orderType The type of order (e.g., Market, Limit)\r\n    * @param baseCcyType The type of base currency (e.g., Asset, Pollen)\r\n    * @param termsId The voting terms ID\r\n    * @param assetTokenType The type of the asset token (e.g., ERC20)\r\n    * @param assetTokenAddress The address of the asset token\r\n    * @param assetTokenAmount The minimum (on invest) or exact (on divest) amount of the asset token to receive/pay\r\n    * @param pollenAmount The exact (on invest) or minimum (on divest) amount of Pollen to be paid/received\r\n    * @param executor The of the account that will execute the proposal (may be the same as msg.sender)\r\n    * @param descriptionCid The IPFS CId of the proposal description\r\n    */\r\n    function submit(\r\n        ProposalType proposalType,\r\n        OrderType orderType,\r\n        BaseCcyType baseCcyType,\r\n        uint256 termsId,\r\n        TokenType assetTokenType,\r\n        address assetTokenAddress,\r\n        uint256 assetTokenAmount,\r\n        uint256 pollenAmount,\r\n        address executor,\r\n        string memory descriptionCid\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Vote on a proposal\r\n    * @param proposalId The proposal ID\r\n    * @param vote The yes/no vote\r\n    */\r\n    function voteOn(uint256 proposalId, bool vote) external;\r\n\r\n    /**\r\n    * @notice Execute a proposal\r\n    * @param proposalId The proposal ID\r\n    * @param data If provided, the message sender is called -\r\n    * it must implement {IPollenCallee}\r\n    */\r\n    function execute(uint256 proposalId, bytes calldata data) external;\r\n\r\n    /**\r\n    * @notice Redeem Pollens for asset tokens\r\n    * @param pollenAmount The amount of Pollens to redeem\r\n    */\r\n    function redeem(uint256 pollenAmount) external;\r\n\r\n    /**\r\n    * @notice Update the status of a proposal (and get a reward, if updated)\r\n    * @param proposalId The ID of a proposal\r\n    */\r\n    function updateProposalStatus(uint256 proposalId) external;\r\n\r\n    /**\r\n    * @notice Update the Reward pool (and get a reward, if updated)\r\n    */\r\n    function updateRewardPool() external;\r\n\r\n    /**\r\n     * @notice Event emitted when an asset gets added to supported assets\r\n     */\r\n    event AssetAdded(address indexed asset);\r\n\r\n    /**\r\n     * @notice Event emitted when an asset gets removed from supported assets\r\n     */\r\n    event AssetRemoved(address indexed asset);\r\n\r\n    /**\r\n     * @notice Event emitted when a proposal is submitted\r\n     */\r\n    event Submitted(\r\n        uint256 proposalId,\r\n        ProposalType proposalType,\r\n        address submitter,\r\n        uint256 snapshotId\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when a proposal is voted on\r\n     */\r\n    event VotedOn(\r\n        uint256 proposalId,\r\n        address voter,\r\n        bool vote,\r\n        uint256 votes\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted each time the PLN price is quoted\r\n     */\r\n    event PollenPrice(uint256 price);\r\n\r\n    /**\r\n     * @notice Event emitted when a proposal is executed\r\n     * @param proposalId The proposal\r\n     * @param amount The amount of Pollen (on invest) or asset token (on divest)\r\n     */\r\n    event Executed(\r\n        uint256 proposalId,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when Pollens are redeemed\r\n     */\r\n    event Redeemed(\r\n        address sender,\r\n        uint256 pollenAmount\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when a proposal status gets changed\r\n     */\r\n    event StatusChanged(\r\n        uint proposalId,\r\n        ProposalStatus newStatus,\r\n        ProposalStatus oldStatus\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when (a set of) voting terms enabled or disabled\r\n     */\r\n    event VotingTermsSwitched(\r\n        uint256 termsId,\r\n        bool isEnabled\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when reward params get updated\r\n     */\r\n    event RewardParamsUpdated();\r\n\r\n    /**\r\n     * @notice Event emitted when new owner is set\r\n     */\r\n    event NewOwner(\r\n        address newOwner,\r\n        address oldOwner\r\n    );\r\n}\r\n\r\n// File: contracts/interfaces/IPollenDaoAdmin.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n\r\n\r\n/**\r\n* @title IPollenDAO Interface - administration functions\r\n* @notice Only the contract owner may call\r\n*/\r\ninterface IPollenDaoAdmin is IPollenTypes {\r\n    /**\r\n    * @notice Initializes a new Pollen instance (proxy)\r\n    * @dev May be run once only, the sender becomes the contract owner\r\n    */\r\n    function initialize() external;\r\n\r\n    /**\r\n    * @notice Set a new address to be the owner\r\n    * (only the owner may call)\r\n    * @param newOwner The address of the new owner\r\n    */\r\n    function setOwner(address newOwner) external;\r\n\r\n    /**\r\n    * @notice Add an asset to supported assets\r\n    * (only the owner may call)\r\n    * @param asset The address of the asset to be added\r\n    */\r\n    function addAsset(address asset) external;\r\n\r\n    /**\r\n    * @notice Remove an asset from supported assets\r\n    * (only the owner may call)\r\n    * @param asset The address of the asset to be removed\r\n    */\r\n    function removeAsset(address asset) external;\r\n\r\n    function addVotingTerms(VotingTerms memory terms) external;\r\n\r\n    function switchVotingTerms(uint256 termsId, bool isEnabled) external;\r\n\r\n    function updatePlnWhitelist(\r\n        address[] calldata accounts,\r\n        bool whitelisted\r\n    ) external;\r\n\r\n    function updateRewardParams(RewardParams memory _rewardParams) external;\r\n}\r\n\r\n// File: contracts/interfaces/IMintableBurnable.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/**\r\n* @title IMintableBurnable Interface - token minting/burning support\r\n*/\r\ninterface IMintableBurnable {\r\n\r\n    /**\r\n     * @dev Mints tokens to the owner account.\r\n     * Can only be called by the owner.\r\n     * @param amount The amount of tokens to mint\r\n     */\r\n    function mint(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     * @param amount The amount of tokens to mint\r\n     */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\r\n     * Requirements: the caller must have allowance for `accounts`'s tokens of at least `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/interfaces/IWhitelist.sol\r\n\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/**\r\n* @title PollenDAO Pre-release Whitelist\r\n* @notice A whitelist of users to prevent this release from being used on DEXs etc\r\n* @author Quantafire (James Key)\r\n*/\r\ninterface IWhitelist {\r\n\r\n    /**\r\n    * @notice Check if the address is whitelisted\r\n    * @param account Addresses to check\r\n    * @return Bool of whether _addr is whitelisted or not\r\n    */\r\n    function isWhitelisted(address account) external view returns (bool);\r\n\r\n    /**\r\n    * @notice Turn whitelisting on/off and add/remove whitelisted addresses.\r\n    * Only the owner of the contract may call.\r\n    * By default, whitelisting is disabled.\r\n    * To enable whitelisting, add zero address to whitelisted addresses:\r\n    * `updateWhitelist([address(0)], [true])`\r\n    * @param accounts Addresses to add or remove\r\n    * @param whitelisted `true` - to add, `false` - to remove addresses\r\n    */\r\n    function updateWhitelist(address[] calldata accounts, bool whitelisted) external;\r\n\r\n    event Whitelist(address addr, bool whitelisted);\r\n}\r\n\r\n// File: contracts/interfaces/openzeppelin/IOwnable.sol\r\n\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/**\r\n* @title Interface for `Ownable` (and `OwnableUpgradeSafe`) from the \"@openzeppelin\" package(s)\r\n*/\r\ninterface IOwnable {\r\n\r\n    /**\r\n     * @dev Emitted when the ownership is transferred from the `previousOwner` to the `newOwner`.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the owner.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner.\r\n     * Can only be called by the owner.\r\n     * It will not be possible to call `onlyOwner` functions anymore.\r\n     */\r\n    function renounceOwnership() external;\r\n}\r\n\r\n// File: contracts/interfaces/openzeppelin/ISnapshot.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/**\r\n* @title ISnapshot - snapshot-support extension from the \"@openzeppelin\" package(s)\r\n*/\r\ninterface ISnapshot {\r\n\r\n    /**\r\n     * @dev Emitted when a snapshot identified by `id` is created.\r\n     */\r\n    event Snapshot(uint256 id);\r\n\r\n    /**\r\n     * @dev Creates a new snapshot and returns its snapshot id.\r\n     * Can only be called by the owner.\r\n     */\r\n    function snapshot() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\r\n     */\r\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\r\n     */\r\n    function totalSupplyAt(uint256 snapshotId) external view returns(uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IPollen.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title IPollen token Interface\r\n*/\r\ninterface IPollen is IERC20, IOwnable, ISnapshot, IMintableBurnable, IWhitelist {\r\n    /**\r\n     * @notice Initializes the contract and sets the token name and symbol\r\n     * @dev Sets the contract `owner` account to the deploying account\r\n     */\r\n    function initialize(string memory name, string memory symbol) external;\r\n}\r\n\r\n// File: contracts/interfaces/IPollenCallee.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n/**\r\n* @title IPollenCallee Interface\r\n*/\r\ninterface IPollenCallee {\r\n    function onExecute(address sender, uint amountIn, uint amountOut, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/interfaces/IRateQuoter.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n/**\r\n* @title IRateQuoter Interface\r\n*/\r\ninterface IRateQuoter {\r\n\r\n    /// @dev Only \"Spot\" for now\r\n    enum RateTypes { Spot, Fixed }\r\n    /// @dev if a rate is quoted against USD or ETH\r\n    enum RateBase { Usd, Eth }\r\n    /**\r\n     * @dev if a rate is expressed in a number of ...\r\n     * the base currency units for one quoted currency unit (i.e. \"Direct\"),\r\n     * or the quoted currency units per one base currency unit (i.e. \"Indirect\")\r\n     */\r\n    enum QuoteType { Direct, Indirect }\r\n\r\n    struct PriceFeed {\r\n        address feed;\r\n        address asset;\r\n        RateBase base;\r\n        QuoteType side;\r\n        uint8 decimals;\r\n        uint16 maxDelaySecs;\r\n        // 0 - highest; default for now, as only one feed for an asset supported\r\n        uint8 priority;\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the contract and sets the token name and symbol.\r\n     * Registers the deployer as the contract `owner`. Can be called once only.\r\n     */\r\n    function initialize() external;\r\n\r\n    /**\r\n     * @dev Return the latest price of the given base asset against given quote asset\r\n     * from a highest priority possible feed, direct quotes (ETH/asset), default decimals\r\n     * (it reverts if the rate is older then the RATE_DELAY_MAX_SECS)\r\n     */\r\n    function quotePrice(address asset) external returns (uint256 rate, uint256 updatedAt);\r\n\r\n    /**\r\n    * @dev\r\n    */\r\n    function getPriceFeedData(address asset) external view returns (PriceFeed memory);\r\n\r\n    /**\r\n    * @dev\r\n    */\r\n    function addPriceFeed(PriceFeed memory priceFeed) external;\r\n\r\n    /**\r\n    * @dev\r\n    */\r\n    function addPriceFeeds(PriceFeed[] memory priceFeeds) external;\r\n\r\n    /**\r\n    * @dev\r\n    */\r\n    function removePriceFeed(address feed) external;\r\n\r\n    event PriceFeedAdded(address indexed asset, address feed);\r\n    event PriceFeedRemoved(address asset);\r\n\r\n    // TODO: Extend the IRateQuoter to support the following specs\r\n    // function quotePriceExtended(\r\n    //    address base,\r\n    //    address quote,\r\n    //    address feed,\r\n    //    RateBase base,\r\n    //    QuoteType side,\r\n    //    uint256 decimals,\r\n    //    uint256 maxDelay,\r\n    //    bool forceUpdate\r\n    // ) external returns (uint256 rate, uint256 timestamp);\r\n}\r\n\r\n// File: contracts/interfaces/IStemVesting.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n\r\n/**\r\n* @title STEM token Interface\r\n*/\r\ninterface IStemVesting {\r\n\r\n    /// @dev Params of a vesting pool\r\n    struct StemVestingPool {\r\n        bool isRestricted; // if `true`, the 'wallet' only may trigger withdrawal\r\n        uint32 startBlock;\r\n        uint32 endBlock;\r\n        uint32 lastVestedBlock;\r\n        uint128 perBlockStemScaled; // scaled (multiplied) by 1e6\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the contract, sets the token name and symbol, creates vesting pools\r\n     * @param foundationWallet The foundation wallet\r\n     * @param reserveWallet The reserve wallet\r\n     * @param foundersWallet The founders wallet\r\n     * @param marketWallet The market wallet\r\n     */\r\n    function initialize(\r\n        address foundationWallet,\r\n        address reserveWallet,\r\n        address foundersWallet,\r\n        address marketWallet\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns params of a vesting pool\r\n     * @param wallet The address of the pool' wallet\r\n     * @return Vesting pool params\r\n     */\r\n    function getVestingPoolParams(address wallet) external view returns(StemVestingPool memory);\r\n\r\n    /**\r\n     * @notice Returns the amount of STEM pending to be vested to a pool\r\n     * @param wallet The address of the pool' wallet\r\n     * @return amount Pending STEM token amount\r\n     */\r\n    function getPoolPendingStem(address wallet) external view returns(uint256 amount);\r\n\r\n    /**\r\n     * @notice Withdraw pending STEM tokens to a pool\r\n     * @param wallet The address of the pool' wallet\r\n     * @return amount Withdrawn STEM token amount\r\n     */\r\n    function withdrawPoolStem(address wallet) external returns (uint256 amount);\r\n\r\n    /// @dev New vesting pool registered\r\n    event VestingPool(address indexed wallet);\r\n    /// @dev STEM tokens mint to a pool\r\n    event StemWithdrawal(address indexed wallet, uint256 amount);\r\n}\r\n\r\n// File: contracts/lib/AddressSet.sol\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n/**\r\n* @title AddressSet Library\r\n* @notice Library for representing a set of addresses\r\n* @author gtlewis\r\n*/\r\nlibrary AddressSet {\r\n    /**\r\n    * @notice Type for representing a set of addresses\r\n    * @member elements The elements of the set, contains address 0x0 for deleted elements\r\n    * @member indexes A mapping of the address to the index in the set, counted from 1 (rather than 0)\r\n    */\r\n    struct Set {\r\n        address[] elements;\r\n        mapping(address => uint256) indexes;\r\n    }\r\n\r\n    /**\r\n    * @notice Add an element to the set (internal)\r\n    * @param self The set\r\n    * @param value The element to add\r\n    * @return False if the element is already in the set or is address 0x0\r\n    */\r\n    function add(Set storage self, address value) internal returns (bool)\r\n    {\r\n        if (self.indexes[value] != 0 || value == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        self.elements.push(value);\r\n        self.indexes[value] = self.elements.length;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove an element from the set (internal)\r\n    * @param self The set\r\n    * @param value The element to remove\r\n    * @return False if the element is not in the set\r\n    */\r\n    function remove(Set storage self, address value) internal returns (bool)\r\n    {\r\n        if (self.indexes[value] == 0) {\r\n            return false;\r\n        }\r\n\r\n        delete(self.elements[self.indexes[value] - 1]);\r\n        self.indexes[value] = 0;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns true if an element is in the set (internal view)\r\n    * @param self The set\r\n    * @param value The element\r\n    * @return True if the element is in the set\r\n    */\r\n    function contains(Set storage self, address value) internal view returns (bool)\r\n    {\r\n        return self.indexes[value] != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeMath96.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMath96 {\r\n\r\n    function add(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function add(uint96 a, uint96 b) internal pure returns (uint96) {\r\n        return add(a, b, \"SafeMath96: addition overflow\");\r\n    }\r\n\r\n    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function sub(uint96 a, uint96 b) internal pure returns (uint96) {\r\n        return sub(a, b, \"SafeMath96: subtraction overflow\");\r\n    }\r\n\r\n    function fromUint(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function fromUint(uint n) internal pure returns (uint96) {\r\n        return fromUint(n, \"SafeMath96: exceeds 96 bits\");\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeMath32.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMath32 {\r\n\r\n    function add(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return add(a, b, \"SafeMath32: addition overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return sub(a, b, \"SafeMath32: subtraction overflow\");\r\n    }\r\n\r\n    function fromUint(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function fromUint(uint n) internal pure returns (uint32) {\r\n        return fromUint(n, \"SafeMath32: exceeds 32 bits\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuardUpgradeSafe is Initializable {\r\n    bool private _notEntered;\r\n\r\n\r\n    function __ReentrancyGuard_init() internal initializer {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal initializer {\r\n\r\n\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: contracts/PollenDAO_v1.sol\r\n\r\n\r\npragma solidity >=0.6 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title PollenDAO Contract\r\n* @notice The main Pollen DAO contract\r\n*/\r\ncontract PollenDAO_v1 is\r\n    Initializable,\r\n    ReentrancyGuardUpgradeSafe,\r\n    PollenParams,\r\n    StemGrantor,\r\n    IPollenDAO,\r\n    IPollenDaoAdmin\r\n{\r\n    using AddressSet for AddressSet.Set;\r\n    using SafeMath for uint256;\r\n    using SafeUint for uint256;\r\n    using SafeMath96 for uint96;\r\n    using SafeMath32 for uint32;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Price of PLN for the 1st proposal, in ETH/PLN with 18 decimals\r\n    uint256 internal constant plnInitialRate = 400e12; // 1ETH = 2500 PLN\r\n\r\n    // \"Points\" for rewarding members (with STEM) for actions\r\n    uint16 internal constant forVotingDefaultPoints = 100;\r\n    uint16 internal constant forProposalDefaultPoints = 300;\r\n    uint16 internal constant forExecutionDefaultPoints = 500;\r\n    uint16 internal constant forStateUpdDefaultPoints = 10;\r\n    uint16 internal constant forPlnDayDefaultPoints = 5;\r\n    // TODO: implement maxForSingleMemberSharePercents limit\r\n    uint16 internal constant maxForSingleMemberSharePercents = 20;\r\n\r\n    // Default voting terms (see more in `PollenParams.sol`)\r\n    uint8 internal constant defaultQuorum = 30;\r\n\r\n    // Min and max allowed delays for voting terms\r\n    uint256 internal constant minDelay = 60;\r\n    uint256 internal constant maxDelay = 3600 * 24 * 365;\r\n\r\n    // Reserved for possible storage structure changes\r\n    uint256[50] private __gap;\r\n\r\n    // The contract owner\r\n    address private _owner;\r\n\r\n    // The count of proposals\r\n    uint32 private _proposalCount;\r\n\r\n    // Number of voting terms sets\r\n    uint16 private _votingTermsNum;\r\n\r\n    // The set of assets that the DAO holds\r\n    AddressSet.Set private _assets;\r\n\r\n    /// @notice Member activity rewards params\r\n    RewardParams public rewardParams;\r\n\r\n    // mapping from voting terms ID to voting terms data\r\n    mapping(uint256 => VotingTerms) internal _votingTerms;\r\n\r\n    // Mapping from proposal ID to proposal data\r\n    mapping(uint256 => Proposal) internal _proposals;\r\n\r\n    /// @dev Mapping from proposal ID to description content Id\r\n    mapping(uint256 => string) private _descriptionCids;\r\n\r\n    // Mapping from proposal ID to proposal execution data\r\n    mapping(uint256 => Execution) private _executions;\r\n\r\n    // Mapping from member address and proposal ID to voting data\r\n    mapping(address => mapping(uint256 => VoteData)) private _voteData;\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"PollenDAO: unauthorised call\");\r\n        _;\r\n    }\r\n\r\n    modifier revertZeroAddress(address _address) {\r\n        require(_address != address(0), \"PollenDAO: invalid address\");\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function initialize() external override initializer {\r\n        __ReentrancyGuard_init_unchained();\r\n        _owner = msg.sender;\r\n        _addVotingTerms(\r\n            VotingTerms(\r\n                true, // is enabled\r\n                true, // do not count vesting pools' votes\r\n                defaultQuorum,\r\n                defaultVotingExpiryDelay,\r\n                defaultExecutionOpenDelay,\r\n                defaultExecutionExpiryDelay\r\n            )\r\n        );\r\n        _initRewardParams(\r\n            RewardParams(\r\n                forVotingDefaultPoints,\r\n                forProposalDefaultPoints,\r\n                forExecutionDefaultPoints,\r\n                forStateUpdDefaultPoints,\r\n                forPlnDayDefaultPoints,\r\n                0 // reserved\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function version() external pure override returns (string memory) {\r\n        return \"v1\";\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getPollenAddress() external pure override returns(address) {\r\n        return address(_plnAddress());\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getStemAddress() external pure override returns(address) {\r\n        return _stemAddress();\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getRateQuoterAddress() external pure override returns(address) {\r\n        return _rateQuoterAddress();\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getPollenPrice() public override returns(uint256) {\r\n        return _getPollenPrice();\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getProposalCount() external view override returns(uint256) {\r\n        return _proposalCount;\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getProposal(uint proposalId) external view override returns (\r\n        ProposalTerms memory terms,\r\n        ProposalParams memory params,\r\n        string memory descriptionCid\r\n    ) {\r\n        _validateProposalId(proposalId);\r\n        terms = _proposals[proposalId].terms;\r\n        params = _proposals[proposalId].params;\r\n        descriptionCid = _descriptionCids[proposalId];\r\n    }\r\n\r\n    function getProposalState(\r\n        uint256 proposalId\r\n    ) external view override returns(ProposalState memory state) {\r\n        _validateProposalId(proposalId);\r\n        state = _proposals[proposalId].state;\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getVoteData(\r\n        address voter,\r\n        uint256 proposalId\r\n    ) external view override returns(VoteData memory) {\r\n        _validateProposalId(proposalId);\r\n        return (_voteData[voter][proposalId]);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getAssets() external view override returns (address[] memory) {\r\n        return _assets.elements;\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function getVotingTerms(\r\n        uint256 termsId\r\n    ) external view override returns(VotingTerms memory) {\r\n        return _getTermSheet(termsId);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function submit(\r\n        ProposalType proposalType,\r\n        OrderType orderType,\r\n        BaseCcyType baseCcyType,\r\n        uint256 termsId,\r\n        TokenType assetTokenType,\r\n        address assetTokenAddress,\r\n        uint256 assetTokenAmount,\r\n        uint256 pollenAmount,\r\n        address executor,\r\n        string memory descriptionCid\r\n    ) external override revertZeroAddress(assetTokenAddress) {\r\n        require(\r\n            IWhitelist(_plnAddress()).isWhitelisted(msg.sender),\r\n            \"PollenDAO: unauthorized\"\r\n        );\r\n        require(proposalType <= ProposalType.Divest, \"PollenDAO: invalid proposal type\");\r\n        require(orderType <= OrderType.Limit, \"PollenDAO: invalid order type\");\r\n        require(baseCcyType <= BaseCcyType.Pollen, \"PollenDAO: invalid base ccy type\");\r\n        require(assetTokenType == TokenType.ERC20, \"PollenDAO: invalid asset type\");\r\n        require(_assets.contains(assetTokenAddress), \"PollenDAO: unsupported asset\");\r\n        require(executor != address(0), \"PollenDAO: invalid executor\");\r\n        {\r\n            bool isAssetFixed = baseCcyType == BaseCcyType.Asset;\r\n            bool isMarket = orderType == OrderType.Market;\r\n            require(\r\n                isAssetFixed ? assetTokenAmount != 0 : pollenAmount != 0,\r\n                \"PollenDAO: zero base amount\"\r\n            );\r\n            require(\r\n                isMarket || (isAssetFixed ? pollenAmount != 0 : assetTokenAmount != 0),\r\n                \"PollenDAO: invalid quoted amount\"\r\n            );\r\n        }\r\n\r\n        uint256 proposalId = _proposalCount;\r\n        _proposalCount = (proposalId + 1).safe32();\r\n\r\n        _proposals[proposalId].terms = ProposalTerms(\r\n            proposalType,\r\n            orderType,\r\n            baseCcyType,\r\n            assetTokenType,\r\n            termsId.safe8(),\r\n            0, // reserved\r\n            msg.sender,\r\n            executor,\r\n            0, // reserved\r\n            assetTokenAddress,\r\n            pollenAmount.safe96(),\r\n            assetTokenAmount\r\n        );\r\n        _descriptionCids[proposalId] = descriptionCid;\r\n\r\n        uint256 snapshotId = 0;\r\n\r\n        if (proposalId == 0) {\r\n            uint32 expiry = now.safe32();\r\n            _proposals[proposalId].params = ProposalParams(\r\n                expiry,     // voting open\r\n                expiry,     // voting expiry\r\n                expiry,     // exec open\r\n                expiry.add( // exec expiry\r\n                    defaultExecutionExpiryDelay\r\n                ),\r\n                uint32(snapshotId),\r\n                0           // no voting (zero passVotes)\r\n            );\r\n            _proposals[proposalId].state = ProposalState(ProposalStatus.Passed, 0, 0);\r\n        } else {\r\n            VotingTerms memory terms = _getTermSheet(termsId);\r\n            require(terms.isEnabled, \"PollenDAO: disabled terms\");\r\n            uint32 votingOpen = now.safe32();\r\n            uint32 votingExpiry = votingOpen.add(terms.votingExpiryDelay);\r\n            uint32 execOpen = votingExpiry.add(terms.executionOpenDelay);\r\n            uint32 execExpiry = execOpen.add(terms.executionExpiryDelay);\r\n\r\n            uint256 totalVotes;\r\n            (snapshotId, totalVotes) = _takeSnapshot(terms.isExclPools);\r\n            // The lowest bit encodes `terms.isExclPools` flag\r\n            uint256 passVotes = (totalVotes.mul(terms.quorum) / 100) | 1;\r\n            if (!terms.isExclPools) passVotes -= 1; // even, if pools included\r\n\r\n            ProposalParams memory params = ProposalParams(\r\n                votingOpen,\r\n                votingExpiry,\r\n                execOpen,\r\n                execExpiry,\r\n                snapshotId.safe32(),\r\n                passVotes.safe96()\r\n            );\r\n            _proposals[proposalId].params = params;\r\n            _proposals[proposalId].state = ProposalState(ProposalStatus.Submitted, 0, 0);\r\n\r\n            uint256 senderVotes = _getVotesOfAt(msg.sender, snapshotId);\r\n            if (senderVotes != 0) {\r\n                _doVoteAndReward(proposalId, params, msg.sender, true, senderVotes);\r\n            }\r\n        }\r\n\r\n        emit Submitted(proposalId, proposalType, msg.sender, snapshotId);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function voteOn(uint256 proposalId, bool vote) external override {\r\n        _validateProposalId(proposalId);\r\n        (ProposalStatus newStatus, ) = _updateProposalStatus(proposalId, ProposalStatus.Null);\r\n        _revertWrongStatus(newStatus, ProposalStatus.Submitted);\r\n\r\n        uint256 newVotes = _getVotesOfAt(msg.sender, _proposals[proposalId].params.snapshotId);\r\n        require(newVotes != 0, \"PollenDAO: no votes to vote with\");\r\n\r\n       _doVoteAndReward(proposalId, _proposals[proposalId].params, msg.sender, vote, newVotes);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function execute(uint256 proposalId, bytes calldata data) external override nonReentrant {\r\n        _validateProposalId(proposalId);\r\n\r\n        ProposalTerms memory terms = _proposals[proposalId].terms;\r\n        require(terms.executor == msg.sender, \"PollenDAO: unauthorized executor\");\r\n\r\n        (ProposalStatus newStatus,  ) = _updateProposalStatus(proposalId, ProposalStatus.Null);\r\n        _revertWrongStatus(newStatus, ProposalStatus.Pended);\r\n\r\n        IPollen pollen = IPollen(_plnAddress());\r\n        uint256 pollenAmount;\r\n        uint256 assetAmount;\r\n        bool isPollenFixed = terms.baseCcyType == BaseCcyType.Pollen;\r\n        {\r\n            IRateQuoter rateQuoter = IRateQuoter(_rateQuoterAddress());\r\n            // Ex.: assetRate = 0.001 ETH/DAI\r\n            // (i.e., `ethers = assetAmount * assetRate`: 1 ETH = 1000 DAI * 0.001 ETH/DAI)\r\n            (uint256 assetRate, ) = rateQuoter.quotePrice(terms.assetTokenAddress);\r\n            // Ex.: plnRate   = 0.0004 ETH/PLN\r\n            // (i.e., `ethers = plnAmount * plnRate`: 1 ETH = 2500 PLN * 0.0004 ETH/PLN)\r\n            uint256 plnRate = _getPollenPrice();\r\n\r\n            if (isPollenFixed) {\r\n                pollenAmount = terms.pollenAmount;\r\n                // Ex.: 2 DAI = 5 PLN * 0.0004 ETH/PLN / 0.001 ETH/DAI\r\n                assetAmount = pollenAmount.mul(plnRate).div(assetRate);\r\n            } else {\r\n                assetAmount = terms.assetTokenAmount;\r\n                // Ex.: 5 PLN = 2 DAI * 0.001 ETH/DAI / 0.0004 ETH/PLN\r\n                pollenAmount = assetAmount.mul(assetRate).div(plnRate);\r\n            }\r\n        }\r\n\r\n        bool isLimitOrder = terms.orderType == OrderType.Limit;\r\n        if (terms.proposalType == ProposalType.Invest) {\r\n            if (isLimitOrder) {\r\n                if (isPollenFixed) {\r\n                    if (terms.assetTokenAmount > assetAmount)\r\n                        assetAmount = terms.assetTokenAmount;\r\n                } else {\r\n                    if (terms.pollenAmount < pollenAmount)\r\n                        pollenAmount = terms.pollenAmount;\r\n                }\r\n            }\r\n\r\n            // OK to send Pollen first as long as the asset received in the end\r\n            pollen.mint(pollenAmount);\r\n            pollen.transfer(msg.sender, pollenAmount);\r\n\r\n            if (data.length > 0) {\r\n                IPollenCallee(msg.sender).onExecute(msg.sender, assetAmount, pollenAmount, data);\r\n            }\r\n\r\n            IERC20(terms.assetTokenAddress)\r\n            .safeTransferFrom(msg.sender, address(this), assetAmount);\r\n        }\r\n        else if (terms.proposalType == ProposalType.Divest) {\r\n            if (isLimitOrder) {\r\n                if (isPollenFixed) {\r\n                    if (terms.assetTokenAmount < assetAmount)\r\n                        assetAmount = terms.assetTokenAmount;\r\n                } else {\r\n                    if (terms.pollenAmount > pollenAmount)\r\n                        pollenAmount = terms.pollenAmount;\r\n                }\r\n            }\r\n\r\n            // OK to send assets first as long as Pollen burnt in the end\r\n            IERC20(terms.assetTokenAddress).safeTransfer(msg.sender, assetAmount);\r\n\r\n            if (data.length > 0) {\r\n                IPollenCallee(msg.sender).onExecute(msg.sender, pollenAmount, assetAmount, data);\r\n            }\r\n\r\n            pollen.burnFrom(msg.sender, pollenAmount);\r\n        } else {\r\n            revert(\"unsupported proposal type\");\r\n        }\r\n\r\n        uint256 quotedAmount = isPollenFixed ? assetAmount : pollenAmount;\r\n\r\n        _executions[proposalId] = Execution(uint32(block.timestamp), uint224(quotedAmount));\r\n        _updateProposalStatus(proposalId, ProposalStatus.Executed);\r\n\r\n        emit Executed(proposalId, quotedAmount);\r\n\r\n        {\r\n            RewardParams memory p = rewardParams;\r\n            Reward[2] memory rewards;\r\n            rewards[0] = Reward(terms.submitter, RewardKind.ForProposal, p.forProposalPoints);\r\n            rewards[1] = Reward(msg.sender, RewardKind.ForExecution, p.forExecutionPoints);\r\n            _rewardMembers(rewards);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function redeem(uint256 pollenAmount) external override nonReentrant {\r\n        require(pollenAmount != 0, \"PollenDAO: can't redeem zero\");\r\n\r\n        IPollen pollen = IPollen(_plnAddress());\r\n        uint256 totalSupply = pollen.totalSupply();\r\n        pollen.burnFrom(msg.sender, pollenAmount);\r\n\r\n        // unbounded loop ignored\r\n        for (uint256 i=0; i < _assets.elements.length; i++) {\r\n            IERC20 asset = IERC20(_assets.elements[i]);\r\n            if (address(asset) != address(0)) {\r\n                uint256 assetBalance = asset.balanceOf(address(this));\r\n                if (assetBalance == 0) {\r\n                    continue;\r\n                }\r\n                uint256 assetAmount = assetBalance.mul(pollenAmount).div(totalSupply);\r\n                asset.transfer(\r\n                    msg.sender,\r\n                    assetAmount > assetBalance ? assetBalance : assetAmount\r\n                );\r\n            }\r\n        }\r\n\r\n        emit Redeemed(\r\n            msg.sender,\r\n            pollenAmount\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function updateProposalStatus(uint256 proposalId) external override {\r\n        (ProposalStatus newStatus,  ProposalStatus oldStatus) = _updateProposalStatus(\r\n            proposalId,\r\n            ProposalStatus.Null\r\n        );\r\n        if (oldStatus != newStatus) {\r\n            RewardParams memory params = rewardParams;\r\n            _rewardMember(Reward(msg.sender, RewardKind.ForStateUpdate, params.forStateUpdPoints));\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPollenDAO\r\n    function updateRewardPool() external override nonReentrant {\r\n        uint256 pendingStem = IStemVesting(_stemAddress()).getPoolPendingStem(address(this));\r\n        if (pendingStem >= minVestedStemRewarded) {\r\n            RewardParams memory params = rewardParams;\r\n            _rewardMember(Reward(msg.sender, RewardKind.ForStateUpdate, params.forStateUpdPoints));\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function setOwner(address newOwner) external override onlyOwner revertZeroAddress(newOwner) {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit NewOwner(newOwner, oldOwner);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function addAsset(address asset) external override onlyOwner revertZeroAddress(asset) {\r\n        require(!_assets.contains(asset), \"PollenDAO: already added\");\r\n        require(_assets.add(asset));\r\n        emit AssetAdded(asset);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function removeAsset(address asset) external override onlyOwner revertZeroAddress(asset) {\r\n        require(_assets.contains(asset), \"PollenDAO: unknown asset\");\r\n        require(IERC20(asset).balanceOf(address(this)) == 0, \"PollenDAO: asset has balance\");\r\n        require(_assets.remove(asset));\r\n        emit AssetRemoved(asset);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function addVotingTerms(VotingTerms memory terms) external override onlyOwner {\r\n        _addVotingTerms(terms);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function switchVotingTerms(\r\n        uint256 termsId,\r\n        bool isEnabled\r\n    ) external override onlyOwner {\r\n        require(termsId < _votingTermsNum, \"PollenDAO: invalid termsId\");\r\n        _votingTerms[termsId].isEnabled =  isEnabled;\r\n        emit VotingTermsSwitched(termsId, isEnabled);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function updatePlnWhitelist(\r\n        address[] calldata accounts,\r\n        bool whitelisted\r\n    ) external override onlyOwner {\r\n        IWhitelist(_plnAddress()).updateWhitelist(accounts, whitelisted);\r\n    }\r\n\r\n    /// @inheritdoc IPollenDaoAdmin\r\n    function updateRewardParams(RewardParams memory _rewardParams) external override onlyOwner\r\n    {\r\n        _initRewardParams(_rewardParams);\r\n    }\r\n\r\n    function preventUseWithoutProxy() external initializer {\r\n        // Prevent using the contract w/o the proxy (potentially abusing)\r\n        // To be called on the \"implementation\", not on the \"proxy\"\r\n        // Does not revert the first call only\r\n    }\r\n\r\n    function _addVotingTerms(VotingTerms memory t) internal returns(uint termsId) {\r\n        require(t.quorum <= 100, \"PollenDAO: invalid quorum\");\r\n        require(\r\n            t.votingExpiryDelay > minDelay &&\r\n            t.executionOpenDelay > minDelay &&\r\n            t.executionExpiryDelay > minDelay &&\r\n            t.votingExpiryDelay < maxDelay &&\r\n            t.executionOpenDelay < maxDelay &&\r\n            t.executionExpiryDelay < maxDelay,\r\n            \"PollenDAO: invalid delays\"\r\n        );\r\n        termsId = _votingTermsNum;\r\n        _votingTerms[termsId] = t;\r\n        _votingTermsNum = uint16(termsId) + 1;\r\n        emit VotingTermsSwitched(termsId, t.isEnabled);\r\n    }\r\n\r\n    function _initRewardParams(RewardParams memory _rewardParams) internal {\r\n        rewardParams = _rewardParams;\r\n        emit RewardParamsUpdated();\r\n    }\r\n\r\n    function _updateProposalStatus(\r\n        uint256 proposalId,\r\n        ProposalStatus knownNewStatus\r\n    ) internal returns(ProposalStatus newStatus, ProposalStatus oldStatus)\r\n    {\r\n        ProposalState memory state = _proposals[proposalId].state;\r\n        oldStatus = state.status;\r\n        if (knownNewStatus != ProposalStatus.Null) {\r\n            newStatus = knownNewStatus;\r\n        } else {\r\n            ProposalParams memory params = _proposals[proposalId].params;\r\n            newStatus = _computeProposalStatus(state, params, now);\r\n        }\r\n        if (oldStatus != newStatus) {\r\n            _proposals[proposalId].state.status = newStatus;\r\n            emit StatusChanged(proposalId, newStatus, oldStatus);\r\n        }\r\n    }\r\n\r\n    function _computeProposalStatus(\r\n        ProposalState memory state,\r\n        ProposalParams memory params,\r\n        uint256 timeNow\r\n    ) internal pure returns (ProposalStatus) {\r\n        /*\r\n         * Possible proposal status transitions:\r\n         *\r\n         *      +-------------=>Passed-----+  // 1st proposal only\r\n         *      |                          |\r\n         * Null-+=>Submitted-+->Passed-----+->Pended----+=>Executed(end)\r\n         *                   |             |            |\r\n         *                   +->Rejected   +->Expired   +->Expired\r\n         *                   |\r\n         *                   +->Expired\r\n         *\r\n         * Transitions triggered by this function:\r\n         * - Submitted->(Passed || Rejected || Expired)\r\n         * - Passed->(Pended || Expired)\r\n         * - Pended->Expired\r\n         *\r\n         * Transitions triggered by other functions:\r\n         * - Null=>Passed , for the 1st proposal only, - by the function `submit`\r\n         * - Null=>Submitted, except for the 1st proposal - by the function `submit`\r\n         * - Pended=>Executed - by the function `execute`\r\n         */\r\n\r\n        ProposalStatus curStatus = state.status;\r\n\r\n        if (\r\n            curStatus == ProposalStatus.Submitted &&\r\n            timeNow >= params.votingExpiry\r\n        ) {\r\n            if (\r\n                (state.yesVotes > state.noVotes) &&\r\n                (state.yesVotes >= params.passVotes)\r\n            ) {\r\n                curStatus = ProposalStatus.Passed;\r\n            } else {\r\n                return ProposalStatus.Rejected;\r\n            }\r\n        }\r\n\r\n        if (curStatus == ProposalStatus.Passed) {\r\n            if (timeNow >= params.executionExpiry) return ProposalStatus.Expired;\r\n            if (timeNow >= params.executionOpen) return ProposalStatus.Pended;\r\n        }\r\n\r\n        if (\r\n            curStatus == ProposalStatus.Pended &&\r\n            timeNow >= params.executionExpiry\r\n        ) return ProposalStatus.Expired;\r\n\r\n        return curStatus;\r\n    }\r\n\r\n    function _doVoteAndReward(\r\n        uint256 proposalId,\r\n        ProposalParams memory params,\r\n        address voter,\r\n        bool vote,\r\n        uint256 numOfVotes\r\n    )\r\n    private {\r\n        bool isExclPools = (params.passVotes & 1) == 1;\r\n        if (isExclPools) _revertOnPool(voter);\r\n\r\n        bool isNewVote = _addVote(proposalId, voter, vote, numOfVotes);\r\n        if (!isNewVote) return;\r\n\r\n        RewardParams memory p = rewardParams;\r\n        Reward[2] memory rewards;\r\n        rewards[0] = Reward(voter, RewardKind.ForVoting, p.forVotingPoints);\r\n\r\n        if (proposalId != 0 && p.forPlnDayPoints != 0) {\r\n            uint256 plnBalance = _getPlnBalanceAt(voter, params.snapshotId);\r\n            uint256 secs = params.votingOpen - _proposals[proposalId - 1].params.votingOpen;\r\n            uint256 points = plnBalance.mul(p.forPlnDayPoints)\r\n                .mul(secs)\r\n                .div(86400) // per day\r\n                .div(1e18); // PLN decimals\r\n            rewards[1] = Reward(voter, RewardKind.ForPlnHeld, points);\r\n        }\r\n\r\n        _rewardMembers(rewards);\r\n    }\r\n\r\n    /**\r\n    * @dev _addVote (private)\r\n    * @param proposalId The proposal ID\r\n    * @param voter The voter address\r\n    * @param vote The yes/no vote\r\n    * @param numOfVotes The number of votes\r\n    */\r\n    function _addVote(uint256 proposalId, address voter, bool vote, uint256 numOfVotes)\r\n    private\r\n    returns(bool isNewVote)\r\n    {\r\n        ProposalState memory proposalState = _proposals[proposalId].state;\r\n\r\n        // if voter had already voted on the proposal, and if so what his vote was.\r\n        VoteData memory prevVote =  _voteData[voter][proposalId];\r\n        isNewVote = prevVote.state == VoterState.Null;\r\n\r\n        // allows to change previous vote\r\n        if (prevVote.state == VoterState.VotedYes) {\r\n            proposalState.yesVotes = proposalState.yesVotes.sub(prevVote.votesNum);\r\n        } else if (prevVote.state == VoterState.VotedNo) {\r\n            proposalState.noVotes = proposalState.noVotes.sub(prevVote.votesNum);\r\n        }\r\n\r\n        VoteData memory newVote;\r\n        newVote.votesNum = numOfVotes.safe96();\r\n        if (vote) {\r\n            proposalState.yesVotes = proposalState.yesVotes.add(newVote.votesNum);\r\n            newVote.state = VoterState.VotedYes;\r\n        } else {\r\n            proposalState.noVotes = proposalState.noVotes.add(newVote.votesNum);\r\n            newVote.state = VoterState.VotedNo;\r\n        }\r\n\r\n        _proposals[proposalId].state = proposalState;\r\n        _voteData[voter][proposalId] = newVote;\r\n        emit VotedOn(proposalId, voter, vote, newVote.votesNum);\r\n    }\r\n\r\n    // Declared `virtual` for tests only\r\n    // This should be a view function but, because ratequoter isn't, it can't be\r\n    function _getPollenPrice() internal virtual returns(uint256 price) {\r\n        uint256 totalVal;\r\n        uint256 plnBal = IERC20(_plnAddress()).totalSupply();\r\n        if (plnBal != 0) {\r\n            // TODO: cache the price and update only if it's outdated\r\n            IRateQuoter rateQuoter = IRateQuoter(_rateQuoterAddress());\r\n            for (uint i; i < _assets.elements.length; i++) {\r\n                uint256 assetBal = IERC20(_assets.elements[i]).balanceOf(address(this));\r\n                if (assetBal == 0) continue;\r\n                (uint256 assetRate, ) = rateQuoter.quotePrice(_assets.elements[i]);\r\n                totalVal = totalVal.add(assetRate.mul(assetBal));\r\n            }\r\n            price = totalVal == 0 ? 0 : totalVal.div(plnBal);\r\n        } else {\r\n            price = plnInitialRate;\r\n        }\r\n        emit PollenPrice(price);\r\n    }\r\n\r\n    function _sendStemTo(address member, uint256 amount) internal override {\r\n        IERC20(_stemAddress()).safeTransfer(member, amount);\r\n    }\r\n\r\n    function _getPendingRewardStem() internal view override returns(uint256 amount) {\r\n        amount = IStemVesting(_stemAddress()).getPoolPendingStem(address(this));\r\n    }\r\n\r\n    // Declared `virtual` for tests only\r\n    function _withdrawRewardStem() internal virtual override returns(uint256 amount) {\r\n        amount = IStemVesting(_stemAddress()).withdrawPoolStem(address(this));\r\n    }\r\n\r\n    // Declared `virtual` for tests only\r\n    function _takeSnapshot(\r\n        bool isExclPools\r\n    ) internal virtual returns (uint256 snapshotId, uint256 totalVotes) {\r\n        {\r\n            IPollen stem = IPollen(_stemAddress());\r\n            uint256 plnSnapId = IPollen(_plnAddress()).snapshot();\r\n            uint256 stmSnapId = stem.snapshot();\r\n            snapshotId = _encodeSnapshotId(plnSnapId, stmSnapId);\r\n            totalVotes = stem.totalSupplyAt(stmSnapId);\r\n        }\r\n        {\r\n            if (isExclPools && (totalVotes != 0)) {\r\n                totalVotes = totalVotes\r\n                .sub(_getVotesOfAt(foundationPoolAddress, snapshotId))\r\n                .sub(_getVotesOfAt(reservePoolAddress, snapshotId))\r\n                .sub(_getVotesOfAt(foundersPoolAddress, snapshotId));\r\n                // Marketing Pool ignored\r\n            }\r\n        }\r\n    }\r\n\r\n    // Declared `virtual` for tests only\r\n    function _getVotesOfAt(\r\n        address member,\r\n        uint256 snapshotId\r\n    ) internal virtual view returns(uint) {\r\n        ( , uint256 stmSnapId) = _decodeSnapshotId(snapshotId);\r\n        return IPollen(_stemAddress()).balanceOfAt(member, stmSnapId);\r\n    }\r\n\r\n    // Made `virtual` for testing only\r\n    function _getTotalVotesAt(uint256 snapshotId) internal view  virtual returns(uint256) {\r\n        (, uint256 stmSnapId) = _decodeSnapshotId(snapshotId);\r\n        return IPollen(_stemAddress()).totalSupplyAt(stmSnapId);\r\n    }\r\n\r\n    // Made `virtual` for testing only\r\n    function _getPlnBalanceAt(\r\n        address member,\r\n        uint256 snapshotId\r\n    ) internal view  virtual returns(uint256) {\r\n        (uint256 plnSnapId, ) = _decodeSnapshotId(snapshotId);\r\n        return IPollen(_plnAddress()).balanceOfAt(member, plnSnapId);\r\n    }\r\n\r\n    // Declared `virtual` for tests only\r\n    function _revertOnPool(address account) internal pure virtual {\r\n        require(\r\n            account != foundationPoolAddress &&\r\n            account != reservePoolAddress &&\r\n            account != marketPoolAddress &&\r\n            account != foundersPoolAddress,\r\n            \"PollenDAO: pools not allowed\"\r\n        );\r\n    }\r\n\r\n    function _validateProposalId(uint256 proposalId) private view {\r\n        require(proposalId < _proposalCount, \"PollenDAO: invalid proposal id\");\r\n    }\r\n\r\n    function _getTermSheet(uint256 termsId) private view returns(VotingTerms memory terms) {\r\n        terms = _votingTerms[termsId];\r\n        require(terms.quorum != 0, \"PollenDAO: invalid termsId\");\r\n    }\r\n\r\n    function _encodeSnapshotId(\r\n        uint plnSnapId,\r\n        uint stmSnapId\r\n    ) private pure returns(uint256) {\r\n        // IDs are supposed to never exceed 16 bits (2**16 - 1)\r\n        // If two IDs are equal, no encoding applied\r\n        if (plnSnapId == stmSnapId) return plnSnapId;\r\n        return (plnSnapId << 16) | stmSnapId;\r\n    }\r\n\r\n    function _decodeSnapshotId(\r\n        uint256 encodedId\r\n    ) private pure returns(uint256 plnSnapId, uint256 stmSnapId) {\r\n        // see notes to `_encodeSnapshotId` function\r\n        if ((encodedId & 0xFFFF0000) == 0) return (encodedId, encodedId);\r\n        plnSnapId = encodedId >> 16;\r\n        stmSnapId = encodedId & 0xFFFF;\r\n    }\r\n\r\n    function _revertWrongStatus(\r\n        ProposalStatus status,\r\n        ProposalStatus expectedStatus\r\n    ) private pure {\r\n        require(status == expectedStatus, \"PollenDAO: wrong proposal status\");\r\n    }\r\n\r\n    // @dev Declared \"internal virtual\" for tests only\r\n    function _plnAddress() internal pure virtual returns(address) {\r\n        return plnTokenAddress;\r\n    }\r\n    function _stemAddress() internal pure virtual returns(address) {\r\n        return stemTokenAddress;\r\n    }\r\n    function _rateQuoterAddress() internal pure virtual returns(address) {\r\n        return rateQuoterAddress;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"AssetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"AssetRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum IPollenTypes.RewardKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"PointsRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PollenPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pollenAmount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RewardParamsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IPollenTypes.ProposalStatus\",\"name\":\"newStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum IPollenTypes.ProposalStatus\",\"name\":\"oldStatus\",\"type\":\"uint8\"}],\"name\":\"StatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StemAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IPollenTypes.ProposalType\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"Submitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"VotedOn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"termsId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"VotingTermsSwitched\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExclPools\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"quorum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"votingExpiryDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executionOpenDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executionExpiryDelay\",\"type\":\"uint32\"}],\"internalType\":\"struct IPollenTypes.VotingTerms\",\"name\":\"terms\",\"type\":\"tuple\"}],\"name\":\"addVotingTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"getMemberPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"getMemberRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"lastUpdateBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"points\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"entitled\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"adjustment\",\"type\":\"uint96\"}],\"internalType\":\"struct IPollenTypes.MemberRewards\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"getPendingStem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stemAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPollenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPollenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IPollenTypes.ProposalType\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"enum IPollenTypes.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum IPollenTypes.BaseCcyType\",\"name\":\"baseCcyType\",\"type\":\"uint8\"},{\"internalType\":\"enum IPollenTypes.TokenType\",\"name\":\"assetTokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"votingTermsId\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"__reserved1\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__reserved2\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"assetTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"pollenAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"assetTokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IPollenTypes.ProposalTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"votingOpen\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"votingExpiry\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executionOpen\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executionExpiry\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"snapshotId\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"passVotes\",\"type\":\"uint96\"}],\"internalType\":\"struct IPollenTypes.ProposalParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"descriptionCid\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalState\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IPollenTypes.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"yesVotes\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"noVotes\",\"type\":\"uint96\"}],\"internalType\":\"struct IPollenTypes.ProposalState\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRateQuoterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardTotals\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"lastAccumBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"accStemPerPoint\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"totalPoints\",\"type\":\"uint112\"}],\"internalType\":\"struct IPollenTypes.RewardTotals\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStemAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getVoteData\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IPollenTypes.VoterState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"votesNum\",\"type\":\"uint96\"}],\"internalType\":\"struct IPollenTypes.VoteData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"termsId\",\"type\":\"uint256\"}],\"name\":\"getVotingTerms\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExclPools\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"quorum\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"votingExpiryDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executionOpenDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"executionExpiryDelay\",\"type\":\"uint32\"}],\"internalType\":\"struct IPollenTypes.VotingTerms\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preventUseWithoutProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pollenAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"removeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardParams\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"forVotingPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forProposalPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forExecutionPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forStateUpdPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forPlnDayPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint176\",\"name\":\"__reserved\",\"type\":\"uint176\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPollenTypes.ProposalType\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"enum IPollenTypes.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum IPollenTypes.BaseCcyType\",\"name\":\"baseCcyType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"termsId\",\"type\":\"uint256\"},{\"internalType\":\"enum IPollenTypes.TokenType\",\"name\":\"assetTokenType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"assetTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pollenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"descriptionCid\",\"type\":\"string\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"termsId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"switchVotingTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"updatePlnWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"updateProposalStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"forVotingPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forProposalPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forExecutionPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forStateUpdPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forPlnDayPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint176\",\"name\":\"__reserved\",\"type\":\"uint176\"}],\"internalType\":\"struct IPollenTypes.RewardParams\",\"name\":\"_rewardParams\",\"type\":\"tuple\"}],\"name\":\"updateRewardParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"voteOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PollenDAO_v1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4fa430b280ab8faa3e7ee92db40aa53c6f9524feb16ec1c1c13cfdd4771609bd"}]}