{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Extension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n* This contract holds staking functions, tallyVotes and updateDisputeFee\\n* Because of space limitations and will be consolidated in future iterations\\n*/\\n\\npragma solidity 0.7.4;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TellorGetters.sol\\\";\\nimport \\\"./TellorVariables.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n\\ncontract Extension is TellorGetters {\\n    using SafeMath for uint256;\\n\\n    //emitted upon dispute tally\\n    event DisputeVoteTallied(\\n        uint256 indexed _disputeID,\\n        int256 _result,\\n        address indexed _reportedMiner,\\n        address _reportingParty,\\n        bool _active\\n    );\\n    event StakeWithdrawn(address indexed _sender); //Emits when a staker is block.timestamp no longer staked\\n    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\\n    event NewStake(address indexed _sender); //Emits upon new staker\\n\\n    /**\\n     * @dev This function allows miners to deposit their stake.\\n     */\\n    function depositStake() public {\\n        newStake(msg.sender);\\n        updateMinDisputeFee();\\n    }\\n\\n    /**\\n     * @dev This internal function is used the depositStake function to successfully stake miners.\\n     * The function updates their status/state and status start date so they are locked it so they can't withdraw\\n     * and updates the number of stakers in the system.\\n     */\\n    function newStake(address _staker) internal {\\n        require(\\n            balances[_staker][balances[_staker].length - 1].value >=\\n                uints[_STAKE_AMOUNT],\\n            \\\"Balance is lower than stake amount\\\"\\n        );\\n        //Ensure they can only stake if they are not currently staked or if their stake time frame has ended\\n        //and they are currently locked for withdraw\\n        require(\\n            stakerDetails[_staker].currentStatus == 0 ||\\n                stakerDetails[_staker].currentStatus == 2,\\n            \\\"Miner is in the wrong state\\\"\\n        );\\n        uints[_STAKE_COUNT] += 1;\\n        stakerDetails[_staker] = StakeInfo({\\n            currentStatus: 1, //this resets their stake start date to today\\n            startDate: block.timestamp - (block.timestamp % 86400)\\n        });\\n        emit NewStake(_staker);\\n    }\\n\\n    /*Functions*/\\n    /**\\n     * @dev This function allows stakers to request to withdraw their stake (no longer stake)\\n     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\\n     * can withdraw the deposit\\n     */\\n    function requestStakingWithdraw() public {\\n        StakeInfo storage stakes = stakerDetails[msg.sender];\\n        //Require that the miner is staked\\n        require(stakes.currentStatus == 1, \\\"Miner is not staked\\\");\\n\\n        //Change the miner staked to locked to be withdrawStake\\n        stakes.currentStatus = 2;\\n\\n        //Change the startDate to block.timestamp since the lock up period begins block.timestamp\\n        //and the miner can only withdraw 7 days later from block.timestamp(check the withdraw function)\\n        stakes.startDate = block.timestamp - (block.timestamp % 86400);\\n\\n        //Reduce the staker count\\n        uints[_STAKE_COUNT] -= 1;\\n\\n        //Update the minimum dispute fee that is based on the number of stakers\\n        updateMinDisputeFee();\\n        emit StakeWithdrawRequested(msg.sender);\\n    }\\n\\n    /**\\n     * @dev This function allows users to withdraw their stake after a 7 day waiting\\n     * period from request\\n     */\\n    function withdrawStake() public {\\n        StakeInfo storage stakes = stakerDetails[msg.sender];\\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have\\n        //passed by since they locked for withdraw\\n        require(\\n            block.timestamp - (block.timestamp % 86400) - stakes.startDate >=\\n                7 days,\\n            \\\"7 days didn't pass\\\"\\n        );\\n        require(\\n            stakes.currentStatus == 2,\\n            \\\"Miner was not locked for withdrawal\\\"\\n        );\\n        stakes.currentStatus = 0;\\n        emit StakeWithdrawn(msg.sender);\\n    }\\n\\n    /**\\n     * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\\n     * @param _disputeId is the dispute id\\n     */\\n    function tallyVotes(uint256 _disputeId) public {\\n        Dispute storage disp = disputesById[_disputeId];\\n        //Ensure this has not already been executed/tallied\\n        require(disp.executed == false, \\\"Dispute has been already executed\\\");\\n        require(\\n            block.timestamp >= disp.disputeUintVars[_MIN_EXECUTION_DATE],\\n            \\\"Time for voting haven't elapsed\\\"\\n        );\\n        require(\\n            disp.reportingParty != address(0),\\n            \\\"reporting Party is address 0\\\"\\n        );\\n        int256 _tally = disp.tally;\\n        if (_tally > 0) {\\n            //Set the dispute state to passed/true\\n            disp.disputeVotePassed = true;\\n        }\\n        //If the vote is not a proposed fork\\n        if (disp.isPropFork == false) {\\n            //Ensure the time for voting has elapsed\\n            StakeInfo storage stakes = stakerDetails[disp.reportedMiner];\\n            //If the vote for disputing a value is successful(disp.tally >0) then unstake the reported\\n            // miner and transfer the stakeAmount and dispute fee to the reporting party\\n            if (stakes.currentStatus == 3) {\\n                stakes.currentStatus = 4;\\n            }\\n        }\\n        disp.disputeUintVars[_TALLY_DATE] = block.timestamp;\\n        disp.executed = true;\\n        emit DisputeVoteTallied(\\n            _disputeId,\\n            _tally,\\n            disp.reportedMiner,\\n            disp.reportingParty,\\n            disp.disputeVotePassed\\n        );\\n    }\\n\\n    /**\\n     * @dev This function updates the minimum dispute fee as a function of the amount\\n     * of staked miners\\n     */\\n    function updateMinDisputeFee() public {\\n        uint256 _stakeAmt = uints[_STAKE_AMOUNT];\\n        uint256 _trgtMiners = uints[_TARGET_MINERS];\\n        uints[_DISPUTE_FEE] = SafeMath.max(\\n            15e18,\\n            (_stakeAmt -\\n                ((_stakeAmt *\\n                    (SafeMath.min(_trgtMiners, uints[_STAKE_COUNT]) * 1000)) /\\n                    _trgtMiners) /\\n                1000)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a + b;\\n            assert(c >= a);\\n        } else {\\n            c = a + b;\\n            assert(c <= a);\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function max(int256 a, int256 b) internal pure returns (uint256) {\\n        return a > b ? uint256(a) : uint256(b);\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        assert(a == 0 || c / a == b);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a - b;\\n            assert(c <= a);\\n        } else {\\n            c = a - b;\\n            assert(c >= a);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorGetters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.4;\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./TellorStorage.sol\\\";\\r\\nimport \\\"./TellorVariables.sol\\\";\\r\\nimport \\\"./Utilities.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Tellor Getters\\r\\n * @dev Oracle contract with all tellor getter functions\\r\\n */\\r\\ncontract TellorGetters is TellorStorage, TellorVariables, Utilities {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev This function tells you if a given challenge has been completed by a given miner\\r\\n     * @param _challenge the challenge to search for\\r\\n     * @param _miner address that you want to know if they solved the challenge\\r\\n     * @return true if the _miner address provided solved the\\r\\n     */\\r\\n    function didMine(bytes32 _challenge, address _miner)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return minersByChallenge[_challenge][_miner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if an address voted in a given dispute\\r\\n     * @param _disputeId to look up\\r\\n     * @param _address to look up\\r\\n     * @return bool of whether or not party voted\\r\\n     */\\r\\n    function didVote(uint256 _disputeId, address _address)\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return disputesById[_disputeId].voted[_address];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev allows Tellor to read data from the addressVars mapping\\r\\n     * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\r\\n     * These are examples of how the variables are saved within other functions:\\r\\n     * addressVars[keccak256(\\\"_owner\\\")]\\r\\n     * addressVars[keccak256(\\\"tellorContract\\\")]\\r\\n     * @return address of the requested variable\\r\\n     */\\r\\n    function getAddressVars(bytes32 _data) external view returns (address) {\\r\\n        return addresses[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets all dispute variables\\r\\n     * @param _disputeId to look up\\r\\n     * @return bytes32 hash of dispute\\r\\n     * bool executed where true if it has been voted on\\r\\n     * bool disputeVotePassed\\r\\n     * bool isPropFork true if the dispute is a proposed fork\\r\\n     * address of reportedMiner\\r\\n     * address of reportingParty\\r\\n     * address of proposedForkAddress\\r\\n     * uint of requestId\\r\\n     * uint of timestamp\\r\\n     * uint of value\\r\\n     * uint of minExecutionDate\\r\\n     * uint of numberOfVotes\\r\\n     * uint of blocknumber\\r\\n     * uint of minerSlot\\r\\n     * uint of quorum\\r\\n     * uint of fee\\r\\n     * int count of the current tally\\r\\n     */\\r\\n    function getAllDisputeVars(uint256 _disputeId)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            bytes32,\\r\\n            bool,\\r\\n            bool,\\r\\n            bool,\\r\\n            address,\\r\\n            address,\\r\\n            address,\\r\\n            uint256[9] memory,\\r\\n            int256\\r\\n        )\\r\\n    {\\r\\n        Dispute storage disp = disputesById[_disputeId];\\r\\n        return (\\r\\n            disp.hash,\\r\\n            disp.executed,\\r\\n            disp.disputeVotePassed,\\r\\n            disp.isPropFork,\\r\\n            disp.reportedMiner,\\r\\n            disp.reportingParty,\\r\\n            disp.proposedForkAddress,\\r\\n            [\\r\\n                disp.disputeUintVars[_REQUEST_ID],\\r\\n                disp.disputeUintVars[_TIMESTAMP],\\r\\n                disp.disputeUintVars[_VALUE],\\r\\n                disp.disputeUintVars[_MIN_EXECUTION_DATE],\\r\\n                disp.disputeUintVars[_NUM_OF_VOTES],\\r\\n                disp.disputeUintVars[_BLOCK_NUMBER],\\r\\n                disp.disputeUintVars[_MINER_SLOT],\\r\\n                disp.disputeUintVars[keccak256(\\\"quorum\\\")],\\r\\n                disp.disputeUintVars[_FEE]\\r\\n            ],\\r\\n            disp.tally\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if a given hash of miner,requestId has been disputed\\r\\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId,_timestamp));\\r\\n     * @return uint disputeId\\r\\n     */\\r\\n    function getDisputeIdByDisputeHash(bytes32 _hash)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return disputeIdByDisputeHash[_hash];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disputeId\\r\\n     * @param _disputeId is the dispute id;\\r\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\r\\n     * the variables/strings used to save the data in the mapping. The variables names are\\r\\n     * commented out under the disputeUintVars under the Dispute struct\\r\\n     * @return uint value for the bytes32 data submitted\\r\\n     */\\r\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return disputesById[_disputeId].disputeUintVars[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the a value for the latest timestamp available\\r\\n     * @return value for timestamp of last proof of work submitted\\r\\n     * @return true if the is a timestamp for the lastNewValue\\r\\n     */\\r\\n    function getLastNewValue() external view returns (uint256, bool) {\\r\\n        return (\\r\\n            retrieveData(\\r\\n                requestIdByTimestamp[uints[_TIME_OF_LAST_NEW_VALUE]],\\r\\n                uints[_TIME_OF_LAST_NEW_VALUE]\\r\\n            ),\\r\\n            true\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the a value for the latest timestamp available\\r\\n     * @param _requestId being requested\\r\\n     * @return value for timestamp of last proof of work submitted and if true if it exist or 0 and false if it doesn't\\r\\n     */\\r\\n    function getLastNewValueById(uint256 _requestId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        Request storage _request = requestDetails[_requestId];\\r\\n        if (_request.requestTimestamps.length != 0) {\\r\\n            return (\\r\\n                retrieveData(\\r\\n                    _requestId,\\r\\n                    _request.requestTimestamps[\\r\\n                        _request.requestTimestamps.length - 1\\r\\n                    ]\\r\\n                ),\\r\\n                true\\r\\n            );\\r\\n        } else {\\r\\n            return (0, false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets blocknumber for mined timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up blocknumber\\r\\n     * @return uint of the blocknumber which the dispute was mined\\r\\n     */\\r\\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].minedBlockNum[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up miners for\\r\\n     * @return the 5 miners' addresses\\r\\n     */\\r\\n    function getMinersByRequestIdAndTimestamp(\\r\\n        uint256 _requestId,\\r\\n        uint256 _timestamp\\r\\n    ) external view returns (address[5] memory) {\\r\\n        return requestDetails[_requestId].minersByValue[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Counts the number of values that have been submitted for the request\\r\\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\r\\n     * request so far\\r\\n     * @param _requestId the requestId to look up\\r\\n     * @return uint count of the number of values received for the requestId\\r\\n     */\\r\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].requestTimestamps.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the specified requestQ index\\r\\n     * @param _index to look up in the requestQ array\\r\\n     * @return uint of requestId\\r\\n     */\\r\\n    function getRequestIdByRequestQIndex(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(_index <= 50, \\\"RequestQ index is above 50\\\");\\r\\n        return requestIdByRequestQIndex[_index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for requestId based on timestamp\\r\\n     * @param _timestamp to check requestId\\r\\n     * @return uint of requestId\\r\\n     */\\r\\n    function getRequestIdByTimestamp(uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestIdByTimestamp[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the requestQ array\\r\\n     * @return the requestQ array\\r\\n     */\\r\\n    function getRequestQ() public view returns (uint256[51] memory) {\\r\\n        return requestQ;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows access to the uint variables saved in the apiUintVars under the requestDetails struct\\r\\n     * for the requestId specified\\r\\n     * @param _requestId to look up\\r\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\r\\n     * the variables/strings used to save the data in the mapping. The variables names are\\r\\n     * commented out under the apiUintVars under the requestDetails struct\\r\\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\\r\\n     */\\r\\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].apiUintVars[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the API struct variables that are not mappings\\r\\n     * @param _requestId to look up\\r\\n     * @return uint of index in requestQ array\\r\\n     * @return uint of current payout/tip for this requestId\\r\\n     */\\r\\n    function getRequestVars(uint256 _requestId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        Request storage _request = requestDetails[_requestId];\\r\\n        return (\\r\\n            _request.apiUintVars[_REQUEST_Q_POSITION],\\r\\n            _request.apiUintVars[_TOTAL_TIP]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This function allows users to retrieve all information about a staker\\r\\n     * @param _staker address of staker inquiring about\\r\\n     * @return uint current state of staker\\r\\n     * @return uint startDate of staking\\r\\n     */\\r\\n    function getStakerInfo(address _staker)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return (\\r\\n            stakerDetails[_staker].currentStatus,\\r\\n            stakerDetails[_staker].startDate\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up miners for\\r\\n     * @return address[5] array of 5 addresses of miners that mined the requestId\\r\\n     */\\r\\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[5] memory)\\r\\n    {\\r\\n        return requestDetails[_requestId].valuesByTimestamp[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the timestamp for the value based on their index\\r\\n     * @param _requestID is the requestId to look up\\r\\n     * @param _index is the value index to look up\\r\\n     * @return uint timestamp\\r\\n     */\\r\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestID].requestTimestamps[_index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the variables saved under the TellorStorageStruct uints variable\\r\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\")\\r\\n     * where variable_name is the variables/strings used to save the data in the mapping.\\r\\n     * The variables names in the TellorVariables contract\\r\\n     * @return uint of specified variable\\r\\n     */\\r\\n    function getUintVar(bytes32 _data) public view returns (uint256) {\\r\\n        return uints[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up miners for\\r\\n     * @return bool true if requestId/timestamp is under dispute\\r\\n     */\\r\\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return requestDetails[_requestId].inDispute[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieve value from oracle based on timestamp\\r\\n     * @param _requestId being requested\\r\\n     * @param _timestamp to retrieve data/value from\\r\\n     * @return value for timestamp submitted\\r\\n     */\\r\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].finalValues[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the total_supply of oracle tokens\\r\\n     * @return uint total supply\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return uints[_TOTAL_SUPPLY];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to access the token's name\\r\\n     */\\r\\n    function name() external pure returns (string memory) {\\r\\n        return \\\"Tellor Tributes\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to access the token's symbol\\r\\n     */\\r\\n    function symbol() external pure returns (string memory) {\\r\\n        return \\\"TRB\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to access the number of decimals\\r\\n     */\\r\\n    function decimals() external pure returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the requestId being mined\\r\\n     * returns the currentChallenge, array of requestIDs, difficulty, and the current Tip of the 5 IDs\\r\\n     */\\r\\n    function getNewCurrentVariables()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            bytes32 _challenge,\\r\\n            uint256[5] memory _requestIds,\\r\\n            uint256 _diff,\\r\\n            uint256 _tip\\r\\n        )\\r\\n    {\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            _requestIds[i] = currentMiners[i].value;\\r\\n        }\\r\\n        return (\\r\\n            bytesVars[_CURRENT_CHALLENGE],\\r\\n            _requestIds,\\r\\n            uints[_DIFFICULTY],\\r\\n            uints[_CURRENT_TOTAL_TIPS]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for next requestIds on queue/request with highest payouts at time the function is called\\r\\n     */\\r\\n    function getNewVariablesOnDeck()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck)\\r\\n    {\\r\\n        idsOnDeck = getTopRequestIDs();\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            tipsOnDeck[i] = requestDetails[idsOnDeck[i]].apiUintVars[\\r\\n                _TOTAL_TIP\\r\\n            ];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the top 5 requests with highest payouts. This function is used within the getNewVariablesOnDeck function\\r\\n     */\\r\\n    function getTopRequestIDs()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256[5] memory _requestIds)\\r\\n    {\\r\\n        uint256[5] memory _max;\\r\\n        uint256[5] memory _index;\\r\\n        (_max, _index) = getMax5(requestQ);\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            if (_max[i] != 0) {\\r\\n                _requestIds[i] = requestIdByRequestQIndex[_index[i]];\\r\\n            } else {\\r\\n                _requestIds[i] = currentMiners[4 - i].value;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TellorVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n// Helper contract to store hashes of variables\\ncontract TellorVariables {\\n    bytes32 constant _BLOCK_NUMBER =\\n        0x4b4cefd5ced7569ef0d091282b4bca9c52a034c56471a6061afd1bf307a2de7c; //keccak256(\\\"_BLOCK_NUMBER\\\");\\n    bytes32 constant _CURRENT_CHALLENGE =\\n        0xd54702836c9d21d0727ffacc3e39f57c92b5ae0f50177e593bfb5ec66e3de280; //keccak256(\\\"_CURRENT_CHALLENGE\\\");\\n    bytes32 constant _CURRENT_REQUESTID =\\n        0xf5126bb0ac211fbeeac2c0e89d4c02ac8cadb2da1cfb27b53c6c1f4587b48020; //keccak256(\\\"_CURRENT_REQUESTID\\\");\\n    bytes32 constant _CURRENT_REWARD =\\n        0xd415862fd27fb74541e0f6f725b0c0d5b5fa1f22367d9b78ec6f61d97d05d5f8; //keccak256(\\\"_CURRENT_REWARD\\\");\\n    bytes32 constant _CURRENT_TOTAL_TIPS =\\n        0x09659d32f99e50ac728058418d38174fe83a137c455ff1847e6fb8e15f78f77a; //keccak256(\\\"_CURRENT_TOTAL_TIPS\\\");\\n    bytes32 constant _DEITY =\\n        0x5fc094d10c65bc33cc842217b2eccca0191ff24148319da094e540a559898961; //keccak256(\\\"_DEITY\\\");\\n    bytes32 constant _DIFFICULTY =\\n        0xf758978fc1647996a3d9992f611883adc442931dc49488312360acc90601759b; //keccak256(\\\"_DIFFICULTY\\\");\\n    bytes32 constant _DISPUTE_COUNT =\\n        0x310199159a20c50879ffb440b45802138b5b162ec9426720e9dd3ee8bbcdb9d7; //keccak256(\\\"_DISPUTE_COUNT\\\");\\n    bytes32 constant _DISPUTE_FEE =\\n        0x675d2171f68d6f5545d54fb9b1fb61a0e6897e6188ca1cd664e7c9530d91ecfc; //keccak256(\\\"_DISPUTE_FEE\\\");\\n    bytes32 constant _DISPUTE_ROUNDS =\\n        0x6ab2b18aafe78fd59c6a4092015bddd9fcacb8170f72b299074f74d76a91a923; //keccak256(\\\"_DISPUTE_ROUNDS\\\");\\n    bytes32 constant _EXTENSION =\\n        0x2b2a1c876f73e67ebc4f1b08d10d54d62d62216382e0f4fd16c29155818207a4; //keccak256(\\\"_EXTENSION\\\");\\n    bytes32 constant _FEE =\\n        0x1da95f11543c9b03927178e07951795dfc95c7501a9d1cf00e13414ca33bc409; //keccak256(\\\"FEE\\\");\\n    bytes32 constant _MIGRATOR =\\n        0xc6b005d45c4c789dfe9e2895b51df4336782c5ff6bd59a5c5c9513955aa06307; //keccak256(\\\"_MIGRATOR\\\");\\n    bytes32 constant _MIN_EXECUTION_DATE =\\n        0x46f7d53798d31923f6952572c6a19ad2d1a8238d26649c2f3493a6d69e425d28; //keccak256(\\\"_MIN_EXECUTION_DATE\\\");\\n    bytes32 constant _MINER_SLOT =\\n        0x6de96ee4d33a0617f40a846309c8759048857f51b9d59a12d3c3786d4778883d; //keccak256(\\\"_MINER_SLOT\\\");\\n    bytes32 constant _NUM_OF_VOTES =\\n        0x1da378694063870452ce03b189f48e04c1aa026348e74e6c86e10738514ad2c4; //keccak256(\\\"_NUM_OF_VOTES\\\");\\n    bytes32 constant _OLD_TELLOR =\\n        0x56e0987db9eaec01ed9e0af003a0fd5c062371f9d23722eb4a3ebc74f16ea371; //keccak256(\\\"_OLD_TELLOR\\\");\\n    bytes32 constant _ORIGINAL_ID =\\n        0xed92b4c1e0a9e559a31171d487ecbec963526662038ecfa3a71160bd62fb8733; //keccak256(\\\"_ORIGINAL_ID\\\");\\n    bytes32 constant _OWNER =\\n        0x7a39905194de50bde334d18b76bbb36dddd11641d4d50b470cb837cf3bae5def; //keccak256(\\\"_OWNER\\\");\\n    bytes32 constant _PAID =\\n        0x29169706298d2b6df50a532e958b56426de1465348b93650fca42d456eaec5fc; //keccak256(\\\"_PAID\\\");\\n    bytes32 constant _PENDING_OWNER =\\n        0x7ec081f029b8ac7e2321f6ae8c6a6a517fda8fcbf63cabd63dfffaeaafa56cc0; //keccak256(\\\"_PENDING_OWNER\\\");\\n    bytes32 constant _REQUEST_COUNT =\\n        0x3f8b5616fa9e7f2ce4a868fde15c58b92e77bc1acd6769bf1567629a3dc4c865; //keccak256(\\\"_REQUEST_COUNT\\\");\\n    bytes32 constant _REQUEST_ID =\\n        0x9f47a2659c3d32b749ae717d975e7962959890862423c4318cf86e4ec220291f; //keccak256(\\\"_REQUEST_ID\\\");\\n    bytes32 constant _REQUEST_Q_POSITION =\\n        0xf68d680ab3160f1aa5d9c3a1383c49e3e60bf3c0c031245cbb036f5ce99afaa1; //keccak256(\\\"_REQUEST_Q_POSITION\\\");\\n    bytes32 constant _SLOT_PROGRESS =\\n        0xdfbec46864bc123768f0d134913175d9577a55bb71b9b2595fda21e21f36b082; //keccak256(\\\"_SLOT_PROGRESS\\\");\\n    bytes32 constant _STAKE_AMOUNT =\\n        0x5d9fadfc729fd027e395e5157ef1b53ef9fa4a8f053043c5f159307543e7cc97; //keccak256(\\\"_STAKE_AMOUNT\\\");\\n    bytes32 constant _STAKE_COUNT =\\n        0x10c168823622203e4057b65015ff4d95b4c650b308918e8c92dc32ab5a0a034b; //keccak256(\\\"_STAKE_COUNT\\\");\\n    bytes32 constant _T_BLOCK =\\n        0xf3b93531fa65b3a18680d9ea49df06d96fbd883c4889dc7db866f8b131602dfb; //keccak256(\\\"_T_BLOCK\\\");\\n    bytes32 constant _TALLY_DATE =\\n        0xf9e1ae10923bfc79f52e309baf8c7699edb821f91ef5b5bd07be29545917b3a6; //keccak256(\\\"_TALLY_DATE\\\");\\n    bytes32 constant _TARGET_MINERS =\\n        0x0b8561044b4253c8df1d9ad9f9ce2e0f78e4bd42b2ed8dd2e909e85f750f3bc1; //keccak256(\\\"_TARGET_MINERS\\\");\\n    bytes32 constant _TELLOR_CONTRACT =\\n        0x0f1293c916694ac6af4daa2f866f0448d0c2ce8847074a7896d397c961914a08; //keccak256(\\\"_TELLOR_CONTRACT\\\");\\n    bytes32 constant _TELLOR_GETTERS =\\n        0xabd9bea65759494fe86471c8386762f989e1f2e778949e94efa4a9d1c4b3545a; //keccak256(\\\"_TELLOR_GETTERS\\\");\\n    bytes32 constant _TIME_OF_LAST_NEW_VALUE =\\n        0x2c8b528fbaf48aaf13162a5a0519a7ad5a612da8ff8783465c17e076660a59f1; //keccak256(\\\"_TIME_OF_LAST_NEW_VALUE\\\");\\n    bytes32 constant _TIME_TARGET =\\n        0xd4f87b8d0f3d3b7e665df74631f6100b2695daa0e30e40eeac02172e15a999e1; //keccak256(\\\"_TIME_TARGET\\\");\\n    bytes32 constant _TIMESTAMP =\\n        0x2f9328a9c75282bec25bb04befad06926366736e0030c985108445fa728335e5; //keccak256(\\\"_TIMESTAMP\\\");\\n    bytes32 constant _TOTAL_SUPPLY =\\n        0xe6148e7230ca038d456350e69a91b66968b222bfac9ebfbea6ff0a1fb7380160; //keccak256(\\\"_TOTAL_SUPPLY\\\");\\n    bytes32 constant _TOTAL_TIP =\\n        0x1590276b7f31dd8e2a06f9a92867333eeb3eddbc91e73b9833e3e55d8e34f77d; //keccak256(\\\"_TOTAL_TIP\\\");\\n    bytes32 constant _VALUE =\\n        0x9147231ab14efb72c38117f68521ddef8de64f092c18c69dbfb602ffc4de7f47; //keccak256(\\\"_VALUE\\\");\\n    bytes32 constant _EIP_SLOT =\\n        0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\\n}\\n\"\r\n    },\r\n    \"contracts/Utilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n//Functions for retrieving min and Max in 51 length array (requestQ)\\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\\n\\ncontract Utilities {\\n    /**\\n     * @dev This is an internal function called by updateOnDeck that gets the top 5 values\\n     * @param data is an array [51] to determine the top 5 values from\\n     * @return max the top 5 values and their index values in the data array\\n     */\\n    function getMax5(uint256[51] memory data)\\n        public\\n        view\\n        returns (uint256[5] memory max, uint256[5] memory maxIndex)\\n    {\\n        uint256 min5 = data[1];\\n        uint256 minI = 0;\\n        for (uint256 j = 0; j < 5; j++) {\\n            max[j] = data[j + 1]; //max[0]=data[1]\\n            maxIndex[j] = j + 1; //maxIndex[0]= 1\\n            if (max[j] < min5) {\\n                min5 = max[j];\\n                minI = j;\\n            }\\n        }\\n        for (uint256 i = 6; i < data.length; i++) {\\n            if (data[i] > min5) {\\n                max[minI] = data[i];\\n                maxIndex[minI] = i;\\n                min5 = data[i];\\n                for (uint256 j = 0; j < 5; j++) {\\n                    if (max[j] < min5) {\\n                        min5 = max[j];\\n                        minI = j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n/**\\n * @title Tellor Oracle Storage Library\\n * @dev Contains all the variables/structs used by Tellor\\n */\\n\\ncontract TellorStorage {\\n    //Internal struct for use in proof-of-work submission\\n    struct Details {\\n        uint256 value;\\n        address miner;\\n    }\\n\\n    struct Dispute {\\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\\n        int256 tally; //current tally of votes for - against measure\\n        bool executed; //is the dispute settled\\n        bool disputeVotePassed; //did the vote pass?\\n        bool isPropFork; //true for fork proposal NEW\\n        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\\n        address proposedForkAddress; //new fork address (if fork proposal)\\n        mapping(bytes32 => uint256) disputeUintVars;\\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\\\"requestId\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"requestId\\\");//apiID of disputed value\\n        // uint keccak256(\\\"timestamp\\\");//timestamp of disputed value\\n        // uint keccak256(\\\"value\\\"); //the value being disputed\\n        // uint keccak256(\\\"minExecutionDate\\\");//7 days from when dispute initialized\\n        // uint keccak256(\\\"numberOfVotes\\\");//the number of parties who have voted on the measure\\n        // uint keccak256(\\\"blockNumber\\\");// the blocknumber for which votes will be calculated from\\n        // uint keccak256(\\\"minerSlot\\\"); //index in dispute array\\n        // uint keccak256(\\\"fee\\\"); //fee paid corresponding to dispute\\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\\n    }\\n\\n    struct StakeInfo {\\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\\n        uint256 startDate; //stake start date\\n    }\\n\\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\\n    struct Checkpoint {\\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\\n        uint128 value; // value is the amount of tokens at a specific block number\\n    }\\n\\n    struct Request {\\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\\n        mapping(bytes32 => uint256) apiUintVars;\\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"requestQPosition\\\"); //index in requestQ\\n        // uint keccak256(\\\"totalTip\\\");//bonus portion of payout\\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\\n        mapping(uint256 => uint256) finalValues;\\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\\n        mapping(uint256 => address[5]) minersByValue;\\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\\n    }\\n\\n    uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\\n    uint256[] public newValueTimestamps; //array of all timestamps requested\\n    //Address fields in the Tellor contract are saved the addressVars mapping\\n    //e.g. addressVars[keccak256(\\\"tellorContract\\\")] = address\\n    //These are the variables saved in this mapping:\\n    // address keccak256(\\\"tellorContract\\\");//Tellor address\\n    // address  keccak256(\\\"_owner\\\");//Tellor Owner address\\n    // address  keccak256(\\\"_deity\\\");//Tellor Owner that can do things at will\\n    // address  keccak256(\\\"pending_owner\\\"); // The proposed new owner\\n    //uint fields in the Tellor contract are saved the uintVars mapping\\n    //e.g. uintVars[keccak256(\\\"decimals\\\")] = uint\\n    //These are the variables saved in this mapping:\\n    // keccak256(\\\"decimals\\\");    //18 decimal standard ERC20\\n    // keccak256(\\\"disputeFee\\\");//cost to dispute a mined value\\n    // keccak256(\\\"disputeCount\\\");//totalHistoricalDisputes\\n    // keccak256(\\\"total_supply\\\"); //total_supply of the token in circulation\\n    // keccak256(\\\"stakeAmount\\\");//stakeAmount for miners (we can cut gas if we just hardcoded it in...or should it be variable?)\\n    // keccak256(\\\"stakerCount\\\"); //number of parties currently staked\\n    // keccak256(\\\"timeOfLastNewValue\\\"); // time of last challenge solved\\n    // keccak256(\\\"difficulty\\\"); // Difficulty of current block\\n    // keccak256(\\\"currentTotalTips\\\"); //value of highest api/timestamp PayoutPool\\n    // keccak256(\\\"currentRequestId\\\"); //API being mined--updates with the ApiOnQ Id\\n    // keccak256(\\\"requestCount\\\"); // total number of requests through the system\\n    // keccak256(\\\"slotProgress\\\");//Number of miners who have mined this value so far\\n    // keccak256(\\\"miningReward\\\");//Mining Reward in PoWo tokens given to all miners per value\\n    // keccak256(\\\"timeTarget\\\"); //The time between blocks (mined Oracle values)\\n    // keccak256(\\\"_tblock\\\"); //\\n    // keccak256(\\\"runningTips\\\"); // VAriable to track running tips\\n    // keccak256(\\\"currentReward\\\"); // The current reward\\n    // keccak256(\\\"devShare\\\"); // The amount directed towards th devShare\\n    // keccak256(\\\"currentTotalTips\\\"); //\\n\\n    //This is a boolean that tells you if a given challenge has been completed by a given miner\\n    mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\\n    mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\\n    mapping(uint256 => Dispute) public disputesById; //disputeId=> Dispute details\\n    mapping(bytes32 => uint256) public requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\\n    mapping(bytes32 => uint256) public disputeIdByDisputeHash; //maps a hash to an ID for each dispute\\n    mapping(bytes32 => mapping(address => bool)) public minersByChallenge;\\n    Details[5] public currentMiners; //This struct is for organizing the five mined values to find the median\\n    mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\\n    mapping(uint256 => Request) requestDetails;\\n\\n    mapping(bytes32 => uint256) public uints;\\n    mapping(bytes32 => address) public addresses;\\n    mapping(bytes32 => bytes32) public bytesVars;\\n\\n    //ERC20 storage\\n    mapping(address => Checkpoint[]) public balances;\\n    mapping(address => mapping(address => uint256)) public _allowances;\\n\\n    //Migration storage\\n    mapping(address => bool) public migrated;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"_result\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reportedMiner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reportingParty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"DisputeVoteTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"StakeWithdrawRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"fromBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bytesVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_challenge\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"didMine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"didVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputesById\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"int256\",\"name\":\"tally\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disputeVotePassed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPropFork\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"reportedMiner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reportingParty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedForkAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getAddressVars\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getAllDisputeVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getDisputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getDisputeUintVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastNewValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getLastNewValueById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"data\",\"type\":\"uint256[51]\"}],\"name\":\"getMax5\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"max\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"maxIndex\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinedBlockNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinersByRequestIdAndTimestamp\",\"outputs\":[{\"internalType\":\"address[5]\",\"name\":\"\",\"type\":\"address[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNewCurrentVariables\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_challenge\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[5]\",\"name\":\"_requestIds\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256\",\"name\":\"_diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tip\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getNewValueCountbyRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNewVariablesOnDeck\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"idsOnDeck\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"tipsOnDeck\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRequestIdByRequestQIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getRequestIdByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequestQ\",\"outputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"\",\"type\":\"uint256[51]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getRequestUintVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getSubmissionsByTimestamp\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyRequestIDandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTopRequestIDs\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"_requestIds\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getUintVar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minersByChallenge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"newValueTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdByQueryHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestStakingWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"tallyVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"uints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMinDisputeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Extension","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}