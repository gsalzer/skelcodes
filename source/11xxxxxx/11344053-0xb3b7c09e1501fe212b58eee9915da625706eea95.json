{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Lens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"tellorcore/contracts/TellorMaster.sol\\\";\\nimport \\\"usingtellor/contracts/UsingTellor.sol\\\";\\n\\n/**\\n * @title Tellor Lens\\n * @dev A contract to aggregate and simplify calls to the Tellor oracle.\\n **/\\ncontract Lens is UsingTellor {\\n    TellorMaster public proxy;\\n\\n    /*Constructor*/\\n    /**\\n     * @dev the constructor sets the storage address and owner\\n     * @param _master is the Tellor proxy contract address.\\n     */\\n    constructor(address payable _master) public UsingTellor(_master) {\\n        proxy = TellorMaster(_master);\\n    }\\n\\n    /**\\n     * @return Returns the current reward amount.\\n        TODO remove once https://github.com/proxy-io/TellorCore/issues/109 is implemented and deployed.\\n     */\\n    function currentReward() external view returns (uint256) {\\n        uint256 timeDiff = now -\\n            proxy.getUintVar(keccak256(\\\"timeOfLastNewValue\\\"));\\n        uint256 rewardAmount = 1e18;\\n\\n        uint256 rewardAccumulated = (timeDiff * rewardAmount) / 300; // 1TRB every 6 minutes.\\n\\n        uint256 tip = proxy.getUintVar(keccak256(\\\"currentTotalTips\\\")) / 10; // Half of the tips are burnt.\\n        return rewardAccumulated + tip;\\n    }\\n\\n    struct value {\\n        uint256 timestamp;\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @param requestID is the ID for which the function returns the values for.\\n     * @param count is the number of last values to return.\\n     * @return Returns the last N values for a request ID.\\n     */\\n    function getLastNewValues(uint256 requestID, uint256 count)\\n        external\\n        view\\n        returns (value[] memory)\\n    {\\n        uint256 totalCount = proxy.getNewValueCountbyRequestId(requestID);\\n        if (count > totalCount) {\\n            count = totalCount;\\n        }\\n        value[] memory values = new value[](count);\\n        for (uint256 i = 0; i < count; i++) {\\n            uint256 ts = proxy.getTimestampbyRequestIDandIndex(\\n                requestID,\\n                totalCount - i - 1\\n            );\\n            uint256 v = proxy.retrieveData(requestID, ts);\\n            values[i] = value({timestamp: ts, value: v});\\n        }\\n\\n        return values;\\n    }\\n\\n    /**\\n     * @return Returns the contract owner that can do things at will.\\n     */\\n    function _deity() external view returns (address) {\\n        return proxy.getAddressVars(keccak256(\\\"_deity\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the contract owner address.\\n     */\\n    function _owner() external view returns (address) {\\n        return proxy.getAddressVars(keccak256(\\\"_owner\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the contract pending owner.\\n     */\\n    function pending_owner() external view returns (address) {\\n        return proxy.getAddressVars(keccak256(\\\"pending_owner\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the contract address that executes all proxy calls.\\n     */\\n    function tellorContract() external view returns (address) {\\n        return proxy.getAddressVars(keccak256(\\\"tellorContract\\\"));\\n    }\\n\\n    /**\\n     * @param requestID is the ID for which the function returns the total tips.\\n     * @return Returns the current tips for a give request ID.\\n     */\\n    function totalTip(uint256 requestID) external view returns (uint256) {\\n        return proxy.getRequestUintVars(requestID, keccak256(\\\"totalTip\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the last time when a value was submitted.\\n     */\\n    function timeOfLastNewValue() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"timeOfLastNewValue\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the total number of requests from user thorugh the addTip function.\\n     */\\n    function requestCount() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"requestCount\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the total oracle blocks.\\n     */\\n    function _tBlock() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"_tBlock\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the current block difficulty.\\n     *\\n     */\\n    function difficulty() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"difficulty\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable is used to calculate the block difficulty based on\\n     * the time diff since the last oracle block.\\n     */\\n    function timeTarget() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"timeTarget\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the highest api/timestamp PayoutPool.\\n     */\\n    function currentTotalTips() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"currentTotalTips\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the number of miners who have mined this value so far.\\n     */\\n    function slotProgress() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"slotProgress\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the cost to dispute a mined value.\\n     */\\n    function disputeFee() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"disputeFee\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     */\\n    function disputeCount() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"disputeCount\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks stake amount required to become a miner.\\n     */\\n    function stakeAmount() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"stakeAmount\\\"));\\n    }\\n\\n    /**\\n     * @return Returns the getUintVar variable named after the function name.\\n     * This variable tracks the number of parties currently staked.\\n     */\\n    function stakerCount() external view returns (uint256) {\\n        return proxy.getUintVar(keccak256(\\\"stakerCount\\\"));\\n    }\\n\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(bytes(a), bytes(b)));\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/TellorMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./TellorGetters.sol\\\";\\n\\n/**\\n* @title Tellor Master\\n* @dev This is the Master contract with all tellor getter functions and delegate call to Tellor.\\n* The logic for the functions on this contract is saved on the TellorGettersLibrary, TellorTransfer,\\n* TellorGettersLibrary, and TellorStake\\n*/\\ncontract TellorMaster is TellorGetters {\\n    event NewTellorAddress(address _newTellor);\\n\\n    /**\\n    * @dev The constructor sets the original `tellorStorageOwner` of the contract to the sender\\n    * account, the tellor contract to the Tellor master address and owner to the Tellor master owner address\\n    * @param _tellorContract is the address for the tellor contract\\n    */\\n    constructor(address _tellorContract) public {\\n        tellor.init();\\n        tellor.addressVars[keccak256(\\\"_owner\\\")] = msg.sender;\\n        tellor.addressVars[keccak256(\\\"_deity\\\")] = msg.sender;\\n        tellor.addressVars[keccak256(\\\"tellorContract\\\")] = _tellorContract;\\n        emit NewTellorAddress(_tellorContract);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @dev Only needs to be in library\\n    * @param _newDeity the new Deity in the contract\\n    */\\n\\n    function changeDeity(address _newDeity) external {\\n        tellor.changeDeity(_newDeity);\\n    }\\n\\n    /**\\n    * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\\n    * @param _tellorContract the address of the new Tellor Contract\\n    */\\n    function changeTellorContract(address _tellorContract) external {\\n        tellor.changeTellorContract(_tellorContract);\\n    }\\n\\n    /**\\n    * @dev This is the fallback function that allows contracts to call the tellor contract at the address stored\\n    */\\n    function() external payable {\\n        address addr = tellor.addressVars[keccak256(\\\"tellorContract\\\")];\\n        bytes memory _calldata = msg.data;\\n        assembly {\\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n            let size := returndatasize\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n            // if the call returned error data, forward it\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"usingtellor/contracts/UsingTellor.sol\": {\r\n      \"content\": \"pragma solidity >0.5.16;\\n\\nimport \\\"./TellorPlayground.sol\\\";\\n\\n/**\\n * @title UserContract\\n * This contracts creates for easy integration to the Tellor System\\n * by allowing smart contracts to read data off Tellor\\n */\\ncontract UsingTellor {\\n    TellorPlayground tellor;\\n\\n    /*Constructor*/\\n    /**\\n     * @dev the constructor sets the storage address and owner\\n     * @param _tellor is the TellorMaster address\\n     */\\n    constructor(address payable _tellor) public {\\n        tellor = TellorPlayground(_tellor);\\n    }\\n\\n    /**\\n     * @dev Retreive value from oracle based on requestId/timestamp\\n     * @param _requestId being requested\\n     * @param _timestamp to retreive data/value from\\n     * @return uint value for requestId/timestamp submitted\\n     */\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return tellor.retrieveData(_requestId, _timestamp);\\n    }\\n\\n    /**\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n     * @param _requestId to looku p\\n     * @param _timestamp is the timestamp to look up miners for\\n     * @return bool true if requestId/timestamp is under dispute\\n     */\\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return tellor.isInDispute(_requestId, _timestamp);\\n    }\\n\\n    /**\\n     * @dev Counts the number of values that have been submited for the request\\n     * @param _requestId the requestId to look up\\n     * @return uint count of the number of values received for the requestId\\n     */\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return tellor.getNewValueCountbyRequestId(_requestId);\\n    }\\n\\n    /**\\n     * @dev Gets the timestamp for the value based on their index\\n     * @param _requestId is the requestId to look up\\n     * @param _index is the value index to look up\\n     * @return uint timestamp\\n     */\\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return tellor.getTimestampbyRequestIDandIndex(_requestId, _index);\\n    }\\n\\n    /**\\n     * @dev Allows the user to get the latest value for the requestId specified\\n     * @param _requestId is the requestId to look up the value for\\n     * @return ifRetrieve bool true if it is able to retreive a value, the value, and the value's timestamp\\n     * @return value the value retrieved\\n     * @return _timestampRetrieved the value's timestamp\\n     */\\n    function getCurrentValue(uint256 _requestId)\\n        public\\n        view\\n        returns (\\n            bool ifRetrieve,\\n            uint256 value,\\n            uint256 _timestampRetrieved\\n        )\\n    {\\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\\n        uint256 _time = tellor.getTimestampbyRequestIDandIndex(\\n            _requestId,\\n            _count - 1\\n        );\\n        uint256 _value = tellor.retrieveData(_requestId, _time);\\n        if (_value > 0) return (true, _value, _time);\\n        return (false, 0, _time);\\n    }\\n\\n    function getIndexForDataBefore(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool found, uint256 index)\\n    {\\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\\n        if (_count > 0) {\\n            uint256 middle;\\n            uint256 start = 0;\\n            uint256 end = _count - 1;\\n            uint256 _time;\\n\\n            //Checking Boundaries to short-circuit the algorithm\\n            _time = tellor.getTimestampbyRequestIDandIndex(_requestId, start);\\n            if (_time >= _timestamp) return (false, 0);\\n            _time = tellor.getTimestampbyRequestIDandIndex(_requestId, end);\\n            if (_time < _timestamp) return (true, end);\\n\\n            //Since the value is within our boundaries, do a binary search\\n            while (true) {\\n                middle = (end - start) / 2 + 1 + start;\\n                _time = tellor.getTimestampbyRequestIDandIndex(\\n                    _requestId,\\n                    middle\\n                );\\n                if (_time < _timestamp) {\\n                    //get imeadiate next value\\n                    uint256 _nextTime = tellor.getTimestampbyRequestIDandIndex(\\n                        _requestId,\\n                        middle + 1\\n                    );\\n                    if (_nextTime >= _timestamp) {\\n                        //_time is correct\\n                        return (true, middle);\\n                    } else {\\n                        //look from middle + 1(next value) to end\\n                        start = middle + 1;\\n                    }\\n                } else {\\n                    uint256 _prevTime = tellor.getTimestampbyRequestIDandIndex(\\n                        _requestId,\\n                        middle - 1\\n                    );\\n                    if (_prevTime < _timestamp) {\\n                        // _prevtime is correct\\n                        return (true, middle - 1);\\n                    } else {\\n                        //look from start to middle -1(prev value)\\n                        end = middle - 1;\\n                    }\\n                }\\n                //We couldn't found a value\\n                //if(middle - 1 == start || middle == _count) return (false, 0);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Allows the user to get the first value for the requestId before the specified timestamp\\n     * @param _requestId is the requestId to look up the value for\\n     * @param _timestamp before which to search for first verified value\\n     * @return _ifRetrieve bool true if it is able to retreive a value, the value, and the value's timestamp\\n     * @return _value the value retrieved\\n     * @return _timestampRetrieved the value's timestamp\\n     */\\n    function getDataBefore(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (\\n            bool _ifRetrieve,\\n            uint256 _value,\\n            uint256 _timestampRetrieved\\n        )\\n    {\\n        (bool _found, uint256 _index) = getIndexForDataBefore(\\n            _requestId,\\n            _timestamp\\n        );\\n        if (!_found) return (false, 0, 0);\\n        uint256 _time = tellor.getTimestampbyRequestIDandIndex(\\n            _requestId,\\n            _index\\n        );\\n        _value = tellor.retrieveData(_requestId, _time);\\n        //If value is diputed it'll return zero\\n        if (_value > 0) return (true, _value, _time);\\n        return (false, 0, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/TellorGetters.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"tellorlegacy/contracts/oldContracts/libraries/OldSafeMath.sol\\\";\\nimport \\\"tellorlegacy/contracts/oldContracts/libraries/OldTellorStorage.sol\\\";\\nimport \\\"tellorlegacy/contracts/oldContracts/libraries/OldTellorTransfer.sol\\\";\\nimport \\\"tellorlegacy/contracts/oldContracts/libraries/OldTellorGettersLibrary.sol\\\";\\nimport \\\"tellorlegacy/contracts/oldContracts/libraries/OldTellorStake.sol\\\";\\n\\n/**\\n* @title Tellor Getters\\n* @dev Oracle contract with all tellor getter functions. The logic for the functions on this contract\\n* is saved on the TellorGettersLibrary, TellorTransfer, TellorGettersLibrary, and TellorStake\\n*/\\ncontract TellorGetters {\\n    using OldSafeMath for uint256;\\n\\n    using OldTellorTransfer for OldTellorStorage.TellorStorageStruct;\\n    using OldTellorGettersLibrary for OldTellorStorage.TellorStorageStruct;\\n    using OldTellorStake for OldTellorStorage.TellorStorageStruct;\\n\\n    OldTellorStorage.TellorStorageStruct tellor;\\n\\n    /**\\n    * @param _user address\\n    * @param _spender address\\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\\n    */\\n    function allowance(address _user, address _spender) external view returns (uint256) {\\n        return tellor.allowance(_user, _spender);\\n    }\\n\\n    /**\\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\\n    * @param _user address\\n    * @param _amount uint of amount\\n    * @return true if the user is alloed to trade the amount specified\\n    */\\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool) {\\n        return tellor.allowedToTrade(_user, _amount);\\n    }\\n\\n    /**\\n    * @dev Gets balance of owner specified\\n    * @param _user is the owner address used to look up the balance\\n    * @return Returns the balance associated with the passed in _user\\n    */\\n    function balanceOf(address _user) external view returns (uint256) {\\n        return tellor.balanceOf(_user);\\n    }\\n\\n    /**\\n    * @dev Queries the balance of _user at a specific _blockNumber\\n    * @param _user The address from which the balance will be retrieved\\n    * @param _blockNumber The block number when the balance is queried\\n    * @return The balance at _blockNumber\\n    */\\n    function balanceOfAt(address _user, uint256 _blockNumber) external view returns (uint256) {\\n        return tellor.balanceOfAt(_user, _blockNumber);\\n    }\\n\\n    /**\\n    * @dev This function tells you if a given challenge has been completed by a given miner\\n    * @param _challenge the challenge to search for\\n    * @param _miner address that you want to know if they solved the challenge\\n    * @return true if the _miner address provided solved the\\n    */\\n    function didMine(bytes32 _challenge, address _miner) external view returns (bool) {\\n        return tellor.didMine(_challenge, _miner);\\n    }\\n\\n    /**\\n    * @dev Checks if an address voted in a given dispute\\n    * @param _disputeId to look up\\n    * @param _address to look up\\n    * @return bool of whether or not party voted\\n    */\\n    function didVote(uint256 _disputeId, address _address) external view returns (bool) {\\n        return tellor.didVote(_disputeId, _address);\\n    }\\n\\n    /**\\n    * @dev allows Tellor to read data from the addressVars mapping\\n    * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\n    * These are examples of how the variables are saved within other functions:\\n    * addressVars[keccak256(\\\"_owner\\\")]\\n    * addressVars[keccak256(\\\"tellorContract\\\")]\\n    * @return address of the requested variable \\n    */\\n    function getAddressVars(bytes32 _data) external view returns (address) {\\n        return tellor.getAddressVars(_data);\\n    }\\n\\n    /**\\n    * @dev Gets all dispute variables\\n    * @param _disputeId to look up\\n    * @return bytes32 hash of dispute\\n    * @return bool executed where true if it has been voted on\\n    * @return bool disputeVotePassed\\n    * @return bool isPropFork true if the dispute is a proposed fork\\n    * @return address of reportedMiner\\n    * @return address of reportingParty\\n    * @return address of proposedForkAddress\\n    * @return uint of requestId\\n    * @return uint of timestamp\\n    * @return uint of value\\n    * @return uint of minExecutionDate\\n    * @return uint of numberOfVotes\\n    * @return uint of blocknumber\\n    * @return uint of minerSlot\\n    * @return uint of quorum\\n    * @return uint of fee\\n    * @return int count of the current tally\\n    */\\n    function getAllDisputeVars(uint256 _disputeId)\\n        public\\n        view\\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\\n    {\\n        return tellor.getAllDisputeVars(_disputeId);\\n    }\\n\\n    /**\\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\\n    */\\n    function getCurrentVariables() external view returns (bytes32, uint256, uint256, string memory, uint256, uint256) {\\n        return tellor.getCurrentVariables();\\n    }\\n\\n    /**\\n    * @dev Checks if a given hash of miner,requestId has been disputed\\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\\n    * @return uint disputeId\\n    */\\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256) {\\n        return tellor.getDisputeIdByDisputeHash(_hash);\\n    }\\n\\n    /**\\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\\n    * @param _disputeId is the dispute id;\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the disputeUintVars under the Dispute struct\\n    * @return uint value for the bytes32 data submitted\\n    */\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data) external view returns (uint256) {\\n        return tellor.getDisputeUintVars(_disputeId, _data);\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @return value for timestamp of last proof of work submited\\n    * @return true if the is a timestamp for the lastNewValue\\n    */\\n    function getLastNewValue() external view returns (uint256, bool) {\\n        return tellor.getLastNewValue();\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @param _requestId being requested\\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\\n    */\\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool) {\\n        return tellor.getLastNewValueById(_requestId);\\n    }\\n\\n    /**\\n    * @dev Gets blocknumber for mined timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up blocknumber\\n    * @return uint of the blocknumber which the dispute was mined\\n    */\\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp) external view returns (uint256) {\\n        return tellor.getMinedBlockNum(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return the 5 miners' addresses\\n    */\\n    function getMinersByRequestIdAndTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (address[5] memory) {\\n        return tellor.getMinersByRequestIdAndTimestamp(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Counts the number of values that have been submited for the request\\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\n    * request so far\\n    * @param _requestId the requestId to look up\\n    * @return uint count of the number of values received for the requestId\\n    */\\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256) {\\n        return tellor.getNewValueCountbyRequestId(_requestId);\\n    }\\n\\n    /**\\n    * @dev Getter function for the specified requestQ index\\n    * @param _index to look up in the requestQ array\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByRequestQIndex(uint256 _index) external view returns (uint256) {\\n        return tellor.getRequestIdByRequestQIndex(_index);\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on timestamp\\n    * @param _timestamp to check requestId\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByTimestamp(uint256 _timestamp) external view returns (uint256) {\\n        return tellor.getRequestIdByTimestamp(_timestamp);\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on the queryHash\\n    * @param _request is the hash(of string api and granularity) to check if a request already exists\\n    * @return uint requestId\\n    */\\n    function getRequestIdByQueryHash(bytes32 _request) external view returns (uint256) {\\n        return tellor.getRequestIdByQueryHash(_request);\\n    }\\n\\n    /**\\n    * @dev Getter function for the requestQ array\\n    * @return the requestQ arrray\\n    */\\n    function getRequestQ() public view returns (uint256[51] memory) {\\n        return tellor.getRequestQ();\\n    }\\n\\n    /**\\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\\n    * for the requestId specified\\n    * @param _requestId to look up\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the apiUintVars under the requestDetails struct\\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\\n    */\\n    function getRequestUintVars(uint256 _requestId, bytes32 _data) external view returns (uint256) {\\n        return tellor.getRequestUintVars(_requestId, _data);\\n    }\\n\\n    /**\\n    * @dev Gets the API struct variables that are not mappings\\n    * @param _requestId to look up\\n    * @return string of api to query\\n    * @return string of symbol of api to query\\n    * @return bytes32 hash of string\\n    * @return bytes32 of the granularity(decimal places) requested\\n    * @return uint of index in requestQ array\\n    * @return uint of current payout/tip for this requestId\\n    */\\n    function getRequestVars(uint256 _requestId) external view returns (string memory, string memory, bytes32, uint256, uint256, uint256) {\\n        return tellor.getRequestVars(_requestId);\\n    }\\n\\n    /**\\n    * @dev This function allows users to retireve all information about a staker\\n    * @param _staker address of staker inquiring about\\n    * @return uint current state of staker\\n    * @return uint startDate of staking\\n    */\\n    function getStakerInfo(address _staker) external view returns (uint256, uint256) {\\n        return tellor.getStakerInfo(_staker);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestampt to look up miners for\\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\\n    */\\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (uint256[5] memory) {\\n        return tellor.getSubmissionsByTimestamp(_requestId, _timestamp);\\n    }\\n\\n\\n    /**\\n    * @dev Gets the timestamp for the value based on their index\\n    * @param _requestID is the requestId to look up\\n    * @param _index is the value index to look up\\n    * @return uint timestamp\\n    */\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256) {\\n        return tellor.getTimestampbyRequestIDandIndex(_requestID, _index);\\n    }\\n\\n    /**\\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the uintVars under the TellorStorageStruct struct\\n    * This is an example of how data is saved into the mapping within other functions:\\n    * self.uintVars[keccak256(\\\"stakerCount\\\")]\\n    * @return uint of specified variable\\n    */\\n    function getUintVar(bytes32 _data) public view returns (uint256) {\\n        return tellor.getUintVar(_data);\\n    }\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\\n    */\\n    function getVariablesOnDeck() external view returns (uint256, uint256, string memory) {\\n        return tellor.getVariablesOnDeck();\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return bool true if requestId/timestamp is under dispute\\n    */\\n    function isInDispute(uint256 _requestId, uint256 _timestamp) external view returns (bool) {\\n        return tellor.isInDispute(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Retreive value from oracle based on timestamp\\n    * @param _requestId being requested\\n    * @param _timestamp to retreive data/value from\\n    * @return value for timestamp submitted\\n    */\\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256) {\\n        return tellor.retrieveData(_requestId, _timestamp);\\n    }\\n\\n    /**\\n    * @dev Getter for the total_supply of oracle tokens\\n    * @return uint total supply\\n    */\\n    function totalSupply() external view returns (uint256) {\\n        return tellor.totalSupply();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\\nlibrary OldSafeMath {\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n\\n  function add(int256 a, int256 b) internal pure returns (int256 c) {\\n    if(b > 0){\\n      c = a + b;\\n      assert(c >= a);\\n    }\\n    else{\\n      c = a + b;\\n      assert(c <= a);\\n    }\\n\\n  }\\n\\n  function max(uint a, uint b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  function max(int256 a, int256 b) internal pure returns (uint256) {\\n    return a > b ? uint(a) : uint(b);\\n  }\\n\\n  function min(uint a, uint b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n  \\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a * b;\\n    assert(a == 0 || c / a == b);\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n    if(b > 0){\\n      c = a - b;\\n      assert(c <= a);\\n    }\\n    else{\\n      c = a - b;\\n      assert(c >= a);\\n    }\\n\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldTellorStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Tellor Oracle Storage Library\\n * @dev Contains all the variables/structs used by Tellor\\n */\\n\\nlibrary OldTellorStorage {\\n    //Internal struct for use in proof-of-work submission\\n    struct Details {\\n        uint value;\\n        address miner;\\n    }\\n\\n    struct Dispute {\\n        bytes32 hash;//unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\\n        int tally;//current tally of votes for - against measure\\n        bool executed;//is the dispute settled\\n        bool disputeVotePassed;//did the vote pass?\\n        bool isPropFork; //true for fork proposal NEW\\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\\n        address reportingParty;//miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\\n        address proposedForkAddress;//new fork address (if fork proposal)\\n        mapping(bytes32 => uint) disputeUintVars;\\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\\\"requestId\\\")]\\n        //These are the variables saved in this mapping:\\n            // uint keccak256(\\\"requestId\\\");//apiID of disputed value\\n            // uint keccak256(\\\"timestamp\\\");//timestamp of distputed value\\n            // uint keccak256(\\\"value\\\"); //the value being disputed\\n            // uint keccak256(\\\"minExecutionDate\\\");//7 days from when dispute initialized\\n            // uint keccak256(\\\"numberOfVotes\\\");//the number of parties who have voted on the measure\\n            // uint keccak256(\\\"blockNumber\\\");// the blocknumber for which votes will be calculated from\\n            // uint keccak256(\\\"minerSlot\\\"); //index in dispute array\\n            // uint keccak256(\\\"quorum\\\"); //quorum for dispute vote NEW\\n            // uint keccak256(\\\"fee\\\"); //fee paid corresponding to dispute\\n        mapping (address => bool) voted; //mapping of address to whether or not they voted\\n    }\\n\\n    struct StakeInfo {\\n        uint currentStatus;//0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute\\n        uint startDate; //stake start date\\n    }\\n\\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\\n    struct  Checkpoint {\\n        uint128 fromBlock;// fromBlock is the block number that the value was generated from\\n        uint128 value;// value is the amount of tokens at a specific block number\\n    }\\n\\n    struct Request {\\n        string queryString;//id to string api\\n        string dataSymbol;//short name for api request\\n        bytes32 queryHash;//hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\\n        uint[]  requestTimestamps; //array of all newValueTimestamps requested\\n        mapping(bytes32 => uint) apiUintVars;\\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        //These are the variables saved in this mapping:\\n            // uint keccak256(\\\"granularity\\\"); //multiplier for miners\\n            // uint keccak256(\\\"requestQPosition\\\"); //index in requestQ\\n            // uint keccak256(\\\"totalTip\\\");//bonus portion of payout\\n        mapping(uint => uint) minedBlockNum;//[apiId][minedTimestamp]=>block.number\\n        mapping(uint => uint) finalValues;//This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\\n        mapping(uint => bool) inDispute;//checks if API id is in dispute or finalized.\\n        mapping(uint => address[5]) minersByValue;\\n        mapping(uint => uint[5])valuesByTimestamp;\\n    }\\n\\n    struct TellorStorageStruct {\\n        bytes32 currentChallenge; //current challenge to be solved\\n        uint[51]  requestQ; //uint50 array of the top50 requests by payment amount\\n        uint[]  newValueTimestamps; //array of all timestamps requested\\n        Details[5]  currentMiners; //This struct is for organizing the five mined values to find the median\\n        mapping(bytes32 => address) addressVars;\\n        //Address fields in the Tellor contract are saved the addressVars mapping\\n        //e.g. addressVars[keccak256(\\\"tellorContract\\\")] = address\\n        //These are the variables saved in this mapping:\\n            // address keccak256(\\\"tellorContract\\\");//Tellor address\\n            // address  keccak256(\\\"_owner\\\");//Tellor Owner address\\n            // address  keccak256(\\\"_deity\\\");//Tellor Owner that can do things at will\\n        mapping(bytes32 => uint) uintVars; \\n        //uint fields in the Tellor contract are saved the uintVars mapping\\n        //e.g. uintVars[keccak256(\\\"decimals\\\")] = uint\\n        //These are the variables saved in this mapping:\\n            // keccak256(\\\"decimals\\\");    //18 decimal standard ERC20\\n            // keccak256(\\\"disputeFee\\\");//cost to dispute a mined value\\n            // keccak256(\\\"disputeCount\\\");//totalHistoricalDisputes\\n            // keccak256(\\\"total_supply\\\"); //total_supply of the token in circulation\\n            // keccak256(\\\"stakeAmount\\\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\\n            // keccak256(\\\"stakerCount\\\"); //number of parties currently staked\\n            // keccak256(\\\"timeOfLastNewValue\\\"); // time of last challenge solved\\n            // keccak256(\\\"difficulty\\\"); // Difficulty of current block\\n            // keccak256(\\\"currentTotalTips\\\"); //value of highest api/timestamp PayoutPool\\n            // keccak256(\\\"currentRequestId\\\"); //API being mined--updates with the ApiOnQ Id\\n            // keccak256(\\\"requestCount\\\"); // total number of requests through the system\\n            // keccak256(\\\"slotProgress\\\");//Number of miners who have mined this value so far\\n            // keccak256(\\\"miningReward\\\");//Mining Reward in PoWo tokens given to all miners per value\\n            // keccak256(\\\"timeTarget\\\"); //The time between blocks (mined Oracle values)\\n        mapping(bytes32 => mapping(address=>bool)) minersByChallenge;//This is a boolean that tells you if a given challenge has been completed by a given miner\\n        mapping(uint => uint) requestIdByTimestamp;//minedTimestamp to apiId\\n        mapping(uint => uint) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\\n        mapping(uint => Dispute) disputesById;//disputeId=> Dispute details\\n        mapping (address => Checkpoint[]) balances; //balances of a party given blocks\\n        mapping(address => mapping (address => uint)) allowed; //allowance for a given party and approver\\n        mapping(address => StakeInfo)  stakerDetails;//mapping from a persons address to their staking info\\n        mapping(uint => Request) requestDetails;//mapping of apiID to details\\n        mapping(bytes32 => uint) requestIdByQueryHash;// api bytes32 gets an id = to count of requests array\\n        mapping(bytes32 => uint) disputeIdByDisputeHash;//maps a hash to an ID for each dispute\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldTellorTransfer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./OldSafeMath.sol\\\";\\nimport \\\"./OldTellorStorage.sol\\\";\\n\\n\\n/**\\n* @title Tellor Transfer\\n* @dev Contais the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\\n* reference this library for function's logic.\\n*/\\nlibrary OldTellorTransfer {\\n    using OldSafeMath for uint256;\\n\\n    event OldApproval(address indexed _owner, address indexed _spender, uint256 _value);//ERC20 OldApproval event\\n    event OldTransfer(address indexed _from, address indexed _to, uint256 _value);//ERC20 Transfer Event\\n\\n    /*Functions*/\\n    \\n    /**\\n    * @dev Allows for a transfer of tokens to _to\\n    * @param _to The address to send tokens to\\n    * @param _amount The amount of tokens to send\\n    * @return true if transfer is successful\\n    */\\n    function transfer(OldTellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\\n        doTransfer(self,msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @notice Send _amount tokens to _to from _from on the condition it\\n    * is approved by _from\\n    * @param _from The address holding the tokens being transferred\\n    * @param _to The address of the recipient\\n    * @param _amount The amount of tokens to be transferred\\n    * @return True if the transfer was successful\\n    */\\n    function transferFrom(OldTellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public returns (bool success) {\\n        require(self.allowed[_from][msg.sender] >= _amount);\\n        self.allowed[_from][msg.sender] -= _amount;\\n        doTransfer(self,_from, _to, _amount);\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @dev This function approves a _spender an _amount of tokens to use\\n    * @param _spender address\\n    * @param _amount amount the spender is being approved for\\n    * @return true if spender appproved successfully\\n    */\\n    function approve(OldTellorStorage.TellorStorageStruct storage self, address _spender, uint _amount) public returns (bool) {\\n        require(allowedToTrade(self,msg.sender,_amount));\\n        require(_spender != address(0));\\n        self.allowed[msg.sender][_spender] = _amount;\\n        emit OldApproval(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @param _user address of party with the balance\\n    * @param _spender address of spender of parties said balance\\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\\n    */\\n    function allowance(OldTellorStorage.TellorStorageStruct storage self,address _user, address _spender) public view returns (uint) {\\n       return self.allowed[_user][_spender]; \\n    }\\n\\n\\n    /**\\n    * @dev Completes POWO transfers by updating the balances on the current block number\\n    * @param _from address to transfer from\\n    * @param _to addres to transfer to\\n    * @param _amount to transfer\\n    */\\n    function doTransfer(OldTellorStorage.TellorStorageStruct storage self, address _from, address _to, uint _amount) public {\\n        require(_amount > 0);\\n        require(_to != address(0));\\n        require(allowedToTrade(self,_from,_amount)); //allowedToTrade checks the stakeAmount is removed from balance if the _user is staked\\n        uint previousBalance = balanceOfAt(self,_from, block.number);\\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\\n        previousBalance = balanceOfAt(self,_to, block.number);\\n        require(previousBalance + _amount >= previousBalance); // Check for overflow\\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\\n        emit OldTransfer(_from, _to, _amount);\\n    }\\n\\n\\n    /**\\n    * @dev Gets balance of owner specified\\n    * @param _user is the owner address used to look up the balance\\n    * @return Returns the balance associated with the passed in _user\\n    */\\n    function balanceOf(OldTellorStorage.TellorStorageStruct storage self,address _user) public view returns (uint) {\\n        return balanceOfAt(self,_user, block.number);\\n    }\\n\\n\\n    /**\\n    * @dev Queries the balance of _user at a specific _blockNumber\\n    * @param _user The address from which the balance will be retrieved\\n    * @param _blockNumber The block number when the balance is queried\\n    * @return The balance at _blockNumber specified\\n    */\\n    function balanceOfAt(OldTellorStorage.TellorStorageStruct storage self,address _user, uint _blockNumber) public view returns (uint) {\\n        if ((self.balances[_user].length == 0) || (self.balances[_user][0].fromBlock > _blockNumber)) {\\n                return 0;\\n        }\\n     else {\\n        return getBalanceAt(self.balances[_user], _blockNumber);\\n     }\\n    }\\n\\n\\n    /**\\n    * @dev Getter for balance for owner on the specified _block number\\n    * @param checkpoints gets the mapping for the balances[owner]\\n    * @param _block is the block number to search the balance on\\n    * @return the balance at the checkpoint\\n    */\\n    function getBalanceAt(OldTellorStorage.Checkpoint[] storage checkpoints, uint _block) view public returns (uint) {\\n        if (checkpoints.length == 0) return 0;\\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\\n            return checkpoints[checkpoints.length-1].value;\\n        if (_block < checkpoints[0].fromBlock) return 0;\\n        // Binary search of the value in the array\\n        uint min = 0;\\n        uint max = checkpoints.length-1;\\n        while (max > min) {\\n            uint mid = (max + min + 1)/ 2;\\n            if (checkpoints[mid].fromBlock<=_block) {\\n                min = mid;\\n            } else {\\n                max = mid-1;\\n            }\\n        }\\n        return checkpoints[min].value;\\n    }\\n\\n\\n    /**\\n    * @dev This function returns whether or not a given user is allowed to trade a given amount \\n    * and removing the staked amount from their balance if they are staked\\n    * @param _user address of user\\n    * @param _amount to check if the user can spend\\n    * @return true if they are allowed to spend the amount being checked\\n    */\\n    function allowedToTrade(OldTellorStorage.TellorStorageStruct storage self,address _user,uint _amount) public view returns(bool) {\\n        if(self.stakerDetails[_user].currentStatus >0){\\n            //Removes the stakeAmount from balance if the _user is staked\\n            if(balanceOf(self,_user).sub(self.uintVars[keccak256(\\\"stakeAmount\\\")]).sub(_amount) >= 0){\\n                return true;\\n            }\\n        }\\n        else if(balanceOf(self,_user).sub(_amount) >= 0){\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n\\n    /**\\n    * @dev Updates balance for from and to on the current block number via doTransfer\\n    * @param checkpoints gets the mapping for the balances[owner]\\n    * @param _value is the new balance\\n    */\\n    function updateBalanceAtNow(OldTellorStorage.Checkpoint[] storage checkpoints, uint _value) public {\\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\\n               OldTellorStorage.Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\\n               newCheckPoint.fromBlock =  uint128(block.number);\\n               newCheckPoint.value = uint128(_value);\\n        } else {\\n               OldTellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\\n               oldCheckPoint.value = uint128(_value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldTellorGettersLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./OldSafeMath.sol\\\";\\nimport \\\"./OldTellorStorage.sol\\\";\\nimport \\\"./OldUtilities.sol\\\";\\n\\n/**\\n* @title Tellor Getters Library\\n* @dev This is the getter library for all variables in the Tellor Tributes system. TellorGetters references this \\n* libary for the getters logic\\n*/\\nlibrary OldTellorGettersLibrary{\\n    using OldSafeMath for uint256;\\n\\n    event OldNewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\\n\\n    /*Functions*/\\n\\n    //The next two functions are onlyOwner functions.  For Tellor to be truly decentralized, we will need to transfer the Deity to the 0 address.\\n    //Only needs to be in library\\n    /**\\n    * @dev This function allows us to set a new Deity (or remove it) \\n    * @param _newDeity address of the new Deity of the tellor system \\n    */\\n    function changeDeity(OldTellorStorage.TellorStorageStruct storage self, address _newDeity) internal{\\n        require(self.addressVars[keccak256(\\\"_deity\\\")] == msg.sender);\\n        self.addressVars[keccak256(\\\"_deity\\\")] =_newDeity;\\n    }\\n\\n\\n    //Only needs to be in library\\n    /**\\n    * @dev This function allows the deity to upgrade the Tellor System\\n    * @param _tellorContract address of new updated TellorCore contract\\n    */\\n    function changeTellorContract(OldTellorStorage.TellorStorageStruct storage self,address _tellorContract) internal{\\n        require(self.addressVars[keccak256(\\\"_deity\\\")] == msg.sender);\\n        self.addressVars[keccak256(\\\"tellorContract\\\")]= _tellorContract;\\n        emit OldNewTellorAddress(_tellorContract);\\n    }\\n\\n\\n    /*Tellor Getters*/\\n\\n    /**\\n    * @dev This function tells you if a given challenge has been completed by a given miner\\n    * @param _challenge the challenge to search for\\n    * @param _miner address that you want to know if they solved the challenge\\n    * @return true if the _miner address provided solved the \\n    */\\n    function didMine(OldTellorStorage.TellorStorageStruct storage self, bytes32 _challenge,address _miner) internal view returns(bool){\\n        return self.minersByChallenge[_challenge][_miner];\\n    }\\n    \\n\\n    /**\\n    * @dev Checks if an address voted in a dispute\\n    * @param _disputeId to look up\\n    * @param _address of voting party to look up\\n    * @return bool of whether or not party voted\\n    */\\n    function didVote(OldTellorStorage.TellorStorageStruct storage self,uint _disputeId, address _address) internal view returns(bool){\\n        return self.disputesById[_disputeId].voted[_address];\\n    }\\n\\n\\n    /**\\n    * @dev allows Tellor to read data from the addressVars mapping\\n    * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed. \\n    * These are examples of how the variables are saved within other functions:\\n    * addressVars[keccak256(\\\"_owner\\\")]\\n    * addressVars[keccak256(\\\"tellorContract\\\")]\\n    */\\n    function getAddressVars(OldTellorStorage.TellorStorageStruct storage self, bytes32 _data) view internal returns(address){\\n        return self.addressVars[_data];\\n    }\\n\\n\\n    /**\\n    * @dev Gets all dispute variables\\n    * @param _disputeId to look up\\n    * @return bytes32 hash of dispute \\n    * @return bool executed where true if it has been voted on\\n    * @return bool disputeVotePassed\\n    * @return bool isPropFork true if the dispute is a proposed fork\\n    * @return address of reportedMiner\\n    * @return address of reportingParty\\n    * @return address of proposedForkAddress\\n    * @return uint of requestId\\n    * @return uint of timestamp\\n    * @return uint of value\\n    * @return uint of minExecutionDate\\n    * @return uint of numberOfVotes\\n    * @return uint of blocknumber\\n    * @return uint of minerSlot\\n    * @return uint of quorum\\n    * @return uint of fee\\n    * @return int count of the current tally\\n    */\\n    function getAllDisputeVars(OldTellorStorage.TellorStorageStruct storage self,uint _disputeId) internal view returns(bytes32, bool, bool, bool, address, address, address,uint[9] memory, int){\\n        OldTellorStorage.Dispute storage disp = self.disputesById[_disputeId];\\n        return(disp.hash,disp.executed, disp.disputeVotePassed, disp.isPropFork, disp.reportedMiner, disp.reportingParty,disp.proposedForkAddress,[disp.disputeUintVars[keccak256(\\\"requestId\\\")], disp.disputeUintVars[keccak256(\\\"timestamp\\\")], disp.disputeUintVars[keccak256(\\\"value\\\")], disp.disputeUintVars[keccak256(\\\"minExecutionDate\\\")], disp.disputeUintVars[keccak256(\\\"numberOfVotes\\\")], disp.disputeUintVars[keccak256(\\\"blockNumber\\\")], disp.disputeUintVars[keccak256(\\\"minerSlot\\\")], disp.disputeUintVars[keccak256(\\\"quorum\\\")],disp.disputeUintVars[keccak256(\\\"fee\\\")]],disp.tally);\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request \\n    */\\n    function getCurrentVariables(OldTellorStorage.TellorStorageStruct storage self) internal view returns(bytes32, uint, uint,string memory,uint,uint){    \\n        return (self.currentChallenge,self.uintVars[keccak256(\\\"currentRequestId\\\")],self.uintVars[keccak256(\\\"difficulty\\\")],self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].queryString,self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].apiUintVars[keccak256(\\\"granularity\\\")],self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].apiUintVars[keccak256(\\\"totalTip\\\")]);\\n    }\\n\\n\\n    /**\\n    * @dev Checks if a given hash of miner,requestId has been disputed\\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\\n    * @return uint disputeId\\n    */\\n    function getDisputeIdByDisputeHash(OldTellorStorage.TellorStorageStruct storage self,bytes32 _hash) internal view returns(uint){\\n        return  self.disputeIdByDisputeHash[_hash];\\n    }\\n\\n\\n    /**\\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\\n    * @param _disputeId is the dispute id;\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is \\n    * the variables/strings used to save the data in the mapping. The variables names are  \\n    * commented out under the disputeUintVars under the Dispute struct\\n    * @return uint value for the bytes32 data submitted\\n    */\\n    function getDisputeUintVars(OldTellorStorage.TellorStorageStruct storage self,uint _disputeId,bytes32 _data) internal view returns(uint){\\n        return self.disputesById[_disputeId].disputeUintVars[_data];\\n    }\\n\\n    \\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @return value for timestamp of last proof of work submited\\n    * @return true if the is a timestamp for the lastNewValue\\n    */\\n    function getLastNewValue(OldTellorStorage.TellorStorageStruct storage self) internal view returns(uint,bool){\\n        return (retrieveData(self,self.requestIdByTimestamp[self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")]], self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")]),true);\\n    }\\n\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @param _requestId being requested\\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\\n    */\\n    function getLastNewValueById(OldTellorStorage.TellorStorageStruct storage self,uint _requestId) internal view returns(uint,bool){\\n        OldTellorStorage.Request storage _request = self.requestDetails[_requestId]; \\n        if(_request.requestTimestamps.length > 0){\\n            return (retrieveData(self,_requestId,_request.requestTimestamps[_request.requestTimestamps.length - 1]),true);\\n        }\\n        else{\\n            return (0,false);\\n        }\\n    }\\n\\n\\n    /**\\n    * @dev Gets blocknumber for mined timestamp \\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up blocknumber\\n    * @return uint of the blocknumber which the dispute was mined\\n    */\\n    function getMinedBlockNum(OldTellorStorage.TellorStorageStruct storage self,uint _requestId, uint _timestamp) internal view returns(uint){\\n        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\\n    }\\n\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return the 5 miners' addresses\\n    */\\n    function getMinersByRequestIdAndTimestamp(OldTellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(address[5] memory){\\n        return self.requestDetails[_requestId].minersByValue[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Counts the number of values that have been submited for the request \\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\n    * request so far\\n    * @param _requestId the requestId to look up\\n    * @return uint count of the number of values received for the requestId\\n    */\\n    function getNewValueCountbyRequestId(OldTellorStorage.TellorStorageStruct storage self, uint _requestId) internal view returns(uint){\\n        return self.requestDetails[_requestId].requestTimestamps.length;\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for the specified requestQ index\\n    * @param _index to look up in the requestQ array\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByRequestQIndex(OldTellorStorage.TellorStorageStruct storage self, uint _index) internal view returns(uint){\\n        require(_index <= 50);\\n        return self.requestIdByRequestQIndex[_index];\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for requestId based on timestamp \\n    * @param _timestamp to check requestId\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByTimestamp(OldTellorStorage.TellorStorageStruct storage self, uint _timestamp) internal view returns(uint){    \\n        return self.requestIdByTimestamp[_timestamp];\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for requestId based on the qeuaryHash\\n    * @param _queryHash hash(of string api and granularity) to check if a request already exists\\n    * @return uint requestId\\n    */\\n    function getRequestIdByQueryHash(OldTellorStorage.TellorStorageStruct storage self, bytes32 _queryHash) internal view returns(uint){    \\n        return self.requestIdByQueryHash[_queryHash];\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for the requestQ array\\n    * @return the requestQ arrray\\n    */\\n    function getRequestQ(OldTellorStorage.TellorStorageStruct storage self) view internal returns(uint[51] memory){\\n        return self.requestQ;\\n    }\\n\\n\\n    /**\\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\\n    * for the requestId specified\\n    * @param _requestId to look up\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is \\n    * the variables/strings used to save the data in the mapping. The variables names are  \\n    * commented out under the apiUintVars under the requestDetails struct\\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\\n    */\\n    function getRequestUintVars(OldTellorStorage.TellorStorageStruct storage self,uint _requestId,bytes32 _data) internal view returns(uint){\\n        return self.requestDetails[_requestId].apiUintVars[_data];\\n    }\\n\\n\\n    /**\\n    * @dev Gets the API struct variables that are not mappings\\n    * @param _requestId to look up\\n    * @return string of api to query\\n    * @return string of symbol of api to query\\n    * @return bytes32 hash of string\\n    * @return bytes32 of the granularity(decimal places) requested\\n    * @return uint of index in requestQ array\\n    * @return uint of current payout/tip for this requestId\\n    */\\n    function getRequestVars(OldTellorStorage.TellorStorageStruct storage self,uint _requestId) internal view returns(string memory,string memory, bytes32,uint, uint, uint) {\\n        OldTellorStorage.Request storage _request = self.requestDetails[_requestId]; \\n        return (_request.queryString,_request.dataSymbol,_request.queryHash, _request.apiUintVars[keccak256(\\\"granularity\\\")],_request.apiUintVars[keccak256(\\\"requestQPosition\\\")],_request.apiUintVars[keccak256(\\\"totalTip\\\")]);\\n    }\\n\\n\\n    /**\\n    * @dev This function allows users to retireve all information about a staker\\n    * @param _staker address of staker inquiring about\\n    * @return uint current state of staker\\n    * @return uint startDate of staking\\n    */\\n    function getStakerInfo(OldTellorStorage.TellorStorageStruct storage self,address _staker) internal view returns(uint,uint){\\n        return (self.stakerDetails[_staker].currentStatus,self.stakerDetails[_staker].startDate);\\n    }\\n\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \\n    * @param _requestId to look up\\n    * @param _timestamp is the timestampt to look up miners for\\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\\n    */\\n    function getSubmissionsByTimestamp(OldTellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(uint[5] memory){\\n        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\\n    }\\n\\n\\n    /**\\n    * @dev Gets the timestamp for the value based on their index\\n    * @param _requestID is the requestId to look up\\n    * @param _index is the value index to look up\\n    * @return uint timestamp\\n    */\\n    function getTimestampbyRequestIDandIndex(OldTellorStorage.TellorStorageStruct storage self,uint _requestID, uint _index) internal view returns(uint){\\n        return self.requestDetails[_requestID].requestTimestamps[_index];\\n    }\\n\\n\\n    /**\\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is \\n    * the variables/strings used to save the data in the mapping. The variables names are  \\n    * commented out under the uintVars under the TellorStorageStruct struct\\n    * This is an example of how data is saved into the mapping within other functions: \\n    * self.uintVars[keccak256(\\\"stakerCount\\\")]\\n    * @return uint of specified variable  \\n    */ \\n    function getUintVar(OldTellorStorage.TellorStorageStruct storage self,bytes32 _data) view internal returns(uint){\\n        return self.uintVars[_data];\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\\n    */\\n    function getVariablesOnDeck(OldTellorStorage.TellorStorageStruct storage self) internal view returns(uint, uint,string memory){ \\n        uint newRequestId = getTopRequestID(self);\\n        return (newRequestId,self.requestDetails[newRequestId].apiUintVars[keccak256(\\\"totalTip\\\")],self.requestDetails[newRequestId].queryString);\\n    }\\n\\n\\n    /**\\n    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\\n    * @return uint _requestId of request with highest payout at the time the function is called\\n    */\\n    function getTopRequestID(OldTellorStorage.TellorStorageStruct storage self) internal view returns(uint _requestId){\\n            uint _max;\\n            uint _index;\\n            (_max,_index) = OldUtilities.getMax(self.requestQ);\\n             _requestId = self.requestIdByRequestQIndex[_index];\\n    }\\n\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return bool true if requestId/timestamp is under dispute\\n    */\\n    function isInDispute(OldTellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(bool){\\n        return self.requestDetails[_requestId].inDispute[_timestamp];\\n    }\\n\\n\\n    /**\\n    * @dev Retreive value from oracle based on requestId/timestamp\\n    * @param _requestId being requested\\n    * @param _timestamp to retreive data/value from\\n    * @return uint value for requestId/timestamp submitted\\n    */\\n    function retrieveData(OldTellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns (uint) {\\n        return self.requestDetails[_requestId].finalValues[_timestamp];\\n    }\\n\\n\\n    /**\\n    * @dev Getter for the total_supply of oracle tokens\\n    * @return uint total supply\\n    */\\n    function totalSupply(OldTellorStorage.TellorStorageStruct storage self) internal view returns (uint) {\\n       return self.uintVars[keccak256(\\\"total_supply\\\")];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldTellorStake.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./OldTellorStorage.sol\\\";\\nimport \\\"./OldTellorTransfer.sol\\\";\\nimport \\\"./OldTellorDispute.sol\\\";\\n\\n/**\\n* itle Tellor Dispute\\n* @dev Contais the methods related to miners staking and unstaking. Tellor.sol \\n* references this library for function's logic.\\n*/\\n\\nlibrary OldTellorStake {\\n    event OldNewStake(address indexed _sender);//Emits upon new staker\\n    event OldStakeWithdrawn(address indexed _sender);//Emits when a staker is now no longer staked\\n    event OldStakeWithdrawRequested(address indexed _sender);//Emits when a staker begins the 7 day withdraw period\\n\\n    /*Functions*/\\n    \\n    /**\\n    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\\n    * This function is called by the constructor function on TellorMaster.sol\\n    */\\n    function init(OldTellorStorage.TellorStorageStruct storage self) public{\\n        require(self.uintVars[keccak256(\\\"decimals\\\")] == 0);\\n        //Give this contract 6000 Tellor Tributes so that it can stake the initial 6 miners\\n        OldTellorTransfer.updateBalanceAtNow(self.balances[address(this)], 2**256-1 - 6000e18);\\n\\n        // //the initial 5 miner addresses are specfied below\\n        // //changed payable[5] to 6\\n        address payable[6] memory _initalMiners = [address(0xE037EC8EC9ec423826750853899394dE7F024fee),\\n        address(0xcdd8FA31AF8475574B8909F135d510579a8087d3),\\n        address(0xb9dD5AfD86547Df817DA2d0Fb89334A6F8eDd891),\\n        address(0x230570cD052f40E14C14a81038c6f3aa685d712B),\\n        address(0x3233afA02644CCd048587F8ba6e99b3C00A34DcC),\\n        address(0xe010aC6e0248790e08F42d5F697160DEDf97E024)];\\n        //Stake each of the 5 miners specified above\\n        for(uint i=0;i<6;i++){//6th miner to allow for dispute\\n            //Miner balance is set at 1000e18 at the block that this function is ran\\n            OldTellorTransfer.updateBalanceAtNow(self.balances[_initalMiners[i]],1000e18);\\n\\n            OldnewStake(self, _initalMiners[i]);\\n        }\\n\\n        //update the total suppply\\n        self.uintVars[keccak256(\\\"total_supply\\\")] += 6000e18;//6th miner to allow for dispute\\n        //set Constants\\n        self.uintVars[keccak256(\\\"decimals\\\")] = 18;\\n        self.uintVars[keccak256(\\\"targetMiners\\\")] = 200;\\n        self.uintVars[keccak256(\\\"stakeAmount\\\")] = 1000e18;\\n        self.uintVars[keccak256(\\\"disputeFee\\\")] = 970e18;\\n        self.uintVars[keccak256(\\\"timeTarget\\\")]= 600;\\n        self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")] = now - now  % self.uintVars[keccak256(\\\"timeTarget\\\")];\\n        self.uintVars[keccak256(\\\"difficulty\\\")] = 1;\\n    }\\n\\n\\n    /**\\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\\n    * can withdraw the deposit\\n    */\\n    function requestStakingWithdraw(OldTellorStorage.TellorStorageStruct storage self) public {\\n        OldTellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\\n        //Require that the miner is staked\\n        require(stakes.currentStatus == 1);\\n\\n        //Change the miner staked to locked to be withdrawStake\\n        stakes.currentStatus = 2;\\n\\n        //Change the startDate to now since the lock up period begins now\\n        //and the miner can only withdraw 7 days later from now(check the withdraw function)\\n        stakes.startDate = now -(now % 86400);\\n\\n        //Reduce the staker count\\n        self.uintVars[keccak256(\\\"stakerCount\\\")] -= 1;\\n        OldTellorDispute.updateDisputeFee(self);\\n        emit OldStakeWithdrawRequested(msg.sender);\\n    }\\n\\n\\n    /**\\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request \\n    */\\n    function withdrawStake(OldTellorStorage.TellorStorageStruct storage self) public {\\n        OldTellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have \\n        //passed by since they locked for withdraw\\n        require(now - (now % 86400) - stakes.startDate >= 7 days);\\n        require(stakes.currentStatus == 2);\\n        stakes.currentStatus = 0;\\n        emit OldStakeWithdrawn(msg.sender);\\n    }\\n\\n\\n    /**\\n    * @dev This function allows miners to deposit their stake.\\n    */\\n    function depositStake(OldTellorStorage.TellorStorageStruct storage self) public {\\n      OldnewStake(self, msg.sender);\\n      //self adjusting disputeFee\\n      OldTellorDispute.updateDisputeFee(self);\\n    }\\n\\n    /**\\n    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\\n    * The function updates their status/state and status start date so they are locked it so they can't withdraw\\n    * and updates the number of stakers in the system.\\n    */\\n    function OldnewStake(OldTellorStorage.TellorStorageStruct storage self, address staker) internal {\\n        require(OldTellorTransfer.balanceOf(self,staker) >= self.uintVars[keccak256(\\\"stakeAmount\\\")]);\\n        //Ensure they can only stake if they are not currrently staked or if their stake time frame has ended\\n        //and they are currently locked for witdhraw\\n        require(self.stakerDetails[staker].currentStatus == 0 || self.stakerDetails[staker].currentStatus == 2);\\n        self.uintVars[keccak256(\\\"stakerCount\\\")] += 1;\\n        self.stakerDetails[staker] = OldTellorStorage.StakeInfo({\\n            currentStatus: 1,\\n            //this resets their stake start date to today\\n            startDate: now - (now % 86400)\\n        });\\n        emit OldNewStake(staker);\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldUtilities.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n//Functions for retrieving min and Max in 51 length array (requestQ)\\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\\n\\nlibrary OldUtilities{\\n\\n    /**\\n    * @dev Returns the minimum value in an array.\\n    */\\n    function getMax(uint[51] memory data) internal pure returns(uint256 max,uint256 maxIndex) {\\n        max = data[1];\\n        maxIndex;\\n        for(uint i=1;i < data.length;i++){\\n            if(data[i] > max){\\n                max = data[i];\\n                maxIndex = i;\\n                }\\n        }\\n    }\\n\\n    /**\\n    * @dev Returns the minimum value in an array.\\n    */\\n    function getMin(uint[51] memory data) internal pure returns(uint256 min,uint256 minIndex) {\\n        minIndex = data.length - 1;\\n        min = data[minIndex];\\n        for(uint i = data.length-1;i > 0;i--) {\\n            if(data[i] < min) {\\n                min = data[i];\\n                minIndex = i;\\n            }\\n        }\\n  }\\n\\n\\n\\n\\n  // /// @dev Returns the minimum value and position in an array.\\n  // //@note IT IGNORES THE 0 INDEX\\n  //   function getMin(uint[51] memory arr) internal pure returns (uint256 min, uint256 minIndex) {\\n  //     assembly {\\n  //         minIndex := 50\\n  //         min := mload(add(arr, mul(minIndex , 0x20)))\\n  //         for {let i := 49 } gt(i,0) { i := sub(i, 1) } {\\n  //             let item := mload(add(arr, mul(i, 0x20)))\\n  //             if lt(item,min){\\n  //                 min := item\\n  //                 minIndex := i\\n  //             }\\n  //         }\\n  //     }\\n  //   }\\n\\n\\n  \\n  // function getMax(uint256[51] memory arr) internal pure returns (uint256 max, uint256 maxIndex) {\\n  //     assembly {\\n  //         for { let i := 0 } lt(i,51) { i := add(i, 1) } {\\n  //             let item := mload(add(arr, mul(i, 0x20)))\\n  //             if lt(max, item) {\\n  //                 max := item\\n  //                 maxIndex := i\\n  //             }\\n  //         }\\n  //     }\\n  //   }\\n\\n\\n\\n\\n\\n  }\\n\"\r\n    },\r\n    \"tellorlegacy/contracts/oldContracts/libraries/OldTellorDispute.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./OldTellorStorage.sol\\\";\\nimport \\\"./OldTellorTransfer.sol\\\";\\n//import \\\"./OldSafeMath.sol\\\";\\n\\n/**\\n* @title Tellor Dispute\\n* @dev Contais the methods related to disputes. Tellor.sol references this library for function's logic.\\n*/\\n\\n\\nlibrary OldTellorDispute {\\n    using OldSafeMath for uint256;\\n    using OldSafeMath for int256;\\n\\n    event OldNewDispute(uint indexed _disputeId, uint indexed _requestId, uint _timestamp, address _miner);//emitted when a new dispute is initialized\\n    event OldVoted(uint indexed _disputeID, bool _position, address indexed _voter);//emitted when a new vote happens\\n    event OldDisputeVoteTallied(uint indexed _disputeID, int _result,address indexed _reportedMiner,address _reportingParty, bool _active);//emitted upon dispute tally\\n    event OldNewTellorAddress(address _newTellor); //emmited when a proposed fork is Oldvoted true\\n\\n    /*Functions*/\\n    \\n    /**\\n    * @dev Helps initialize a dispute by assigning it a disputeId\\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\\n    * invalidated value information to POS voting\\n    * @param _requestId being disputed\\n    * @param _timestamp being disputed\\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\\n    * requires 5 miners to submit a value.\\n    */\\n    function beginDispute(OldTellorStorage.TellorStorageStruct storage self,uint _requestId, uint _timestamp,uint _minerIndex) public {\\n        OldTellorStorage.Request storage _request = self.requestDetails[_requestId];\\n        //require that no more than a day( (24 hours * 60 minutes)/10minutes=144 blocks) has gone by since the value was \\\"mined\\\"\\n        require(block.number- _request.minedBlockNum[_timestamp]<= 144);//This is \\n        require(_request.minedBlockNum[_timestamp] > 0);\\n        require(_minerIndex < 5);\\n        \\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\\n        //provided by the party initiating the dispute\\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\\n        bytes32 _hash = keccak256(abi.encodePacked(_miner,_requestId,_timestamp));\\n        \\n        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\\n        require(self.disputeIdByDisputeHash[_hash] == 0);\\n        OldTellorTransfer.doTransfer(self, msg.sender,address(this), self.uintVars[keccak256(\\\"disputeFee\\\")]);\\n        \\n        //Increase the dispute count by 1\\n        self.uintVars[keccak256(\\\"disputeCount\\\")] =  self.uintVars[keccak256(\\\"disputeCount\\\")] + 1;\\n        \\n        //Sets the new disputeCount as the disputeId\\n        uint disputeId = self.uintVars[keccak256(\\\"disputeCount\\\")];\\n        \\n        //maps the dispute hash to the disputeId\\n        self.disputeIdByDisputeHash[_hash] = disputeId;\\n        //maps the dispute to the Dispute struct\\n        self.disputesById[disputeId] = OldTellorStorage.Dispute({\\n            hash:_hash,\\n            isPropFork: false,\\n            reportedMiner: _miner,\\n            reportingParty: msg.sender,\\n            proposedForkAddress:address(0),\\n            executed: false,\\n            disputeVotePassed: false,\\n            tally: 0\\n            });\\n        \\n        //Saves all the dispute variables for the disputeId\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"requestId\\\")] = _requestId;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"timestamp\\\")] = _timestamp;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"value\\\")] = _request.valuesByTimestamp[_timestamp][_minerIndex];\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] = now + 7 days;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"blockNumber\\\")] = block.number;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minerSlot\\\")] = _minerIndex;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"fee\\\")]  = self.uintVars[keccak256(\\\"disputeFee\\\")];\\n        \\n        //Values are sorted as they come in and the official value is the median of the first five\\n        //So the \\\"official value\\\" miner is always minerIndex==2. If the official value is being \\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\\n        if(_minerIndex == 2){\\n            self.requestDetails[_requestId].inDispute[_timestamp] = true;\\n        }\\n        self.stakerDetails[_miner].currentStatus = 3;\\n        emit OldNewDispute(disputeId,_requestId,_timestamp,_miner);\\n    }\\n\\n\\n    /**\\n    * @dev Allows token holders to vote\\n    * @param _disputeId is the dispute id\\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\\n    */\\n    function vote(OldTellorStorage.TellorStorageStruct storage self, uint _disputeId, bool _supportsDispute) public {\\n        OldTellorStorage.Dispute storage disp = self.disputesById[_disputeId];\\n        \\n        //Get the voteWeight or the balance of the user at the time/blockNumber the disupte began\\n        uint voteWeight = OldTellorTransfer.balanceOfAt(self,msg.sender,disp.disputeUintVars[keccak256(\\\"blockNumber\\\")]);\\n        \\n        //Require that the msg.sender has not Oldvoted\\n        require(disp.voted[msg.sender] != true);\\n        \\n        //Requre that the user had a balance >0 at time/blockNumber the disupte began\\n        require(voteWeight > 0);\\n        \\n        //ensures miners that are under dispute cannot vote\\n        require(self.stakerDetails[msg.sender].currentStatus != 3);\\n        \\n        //Update user voting status to true\\n        disp.voted[msg.sender] = true;\\n        \\n        //Update the number of votes for the dispute\\n        disp.disputeUintVars[keccak256(\\\"numberOfVotes\\\")] += 1;\\n        \\n        //Update the quorum by adding the voteWeight\\n        disp.disputeUintVars[keccak256(\\\"quorum\\\")] += voteWeight; \\n        \\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\\n        //otherwise decrease it\\n        if (_supportsDispute) {\\n            disp.tally = disp.tally.add(int(voteWeight));\\n        } else {\\n            disp.tally = disp.tally.sub(int(voteWeight));\\n        }\\n        \\n        //Let the network know the user has Oldvoted on the dispute and their casted vote\\n        emit OldVoted(_disputeId,_supportsDispute,msg.sender);\\n    }\\n\\n\\n    /**\\n    * @dev tallies the votes.\\n    * @param _disputeId is the dispute id\\n    */\\n    function tallyVotes(OldTellorStorage.TellorStorageStruct storage self, uint _disputeId) public {\\n        OldTellorStorage.Dispute storage disp = self.disputesById[_disputeId];\\n        OldTellorStorage.Request storage _request = self.requestDetails[disp.disputeUintVars[keccak256(\\\"requestId\\\")]];\\n\\n        //Ensure this has not already been executed/tallied\\n        require(disp.executed == false);\\n\\n        //Ensure the time for voting has elapsed\\n        require(now > disp.disputeUintVars[keccak256(\\\"minExecutionDate\\\")]);  \\n\\n        //If the vote is not a proposed fork \\n        if (disp.isPropFork== false){\\n        OldTellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];  \\n            //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported \\n            // miner and transfer the stakeAmount and dispute fee to the reporting party \\n            if (disp.tally > 0 ) { \\n\\n                //Changing the currentStatus and startDate unstakes the reported miner and allows for the\\n                //transfer of the stakeAmount\\n                stakes.currentStatus = 0;\\n                stakes.startDate = now -(now % 86400);\\n\\n                //Decreases the stakerCount since the miner's stake is being slashed\\n                self.uintVars[keccak256(\\\"stakerCount\\\")]--;\\n                updateDisputeFee(self);\\n\\n                //Transfers the StakeAmount from the reporded miner to the reporting party\\n                OldTellorTransfer.doTransfer(self, disp.reportedMiner,disp.reportingParty, self.uintVars[keccak256(\\\"stakeAmount\\\")]);\\n                \\n                //Returns the dispute fee to the reportingParty\\n                OldTellorTransfer.doTransfer(self, address(this),disp.reportingParty,disp.disputeUintVars[keccak256(\\\"fee\\\")]);\\n                \\n                //Set the dispute state to passed/true\\n                disp.disputeVotePassed = true;\\n\\n                //If the dispute was succeful(miner found guilty) then update the timestamp value to zero\\n                //so that users don't use this datapoint\\n                if(_request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] == true){\\n                    _request.finalValues[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] = 0;\\n                }\\n\\n            //If the vote for disputing a value is unsuccesful then update the miner status from being on \\n            //dispute(currentStatus=3) to staked(currentStatus =1) and tranfer the dispute fee to the miner\\n            } else {\\n                //Update the miner's current status to staked(currentStatus = 1)\\n                stakes.currentStatus = 1;              \\n                //tranfer the dispute fee to the miner\\n                OldTellorTransfer.doTransfer(self,address(this),disp.reportedMiner,disp.disputeUintVars[keccak256(\\\"fee\\\")]);\\n                if(_request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] == true){\\n                    _request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] = false;\\n                }\\n            }\\n        //If the vote is for a proposed fork require a 20% quorum before excecuting the update to the new tellor contract address\\n        } else {\\n            if(disp.tally > 0 ){\\n                require(disp.disputeUintVars[keccak256(\\\"quorum\\\")] >  (self.uintVars[keccak256(\\\"total_supply\\\")] * 20 / 100));\\n                self.addressVars[keccak256(\\\"tellorContract\\\")] = disp.proposedForkAddress;\\n                disp.disputeVotePassed = true;\\n                emit OldNewTellorAddress(disp.proposedForkAddress);\\n            }\\n        }\\n        \\n        //update the dispute status to executed\\n        disp.executed = true;\\n        emit OldDisputeVoteTallied(_disputeId,disp.tally,disp.reportedMiner,disp.reportingParty,disp.disputeVotePassed);\\n    }\\n\\n\\n    /**\\n    * @dev Allows for a fork to be proposed\\n    * @param _propOldNewTellorAddress address for new proposed Tellor\\n    */\\n    function proposeFork(OldTellorStorage.TellorStorageStruct storage self, address _propOldNewTellorAddress) public {\\n        bytes32 _hash = keccak256(abi.encodePacked(_propOldNewTellorAddress));\\n        require(self.disputeIdByDisputeHash[_hash] == 0);\\n        OldTellorTransfer.doTransfer(self, msg.sender,address(this), self.uintVars[keccak256(\\\"disputeFee\\\")]);//This is the fork fee\\n        self.uintVars[keccak256(\\\"disputeCount\\\")]++;\\n        uint disputeId = self.uintVars[keccak256(\\\"disputeCount\\\")];\\n        self.disputeIdByDisputeHash[_hash] = disputeId;\\n        self.disputesById[disputeId] = OldTellorStorage.Dispute({\\n            hash: _hash,\\n            isPropFork: true,\\n            reportedMiner: msg.sender, \\n            reportingParty: msg.sender, \\n            proposedForkAddress: _propOldNewTellorAddress,\\n            executed: false,\\n            disputeVotePassed: false,\\n            tally: 0\\n            }); \\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"blockNumber\\\")] = block.number;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"fee\\\")]  = self.uintVars[keccak256(\\\"disputeFee\\\")];\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] = now + 7 days;\\n    }\\n    \\n\\n    /**\\n    * @dev this function allows the dispute fee to fluctuate based on the number of miners on the system.\\n    * The floor for the fee is 15e18.\\n    */\\n    function updateDisputeFee(OldTellorStorage.TellorStorageStruct storage self) public {\\n            //if the number of staked miners divided by the target count of staked miners is less than 1\\n            if(self.uintVars[keccak256(\\\"stakerCount\\\")]*1000/self.uintVars[keccak256(\\\"targetMiners\\\")] < 1000){\\n                //Set the dispute fee at stakeAmt * (1- stakerCount/targetMiners)\\n                //or at the its minimum of 15e18 \\n                self.uintVars[keccak256(\\\"disputeFee\\\")] = OldSafeMath.max(15e18,self.uintVars[keccak256(\\\"stakeAmount\\\")].mul(1000 - self.uintVars[keccak256(\\\"stakerCount\\\")]*1000/self.uintVars[keccak256(\\\"targetMiners\\\")])/1000);\\n            }\\n            else{\\n                //otherwise set the dispute fee at 15e18 (the floor/minimum fee allowed)\\n                self.uintVars[keccak256(\\\"disputeFee\\\")] = 15e18;\\n            }\\n    }\\n}\\n\"\r\n    },\r\n    \"usingtellor/contracts/TellorPlayground.sol\": {\r\n      \"content\": \"pragma solidity >0.5.16;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ncontract TellorPlayground {\\n    using SafeMath for uint256;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event TipAdded(\\n        address indexed _sender,\\n        uint256 indexed _requestId,\\n        uint256 _tip\\n    );\\n    event NewValue(uint256 _requestId, uint256 _time, uint256 _value);\\n\\n    mapping(uint256 => mapping(uint256 => uint256)) public values; //requestId -> timestamp -> value\\n    mapping(uint256 => mapping(uint256 => bool)) public isDisputed; //requestId -> timestamp -> value\\n    mapping(uint256 => uint256[]) public timestamps;\\n    mapping(address => uint256) public balances;\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor() public {\\n        _name = \\\"TellorPlayground\\\";\\n        _symbol = \\\"TRBP\\\";\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Public function to mint tokens for the passed address\\n     * @param user The address which will own the tokens\\n     *\\n     */\\n    function faucet(address user) external {\\n        _mint(user, 1000 ether);\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the total supply of the token.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the balance of a given user.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from user to another\\n     * @param recipient The destination address\\n     * @param amount The amount of tokens, including decimals, to transfer\\n     * @return bool If the transfer succeeded\\n     *\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Retruns the amount that an address is alowed to spend of behalf of other\\n     * @param owner The address which owns the tokens\\n     * @param spender The address that will use the tokens\\n     * @return uint256 Indicating the amount of allowed tokens\\n     *\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Approves  amount that an address is alowed to spend of behalf of other\\n     * @param spender The address which user the tokens\\n     * @param amount The amount that msg.sender is allowing spender to use\\n     * @return bool If the transaction succeeded\\n     *\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from user to another\\n     * @param sender The address which owns the tokens\\n     * @param recipient The destination address\\n     * @param amount The amount of tokens, including decimals, to transfer\\n     * @return bool If the transfer succeeded\\n     *\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            msg.sender,\\n            _allowances[sender][msg.sender].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Helper function to increase the allowance\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Helper function to increase the allowance\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to perform token transfer\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to create new tokens for the user\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn tokens for the user\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to approve tokens for the user\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev A mock function to submit a value to be read withoun miners needed\\n     * @param _requestId The tellorId to associate the value to\\n     * @param _value the value for the requestId\\n     */\\n    function submitValue(uint256 _requestId, uint256 _value) external {\\n        values[_requestId][block.timestamp] = _value;\\n        timestamps[_requestId].push(block.timestamp);\\n        emit NewValue(_requestId, block.timestamp, _value);\\n    }\\n\\n    /**\\n     * @dev A mock function to create a dispute\\n     * @param _requestId The tellorId to be disputed\\n     * @param _timestamp the timestamp that indentifies for the value\\n     */\\n    function disputeValue(uint256 _requestId, uint256 _timestamp) external {\\n        values[_requestId][_timestamp] = 0;\\n        isDisputed[_requestId][_timestamp] = true;\\n    }\\n\\n    /**\\n     * @dev Retreive value from oracle based on requestId/timestamp\\n     * @param _requestId being requested\\n     * @param _timestamp to retreive data/value from\\n     * @return uint value for requestId/timestamp submitted\\n     */\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return values[_requestId][_timestamp];\\n    }\\n\\n    /**\\n     * @dev Gets if the mined value for the specified requestId/_timestamp is currently under dispute\\n     * @param _requestId to looku p\\n     * @param _timestamp is the timestamp to look up miners for\\n     * @return bool true if requestId/timestamp is under dispute\\n     */\\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return isDisputed[_requestId][_timestamp];\\n    }\\n\\n    /**\\n     * @dev Counts the number of values that have been submited for the request\\n     * @param _requestId the requestId to look up\\n     * @return uint count of the number of values received for the requestId\\n     */\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return timestamps[_requestId].length;\\n    }\\n\\n    /**\\n     * @dev Gets the timestamp for the value based on their index\\n     * @param _requestId is the requestId to look up\\n     * @param index is the value index to look up\\n     * @return uint timestamp\\n     */\\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 len = timestamps[_requestId].length;\\n        if (len == 0 || len <= index) return 0;\\n        return timestamps[_requestId][index];\\n    }\\n\\n    /**\\n     * @dev Adds a tip to a given request Id.\\n     * @param _requestId is the requestId to look up\\n     * @param _amount is the amount of tips\\n     */\\n    function addTip(uint256 _requestId, uint256 _amount) external {\\n        _transfer(msg.sender, address(this), _amount);\\n        emit TipAdded(msg.sender, _requestId, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// This file exists only so that the compile task creates the artifacts\\n// which are then used for the tests.\\n\\npragma solidity >=0.5.16;\\n\\nimport \\\"tellorcore/contracts/libraries/TellorTransfer.sol\\\";\\nimport \\\"tellorcore/contracts/libraries/TellorLibrary.sol\\\";\\nimport \\\"tellorlegacy/contracts/oldContracts/libraries/OldTellorTransfer.sol\\\";\\nimport \\\"tellorcore/contracts/TellorGetters.sol\\\";\\nimport \\\"tellorcore/contracts/Tellor.sol\\\";\\nimport \\\"tellorcore/contracts/TellorMaster.sol\\\";\\n\\ncontract TellorTest is\\n    Tellor // TellorMaster has too many legacy dependancies to just import Tellor.\\n{\\n    constructor() public {\\n        tellor.uintVars[keccak256(\\\"stakeAmount\\\")] = 500e18;\\n        tellor.uintVars[keccak256(\\\"disputeFee\\\")] = 500e18;\\n\\n        tellor.uintVars[keccak256(\\\"difficulty\\\")] = 1;\\n        tellor.uintVars[keccak256(\\\"targetMiners\\\")] = 100;\\n\\n        // This is used when calculating the current reward so can't be zero.\\n        tellor.uintVars[keccak256(\\\"timeOfLastNewValue\\\")] = now;\\n\\n        // Set the initial request ids to mine.\\n        tellor.currentMiners[0].value = 1;\\n        tellor.currentMiners[1].value = 2;\\n        tellor.currentMiners[2].value = 3;\\n        tellor.currentMiners[3].value = 4;\\n        tellor.currentMiners[4].value = 5;\\n\\n        tellor.addressVars[keccak256(\\\"_owner\\\")] = msg.sender;\\n    }\\n\\n    function setBalance(address _address, uint256 _amount) public {\\n        TellorTransfer.updateBalanceAtNow(\\n            tellor.balances[_address], // `tellor` variable is inherited from the Tellor contract.\\n            _amount * 1e18\\n        );\\n    }\\n\\n    // Library functions that take `storage` as an argument need to be reimplemented\\n    // `storage` argument can't be passed from an external call and\\n    // because of this not added to the generated ABI this requiring re-implementation.\\n\\n    function balanceOf(address _address) public view returns (uint256) {\\n        return TellorTransfer.balanceOf(tellor, _address);\\n    }\\n\\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            TellorGettersLibrary.getRequestUintVars(tellor, _requestId, _data);\\n    }\\n\\n    function getUintVar(bytes32 _data) external view returns (uint256) {\\n        return TellorGettersLibrary.getUintVar(tellor, _data);\\n    }\\n\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            TellorGettersLibrary.getNewValueCountbyRequestId(\\n                tellor,\\n                _requestId\\n            );\\n    }\\n\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            TellorGettersLibrary.getTimestampbyRequestIDandIndex(\\n                tellor,\\n                _requestID,\\n                _index\\n            );\\n    }\\n\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            TellorGettersLibrary.retrieveData(tellor, _requestId, _timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/TellorTransfer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TellorStorage.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n* @title Tellor Transfer\\n* @dev Contains the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\\n* reference this library for function's logic.\\n*/\\nlibrary TellorTransfer {\\n    using SafeMath for uint256;\\n\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //ERC20 Approval event\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\\n\\n    bytes32 public constant stakeAmount = 0x7be108969d31a3f0b261465c71f2b0ba9301cd914d55d9091c3b36a49d4d41b2; //keccak256(\\\"stakeAmount\\\")\\n\\n    /*Functions*/\\n\\n    /**\\n    * @dev Allows for a transfer of tokens to _to\\n    * @param _to The address to send tokens to\\n    * @param _amount The amount of tokens to send\\n    * @return true if transfer is successful\\n    */\\n    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\\n        doTransfer(self, msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n    * @notice Send _amount tokens to _to from _from on the condition it\\n    * is approved by _from\\n    * @param _from The address holding the tokens being transferred\\n    * @param _to The address of the recipient\\n    * @param _amount The amount of tokens to be transferred\\n    * @return True if the transfer was successful\\n    */\\n    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount)\\n        public\\n        returns (bool success)\\n    {\\n        require(self.allowed[_from][msg.sender] >= _amount, \\\"Allowance is wrong\\\");\\n        self.allowed[_from][msg.sender] -= _amount;\\n        doTransfer(self, _from, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev This function approves a _spender an _amount of tokens to use\\n    * @param _spender address\\n    * @param _amount amount the spender is being approved for\\n    * @return true if spender appproved successfully\\n    */\\n    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint256 _amount) public returns (bool) {\\n        require(_spender != address(0), \\\"Spender is 0-address\\\");\\n        require(self.allowed[msg.sender][_spender] == 0 || _amount == 0, \\\"Spender is already approved\\\");\\n        self.allowed[msg.sender][_spender] = _amount;\\n        emit Approval(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n    * @param _user address of party with the balance\\n    * @param _spender address of spender of parties said balance\\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\\n    */\\n    function allowance(TellorStorage.TellorStorageStruct storage self, address _user, address _spender) public view returns (uint256) {\\n        return self.allowed[_user][_spender];\\n    }\\n\\n    /**\\n    * @dev Completes POWO transfers by updating the balances on the current block number\\n    * @param _from address to transfer from\\n    * @param _to addres to transfer to\\n    * @param _amount to transfer\\n    */\\n    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public {\\n        console.log(\\\"transfering\\\",_from, _amount);\\n        require(_amount != 0, \\\"Tried to send non-positive amount\\\");\\n        require(_to != address(0), \\\"Receiver is 0 address\\\");\\n        require(allowedToTrade(self, _from, _amount), \\\"Should have sufficient balance to trade\\\");\\n        uint256 previousBalance = balanceOf(self, _from);\\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\\n        previousBalance = balanceOf(self,_to);\\n        require(previousBalance + _amount >= previousBalance, \\\"Overflow happened\\\"); // Check for overflow\\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    /**\\n    * @dev Gets balance of owner specified\\n    * @param _user is the owner address used to look up the balance\\n    * @return Returns the balance associated with the passed in _user\\n    */\\n    function balanceOf(TellorStorage.TellorStorageStruct storage self, address _user) public view returns (uint256) {\\n        return balanceOfAt(self, _user, block.number);\\n    }\\n\\n    /**\\n    * @dev Queries the balance of _user at a specific _blockNumber\\n    * @param _user The address from which the balance will be retrieved\\n    * @param _blockNumber The block number when the balance is queried\\n    * @return The balance at _blockNumber specified\\n    */\\n    function balanceOfAt(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _blockNumber) public view returns (uint256) {\\n        TellorStorage.Checkpoint[] storage checkpoints = self.balances[_user];\\n        if (checkpoints.length == 0|| checkpoints[0].fromBlock > _blockNumber) {\\n            return 0;\\n        } else {\\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock) return checkpoints[checkpoints.length - 1].value;\\n            // Binary search of the value in the array\\n            uint256 min = 0;\\n            uint256 max = checkpoints.length - 2;\\n            while (max > min) {\\n                uint256 mid = (max + min + 1) / 2;\\n                if  (checkpoints[mid].fromBlock ==_blockNumber){\\n                    return checkpoints[mid].value;\\n                }else if(checkpoints[mid].fromBlock < _blockNumber) {\\n                    min = mid;\\n                } else {\\n                    max = mid - 1;\\n                }\\n            }\\n            return checkpoints[min].value;\\n        }\\n    }\\n    /**\\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\\n    * and removing the staked amount from their balance if they are staked\\n    * @param _user address of user\\n    * @param _amount to check if the user can spend\\n    * @return true if they are allowed to spend the amount being checked\\n    */\\n    function allowedToTrade(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _amount) public view returns (bool) { \\n        if (self.stakerDetails[_user].currentStatus != 0 && self.stakerDetails[_user].currentStatus < 5) {\\n            //Subtracts the stakeAmount from balance if the _user is staked\\n            if (balanceOf(self, _user)- self.uintVars[stakeAmount] >= _amount) {\\n                return true;\\n            }\\n            return false;\\n        } \\n        return (balanceOf(self, _user) >= _amount);\\n    }\\n\\n    /**\\n    * @dev Updates balance for from and to on the current block number via doTransfer\\n    * @param checkpoints gets the mapping for the balances[owner]\\n    * @param _value is the new balance\\n    */\\n    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint256 _value) public {\\n        if (checkpoints.length == 0 || checkpoints[checkpoints.length - 1].fromBlock != block.number) {\\n           checkpoints.push(TellorStorage.Checkpoint({\\n                fromBlock : uint128(block.number),\\n                value : uint128(_value)\\n            }));\\n        } else {\\n            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\\n            oldCheckPoint.value = uint128(_value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/TellorLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"./TellorStorage.sol\\\";\\nimport \\\"./TellorTransfer.sol\\\";\\nimport \\\"./TellorDispute.sol\\\";\\nimport \\\"./TellorStake.sol\\\";\\nimport \\\"./TellorGettersLibrary.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title Tellor Oracle System Library\\n * @dev Contains the functions' logic for the Tellor contract where miners can submit the proof of work\\n * along with the value and smart contracts can requestData and tip miners.\\n */\\nlibrary TellorLibrary {\\n    using SafeMath for uint256;\\n\\n    bytes32 public constant requestCount = 0x05de9147d05477c0a5dc675aeea733157f5092f82add148cf39d579cafe3dc98; //keccak256(\\\"requestCount\\\")\\n    bytes32 public constant totalTip = 0x2a9e355a92978430eca9c1aa3a9ba590094bac282594bccf82de16b83046e2c3; //keccak256(\\\"totalTip\\\")\\n    bytes32 public constant _tBlock = 0x969ea04b74d02bb4d9e6e8e57236e1b9ca31627139ae9f0e465249932e824502; //keccak256(\\\"_tBlock\\\")\\n    bytes32 public constant timeOfLastNewValue = 0x97e6eb29f6a85471f7cc9b57f9e4c3deaf398cfc9798673160d7798baf0b13a4; //keccak256(\\\"timeOfLastNewValue\\\")\\n    bytes32 public constant difficulty = 0xb12aff7664b16cb99339be399b863feecd64d14817be7e1f042f97e3f358e64e; //keccak256(\\\"difficulty\\\")\\n    bytes32 public constant timeTarget = 0xad16221efc80aaf1b7e69bd3ecb61ba5ffa539adf129c3b4ffff769c9b5bbc33; //keccak256(\\\"timeTarget\\\")\\n    bytes32 public constant runningTips = 0xdb21f0c4accc4f2f5f1045353763a9ffe7091ceaf0fcceb5831858d96cf84631; //keccak256(\\\"runningTips\\\")\\n    bytes32 public constant currentReward = 0x9b6853911475b07474368644a0d922ee13bc76a15cd3e97d3e334326424a47d4; //keccak256(\\\"currentReward\\\")\\n    bytes32 public constant total_supply = 0xb1557182e4359a1f0c6301278e8f5b35a776ab58d39892581e357578fb287836; //keccak256(\\\"total_supply\\\")\\n    bytes32 public constant devShare = 0x8fe9ded8d7c08f720cf0340699024f83522ea66b2bbfb8f557851cb9ee63b54c; //keccak256(\\\"devShare\\\")\\n    bytes32 public constant _owner =  0x9dbc393ddc18fd27b1d9b1b129059925688d2f2d5818a5ec3ebb750b7c286ea6; //keccak256(\\\"_owner\\\")\\n    bytes32 public constant requestQPosition = 0x1e344bd070f05f1c5b3f0b1266f4f20d837a0a8190a3a2da8b0375eac2ba86ea; //keccak256(\\\"requestQPosition\\\")\\n    bytes32 public constant currentTotalTips = 0xd26d9834adf5a73309c4974bf654850bb699df8505e70d4cfde365c417b19dfc; //keccak256(\\\"currentTotalTips\\\")\\n    bytes32 public constant slotProgress =0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a; //keccak256(\\\"slotProgress\\\")\\n    bytes32 public constant pending_owner = 0x44b2657a0f8a90ed8e62f4c4cceca06eacaa9b4b25751ae1ebca9280a70abd68; //keccak256(\\\"pending_owner\\\")\\n    bytes32 public constant currentRequestId = 0x7584d7d8701714da9c117f5bf30af73b0b88aca5338a84a21eb28de2fe0d93b8; //keccak256(\\\"currentRequestId\\\")\\n\\n\\n    event TipAdded(address indexed _sender, uint256 indexed _requestId, uint256 _tip, uint256 _totalTips);\\n    //emits when a new challenge is created (either on mined block or when a new request is pushed forward on waiting system)\\n    event NewChallenge(\\n        bytes32 indexed _currentChallenge,\\n        uint256[5] _currentRequestId,\\n        uint256 _difficulty,\\n        uint256 _totalTips\\n    );\\n    //Emits upon a successful Mine, indicates the blocktime at point of the mine and the value mined\\n    event NewValue(uint256[5] _requestId, uint256 _time, uint256[5] _value, uint256 _totalTips, bytes32 indexed _currentChallenge);\\n    //Emits upon each mine (5 total) and shows the miner, nonce, and value submitted\\n    event NonceSubmitted(address indexed _miner, string _nonce, uint256[5] _requestId, uint256[5] _value, bytes32 indexed _currentChallenge);\\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\\n    event OwnershipProposed(address indexed _previousOwner, address indexed _newOwner);\\n\\n    /*Functions*/\\n    /**\\n    * @dev Add tip to Request value from oracle\\n    * @param _requestId being requested to be mined\\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\\n    * mine the onDeckQueryHash, or the api with the highest payout pool\\n    */\\n    function addTip(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _tip) public {\\n        require(_requestId != 0, \\\"RequestId is 0\\\");\\n        require(_tip != 0, \\\"Tip should be greater than 0\\\");\\n        uint256 _count =self.uintVars[requestCount] + 1;\\n        if(_requestId == _count){\\n            self.uintVars[requestCount] = _count;\\n        }\\n        else{\\n            require(_requestId < _count, \\\"RequestId is not less than count\\\");\\n        }\\n        TellorTransfer.doTransfer(self, msg.sender, address(this), _tip);\\n        //Update the information for the request that should be mined next based on the tip submitted\\n        updateOnDeck(self, _requestId, _tip);\\n        emit TipAdded(msg.sender, _requestId, _tip, self.requestDetails[_requestId].apiUintVars[totalTip]);\\n    }\\n\\n   /**\\n    * @dev This function is called by submitMiningSolution and adjusts the difficulty, sorts and stores the first\\n    * 5 values received, pays the miners, the dev share and assigns a new challenge\\n    * @param _nonce or solution for the PoW  for the requestId\\n    * @param _requestId for the current request being mined\\n    */\\n    function newBlock(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256[5] memory _requestId) public {\\n        TellorStorage.Request storage _tblock = self.requestDetails[self.uintVars[_tBlock]];\\n        // If the difference between the timeTarget and how long it takes to solve the challenge this updates the challenge\\n        //difficulty up or donw by the difference between the target time and how long it took to solve the previous challenge\\n        //otherwise it sets it to 1\\n        uint timeDiff = now - self.uintVars[timeOfLastNewValue];\\n        int256 _change = int256(SafeMath.min(1200, timeDiff));\\n        int256 _diff = int256(self.uintVars[difficulty]);\\n        _change = (_diff * (int256(self.uintVars[timeTarget]) - _change)) / 4000;\\n        if (_change == 0) {\\n                _change = 1;\\n            }\\n        self.uintVars[difficulty]  = uint256(SafeMath.max(_diff + _change,1));\\n\\n\\n        //Sets time of value submission rounded to 1 minute\\n        bytes32 _currChallenge = self.currentChallenge;\\n        uint256 _timeOfLastNewValue = now - (now % 1 minutes);\\n        self.uintVars[timeOfLastNewValue] = _timeOfLastNewValue;\\n        uint[5] memory a; \\n        for (uint k = 0; k < 5; k++) {\\n            for (uint i = 1; i < 5; i++) {\\n                uint256 temp = _tblock.valuesByTimestamp[k][i];\\n                address temp2 = _tblock.minersByValue[k][i];\\n                uint256 j = i;\\n                while (j > 0 && temp < _tblock.valuesByTimestamp[k][j - 1]) {\\n                    _tblock.valuesByTimestamp[k][j] = _tblock.valuesByTimestamp[k][j - 1];\\n                    _tblock.minersByValue[k][j] = _tblock.minersByValue[k][j - 1];\\n                    j--;\\n                }\\n                if (j < i) {\\n                    _tblock.valuesByTimestamp[k][j] = temp;\\n                    _tblock.minersByValue[k][j] = temp2;\\n                }\\n            }\\n            TellorStorage.Request storage _request = self.requestDetails[_requestId[k]];\\n            //Save the official(finalValue), timestamp of it, 5 miners and their submitted values for it, and its block number\\n            a = _tblock.valuesByTimestamp[k];            \\n            _request.finalValues[_timeOfLastNewValue] = a[2];\\n            _request.minersByValue[_timeOfLastNewValue] = _tblock.minersByValue[k];\\n            _request.valuesByTimestamp[_timeOfLastNewValue] = _tblock.valuesByTimestamp[k];\\n            delete _tblock.minersByValue[k];\\n            delete _tblock.valuesByTimestamp[k];\\n            _request.requestTimestamps.push(_timeOfLastNewValue);\\n            _request.minedBlockNum[_timeOfLastNewValue] = block.number;\\n            _request.apiUintVars[totalTip] = 0;\\n        }\\n            emit NewValue(\\n                _requestId,\\n                _timeOfLastNewValue,\\n                a,\\n                self.uintVars[runningTips],\\n                _currChallenge\\n            );\\n        //map the timeOfLastValue to the requestId that was just mined\\n        self.requestIdByTimestamp[_timeOfLastNewValue] = _requestId[0];\\n        //add timeOfLastValue to the newValueTimestamps array\\n        self.newValueTimestamps.push(_timeOfLastNewValue);\\n\\n        address[5] memory miners = self.requestDetails[_requestId[0]].minersByValue[_timeOfLastNewValue];\\n        //payMinersRewards\\n        _payReward(self, timeDiff, miners);\\n        \\n        self.uintVars[_tBlock] ++;\\n        uint256[5] memory _topId = TellorStake.getTopRequestIDs(self);\\n        for(uint i = 0; i< 5;i++){\\n            self.currentMiners[i].value = _topId[i];\\n            self.requestQ[self.requestDetails[_topId[i]].apiUintVars[requestQPosition]] = 0;\\n            self.uintVars[currentTotalTips] += self.requestDetails[_topId[i]].apiUintVars[totalTip];\\n        }\\n        //Issue the the next challenge\\n       \\n        _currChallenge = keccak256(abi.encode(_nonce, _currChallenge, blockhash(block.number - 1)));\\n        self.currentChallenge = _currChallenge; // Save hash for next proof\\n        emit NewChallenge(\\n            _currChallenge,\\n            _topId,\\n            self.uintVars[difficulty],\\n            self.uintVars[currentTotalTips]\\n        );\\n    }\\n\\n    /**\\n    * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\\n    * @param _nonce uint submitted by miner\\n    * @param _requestId is the array of the 5 PSR's being mined\\n    * @param _value is an array of 5 values\\n    */\\n    function submitMiningSolution(TellorStorage.TellorStorageStruct storage self, string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value)\\n        external\\n    {\\n        _verifyNonce(self, _nonce);\\n        _submitMiningSolution(self, _nonce, _requestId, _value);\\n    }\\n\\n\\n    function _submitMiningSolution(TellorStorage.TellorStorageStruct storage self, string memory _nonce,uint256[5] memory _requestId, uint256[5] memory _value)\\n        internal\\n    {\\n                //Verifying Miner Eligibility\\n        bytes32 _hashMsgSender = keccak256(abi.encode(msg.sender));\\n        require(self.stakerDetails[msg.sender].currentStatus == 1, \\\"Miner status is not staker\\\");\\n        require(now - self.uintVars[_hashMsgSender] > 15 minutes, \\\"Miner can only win rewards once per 15 min\\\");\\n        require(_requestId[0] ==  self.currentMiners[0].value,\\\"Request ID is wrong\\\");\\n        require(_requestId[1] ==  self.currentMiners[1].value,\\\"Request ID is wrong\\\");\\n        require(_requestId[2] ==  self.currentMiners[2].value,\\\"Request ID is wrong\\\");\\n        require(_requestId[3] ==  self.currentMiners[3].value,\\\"Request ID is wrong\\\");\\n        require(_requestId[4] ==  self.currentMiners[4].value,\\\"Request ID is wrong\\\");\\n        self.uintVars[_hashMsgSender] = now;\\n\\n        \\n        bytes32 _currChallenge = self.currentChallenge;\\n        uint256 _slotProgress = self.uintVars[slotProgress]; \\n        //Saving the challenge information as unique by using the msg.sender\\n\\n        //Checking and updating Miner Status\\n        require(self.minersByChallenge[_currChallenge][msg.sender] == false, \\\"Miner already submitted the value\\\");\\n        //Update the miner status to true once they submit a value so they don't submit more than once\\n        self.minersByChallenge[_currChallenge][msg.sender] = true;\\n\\n        //Updating Request\\n        TellorStorage.Request storage _tblock = self.requestDetails[self.uintVars[_tBlock]];\\n        _tblock.minersByValue[1][_slotProgress]= msg.sender; \\n        //Assigng directly is cheaper than using a for loop\\n        _tblock.valuesByTimestamp[0][_slotProgress] = _value[0];\\n        _tblock.valuesByTimestamp[1][_slotProgress] = _value[1];\\n        _tblock.valuesByTimestamp[2][_slotProgress] = _value[2];\\n        _tblock.valuesByTimestamp[3][_slotProgress] = _value[3];\\n        _tblock.valuesByTimestamp[4][_slotProgress] = _value[4];\\n        _tblock.minersByValue[0][_slotProgress]= msg.sender;\\n        _tblock.minersByValue[1][_slotProgress]= msg.sender;\\n        _tblock.minersByValue[2][_slotProgress]= msg.sender;\\n        _tblock.minersByValue[3][_slotProgress]= msg.sender;\\n        _tblock.minersByValue[4][_slotProgress]= msg.sender;\\n\\n        //If 5 values have been received, adjust the difficulty otherwise sort the values until 5 are received         \\n        if (_slotProgress + 1 == 5) { //slotProgress has been incremented, but we're using the variable on stack to save gas\\n            newBlock(self, _nonce, _requestId);\\n            self.uintVars[slotProgress] = 0;\\n        }\\n        else{\\n            self.uintVars[slotProgress]++;\\n        }\\n        emit NonceSubmitted(msg.sender, _nonce, _requestId, _value, _currChallenge);\\n    }\\n\\n    function _verifyNonce(TellorStorage.TellorStorageStruct storage self,string memory _nonce ) view internal {\\n                require(uint256(\\n                sha256(abi.encodePacked(ripemd160(abi.encodePacked(keccak256(abi.encodePacked(self.currentChallenge, msg.sender, _nonce))))))\\n            ) %\\n                self.uintVars[difficulty] == 0\\n                || (now - (now % 1 minutes)) - self.uintVars[timeOfLastNewValue] >= 15 minutes,\\n            \\\"Incorrect nonce for current challenge\\\"\\n        );\\n    }\\n\\n     /**\\n    * @dev Internal function to calculate and pay rewards to miners\\n    * \\n    */\\n    function _payReward(TellorStorage.TellorStorageStruct storage self, uint _timeDiff, address[5] memory miners) internal {\\n        //_timeDiff is how many minutes passed since last block\\n        uint _currReward = 1e18;\\n        uint reward = _timeDiff* _currReward / 300; //each miner get's \\n        uint _tip = self.uintVars[currentTotalTips] / 10;\\n        uint _devShare = reward / 2;\\n\\n        TellorTransfer.doTransfer(self, address(this), miners[0], reward + _tip);\\n        TellorTransfer.doTransfer(self, address(this), miners[1], reward + _tip);\\n        TellorTransfer.doTransfer(self, address(this), miners[2], reward + _tip);\\n        TellorTransfer.doTransfer(self, address(this), miners[3], reward + _tip);\\n        TellorTransfer.doTransfer(self, address(this), miners[4], reward + _tip);\\n \\n        //update the total supply\\n        self.uintVars[total_supply] +=  _devShare + reward * 5 - (self.uintVars[currentTotalTips] / 2);\\n        TellorTransfer.doTransfer(self, address(this), self.addressVars[_owner],  _devShare);\\n        self.uintVars[currentTotalTips] = 0;\\n    }\\n\\n\\n    /**\\n    * @dev Allows the current owner to propose transfer control of the contract to a\\n    * newOwner and the ownership is pending until the new owner calls the claimOwnership\\n    * function\\n    * @param _pendingOwner The address to transfer ownership to.\\n    */\\n    function proposeOwnership(TellorStorage.TellorStorageStruct storage self, address payable _pendingOwner) public {\\n        require(msg.sender == self.addressVars[_owner], \\\"Sender is not owner\\\");\\n        emit OwnershipProposed(self.addressVars[_owner], _pendingOwner);\\n        self.addressVars[pending_owner] = _pendingOwner;\\n    }\\n\\n    /**\\n    * @dev Allows the new owner to claim control of the contract\\n    */\\n    function claimOwnership(TellorStorage.TellorStorageStruct storage self) public {\\n        require(msg.sender == self.addressVars[pending_owner], \\\"Sender is not pending owner\\\");\\n        emit OwnershipTransferred(self.addressVars[_owner], self.addressVars[pending_owner]);\\n        self.addressVars[_owner] = self.addressVars[pending_owner];\\n    }\\n\\n    /**\\n    * @dev This function updates APIonQ and the requestQ when requestData or addTip are ran\\n    * @param _requestId being requested\\n    * @param _tip is the tip to add\\n    */\\n    function updateOnDeck(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _tip) public {\\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\\n        _request.apiUintVars[totalTip] = _request.apiUintVars[totalTip].add(_tip);\\n        if(self.currentMiners[0].value == _requestId || self.currentMiners[1].value== _requestId ||self.currentMiners[2].value == _requestId||self.currentMiners[3].value== _requestId || self.currentMiners[4].value== _requestId ){\\n            self.uintVars[currentTotalTips] += _tip;\\n        }\\n        else {\\n            //if the request is not part of the requestQ[51] array\\n            //then add to the requestQ[51] only if the _payout/tip is greater than the minimum(tip) in the requestQ[51] array\\n            if (_request.apiUintVars[requestQPosition] == 0) {\\n                uint256 _min;\\n                uint256 _index;\\n                (_min, _index) = Utilities.getMin(self.requestQ);\\n                //we have to zero out the oldOne\\n                //if the _payout is greater than the current minimum payout in the requestQ[51] or if the minimum is zero\\n                //then add it to the requestQ array aand map its index information to the requestId and the apiUintvars\\n                if (_request.apiUintVars[totalTip] > _min || _min == 0) {\\n                    self.requestQ[_index] = _request.apiUintVars[totalTip];\\n                    self.requestDetails[self.requestIdByRequestQIndex[_index]].apiUintVars[requestQPosition] = 0;\\n                    self.requestIdByRequestQIndex[_index] = _requestId;\\n                    _request.apiUintVars[requestQPosition] = _index;\\n                }\\n                // else if the requestid is part of the requestQ[51] then update the tip for it\\n            } else{\\n                self.requestQ[_request.apiUintVars[requestQPosition]] += _tip;\\n            }\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/Tellor.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/TellorStorage.sol\\\";\\nimport \\\"./libraries/TellorTransfer.sol\\\";\\nimport \\\"./libraries/TellorDispute.sol\\\";\\nimport \\\"./libraries/TellorStake.sol\\\";\\nimport \\\"./libraries/TellorLibrary.sol\\\";\\n\\n/**\\n * @title Tellor Oracle System\\n * @dev Oracle contract where miners can submit the proof of work along with the value.\\n * The logic for this contract is in TellorLibrary.sol, TellorDispute.sol, TellorStake.sol,\\n * and TellorTransfer.sol\\n */\\ncontract Tellor {\\n    using SafeMath for uint256;\\n\\n    using TellorDispute for TellorStorage.TellorStorageStruct;\\n    using TellorLibrary for TellorStorage.TellorStorageStruct;\\n    using TellorStake for TellorStorage.TellorStorageStruct;\\n    using TellorTransfer for TellorStorage.TellorStorageStruct;\\n\\n    TellorStorage.TellorStorageStruct tellor;\\n\\n    /*Functions*/\\n\\n    /**\\n    * @dev Helps initialize a dispute by assigning it a disputeId\\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\\n    * invalidated value information to POS voting\\n    * @param _requestId being disputed\\n    * @param _timestamp being disputed\\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\\n    * requires 5 miners to submit a value.\\n    */\\n    function beginDispute(uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) external {\\n        tellor.beginDispute(_requestId, _timestamp, _minerIndex);\\n    }\\n\\n    /**\\n    * @dev Allows token holders to vote\\n    * @param _disputeId is the dispute id\\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\\n    */\\n    function vote(uint256 _disputeId, bool _supportsDispute) external {\\n        tellor.vote(_disputeId, _supportsDispute);\\n    }\\n\\n    /**\\n    * @dev tallies the votes.\\n    * @param _disputeId is the dispute id\\n    */\\n    function tallyVotes(uint256 _disputeId) external {\\n        tellor.tallyVotes(_disputeId);\\n    }\\n\\n    /**\\n    * @dev Allows for a fork to be proposed\\n    * @param _propNewTellorAddress address for new proposed Tellor\\n    */\\n    function proposeFork(address _propNewTellorAddress) external {\\n        tellor.proposeFork(_propNewTellorAddress);\\n    }\\n\\n    /**\\n    * @dev Add tip to Request value from oracle\\n    * @param _requestId being requested to be mined\\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\\n    * mine the onDeckQueryHash, or the api with the highest payout pool\\n    */\\n    function addTip(uint256 _requestId, uint256 _tip) external {\\n        tellor.addTip(_requestId, _tip);\\n    }\\n\\n    /**\\n    * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\\n    * @param _nonce uint submitted by miner\\n    * @param _requestId is the array of the 5 PSR's being mined\\n    * @param _value is an array of 5 values\\n    */\\n    function submitMiningSolution(string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value) external {\\n        tellor.submitMiningSolution(_nonce,_requestId, _value);\\n    }\\n\\n\\n    /**\\n    * @dev Allows the current owner to propose transfer control of the contract to a\\n    * newOwner and the ownership is pending until the new owner calls the claimOwnership\\n    * function\\n    * @param _pendingOwner The address to transfer ownership to.\\n    */\\n    function proposeOwnership(address payable _pendingOwner) external {\\n        tellor.proposeOwnership(_pendingOwner);\\n    }\\n\\n    /**\\n    * @dev Allows the new owner to claim control of the contract\\n    */\\n    function claimOwnership() external {\\n        tellor.claimOwnership();\\n    }\\n\\n    /**\\n    * @dev This function allows miners to deposit their stake.\\n    */\\n    function depositStake() external {\\n        tellor.depositStake();\\n    }\\n\\n    /**\\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\\n    * can withdraw the stake\\n    */\\n    function requestStakingWithdraw() external {\\n        tellor.requestStakingWithdraw();\\n    }\\n\\n    /**\\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\\n    */\\n    function withdrawStake() external {\\n        tellor.withdrawStake();\\n    }\\n\\n    /**\\n    * @dev This function approves a _spender an _amount of tokens to use\\n    * @param _spender address\\n    * @param _amount amount the spender is being approved for\\n    * @return true if spender appproved successfully\\n    */\\n    function approve(address _spender, uint256 _amount) external returns (bool) {\\n        return tellor.approve(_spender, _amount);\\n    }\\n\\n    /**\\n    * @dev Allows for a transfer of tokens to _to\\n    * @param _to The address to send tokens to\\n    * @param _amount The amount of tokens to send\\n    * @return true if transfer is successful\\n    */\\n    function transfer(address _to, uint256 _amount) external returns (bool) {\\n        return tellor.transfer(_to, _amount);\\n    }\\n\\n    /**\\n    * @dev Sends _amount tokens to _to from _from on the condition it\\n    * is approved by _from\\n    * @param _from The address holding the tokens being transferred\\n    * @param _to The address of the recipient\\n    * @param _amount The amount of tokens to be transferred\\n    * @return True if the transfer was successful\\n    */\\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool) {\\n        return tellor.transferFrom(_from, _to, _amount);\\n    }\\n\\n    /**\\n    * @dev Allows users to access the token's name\\n    */\\n    function name() external pure returns (string memory) {\\n        return \\\"Tellor Tributes\\\";\\n    }\\n\\n    /**\\n    * @dev Allows users to access the token's symbol\\n    */\\n    function symbol() external pure returns (string memory) {\\n        return \\\"TRB\\\";\\n    }\\n\\n    /**\\n    * @dev Allows users to access the number of decimals\\n    */\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n    * @dev Getter for the current variables that include the 5 requests Id's\\n    * @return the challenge, 5 requestsId, difficulty and tip\\n    */\\n    function getNewCurrentVariables() external view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficutly, uint256 _tip){\\n        return tellor.getNewCurrentVariables();\\n    }\\n\\n    /**\\n    * @dev Getter for the top tipped 5 requests Id's\\n    * @return the 5 requestsId\\n    */\\n    function getTopRequestIDs() external view returns(uint256[5] memory _requestIds){\\n        return tellor.getTopRequestIDs();\\n    }\\n\\n    /**\\n    * @dev Getter for the 5 requests Id's next in line to get mined\\n    * @return the 5 requestsId\\n    */\\n    function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck) {\\n        return tellor.getNewVariablesOnDeck();\\n    }\\n\\n    /**\\n    * @dev Updates the Tellor address after a proposed fork has \\n    * passed the vote and day has gone by without a dispute\\n    * @param _disputeId the disputeId for the proposed fork\\n    */\\n     function updateTellor(uint _disputeId) external{\\n        return tellor.updateTellor(_disputeId);\\n    }\\n\\n    /**\\n    * @dev Allows disputer to unlock the dispute fee\\n    * @param _disputeId to unlock fee from\\n    */\\n     function unlockDisputeFee (uint _disputeId) external{\\n        return tellor.unlockDisputeFee(_disputeId);\\n    }\\n\\n    /*******************TEST Functions NOT INCLUDED ON PRODUCTION/MAINNET/RINKEBY******/\\n    // /*This is a cheat for demo purposes, will delete upon actual launch*/\\n    // function theLazyCoon(address _address, uint _amount) external {\\n    //     tellor.theLazyCoon(_address,_amount);\\n    // }\\n\\n    // // function testSubmitMiningSolution(string calldata _nonce, uint256 _requestId, uint256 _value) external {\\n    // //     tellor.testSubmitMiningSolution(_nonce, _requestId, _value);\\n    // // }\\n\\n    // function testSubmitMiningSolution(string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value) external {\\n    //     tellor.testSubmitMiningSolution(_nonce,_requestId, _value);\\n    // }\\n    /***************END TEST Functions NOT INCLUDED ON PRODUCTION/MAINNET/RINKEBY******/\\n }\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a + b;\\n            assert(c >= a);\\n        } else {\\n            c = a + b;\\n            assert(c <= a);\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function max(int256 a, int256 b) internal pure returns (uint256) {\\n        return a > b ? uint256(a) : uint256(b);\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        assert(a == 0 || c / a == b);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a - b;\\n            assert(c <= a);\\n        } else {\\n            c = a - b;\\n            assert(c >= a);\\n        }\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/TellorStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Tellor Oracle Storage Library\\n * @dev Contains all the variables/structs used by Tellor\\n */\\n\\nlibrary TellorStorage {\\n    //Internal struct for use in proof-of-work submission\\n    struct Details {\\n        uint256 value;\\n        address miner;\\n    }\\n\\n    struct Dispute {\\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\\n        int256 tally; //current tally of votes for - against measure\\n        bool executed; //is the dispute settled\\n        bool disputeVotePassed; //did the vote pass?\\n        bool isPropFork; //true for fork proposal NEW\\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\\n        address proposedForkAddress; //new fork address (if fork proposal)\\n        mapping(bytes32 => uint256) disputeUintVars;\\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\\\"requestId\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"requestId\\\");//apiID of disputed value\\n        // uint keccak256(\\\"timestamp\\\");//timestamp of distputed value\\n        // uint keccak256(\\\"value\\\"); //the value being disputed\\n        // uint keccak256(\\\"minExecutionDate\\\");//7 days from when dispute initialized\\n        // uint keccak256(\\\"numberOfVotes\\\");//the number of parties who have voted on the measure\\n        // uint keccak256(\\\"blockNumber\\\");// the blocknumber for which votes will be calculated from\\n        // uint keccak256(\\\"minerSlot\\\"); //index in dispute array\\n        // uint keccak256(\\\"fee\\\"); //fee paid corresponding to dispute\\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\\n    }\\n\\n    struct StakeInfo {\\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\\n        uint256 startDate; //stake start date\\n    }\\n\\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\\n    struct Checkpoint {\\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\\n        uint128 value; // value is the amount of tokens at a specific block number\\n    }\\n\\n    struct Request {\\n        string queryString; //id to string api\\n        string dataSymbol; //short name for api request\\n        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\\n        mapping(bytes32 => uint256) apiUintVars;\\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"granularity\\\"); //multiplier for miners\\n        // uint keccak256(\\\"requestQPosition\\\"); //index in requestQ\\n        // uint keccak256(\\\"totalTip\\\");//bonus portion of payout\\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\\n        mapping(uint256 => uint256) finalValues;\\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\\n        mapping(uint256 => address[5]) minersByValue;\\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\\n    }\\n\\n    struct TellorStorageStruct {\\n        bytes32 currentChallenge; //current challenge to be solved\\n        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\\n        uint256[] newValueTimestamps; //array of all timestamps requested\\n        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\\n        mapping(bytes32 => address) addressVars;\\n        //Address fields in the Tellor contract are saved the addressVars mapping\\n        //e.g. addressVars[keccak256(\\\"tellorContract\\\")] = address\\n        //These are the variables saved in this mapping:\\n        // address keccak256(\\\"tellorContract\\\");//Tellor address\\n        // address  keccak256(\\\"_owner\\\");//Tellor Owner address\\n        // address  keccak256(\\\"_deity\\\");//Tellor Owner that can do things at will\\n        // address  keccak256(\\\"pending_owner\\\"); // The proposed new owner\\n        mapping(bytes32 => uint256) uintVars;\\n        //uint fields in the Tellor contract are saved the uintVars mapping\\n        //e.g. uintVars[keccak256(\\\"decimals\\\")] = uint\\n        //These are the variables saved in this mapping:\\n        // keccak256(\\\"decimals\\\");    //18 decimal standard ERC20\\n        // keccak256(\\\"disputeFee\\\");//cost to dispute a mined value\\n        // keccak256(\\\"disputeCount\\\");//totalHistoricalDisputes\\n        // keccak256(\\\"total_supply\\\"); //total_supply of the token in circulation\\n        // keccak256(\\\"stakeAmount\\\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\\n        // keccak256(\\\"stakerCount\\\"); //number of parties currently staked\\n        // keccak256(\\\"timeOfLastNewValue\\\"); // time of last challenge solved\\n        // keccak256(\\\"difficulty\\\"); // Difficulty of current block\\n        // keccak256(\\\"currentTotalTips\\\"); //value of highest api/timestamp PayoutPool\\n        // keccak256(\\\"currentRequestId\\\"); //API being mined--updates with the ApiOnQ Id\\n        // keccak256(\\\"requestCount\\\"); // total number of requests through the system\\n        // keccak256(\\\"slotProgress\\\");//Number of miners who have mined this value so far\\n        // keccak256(\\\"miningReward\\\");//Mining Reward in PoWo tokens given to all miners per value\\n        // keccak256(\\\"timeTarget\\\"); //The time between blocks (mined Oracle values)\\n        // keccak256(\\\"_tblock\\\"); //\\n        // keccak256(\\\"runningTips\\\"); // VAriable to track running tips\\n        // keccak256(\\\"currentReward\\\"); // The current reward\\n        // keccak256(\\\"devShare\\\"); // The amount directed towards th devShare\\n        // keccak256(\\\"currentTotalTips\\\"); //\\n        //This is a boolean that tells you if a given challenge has been completed by a given miner\\n        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\\n        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\\n        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\\n        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\\n        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\\n        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\\n        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\\n        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\\n        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\\n        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.8.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logByte(byte p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(byte)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/Utilities.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n//Functions for retrieving min and Max in 51 length array (requestQ)\\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\\n\\nlibrary Utilities {\\n    /**\\n    * @dev Returns the max value in an array.\\n    * The zero position here is ignored. It's because \\n    * there's no null in solidity and we map each address \\n    * to an index in this array. So when we get 51 parties, \\n    * and one person is kicked out of the top 50, we \\n    * assign them a 0, and when you get mined and pulled \\n    * out of the top 50, also a 0. So then lot's of parties \\n    * will have zero as the index so we made the array run \\n    * from 1-51 with zero as nothing.\\n    * @param data is the array to calculate max from\\n    * @return max amount and its index within the array\\n    */\\n    function getMax(uint256[51] memory data) internal pure returns (uint256 max, uint256 maxIndex) {\\n        maxIndex = 1;\\n        max = data[maxIndex];\\n        for (uint256 i = 2; i < data.length; i++) {\\n            if (data[i] > max) {\\n                max = data[i];\\n                maxIndex = i;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Returns the minimum value in an array.\\n    * @param data is the array to calculate min from\\n    * @return min amount and its index within the array\\n    */\\n    function getMin(uint256[51] memory data) internal pure returns (uint256 min, uint256 minIndex) {\\n        minIndex = data.length - 1;\\n        min = data[minIndex];\\n        for (uint256 i = data.length - 2; i > 0; i--) {\\n            if (data[i] < min) {\\n                min = data[i];\\n                minIndex = i;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Returns the 5 requestsId's with the top payouts in an array.\\n    * @param data is the array to get the top 5 from\\n    * @return to 5 max amounts and their respective index within the array\\n    */\\n    function getMax5(uint256[51] memory data) internal pure returns (uint256[5] memory max, uint256[5] memory maxIndex) {\\n        uint256 min5 = data[1];\\n        uint256 minI = 0;\\n        for(uint256 j=0;j<5;j++){\\n            max[j]= data[j+1];//max[0]=data[1]\\n            maxIndex[j] = j+1;//maxIndex[0]= 1\\n            if(max[j] < min5){\\n                min5 = max[j];\\n                minI = j;\\n            }\\n        }\\n        for(uint256 i = 6; i < data.length; i++) {\\n            if (data[i] > min5) {\\n                max[minI] = data[i];\\n                maxIndex[minI] = i;\\n                min5 = data[i];\\n                for(uint256 j=0;j<5;j++){\\n                    if(max[j] < min5){\\n                        min5 = max[j];\\n                        minI = j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/TellorDispute.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\nimport \\\"./TellorStorage.sol\\\";\\nimport \\\"./TellorTransfer.sol\\\";\\n\\n\\n/**\\n* @title Tellor Dispute\\n* @dev Contains the methods related to disputes. Tellor.sol references this library for function's logic.\\n*/\\n\\nlibrary TellorDispute {\\n    using SafeMath for uint256;\\n    using SafeMath for int256;\\n\\n    //emitted when a new dispute is initialized\\n    event NewDispute(uint256 indexed _disputeId, uint256 indexed _requestId, uint256 _timestamp, address _miner);\\n    //emitted when a new vote happens\\n    event Voted(uint256 indexed _disputeID, bool _position, address indexed _voter, uint256 indexed _voteWeight);\\n    //emitted upon dispute tally\\n    event DisputeVoteTallied(uint256 indexed _disputeID, int256 _result, address indexed _reportedMiner, address _reportingParty, bool _active);\\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\\n\\n    /*Functions*/\\n\\n    /**\\n    * @dev Helps initialize a dispute by assigning it a disputeId\\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\\n    * invalidated value information to POS voting\\n    * @param _requestId being disputed\\n    * @param _timestamp being disputed\\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\\n    * requires 5 miners to submit a value.\\n    */\\n    function beginDispute(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) public {\\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\\n        require(_request.minedBlockNum[_timestamp] != 0, \\\"Mined block is 0\\\");\\n        require(_minerIndex < 5, \\\"Miner index is wrong\\\");\\n\\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\\n        //provided by the party initiating the dispute\\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\\n        bytes32 _hash = keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\\n\\n\\n\\n        //Increase the dispute count by 1\\n        uint256 disputeId = self.uintVars[keccak256(\\\"disputeCount\\\")] + 1;\\n        self.uintVars[keccak256(\\\"disputeCount\\\")] = disputeId;\\n\\n        //Sets the new disputeCount as the disputeId\\n\\n                //Ensures that a dispute is not already open for the that miner, requestId and timestamp\\n        uint256 hashId = self.disputeIdByDisputeHash[_hash];\\n        if(hashId != 0){\\n            self.disputesById[disputeId].disputeUintVars[keccak256(\\\"origID\\\")] = hashId;\\n\\n        }\\n        else{\\n            self.disputeIdByDisputeHash[_hash] = disputeId;\\n            hashId = disputeId;\\n        }\\n        uint256 origID = hashId;\\n        uint256 dispRounds = self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")] + 1;\\n        self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")] = dispRounds;\\n        self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds))] = disputeId;\\n        if(disputeId != origID){\\n            uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds-1))];\\n            require(self.disputesById[lastID].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] <= now, \\\"Dispute is already open\\\");\\n            if(self.disputesById[lastID].executed){\\n                require(now - self.disputesById[lastID].disputeUintVars[keccak256(\\\"tallyDate\\\")] <= 1 days, \\\"Time for voting haven't elapsed\\\");\\n            }\\n        }\\n        uint256 _fee;\\n        if (_minerIndex == 2) {\\n            self.requestDetails[_requestId].apiUintVars[keccak256(\\\"disputeCount\\\")] = self.requestDetails[_requestId].apiUintVars[keccak256(\\\"disputeCount\\\")] +1;\\n            //update dispute fee for this case\\n            _fee = self.uintVars[keccak256(\\\"stakeAmount\\\")]*self.requestDetails[_requestId].apiUintVars[keccak256(\\\"disputeCount\\\")];\\n        } else {\\n\\n            _fee = self.uintVars[keccak256(\\\"disputeFee\\\")] * dispRounds;\\n        }\\n\\n        //maps the dispute to the Dispute struct\\n        self.disputesById[disputeId] = TellorStorage.Dispute({\\n            hash: _hash,\\n            isPropFork: false,\\n            reportedMiner: _miner,\\n            reportingParty: msg.sender,\\n            proposedForkAddress: address(0),\\n            executed: false,\\n            disputeVotePassed: false,\\n            tally: 0\\n        });\\n\\n        //Saves all the dispute variables for the disputeId\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"requestId\\\")] = _requestId;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"timestamp\\\")] = _timestamp;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"value\\\")] = _request.valuesByTimestamp[_timestamp][_minerIndex];\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] = now + 2 days * dispRounds;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"blockNumber\\\")] = block.number;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minerSlot\\\")] = _minerIndex;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"fee\\\")] = _fee;\\n        TellorTransfer.doTransfer(self, msg.sender, address(this),_fee);\\n\\n   \\n\\n        //Values are sorted as they come in and the official value is the median of the first five\\n        //So the \\\"official value\\\" miner is always minerIndex==2. If the official value is being\\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\\n        if (_minerIndex == 2) {\\n            _request.inDispute[_timestamp] = true;\\n            _request.finalValues[_timestamp] = 0;\\n        }\\n        self.stakerDetails[_miner].currentStatus = 3;\\n        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\\n    }\\n\\n    /**\\n    * @dev Allows token holders to vote\\n    * @param _disputeId is the dispute id\\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\\n    */\\n    function vote(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, bool _supportsDispute) public {\\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\\n\\n        //Get the voteWeight or the balance of the user at the time/blockNumber the disupte began\\n        uint256 voteWeight = TellorTransfer.balanceOfAt(self, msg.sender, disp.disputeUintVars[keccak256(\\\"blockNumber\\\")]);\\n\\n        //Require that the msg.sender has not voted\\n        require(disp.voted[msg.sender] != true, \\\"Sender has already voted\\\");\\n\\n        //Requre that the user had a balance >0 at time/blockNumber the disupte began\\n        require(voteWeight != 0, \\\"User balance is 0\\\");\\n\\n        //ensures miners that are under dispute cannot vote\\n        require(self.stakerDetails[msg.sender].currentStatus != 3, \\\"Miner is under dispute\\\");\\n\\n        //Update user voting status to true\\n        disp.voted[msg.sender] = true;\\n\\n        //Update the number of votes for the dispute\\n        disp.disputeUintVars[keccak256(\\\"numberOfVotes\\\")] += 1;\\n\\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\\n        //otherwise decrease it\\n        if (_supportsDispute) {\\n            disp.tally = disp.tally.add(int256(voteWeight));\\n        } else {\\n            disp.tally = disp.tally.sub(int256(voteWeight));\\n        }\\n\\n        //Let the network know the user has voted on the dispute and their casted vote\\n        emit Voted(_disputeId, _supportsDispute, msg.sender, voteWeight);\\n    }\\n\\n    /**\\n    * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\\n    * @param _disputeId is the dispute id\\n    */\\n    function tallyVotes(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId) public {\\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\\n\\n        //Ensure this has not already been executed/tallied\\n        require(disp.executed == false, \\\"Dispute has been already executed\\\");\\n        require(now >= disp.disputeUintVars[keccak256(\\\"minExecutionDate\\\")], \\\"Time for voting haven't elapsed\\\");\\n        require(disp.reportingParty != address(0), \\\"reporting Party is address 0\\\");\\n        int256  _tally = disp.tally;\\n        if (_tally > 0) {\\n            //Set the dispute state to passed/true\\n            disp.disputeVotePassed = true;\\n        }\\n        //If the vote is not a proposed fork\\n        if (disp.isPropFork == false) {\\n                //Ensure the time for voting has elapsed\\n                    TellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\\n                    //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported\\n                    // miner and transfer the stakeAmount and dispute fee to the reporting party\\n                    if(stakes.currentStatus == 3){\\n                        stakes.currentStatus = 4;\\n                    }\\n        } else if (uint(_tally) >= ((self.uintVars[keccak256(\\\"total_supply\\\")] * 10) / 100)) {\\n            emit NewTellorAddress(disp.proposedForkAddress);\\n        }\\n        disp.disputeUintVars[keccak256(\\\"tallyDate\\\")] = now;\\n        disp.executed = true;\\n        emit DisputeVoteTallied(_disputeId, _tally, disp.reportedMiner, disp.reportingParty, disp.disputeVotePassed);\\n    }\\n\\n    /**\\n    * @dev Allows for a fork to be proposed\\n    * @param _propNewTellorAddress address for new proposed Tellor\\n    */\\n    function proposeFork(TellorStorage.TellorStorageStruct storage self, address _propNewTellorAddress) public {\\n        bytes32 _hash = keccak256(abi.encode(_propNewTellorAddress));\\n        TellorTransfer.doTransfer(self, msg.sender, address(this), 100e18); //This is the fork fee (just 100 tokens flat, no refunds)\\n        self.uintVars[keccak256(\\\"disputeCount\\\")]++;\\n        uint256 disputeId = self.uintVars[keccak256(\\\"disputeCount\\\")];\\n        if(self.disputeIdByDisputeHash[_hash] != 0){\\n            self.disputesById[disputeId].disputeUintVars[keccak256(\\\"origID\\\")] = self.disputeIdByDisputeHash[_hash];\\n        }\\n        else{\\n            self.disputeIdByDisputeHash[_hash] = disputeId;\\n        }\\n        uint256 origID = self.disputeIdByDisputeHash[_hash];\\n\\n        self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")]++;\\n        uint256 dispRounds = self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")];\\n        self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds))] = disputeId;\\n        if(disputeId != origID){\\n            uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds-1))];\\n            require(self.disputesById[lastID].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] <= now, \\\"Dispute is already open\\\");\\n            if(self.disputesById[lastID].executed){\\n                require(now - self.disputesById[lastID].disputeUintVars[keccak256(\\\"tallyDate\\\")] <= 1 days, \\\"Time for voting haven't elapsed\\\");\\n            }\\n        }\\n        self.disputesById[disputeId] = TellorStorage.Dispute({\\n            hash: _hash,\\n            isPropFork: true,\\n            reportedMiner: msg.sender,\\n            reportingParty: msg.sender,\\n            proposedForkAddress: _propNewTellorAddress,\\n            executed: false,\\n            disputeVotePassed: false,\\n            tally: 0\\n        });\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"blockNumber\\\")] = block.number;\\n        self.disputesById[disputeId].disputeUintVars[keccak256(\\\"minExecutionDate\\\")] = now + 7 days;\\n    }\\n\\n    /**\\n    * @dev Updates the Tellor address after a proposed fork has \\n    * passed the vote and day has gone by without a dispute\\n    * @param _disputeId the disputeId for the proposed fork\\n    */\\n    function updateTellor(TellorStorage.TellorStorageStruct storage self, uint _disputeId) public {\\n        bytes32 _hash = self.disputesById[_disputeId].hash;\\n        uint256 origID = self.disputeIdByDisputeHash[_hash];\\n        uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")]))];\\n        TellorStorage.Dispute storage disp = self.disputesById[lastID];\\n        require(disp.disputeVotePassed == true, \\\"vote needs to pass\\\");\\n        require(now - disp.disputeUintVars[keccak256(\\\"tallyDate\\\")] > 1 days, \\\"Time for voting for further disputes has not passed\\\");\\n        self.addressVars[keccak256(\\\"tellorContract\\\")] = disp.proposedForkAddress;\\n    }\\n\\n    /**\\n    * @dev Allows disputer to unlock the dispute fee\\n    * @param _disputeId to unlock fee from\\n    */\\n    function unlockDisputeFee (TellorStorage.TellorStorageStruct storage self, uint _disputeId) public {\\n        uint256 origID = self.disputeIdByDisputeHash[self.disputesById[_disputeId].hash];\\n        uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(self.disputesById[origID].disputeUintVars[keccak256(\\\"disputeRounds\\\")]))];\\n        if(lastID == 0){\\n            lastID = origID;\\n        }\\n        TellorStorage.Dispute storage disp = self.disputesById[origID];\\n        TellorStorage.Dispute storage last = self.disputesById[lastID];\\n                //disputeRounds is increased by 1 so that the _id is not a negative number when it is the first time a dispute is initiated\\n        uint256 dispRounds = disp.disputeUintVars[keccak256(\\\"disputeRounds\\\")];\\n        if(dispRounds == 0){\\n          dispRounds = 1;  \\n        }\\n        uint256 _id;\\n        require(disp.disputeUintVars[keccak256(\\\"paid\\\")] == 0,\\\"already paid out\\\");\\n        require(now - last.disputeUintVars[keccak256(\\\"tallyDate\\\")] > 1 days, \\\"Time for voting haven't elapsed\\\");\\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\\n        disp.disputeUintVars[keccak256(\\\"paid\\\")] = 1;\\n        if (last.disputeVotePassed == true){\\n                //Changing the currentStatus and startDate unstakes the reported miner and transfers the stakeAmount\\n                stakes.startDate = now - (now % 86400);\\n\\n                //Reduce the staker count\\n                self.uintVars[keccak256(\\\"stakerCount\\\")] -= 1;\\n\\n                //Update the minimum dispute fee that is based on the number of stakers \\n                updateMinDisputeFee(self);\\n                //Decreases the stakerCount since the miner's stake is being slashed\\n                if(stakes.currentStatus == 4){\\n                    stakes.currentStatus = 5;\\n                    TellorTransfer.doTransfer(self,disp.reportedMiner,disp.reportingParty,self.uintVars[keccak256(\\\"stakeAmount\\\")]);\\n                    stakes.currentStatus =0 ;\\n                }\\n                for(uint i = 0; i < dispRounds;i++){\\n                    _id = disp.disputeUintVars[keccak256(abi.encode(dispRounds-i))];\\n                    if(_id == 0){\\n                        _id = origID;\\n                    }\\n                    TellorStorage.Dispute storage disp2 = self.disputesById[_id];\\n                        //transfer fee adjusted based on number of miners if the minerIndex is not 2(official value)\\n                    TellorTransfer.doTransfer(self,address(this), disp2.reportingParty, disp2.disputeUintVars[keccak256(\\\"fee\\\")]);\\n                }\\n            }\\n            else {\\n                stakes.currentStatus = 1;\\n                TellorStorage.Request storage _request = self.requestDetails[disp.disputeUintVars[keccak256(\\\"requestId\\\")]];\\n                if(disp.disputeUintVars[keccak256(\\\"minerSlot\\\")] == 2) {\\n                    //note we still don't put timestamp back into array (is this an issue? (shouldn't be))\\n                  _request.finalValues[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] = disp.disputeUintVars[keccak256(\\\"value\\\")];\\n                }\\n                if (_request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] == true) {\\n                    _request.inDispute[disp.disputeUintVars[keccak256(\\\"timestamp\\\")]] = false;\\n                }\\n                for(uint i = 0; i < dispRounds;i++){\\n                    _id = disp.disputeUintVars[keccak256(abi.encode(dispRounds-i))];\\n                    if(_id != 0){\\n                        last = self.disputesById[_id];//handling if happens during an upgrade\\n                    }\\n                    TellorTransfer.doTransfer(self,address(this),last.reportedMiner,self.disputesById[_id].disputeUintVars[keccak256(\\\"fee\\\")]);\\n                }\\n            }\\n\\n            if (disp.disputeUintVars[keccak256(\\\"minerSlot\\\")] == 2) {\\n                self.requestDetails[disp.disputeUintVars[keccak256(\\\"requestId\\\")]].apiUintVars[keccak256(\\\"disputeCount\\\")]--;\\n            } \\n    }\\n\\n    /**\\n    * @dev This function upates the minimun dispute fee as a function of the amount\\n    * of staked miners\\n    */\\n    function updateMinDisputeFee(TellorStorage.TellorStorageStruct storage self) public {\\n        uint256 stakeAmount = self.uintVars[keccak256(\\\"stakeAmount\\\")];\\n        uint256 targetMiners = self.uintVars[keccak256(\\\"targetMiners\\\")];\\n        self.uintVars[keccak256(\\\"disputeFee\\\")] = SafeMath.max(15e18,\\n                (stakeAmount-(stakeAmount*(SafeMath.min(targetMiners,self.uintVars[keccak256(\\\"stakerCount\\\")])*1000)/\\n                targetMiners)/1000));\\n    }\\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/TellorStake.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\nimport \\\"./TellorStorage.sol\\\";\\nimport \\\"./TellorTransfer.sol\\\";\\nimport \\\"./TellorDispute.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n/**\\n* itle Tellor Stake\\n* @dev Contains the methods related to miners staking and unstaking. Tellor.sol\\n* references this library for function's logic.\\n*/\\n\\nlibrary TellorStake {\\n    event NewStake(address indexed _sender); //Emits upon new staker\\n    event StakeWithdrawn(address indexed _sender); //Emits when a staker is now no longer staked\\n    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\\n\\n    /*Functions*/\\n    /**\\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\\n    * can withdraw the deposit\\n    */\\n    function requestStakingWithdraw(TellorStorage.TellorStorageStruct storage self) public {\\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\\n        //Require that the miner is staked\\n        require(stakes.currentStatus == 1, \\\"Miner is not staked\\\");\\n\\n        //Change the miner staked to locked to be withdrawStake\\n        stakes.currentStatus = 2;\\n\\n        //Change the startDate to now since the lock up period begins now\\n        //and the miner can only withdraw 7 days later from now(check the withdraw function)\\n        stakes.startDate = now - (now % 86400);\\n\\n        //Reduce the staker count\\n        self.uintVars[keccak256(\\\"stakerCount\\\")] -= 1;\\n\\n        //Update the minimum dispute fee that is based on the number of stakers \\n        TellorDispute.updateMinDisputeFee(self);\\n        emit StakeWithdrawRequested(msg.sender);\\n    }\\n\\n    /**\\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\\n    */\\n    function withdrawStake(TellorStorage.TellorStorageStruct storage self) public {\\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have\\n        //passed by since they locked for withdraw\\n        require(now - (now % 86400) - stakes.startDate >= 7 days, \\\"7 days didn't pass\\\");\\n        require(stakes.currentStatus == 2, \\\"Miner was not locked for withdrawal\\\");\\n        stakes.currentStatus = 0;\\n        emit StakeWithdrawn(msg.sender);\\n    }\\n\\n    /**\\n    * @dev This function allows miners to deposit their stake.\\n    */\\n    function depositStake(TellorStorage.TellorStorageStruct storage self) public {\\n        newStake(self, msg.sender);\\n        //self adjusting disputeFee\\n        TellorDispute.updateMinDisputeFee(self);\\n    }\\n\\n    /**\\n    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\\n    * The function updates their status/state and status start date so they are locked it so they can't withdraw\\n    * and updates the number of stakers in the system.\\n    */\\n    function newStake(TellorStorage.TellorStorageStruct storage self, address staker) internal {\\n        require(TellorTransfer.balanceOf(self, staker) >= self.uintVars[keccak256(\\\"stakeAmount\\\")], \\\"Balance is lower than stake amount\\\");\\n        //Ensure they can only stake if they are not currrently staked or if their stake time frame has ended\\n        //and they are currently locked for witdhraw\\n        require(self.stakerDetails[staker].currentStatus == 0 || self.stakerDetails[staker].currentStatus == 2, \\\"Miner is in the wrong state\\\");\\n        self.uintVars[keccak256(\\\"stakerCount\\\")] += 1;\\n        self.stakerDetails[staker] = TellorStorage.StakeInfo({\\n            currentStatus: 1, //this resets their stake start date to today\\n            startDate: now - (now % 86400)\\n        });\\n        emit NewStake(staker);\\n    }\\n\\n    /**\\n    * @dev Getter function for the requestId being mined \\n    * @return variables for the current minin event: Challenge, 5 RequestId, difficulty and Totaltips\\n    */\\n    function getNewCurrentVariables(TellorStorage.TellorStorageStruct storage self) internal view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficulty, uint256 _tip){\\n        for(uint i=0;i<5;i++){\\n            _requestIds[i] =  self.currentMiners[i].value;\\n        }\\n        return (self.currentChallenge,_requestIds,self.uintVars[keccak256(\\\"difficulty\\\")],self.uintVars[keccak256(\\\"currentTotalTips\\\")]);\\n    }\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on top 5 requests(highest payout)-- RequestId, Totaltips\\n    */\\n    function getNewVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck) {\\n        idsOnDeck = getTopRequestIDs(self);\\n        for(uint i = 0;i<5;i++){\\n            tipsOnDeck[i] = self.requestDetails[idsOnDeck[i]].apiUintVars[keccak256(\\\"totalTip\\\")];\\n        }\\n    }\\n    \\n    /**\\n    * @dev Getter function for the top 5 requests with highest payouts. This function is used within the getNewVariablesOnDeck function\\n    * @return uint256[5] is an array with the top 5(highest payout) _requestIds at the time the function is called\\n    */\\n    function getTopRequestIDs(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[5] memory _requestIds) {\\n        uint256[5] memory _max;\\n        uint256[5] memory _index;\\n        (_max, _index) = Utilities.getMax5(self.requestQ);\\n        for(uint i=0;i<5;i++){\\n            if(_max[i] != 0){\\n                _requestIds[i] = self.requestIdByRequestQIndex[_index[i]];\\n            }\\n            else{\\n                _requestIds[i] = self.currentMiners[4-i].value;\\n            }\\n        }\\n    }\\n\\n\\n   \\n}\\n\"\r\n    },\r\n    \"tellorcore/contracts/libraries/TellorGettersLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TellorStorage.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n* @title Tellor Getters Library\\n* @dev This is the getter library for all variables in the Tellor Tributes system. TellorGetters references this\\n* libary for the getters logic\\n*/\\nlibrary TellorGettersLibrary {\\n    using SafeMath for uint256;\\n\\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\\n\\n    /*Functions*/\\n\\n    //The next two functions are onlyOwner functions.  For Tellor to be truly decentralized, we will need to transfer the Deity to the 0 address.\\n    //Only needs to be in library\\n    /**\\n    * @dev This function allows us to set a new Deity (or remove it)\\n    * @param _newDeity address of the new Deity of the tellor system\\n    */\\n    function changeDeity(TellorStorage.TellorStorageStruct storage self, address _newDeity) internal {\\n        require(self.addressVars[keccak256(\\\"_deity\\\")] == msg.sender, \\\"Sender is not deity\\\");\\n        self.addressVars[keccak256(\\\"_deity\\\")] = _newDeity;\\n    }\\n\\n    //Only needs to be in library\\n    /**\\n    * @dev This function allows the deity to upgrade the Tellor System\\n    * @param _tellorContract address of new updated TellorCore contract\\n    */\\n    function changeTellorContract(TellorStorage.TellorStorageStruct storage self, address _tellorContract) internal {\\n        require(self.addressVars[keccak256(\\\"_deity\\\")] == msg.sender, \\\"Sender is not deity\\\");\\n        self.addressVars[keccak256(\\\"tellorContract\\\")] = _tellorContract;\\n        emit NewTellorAddress(_tellorContract);\\n    }\\n\\n    /*Tellor Getters*/\\n\\n    /**\\n    * @dev This function tells you if a given challenge has been completed by a given miner\\n    * @param _challenge the challenge to search for\\n    * @param _miner address that you want to know if they solved the challenge\\n    * @return true if the _miner address provided solved the\\n    */\\n    function didMine(TellorStorage.TellorStorageStruct storage self, bytes32 _challenge, address _miner) public view returns (bool) {\\n        return self.minersByChallenge[_challenge][_miner];\\n    }\\n\\n    /**\\n    * @dev Checks if an address voted in a dispute\\n    * @param _disputeId to look up\\n    * @param _address of voting party to look up\\n    * @return bool of whether or not party voted\\n    */\\n    function didVote(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, address _address) internal view returns (bool) {\\n        return self.disputesById[_disputeId].voted[_address];\\n    }\\n\\n    /**\\n    * @dev allows Tellor to read data from the addressVars mapping\\n    * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\n    * These are examples of how the variables are saved within other functions:\\n    * addressVars[keccak256(\\\"_owner\\\")]\\n    * addressVars[keccak256(\\\"tellorContract\\\")]\\n    * @return address requested\\n    */\\n    function getAddressVars(TellorStorage.TellorStorageStruct storage self, bytes32 _data) internal view returns (address) {\\n        return self.addressVars[_data];\\n    }\\n\\n    /**\\n    * @dev Gets all dispute variables\\n    * @param _disputeId to look up\\n    * @return bytes32 hash of dispute\\n    * @return bool executed where true if it has been voted on\\n    * @return bool disputeVotePassed\\n    * @return bool isPropFork true if the dispute is a proposed fork\\n    * @return address of reportedMiner\\n    * @return address of reportingParty\\n    * @return address of proposedForkAddress\\n    * @return uint of requestId\\n    * @return uint of timestamp\\n    * @return uint of value\\n    * @return uint of minExecutionDate\\n    * @return uint of numberOfVotes\\n    * @return uint of blocknumber\\n    * @return uint of minerSlot\\n    * @return uint of quorum\\n    * @return uint of fee\\n    * @return int count of the current tally\\n    */\\n    function getAllDisputeVars(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId)\\n        internal\\n        view\\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\\n    {\\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\\n        return (\\n            disp.hash,\\n            disp.executed,\\n            disp.disputeVotePassed,\\n            disp.isPropFork,\\n            disp.reportedMiner,\\n            disp.reportingParty,\\n            disp.proposedForkAddress,\\n            [\\n                disp.disputeUintVars[keccak256(\\\"requestId\\\")],\\n                disp.disputeUintVars[keccak256(\\\"timestamp\\\")],\\n                disp.disputeUintVars[keccak256(\\\"value\\\")],\\n                disp.disputeUintVars[keccak256(\\\"minExecutionDate\\\")],\\n                disp.disputeUintVars[keccak256(\\\"numberOfVotes\\\")],\\n                disp.disputeUintVars[keccak256(\\\"blockNumber\\\")],\\n                disp.disputeUintVars[keccak256(\\\"minerSlot\\\")],\\n                disp.disputeUintVars[keccak256(\\\"quorum\\\")],\\n                disp.disputeUintVars[keccak256(\\\"fee\\\")]\\n            ],\\n            disp.tally\\n        );\\n    }\\n\\n    /**\\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\\n    */\\n    function getCurrentVariables(TellorStorage.TellorStorageStruct storage self)\\n        internal\\n        view\\n        returns (bytes32, uint256, uint256, string memory, uint256, uint256)\\n    {\\n        return (\\n            self.currentChallenge,\\n            self.uintVars[keccak256(\\\"currentRequestId\\\")],\\n            self.uintVars[keccak256(\\\"difficulty\\\")],\\n            self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].queryString,\\n            self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].apiUintVars[keccak256(\\\"granularity\\\")],\\n            self.requestDetails[self.uintVars[keccak256(\\\"currentRequestId\\\")]].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        );\\n    }\\n\\n    /**\\n    * @dev Checks if a given hash of miner,requestId has been disputed\\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\\n    * @return uint disputeId\\n    */\\n    function getDisputeIdByDisputeHash(TellorStorage.TellorStorageStruct storage self, bytes32 _hash) internal view returns (uint256) {\\n        return self.disputeIdByDisputeHash[_hash];\\n    }\\n\\n    /**\\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\\n    * @param _disputeId is the dispute id;\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the disputeUintVars under the Dispute struct\\n    * @return uint value for the bytes32 data submitted\\n    */\\n    function getDisputeUintVars(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, bytes32 _data)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.disputesById[_disputeId].disputeUintVars[_data];\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @return value for timestamp of last proof of work submited\\n    * @return true if the is a timestamp for the lastNewValue\\n    */\\n    function getLastNewValue(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256, bool) {\\n        return (\\n            retrieveData(\\n                self,\\n                self.requestIdByTimestamp[self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")]],\\n                self.uintVars[keccak256(\\\"timeOfLastNewValue\\\")]\\n            ),\\n            true\\n        );\\n    }\\n\\n    /**\\n    * @dev Gets the a value for the latest timestamp available\\n    * @param _requestId being requested\\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\\n    */\\n    function getLastNewValueById(TellorStorage.TellorStorageStruct storage self, uint256 _requestId) internal view returns (uint256, bool) {\\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\\n        if (_request.requestTimestamps.length != 0) {\\n            return (retrieveData(self, _requestId, _request.requestTimestamps[_request.requestTimestamps.length - 1]), true);\\n        } else {\\n            return (0, false);\\n        }\\n    }\\n\\n    /**\\n    * @dev Gets blocknumber for mined timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up blocknumber\\n    * @return uint of the blocknumber which the dispute was mined\\n    */\\n    function getMinedBlockNum(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return the 5 miners' addresses\\n    */\\n    function getMinersByRequestIdAndTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (address[5] memory)\\n    {\\n        return self.requestDetails[_requestId].minersByValue[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Counts the number of values that have been submited for the request\\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\n    * request so far\\n    * @param _requestId the requestId to look up\\n    * @return uint count of the number of values received for the requestId\\n    */\\n    function getNewValueCountbyRequestId(TellorStorage.TellorStorageStruct storage self, uint256 _requestId) internal view returns (uint256) {\\n        return self.requestDetails[_requestId].requestTimestamps.length;\\n    }\\n\\n    /**\\n    * @dev Getter function for the specified requestQ index\\n    * @param _index to look up in the requestQ array\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByRequestQIndex(TellorStorage.TellorStorageStruct storage self, uint256 _index) internal view returns (uint256) {\\n        require(_index <= 50, \\\"RequestQ index is above 50\\\");\\n        return self.requestIdByRequestQIndex[_index];\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on timestamp\\n    * @param _timestamp to check requestId\\n    * @return uint of reqeuestId\\n    */\\n    function getRequestIdByTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _timestamp) internal view returns (uint256) {\\n        return self.requestIdByTimestamp[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Getter function for requestId based on the qeuaryHash\\n    * @param _queryHash hash(of string api and granularity) to check if a request already exists\\n    * @return uint requestId\\n    */\\n    function getRequestIdByQueryHash(TellorStorage.TellorStorageStruct storage self, bytes32 _queryHash) internal view returns (uint256) {\\n        return self.requestIdByQueryHash[_queryHash];\\n    }\\n\\n    /**\\n    * @dev Getter function for the requestQ array\\n    * @return the requestQ arrray\\n    */\\n    function getRequestQ(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[51] memory) {\\n        return self.requestQ;\\n    }\\n\\n    /**\\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\\n    * for the requestId specified\\n    * @param _requestId to look up\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the apiUintVars under the requestDetails struct\\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\\n    */\\n    function getRequestUintVars(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, bytes32 _data)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestId].apiUintVars[_data];\\n    }\\n\\n    /**\\n    * @dev Gets the API struct variables that are not mappings\\n    * @param _requestId to look up\\n    * @return string of api to query\\n    * @return string of symbol of api to query\\n    * @return bytes32 hash of string\\n    * @return bytes32 of the granularity(decimal places) requested\\n    * @return uint of index in requestQ array\\n    * @return uint of current payout/tip for this requestId\\n    */\\n    function getRequestVars(TellorStorage.TellorStorageStruct storage self, uint256 _requestId)\\n        internal\\n        view\\n        returns (string memory, string memory, bytes32, uint256, uint256, uint256)\\n    {\\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\\n        return (\\n            _request.queryString,\\n            _request.dataSymbol,\\n            _request.queryHash,\\n            _request.apiUintVars[keccak256(\\\"granularity\\\")],\\n            _request.apiUintVars[keccak256(\\\"requestQPosition\\\")],\\n            _request.apiUintVars[keccak256(\\\"totalTip\\\")]\\n        );\\n    }\\n\\n    /**\\n    * @dev This function allows users to retireve all information about a staker\\n    * @param _staker address of staker inquiring about\\n    * @return uint current state of staker\\n    * @return uint startDate of staking\\n    */\\n    function getStakerInfo(TellorStorage.TellorStorageStruct storage self, address _staker) internal view returns (uint256, uint256) {\\n        return (self.stakerDetails[_staker].currentStatus, self.stakerDetails[_staker].startDate);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to look up\\n    * @param _timestamp is the timestampt to look up miners for\\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\\n    */\\n    function getSubmissionsByTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256[5] memory)\\n    {\\n        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Gets the timestamp for the value based on their index\\n    * @param _requestID is the requestId to look up\\n    * @param _index is the value index to look up\\n    * @return uint timestamp\\n    */\\n    function getTimestampbyRequestIDandIndex(TellorStorage.TellorStorageStruct storage self, uint256 _requestID, uint256 _index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestID].requestTimestamps[_index];\\n    }\\n\\n    /**\\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\\n    * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n    * the variables/strings used to save the data in the mapping. The variables names are\\n    * commented out under the uintVars under the TellorStorageStruct struct\\n    * This is an example of how data is saved into the mapping within other functions:\\n    * self.uintVars[keccak256(\\\"stakerCount\\\")]\\n    * @return uint of specified variable\\n    */\\n    function getUintVar(TellorStorage.TellorStorageStruct storage self, bytes32 _data) internal view returns (uint256) {\\n        return self.uintVars[_data];\\n    }\\n\\n    /**\\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\\n    */\\n    function getVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256, uint256, string memory) {\\n        uint256 newRequestId = getTopRequestID(self);\\n        return (\\n            newRequestId,\\n            self.requestDetails[newRequestId].apiUintVars[keccak256(\\\"totalTip\\\")],\\n            self.requestDetails[newRequestId].queryString\\n        );\\n    }\\n\\n    /**\\n    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\\n    * @return uint _requestId of request with highest payout at the time the function is called\\n    */\\n    function getTopRequestID(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256 _requestId) {\\n        uint256 _max;\\n        uint256 _index;\\n        (_max, _index) = Utilities.getMax(self.requestQ);\\n        _requestId = self.requestIdByRequestQIndex[_index];\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @param _requestId to looku p\\n    * @param _timestamp is the timestamp to look up miners for\\n    * @return bool true if requestId/timestamp is under dispute\\n    */\\n    function isInDispute(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp) internal view returns (bool) {\\n        return self.requestDetails[_requestId].inDispute[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Retreive value from oracle based on requestId/timestamp\\n    * @param _requestId being requested\\n    * @param _timestamp to retreive data/value from\\n    * @return uint value for requestId/timestamp submitted\\n    */\\n    function retrieveData(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.requestDetails[_requestId].finalValues[_timestamp];\\n    }\\n\\n    /**\\n    * @dev Getter for the total_supply of oracle tokens\\n    * @return uint total supply\\n    */\\n    function totalSupply(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256) {\\n        return self.uintVars[keccak256(\\\"total_supply\\\")];\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_master\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"_deity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_tBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTotalTips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disputeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disputeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getCurrentValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getLastNewValues\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Lens.value[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getNewValueCountbyRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyRequestIDandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pending_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"internalType\":\"contract TellorMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slotProgress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tellorContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeOfLastNewValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"}],\"name\":\"totalTip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Lens","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000ba45a8b5d5575935b8158a88c631e9f9c95a2e5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}