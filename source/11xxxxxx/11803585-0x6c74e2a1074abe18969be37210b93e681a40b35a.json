{"status":"1","message":"OK","result":[{"SourceCode":"// File: node_modules\\@openzeppelin\\contracts\\GSN\\Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\access\\Ownable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\WarpVaultSCI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpVaultSCI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe WarpVaultSCI contract an abstract contract the WarpControl contract uses to interface\r\n    with a WarpVaultSC contract.\r\n**/\r\n\r\nabstract contract WarpVaultSCI {\r\n    uint256 public totalReserves;\r\n\r\n    function borrowBalanceCurrent(address account)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function borrowBalancePrior(address account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function exchangeRateCurrent() public virtual returns (uint256);\r\n\r\n    function _borrow(uint256 _borrowAmount, address _borrower) external virtual;\r\n\r\n    function _repayLiquidatedLoan(\r\n        address _borrower,\r\n        address _liquidator,\r\n        uint256 _amount\r\n    ) public virtual;\r\n\r\n    function setNewInterestModel(address _newModel) public virtual;\r\n\r\n    function getSCDecimals() public virtual view returns (uint8);\r\n\r\n    function getSCAddress() public virtual view returns (address);\r\n\r\n    function updateWarpControl(address _warpControl) public virtual;\r\n\r\n    function updateTeam(address _warpTeam) public virtual;\r\n\r\n    function viewAccountBalance(address _account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts\\interfaces\\WarpVaultLPI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpVaultLPI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe WarpVaultLPI contract an abstract contract the WarpControl contract uses to interface\r\n    with a WarpVaultLP contract.\r\n**/\r\n\r\nabstract contract WarpVaultLPI {\r\n    function getAssetAdd() public virtual view returns (address);\r\n\r\n    function collateralOfAccount(address _account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function _liquidateAccount(address _account, address _liquidator)\r\n        public\r\n        virtual;\r\n\r\n    function updateWarpControl(address _warpControl) public virtual;\r\n}\r\n\r\n// File: contracts\\interfaces\\WarpVaultLPFactoryI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpVaultLPFactoryI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe WarpVaultLPFactory contract is designed to produce individual WarpVaultLP contracts\r\n**/\r\n\r\nabstract contract WarpVaultLPFactoryI {\r\n    function createWarpVaultLP(\r\n        uint256 _timelock,\r\n        address _lp\r\n    ) public virtual returns (address);\r\n}\r\n\r\n// File: contracts\\interfaces\\WarpVaultSCFactoryI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpVaultSCFactoryI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe WarpVaultSCFactoryI contract is used by the Warp Control contract to interface with the WarpVaultSCFactory contract\r\n**/\r\n\r\nabstract contract WarpVaultSCFactoryI {\r\n    function createNewWarpVaultSC(\r\n        address _InterestRate,\r\n        address _StableCoin,\r\n        address _warpTeam,\r\n        uint256 _initialExchangeRate,\r\n        uint256 _timelock,\r\n        uint256 _reserveFactorMantissa\r\n    ) public virtual returns (address);\r\n}\r\n\r\n// File: contracts\\interfaces\\SwapLPOracleI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title SwapLPOracleI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe SwapLPOracleI contract an abstract contract the Warp platform uses to interface\r\n    With the SwapOracle to retrieve token prices.\r\n**/\r\n\r\nabstract contract SwapLPOracleI {\r\n    function addChainlinkETHOracle(\r\n                                   address oracle, address token\r\n    ) public virtual;\r\n\r\n    function OneUSDC() public virtual view returns (uint256);\r\n    function OneWETH() public virtual view returns (uint256);\r\n\r\n    function getUnderlyingPrice(address _MMI) public virtual returns (uint256);\r\n\r\n    function getPriceOfToken(address _token, uint256 _amount)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function transferOwnership(address _newOwner) public virtual;\r\n\r\n    function _calculatePriceOfLP(\r\n        uint256 supply,\r\n        uint256 value0,\r\n        uint256 value1,\r\n        uint256 reserve0,\r\n        uint256 reserve1\r\n    ) public virtual pure returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\compound\\BaseJumpRateModelV2.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Logic for Compound's JumpRateModel Contract V2.\r\n * @author Compound (modified by Dharma Labs, refactored by Arr00)\r\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\r\n */\r\ncontract BaseJumpRateModelV2 {\r\n    using SafeMath for uint256;\r\n\r\n    event NewInterestParams(\r\n        uint256 baseRatePerBlock,\r\n        uint256 multiplierPerBlock,\r\n        uint256 jumpMultiplierPerBlock,\r\n        uint256 kink\r\n    );\r\n\r\n    /**\r\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\r\n     */\r\n    address public owner;\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint256 public constant blocksPerYear = 2102400;\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint256 public multiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint256 public baseRatePerBlock;\r\n\r\n    /**\r\n     * @notice The multiplierPerBlock after hitting a specified utilization point\r\n     */\r\n    uint256 public jumpMultiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The utilization point at which the jump multiplier is applied\r\n     */\r\n    uint256 public kink;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\r\n     */\r\n    constructor(\r\n        uint256 baseRatePerYear,\r\n        uint256 multiplierPerYear,\r\n        uint256 jumpMultiplierPerYear,\r\n        uint256 kink_,\r\n        address owner_\r\n    ) internal {\r\n        owner = owner_;\r\n\r\n        updateJumpRateModelInternal(\r\n            baseRatePerYear,\r\n            multiplierPerYear,\r\n            jumpMultiplierPerYear,\r\n            kink_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     */\r\n    function updateJumpRateModel(\r\n        uint256 baseRatePerYear,\r\n        uint256 multiplierPerYear,\r\n        uint256 jumpMultiplierPerYear,\r\n        uint256 kink_\r\n    ) external {\r\n        require(msg.sender == owner, \"only the owner may call this function.\");\r\n\r\n        updateJumpRateModelInternal(\r\n            baseRatePerYear,\r\n            multiplierPerYear,\r\n            jumpMultiplierPerYear,\r\n            kink_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market (currently unused)\r\n     * @return The utilization rate as a mantissa between [0, 1e18]\r\n     */\r\n    function utilizationRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves\r\n    ) public pure returns (uint256) {\r\n        // Utilization rate is 0 when there are no borrows\r\n        if (borrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRateInternal(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves\r\n    ) internal view returns (uint256) {\r\n        uint256 util = utilizationRate(cash, borrows, reserves);\r\n\r\n        if (util <= kink) {\r\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n        } else {\r\n            uint256 normalRate =\r\n                kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n            uint256 excessUtil = util.sub(kink);\r\n            return\r\n                excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(\r\n                    normalRate\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @param reserveFactorMantissa The current reserve factor for the market\r\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getSupplyRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves,\r\n        uint256 reserveFactorMantissa\r\n    ) public view returns (uint256) {\r\n        uint256 oneMinusReserveFactor =\r\n            uint256(1e18).sub(reserveFactorMantissa);\r\n        uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);\r\n        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\r\n        return\r\n            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to update the parameters of the interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     */\r\n    function updateJumpRateModelInternal(\r\n        uint256 baseRatePerYear,\r\n        uint256 multiplierPerYear,\r\n        uint256 jumpMultiplierPerYear,\r\n        uint256 kink_\r\n    ) internal {\r\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\r\n        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(\r\n            blocksPerYear.mul(kink_)\r\n        );\r\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\r\n        kink = kink_;\r\n\r\n        emit NewInterestParams(\r\n            baseRatePerBlock,\r\n            multiplierPerBlock,\r\n            jumpMultiplierPerBlock,\r\n            kink\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts\\compound\\JumpRateModelV2.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title Compound's JumpRateModel Contract V2 for V2 cTokens\r\n  * @author Arr00\r\n  * @notice Supports only for V2 cTokens\r\n  */\r\ncontract JumpRateModelV2 is  BaseJumpRateModelV2  {\r\n\r\n\t/**\r\n     * @notice Calculates the current borrow rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external  view returns (uint) {\r\n        return getBorrowRateInternal(cash, borrows, reserves);\r\n    }\r\n\r\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_)\r\n    \tBaseJumpRateModelV2(baseRatePerYear,multiplierPerYear,jumpMultiplierPerYear,kink_,owner_) public {}\r\n}\r\n\r\n// File: contracts\\compound\\CarefulMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author Compound\r\n\r\n/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\n// File: contracts\\compound\\Exponential.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n\r\n// File: @uniswap\\v2-core\\contracts\\interfaces\\IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts\\WarpControl.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n//import \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpControl\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nWarpControl is designed to coordinate Warp Vaults\r\nThis contract uses the OpenZeppelin contract Library to inherit functions from\r\n  Ownable.sol\r\n**/\r\n\r\ncontract WarpControl is Ownable, Exponential {\r\n    using SafeMath for uint256;\r\n\r\n    SwapLPOracleI public oracle; //oracle contract \r\n    WarpVaultLPFactoryI public WVLPF;\r\n    WarpVaultSCFactoryI public WVSCF;\r\n\r\n    address public warpTeam;\r\n    address public newWarpControl;\r\n    uint256 public graceSpace;\r\n\r\n    address[] public lpVaults;\r\n    address[] public scVaults;\r\n\r\n    mapping(address => address) public instanceLPTracker; //maps LP token address to the assets WarpVault\r\n    mapping(address => address) public instanceSCTracker;\r\n    mapping(address => address) public getAssetByVault;\r\n    mapping(address => bool) public isVault;\r\n\r\n    uint256 public borrowLimitPercentage = 66 ether;  // max percentage of collateral value allowed to borrow, with 18 decimals\r\n    uint256 public liquidateLimitPercentage = 75 ether; // max percentage of collateral value before liquidation can occur\r\n    uint256 public liquidationFee = 15 ether; // percentage of LP tokens to give to warp team upon liquidation\r\n\r\n    event LogEvent2(uint256 lnum);\r\n    event NewLPVault(address _newVault);\r\n    event ImportedLPVault(address _vault);\r\n    event NewSCVault(address _newVault, address _interestRateModel);\r\n    event ImportedSCVault(address _vault);\r\n    event NewBorrow(\r\n        address _borrower,\r\n        address _StableCoin,\r\n        uint256 _amountBorrowed\r\n    );\r\n    event Liquidation(address _account, address liquidator);\r\n    event NewInterestRateModelCreated(\r\n      address _token,\r\n      uint256 _baseRatePerYear,\r\n      uint256 _multiplierPerYear,\r\n      uint256 _jumpMultiplierPerYear,\r\n      uint256 _optimal\r\n    );\r\n\r\n    /**\r\n      @dev Throws if called by any account other than a warp vault\r\n     */\r\n    modifier onlyVault() {\r\n        require(isVault[msg.sender] == true, \"Only a vault may call this\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice the constructor function is fired during the contract deployment process. The constructor can only be fired once and\r\n            is used to set up OracleFactory variables for the MoneyMarketFactory contract.\r\n    @param _oracle is the address for the UniswapOracleFactorycontract\r\n    @param _WVLPF is the address for the WarpVaultLPFactory used to produce LP Warp Vaults\r\n    @param _WVSCF is the address for the WarpVaultSCFactory used to produce Stable Coin Warp Vaults\r\n    @dev These factories are split into seperate contracts to avoid hitting the block gas limit\r\n    **/\r\n    constructor(\r\n        address _oracle,\r\n        address _WVLPF,\r\n        address _WVSCF,\r\n        address _warpTeam\r\n    ) public {\r\n        //instantiate the contracts\r\n        oracle = SwapLPOracleI(_oracle);\r\n        WVLPF = WarpVaultLPFactoryI(_WVLPF);\r\n        WVSCF = WarpVaultSCFactoryI(_WVSCF);\r\n        warpTeam = _warpTeam;\r\n    }\r\n\r\n    /**\r\n    @notice viewNumLPVaults returns the number of lp vaults on the warp platform\r\n    **/\r\n    function viewNumLPVaults() external view returns (uint256) {\r\n        return lpVaults.length;\r\n    }\r\n\r\n    /**\r\n    @notice viewNumSCVaults returns the number of stablecoin vaults on the warp platform\r\n    **/\r\n    function viewNumSCVaults() external view returns (uint256) {\r\n        return scVaults.length;\r\n    }\r\n     /**\r\n    @notice createNewLPVault allows the contract owner to create a new WarpVaultLP contract for a specific LP token\r\n    @param _timelock is a variable representing the number of seconds the timeWizard will prevent withdraws and borrows from a contracts(one week is 605800 seconds)\r\n    @param _lp is the address for the LP token this Warp Vault will manage\r\n    **/\r\n    function createNewLPVault( \r\n        uint256 _timelock,\r\n        address _lp\r\n    ) public onlyOwner {\r\n \r\n        require(instanceLPTracker[_lp] == address(0), \"LP vault already exists\");\r\n\r\n        //create new Warp LP Vault\r\n        address _WarpVault = WVLPF.createWarpVaultLP(_timelock, _lp);\r\n        //track the warp vault lp instance by the address of the LP it represents\r\n        instanceLPTracker[_lp] = _WarpVault;\r\n        //add new LP Vault to the array of all LP vaults\r\n        lpVaults.push(_WarpVault);\r\n        //set Warp vault address as an approved vault\r\n        isVault[_WarpVault] = true;\r\n        //track vault to asset\r\n        getAssetByVault[_WarpVault] = _lp;\r\n        emit NewLPVault(_WarpVault);\r\n    }\r\n\r\n    function importLPVault(address _lpVault) public onlyOwner {\r\n      require(isVault[_lpVault] == false);\r\n        WarpVaultLPI _vault = WarpVaultLPI(_lpVault);\r\n        address _lp = _vault.getAssetAdd();\r\n\r\n        instanceLPTracker[_lp] = _lpVault;\r\n        lpVaults.push(_lpVault);\r\n        isVault[_lpVault] = true;\r\n        getAssetByVault[_lpVault] = _lp;\r\n        emit ImportedLPVault(_lpVault);\r\n    }\r\n\r\n\r\n    /**\r\n    @notice createNewSCVault allows the contract owner to create a new WarpVaultLP contract for a specific LP token\r\n    @param _timelock is a variable representing the number of seconds the timeWizard will prevent withdraws and borrows from a contracts(one week is 605800 seconds)\r\n    @param _baseRatePerYear is the base rate per year(approx target base APR)\r\n    @param _multiplierPerYear is the multiplier per year(rate of increase in interest w/ utilizastion)\r\n    @param _jumpMultiplierPerYear is the Jump Multiplier Per Year(the multiplier per block after hitting a specific utilizastion point)\r\n    @param _optimal is the this is the utilizastion point or \"kink\" at which the jump multiplier is applied\r\n    @param _initialExchangeRate is the intitial exchange rate(the rate at which the initial exchange of asset/ART is set)\r\n    @param _StableCoin is the address of the StableCoin this Warp Vault will manage\r\n    **/\r\n    function createNewSCVault(\r\n        uint256 _timelock,\r\n        uint256 _baseRatePerYear,\r\n        uint256 _multiplierPerYear,\r\n        uint256 _jumpMultiplierPerYear,\r\n        uint256 _optimal,\r\n        uint256 _initialExchangeRate,\r\n        uint256 _reserveFactorMantissa,\r\n        address _StableCoin\r\n    ) public onlyOwner {\r\n        //create the interest rate model for this stablecoin\r\n        address IR = address(\r\n            new JumpRateModelV2(\r\n                _baseRatePerYear,\r\n                _multiplierPerYear,\r\n                _jumpMultiplierPerYear,\r\n                _optimal,\r\n                address(this)\r\n            )\r\n        );\r\n        //create the SC Warp vault\r\n        address _WarpVault = WVSCF.createNewWarpVaultSC(\r\n            IR,\r\n            _StableCoin,\r\n            warpTeam,\r\n            _initialExchangeRate,\r\n            _timelock,\r\n            _reserveFactorMantissa\r\n        );\r\n        //track the warp vault sc instance by the address of the stablecoin it represents\r\n        instanceSCTracker[_StableCoin] = _WarpVault;\r\n        //add new SC Vault to the array of all SC vaults\r\n        scVaults.push(_WarpVault);\r\n        //set Warp vault address as an approved vault\r\n        isVault[_WarpVault] = true;\r\n        //track vault to asset\r\n        getAssetByVault[_WarpVault] = _StableCoin;\r\n        emit NewSCVault(_WarpVault, IR);\r\n    }\r\n\r\n    function importSCVault(address _scVault) public onlyOwner {\r\n      require(isVault[_scVault] == false);\r\n\r\n        WarpVaultSCI _vault = WarpVaultSCI(_scVault);\r\n        address _token = _vault.getSCAddress();\r\n\r\n        // track token -> vault\r\n        instanceSCTracker[_token] = _scVault;\r\n        // vault list\r\n        scVaults.push(_scVault);\r\n        // register vault in mapping\r\n        isVault[_scVault] = true;\r\n        // track vault -> token\r\n        getAssetByVault[_scVault] = _token;\r\n        emit ImportedSCVault(_scVault);\r\n    }\r\n\r\n    function setBorrowThreshold(uint256 _borrowLimitPercentage) public onlyOwner {\r\n        borrowLimitPercentage = _borrowLimitPercentage;\r\n    }\r\n\r\n    function setLiquidateThreshold(uint256 _liquidateimitPercentage) public onlyOwner{\r\n        liquidateLimitPercentage = _liquidateimitPercentage;\r\n    }\r\n\r\n    function setLiquidationFee(uint256 _liquidationFee) public onlyOwner {\r\n        liquidationFee = _liquidationFee;\r\n    }\r\n\r\n    /**\r\n    @notice Figures out how much of a given LP token an account is allowed to withdraw\r\n    @param account is the account being checked\r\n    @param lpToken is the address of the lpToken the user wishes to withdraw\r\n    @dev this function runs calculations to accrue interest for an up to date amount\r\n     */\r\n    function getMaxWithdrawAllowed(address account, address lpToken)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        uint256 borrowedTotal = getTotalBorrowedValue(account);\r\n        uint256 collateralValue = getTotalAvailableCollateralValue(account);\r\n        uint256 requiredCollateral = calcCollateralRequired(borrowedTotal);\r\n        if (collateralValue < requiredCollateral) {\r\n            return 0;\r\n        }\r\n        uint256 leftoverCollateral = collateralValue.sub(requiredCollateral);\r\n        uint256 lpValue = oracle.getUnderlyingPrice(lpToken);\r\n        return leftoverCollateral.mul(1e18).div(lpValue);\r\n    }\r\n\r\n\r\n    /**\r\n    @notice getTotalAvailableCollateralValue returns the total availible collaeral value for an account in USDC\r\n    @param _account is the address whos collateral is being retreived\r\n    @dev this function runs calculations to accrue interest for an up to date amount\r\n    **/\r\n    function getTotalAvailableCollateralValue(address _account)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        //get the number of LP vaults the platform has\r\n        uint256 numVaults = lpVaults.length;\r\n        //initialize the totalCollateral variable to zero\r\n        uint256 totalCollateral = 0;\r\n        //loop through each lp wapr vault\r\n        for (uint256 i = 0; i < numVaults; ++i) {\r\n            //instantiate warp vault at that position\r\n            WarpVaultLPI vault = WarpVaultLPI(lpVaults[i]);\r\n            //retreive the address of its asset\r\n            address asset = vault.getAssetAdd();\r\n            //retrieve USD price of this asset\r\n            uint256 assetPrice = oracle.getUnderlyingPrice(asset);\r\n\r\n            uint256 accountCollateral = vault.collateralOfAccount(_account);\r\n            //emit DebugValues(accountCollateral, assetPrice);\r\n\r\n            //multiply the amount of collateral by the asset price and return it\r\n            uint256 accountAssetsValue = accountCollateral.mul(assetPrice);\r\n            //add value to total collateral\r\n            totalCollateral = totalCollateral.add(accountAssetsValue);\r\n        }\r\n        //return total USDC value of all collateral\r\n        return totalCollateral.div(1e18);\r\n    }\r\n\r\n    /**\r\n    @notice getPriceOfCollateral returns the price of an lpToken\r\n    @param lpToken is the address of the lp token\r\n    @dev this function does not run calculations amd returns the previously calculated price\r\n    **/\r\n    function getPriceOfCollateral(address lpToken) public returns (uint256) {\r\n        return oracle.getUnderlyingPrice(lpToken);\r\n    }\r\n\r\n    /**\r\n    @notice viewPriceOfToken retrieves the price of a stablecoin\r\n    @param token is the address of the stablecoin\r\n    @param amount is the amount of stablecoin\r\n    @dev this function does not run calculations amd returns the previously calculated price\r\n    **/\r\n    function getPriceOfToken(address token, uint256 amount)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return oracle.getPriceOfToken(token, amount);\r\n    }\r\n\r\n    /**\r\n    @notice getTotalLentValue returns the total lent value for an account in USDC\r\n    @param _account is the account whos lent value we are calculating\r\n    **/\r\n    function getTotalLentValue(address _account)\r\n        public\r\n        //view\r\n        returns (uint256)\r\n    {\r\n        uint256 numSCVaults = scVaults.length;\r\n        uint256 totalValue = 0;\r\n\r\n        // Add up each stable coin vaults value\r\n        for (uint256 i = 0; i < numSCVaults; ++i) {\r\n            //instantiate each LP warp vault\r\n            WarpVaultSCI WVSC = WarpVaultSCI(scVaults[i]);\r\n            //retreive the amount user has borrowed from each stablecoin vault\r\n            uint256 lentBalanceInStable = WVSC.viewAccountBalance(_account);\r\n            if (lentBalanceInStable == 0) {\r\n                continue;\r\n            }\r\n            uint256 usdcLentAmount = getPriceOfToken(\r\n                WVSC.getSCAddress(),\r\n                lentBalanceInStable\r\n            );\r\n            totalValue = totalValue.add(usdcLentAmount);\r\n        }\r\n\r\n        return totalValue;\r\n    }\r\n\r\n    /**\r\n    @notice viewTotalBorrowedValue returns the total borrowed value for an account in USDC\r\n    @param _account is the account whos borrowed value we are calculating\r\n    @dev this function returns newly calculated values\r\n    **/\r\n    function getTotalBorrowedValue(address _account) public returns (uint256) {\r\n        uint256 numSCVaults = scVaults.length;\r\n        //initialize the totalBorrowedValue variable to zero\r\n        uint256 totalBorrowedValue = 0;\r\n        //loop through all stable coin vaults\r\n        for (uint256 i = 0; i < numSCVaults; ++i) {\r\n            //instantiate each LP warp vault\r\n            WarpVaultSCI WVSC = WarpVaultSCI(scVaults[i]);\r\n            //retreive the amount user has borrowed from each stablecoin vault\r\n            uint256 borrowBalanceInStable = WVSC.borrowBalanceCurrent(_account);\r\n            if (borrowBalanceInStable == 0) {\r\n                continue;\r\n            }\r\n            uint256 usdcBorrowedAmount = getPriceOfToken(\r\n                WVSC.getSCAddress(),\r\n                borrowBalanceInStable\r\n            );\r\n            totalBorrowedValue = totalBorrowedValue.add(usdcBorrowedAmount);\r\n        }\r\n        //return total Borrowed Value\r\n        return totalBorrowedValue;\r\n    }\r\n\r\n    function calcBorrowLimit(uint256 _collateralValue)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _collateralValue.mul(borrowLimitPercentage).div(100 ether);\r\n    }\r\n\r\n    function calcLiquidationLimit(uint256 _collateralValue)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _collateralValue.mul(liquidateLimitPercentage).div(100 ether);\r\n    }\r\n\r\n    /**\r\n    @notice calcCollateralRequired returns the amount of collateral needed for an input borrow value\r\n    liquidatteLimitPercentage\r\n    @param _borrowAmount is the input borrow amount\r\n    **/\r\n    function calcCollateralRequired(uint256 _borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _borrowAmount.mul(100 ether).div(borrowLimitPercentage);\r\n    }\r\n\r\n    /**\r\n    @notice getBorrowLimit returns the borrow limit for an account\r\n    @param _account is the input account address\r\n    @dev this calculation uses current values for calculations\r\n    **/\r\n    function getBorrowLimit(address _account) public returns (uint256) {\r\n        uint256 availibleCollateralValue = getTotalAvailableCollateralValue(\r\n            _account\r\n        );\r\n\r\n        return calcBorrowLimit(availibleCollateralValue);\r\n    }\r\n\r\n    function getLiquidationLimit(address _account) public returns (uint256) {\r\n        uint256 availibleCollateralValue = getTotalAvailableCollateralValue(\r\n            _account\r\n        );\r\n\r\n        return calcLiquidationLimit(availibleCollateralValue);\r\n    }\r\n\r\n    /**\r\n    @notice borrowSC is the function an end user will call when they wish to borrow a stablecoin from the warp platform\r\n    @param _StableCoin is the address of the stablecoin the user wishes to borrow\r\n    @param _amount is the amount of that stablecoin the user wants to borrow\r\n    **/\r\n    function borrowSC(address _StableCoin, uint256 _amount) public {\r\n        uint256 borrowedTotalInUSDC = getTotalBorrowedValue(msg.sender);\r\n        uint256 borrowLimitInUSDC = getBorrowLimit(msg.sender);\r\n        uint256 borrowAmountAllowedInUSDC = borrowLimitInUSDC.sub(\r\n            borrowedTotalInUSDC\r\n        );\r\n\r\n        uint256 borrowAmountInUSDC = getPriceOfToken(_StableCoin, _amount);\r\n\r\n        //require the amount being borrowed is less than or equal to the amount they are aloud to borrow\r\n        require(\r\n            borrowAmountAllowedInUSDC >= borrowAmountInUSDC,\r\n            \"Borrowing more than allowed\"\r\n        );\r\n\r\n        //retreive stablecoin vault address being borrowed from and instantiate it\r\n        WarpVaultSCI WV = WarpVaultSCI(instanceSCTracker[_StableCoin]);\r\n        //call _borrow function on the stablecoin warp vault\r\n        WV._borrow(_amount, msg.sender);\r\n        emit NewBorrow(msg.sender, _StableCoin, _amount);\r\n    }\r\n\r\n    /**\r\n    @notice liquidateAccount is used to liquidate a non-compliant loan after it has reached its 30 minute grace period\r\n    @param _borrower is the address of the borrower whos loan is non-compliant\r\n    **/\r\n    function liquidateAccount(address _borrower) public {\r\n        //require the liquidator is not also the borrower\r\n        require(msg.sender != _borrower, \"you cant liquidate yourself\");\r\n        //retreive the number of stablecoin vaults in the warp platform\r\n        uint256 numSCVaults = scVaults.length;\r\n        //retreive the number of LP vaults in the warp platform\r\n        uint256 numLPVaults = lpVaults.length;\r\n        // This is how much USDC worth of Stablecoin the user has borrowed\r\n        uint256 borrowedAmount = 0;\r\n        //initialize the stable coin balances array\r\n        uint256[] memory scBalances = new uint256[](numSCVaults);\r\n        // loop through and retreive the Borrowed Amount From All Vaults\r\n        for (uint256 i = 0; i < numSCVaults; ++i) {\r\n            //instantiate the vault at the current  position in the array\r\n            WarpVaultSCI scVault = WarpVaultSCI(scVaults[i]);\r\n            //retreive the borrowers borrow balance from this vault and add it to the scBalances array\r\n            scBalances[i] = scVault.borrowBalanceCurrent(_borrower);\r\n            uint256 borrowedAmountInUSDC = getPriceOfToken(\r\n                getAssetByVault[address(scVault)],\r\n                scBalances[i]\r\n            );\r\n\r\n            //add the borrowed amount to the total borrowed balance\r\n            borrowedAmount = borrowedAmount.add(borrowedAmountInUSDC);\r\n        }\r\n        //retreve the USDC borrow limit for the borrower\r\n        uint256 liquidationLimit = getLiquidationLimit(_borrower);\r\n        \r\n        //check if the borrow is less than the borrowed amount\r\n        require(borrowedAmount > liquidationLimit, \"Loan is still valid\");\r\n\r\n        // If it is Liquidate the account\r\n        //loop through each SC vault so the  Liquidator can pay off Stable Coin loans\r\n        for (uint256 i = 0; i < numSCVaults; ++i) {\r\n            //instantiate the Warp SC Vault at the current position\r\n            WarpVaultSCI scVault = WarpVaultSCI(scVaults[i]);\r\n            //call repayLiquidatedLoan function to repay the loan\r\n            scVault._repayLiquidatedLoan(\r\n                _borrower,\r\n                msg.sender,\r\n                scBalances[i]\r\n            );\r\n        }\r\n        //loop through each LP vault so the Liquidator gets the LP tokens the borrower had\r\n        for (uint256 i = 0; i < numLPVaults; ++i) {\r\n            //instantiate the Warp LP Vault at the current position\r\n            WarpVaultLPI lpVault = WarpVaultLPI(lpVaults[i]);\r\n            \r\n            //call liquidateAccount function on that LP vault and transfer LP tokens to warp control\r\n            lpVault._liquidateAccount(_borrower, address(this));\r\n\r\n            IUniswapV2Pair lpToken = IUniswapV2Pair(lpVault.getAssetAdd());\r\n\r\n            // transfer 15% of those tokens to the warp team\r\n            lpToken.transfer(warpTeam, lpToken.balanceOf(address(this)) * liquidationFee / 100 ether);\r\n\r\n            // transfer the remaining to liquidator\r\n            lpToken.transfer(msg.sender, lpToken.balanceOf(address(this)));\r\n        }\r\n        emit Liquidation(_borrower, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @notice updateInterestRateModel allows the warp team to update the interest rate model for a stablecoin\r\n    @param _token is the address of the stablecoin whos vault is having its interest rate updated\r\n    @param _baseRatePerYear is the base rate per year(approx target base APR)\r\n    @param _multiplierPerYear is the multiplier per year(rate of increase in interest w/ utilizastion)\r\n    @param _jumpMultiplierPerYear is the Jump Multiplier Per Year(the multiplier per block after hitting a specific utilizastion point)\r\n    @param _optimal is the this is the utilizastion point or \"kink\" at which the jump multiplier is applied\r\n    **/\r\n    function updateInterestRateModel(\r\n        address _token,\r\n        uint256 _baseRatePerYear,\r\n        uint256 _multiplierPerYear,\r\n        uint256 _jumpMultiplierPerYear,\r\n        uint256 _optimal\r\n    ) public onlyOwner {\r\n        address IR = address(\r\n            new JumpRateModelV2(\r\n                _baseRatePerYear,\r\n                _multiplierPerYear,\r\n                _jumpMultiplierPerYear,\r\n                _optimal,\r\n                address(this)\r\n            )\r\n        );\r\n        address vault = instanceSCTracker[_token];\r\n        WarpVaultSCI WV = WarpVaultSCI(vault);\r\n        WV.setNewInterestModel(IR);\r\n        emit NewInterestRateModelCreated(\r\n          _token,\r\n           _baseRatePerYear,\r\n          _multiplierPerYear,\r\n          _jumpMultiplierPerYear,\r\n          _optimal\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice startUpgradeTimer starts a two day timer signaling that this contract will soon be updated to a new version\r\n    @param _newWarpControl is the address of the new Warp control contract being upgraded to\r\n    **/\r\n    function startUpgradeTimer(address _newWarpControl) public onlyOwner {\r\n        newWarpControl = _newWarpControl;\r\n        graceSpace = now.add(172800);\r\n    }\r\n\r\n    /**\r\n    @notice upgradeWarp is used to upgrade the Warp platform to use a new version of the WarpControl contract\r\n    **/\r\n    function upgradeWarp() public onlyOwner {\r\n        require(now >= graceSpace, \"you cant ugrade yet, less than two days\");\r\n        require(newWarpControl != address(0), \"no new warp control set\");\r\n\r\n        oracle.transferOwnership(newWarpControl);\r\n\r\n        uint256 numVaults = lpVaults.length;\r\n        uint256 numSCVaults = scVaults.length;\r\n\r\n        for (uint256 i = 0; i < numVaults; ++i) {\r\n            WarpVaultLPI vault = WarpVaultLPI(lpVaults[i]);\r\n            vault.updateWarpControl(newWarpControl);\r\n        }\r\n\r\n        for (uint256 i = 0; i < numSCVaults; ++i) {\r\n            WarpVaultSCI vault = WarpVaultSCI(scVaults[i]);\r\n            vault.updateWarpControl(newWarpControl);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice transferWarpTeam allows the wapr team address to be changed by the owner account\r\n    @param _newWarp is the address of the new warp team\r\n    **/\r\n    function transferWarpTeam(address _newWarp) public onlyOwner {\r\n        uint256 numSCVaults = scVaults.length;\r\n        warpTeam = _newWarp;\r\n        for (uint256 i = 0; i < numSCVaults; ++i) {\r\n            WarpVaultSCI WVSC = WarpVaultSCI(scVaults[i]);\r\n            WVSC.updateTeam(_newWarp);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WVLPF\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WVSCF\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_warpTeam\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"ImportedLPVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"ImportedSCVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lnum\",\"type\":\"uint256\"}],\"name\":\"LogEvent2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_StableCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountBorrowed\",\"type\":\"uint256\"}],\"name\":\"NewBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseRatePerYear\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_multiplierPerYear\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_jumpMultiplierPerYear\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_optimal\",\"type\":\"uint256\"}],\"name\":\"NewInterestRateModelCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newVault\",\"type\":\"address\"}],\"name\":\"NewLPVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_interestRateModel\",\"type\":\"address\"}],\"name\":\"NewSCVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WVLPF\",\"outputs\":[{\"internalType\":\"contract WarpVaultLPFactoryI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WVSCF\",\"outputs\":[{\"internalType\":\"contract WarpVaultSCFactoryI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowLimitPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_StableCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowSC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralValue\",\"type\":\"uint256\"}],\"name\":\"calcBorrowLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowAmount\",\"type\":\"uint256\"}],\"name\":\"calcCollateralRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralValue\",\"type\":\"uint256\"}],\"name\":\"calcLiquidationLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"createNewLPVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timelock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseRatePerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplierPerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_jumpMultiplierPerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_optimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_StableCoin\",\"type\":\"address\"}],\"name\":\"createNewSCVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getAssetByVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getBorrowLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getLiquidationLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"name\":\"getMaxWithdrawAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"name\":\"getPriceOfCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPriceOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTotalAvailableCollateralValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTotalBorrowedValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTotalLentValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"graceSpace\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpVault\",\"type\":\"address\"}],\"name\":\"importLPVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_scVault\",\"type\":\"address\"}],\"name\":\"importSCVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"instanceLPTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"instanceSCTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"liquidateAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidateLimitPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpVaults\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newWarpControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract SwapLPOracleI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scVaults\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowLimitPercentage\",\"type\":\"uint256\"}],\"name\":\"setBorrowThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidateimitPercentage\",\"type\":\"uint256\"}],\"name\":\"setLiquidateThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidationFee\",\"type\":\"uint256\"}],\"name\":\"setLiquidationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWarpControl\",\"type\":\"address\"}],\"name\":\"startUpgradeTimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWarp\",\"type\":\"address\"}],\"name\":\"transferWarpTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseRatePerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplierPerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_jumpMultiplierPerYear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_optimal\",\"type\":\"uint256\"}],\"name\":\"updateInterestRateModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeWarp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewNumLPVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewNumSCVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"warpTeam\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WarpControl","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007933e8b6861dfb0e1db75a8b55baef62f05936d4000000000000000000000000a2c93074681270c4d51e3402b0f1b2bc5694210900000000000000000000000007aad26d0ed27d0ae43b908fcb581a751acf70490000000000000000000000000efe54e77e5cc430342088da27ef73f42b482d33","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3651bfbe0b6e952a6afb06acbe2fe772c70fb4111396b593f5239b901c297bc7"}]}