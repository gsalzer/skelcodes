{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/managers/TokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport {Ownable} from \\\"../roles/Ownable.sol\\\";\\n\\n\\ninterface ITokenManager\\n{\\n  function isWhitelisted(address token) external view returns (bool);\\n\\n  function isStableToken(address token) external view returns (bool);\\n\\n  function isDynamicToken(address token) external view returns (bool);\\n\\n  function isBothStable(address tokenA, address tokenB) external view returns (bool);\\n\\n  function isBothWhitelisted(address tokenA, address tokenB) external view returns (bool);\\n}\\n\\ncontract TokenManager is ITokenManager, Ownable\\n{\\n  using SafeMath for uint256;\\n\\n\\n  address[] private _stableTokens;\\n  address[] private _dynamicTokens;\\n  address[] private _whitelistedTokens;\\n\\n  uint256 private _tokenID;\\n  uint256 private _stableTokenID;\\n  uint256 private _dynamicTokenID;\\n  mapping(address => uint256) private _tokenIDOf;\\n  mapping(address => bool) private _whitelistedToken;\\n  mapping(address => bool) private _stableToken;\\n  mapping(address => uint256) private _stableTokenIDOf;\\n  mapping(address => bool) private _dynamicToken;\\n  mapping(address => uint256) private _dynamicTokenIDOf;\\n\\n\\n  constructor ()\\n  {\\n    _handleAddition(0x6B175474E89094C44Da98b954EedeAC495271d0F, false);\\n    _handleAddition(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, false);\\n\\n    _handleAddition(0x111111111117dC0aa78b770fA6A738034120C302, false);\\n    _handleAddition(0xD46bA6D942050d489DBd938a2C909A5d5039A161, false);\\n    _handleAddition(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C, false);\\n    _handleAddition(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9, false);\\n    _handleAddition(0xa117000000f279D81A1D3cc75430fAA017FA5A2e, false);\\n    _handleAddition(0xba100000625a3754423978a60c9317c58a424e3D, false);\\n    _handleAddition(0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55, false);\\n    _handleAddition(0x0D8775F648430679A709E98d2b0Cb6250d2887EF, false);\\n    _handleAddition(0xc00e94Cb662C3520282E6f5717214004A7f26888, false);\\n    _handleAddition(0x2ba592F78dB6436527729929AAf6c908497cB200, false);\\n    _handleAddition(0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b, false);\\n    _handleAddition(0xD533a949740bb3306d119CC777fa900bA034cd52, false);\\n    _handleAddition(0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c, false);\\n    _handleAddition(0xc944E90C64B2c07662A292be6244BDf05Cda44a7, false);\\n    _handleAddition(0xdd974D5C2e2928deA5F71b9825b8b646686BD200, false);\\n    _handleAddition(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44, false);\\n    _handleAddition(0x514910771AF9Ca656af840dff83E8264EcF986CA, false);\\n    _handleAddition(0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD, false);\\n    _handleAddition(0x0F5D2fB29fb7d3CFeE444a200298f468908cC942, false);\\n    _handleAddition(0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2, false);\\n    _handleAddition(0x408e41876cCCDC0F92210600ef50372656052a38, false);\\n    _handleAddition(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F, false);\\n\\n    _handleAddition(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51, false);\\n    _handleAddition(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51, true);\\n\\n    _handleAddition(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, false);\\n\\n    _handleAddition(0x0000000000085d4780B73119b644AE5ecd22b376, false);\\n    _handleAddition(0x0000000000085d4780B73119b644AE5ecd22b376, true);\\n\\n    _handleAddition(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, false);\\n\\n    _handleAddition(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, false);\\n    _handleAddition(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, true);\\n\\n    _handleAddition(0xdAC17F958D2ee523a2206206994597C13D831ec7, false);\\n    _handleAddition(0xdAC17F958D2ee523a2206206994597C13D831ec7, true);\\n\\n    _handleAddition(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, false);\\n    _handleAddition(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e, false);\\n    _handleAddition(0xE41d2489571d322189246DaFA5ebDe1F4699F498, false);\\n  }\\n\\n\\n  function isWhitelisted(address token) public view override returns (bool)\\n  {\\n    return token != address(0) && _whitelistedToken[token];\\n  }\\n\\n  function isStableToken(address token) public view override returns (bool)\\n  {\\n    return token != address(0) && _stableToken[token];\\n  }\\n\\n  function isDynamicToken(address token) public view override returns (bool)\\n  {\\n    return token != address(0) && _dynamicToken[token];\\n  }\\n\\n  function isBothStable(address tokenA, address tokenB) external view override returns (bool)\\n  {\\n    return _stableToken[tokenA] && _stableToken[tokenB];\\n  }\\n\\n  function isBothWhitelisted(address tokenA, address tokenB) external view override returns (bool)\\n  {\\n    return _whitelistedToken[tokenA] && _whitelistedToken[tokenB];\\n  }\\n\\n  function getDynamicTokens() external view returns (address[] memory)\\n  {\\n    return _dynamicTokens;\\n  }\\n\\n  function getStableTokens() external view returns (address[] memory)\\n  {\\n    return _stableTokens;\\n  }\\n\\n  function getWhitelistedTokens() external view returns (address[] memory)\\n  {\\n    return _whitelistedTokens;\\n  }\\n\\n\\n  function whitelistToken(address token) external onlyOwner\\n  {\\n    require(!isWhitelisted(token), \\\"Whitelisted\\\");\\n\\n    _handleAddition(token, false);\\n  }\\n\\n  function whitelistTokens(address[] calldata tokens) external onlyOwner\\n  {\\n    for (uint256 i = 0; i < tokens.length; i++)\\n    {\\n      if (!isWhitelisted(tokens[i]))\\n      {\\n        _handleAddition(tokens[i], false);\\n      }\\n    }\\n  }\\n\\n  function unwhitelistToken(address token) external onlyOwner\\n  {\\n    require(isWhitelisted(token), \\\"!whitelisted\\\");\\n\\n    _handleRemoval(token, false);\\n\\n    if (isStableToken(token))\\n    {\\n      _handleRemoval(token, true);\\n    }\\n\\n    if (isDynamicToken(token))\\n    {\\n      _handleDynamicRemoval(token);\\n    }\\n  }\\n\\n  function setAsStableToken(address token) external onlyOwner\\n  {\\n    require(!isStableToken(token), \\\"Set\\\");\\n    require(isWhitelisted(token), \\\"!whitelisted\\\");\\n\\n    _handleAddition(token, true);\\n  }\\n\\n  function unsetAsStableToken(address token) external onlyOwner\\n  {\\n    require(isStableToken(token), \\\"!stabletoken\\\");\\n\\n    _handleRemoval(token, true);\\n  }\\n\\n  function setAsDynamicToken(address token) external onlyOwner\\n  {\\n    require(!isDynamicToken(token), \\\"Set\\\");\\n    require(isWhitelisted(token), \\\"!whitelisted\\\");\\n\\n    _dynamicTokenID = _dynamicTokenID.add(1);\\n    _dynamicTokenIDOf[token] = _dynamicTokenID;\\n    _dynamicToken[token] = true;\\n    _dynamicTokens.push(token);\\n  }\\n\\n  function unsetAsDynamicToken(address token) external onlyOwner\\n  {\\n    require(isDynamicToken(token), \\\"!dynamic\\\");\\n\\n    _handleDynamicRemoval(token);\\n  }\\n\\n\\n  function _handleAddition(address token, bool forStableToken) private\\n  {\\n    if (!forStableToken)\\n    {\\n      _tokenID = _tokenID.add(1);\\n      _tokenIDOf[token] = _tokenID;\\n      _whitelistedToken[token] = true;\\n      _whitelistedTokens.push(token);\\n    }\\n    else\\n    {\\n      _stableTokenID = _stableTokenID.add(1);\\n      _stableTokenIDOf[token] = _stableTokenID;\\n      _stableToken[token] = true;\\n      _stableTokens.push(token);\\n    }\\n  }\\n\\n  function _handleRemoval(address token, bool forStableToken) private\\n  {\\n    if (!forStableToken)\\n    {\\n      uint256 tokenIndex = _tokenIDOf[token].sub(1);\\n\\n      _tokenIDOf[token] = 0;\\n      _whitelistedToken[token] = false;\\n      delete _whitelistedTokens[tokenIndex];\\n    }\\n    else\\n    {\\n      uint256 stableTokenIndex = _stableTokenIDOf[token].sub(1);\\n\\n      _stableTokenIDOf[token] = 0;\\n      _stableToken[token] = false;\\n      delete _stableTokens[stableTokenIndex];\\n    }\\n  }\\n\\n  function _handleDynamicRemoval(address token) private\\n  {\\n    uint256 dynamicTokenIndex = _dynamicTokenIDOf[token].sub(1);\\n\\n    _dynamicTokenIDOf[token] = 0;\\n    _dynamicToken[token] = false;\\n    delete _dynamicTokens[dynamicTokenIndex];\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/roles/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\ncontract Ownable\\n{\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  modifier onlyOwner()\\n  {\\n    require(isOwner(), \\\"!owner\\\");\\n    _;\\n  }\\n\\n  constructor()\\n  {\\n    _owner = msg.sender;\\n\\n    emit OwnershipTransferred(address(0), msg.sender);\\n  }\\n\\n  function owner() public view returns (address)\\n  {\\n    return _owner;\\n  }\\n\\n  function isOwner() public view returns (bool)\\n  {\\n    return msg.sender == _owner;\\n  }\\n\\n  function renounceOwnership() public onlyOwner\\n  {\\n    emit OwnershipTransferred(_owner, address(0));\\n\\n    _owner = address(0);\\n  }\\n\\n  function transferOwnership(address newOwner) public onlyOwner\\n  {\\n    require(newOwner != address(0), \\\"0 addy\\\");\\n\\n    emit OwnershipTransferred(_owner, newOwner);\\n\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getDynamicTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"isBothStable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"isBothWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isDynamicToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isStableToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setAsDynamicToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setAsStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unsetAsDynamicToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unsetAsStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unwhitelistToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"whitelistToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"whitelistTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenManager","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}