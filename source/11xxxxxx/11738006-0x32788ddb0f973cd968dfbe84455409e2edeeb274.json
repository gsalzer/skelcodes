{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/treasury/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.10;\\n\\nimport '@openzeppelin/contracts/math/Math.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '../interfaces/ICustomERC20.sol';\\nimport '../interfaces/IUniswapV2Factory.sol';\\nimport {IUniswapOracle} from '../interfaces/IUniswapOracle.sol';\\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\\nimport {IBoardroom} from '../interfaces/IBoardroom.sol';\\nimport {IBasisAsset} from '../interfaces/IBasisAsset.sol';\\nimport {ISimpleERCFund} from '../interfaces/ISimpleERCFund.sol';\\nimport {Operator} from '../owner/Operator.sol';\\nimport {Epoch} from '../utils/Epoch.sol';\\nimport {ContractGuard} from '../utils/ContractGuard.sol';\\n\\nimport './TreasuryHelpers.sol';\\n\\n/**\\n * @title ARTH Treasury contract\\n * @notice Monetary policy logic to adjust supplies of basis cash assets\\n * @author Steven Enamakel & Yash Agrawal. Original code written by Summer Smith & Rick Sanchez\\n */\\ncontract Treasury is TreasuryHelpers {\\n    using SafeERC20 for ICustomERC20;\\n\\n    constructor(\\n        // tokens\\n        address _dai,\\n        address _cash,\\n        address _bond,\\n        address _share,\\n        // oracles\\n        address _bondOracle,\\n        address _arthMahaOracle,\\n        address _seigniorageOracle,\\n        address _gmuOracle,\\n        // boardrooms\\n        address _arthLiquidityBoardroom,\\n        address _mahaLiquidityBoardroom,\\n        address _arthBoardroom,\\n        // ecosystem fund\\n        address _fund,\\n        // uniswap router\\n        address _uniswapRouter,\\n        uint256 _startTime,\\n        uint256 _period,\\n        uint256 _startEpoch\\n    )\\n        public\\n        TreasuryHelpers(\\n            _dai,\\n            _cash,\\n            _bond,\\n            _share,\\n            _bondOracle,\\n            _arthMahaOracle,\\n            _seigniorageOracle,\\n            _gmuOracle,\\n            _arthLiquidityBoardroom,\\n            _mahaLiquidityBoardroom,\\n            _arthBoardroom,\\n            _fund,\\n            _uniswapRouter,\\n            _startTime,\\n            _period,\\n            _startEpoch\\n        )\\n    {}\\n\\n    function initialize() public checkOperator {\\n        require(!initialized, '!initialized');\\n\\n        // set accumulatedSeigniorage to the treasury's balance\\n        accumulatedSeigniorage = IERC20(cash).balanceOf(address(this));\\n\\n        initialized = true;\\n        emit Initialized(msg.sender, block.number);\\n    }\\n\\n    function buyBonds(uint256 amountInDai, uint256 targetPrice)\\n        external\\n        onlyOneBlock\\n        checkMigration\\n        checkStartTime\\n        checkOperator\\n        updatePrice\\n        returns (uint256)\\n    {\\n        require(amountInDai > 0, 'zero amount');\\n\\n        // Update the price to latest before using.\\n        uint256 cash1hPrice = getBondOraclePrice();\\n\\n        require(cash1hPrice <= targetPrice, 'cash price moved');\\n        require(\\n            cash1hPrice <= getBondPurchasePrice(), // price < $0.95\\n            'cash price not eligible'\\n        );\\n        require(cashToBondConversionLimit > 0, 'no more bonds');\\n\\n        // Find the expected amount recieved when swapping the following\\n        // tokens on uniswap.\\n        address[] memory path = new address[](2);\\n        path[0] = address(dai);\\n        path[1] = address(cash);\\n\\n        uint256[] memory amountsOut =\\n            IUniswapV2Router02(uniswapRouter).getAmountsOut(amountInDai, path);\\n        uint256 expectedCashAmount = amountsOut[1];\\n\\n        // 1. Take Dai from the user\\n        ICustomERC20(dai).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amountInDai\\n        );\\n\\n        // 2. Approve dai for trade on uniswap\\n        ICustomERC20(dai).safeApprove(uniswapRouter, amountInDai);\\n\\n        // 3. Swap dai for ARTH from uniswap and send the ARTH to the sender\\n        // we send the ARTH back to the sender just in case there is some slippage\\n        // in our calculations and we end up with more ARTH than what is needed.\\n        uint256[] memory output =\\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(\\n                amountInDai,\\n                expectedCashAmount,\\n                path,\\n                msg.sender,\\n                block.timestamp\\n            );\\n\\n        // set approve to 0 after transfer\\n        ICustomERC20(dai).safeApprove(uniswapRouter, 0);\\n\\n        // we do this to understand how much ARTH was bought back as without this, we\\n        // could witness a flash loan attack. (given that the minted amount of ARTHB\\n        // minted is based how much ARTH was received)\\n        uint256 boughtBackCash = Math.min(output[1], expectedCashAmount);\\n\\n        // basis the amount of ARTH being bought back; understand how much of it\\n        // can we convert to bond tokens by looking at the conversion limits\\n        uint256 cashToConvert =\\n            Math.min(\\n                boughtBackCash,\\n                cashToBondConversionLimit.sub(accumulatedBonds)\\n            );\\n\\n        // if all good then mint ARTHB, burn ARTH and update the counters\\n        require(cashToConvert > 0, 'no more bond limit');\\n\\n        uint256 bondsToIssue =\\n            cashToConvert.mul(uint256(100).add(bondDiscount)).div(100);\\n        accumulatedBonds = accumulatedBonds.add(bondsToIssue);\\n\\n        // 3. Burn bought ARTH cash and mint bonds at the discounted price.\\n        // TODO: Set the minting amount according to bond price.\\n        // TODO: calculate premium basis size of the trade\\n        IBasisAsset(cash).burnFrom(msg.sender, cashToConvert);\\n        IBasisAsset(bond).mint(msg.sender, bondsToIssue);\\n\\n        emit BoughtBonds(msg.sender, amountInDai, cashToConvert, bondsToIssue);\\n\\n        return bondsToIssue;\\n    }\\n\\n    /**\\n     * Redeeming bonds happen when\\n     */\\n    function redeemBonds(uint256 amount, bool sellForDai)\\n        external\\n        onlyOneBlock\\n        checkMigration\\n        checkStartTime\\n        checkOperator\\n        updatePrice\\n    {\\n        require(amount > 0, 'zero amount');\\n\\n        uint256 cashPrice = _getCashPrice(bondOracle);\\n        require(\\n            cashPrice > getBondRedemtionPrice(), // price > $1.05\\n            'cashPrice less than ceiling'\\n        );\\n\\n        require(\\n            ICustomERC20(cash).balanceOf(address(this)) >= amount,\\n            'treasury has not enough budget'\\n        );\\n\\n        amount = Math.min(accumulatedSeigniorage, amount);\\n\\n        // charge stabilty fees in MAHA\\n        if (stabilityFee > 0) {\\n            uint256 stabilityFeeInARTH = amount.mul(stabilityFee).div(100);\\n            uint256 stabilityFeeInMAHA =\\n                getArthMahaOraclePrice().mul(stabilityFeeInARTH).div(1e18);\\n\\n            // charge the stability fee\\n            ICustomERC20(share).burnFrom(msg.sender, stabilityFeeInMAHA);\\n\\n            emit StabilityFeesCharged(msg.sender, stabilityFeeInMAHA);\\n        }\\n\\n        accumulatedSeigniorage = accumulatedSeigniorage.sub(amount);\\n        IBasisAsset(bond).burnFrom(msg.sender, amount);\\n\\n        // sell the ARTH for Dai right away\\n        if (sellForDai) {\\n            // calculate how much DAI will we get from Uniswap by selling ARTH\\n            address[] memory path = new address[](2);\\n            path[0] = address(cash);\\n            path[1] = address(dai);\\n            uint256[] memory amountsOut =\\n                IUniswapV2Router02(uniswapRouter).getAmountsOut(amount, path);\\n            uint256 expectedDaiAmount = amountsOut[1];\\n\\n            // TODO: write some checkes over here\\n\\n            // send it!\\n            ICustomERC20(cash).safeApprove(uniswapRouter, amount);\\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(\\n                amount,\\n                expectedDaiAmount,\\n                path,\\n                msg.sender,\\n                block.timestamp\\n            );\\n            // set approve to 0 after transfer\\n            ICustomERC20(cash).safeApprove(uniswapRouter, 0);\\n        } else {\\n            // or just hand over the ARTH directly\\n            ICustomERC20(cash).safeTransfer(msg.sender, amount);\\n        }\\n\\n        emit RedeemedBonds(msg.sender, amount, sellForDai);\\n    }\\n\\n    function allocateSeigniorage()\\n        external\\n        onlyOneBlock\\n        checkMigration\\n        checkStartTime\\n        checkEpoch\\n        checkOperator\\n    {\\n        _updateCashPrice();\\n        uint256 cash12hPrice = getSeigniorageOraclePrice();\\n        uint256 cash1hPrice = getBondOraclePrice();\\n\\n        // send 200 ARTH reward to the person advancing the epoch to compensate for gas\\n        IBasisAsset(cash).mint(msg.sender, uint256(200).mul(1e18));\\n\\n        // update the bond limits\\n        _updateConversionLimit(cash1hPrice);\\n\\n        if (cash12hPrice <= cashTargetPrice) {\\n            return; // just advance epoch instead revert\\n        }\\n\\n        if (cash12hPrice <= getExpansionLimitPrice()) {\\n            // if we are below the ceiling price (or expansion limit price) but\\n            // above the target price, then we try to pay off all the bond holders\\n            // as much as possible.\\n\\n            // calculate how much seigniorage should be minted basis deviation from target price\\n            uint256 seigniorage = estimateSeignorageToMint(cash12hPrice);\\n\\n            // if we don't have to pay bond holders anything then simply return.\\n            if (seigniorage == 0) return;\\n\\n            // we have to pay them some amount; so mint, distribute and return\\n            IBasisAsset(cash).mint(address(this), seigniorage);\\n            emit SeigniorageMinted(seigniorage);\\n\\n            _allocateToBondHolders(seigniorage);\\n            return;\\n        }\\n\\n        uint256 seigniorage = estimateSeignorageToMint(cash12hPrice);\\n        if (seigniorage == 0) return;\\n\\n        IBasisAsset(cash).mint(address(this), seigniorage);\\n        emit SeigniorageMinted(seigniorage);\\n\\n        // send funds to the community development fund\\n        uint256 ecosystemReserve = _allocateToEcosystemFund(seigniorage);\\n        seigniorage = seigniorage.sub(ecosystemReserve);\\n\\n        // keep 90% of the funds to bond token holders; and send the remaining to the boardroom\\n        uint256 allocatedForBondHolders =\\n            seigniorage.mul(bondSeigniorageRate).div(100);\\n        uint256 treasuryReserve =\\n            _allocateToBondHolders(allocatedForBondHolders);\\n        seigniorage = seigniorage.sub(treasuryReserve);\\n\\n        // allocate everything else to the boardroom\\n        _allocateToBoardrooms(seigniorage);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICustomERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\ninterface ICustomERC20 is IERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IUniswapOracle {\\n    function update() external;\\n\\n    function consult(address token, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBoardroom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IBoardroom {\\n    function allocateSeigniorage(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBasisAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IBasisAsset {\\n    function mint(address recipient, uint256 amount) external returns (bool);\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address from, uint256 amount) external;\\n\\n    function isOperator() external returns (bool);\\n\\n    function operator() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISimpleERCFund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface ISimpleERCFund {\\n    function deposit(\\n        address token,\\n        uint256 amount,\\n        string memory reason\\n    ) external;\\n\\n    function withdraw(\\n        address token,\\n        uint256 amount,\\n        address to,\\n        string memory reason\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/owner/Operator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport '@openzeppelin/contracts/GSN/Context.sol';\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\ncontract Operator is Context, Ownable {\\n    address private _operator;\\n\\n    event OperatorTransferred(\\n        address indexed previousOperator,\\n        address indexed newOperator\\n    );\\n\\n    constructor() internal {\\n        _operator = _msgSender();\\n\\n        emit OperatorTransferred(address(0), _operator);\\n    }\\n\\n    function operator() public view returns (address) {\\n        return _operator;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            _operator == msg.sender,\\n            'operator: caller is not the operator'\\n        );\\n        _;\\n    }\\n\\n    function isOperator() public view returns (bool) {\\n        return _msgSender() == _operator;\\n    }\\n\\n    function transferOperator(address newOperator_) public onlyOwner {\\n        _transferOperator(newOperator_);\\n    }\\n\\n    function _transferOperator(address newOperator_) internal {\\n        require(\\n            newOperator_ != address(0),\\n            'operator: zero address given for new operator'\\n        );\\n\\n        emit OperatorTransferred(address(0), newOperator_);\\n\\n        _operator = newOperator_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Epoch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport '@openzeppelin/contracts/math/Math.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport '../owner/Operator.sol';\\n\\ncontract Epoch is Operator {\\n    using SafeMath for uint256;\\n\\n    uint256 public period = 1;\\n    uint256 public startTime;\\n    uint256 public lastExecutedAt;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        uint256 _period,\\n        uint256 _startTime,\\n        uint256 _startEpoch\\n    ) public {\\n        // require(_startTime > block.timestamp, 'Epoch: invalid start time');\\n        period = _period;\\n        startTime = _startTime;\\n        lastExecutedAt = startTime.add(_startEpoch.mul(period));\\n    }\\n\\n    /* ========== Modifier ========== */\\n\\n    modifier checkStartTime {\\n        require(now >= startTime, 'Epoch: not started yet');\\n\\n        _;\\n    }\\n\\n    modifier checkEpoch {\\n        require(now > startTime, 'Epoch: not started yet');\\n        require(callable(), 'Epoch: not allowed');\\n\\n        _;\\n\\n        lastExecutedAt = block.timestamp;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function callable() public view returns (bool) {\\n        return getCurrentEpoch() >= getNextEpoch();\\n    }\\n\\n    // epoch\\n    function getLastEpoch() public view returns (uint256) {\\n        return lastExecutedAt.sub(startTime).div(period);\\n    }\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return Math.max(startTime, block.timestamp).sub(startTime).div(period);\\n    }\\n\\n    function getNextEpoch() public view returns (uint256) {\\n        if (startTime == lastExecutedAt) {\\n            return getLastEpoch();\\n        }\\n        return getLastEpoch().add(1);\\n    }\\n\\n    function nextEpochPoint() public view returns (uint256) {\\n        return startTime.add(getNextEpoch().mul(period));\\n    }\\n\\n    // params\\n    function getPeriod() public view returns (uint256) {\\n        return period;\\n    }\\n\\n    function getStartTime() public view returns (uint256) {\\n        return startTime;\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function setPeriod(uint256 _period) external onlyOperator {\\n        period = _period;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ContractGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ncontract ContractGuard {\\n    mapping(uint256 => mapping(address => bool)) private _status;\\n\\n    function checkSameOriginReentranted() internal view returns (bool) {\\n        return _status[block.number][tx.origin];\\n    }\\n\\n    function checkSameSenderReentranted() internal view returns (bool) {\\n        return _status[block.number][msg.sender];\\n    }\\n\\n    modifier onlyOneBlock() {\\n        require(\\n            !checkSameOriginReentranted(),\\n            'ContractGuard: one block, one function'\\n        );\\n        require(\\n            !checkSameSenderReentranted(),\\n            'ContractGuard: one block, one function'\\n        );\\n\\n        _;\\n\\n        _status[block.number][tx.origin] = true;\\n        _status[block.number][msg.sender] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/TreasuryHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.10;\\n\\nimport '@openzeppelin/contracts/math/Math.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '../interfaces/ICustomERC20.sol';\\nimport '../interfaces/IUniswapV2Factory.sol';\\n\\nimport {IUniswapOracle} from '../interfaces/IUniswapOracle.sol';\\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\\nimport {IBoardroom} from '../interfaces/IBoardroom.sol';\\nimport {IBasisAsset} from '../interfaces/IBasisAsset.sol';\\nimport {ISimpleERCFund} from '../interfaces/ISimpleERCFund.sol';\\nimport {Operator} from '../owner/Operator.sol';\\nimport {Epoch} from '../utils/Epoch.sol';\\nimport {ContractGuard} from '../utils/ContractGuard.sol';\\n\\nimport './TreasurySetters.sol';\\n\\n/**\\n * @title ARTH Treasury contract\\n * @notice Monetary policy logic to adjust supplies of basis cash assets\\n * @author Steven Enamakel & Yash Agrawal. Original code written by Summer Smith & Rick Sanchez\\n */\\ncontract TreasuryHelpers is TreasurySetters {\\n    using SafeERC20 for ICustomERC20;\\n\\n    constructor(\\n        address _dai,\\n        address _cash,\\n        address _bond,\\n        address _share,\\n        address _bondOracle,\\n        address _arthMahaOracle,\\n        address _seigniorageOracle,\\n        address _gmuOracle,\\n        address _arthLiquidityBoardroom,\\n        address _mahaLiquidityBoardroom,\\n        address _arthBoardroom,\\n        address _fund,\\n        address _uniswapRouter,\\n        uint256 _startTime,\\n        uint256 _period,\\n        uint256 _startEpoch\\n    ) public Epoch(_period, _startTime, _startEpoch) {\\n        // tokens\\n        dai = _dai;\\n        cash = _cash;\\n        bond = _bond;\\n        share = _share;\\n\\n        // oracles\\n        bondOracle = _bondOracle;\\n        arthMahaOracle = _arthMahaOracle;\\n        seigniorageOracle = _seigniorageOracle;\\n        gmuOracle = _gmuOracle;\\n\\n        // funds\\n        arthLiquidityBoardroom = _arthLiquidityBoardroom;\\n        mahaLiquidityBoardroom = _mahaLiquidityBoardroom;\\n        arthBoardroom = _arthBoardroom;\\n        ecosystemFund = _fund;\\n\\n        // others\\n        uniswapRouter = _uniswapRouter;\\n\\n        // _updateCashPrice();\\n    }\\n\\n    modifier updatePrice {\\n        _;\\n\\n        _updateCashPrice();\\n    }\\n\\n    function migrate(address target) public onlyOperator checkOperator {\\n        require(target != address(0), 'migrate to zero');\\n        require(!migrated, '!migrated');\\n\\n        // cash\\n        Operator(cash).transferOperator(target);\\n        Operator(cash).transferOwnership(target);\\n        ICustomERC20(cash).transfer(\\n            target,\\n            ICustomERC20(cash).balanceOf(address(this))\\n        );\\n\\n        // bond\\n        Operator(bond).transferOperator(target);\\n        Operator(bond).transferOwnership(target);\\n        ICustomERC20(bond).transfer(\\n            target,\\n            ICustomERC20(bond).balanceOf(address(this))\\n        );\\n\\n        // share - disabled ownership and operator functions as MAHA tokens don't have these\\n        ICustomERC20(share).transfer(\\n            target,\\n            ICustomERC20(share).balanceOf(address(this))\\n        );\\n\\n        migrated = true;\\n        emit Migration(target);\\n    }\\n\\n    function _allocateToEcosystemFund(uint256 seigniorage)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 ecosystemReserve =\\n            seigniorage.mul(ecosystemFundAllocationRate).div(100);\\n        if (ecosystemReserve > 0) {\\n            ICustomERC20(cash).safeApprove(ecosystemFund, ecosystemReserve);\\n            ISimpleERCFund(ecosystemFund).deposit(\\n                cash,\\n                ecosystemReserve,\\n                'Treasury: Ecosystem Seigniorage Allocation'\\n            );\\n            emit PoolFunded(ecosystemFund, ecosystemReserve);\\n            return ecosystemReserve;\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * Updates the cash price from the various oracles.\\n     * TODO: this function needs to be optimised for gas\\n     */\\n    function _updateCashPrice() internal {\\n        if (Epoch(bondOracle).callable()) {\\n            try IUniswapOracle(bondOracle).update() {} catch {}\\n        }\\n\\n        if (Epoch(seigniorageOracle).callable()) {\\n            try IUniswapOracle(seigniorageOracle).update() {} catch {}\\n        }\\n\\n        // TODO: do the same for the gmu oracle as well\\n        // if (Epoch(seigniorageOracle).callable()) {\\n        //     try IOracle(seigniorageOracle).update() {} catch {}\\n        // }\\n\\n        cashTargetPrice = getGMUOraclePrice();\\n    }\\n\\n    /**\\n     * Helper function to allocate seigniorage to bond token holders. Seigniorage\\n     * before the boardrooms get paid.\\n     */\\n    function _allocateToBondHolders(uint256 seigniorage)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 treasuryReserve =\\n            Math.min(\\n                seigniorage,\\n                ICustomERC20(bond).totalSupply().sub(accumulatedSeigniorage)\\n            );\\n\\n        if (treasuryReserve > 0) {\\n            // update accumulated seigniorage\\n            accumulatedSeigniorage = accumulatedSeigniorage.add(\\n                treasuryReserve\\n            );\\n            emit TreasuryFunded(now, treasuryReserve);\\n            return treasuryReserve;\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * Helper function to allocate seigniorage to boardooms. Seigniorage is allocated\\n     * after bond token holders have been paid first.\\n     */\\n    function _allocateToBoardrooms(uint256 boardroomReserve) internal {\\n        if (boardroomReserve <= 0) return;\\n\\n        // Calculate boardroom reserves.\\n        uint256 arthLiquidityBoardroomReserve =\\n            boardroomReserve.mul(arthLiquidityBoardroomAllocationRate).div(100);\\n        uint256 arthBoardroomReserve =\\n            boardroomReserve.mul(arthBoardroomAllocationRate).div(100);\\n        uint256 mahaLiquidityBoardroomReserve =\\n            boardroomReserve.mul(mahaLiquidityBoardroomAllocationRate).div(100);\\n\\n        if (arthLiquidityBoardroomReserve > 0) {\\n            ICustomERC20(cash).safeApprove(\\n                arthLiquidityBoardroom,\\n                arthLiquidityBoardroomReserve\\n            );\\n            IBoardroom(arthLiquidityBoardroom).allocateSeigniorage(\\n                arthLiquidityBoardroomReserve\\n            );\\n            emit PoolFunded(\\n                arthLiquidityBoardroom,\\n                arthLiquidityBoardroomReserve\\n            );\\n        }\\n\\n        if (arthBoardroomReserve > 0) {\\n            ICustomERC20(cash).safeApprove(arthBoardroom, arthBoardroomReserve);\\n            IBoardroom(arthBoardroom).allocateSeigniorage(arthBoardroomReserve);\\n            emit PoolFunded(arthBoardroom, arthBoardroomReserve);\\n        }\\n\\n        if (mahaLiquidityBoardroomReserve > 0) {\\n            ICustomERC20(cash).safeApprove(\\n                mahaLiquidityBoardroom,\\n                mahaLiquidityBoardroomReserve\\n            );\\n            IBoardroom(mahaLiquidityBoardroom).allocateSeigniorage(\\n                mahaLiquidityBoardroomReserve\\n            );\\n            emit PoolFunded(\\n                mahaLiquidityBoardroom,\\n                mahaLiquidityBoardroomReserve\\n            );\\n        }\\n    }\\n\\n    /**\\n     * This function calculates how much bonds should be minted given an epoch\\n     * https://github.com/Basis-Cash/basiscash-protocol/issues/27\\n     *\\n     * The cap will be of the following size: ($1-1hTWAP)*(Circ $BAC),\\n     * where 1hTWAP is the 1h TWAP of the $ARTH price and â€œCirc $ARTH is\\n     * the Circulating $ARTH supply. The cap will last for one hour; after\\n     * an hour a new TWAP will be calculated and the cap is reset based on\\n     * next 12h epoch.\\n     */\\n    function _updateConversionLimit(uint256 cash1hPrice) internal {\\n        // reset this counter so that new bonds can now be minted.\\n        accumulatedBonds = 0;\\n        cashToBondConversionLimit = estimateBondsToIssue(cash1hPrice);\\n    }\\n\\n    // GOV\\n    event Initialized(address indexed executor, uint256 at);\\n    event Migration(address indexed target);\\n    event RedeemedBonds(address indexed from, uint256 amount, bool sellForDai);\\n    event BoughtBonds(\\n        address indexed from,\\n        uint256 amountDaiIn,\\n        uint256 amountBurnt,\\n        uint256 bondsIssued\\n    );\\n    event Log(uint256 data);\\n    event TreasuryFunded(uint256 timestamp, uint256 seigniorage);\\n    event SeigniorageMinted(uint256 seigniorage);\\n    event BondsAllocated(uint256 limit);\\n    event PoolFunded(address indexed pool, uint256 seigniorage);\\n    event StabilityFeesCharged(address indexed from, uint256 stabilityFeeValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/TreasurySetters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\\n\\nimport '../interfaces/IBoardroom.sol';\\nimport '../interfaces/IBasisAsset.sol';\\nimport '../interfaces/ISimpleERCFund.sol';\\nimport './TreasuryGetters.sol';\\n\\nabstract contract TreasurySetters is TreasuryGetters {\\n    function setStabilityFee(uint256 _stabilityFee) public onlyOwner {\\n        require(_stabilityFee <= 100, 'rate >= 0');\\n\\n        stabilityFee = _stabilityFee;\\n\\n        emit StabilityFeeChanged(stabilityFee, _stabilityFee);\\n    }\\n\\n    function setFund(address newFund, uint256 rate) public onlyOwner {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        ecosystemFund = newFund;\\n        ecosystemFundAllocationRate = rate;\\n\\n        emit EcosystemFundChanged(newFund, rate);\\n    }\\n\\n    function setBondDiscount(uint256 rate) public onlyOwner returns (uint256) {\\n        require(rate <= 100, 'rate >= 0');\\n        bondDiscount = rate;\\n    }\\n\\n    function setConsiderUniswapLiquidity(bool val) public onlyOwner {\\n        considerUniswapLiquidity = val;\\n    }\\n\\n    function setMaxDebtIncreasePerEpoch(uint256 rate) public onlyOwner {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        maxDebtIncreasePerEpoch = rate;\\n    }\\n\\n    function setMaxSupplyIncreasePerEpoch(uint256 rate) public onlyOwner {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        maxSupplyIncreasePerEpoch = rate;\\n    }\\n\\n    function setSafetyRegion(uint256 rate) public onlyOwner returns (uint256) {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        safetyRegion = rate;\\n    }\\n\\n    function setBondSeigniorageRate(uint256 rate) public onlyOwner {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        bondSeigniorageRate = rate;\\n\\n        emit BondSeigniorageRateChanged(rate);\\n    }\\n\\n    function setArthBoardroom(address newFund, uint256 rate) public onlyOwner {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        arthBoardroom = newFund;\\n        arthBoardroomAllocationRate = rate;\\n        emit BoardroomChanged(newFund, rate);\\n    }\\n\\n    function setArthLiquidityBoardroom(address newFund, uint256 rate)\\n        public\\n        onlyOwner\\n    {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        arthLiquidityBoardroom = newFund;\\n        arthLiquidityBoardroomAllocationRate = rate;\\n\\n        emit BoardroomChanged(newFund, rate);\\n    }\\n\\n    function setMahaLiquidityBoardroom(address newFund, uint256 rate)\\n        public\\n        onlyOwner\\n    {\\n        require(rate <= 100, 'rate >= 0');\\n\\n        mahaLiquidityBoardroom = newFund;\\n        mahaLiquidityBoardroomAllocationRate = rate;\\n\\n        emit BoardroomChanged(newFund, rate);\\n    }\\n\\n    // ORACLE\\n    function setBondOracle(address newOracle) public onlyOwner {\\n        address oldOracle = bondOracle;\\n        bondOracle = newOracle;\\n        emit OracleChanged(msg.sender, oldOracle, newOracle);\\n    }\\n\\n    function setSeigniorageOracle(address newOracle) public onlyOwner {\\n        address oldOracle = seigniorageOracle;\\n        seigniorageOracle = newOracle;\\n        emit OracleChanged(msg.sender, oldOracle, newOracle);\\n    }\\n\\n    function setGMUOracle(address newOracle) public onlyOwner {\\n        address oldOracle = gmuOracle;\\n        gmuOracle = newOracle;\\n        emit OracleChanged(msg.sender, oldOracle, newOracle);\\n    }\\n\\n    function setArthMahaOracle(address newOracle) public onlyOwner {\\n        address oldOracle = arthMahaOracle;\\n        arthMahaOracle = newOracle;\\n        emit OracleChanged(msg.sender, oldOracle, newOracle);\\n    }\\n\\n    event OracleChanged(\\n        address indexed operator,\\n        address oldOracle,\\n        address newOracle\\n    );\\n    event EcosystemFundChanged(address newFund, uint256 newRate);\\n    event BoardroomChanged(address newFund, uint256 newRate);\\n    event StabilityFeeChanged(uint256 old, uint256 newRate);\\n    event BondSeigniorageRateChanged(uint256 newRate);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/TreasuryGetters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.10;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '../interfaces/IUniswapOracle.sol';\\nimport '../interfaces/ISimpleOracle.sol';\\nimport '../interfaces/IBoardroom.sol';\\nimport '../interfaces/IBasisAsset.sol';\\nimport '../interfaces/ISimpleERCFund.sol';\\nimport './TreasuryState.sol';\\n\\nimport '../interfaces/ICustomERC20.sol';\\nimport '../interfaces/IUniswapV2Factory.sol';\\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\\n\\nabstract contract TreasuryGetters is TreasuryState {\\n    function getReserve() public view returns (uint256) {\\n        return accumulatedSeigniorage;\\n    }\\n\\n    function getStabilityFee() public view returns (uint256) {\\n        return stabilityFee;\\n    }\\n\\n    function getBondOraclePrice() public view returns (uint256) {\\n        return _getCashPrice(bondOracle);\\n    }\\n\\n    function getGMUOraclePrice() public view returns (uint256) {\\n        return ISimpleOracle(gmuOracle).getPrice();\\n    }\\n\\n    function getArthMahaOraclePrice() public view returns (uint256) {\\n        return ISimpleOracle(arthMahaOracle).getPrice();\\n    }\\n\\n    function getPercentDeviationFromTarget(uint256 price)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 target = getGMUOraclePrice();\\n\\n        if (price > target) return price.sub(target).mul(100).div(target);\\n        return target.sub(price).mul(100).div(target);\\n    }\\n\\n    function getSeigniorageOraclePrice() public view returns (uint256) {\\n        return _getCashPrice(seigniorageOracle);\\n    }\\n\\n    function arthCirculatingSupply() public view returns (uint256) {\\n        return IERC20(cash).totalSupply().sub(accumulatedSeigniorage);\\n    }\\n\\n    function bondCirculatingSupply() public view returns (uint256) {\\n        return ICustomERC20(bond).totalSupply().sub(accumulatedSeigniorage);\\n    }\\n\\n    /**\\n     * Understand how much Seignorage should be minted\\n     */\\n    function estimateSeignorageToMint(uint256 price)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (price <= cashTargetPrice) return 0; // < $1.00\\n        uint256 percentage = getPercentDeviationFromTarget(price);\\n\\n        // cap the max supply increase per epoch to only 30%\\n        uint256 finalPercentage =\\n            Math.min(percentage, maxSupplyIncreasePerEpoch);\\n\\n        // take into consideration uniswap liq. if flag is on, ie how much liquidity is there in the ARTH uniswap pool\\n        uint256 toMint = arthCirculatingSupply().mul(finalPercentage).div(100);\\n\\n        // if we are below the expansion price limit; only pay back bond holders if we are within the right price range\\n        // < $1.05\\n        if (price <= getExpansionLimitPrice()) {\\n            return Math.min(toMint, bondCirculatingSupply());\\n        }\\n\\n        return toMint;\\n    }\\n\\n    function estimateBondsToIssue(uint256 price) public view returns (uint256) {\\n        uint256 bondPurchasePrice = getBondPurchasePrice();\\n\\n        // check if we are in contract mode.\\n        if (price > bondPurchasePrice) return 0; // <= $0.95?\\n\\n        // in contraction mode -> issue bonds.\\n        // set a limit to how many bonds are there.\\n\\n        uint256 percentage = getPercentDeviationFromTarget(price);\\n\\n        // understand how much % deviation do we have from target price\\n        // if target price is 2.5$ and we are at 2$; then percentage should be 20%\\n        // cap the bonds to be issed; we don't want too many\\n        uint256 finalPercentage = Math.min(percentage, maxDebtIncreasePerEpoch);\\n\\n        // accordingly set the new conversion limit to be that % from the\\n        // current circulating supply of ARTH and if uniswap enabled then uniswap liquidity.\\n        return\\n            arthCirculatingSupply()\\n                .mul(finalPercentage)\\n                .div(100)\\n                .mul(getCashSupplyInLiquidity())\\n                .div(100);\\n    }\\n\\n    function getBondRedemtionPrice() public view returns (uint256) {\\n        return cashTargetPrice; // 1$\\n    }\\n\\n    function getExpansionLimitPrice() public view returns (uint256) {\\n        return cashTargetPrice.mul(safetyRegion.add(100)).div(100); // 1.05$\\n    }\\n\\n    function getBondPurchasePrice() public view returns (uint256) {\\n        return cashTargetPrice.mul(uint256(100).sub(safetyRegion)).div(100); // 0.95$\\n    }\\n\\n    function getCashSupplyInLiquidity() public view returns (uint256) {\\n        // check if enabled or not\\n        if (!considerUniswapLiquidity) return uint256(100);\\n\\n        address uniswapFactory = IUniswapV2Router02(uniswapRouter).factory();\\n        address uniswapLiquidityPair =\\n            IUniswapV2Factory(uniswapFactory).getPair(cash, dai);\\n\\n        // Get the liquidity of cash locked in uniswap pair.\\n        uint256 uniswapLiquidityPairCashBalance =\\n            ICustomERC20(cash).balanceOf(uniswapLiquidityPair);\\n\\n        // Get the liquidity percent.\\n        return\\n            uniswapLiquidityPairCashBalance.mul(100).div(\\n                ICustomERC20(cash).totalSupply()\\n            );\\n    }\\n\\n    function get1hourEpoch() public view returns (uint256) {\\n        return Epoch(bondOracle).getLastEpoch();\\n    }\\n\\n    function _getCashPrice(address oracle) internal view returns (uint256) {\\n        try IUniswapOracle(oracle).consult(cash, 1e18) returns (uint256 price) {\\n            return price;\\n        } catch {\\n            revert('Treasury: failed to consult cash price from the oracle');\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISimpleOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface ISimpleOracle {\\n    function getPrice() external view returns (uint256 amountOut);\\n    // function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestamp);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/TreasuryState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport '@openzeppelin/contracts/math/Math.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../lib/FixedPoint.sol';\\nimport '../lib/Safe112.sol';\\nimport '../owner/Operator.sol';\\nimport '../utils/Epoch.sol';\\nimport '../utils/ContractGuard.sol';\\n\\nabstract contract TreasuryState is ContractGuard, Epoch {\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n    using Safe112 for uint112;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // ========== FLAGS\\n    bool public migrated = false;\\n    bool public initialized = false;\\n\\n    // ========== CORE\\n    address public dai;\\n    address public cash;\\n    address public bond;\\n    address public share;\\n    address public uniswapRouter;\\n\\n    address public arthLiquidityBoardroom;\\n    address public mahaLiquidityBoardroom;\\n    address public arthBoardroom;\\n\\n    address public ecosystemFund;\\n\\n    // oracles\\n    address public bondOracle;\\n    address public seigniorageOracle;\\n    address public gmuOracle;\\n    address public arthMahaOracle;\\n\\n    // cash price tracking vars\\n    uint256 public cashTargetPrice = 1e18;\\n\\n    // these govern how much bond tokens are issued\\n    uint256 public cashToBondConversionLimit = 0;\\n    uint256 public accumulatedBonds = 0;\\n\\n    // this governs how much cash tokens are issued\\n    uint256 public accumulatedSeigniorage = 0;\\n\\n    // flag whether we should considerUniswapLiquidity or not.\\n    bool public considerUniswapLiquidity = false;\\n\\n    // used to limit how much of the supply is converted into bonds\\n    uint256 public maxDebtIncreasePerEpoch = 5; // in %\\n\\n    // the discount given to bond purchasers\\n    uint256 public bondDiscount = 20; // in %\\n\\n    // the band beyond which bond purchase or protocol expansion happens.\\n    uint256 public safetyRegion = 5; // in %\\n\\n    // at the most how much % of the supply should be increased\\n    uint256 public maxSupplyIncreasePerEpoch = 30; // in %\\n\\n    // the ecosystem fund recieves seigniorage before anybody else; this\\n    // value decides how much of the new seigniorage is sent to this fund.\\n    uint256 public ecosystemFundAllocationRate = 2; // in %\\n\\n    // this controls how much of the new seigniorage is given to bond token holders\\n    // when we are in expansion mode. ideally 90% of new seigniorate is\\n    // given to bond token holders.\\n    uint256 public bondSeigniorageRate = 90; // in %\\n\\n    // we decide how much allocation to give to the boardrooms. there\\n    // are currently two boardrooms; one for ARTH holders and the other for\\n    // ARTH liqudity providers\\n    //\\n    // TODO: make one for maha holders and one for the various community pools\\n    uint256 public arthLiquidityBoardroomAllocationRate = 70; // In %.\\n    uint256 public arthBoardroomAllocationRate = 20; // IN %.\\n    uint256 public mahaLiquidityBoardroomAllocationRate = 10; // IN %.\\n\\n    // stability fee is a special fee charged by the protocol in MAHA tokens\\n    // whenever a person is going to redeem his/her bonds. the fee is charged\\n    // basis how much ARTHB is being redeemed.\\n    //\\n    // eg: a 1% fee means that while redeeming 100 ARTHB, 1 ARTH worth of MAHA is\\n    // deducted to pay for stability fees.\\n    uint256 public stabilityFee = 1; // IN %;\\n\\n    modifier checkMigration {\\n        require(!migrated, 'Treasury: migrated');\\n        _;\\n    }\\n\\n    modifier checkOperator {\\n        require(\\n            Operator(cash).operator() == address(this) &&\\n                Operator(bond).operator() == address(this) &&\\n                Operator(arthLiquidityBoardroom).operator() == address(this) &&\\n                Operator(arthBoardroom).operator() == address(this) &&\\n                Operator(mahaLiquidityBoardroom).operator() == address(this),\\n            'Treasury: need more permission'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport './Babylonian.sol';\\n\\n// A library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)).\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\\n    uint256 private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y)\\n        internal\\n        pure\\n        returns (uq144x112 memory)\\n    {\\n        uint256 z;\\n        require(\\n            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\\n            'FixedPoint: MULTIPLICATION_OVERFLOW'\\n        );\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        require(denominator > 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    function sqrt(uq112x112 memory self)\\n        internal\\n        pure\\n        returns (uq112x112 memory)\\n    {\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Safe112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nlibrary Safe112 {\\n    function add(uint112 a, uint112 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, 'Safe112: addition overflow');\\n\\n        return c;\\n    }\\n\\n    function sub(uint112 a, uint112 b) internal pure returns (uint256) {\\n        return sub(a, b, 'Safe112: subtraction overflow');\\n    }\\n\\n    function sub(\\n        uint112 a,\\n        uint112 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint112) {\\n        require(b <= a, errorMessage);\\n        uint112 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint112 a, uint112 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, 'Safe112: multiplication overflow');\\n\\n        return c;\\n    }\\n\\n    function div(uint112 a, uint112 b) internal pure returns (uint256) {\\n        return div(a, b, 'Safe112: division by zero');\\n    }\\n\\n    function div(\\n        uint112 a,\\n        uint112 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint112) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint112 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function mod(uint112 a, uint112 b) internal pure returns (uint256) {\\n        return mod(a, b, 'Safe112: modulo by zero');\\n    }\\n\\n    function mod(\\n        uint112 a,\\n        uint112 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint112) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nlibrary Babylonian {\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cash\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bond\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_share\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bondOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_arthMahaOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_seigniorageOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gmuOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_arthLiquidityBoardroom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mahaLiquidityBoardroom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_arthBoardroom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"BoardroomChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"BondSeigniorageRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"BondsAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDaiIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondsIssued\",\"type\":\"uint256\"}],\"name\":\"BoughtBonds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"EcosystemFundChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"at\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Migration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seigniorage\",\"type\":\"uint256\"}],\"name\":\"PoolFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sellForDai\",\"type\":\"bool\"}],\"name\":\"RedeemedBonds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seigniorage\",\"type\":\"uint256\"}],\"name\":\"SeigniorageMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"old\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"StabilityFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stabilityFeeValue\",\"type\":\"uint256\"}],\"name\":\"StabilityFeesCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seigniorage\",\"type\":\"uint256\"}],\"name\":\"TreasuryFunded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accumulatedBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulatedSeigniorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocateSeigniorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arthBoardroom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arthBoardroomAllocationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arthCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arthLiquidityBoardroom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arthLiquidityBoardroomAllocationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arthMahaOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bond\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondSeigniorageRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"}],\"name\":\"buyBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cashTargetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cashToBondConversionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"considerUniswapLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecosystemFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecosystemFundAllocationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"estimateBondsToIssue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"estimateSeignorageToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get1hourEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getArthMahaOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBondOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBondPurchasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBondRedemtionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCashSupplyInLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpansionLimitPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGMUOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getPercentDeviationFromTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSeigniorageOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStabilityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gmuOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastExecutedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mahaLiquidityBoardroom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mahaLiquidityBoardroomAllocationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDebtIncreasePerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupplyIncreasePerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextEpochPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sellForDai\",\"type\":\"bool\"}],\"name\":\"redeemBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safetyRegion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seigniorageOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setArthBoardroom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setArthLiquidityBoardroom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"setArthMahaOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setBondDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"setBondOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setBondSeigniorageRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setConsiderUniswapLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"setGMUOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setMahaLiquidityBoardroom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setMaxDebtIncreasePerEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setMaxSupplyIncreasePerEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setSafetyRegion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"setSeigniorageOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stabilityFee\",\"type\":\"uint256\"}],\"name\":\"setStabilityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stabilityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator_\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Treasury","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000e3cc2c4fb9252d17d07c67135e48536071735d9000000000000000000000000e3d620ca72ff970f5b36a2b2d51afdbbdbce59b5000000000000000000000000b4d930279552397bba2ee473229f89ec245bc3650000000000000000000000000f040ed37c0cab55305de16adc6c8114e289942b000000000000000000000000cd24efb0f7285cb923cab11a85fbdb1523f10011000000000000000000000000977a86faba6ea1876c94e725a4e88e39dfaf3268000000000000000000000000cd0efae7fa77bfdda4e4997452f3deb06f290a08000000000000000000000000d5f501c4cdbfca915f04d4ae3853a904c9a35af5000000000000000000000000677d54d7def7da25adde1827e000b81a65b1f408000000000000000000000000dec0b3bd49347c75fe1c44a219ab474a13e68ffd0000000000000000000000005ac2a32bfa475765558cea2a0fe0bf0207d58ca40000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000000000000000000000000000000000000600ada60000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000000000a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}