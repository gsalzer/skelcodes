{"status":"1","message":"OK","result":[{"SourceCode":"//Audit report available at https://www.tkd-coop.com/files/audit.pdf\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n//Control who can access various functions.\r\ncontract AccessControl {\r\n    address payable public creatorAddress;\r\n    mapping (address => bool) public admins;\r\n\r\n    modifier onlyCREATOR() {\r\n        require(msg.sender == creatorAddress, \"You are not the creator of this contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyADMINS() {\r\n      \r\n      require(admins[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    // Constructor\r\n    constructor() {\r\n        creatorAddress = 0x813dd04A76A716634968822f4D30Dfe359641194;\r\n    }\r\n\r\n    //Admins are contracts or addresses that have write access\r\n    function addAdmin(address _newAdmin) onlyCREATOR public {\r\n        if (admins[_newAdmin] == false) {\r\n            admins[_newAdmin] = true;\r\n        }\r\n    }\r\n    \r\n    function removeAdmin(address _oldAdmin) onlyCREATOR public {\r\n        if (admins[_oldAdmin] == true) {\r\n            admins[_oldAdmin] = false;\r\n        }\r\n    }\r\n}\r\n\r\n//Interface to TAC Contract\r\nabstract contract ITAC {\r\n     function awardTAC(address winner, address loser, address referee) public virtual;\r\n     function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);\r\n     function balanceOf(address account) external virtual view returns (uint256);\r\n}\r\n\r\n\r\ncontract CoopData is AccessControl {\r\n\r\n    /////////////////////////////////////////////////DATA STRUCTURES AND GLOBAL VARIABLES ///////////////////////////////////////////////////////////////////////\r\n  \r\n    uint256 public numUsers = 0; //total number of user profiles, independent of number of addresses with balances\r\n    uint64 public numMatches = 0; //total number of matches recorded\r\n    uint16 public numEvents = 0; //number of events created\r\n\r\n    uint256 public eventHostingCost = 100000000000000000000; //cost to host an event in Hwangs.\r\n\r\n    //Main data structure to hold info about an athlete\r\n    struct User {\r\n        address userAddress; //since the address is unique this also serves as their id.\r\n        uint8 allowedMatches;\r\n        uint64[] matches;\r\n        uint64[] proposedMatches;\r\n        uint64[] approvedMatches;\r\n    }\r\n\r\n    //Main data structure to hold info about an event\r\n    struct Event {\r\n        address promoter; //the person who holds the tournament\r\n        string eventName;\r\n        uint64 time;\r\n        uint64 eventId;\r\n        uint16 allowedMatches;\r\n    }\r\n\r\n    // Main data structure to hold info about a match\r\n    struct Match {\r\n        uint64 id;\r\n        address winner; //address (id) of the athlete who won\r\n        uint8 winnerPoints;\r\n        address loser; //address (id) of the athlete who lost\r\n        uint8 loserPoints;\r\n        address referee; //Who recorded the match\r\n        bool loserVerified;\r\n        bool winnerVerified;\r\n        uint64 time;\r\n        string notes;\r\n    }\r\n    \r\n    // Main mapping storing an Match record for each match id.\r\n    Match[] public allMatches;\r\n    Match[] public proposedMatches;\r\n    Event[] allEvents;\r\n    address[] public allUsersById;\r\n        \r\n    // Main mapping storing an athlete record for each address.\r\n    mapping(address => User) public allUsers;\r\n\r\n    // Mapping storing which users are authorized to act as staff for which event.\r\n    // A user can only be authorized for one event at a time\r\n    mapping(address  => uint64) public tournamentStaff;\r\n\r\n    //A list of all proposed matches to be used as ID. \r\n    uint64 public numProposedMatches = 0;\r\n    bool public requireMembership = true;\r\n\r\n    address public TACContract = 0xABa8ace37f301E7a3A3FaD44682C8Ec8DC2BD18A;\r\n    \r\n    //The amount of Hwangs required to spar a match. \r\n    uint public matchCost = 10000000000000000000;\r\n\r\n    /////////////////////////////////////////////////////////CONTRACT CONTROL FUNCTIONS //////////////////////////////////////////////////\r\n\r\n    function changeParameters(uint256 _eventHostingCost, address _TACContract, uint _matchCost, bool _requireMembership) external onlyCREATOR {\r\n        \r\n        eventHostingCost = _eventHostingCost;\r\n        TACContract = _TACContract;\r\n        matchCost = _matchCost;\r\n        requireMembership = _requireMembership;\r\n    }\r\n\r\n    function getParameters() external view returns (uint256 _eventHostingCost) {\r\n        _eventHostingCost = eventHostingCost;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////USER INFO FUNCTIONS  //////////////////////////////////////////////////\r\n\r\n   //function which sets information for the address which submitted the transaction.\r\n    function setUser() public {\r\n\r\n        bool zeroMatches = false;\r\n\r\n        if (allUsers[msg.sender].userAddress == address(0)) {\r\n            //new user so add to number of users\r\n             numUsers ++;\r\n             allUsersById.push(msg.sender);\r\n             zeroMatches = true;\r\n        }\r\n\r\n        User storage user = allUsers[msg.sender];\r\n        user.userAddress = msg.sender;\r\n        if (zeroMatches == true) {\r\n            user.allowedMatches = 0;\r\n        }\r\n    }\r\n\r\n    //Function which specifies how many matches a user has left.\r\n    //Only coop members have approved matches and only referees need them. \r\n    //Set 0 to remove a user's ability to record matches. \r\n    function setUserAllowedMatches(address user, uint8 newApprovalNumber) public onlyADMINS {\r\n        allUsers[user].allowedMatches = newApprovalNumber;\r\n    }\r\n\r\n    //Function which returns user information for the specified address. \r\n    function getUser(address _address) public view returns(address userAddress, uint64[] memory matches, uint8 allowedMatches) {\r\n      \r\n       User storage user = allUsers[_address];\r\n       userAddress = user.userAddress;\r\n       matches = user.matches;\r\n       allowedMatches = user.allowedMatches;\r\n      }\r\n      \r\n    //Function which returns user information for the specified address. \r\n    function getUserMatches(address _address) public view returns(uint64[] memory _proposedMatches, uint64[] memory approvedMatches) {\r\n       \r\n       User storage user = allUsers[_address];\r\n       _proposedMatches = user.proposedMatches;\r\n       approvedMatches = user.approvedMatches;\r\n      }\r\n      \r\n      function getUserMatchNumber(address _address) public view returns (uint256) {\r\n          return allUsers[_address].approvedMatches.length;\r\n      }\r\n\r\n    /////////////////////////////////////////////////////////MATCH FUNCTIONS  //////////////////////////////////////////////////\r\n\r\n    function proposeMatch(address _winner, uint8 _winnerPoints, address _loser, uint8 _loserPoints, address _referee, string memory _notes) public {\r\n       \r\n        require((allUsers[_referee].allowedMatches > 0 || requireMembership == false), \"Members must have available allowed matches\");\r\n        require(msg.sender == _referee, \"The referee must record the match\");\r\n        require((_winner != _loser) && (_winner != _referee) && (_loser != _referee), \"The only true battle is against yourself, but can't count it here.\");\r\n        \r\n        require(allUsers[_winner].userAddress != address(0), \"User is not yet registered\");\r\n        require(allUsers[_loser].userAddress != address(0), \"User is not yet registered\");\r\n        \r\n        //Decrement the referee's match allowance\r\n        if (requireMembership == true) {\r\n        allUsers[_referee].allowedMatches -= 1;\r\n        }\r\n\r\n        // Create the proposed match\r\n        Match memory proposedMatch;\r\n        proposedMatch.id = numProposedMatches;\r\n        proposedMatch.winner = _winner;\r\n        proposedMatch.winnerPoints = _winnerPoints;\r\n        proposedMatch.loser = _loser;\r\n        proposedMatch.loserPoints = _loserPoints;\r\n        proposedMatch.referee = _referee;\r\n        proposedMatch.loserVerified = false;\r\n        proposedMatch.winnerVerified = false;\r\n        proposedMatch.time = uint64 (block.timestamp);\r\n        proposedMatch.notes = _notes;\r\n        \r\n        numProposedMatches ++;\r\n        \r\n        // Add it to the list of each person as well as the overall list. \r\n        proposedMatches.push(proposedMatch);\r\n        allUsers[_winner].proposedMatches.push(proposedMatch.id);\r\n        allUsers[_loser].proposedMatches.push(proposedMatch.id);\r\n        allUsers[_referee].proposedMatches.push(proposedMatch.id);\r\n    }\r\n    \r\n    function overwriteMatch(uint64 id, address _winner, uint8 _winnerPoints, address _loser, uint8 _loserPoints, string memory _notes) public {\r\n        // The referee only can overwrite matches\r\n        require(proposedMatches[id].referee == msg.sender, \"Only the referee may overwrite a match\");\r\n        // Matches can only be overwritten before they have been approved by both athletes\r\n        require(proposedMatches[id].winnerVerified == false || proposedMatches[id].loserVerified == false, \"This match has already been finalized\");\r\n        // Each participant can have only one role. \r\n        require((_winner != _loser) && (_winner != msg.sender) && (_loser != msg.sender), \"The only true battle is against yourself, but can't count it here.\");\r\n        \r\n        // Reset the athlete approvals since the result has changed. \r\n        proposedMatches[id].winnerVerified = false;\r\n        proposedMatches[id].loserVerified = false;\r\n\r\n        require(allUsers[_winner].userAddress != address(0), \"User is not yet registered\");\r\n        require(allUsers[_loser].userAddress != address(0), \"User is not yet registered\");\r\n\r\n        //Push to their proposedMatches if athlete changes\r\n        if ((_winner != proposedMatches[id].winner) && (_winner != proposedMatches[id].loser)) {\r\n            allUsers[_winner].proposedMatches.push(id);\r\n        }\r\n\r\n        if ((_loser != proposedMatches[id].winner) && (_loser != proposedMatches[id].loser)) {\r\n            allUsers[_loser].proposedMatches.push(id);\r\n        }\r\n\r\n        // Overwrite the match. \r\n        proposedMatches[id].winner = _winner;\r\n        proposedMatches[id].winnerPoints = _winnerPoints;\r\n        proposedMatches[id].loser = _loser;\r\n        proposedMatches[id].loserPoints = _loserPoints;\r\n        proposedMatches[id].notes = _notes;\r\n        \r\n        allUsers[_winner].proposedMatches.push(id);\r\n        allUsers[_loser].proposedMatches.push(id);\r\n    }\r\n\r\n    function getProposedMatch(uint64 matchId) public view returns (uint64 id, address winner, uint8 winnerPoints, address loser, uint8 loserPoints, address referee, uint64 time, string memory notes, bool winnerVerified, bool loserVerified) {\r\n        \r\n        id = proposedMatches[matchId].id;\r\n        winner = proposedMatches[matchId].winner;\r\n        winnerPoints = proposedMatches[matchId].winnerPoints;\r\n        loser = proposedMatches[matchId].loser;\r\n        loserPoints = proposedMatches[matchId].loserPoints;\r\n        referee = proposedMatches[matchId].referee;\r\n        notes = proposedMatches[matchId].notes;\r\n        winnerVerified = proposedMatches[matchId].winnerVerified;\r\n        loserVerified = proposedMatches[matchId].loserVerified;\r\n        time = proposedMatches[matchId].time;\r\n    }\r\n\r\n    function approveMatch(uint64 id) public {\r\n        // Make sure the match has not already been verified. \r\n        require(((proposedMatches[id].winnerVerified == false) || (proposedMatches[id].loserVerified == false)), 'Both athletes have already verified this match' );\r\n        \r\n        //  Find if the user calling approve is the winner or loser. \r\n        bool winner = false;\r\n        bool loser = false;\r\n        if (proposedMatches[id].winner == msg.sender) {\r\n            winner = true;\r\n        }\r\n         if (proposedMatches[id].loser == msg.sender) {\r\n            loser = true;\r\n        }\r\n        \r\n        require(winner || loser, \"You are not a player in this match\");\r\n        \r\n          // First see if the other player has verified. \r\n          \r\n          //Case 1 - The caller is the winner   \r\n          if (winner) {\r\n              // If the loser has not verified.\r\n              if (proposedMatches[id].loserVerified == false) {\r\n              proposedMatches[id].winnerVerified = true;\r\n                }\r\n             //If the loser has verified\r\n            else {\r\n                proposedMatches[id].winnerVerified = true;\r\n                finalizeMatch(id);\r\n            }\r\n          }\r\n          \r\n               //Case 2 - The caller is the losing athlete  \r\n          if (loser) {\r\n              // If the winner has not verified.\r\n              if (proposedMatches[id].winnerVerified == false) {\r\n              proposedMatches[id].loserVerified = true;\r\n                }\r\n             //If the loser has verified\r\n            else {\r\n                proposedMatches[id].loserVerified = true;\r\n                finalizeMatch(id);\r\n            }\r\n          }\r\n          \r\n    }\r\n    \r\n    //Called to record match and award TAC\r\n    //Internal function called only once all checks are passed\r\n    function finalizeMatch(uint64 id) internal {\r\n\r\n        allUsers[proposedMatches[id].winner].approvedMatches.push(id);\r\n        allUsers[proposedMatches[id].loser].approvedMatches.push(id);\r\n        allUsers[proposedMatches[id].referee].approvedMatches.push(id);\r\n           \r\n        proposedMatches[id].id = numMatches;\r\n         \r\n        //Add the match to the athletes\r\n        allUsers[proposedMatches[id].winner].matches.push(numMatches);\r\n        allUsers[proposedMatches[id].loser].matches.push(numMatches);\r\n           \r\n        allMatches.push(proposedMatches[id]);\r\n        numMatches ++;\r\n           \r\n        ITAC TAC = ITAC(TACContract);\r\n        //Transfer the 10 TAC from each athlete. \r\n        TAC.transferFrom(proposedMatches[id].loser, creatorAddress, matchCost);\r\n        TAC.transferFrom(proposedMatches[id].winner, creatorAddress, matchCost);\r\n        //Award bonus TAC\r\n        TAC.awardTAC(allUsers[proposedMatches[id].winner].userAddress, allUsers[proposedMatches[id].loser].userAddress, allUsers[proposedMatches[id].referee].userAddress);\r\n     \r\n    }\r\n\r\n\r\n    function recordEventMatch(uint64 _eventId, address _winner, uint8 _winnerPoints, address _loser, uint8 _loserPoints, address _referee) public {\r\n        //Check that the tournament promoter is the caller\r\n        require((msg.sender == allEvents[_eventId].promoter || tournamentStaff[msg.sender] == _eventId), \"Only the promoter can record event matches\");\r\n        //Check that the event has enough matches left. \r\n        require(allEvents[_eventId].allowedMatches > 0, \"This event does not have any matches left\");\r\n        //Make sure that the tournament isn't too old. \r\n        require(allEvents[_eventId].time + 604800 > block.timestamp, \"This event is too old\");\r\n        //Decrement the allowedMatches\r\n        allEvents[_eventId].allowedMatches = allEvents[_eventId].allowedMatches - 1;\r\n       \r\n        //Record the match. \r\n        Match memory newMatch;\r\n        newMatch.id = numMatches;\r\n        newMatch.winner = _winner;\r\n        newMatch.winnerPoints = _winnerPoints;\r\n        newMatch.loser = _loser;\r\n        newMatch.loserPoints = _loserPoints;\r\n        newMatch.referee = _referee;\r\n        newMatch.time = uint64 (block.timestamp);\r\n       \r\n        numMatches ++;\r\n        allMatches.push(newMatch);\r\n        \r\n           \r\n        ITAC TAC = ITAC(TACContract);\r\n        \r\n         //Add the match to the athletes and ref\r\n        allUsers[_winner].matches.push(newMatch.id);\r\n        allUsers[_loser].matches.push(newMatch.id);\r\n        allUsers[_referee].matches.push(newMatch.id);\r\n        \r\n\r\n        if ((TAC.balanceOf(_loser) >= matchCost) && (TAC.balanceOf(_winner) >= matchCost)) {\r\n            //Transfer the 10 TAC from each athlete. \r\n            TAC.transferFrom(_loser, creatorAddress, matchCost);\r\n            TAC.transferFrom(_winner, creatorAddress, matchCost);\r\n        \r\n            //Issue TAC\r\n            TAC.awardTAC(_winner, _loser, _referee);\r\n        }\r\n    }\r\n\r\n     function getMatch(uint64 _id) public view returns(uint64 id, address winner, uint8 winnerPoints, address loser, uint8 loserPoints, uint64 time, string memory notes, address referee) {\r\n\r\n       Match memory matchToGet = allMatches[_id];\r\n       id = matchToGet.id;\r\n       winner = matchToGet.winner;\r\n       winnerPoints = matchToGet.winnerPoints;\r\n       loser = matchToGet.loser;\r\n       loserPoints = matchToGet.loserPoints;\r\n       time = matchToGet.time;\r\n       notes = matchToGet.notes;\r\n       referee = matchToGet.referee;\r\n    }\r\n\r\n\r\n  /////////////////////////////////////////////////////////EVENT FUNCTIONS  //////////////////////////////////////////////////\r\n\r\n    function hostEvent(uint64 startTime, string memory eventName) public {\r\n\r\n        Event memory newEvent;\r\n        ITAC TAC = ITAC(TACContract);\r\n        require((allUsers[msg.sender].allowedMatches > 0 || requireMembership == false), \"Members must have available allowed matches\");\r\n        require(TAC.balanceOf(msg.sender) >= eventHostingCost, \"You need to have more TAC to open an event. \");\r\n        TAC.transferFrom(msg.sender, creatorAddress, eventHostingCost);\r\n        newEvent.promoter = msg.sender;\r\n        newEvent.eventName = eventName;\r\n        newEvent.time = startTime;\r\n        newEvent.eventId = numEvents;\r\n        newEvent.allowedMatches = 0;\r\n        allEvents.push(newEvent);\r\n        numEvents += 1;\r\n    }\r\n\r\n    function getEvent(uint64 _eventId) public view returns(address promoter, uint64 time, uint64 eventId, string memory eventName, uint16 allowedMatches) {\r\n\r\n       Event memory eventToGet = allEvents[_eventId];\r\n       promoter = eventToGet.promoter;\r\n       time = eventToGet.time;\r\n       eventName = eventToGet.eventName;\r\n       eventId = eventToGet.eventId;\r\n       allowedMatches = eventToGet.allowedMatches;   \r\n    }\r\n    \r\n    \r\n    function approveEvent(uint64 _eventId, uint16 _numMatches) public onlyADMINS {\r\n        // Function to allow an event host to approve a specified number of matches.\r\n        allEvents[_eventId].allowedMatches = _numMatches;\r\n     }\r\n    \r\n    //Function a tournament promoter can call to delegate staff to record matches. \r\n    function addStaff(uint64 _eventId, address _newStaff) public {\r\n        //Check that the tournament promoter is the caller\r\n        require(msg.sender == allEvents[_eventId].promoter, \"Only the promoter can add staff\");\r\n        tournamentStaff[_newStaff] = _eventId;\r\n\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"name\":\"TACContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_eventId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_newStaff\",\"type\":\"address\"}],\"name\":\"addStaff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allMatches\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"loserVerified\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"winnerVerified\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"notes\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"allowedMatches\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allUsersById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_eventId\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"_numMatches\",\"type\":\"uint16\"}],\"name\":\"approveEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"}],\"name\":\"approveMatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventHostingCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_TACContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_matchCost\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_requireMembership\",\"type\":\"bool\"}],\"name\":\"changeParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eventHostingCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_eventId\",\"type\":\"uint64\"}],\"name\":\"getEvent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"promoter\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"eventId\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"eventName\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"allowedMatches\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_id\",\"type\":\"uint64\"}],\"name\":\"getMatch\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"notes\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getParameters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventHostingCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"matchId\",\"type\":\"uint64\"}],\"name\":\"getProposedMatch\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"notes\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"winnerVerified\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"loserVerified\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"matches\",\"type\":\"uint64[]\"},{\"internalType\":\"uint8\",\"name\":\"allowedMatches\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserMatchNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserMatches\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_proposedMatches\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"approvedMatches\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"eventName\",\"type\":\"string\"}],\"name\":\"hostEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matchCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numEvents\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numMatches\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProposedMatches\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_notes\",\"type\":\"string\"}],\"name\":\"overwriteMatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_referee\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_notes\",\"type\":\"string\"}],\"name\":\"proposeMatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposedMatches\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"loserVerified\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"winnerVerified\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"notes\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_eventId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_winnerPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_loser\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_loserPoints\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_referee\",\"type\":\"address\"}],\"name\":\"recordEventMatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requireMembership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"newApprovalNumber\",\"type\":\"uint8\"}],\"name\":\"setUserAllowedMatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tournamentStaff\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CoopData","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b5ab0f9f3baee65f5b3cc45a4fdcd8d8d8e208606757e89fd231986307fba4ed"}]}