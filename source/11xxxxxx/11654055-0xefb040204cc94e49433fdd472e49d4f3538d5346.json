{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/contracts/versioning/PoolRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {ISynthereumPoolRegistry} from './interfaces/IPoolRegistry.sol';\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {IERC20} from '../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {SynthereumInterfaces} from './Constants.sol';\\nimport {\\n  EnumerableSet\\n} from '../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\nimport {\\n  Lockable\\n} from '../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\n\\ncontract SynthereumPoolRegistry is ISynthereumPoolRegistry, Lockable {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  ISynthereumFinder public synthereumFinder;\\n\\n  mapping(string => mapping(IERC20 => mapping(uint8 => EnumerableSet.AddressSet)))\\n    private symbolToPools;\\n\\n  EnumerableSet.AddressSet private collaterals;\\n\\n  constructor(ISynthereumFinder _synthereumFinder) public {\\n    synthereumFinder = _synthereumFinder;\\n  }\\n\\n  function registerPool(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 poolVersion,\\n    address pool\\n  ) external override nonReentrant {\\n    address deployer =\\n      ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n        SynthereumInterfaces.Deployer\\n      );\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    symbolToPools[syntheticTokenSymbol][collateralToken][poolVersion].add(pool);\\n    collaterals.add(address(collateralToken));\\n  }\\n\\n  function isPoolDeployed(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion,\\n    address pool\\n  ) external view override nonReentrantView returns (bool isDeployed) {\\n    isDeployed = symbolToPools[poolSymbol][collateral][poolVersion].contains(\\n      pool\\n    );\\n  }\\n\\n  function getPools(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion\\n  ) external view override nonReentrantView returns (address[] memory) {\\n    EnumerableSet.AddressSet storage poolSet =\\n      symbolToPools[poolSymbol][collateral][poolVersion];\\n    uint256 numberOfPools = poolSet.length();\\n    address[] memory pools = new address[](numberOfPools);\\n    for (uint256 j = 0; j < numberOfPools; j++) {\\n      pools[j] = poolSet.at(j);\\n    }\\n    return pools;\\n  }\\n\\n  function getCollaterals()\\n    external\\n    view\\n    override\\n    nonReentrantView\\n    returns (address[] memory)\\n  {\\n    uint256 numberOfCollaterals = collaterals.length();\\n    address[] memory collateralAddresses = new address[](numberOfCollaterals);\\n    for (uint256 j = 0; j < numberOfCollaterals; j++) {\\n      collateralAddresses[j] = collaterals.at(j);\\n    }\\n    return collateralAddresses;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IPoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface ISynthereumPoolRegistry {\\n  function registerPool(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 poolVersion,\\n    address pool\\n  ) external;\\n\\n  function isPoolDeployed(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion,\\n    address pool\\n  ) external view returns (bool isDeployed);\\n\\n  function getPools(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion\\n  ) external view returns (address[] memory);\\n\\n  function getCollaterals() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IFinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFinder {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nlibrary SynthereumInterfaces {\\n  bytes32 public constant Deployer = 'Deployer';\\n  bytes32 public constant FactoryVersioning = 'FactoryVersioning';\\n  bytes32 public constant PoolRegistry = 'PoolRegistry';\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Lockable {\\n  bool private _notEntered;\\n\\n  constructor() internal {\\n    _notEntered = true;\\n  }\\n\\n  modifier nonReentrant() {\\n    _preEntranceCheck();\\n    _preEntranceSet();\\n    _;\\n    _postEntranceReset();\\n  }\\n\\n  modifier nonReentrantView() {\\n    _preEntranceCheck();\\n    _;\\n  }\\n\\n  function _preEntranceCheck() internal view {\\n    require(_notEntered, 'ReentrancyGuard: reentrant call');\\n  }\\n\\n  function _preEntranceSet() internal {\\n    _notEntered = false;\\n  }\\n\\n  function _postEntranceReset() internal {\\n    _notEntered = true;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"_synthereumFinder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getCollaterals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"poolSymbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"}],\"name\":\"getPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"poolSymbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolDeployed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isDeployed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"syntheticTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"registerPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthereumFinder\",\"outputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SynthereumPoolRegistry","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d451de78e297b496ee8a4f06dcf991c17580b452","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}