{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem item;   // Item that's being iterated over.\r\n        uint nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\r\n    * @param self The iterator.\r\n    * @return The next element in the iteration.\r\n    */\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\r\n        require(hasNext(self));\r\n\r\n        uint ptr = self.nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        self.nextPtr = ptr + itemLength;\r\n\r\n        return RLPItem(itemLength, ptr);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the iteration has more elements.\r\n    * @param self The iterator.\r\n    * @return true if the iteration has more elements.\r\n    */\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self.item;\r\n        return self.nextPtr < item.memPtr + item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @dev Create an iterator. Reverts if item is not a list.\r\n    * @param self The RLP item.\r\n    * @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\r\n        require(isList(self));\r\n\r\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\r\n        return Iterator(self, ptr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    // any non-zero byte is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    * Private Helpers\r\n    */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint) {\r\n        uint itemLen;\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            itemLen = 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(\r\n                        add(tempBytes, lengthmod),\r\n                        mul(0x20, iszero(lengthmod))\r\n                    )\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(\r\n                            add(\r\n                                add(_bytes, lengthmod),\r\n                                mul(0x20, iszero(lengthmod))\r\n                            ),\r\n                            _start\r\n                        )\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\r\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\r\n        return concat(newBytes, _bytes);\r\n    }\r\n\r\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\r\n        require(b.length >= 32, \"Bytes array should atleast be 32 bytes\");\r\n        bytes32 out;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\r\n        assembly {\r\n            result := mload(add(b, 32))\r\n        }\r\n    }\r\n\r\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\r\n        bytes memory b = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\r\n        }\r\n        return b;\r\n    }\r\n\r\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\r\n        _ret = new bytes(32);\r\n        assembly {\r\n            mstore(add(_ret, 32), _num)\r\n        }\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(\r\n                mload(add(add(_bytes, 0x20), _start)),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/ECVerify.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary ECVerify {\r\n    function ecrecovery(bytes32 hash, bytes memory sig)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65) {\r\n            return address(0x0);\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0x0);\r\n        }\r\n\r\n        // get address out of hash and signature\r\n        address result = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0));\r\n\r\n        return result;\r\n    }\r\n\r\n    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        // get address out of hash and signature\r\n        address result = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0), \"signature verification failed\");\r\n\r\n        return result;\r\n    }\r\n\r\n    function ecverify(bytes32 hash, bytes memory sig, address signer)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return signer == ecrecovery(hash, sig);\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/Merkle.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\nlibrary Merkle {\r\n    function checkMembership(\r\n        bytes32 leaf,\r\n        uint256 index,\r\n        bytes32 rootHash,\r\n        bytes memory proof\r\n    ) public pure returns (bool) {\r\n        require(proof.length % 32 == 0, \"Invalid proof length\");\r\n        uint256 proofHeight = proof.length / 32;\r\n        // Proof of size n means, height of the tree is n+1.\r\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\r\n        require(index < 2 ** proofHeight, \"Leaf index is too big\");\r\n\r\n        bytes32 proofElement;\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 32; i <= proof.length; i += 32) {\r\n            assembly {\r\n                proofElement := mload(add(proof, i))\r\n            }\r\n\r\n            if (index % 2 == 0) {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(computedHash, proofElement)\r\n                );\r\n            } else {\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(proofElement, computedHash)\r\n                );\r\n            }\r\n\r\n            index = index / 2;\r\n        }\r\n        return computedHash == rootHash;\r\n    }\r\n}\r\n\r\n// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Lockable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        _assertUnlocked();\r\n        _;\r\n    }\r\n\r\n    function _assertUnlocked() private view {\r\n        require(!locked, \"locked\");\r\n    }\r\n\r\n    function lock() public {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() public {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/GovernanceLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract GovernanceLockable is Lockable, Governable {\r\n    constructor(address governance) public Governable(governance) {}\r\n\r\n    function lock() public onlyGovernance {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyGovernance {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/RootChainable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title RootChainable\r\n */\r\ncontract RootChainable is Ownable {\r\n    address public rootChain;\r\n\r\n    // Rootchain changed\r\n    event RootChainChanged(\r\n        address indexed previousRootChain,\r\n        address indexed newRootChain\r\n    );\r\n\r\n    //\r\n    // Only root chain\r\n    //\r\n\r\n    // only root chain\r\n    modifier onlyRootChain() {\r\n        require(msg.sender == rootChain);\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Allows the current owner to change root chain address.\r\n   * @param newRootChain The address to new rootchain.\r\n   */\r\n    function changeRootChain(address newRootChain) public onlyOwner {\r\n        require(newRootChain != address(0));\r\n        emit RootChainChanged(rootChain, newRootChain);\r\n        rootChain = newRootChain;\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function stake(\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        bytes memory sigs\r\n    ) public returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes memory slashingInfoList) public returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/staking/validatorShare/IValidatorShare.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n// note this contract interface is only for stakeManager use\r\ncontract IValidatorShare {\r\n    function withdrawRewardsValidator() external returns (uint256);\r\n\r\n    function addProposerBonus(uint256 _rewards, uint256 valStake) public;\r\n\r\n    function withdrawRewards() public;\r\n\r\n    function unstakeClaimTokens() public;\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256);\r\n    \r\n    function getActiveAmount() external view returns (uint256);\r\n\r\n    function owner() public view returns (address);\r\n\r\n    function restake() public;\r\n\r\n    function updateRewards(\r\n        uint256 _reward,\r\n        uint256 _totalStake,\r\n        uint256 validatorStake\r\n    ) external returns (uint256);\r\n\r\n    function unlockContract() external returns (uint256);\r\n\r\n    function lockContract() external returns (uint256);\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function slash(uint256 valPow, uint256 totalAmountToSlash) external returns (uint256);\r\n\r\n    function updateDelegation(bool delegation) external;\r\n\r\n    function migrateOut(address user, uint256 amount) external;\r\n\r\n    function migrateIn(address user, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/staking/StakingInfo.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// dummy interface to avoid cyclic dependency\r\ncontract IStakeManagerLocal {\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    bytes32 public accountStateRoot;\r\n    uint256 public activeAmount; // delegation amount from validator contract\r\n    uint256 public validatorRewards;\r\n\r\n    function currentValidatorSetTotalStake() public view returns (uint256);\r\n\r\n    // signer to Validator mapping\r\n    function signerToValidator(address validatorAddress)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function isValidator(uint256 validatorId) public view returns (bool);\r\n}\r\n\r\n\r\ncontract StakingInfo is Ownable {\r\n    using SafeMath for uint256;\r\n    mapping(uint256 => uint256) public validatorNonce;\r\n\r\n    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\r\n    /// @param signer validator address.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param activationEpoch validator's first epoch as proposer.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    /// @param signerPubkey public key of the validator\r\n    event Staked(\r\n        address indexed signer,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 indexed activationEpoch,\r\n        uint256 amount,\r\n        uint256 total,\r\n        bytes signerPubkey\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    event Unstaked(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in '_unstake()'.\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param deactivationEpoch last epoch for validator.\r\n    /// @param amount staking amount.\r\n    event UnstakeInit(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 deactivationEpoch,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param oldSigner old address of the validator.\r\n    /// @param newSigner new address of the validator.\r\n    /// @param signerPubkey public key of the validator.\r\n    event SignerChange(\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        address indexed oldSigner,\r\n        address indexed newSigner,\r\n        bytes signerPubkey\r\n    );\r\n    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\r\n    event Jailed(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed exitEpoch,\r\n        address indexed signer\r\n    );\r\n    event UnJailed(uint256 indexed validatorId, address indexed signer);\r\n    event Slashed(uint256 indexed nonce, uint256 indexed amount);\r\n    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\r\n    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\r\n    event ProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    );\r\n\r\n    event RewardUpdate(uint256 newReward, uint256 oldReward);\r\n\r\n    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param newAmount the updated stake amount.\r\n    event StakeUpdate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed nonce,\r\n        uint256 indexed newAmount\r\n    );\r\n    event ClaimRewards(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed totalAmount\r\n    );\r\n    event StartAuction(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed auctionAmount\r\n    );\r\n    event ConfirmAuction(\r\n        uint256 indexed newValidatorId,\r\n        uint256 indexed oldValidatorId,\r\n        uint256 indexed amount\r\n    );\r\n    event TopUpFee(address indexed user, uint256 indexed fee);\r\n    event ClaimFee(address indexed user, uint256 indexed fee);\r\n    // Delegator events\r\n    event ShareMinted(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event ShareBurned(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event DelegatorClaimedRewards(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed rewards\r\n    );\r\n    event DelegatorRestaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed totalStaked\r\n    );\r\n    event DelegatorUnstaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        require(_contract == msg.sender,\r\n        \"Invalid sender, not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        address _stakeManager = registry.getStakeManagerAddress();\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\r\n            validatorId\r\n        );\r\n        require(_contract == msg.sender || _stakeManager == msg.sender,\r\n        \"Invalid sender, not stake manager or validator contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender,\r\n        \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n    modifier onlySlashingManager() {\r\n        require(registry.getSlashingManagerAddress() == msg.sender,\r\n        \"Invalid sender, not slashing manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function updateNonce(\r\n        uint256[] calldata validatorIds,\r\n        uint256[] calldata nonces\r\n    ) external onlyOwner {\r\n        require(validatorIds.length == nonces.length, \"args length mismatch\");\r\n\r\n        for (uint256 i = 0; i < validatorIds.length; ++i) {\r\n            validatorNonce[validatorIds[i]] = nonces[i];\r\n        }\r\n    } \r\n\r\n    function logStaked(\r\n        address signer,\r\n        bytes memory signerPubkey,\r\n        uint256 validatorId,\r\n        uint256 activationEpoch,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit Staked(\r\n            signer,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            activationEpoch,\r\n            amount,\r\n            total,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logUnstaked(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        emit Unstaked(user, validatorId, amount, total);\r\n    }\r\n\r\n    function logUnstakeInit(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 deactivationEpoch,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit UnstakeInit(\r\n            user,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            deactivationEpoch,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function logSignerChange(\r\n        uint256 validatorId,\r\n        address oldSigner,\r\n        address newSigner,\r\n        bytes memory signerPubkey\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit SignerChange(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            oldSigner,\r\n            newSigner,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Restaked(validatorId, amount, total);\r\n    }\r\n\r\n    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Jailed(validatorId, exitEpoch, signer);\r\n    }\r\n\r\n    function logUnjailed(uint256 validatorId, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit UnJailed(validatorId, signer);\r\n    }\r\n\r\n    function logSlashed(uint256 nonce, uint256 amount)\r\n        public\r\n        onlySlashingManager\r\n    {\r\n        emit Slashed(nonce, amount);\r\n    }\r\n\r\n    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit ThresholdChange(newThreshold, oldThreshold);\r\n    }\r\n\r\n    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit DynastyValueChange(newDynasty, oldDynasty);\r\n    }\r\n\r\n    function logProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    ) public onlyStakeManager {\r\n        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\r\n    }\r\n\r\n    function logRewardUpdate(uint256 newReward, uint256 oldReward)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit RewardUpdate(newReward, oldReward);\r\n    }\r\n\r\n    function logStakeUpdate(uint256 validatorId)\r\n        public\r\n        StakeManagerOrValidatorContract(validatorId)\r\n    {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit StakeUpdate(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            totalValidatorStake(validatorId)\r\n        );\r\n    }\r\n\r\n    function logClaimRewards(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 totalAmount\r\n    ) public onlyStakeManager {\r\n        emit ClaimRewards(validatorId, amount, totalAmount);\r\n    }\r\n\r\n    function logStartAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 auctionAmount\r\n    ) public onlyStakeManager {\r\n        emit StartAuction(validatorId, amount, auctionAmount);\r\n    }\r\n\r\n    function logConfirmAuction(\r\n        uint256 newValidatorId,\r\n        uint256 oldValidatorId,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\r\n    }\r\n\r\n    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit TopUpFee(user, fee);\r\n    }\r\n\r\n    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit ClaimFee(user, fee);\r\n    }\r\n\r\n    function getStakerDetails(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 reward,\r\n            uint256 activationEpoch,\r\n            uint256 deactivationEpoch,\r\n            address signer,\r\n            uint256 _status\r\n        )\r\n    {\r\n        IStakeManagerLocal stakeManager = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        );\r\n        address _contract;\r\n        IStakeManagerLocal.Status status;\r\n        (\r\n            amount,\r\n            reward,\r\n            activationEpoch,\r\n            deactivationEpoch,\r\n            ,\r\n            signer,\r\n            _contract,\r\n            status\r\n        ) = stakeManager.validators(validatorId);\r\n        _status = uint256(status);\r\n        if (_contract != address(0x0)) {\r\n            reward += IStakeManagerLocal(_contract).validatorRewards();\r\n        }\r\n    }\r\n\r\n    function totalValidatorStake(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (uint256 validatorStake)\r\n    {\r\n        address contractAddress;\r\n        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        if (contractAddress != address(0x0)) {\r\n            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\r\n        }\r\n    }\r\n\r\n    function getAccountStateRoot()\r\n        public\r\n        view\r\n        returns (bytes32 accountStateRoot)\r\n    {\r\n        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\r\n            .accountStateRoot();\r\n    }\r\n\r\n    function getValidatorContractAddress(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (address ValidatorContract)\r\n    {\r\n        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n    }\r\n\r\n    // validator Share contract logging func\r\n    function logShareMinted(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareMinted(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logShareBurned(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurned(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logDelegatorClaimRewards(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 rewards\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorClaimedRewards(validatorId, user, rewards);\r\n    }\r\n\r\n    function logDelegatorRestaked(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 totalStaked\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorRestaked(validatorId, user, totalStaked);\r\n    }\r\n\r\n    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\r\n        public\r\n        onlyValidatorContract(validatorId)\r\n    {\r\n        emit DelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit UpdateCommissionRate(\r\n            validatorId,\r\n            newCommissionRate,\r\n            oldCommissionRate\r\n        );\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /*\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n    /*\r\n     * 0x780e9d63 ===\r\n     *     bytes4(keccak256('totalSupply()')) ^\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor () public {\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner));\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply());\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].length--;\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _allTokens.length--;\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    /*\r\n     * 0x5b5e139f ===\r\n     *     bytes4(keccak256('name()')) ^\r\n     *     bytes4(keccak256('symbol()')) ^\r\n     *     bytes4(keccak256('tokenURI(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId));\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token\r\n     * Reverts if the token ID does not exist\r\n     * @param tokenId uint256 ID of the token to set its URI\r\n     * @param uri string URI to assign\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId));\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\r\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakingNFT.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract StakingNFT is ERC721Full, Ownable {\r\n    constructor(string memory name, string memory symbol)\r\n        public\r\n        ERC721Full(name, symbol)\r\n    {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public onlyOwner {\r\n        require(\r\n            balanceOf(to) == 0,\r\n            \"Validators MUST NOT own multiple stake position\"\r\n        );\r\n        _mint(to, tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) public onlyOwner {\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(\r\n            balanceOf(to) == 0,\r\n            \"Validators MUST NOT own multiple stake position\"\r\n        );\r\n        super._transferFrom(from, to, tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ProxyStorage is Ownable {\r\n    address internal proxyTo;\r\n}\r\n\r\n// File: contracts/common/misc/ERCProxy.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.5.2;\r\n\r\n// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\r\n\r\ninterface ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId);\r\n    function implementation() external view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/common/misc/DelegateProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId) {\r\n        // Upgradeable proxy\r\n        proxyTypeId = 2;\r\n    }\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let result := delegatecall(\r\n                sub(gas, 10000),\r\n                _dst,\r\n                add(_calldata, 0x20),\r\n                mload(_calldata),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize\r\n\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/UpgradableProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract UpgradableProxy is DelegateProxy {\r\n    event ProxyUpdated(address indexed _new, address indexed _old);\r\n    event OwnerUpdate(address _new, address _old);\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"matic.network.proxy.implementation\");\r\n    bytes32 constant OWNER_SLOT = keccak256(\"matic.network.proxy.owner\");\r\n\r\n    constructor(address _proxyTo) public {\r\n        setOwner(msg.sender);\r\n        setImplementation(_proxyTo);\r\n    }\r\n\r\n    function() external payable {\r\n        // require(currentContract != 0, \"If app code has not been set yet, do not call\");\r\n        // Todo: filter out some calls or handle in the end fallback\r\n        delegatedFwd(loadImplementation(), msg.data);\r\n    }\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(loadOwner() == msg.sender, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    function owner() external view returns(address) {\r\n        return loadOwner();\r\n    }\r\n\r\n    function loadOwner() internal view returns(address) {\r\n        address _owner;\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            _owner := sload(position)\r\n        }\r\n        return _owner;\r\n    }\r\n\r\n    function implementation() external view returns (address) {\r\n        return loadImplementation();\r\n    }\r\n\r\n    function loadImplementation() internal view returns(address) {\r\n        address _impl;\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            _impl := sload(position)\r\n        }\r\n        return _impl;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnerUpdate(newOwner, loadOwner());\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    function setOwner(address newOwner) private {\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            sstore(position, newOwner)\r\n        }\r\n    }\r\n\r\n    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\r\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\r\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\r\n\r\n        emit ProxyUpdated(_newProxyTo, loadImplementation());\r\n        \r\n        setImplementation(_newProxyTo);\r\n    }\r\n\r\n    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\r\n        updateImplementation(_newProxyTo);\r\n\r\n        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    function setImplementation(address _newProxyTo) private {\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            sstore(position, _newProxyTo)\r\n        }\r\n    }\r\n    \r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_target)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ValidatorShareProxy is UpgradableProxy {\r\n    constructor(address _registry) public UpgradableProxy(_registry) {}\r\n\r\n    function loadImplementation() internal view returns (address) {\r\n        return Registry(super.loadImplementation()).getValidatorShareAddress();\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: contracts/common/tokens/ERC20NonTransferable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ERC20NonTransferable is ERC20 {\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        revert(\"Disabled\");\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/OwnableLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract OwnableLockable is Lockable, Ownable {\r\n    function lock() public onlyOwner {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyOwner {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Initializable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Initializable {\r\n    bool inited = false;\r\n\r\n    modifier initializer() {\r\n        require(!inited, \"already inited\");\r\n        inited = true;\r\n        \r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShare.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ValidatorShare is IValidatorShare, ERC20NonTransferable, OwnableLockable, Initializable {\r\n    struct DelegatorUnbond {\r\n        uint256 shares;\r\n        uint256 withdrawEpoch;\r\n    }\r\n\r\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\r\n    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\r\n    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10 ** 29; \r\n    uint256 constant MAX_COMMISION_RATE = 100;\r\n    uint256 constant REWARD_PRECISION = 10**25;\r\n\r\n    StakingInfo public stakingLogger;\r\n    IStakeManager public stakeManager;\r\n    uint256 public validatorId;\r\n    uint256 public validatorRewards;\r\n    uint256 public commissionRate;\r\n    //last checkpoint where validator updated commission rate\r\n    uint256 public lastCommissionUpdate;\r\n    uint256 public minAmount = 10**18;\r\n\r\n    // deprecated\r\n    uint256 public __totalStake;\r\n    uint256 public rewardPerShare;\r\n    uint256 public activeAmount;\r\n    bool public delegation = true;\r\n\r\n    uint256 public withdrawPool;\r\n    uint256 public withdrawShares;\r\n\r\n    // deprecated\r\n    mapping(address => uint256) __amountStaked;\r\n    mapping(address => DelegatorUnbond) public unbonds;\r\n    mapping(address => uint256) public initalRewardPerShare;\r\n\r\n    modifier onlyValidator() {\r\n        require(stakeManager.ownerOf(validatorId) == msg.sender, \"not validator\");\r\n        _;\r\n    }\r\n\r\n    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\r\n    function initialize(uint256 _validatorId, address _stakingLogger, address _stakeManager) external initializer  {\r\n        validatorId = _validatorId;\r\n        stakingLogger = StakingInfo(_stakingLogger);\r\n        stakeManager = IStakeManager(_stakeManager);\r\n        _transferOwnership(_stakeManager);\r\n\r\n        minAmount = 10**18;\r\n        delegation = true;\r\n    }\r\n\r\n    function updateCommissionRate(uint256 newCommissionRate) external onlyValidator {\r\n        uint256 epoch = stakeManager.epoch();\r\n        uint256 _lastCommissionUpdate = lastCommissionUpdate;\r\n\r\n        require( // withdrawalDelay == dynasty\r\n            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) <= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\r\n            \"Commission rate update cooldown period\"\r\n        );\r\n\r\n        require(newCommissionRate <= MAX_COMMISION_RATE, \"Commission rate should be in range of 0-100\");\r\n        stakingLogger.logUpdateCommissionRate(validatorId, newCommissionRate, commissionRate);\r\n        commissionRate = newCommissionRate;\r\n        lastCommissionUpdate = epoch;\r\n    }\r\n\r\n    function updateRewards(uint256 reward, uint256 checkpointStakePower, uint256 validatorStake)\r\n        external\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        uint256 combinedStakePower = validatorStake.add(activeAmount); // validator + delegation stake power\r\n        uint256 rewards = combinedStakePower.mul(reward).div(checkpointStakePower);\r\n\r\n        _updateRewards(rewards, validatorStake, combinedStakePower);\r\n        return combinedStakePower;\r\n    }\r\n\r\n    function addProposerBonus(uint256 rewards, uint256 validatorStake) public onlyOwner {\r\n        uint256 combinedStakePower = validatorStake.add(activeAmount);\r\n        _updateRewards(rewards, validatorStake, combinedStakePower);\r\n    }\r\n\r\n    function _updateRewards(uint256 rewards, uint256 validatorStake, uint256 combinedStakePower) internal {\r\n        uint256 _validatorRewards = validatorStake.mul(rewards).div(combinedStakePower);\r\n\r\n        // add validator commission from delegation rewards\r\n        if (commissionRate > 0) {\r\n            _validatorRewards = _validatorRewards.add(\r\n                rewards.sub(_validatorRewards).mul(commissionRate).div(MAX_COMMISION_RATE)\r\n            );\r\n        }\r\n\r\n        validatorRewards = validatorRewards.add(_validatorRewards);\r\n\r\n        uint256 delegatorsRewards = rewards.sub(_validatorRewards);\r\n        uint256 totalShares = totalSupply();\r\n        if (totalShares > 0) {\r\n            rewardPerShare = rewardPerShare.add(\r\n                delegatorsRewards.mul(REWARD_PRECISION).div(totalShares)\r\n            );\r\n        }\r\n    }\r\n\r\n    function withdrawRewardsValidator() external onlyOwner returns (uint256) {\r\n        uint256 _validatorRewards = validatorRewards;\r\n        validatorRewards = 0;\r\n        return _validatorRewards;\r\n    }\r\n\r\n    function _getRatePrecision() private view returns(uint256) {\r\n        // if foundation validator, use old precision\r\n        if (validatorId < 8) {\r\n            return EXCHANGE_RATE_PRECISION;\r\n        } \r\n\r\n        return EXCHANGE_RATE_HIGH_PRECISION;\r\n    }\r\n\r\n    function exchangeRate() public view returns (uint256) {\r\n        uint256 totalShares = totalSupply();\r\n        uint256 precision = _getRatePrecision();\r\n        return\r\n            totalShares == 0\r\n                ? precision\r\n                : activeAmount.mul(precision).div(totalShares);\r\n    }\r\n\r\n    function withdrawExchangeRate() public view returns (uint256) {\r\n        uint256 precision = _getRatePrecision();\r\n        if (validatorId < 8) {\r\n            // fix of potentially broken withdrawals for future unbonding\r\n            // foundation validators have no slashing enabled and thus we can return default exchange rate\r\n            // because without slashing rate will stay constant\r\n            return precision;\r\n        }\r\n\r\n        uint256 _withdrawShares = withdrawShares;\r\n        return\r\n            _withdrawShares == 0\r\n                ? precision\r\n                : withdrawPool.mul(precision).div(_withdrawShares);\r\n    }\r\n\r\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public {\r\n        _buyVoucher(_amount, _minSharesToMint);\r\n    }\r\n\r\n    function _buyVoucher(uint256 _amount, uint256 _minSharesToMint) internal returns(uint256) {\r\n        _withdrawAndTransferReward(msg.sender);\r\n        uint256 amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);\r\n        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), \"deposit failed\");\r\n        return amountToDeposit;\r\n    }\r\n\r\n    function _getTotalStake(address user) internal view returns(uint256, uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        uint256 rate = exchangeRate();\r\n        if (shares == 0) {\r\n            return (0, rate);\r\n        }\r\n\r\n        return (rate.mul(shares).div(_getRatePrecision()), rate);\r\n    }\r\n\r\n    function restake() public {\r\n        _restake();\r\n    }\r\n\r\n    function _restake() internal returns(uint256) {\r\n        uint256 liquidReward = _withdrawReward(msg.sender);\r\n        require(liquidReward >= minAmount, \"Too small rewards to restake\");\r\n\r\n        uint256 amountRestaked = _buyShares(liquidReward, 0, msg.sender);\r\n        if (liquidReward > amountRestaked) {\r\n            // return change to the user\r\n            require(stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, msg.sender), \"Insufficent rewards\");\r\n            stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidReward - amountRestaked);\r\n        }\r\n\r\n        (uint256 totalStaked, ) = _getTotalStake(msg.sender);\r\n        stakingLogger.logDelegatorRestaked(validatorId, msg.sender, totalStaked);\r\n\r\n        return amountRestaked;\r\n    }\r\n\r\n    function _buyShares(uint256 _amount, uint256 _minSharesToMint, address user) private onlyWhenUnlocked returns(uint256) {\r\n        require(delegation, \"Delegation is disabled\");\r\n\r\n        uint256 rate = exchangeRate();\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = _amount.mul(precision).div(rate);\r\n        require(shares >= _minSharesToMint, \"Too much slippage\");\r\n        require(unbonds[user].shares == 0, \"Ongoing exit\");\r\n\r\n        _mint(user, shares);\r\n\r\n        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\r\n        _amount = _amount.sub(_amount % rate.mul(shares).div(precision));\r\n\r\n        activeAmount = activeAmount.add(_amount);\r\n        stakeManager.updateValidatorState(validatorId, int256(_amount));\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareMinted(validatorId, user, _amount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function _reduceActiveStake(uint256 activeStakeReduce) private {\r\n        activeAmount = activeAmount.sub(activeStakeReduce);\r\n    }\r\n\r\n    function _reduceWithdrawPool(uint256 withdrawPoolReduce) private {\r\n        withdrawPool = withdrawPool.sub(withdrawPoolReduce);\r\n    }\r\n\r\n    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\r\n        // first get how much staked in total and compare to target unstake amount\r\n        (uint256 totalStaked, uint256 rate) = _getTotalStake(msg.sender);\r\n        require(totalStaked > 0 && totalStaked >= claimAmount, \"Too much requested\");\r\n\r\n        // convert requested amount back to shares\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = claimAmount.mul(precision).div(rate);\r\n        require(shares <= maximumSharesToBurn, \"too much slippage\");\r\n\r\n        _withdrawAndTransferReward(msg.sender);\r\n        \r\n        _burn(msg.sender, shares);\r\n        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\r\n\r\n        _reduceActiveStake(claimAmount);\r\n\r\n        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\r\n        withdrawPool = withdrawPool.add(claimAmount);\r\n        withdrawShares = withdrawShares.add(_withdrawPoolShare);\r\n        \r\n        DelegatorUnbond memory unbond = unbonds[msg.sender];\r\n        unbond.shares = unbond.shares.add(_withdrawPoolShare);\r\n        // refresh undond period\r\n        unbond.withdrawEpoch = stakeManager.epoch();\r\n        unbonds[msg.sender] = unbond;\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function _withdrawReward(address user) private returns(uint256) {\r\n        uint256 liquidRewards = getLiquidRewards(user);\r\n        initalRewardPerShare[user] = rewardPerShare;\r\n        return liquidRewards;\r\n    }\r\n\r\n    function _withdrawAndTransferReward(address user) private returns(uint256) {\r\n        uint256 liquidRewards = _withdrawReward(user);\r\n        if (liquidRewards > 0) {\r\n            require(stakeManager.transferFunds(validatorId, liquidRewards, user), \"Insufficent rewards\");\r\n            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);\r\n        }\r\n        \r\n        return liquidRewards;\r\n    }\r\n\r\n    function withdrawRewards() public {\r\n        uint256 rewards = _withdrawAndTransferReward(msg.sender);\r\n        require(rewards >= minAmount, \"Too small rewards amount\");\r\n    }\r\n\r\n    function migrateOut(address user, uint256 amount) external onlyOwner {\r\n        _withdrawAndTransferReward(user);\r\n        (uint256 totalStaked, uint256 rate) = _getTotalStake(user);\r\n        require(totalStaked >= amount, \"Migrating too much\");\r\n\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = amount.mul(precision).div(rate);\r\n        _burn(user, shares);\r\n\r\n        stakeManager.updateValidatorState(validatorId, -int256(amount));\r\n        _reduceActiveStake(amount);\r\n\r\n        stakingLogger.logShareBurned(validatorId, user, amount, shares);\r\n        stakingLogger.logStakeUpdate(validatorId);\r\n        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    function migrateIn(address user, uint256 amount) external onlyOwner {\r\n        _buyShares(amount, 0, user);\r\n    }\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        if (shares == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return rewardPerShare.sub(initalRewardPerShare[user]).mul(shares).div(REWARD_PRECISION);\r\n    }\r\n\r\n    function unstakeClaimTokens() public {\r\n        _claimUnstakedTokens();\r\n    }\r\n\r\n    function _claimUnstakedTokens() internal returns(uint256) {\r\n        DelegatorUnbond memory unbond = unbonds[msg.sender];\r\n\r\n        uint256 shares = unbond.shares;\r\n        require(\r\n            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\r\n            \"Incomplete withdrawal period\"\r\n        );\r\n\r\n        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\r\n        withdrawShares = withdrawShares.sub(shares);\r\n        withdrawPool = withdrawPool.sub(_amount);\r\n\r\n        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), \"Insufficent rewards\");\r\n        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, _amount);\r\n        delete unbonds[msg.sender];\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function slash(uint256 valPow, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {\r\n        uint256 _withdrawPool = withdrawPool;\r\n        uint256 delegationAmount = activeAmount.add(_withdrawPool);\r\n        if (delegationAmount == 0) {\r\n            return 0;\r\n        }\r\n        // total amount to be slashed from delegation pool (active + inactive)\r\n        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(valPow.add(delegationAmount));\r\n        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\r\n\r\n        // slash inactive pool\r\n        _reduceActiveStake(_amountToSlash.sub(_amountToSlashWithdrawalPool));\r\n        _reduceWithdrawPool(_amountToSlashWithdrawalPool);\r\n        return _amountToSlash;\r\n    }\r\n\r\n    function updateDelegation(bool _delegation) external onlyOwner {\r\n        delegation = _delegation;\r\n    }\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if (token == address(0x0)) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(destination, amount), \"Drain failed\");\r\n        }\r\n    }\r\n\r\n    function getActiveAmount() external view returns(uint256) {\r\n        return activeAmount;\r\n    }\r\n\r\n    function unlockContract() external onlyOwner returns (uint256) {\r\n        unlock();\r\n        return activeAmount;\r\n    }\r\n\r\n    function lockContract() external onlyOwner returns (uint256) {\r\n        lock();\r\n        return activeAmount;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareFactory.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ValidatorShareFactory {\r\n    /**\r\n    - factory to create new validatorShare contracts\r\n   */\r\n    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {\r\n        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);\r\n\r\n        proxy.transferOwnership(msg.sender);\r\n\r\n        address proxyAddr = address(proxy);\r\n        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(\r\n            abi.encodeWithSelector(\r\n                ValidatorShare(proxyAddr).initialize.selector, \r\n                validatorId, \r\n                loggerAddress, \r\n                msg.sender\r\n            )\r\n        );\r\n        require(success, string(data));\r\n\r\n        return proxyAddr;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakeManagerStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StakeManagerStorage is GovernanceLockable, RootChainable {\r\n    IERC20 public token;\r\n    address public registry;\r\n    StakingInfo public logger;\r\n    StakingNFT public NFTContract;\r\n    ValidatorShareFactory public factory;\r\n    uint256 public WITHDRAWAL_DELAY; // unit: epoch\r\n    uint256 public currentEpoch;\r\n\r\n    // genesis/governance variables\r\n    uint256 public dynasty ; // unit: epoch 50 days\r\n    uint256 public CHECKPOINT_REWARD; // update via governance\r\n    uint256 public minDeposit; // in ERC20 token\r\n    uint256 public minHeimdallFee; // in ERC20 token\r\n    uint256 public checkPointBlockInterval;\r\n    uint256 public signerUpdateLimit;\r\n\r\n    uint256 public validatorThreshold; //128\r\n    uint256 public totalStaked;\r\n    uint256 public NFTCounter;\r\n    uint256 public totalRewards;\r\n    uint256 public totalRewardsLiquidated;\r\n    uint256 public auctionPeriod; // 1 week in epochs\r\n    uint256 public proposerBonus; // 10 % of total rewards\r\n    bytes32 public accountStateRoot;\r\n    // Stop validator auction for some time when updating dynasty value\r\n    uint256 public replacementCoolDown;\r\n    bool public delegationEnabled;\r\n\r\n    struct Auction {\r\n        uint256 amount;\r\n        uint256 startEpoch;\r\n        address user;\r\n        bool acceptDelegation;\r\n        bytes signerPubkey;\r\n    }\r\n\r\n    struct State {\r\n        uint256 amount;\r\n        uint256 stakerCount;\r\n    }\r\n\r\n    struct StateChange {\r\n        int256 amount;\r\n        int256 stakerCount;\r\n    }\r\n\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    // signer to Validator mapping\r\n    mapping(address => uint256) public signerToValidator;\r\n    State public validatorState;\r\n    mapping(uint256 => StateChange) public validatorStateChanges;\r\n\r\n    mapping(address => uint256) public userFeeExit;\r\n    //Ongoing auctions for validatorId\r\n    mapping(uint256 => Auction) public validatorAuction;\r\n    // validatorId to last signer update epoch\r\n    mapping(uint256 => uint256) public latestSignerUpdateEpoch;\r\n\r\n    uint256 public totalHeimdallFee;\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakeManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StakeManager is IStakeManager, StakeManagerStorage, Initializable {\r\n    using SafeMath for uint256;\r\n    using ECVerify for bytes32;\r\n    using Merkle for bytes32;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    uint256 private constant INCORRECT_VALIDATOR_ID = 2**256 - 1;\r\n\r\n    modifier onlyStaker(uint256 validatorId) {\r\n        _assertOnlyStaker(validatorId);\r\n        _;\r\n    }\r\n\r\n    function _assertOnlyStaker(uint256 validatorId) private view {\r\n        require(NFTContract.ownerOf(validatorId) == msg.sender);\r\n    }\r\n\r\n    constructor() public GovernanceLockable(address(0x0)) {}\r\n\r\n    function initialize(\r\n        address _registry,\r\n        address _rootchain,\r\n        address _token,\r\n        address _NFTContract,\r\n        address _stakingLogger,\r\n        address _validatorShareFactory,\r\n        address _governance,\r\n        address _owner\r\n    ) external initializer {\r\n        governance = IGovernance(_governance);\r\n        registry = _registry;\r\n        rootChain = _rootchain;\r\n        token = IERC20(_token);\r\n        NFTContract = StakingNFT(_NFTContract);\r\n        logger = StakingInfo(_stakingLogger);\r\n        factory = ValidatorShareFactory(_validatorShareFactory);\r\n        _transferOwnership(_owner);\r\n\r\n        WITHDRAWAL_DELAY = (2**13); // unit: epoch\r\n        currentEpoch = 1;\r\n        dynasty = 886; // unit: epoch 50 days\r\n        CHECKPOINT_REWARD = 20188 * (10**18); // update via governance\r\n        minDeposit = (10**18); // in ERC20 token\r\n        minHeimdallFee = (10**18); // in ERC20 token\r\n        checkPointBlockInterval = 1024;\r\n        signerUpdateLimit = 100;\r\n\r\n        validatorThreshold = 7; //128\r\n        NFTCounter = 1;\r\n        auctionPeriod = (2**13) / 4; // 1 week in epochs\r\n        proposerBonus = 10; // 10 % of total rewards\r\n        delegationEnabled = true;\r\n    }\r\n\r\n    function setDelegationEnabled(bool enabled) public onlyGovernance {\r\n        delegationEnabled = enabled;\r\n    }\r\n\r\n    // TopUp heimdall fee\r\n    function topUpForFee(address user, uint256 heimdallFee) public onlyWhenUnlocked {\r\n        _transferAndTopUp(user, heimdallFee, 0);\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        return NFTContract.ownerOf(tokenId);\r\n    }\r\n\r\n    function epoch() public view returns (uint256) {\r\n        return currentEpoch;\r\n    }\r\n\r\n    function withdrawalDelay() public view returns (uint256) {\r\n        return WITHDRAWAL_DELAY;\r\n    }\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256) {\r\n        return validators[validatorId].amount;\r\n    }\r\n\r\n    function _transferAndTopUp(\r\n        address user,\r\n        uint256 fee,\r\n        uint256 additionalAmount\r\n    ) private {\r\n        require(fee >= minHeimdallFee, \"Not enough heimdall fee\");\r\n        require(token.transferFrom(msg.sender, address(this), fee.add(additionalAmount)), \"Fee transfer failed\");\r\n        totalHeimdallFee = totalHeimdallFee.add(fee);\r\n        logger.logTopUpFee(user, fee);\r\n    }\r\n\r\n    function _claimFee(address user, uint256 amount) private {\r\n        totalHeimdallFee = totalHeimdallFee.sub(amount);\r\n        logger.logClaimFee(user, amount);\r\n    }\r\n\r\n    function claimFee(\r\n        uint256 accumFeeAmount,\r\n        uint256 index,\r\n        bytes memory proof\r\n    ) public {\r\n        //Ignoring other params becuase rewards distribution is on chain\r\n        require(\r\n            keccak256(abi.encode(msg.sender, accumFeeAmount)).checkMembership(index, accountStateRoot, proof),\r\n            \"Wrong acc proof\"\r\n        );\r\n        uint256 withdrawAmount = accumFeeAmount.sub(userFeeExit[msg.sender]);\r\n        _claimFee(msg.sender, withdrawAmount);\r\n        userFeeExit[msg.sender] = accumFeeAmount;\r\n        require(token.transfer(msg.sender, withdrawAmount));\r\n    }\r\n\r\n    function stake(\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external {\r\n        stakeFor(msg.sender, amount, heimdallFee, acceptDelegation, signerPubkey);\r\n    }\r\n\r\n    function totalStakedFor(address user) external view returns (uint256) {\r\n        if (user == address(0x0) || NFTContract.balanceOf(user) == 0) {\r\n            return 0;\r\n        }\r\n        return validators[NFTContract.tokenOfOwnerByIndex(user, 0)].amount;\r\n    }\r\n\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool _acceptDelegation,\r\n        bytes calldata _signerPubkey\r\n    ) external onlyWhenUnlocked {\r\n        uint256 currentValidatorAmount = validators[validatorId].amount;\r\n\r\n        require(\r\n            validators[validatorId].deactivationEpoch == 0 && currentValidatorAmount != 0,\r\n            \"Invalid validator for an auction\"\r\n        );\r\n        uint256 senderValidatorId = signerToValidator[msg.sender];\r\n        // make sure that signer wasn't used already\r\n        require(\r\n            NFTContract.balanceOf(msg.sender) == 0 && // existing validators can't bid\r\n                senderValidatorId != INCORRECT_VALIDATOR_ID,\r\n            \"Already used address\"\r\n        );\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        uint256 _replacementCoolDown = replacementCoolDown;\r\n        // when dynasty period is updated validators are in cooldown period\r\n        require(_replacementCoolDown == 0 || _replacementCoolDown <= _currentEpoch, \"Cooldown period\");\r\n        // (auctionPeriod--dynasty)--(auctionPeriod--dynasty)--(auctionPeriod--dynasty)\r\n        // if it's auctionPeriod then will get residue smaller then auctionPeriod\r\n        // from (CurrentPeriod of validator )%(auctionPeriod--dynasty)\r\n        // make sure that its `auctionPeriod` window\r\n        // dynasty = 30, auctionPeriod = 7, activationEpoch = 1, currentEpoch = 39\r\n        // residue 1 = (39-1)% (7+30), if residue <= auctionPeriod it's `auctionPeriod`\r\n\r\n        require(\r\n            (_currentEpoch.sub(validators[validatorId].activationEpoch) % dynasty.add(auctionPeriod)) < auctionPeriod,\r\n            \"Invalid auction period\"\r\n        );\r\n\r\n        uint256 perceivedStake = currentValidatorAmount;\r\n        address _contract = validators[validatorId].contractAddress;\r\n\r\n        if (_contract != address(0x0)) {\r\n            perceivedStake = perceivedStake.add(IValidatorShare(_contract).getActiveAmount());\r\n        }\r\n\r\n        Auction storage auction = validatorAuction[validatorId];\r\n        uint256 currentAuctionAmount = auction.amount;\r\n\r\n        perceivedStake = Math.max(perceivedStake, currentAuctionAmount);\r\n\r\n        require(perceivedStake < amount, \"Must bid higher\");\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer amount failed\");\r\n\r\n        //replace prev auction\r\n        if (currentAuctionAmount != 0) {\r\n            require(token.transfer(auction.user, currentAuctionAmount), \"Bid return failed\");\r\n        }\r\n\r\n        // create new auction\r\n        auction.amount = amount;\r\n        auction.user = msg.sender;\r\n        auction.acceptDelegation = _acceptDelegation;\r\n        auction.signerPubkey = _signerPubkey;\r\n\r\n        logger.logStartAuction(validatorId, currentValidatorAmount, amount);\r\n    }\r\n\r\n    function confirmAuctionBid(\r\n        uint256 validatorId,\r\n        uint256 heimdallFee /** for new validator */\r\n    ) external onlyWhenUnlocked {\r\n        Auction storage auction = validatorAuction[validatorId];\r\n        address auctionUser = auction.user;\r\n\r\n        require(\r\n            msg.sender == auctionUser || getValidatorId(msg.sender) == validatorId,\r\n            \"Only bidder or validator can confirm\"\r\n        );\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        require(\r\n            _currentEpoch.sub(auction.startEpoch) % auctionPeriod.add(dynasty) >= auctionPeriod,\r\n            \"Not allowed before auctionPeriod\"\r\n        );\r\n        require(auction.user != address(0x0), \"Invalid auction\");\r\n\r\n        uint256 validatorAmount = validators[validatorId].amount;\r\n        uint256 perceivedStake = validatorAmount;\r\n        uint256 auctionAmount = auction.amount;\r\n        address contractAddr = validators[validatorId].contractAddress;\r\n\r\n        if (contractAddr != address(0x0)) {\r\n            perceivedStake = perceivedStake.add(IValidatorShare(contractAddr).getActiveAmount());\r\n        }\r\n\r\n        // validator is last auctioner\r\n        if (perceivedStake >= auctionAmount && validators[validatorId].deactivationEpoch == 0) {\r\n            require(token.transfer(auctionUser, auctionAmount), \"Bid return failed\");\r\n            //cleanup auction data\r\n            auction.startEpoch = _currentEpoch;\r\n            logger.logConfirmAuction(validatorId, validatorId, validatorAmount);\r\n        } else {\r\n            // dethrone\r\n            _transferAndTopUp(auctionUser, heimdallFee, 0);\r\n            _unstake(validatorId, _currentEpoch);\r\n\r\n            uint256 newValidatorId = _stakeFor(\r\n                auctionUser,\r\n                auctionAmount,\r\n                auction.acceptDelegation,\r\n                auction.signerPubkey\r\n            );\r\n            logger.logConfirmAuction(newValidatorId, validatorId, auctionAmount);\r\n        }\r\n        uint256 startEpoch = auction.startEpoch;\r\n        delete validatorAuction[validatorId];\r\n        validatorAuction[validatorId].startEpoch = startEpoch;\r\n    }\r\n\r\n    function unstake(uint256 validatorId) external onlyStaker(validatorId) {\r\n        require(validatorAuction[validatorId].amount == 0, \"Wait for auction completion\");\r\n        require(\r\n            validators[validatorId].activationEpoch > 0 &&\r\n                validators[validatorId].deactivationEpoch == 0 &&\r\n                (validators[validatorId].status == Status.Active || validators[validatorId].status == Status.Locked)\r\n        );\r\n\r\n        uint256 exitEpoch = currentEpoch.add(1); // notice period\r\n        _unstake(validatorId, exitEpoch);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function forceUnstake(uint256 validatorId) external onlyGovernance {\r\n        _unstake(validatorId, currentEpoch);\r\n    }\r\n\r\n    function setCurrentEpoch(uint256 _currentEpoch) external onlyGovernance {\r\n        currentEpoch = _currentEpoch;\r\n    }\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool) {\r\n        require(\r\n            validators[validatorId].contractAddress == msg.sender ||\r\n            Registry(registry).getSlashingManagerAddress() == msg.sender,\r\n            \"Invalid contract address\"\r\n        );\r\n        return token.transfer(delegator, amount);\r\n    }\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool) {\r\n        require(validators[validatorId].contractAddress == msg.sender, \"Invalid contract address\");\r\n        return token.transferFrom(delegator, address(this), amount);\r\n    }\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public onlyWhenUnlocked {\r\n        require(currentValidatorSetSize() < validatorThreshold, \"Validator set Threshold exceeded!\");\r\n        require(amount > minDeposit, \"min deposit limit failed!\");\r\n        _transferAndTopUp(user, heimdallFee, amount);\r\n        _stakeFor(user, amount, acceptDelegation, signerPubkey);\r\n    }\r\n\r\n    function unstakeClaim(uint256 validatorId) public onlyStaker(validatorId) {\r\n        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;\r\n        // can only claim stake back after WITHDRAWAL_DELAY\r\n        require(\r\n            deactivationEpoch > 0 &&\r\n                deactivationEpoch.add(WITHDRAWAL_DELAY) <= currentEpoch &&\r\n                validators[validatorId].status != Status.Unstaked\r\n        );\r\n\r\n        uint256 amount = validators[validatorId].amount;\r\n        uint256 newTotalStaked = totalStaked.sub(amount);\r\n        totalStaked = newTotalStaked;\r\n\r\n        NFTContract.burn(validatorId);\r\n\r\n        signerToValidator[validators[validatorId].signer] = INCORRECT_VALIDATOR_ID;\r\n        validators[validatorId].status = Status.Unstaked;\r\n        require(token.transfer(msg.sender, amount), \"Transfer stake failed\");\r\n        logger.logUnstaked(msg.sender, validatorId, amount, newTotalStaked);\r\n    }\r\n\r\n    // slashing and jail interface\r\n    function restake(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool stakeRewards\r\n    ) public onlyWhenUnlocked onlyStaker(validatorId) {\r\n        require(validators[validatorId].deactivationEpoch == 0, \"No use of restaking\");\r\n\r\n        if (amount > 0) {\r\n            require(token.transferFrom(msg.sender, address(this), amount), \"Transfer stake failed\");\r\n        }\r\n\r\n        if (stakeRewards) {\r\n            amount = amount.add(validators[validatorId].reward);\r\n            address contractAddr = validators[validatorId].contractAddress;\r\n            if (contractAddr != address(0x0)) {\r\n                amount = amount.add(IValidatorShare(contractAddr).withdrawRewardsValidator());\r\n            }\r\n            validators[validatorId].reward = 0;\r\n        }\r\n\r\n        uint256 newTotalStaked = totalStaked.add(amount);\r\n        totalStaked = newTotalStaked;\r\n        validators[validatorId].amount = validators[validatorId].amount.add(amount);\r\n\r\n        updateTimeline(int256(amount), 0, 0);\r\n\r\n        logger.logStakeUpdate(validatorId);\r\n        logger.logRestaked(validatorId, validators[validatorId].amount, newTotalStaked);\r\n    }\r\n\r\n    function _liquidateRewards(uint256 validatorId, address validatorUser, uint256 reward) private {\r\n        totalRewardsLiquidated = totalRewardsLiquidated.add(reward);\r\n        validators[validatorId].reward = 0;\r\n        require(token.transfer(validatorUser, reward), \"Insufficent rewards\");\r\n        logger.logClaimRewards(validatorId, reward, totalRewardsLiquidated);\r\n    }\r\n\r\n    function withdrawRewards(uint256 validatorId) public onlyStaker(validatorId) {\r\n        uint256 reward = validators[validatorId].reward;\r\n        address contractAddr = validators[validatorId].contractAddress;\r\n        if (contractAddr != address(0x0)) {\r\n            reward = reward.add(IValidatorShare(contractAddr).withdrawRewardsValidator());\r\n        }\r\n\r\n        _liquidateRewards(validatorId, msg.sender, reward);\r\n    }\r\n\r\n    function migrateDelegation(uint256 fromValidatorId, uint256 toValidatorId, uint256 amount) public {\r\n        require(fromValidatorId < 8 && toValidatorId > 7, \"Invalid migration\");\r\n        IValidatorShare(validators[fromValidatorId].contractAddress).migrateOut(msg.sender, amount);\r\n        IValidatorShare(validators[toValidatorId].contractAddress).migrateIn(msg.sender, amount);\r\n    }\r\n\r\n    function getValidatorId(address user) public view returns (uint256) {\r\n        return NFTContract.tokenOfOwnerByIndex(user, 0);\r\n    }\r\n\r\n    // set staking Token\r\n    function setToken(address _token) public onlyGovernance {\r\n        require(_token != address(0x0));\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    // Change the number of validators required to allow a passed header root\r\n    function updateValidatorThreshold(uint256 newThreshold) public onlyGovernance {\r\n        require(newThreshold > 0);\r\n        logger.logThresholdChange(newThreshold, validatorThreshold);\r\n        validatorThreshold = newThreshold;\r\n    }\r\n\r\n    function updateCheckPointBlockInterval(uint256 _blocks) public onlyGovernance {\r\n        require(_blocks > 0, \"Blocks interval must be non-zero\");\r\n        checkPointBlockInterval = _blocks;\r\n    }\r\n\r\n    // Change reward for each checkpoint\r\n    function updateCheckpointReward(uint256 newReward) public onlyGovernance {\r\n        require(newReward > 0);\r\n        logger.logRewardUpdate(newReward, CHECKPOINT_REWARD);\r\n        CHECKPOINT_REWARD = newReward;\r\n    }\r\n\r\n    // Change delegation contract for a validator\r\n    // @note: Users must exit before this update or all funds may get lost\r\n    function updateContractAddress(uint256 validatorId, address newContractAddress) public onlyGovernance {\r\n        require(IValidatorShare(newContractAddress).owner() == address(this), \"Owner of contract must be stakeManager\");\r\n        validators[validatorId].contractAddress = newContractAddress;\r\n    }\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public {\r\n        if (amount > 0) {\r\n            // deposit during shares purchase\r\n            require(delegationEnabled, \"Delegation is disabled\");\r\n        }\r\n\r\n        require(validators[validatorId].contractAddress == msg.sender, \"Invalid contract address\");\r\n        updateTimeline(amount, 0, 0);\r\n    }\r\n\r\n    function updateDynastyValue(uint256 newDynasty) public onlyGovernance {\r\n        require(newDynasty > 0);\r\n        logger.logDynastyValueChange(newDynasty, dynasty);\r\n        dynasty = newDynasty;\r\n        WITHDRAWAL_DELAY = newDynasty;\r\n        auctionPeriod = newDynasty.div(4);\r\n        // set cooldown period\r\n        replacementCoolDown = currentEpoch.add(auctionPeriod);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function stopAuctions(uint256 forNCheckpoints) public onlyGovernance {\r\n        replacementCoolDown = currentEpoch.add(forNCheckpoints);\r\n    }\r\n\r\n    function updateProposerBonus(uint256 newProposerBonus) public onlyGovernance {\r\n        logger.logProposerBonusChange(newProposerBonus, proposerBonus);\r\n        require(newProposerBonus <= 100, \"too big\");\r\n        proposerBonus = newProposerBonus;\r\n    }\r\n\r\n    function updateSignerUpdateLimit(uint256 _limit) public onlyGovernance {\r\n        signerUpdateLimit = _limit;\r\n    }\r\n\r\n    function updateMinAmounts(uint256 _minDeposit, uint256 _minHeimdallFee) public onlyGovernance {\r\n        minDeposit = _minDeposit;\r\n        minHeimdallFee = _minHeimdallFee;\r\n    }\r\n\r\n    function updateSigner(uint256 validatorId, bytes memory signerPubkey) public onlyStaker(validatorId) {\r\n        address signer = pubToAddress(signerPubkey);\r\n        require(signer != address(0x0) && signerToValidator[signer] == 0, \"Invalid signer\");\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        require(\r\n            _currentEpoch >= latestSignerUpdateEpoch[validatorId].add(signerUpdateLimit),\r\n            \"Invalid checkpoint number!\"\r\n        );\r\n\r\n        address currentSigner = validators[validatorId].signer;\r\n        // update signer event\r\n        logger.logSignerChange(validatorId, currentSigner, signer, signerPubkey);\r\n\r\n        signerToValidator[currentSigner] = INCORRECT_VALIDATOR_ID;\r\n        signerToValidator[signer] = validatorId;\r\n        validators[validatorId].signer = signer;\r\n        // reset update time to current time\r\n        latestSignerUpdateEpoch[validatorId] = _currentEpoch;\r\n    }\r\n\r\n    function currentValidatorSetSize() public view returns (uint256) {\r\n        return validatorState.stakerCount;\r\n    }\r\n\r\n    function currentValidatorSetTotalStake() public view returns (uint256) {\r\n        return validatorState.amount;\r\n    }\r\n\r\n    function getValidatorContract(uint256 validatorId) public view returns (address) {\r\n        return validators[validatorId].contractAddress;\r\n    }\r\n\r\n    function isValidator(uint256 validatorId) public view returns (bool) {\r\n        uint256 activationEpoch = validators[validatorId].activationEpoch;\r\n        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;\r\n        uint256 amount = validators[validatorId].amount;\r\n        Status status = validators[validatorId].status;\r\n        uint256 _currentEpoch = currentEpoch;\r\n\r\n        return (amount > 0 &&\r\n            (activationEpoch != 0 && activationEpoch <= _currentEpoch) &&\r\n            (deactivationEpoch == 0 || deactivationEpoch > _currentEpoch) &&\r\n            status == Status.Active);\r\n    }\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        bytes memory sigs\r\n    ) public onlyRootChain returns (uint256) {\r\n        // checkpoint rewards are based on BlockInterval multiplied on `CHECKPOINT_REWARD`\r\n        // for bigger checkpoints reward is capped at `CHECKPOINT_REWARD`\r\n        // if interval is 50% of checkPointBlockInterval then reward R is half of `CHECKPOINT_REWARD`\r\n        // and then stakePower is 90% of currentValidatorSetTotalStake then final reward is 90% of R\r\n        uint256 reward = blockInterval.mul(CHECKPOINT_REWARD).div(checkPointBlockInterval);\r\n        reward = Math.min(CHECKPOINT_REWARD, reward);\r\n\r\n        uint256 _proposerBonus = reward.mul(proposerBonus).div(100);\r\n        Validator storage _proposer = validators[signerToValidator[proposer]];\r\n        if (_proposer.contractAddress != address(0x0)) {\r\n            IValidatorShare(_proposer.contractAddress).addProposerBonus(_proposerBonus, _proposer.amount);\r\n        } else {\r\n            _proposer.reward = _proposer.reward.add(_proposerBonus);\r\n        }\r\n\r\n        reward = reward.sub(_proposerBonus);\r\n        uint256 stakePower = currentValidatorSetTotalStake();\r\n        // update stateMerkleTree root for accounts balance on heimdall chain\r\n        accountStateRoot = stateRoot;\r\n        _finalizeCommit();\r\n        return checkSignature(stakePower, reward, voteHash, sigs);\r\n    }\r\n\r\n    function checkSignature(\r\n        uint256 checkpointStakePower,\r\n        uint256 reward,\r\n        bytes32 voteHash,\r\n        bytes memory sigs\r\n    ) internal returns (uint256) {\r\n        // total voting power\r\n        uint256 totalStakePower;\r\n        address lastAdd; // cannot have address(0x0) as an owner\r\n        for (uint64 i = 0; i < sigs.length; i += 65) {\r\n            address signer = voteHash.ecrecovery(BytesLib.slice(sigs, i, 65));\r\n            uint256 validatorId = signerToValidator[signer];\r\n            // check if signer is staker and not proposer\r\n            if (signer == lastAdd) {\r\n                break;\r\n            } else if (isValidator(validatorId) && signer > lastAdd) {\r\n                lastAdd = signer;\r\n\r\n                Validator storage validator = validators[validatorId];\r\n                uint256 valPow;\r\n                // add delegation power\r\n                address contractAddr = validator.contractAddress;\r\n                if (contractAddr != address(0x0)) {\r\n                    valPow = IValidatorShare(contractAddr).updateRewards(\r\n                        reward,\r\n                        checkpointStakePower,\r\n                        validatorStake(validatorId)\r\n                    );\r\n                } else {\r\n                    valPow = validator.amount;\r\n                    validator.reward = validator.reward.add(valPow.mul(reward).div(checkpointStakePower));\r\n                }\r\n                totalStakePower = totalStakePower.add(valPow);\r\n            }\r\n        }\r\n\r\n        reward = CHECKPOINT_REWARD.mul(totalStakePower).div(currentValidatorSetTotalStake());\r\n        totalRewards = totalRewards.add(reward);\r\n        require(totalStakePower >= currentValidatorSetTotalStake().mul(2).div(3).add(1), \"2/3+1 non-majority!\");\r\n\r\n        return reward;\r\n    }\r\n\r\n    function slash(bytes memory _slashingInfoList) public returns (uint256) {\r\n        require(Registry(registry).getSlashingManagerAddress() == msg.sender, \"Sender must be slashing manager!\");\r\n        RLPReader.RLPItem[] memory slashingInfoList = _slashingInfoList.toRlpItem().toList();\r\n        int256 valJailed = 0;\r\n        uint256 jailedAmount = 0;\r\n        uint256 totalAmount;\r\n        for (uint256 i = 0; i < slashingInfoList.length; i++) {\r\n            RLPReader.RLPItem[] memory slashData = slashingInfoList[i].toList();\r\n            uint256 validatorId = slashData[0].toUint();\r\n            uint256 _amount = slashData[1].toUint();\r\n            totalAmount = totalAmount.add(_amount);\r\n\r\n            if (validators[validatorId].contractAddress != address(0x0)) {\r\n                uint256 delSlashedAmount = IValidatorShare(validators[validatorId].contractAddress).slash(\r\n                    validators[validatorId].amount,\r\n                    _amount\r\n                );\r\n                _amount = _amount.sub(delSlashedAmount);\r\n            }\r\n\r\n            uint256 validatorStakeSlashed = validators[validatorId].amount.sub(_amount);\r\n            validators[validatorId].amount = validatorStakeSlashed;\r\n\r\n            if (validatorStakeSlashed == 0) {\r\n                _unstake(validatorId, currentEpoch);    \r\n            } else if (slashData[2].toBoolean()) {\r\n                jailedAmount = jailedAmount.add(_jail(validatorId, 1));\r\n                valJailed++;\r\n            }\r\n        }\r\n\r\n        //update timeline\r\n        updateTimeline(-int256(totalAmount.add(jailedAmount)), -valJailed, 0);\r\n\r\n        return totalAmount;\r\n    }\r\n\r\n    function unjail(uint256 validatorId) public onlyStaker(validatorId) {\r\n        require(validators[validatorId].status == Status.Locked, \"Validator is not jailed\");\r\n        require(validators[validatorId].deactivationEpoch == 0, \"Validator already unstaking\");\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        require(validators[validatorId].jailTime <= _currentEpoch, \"Incomplete jail period\");\r\n\r\n        uint256 amount = validators[validatorId].amount;\r\n        require(amount >= minDeposit);\r\n\r\n        uint256 delegationAmount = 0;\r\n        if (validators[validatorId].contractAddress != address(0x0)) {\r\n            delegationAmount = IValidatorShare(validators[validatorId].contractAddress).unlockContract();\r\n        }\r\n\r\n        // undo timline so that validator is normal validator\r\n        updateTimeline(int256(amount.add(delegationAmount)), 1, 0);\r\n\r\n        validators[validatorId].status = Status.Active;\r\n        logger.logUnjailed(validatorId, validators[validatorId].signer);\r\n    }\r\n\r\n    function _jail(uint256 validatorId, uint256 jailCheckpoints) internal returns (uint256) {\r\n        uint256 delegationAmount = 0;\r\n        if (validators[validatorId].contractAddress != address(0x0)) {\r\n            delegationAmount = IValidatorShare(validators[validatorId].contractAddress).lockContract();\r\n        }\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        validators[validatorId].jailTime = _currentEpoch.add(jailCheckpoints);\r\n        validators[validatorId].status = Status.Locked;\r\n        logger.logJailed(validatorId, _currentEpoch, validators[validatorId].signer);\r\n        return validators[validatorId].amount.add(delegationAmount);\r\n    }\r\n\r\n    function _stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) internal returns (uint256) {\r\n        address signer = pubToAddress(signerPubkey);\r\n        require(signer != address(0x0) && signerToValidator[signer] == 0, \"Invalid signer\");\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        uint256 validatorId = NFTCounter;\r\n        StakingInfo _logger = logger;\r\n        uint256 newTotalStaked = totalStaked.add(amount);\r\n        totalStaked = newTotalStaked;\r\n\r\n        validators[validatorId] = Validator({\r\n            reward: 0,\r\n            amount: amount,\r\n            activationEpoch: _currentEpoch,\r\n            deactivationEpoch: 0,\r\n            jailTime: 0,\r\n            signer: signer,\r\n            contractAddress: acceptDelegation ? factory.create(validatorId, address(_logger), registry) : address(0x0),\r\n            status: Status.Active\r\n        });\r\n\r\n        latestSignerUpdateEpoch[validatorId] = _currentEpoch;\r\n        NFTContract.mint(user, validatorId);\r\n\r\n        signerToValidator[signer] = validatorId;\r\n        updateTimeline(int256(amount), 1, 0);\r\n        // no Auctions for 1 dynasty\r\n        validatorAuction[validatorId].startEpoch = _currentEpoch;\r\n        _logger.logStaked(signer, signerPubkey, validatorId, _currentEpoch, amount, newTotalStaked);\r\n        NFTCounter = validatorId.add(1);\r\n\r\n        return validatorId;\r\n    }\r\n\r\n    function _unstake(uint256 validatorId, uint256 exitEpoch) internal {\r\n        uint256 amount = validators[validatorId].amount;\r\n        address validator = ownerOf(validatorId);\r\n\r\n        validators[validatorId].deactivationEpoch = exitEpoch;\r\n\r\n        // unbond all delegators in future\r\n        int256 delegationAmount = 0;\r\n        uint256 rewards = validators[validatorId].reward;\r\n        address contractAddr = validators[validatorId].contractAddress;\r\n        if (contractAddr != address(0x0)) {\r\n            IValidatorShare validatorShare = IValidatorShare(contractAddr);\r\n            rewards = rewards.add(validatorShare.withdrawRewardsValidator());\r\n            delegationAmount = int256(validatorShare.lockContract());\r\n        }\r\n\r\n        _liquidateRewards(validatorId, validator, rewards);\r\n\r\n        //  update future\r\n        uint256 targetEpoch = exitEpoch <= currentEpoch ? 0 : exitEpoch;\r\n        updateTimeline(-(int256(amount) + delegationAmount), -1, targetEpoch);\r\n\r\n        logger.logUnstakeInit(validator, validatorId, exitEpoch, amount);\r\n    }\r\n\r\n    function _finalizeCommit() internal {\r\n        uint256 _currentEpoch = currentEpoch;\r\n        uint256 nextEpoch = _currentEpoch.add(1);\r\n\r\n        StateChange memory changes = validatorStateChanges[nextEpoch];\r\n        updateTimeline(changes.amount, changes.stakerCount, 0);\r\n\r\n        delete validatorStateChanges[_currentEpoch];\r\n\r\n        currentEpoch = nextEpoch;\r\n    }\r\n\r\n    function updateTimeline(\r\n        int256 amount,\r\n        int256 stakerCount,\r\n        uint256 targetEpoch\r\n    ) private {\r\n        if (targetEpoch == 0) {\r\n            // update totalstake and validator count\r\n            if (amount > 0) {\r\n                validatorState.amount = validatorState.amount.add(uint256(amount));\r\n            } else if (amount < 0) {\r\n                validatorState.amount = validatorState.amount.sub(uint256(amount * -1));\r\n            }\r\n\r\n            if (stakerCount > 0) {\r\n                validatorState.stakerCount = validatorState.stakerCount.add(uint256(stakerCount));\r\n            } else if (stakerCount < 0) {\r\n                validatorState.stakerCount = validatorState.stakerCount.sub(uint256(stakerCount * -1));\r\n            }\r\n        } else {\r\n            validatorStateChanges[targetEpoch].amount += amount;\r\n            validatorStateChanges[targetEpoch].stakerCount += stakerCount;\r\n        }\r\n    }\r\n\r\n    function pubToAddress(bytes memory pub) private pure returns (address) {\r\n        require(pub.length == 64, \"Invalid pubkey\");\r\n        return address(uint160(uint256(keccak256(pub))));\r\n    }\r\n\r\n    function reinitialize(\r\n        address _NFTContract,\r\n        address _stakingLogger,\r\n        address _validatorShareFactory\r\n    ) external onlyGovernance {\r\n        NFTContract = StakingNFT(_NFTContract);\r\n        logger = StakingInfo(_stakingLogger);\r\n        factory = ValidatorShareFactory(_validatorShareFactory);\r\n    }\r\n\r\n    function updateValidatorDelegation(bool delegation) external {\r\n        uint256 validatorId = signerToValidator[msg.sender];\r\n        require(isValidator(validatorId), \"not a validator\");\r\n\r\n        address contractAddr = validators[validatorId].contractAddress;\r\n        require(contractAddr != address(0x0), \"delegation not enabled\");\r\n\r\n        IValidatorShare(contractAddr).updateDelegation(delegation);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRootChain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRootChain\",\"type\":\"address\"}],\"name\":\"RootChainChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHECKPOINT_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NFTContract\",\"outputs\":[{\"internalType\":\"contract StakingNFT\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NFTCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRootChain\",\"type\":\"address\"}],\"name\":\"changeRootChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkPointBlockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockInterval\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"voteHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sigs\",\"type\":\"bytes\"}],\"name\":\"checkSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accumFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"claimFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heimdallFee\",\"type\":\"uint256\"}],\"name\":\"confirmAuctionBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentValidatorSetSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentValidatorSetTotalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"delegationDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dynasty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract ValidatorShareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"forceUnstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"getValidatorContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getValidatorId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IGovernance\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rootchain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFTContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingLogger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_validatorShareFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"latestSignerUpdateEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logger\",\"outputs\":[{\"internalType\":\"contract StakingInfo\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromValidatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toValidatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minHeimdallFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposerBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NFTContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingLogger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_validatorShareFactory\",\"type\":\"address\"}],\"name\":\"reinitialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"replacementCoolDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stakeRewards\",\"type\":\"bool\"}],\"name\":\"restake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootChain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentEpoch\",\"type\":\"uint256\"}],\"name\":\"setCurrentEpoch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelegationEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signerToValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signerUpdateLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_slashingInfoList\",\"type\":\"bytes\"}],\"name\":\"slash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heimdallFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"acceptDelegation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heimdallFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"acceptDelegation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"name\":\"stakeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_acceptDelegation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_signerPubkey\",\"type\":\"bytes\"}],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forNCheckpoints\",\"type\":\"uint256\"}],\"name\":\"stopAuctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"heimdallFee\",\"type\":\"uint256\"}],\"name\":\"topUpForFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHeimdallFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardsLiquidated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"transferFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"unjail\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"unstakeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocks\",\"type\":\"uint256\"}],\"name\":\"updateCheckPointBlockInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"updateCheckpointReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"}],\"name\":\"updateContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDynasty\",\"type\":\"uint256\"}],\"name\":\"updateDynastyValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minHeimdallFee\",\"type\":\"uint256\"}],\"name\":\"updateMinAmounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProposerBonus\",\"type\":\"uint256\"}],\"name\":\"updateProposerBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"name\":\"updateSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"updateSignerUpdateLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"delegation\",\"type\":\"bool\"}],\"name\":\"updateValidatorDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"updateValidatorState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"updateValidatorThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFeeExit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"acceptDelegation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"validatorStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorStateChanges\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"stakerCount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deactivationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jailTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"enum StakeManagerStorage.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"withdrawRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakeManager","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"Merkle:29d2706cdb97783a652314863668ed5cab971db2;ECVerify:ad758ddd05c851abfe184d6b1be0a5f1b3bcab78","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5303fd765be1bd98f895304344671726e733bd897ca8b4c4e93a97b01f9a2488"}]}