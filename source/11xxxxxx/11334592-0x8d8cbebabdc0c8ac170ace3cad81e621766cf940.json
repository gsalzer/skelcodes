{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract IConversionRate {\r\n\r\n    function getStepFunctionData(address token, uint command, uint param) virtual external view returns(int);\r\n    function getListedTokens() virtual external view returns(address[] memory);\r\n    function getBasicRate(address token, bool buy) virtual external view returns(uint);\r\n    function getRateUpdateBlock(address token) virtual external view returns(uint);\r\n    function getCompactData(address token) virtual external view returns(uint, uint, byte, byte);\r\n    function getTokenControlInfo(address token) virtual external view returns(uint, uint, uint);\r\n    \r\n     mapping(address => mapping(uint=>uint)) public tokenImbalanceData;\r\n}\r\n\r\n\r\n\r\ncontract KyberHelper {\r\n    \r\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\n    struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }\r\n\r\n    struct TokenData {\r\n        address token;\r\n        \r\n        uint256 rateUpdateBlock;\r\n\r\n        uint256 baseBuyRate;\r\n        uint256 baseSellRate;\r\n        \r\n        StepFunction buyRateQtyStepFunction;       // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;      // in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n    \r\n    struct RatesCompactData {\r\n        address token;\r\n        byte buy;\r\n        byte sell;\r\n    }\r\n    \r\n    struct TokenControlInfo {\r\n        address token;\r\n        uint minimalRecordResolution;\r\n        uint maxPerBlockImbalance;\r\n        uint maxTotalImbalance;\r\n    }\r\n    \r\n    struct TokenImbalanceData {\r\n        address token;\r\n        uint256[5] data;\r\n    }\r\n    \r\n    function getTokenImbalanceData(address conversionRateContract) external view returns (TokenImbalanceData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new TokenImbalanceData[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            data[i].token = tokens[i];\r\n            for (uint j = 0; j < 5; j++) {\r\n                data[i].data[j] = IConversionRate(conversionRateContract).tokenImbalanceData(tokens[i], j);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getTokenControlInfo(address conversionRateContract) external view returns (TokenControlInfo[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new TokenControlInfo[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n             (\r\n                 uint minimalRecordResolution,\r\n                 uint maxPerBlockImbalance,\r\n                 uint maxTotalImbalance\r\n             ) = IConversionRate(conversionRateContract).getTokenControlInfo(tokens[i]);\r\n            \r\n            data[i].token = tokens[i];\r\n            data[i].minimalRecordResolution = minimalRecordResolution;\r\n            data[i].maxPerBlockImbalance = maxPerBlockImbalance;\r\n            data[i].maxTotalImbalance = maxTotalImbalance;\r\n        }\r\n    }\r\n    \r\n    function getRatesCompactData(address conversionRateContract) external view returns (RatesCompactData[] memory data) {\r\n          address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n          data = new RatesCompactData[](tokens.length);\r\n          for (uint i = 0; i < tokens.length; i++) {\r\n              (,,byte buy, byte sell) = IConversionRate(conversionRateContract).getCompactData(tokens[i]);\r\n              \r\n              data[i].token = tokens[i];\r\n              data[i].buy = buy;\r\n              data[i].sell = sell;\r\n          }\r\n    }\r\n    \r\n    function getStepFunctionData(address conversionRateContract) external view returns (TokenData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        \r\n        data = new TokenData[](tokens.length);\r\n        \r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            \r\n            data[i].token = tokens[i];\r\n            \r\n            data[i].rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\r\n            \r\n            data[i].baseBuyRate = IConversionRate(conversionRateContract).getBasicRate(tokens[i], true);\r\n            data[i].baseSellRate = IConversionRate(conversionRateContract).getBasicRate(tokens[i], false);\r\n            \r\n            uint[8] memory stepFunctionLenList = [\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 0, 0)),  // buyRateQtyStepFunctionXLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 2, 0)),  // buyRateQtyStepFunctionYLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 4, 0)),  // sellRateQtyStepFunctionXLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 6, 0)),  // sellRateQtyStepFunctionYLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 8, 0)),  // buyRateImbalanceStepFunctionXLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 10, 0)), // buyRateImbalanceStepFunctionYLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 12, 0)), // sellRateImbalanceStepFunctionXLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 14, 0))  // sellRateImbalanceStepFunctionYLen\r\n            ]; \r\n            \r\n            data[i].buyRateQtyStepFunction = initStepFunction(stepFunctionLenList[0], stepFunctionLenList[1]);\r\n            data[i].sellRateQtyStepFunction = initStepFunction(stepFunctionLenList[2], stepFunctionLenList[3]);\r\n            data[i].buyRateImbalanceStepFunction = initStepFunction(stepFunctionLenList[4], stepFunctionLenList[5]);\r\n            data[i].sellRateImbalanceStepFunction = initStepFunction(stepFunctionLenList[6], stepFunctionLenList[7]);\r\n\r\n            for (uint j = 0; j < getMaxValue(stepFunctionLenList); j++) {\r\n              if (j < stepFunctionLenList[0]) {\r\n                data[i].buyRateQtyStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 1, j);\r\n              }\r\n              if (j < stepFunctionLenList[1]) {\r\n                data[i].buyRateQtyStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 3, j);\r\n              }\r\n              if (j < stepFunctionLenList[2]) {\r\n                data[i].sellRateQtyStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 5, j);\r\n              }\r\n              if (j < stepFunctionLenList[3]) {\r\n                data[i].sellRateQtyStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 7, j);\r\n              }\r\n              if (j < stepFunctionLenList[4]) {\r\n                data[i].buyRateImbalanceStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 9, j);\r\n              }\r\n              if (j < stepFunctionLenList[5]) {\r\n                data[i].buyRateImbalanceStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 11, j);\r\n              }\r\n              if (j < stepFunctionLenList[6]) {\r\n                data[i].sellRateImbalanceStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 13, j);\r\n              }\r\n              if (j < stepFunctionLenList[7]) {\r\n                data[i].sellRateImbalanceStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 15, j);\r\n              }  \r\n            }\r\n        }\r\n    }\r\n    \r\n    function getMaxValue(uint[8] memory values) private pure returns (uint) {\r\n        uint max; \r\n        for(uint i = 0; i < values.length; i++) {\r\n            if(values[i] > max) {\r\n                max = values[i]; \r\n            } \r\n        }\r\n        return max;\r\n    }\r\n    \r\n    function initStepFunction(uint xLen, uint yLen) private pure returns (StepFunction memory stepFunc) {\r\n        stepFunc.x = new int[](xLen);\r\n        stepFunc.y = new int[](yLen);\r\n    }\r\n    \r\n    function getStepFunctionData(address conversionRateContract, address token, uint256 command, uint256 param) private view returns (int) {\r\n        try IConversionRate(conversionRateContract).getStepFunctionData(token, command, param) returns (int len) {\r\n            return (len);\r\n        } catch {\r\n            return (0);\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getRatesCompactData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"buy\",\"type\":\"bytes1\"},{\"internalType\":\"bytes1\",\"name\":\"sell\",\"type\":\"bytes1\"}],\"internalType\":\"struct KyberHelper.RatesCompactData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getStepFunctionData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rateUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBuyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseSellRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"buyRateQtyStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"sellRateQtyStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"buyRateImbalanceStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"sellRateImbalanceStepFunction\",\"type\":\"tuple\"}],\"internalType\":\"struct KyberHelper.TokenData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getTokenControlInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimalRecordResolution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerBlockImbalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalImbalance\",\"type\":\"uint256\"}],\"internalType\":\"struct KyberHelper.TokenControlInfo[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getTokenImbalanceData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[5]\",\"name\":\"data\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct KyberHelper.TokenImbalanceData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KyberHelper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2b53b07bcec880015d6e0b6fa7987bb0ade0dd3f25f9873e750c0589e2e723c2"}]}