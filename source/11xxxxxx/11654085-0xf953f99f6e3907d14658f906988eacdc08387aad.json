{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../common/interfaces/IERC20Standard.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport '../../oracle/interfaces/OracleInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\nimport './PerpetualPositionManagerPoolParty.sol';\\nimport '../common/FeePayerPoolPartyLib.sol';\\n\\nlibrary PerpetualPositionManagerPoolPartyLib {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionManagerData;\\n  using PerpetualPositionManagerPoolPartyLib for FeePayerPoolParty.FeePayerData;\\n  using PerpetualPositionManagerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n\\n  event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\\n  event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\\n  event RequestWithdrawal(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalExecuted(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalCanceled(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event PositionCreated(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event NewSponsor(address indexed sponsor);\\n  event EndedSponsorPosition(address indexed sponsor);\\n  event Redeem(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event Repay(\\n    address indexed sponsor,\\n    uint256 indexed numTokensRepaid,\\n    uint256 indexed newTokenCount\\n  );\\n  event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\\n  event SettleEmergencyShutdown(\\n    address indexed caller,\\n    uint256 indexed collateralReturned,\\n    uint256 indexed tokensBurned\\n  );\\n\\n  function depositTo(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external {\\n    require(collateralAmount.isGreaterThan(0), 'Invalid collateral amount');\\n\\n    positionData._incrementCollateralBalances(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    emit Deposit(sponsor, collateralAmount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      collateralAmount.rawValue\\n    );\\n  }\\n\\n  function withdraw(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(collateralAmount.isGreaterThan(0), 'Invalid collateral amount');\\n\\n    amountWithdrawn = _decrementCollateralBalancesCheckGCR(\\n      positionData,\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n  }\\n\\n  function requestWithdrawal(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    uint256 actualTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    require(\\n      collateralAmount.isGreaterThan(0) &&\\n        collateralAmount.isLessThanOrEqual(\\n          positionData.rawCollateral.getFeeAdjustedCollateral(\\n            feePayerData.cumulativeFeeMultiplier\\n          )\\n        ),\\n      'Invalid collateral amount'\\n    );\\n\\n    positionData.withdrawalRequestPassTimestamp = actualTime.add(\\n      positionManagerData.withdrawalLiveness\\n    );\\n    positionData.withdrawalRequestAmount = collateralAmount;\\n\\n    emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\\n  }\\n\\n  function withdrawPassedRequest(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    uint256 actualTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(\\n      positionData.withdrawalRequestPassTimestamp != 0 &&\\n        positionData.withdrawalRequestPassTimestamp <= actualTime,\\n      'Invalid withdraw request'\\n    );\\n\\n    FixedPoint.Unsigned memory amountToWithdraw =\\n      positionData.withdrawalRequestAmount;\\n    if (\\n      positionData.withdrawalRequestAmount.isGreaterThan(\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      )\\n    ) {\\n      amountToWithdraw = positionData.rawCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n    }\\n\\n    amountWithdrawn = positionData._decrementCollateralBalances(\\n      globalPositionData,\\n      amountToWithdraw,\\n      feePayerData\\n    );\\n\\n    positionData._resetWithdrawalRequest();\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n\\n    emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\\n  }\\n\\n  function cancelWithdrawal(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData\\n  ) external {\\n    require(\\n      positionData.withdrawalRequestPassTimestamp != 0,\\n      'No pending withdrawal'\\n    );\\n\\n    emit RequestWithdrawalCanceled(\\n      msg.sender,\\n      positionData.withdrawalRequestAmount.rawValue\\n    );\\n\\n    _resetWithdrawalRequest(positionData);\\n  }\\n\\n  function create(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    require(\\n      (_checkCollateralization(\\n        globalPositionData,\\n        positionData\\n          .rawCollateral\\n          .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n          .add(collateralAmount),\\n        positionData.tokensOutstanding.add(numTokens),\\n        feePayerData\\n      ) ||\\n        _checkCollateralization(\\n          globalPositionData,\\n          collateralAmount,\\n          numTokens,\\n          feePayerData\\n        )),\\n      'Insufficient collateral'\\n    );\\n\\n    require(\\n      positionData.withdrawalRequestPassTimestamp == 0,\\n      'Pending withdrawal'\\n    );\\n    if (positionData.tokensOutstanding.isEqual(0)) {\\n      require(\\n        numTokens.isGreaterThanOrEqual(positionManagerData.minSponsorTokens),\\n        'Below minimum sponsor position'\\n      );\\n      emit NewSponsor(msg.sender);\\n    }\\n\\n    _incrementCollateralBalances(\\n      positionData,\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    positionData.tokensOutstanding = positionData.tokensOutstanding.add(\\n      numTokens\\n    );\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .add(numTokens);\\n\\n    emit PositionCreated(\\n      msg.sender,\\n      collateralAmount.rawValue,\\n      numTokens.rawValue\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      collateralAmount.rawValue\\n    );\\n    require(\\n      positionManagerData.tokenCurrency.mint(msg.sender, numTokens.rawValue),\\n      'Minting synthetic tokens failed'\\n    );\\n  }\\n\\n  function redeeem(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(\\n      numTokens.isLessThanOrEqual(positionData.tokensOutstanding),\\n      'Invalid token amount'\\n    );\\n\\n    FixedPoint.Unsigned memory fractionRedeemed =\\n      numTokens.div(positionData.tokensOutstanding);\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      fractionRedeemed.mul(\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n\\n    if (positionData.tokensOutstanding.isEqual(numTokens)) {\\n      amountWithdrawn = positionData._deleteSponsorPosition(\\n        globalPositionData,\\n        feePayerData,\\n        sponsor\\n      );\\n    } else {\\n      amountWithdrawn = positionData._decrementCollateralBalances(\\n        globalPositionData,\\n        collateralRedeemed,\\n        feePayerData\\n      );\\n\\n      FixedPoint.Unsigned memory newTokenCount =\\n        positionData.tokensOutstanding.sub(numTokens);\\n      require(\\n        newTokenCount.isGreaterThanOrEqual(\\n          positionManagerData.minSponsorTokens\\n        ),\\n        'Below minimum sponsor position'\\n      );\\n      positionData.tokensOutstanding = newTokenCount;\\n\\n      globalPositionData.totalTokensOutstanding = globalPositionData\\n        .totalTokensOutstanding\\n        .sub(numTokens);\\n    }\\n\\n    emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(numTokens.rawValue);\\n  }\\n\\n  function repay(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory numTokens\\n  ) external {\\n    require(\\n      numTokens.isLessThanOrEqual(positionData.tokensOutstanding),\\n      'Invalid token amount'\\n    );\\n\\n    FixedPoint.Unsigned memory newTokenCount =\\n      positionData.tokensOutstanding.sub(numTokens);\\n    require(\\n      newTokenCount.isGreaterThanOrEqual(positionManagerData.minSponsorTokens),\\n      'Below minimum sponsor position'\\n    );\\n    positionData.tokensOutstanding = newTokenCount;\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(numTokens);\\n\\n    emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\\n\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(numTokens.rawValue);\\n  }\\n\\n  function settleEmergencyShutdown(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    if (\\n      positionManagerData.emergencyShutdownPrice.isEqual(\\n        FixedPoint.fromUnscaledUint(0)\\n      )\\n    ) {\\n      FixedPoint.Unsigned memory oraclePrice =\\n        positionManagerData._getOracleEmergencyShutdownPrice(feePayerData);\\n      positionManagerData.emergencyShutdownPrice = oraclePrice\\n        ._decimalsScalingFactor(feePayerData);\\n    }\\n\\n    FixedPoint.Unsigned memory tokensToRedeem =\\n      FixedPoint.Unsigned(\\n        positionManagerData.tokenCurrency.balanceOf(msg.sender)\\n      );\\n\\n    FixedPoint.Unsigned memory totalRedeemableCollateral =\\n      tokensToRedeem.mul(positionManagerData.emergencyShutdownPrice);\\n\\n    if (\\n      positionData\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isGreaterThan(0)\\n    ) {\\n      FixedPoint.Unsigned memory tokenDebtValueInCollateral =\\n        positionData.tokensOutstanding.mul(\\n          positionManagerData.emergencyShutdownPrice\\n        );\\n      FixedPoint.Unsigned memory positionCollateral =\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        );\\n\\n      FixedPoint.Unsigned memory positionRedeemableCollateral =\\n        tokenDebtValueInCollateral.isLessThan(positionCollateral)\\n          ? positionCollateral.sub(tokenDebtValueInCollateral)\\n          : FixedPoint.Unsigned(0);\\n\\n      totalRedeemableCollateral = totalRedeemableCollateral.add(\\n        positionRedeemableCollateral\\n      );\\n\\n      PerpetualPositionManagerPoolParty(address(this)).deleteSponsorPosition(\\n        msg.sender\\n      );\\n      emit EndedSponsorPosition(msg.sender);\\n    }\\n\\n    FixedPoint.Unsigned memory payout =\\n      FixedPoint.min(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        totalRedeemableCollateral\\n      );\\n\\n    amountWithdrawn = globalPositionData\\n      .rawTotalPositionCollateral\\n      .removeCollateral(payout, feePayerData.cumulativeFeeMultiplier);\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(tokensToRedeem);\\n\\n    emit SettleEmergencyShutdown(\\n      msg.sender,\\n      amountWithdrawn.rawValue,\\n      tokensToRedeem.rawValue\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      tokensToRedeem.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(tokensToRedeem.rawValue);\\n  }\\n\\n  function trimExcess(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    IERC20 token,\\n    FixedPoint.Unsigned memory pfcAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amount) {\\n    FixedPoint.Unsigned memory balance =\\n      FixedPoint.Unsigned(token.balanceOf(address(this)));\\n    if (address(token) == address(feePayerData.collateralCurrency)) {\\n      amount = balance.sub(pfcAmount);\\n    } else {\\n      amount = balance;\\n    }\\n    token.safeTransfer(\\n      positionManagerData.excessTokenBeneficiary,\\n      amount.rawValue\\n    );\\n  }\\n\\n  function requestOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    feePayerData._getOracle().requestPrice(\\n      positionManagerData.priceIdentifier,\\n      requestedTime\\n    );\\n  }\\n\\n  function reduceSponsorPosition(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory tokensToRemove,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory withdrawalAmountToRemove,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external {\\n    if (\\n      tokensToRemove.isEqual(positionData.tokensOutstanding) &&\\n      positionData\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isEqual(collateralToRemove)\\n    ) {\\n      positionData._deleteSponsorPosition(\\n        globalPositionData,\\n        feePayerData,\\n        sponsor\\n      );\\n      return;\\n    }\\n\\n    positionData._decrementCollateralBalances(\\n      globalPositionData,\\n      collateralToRemove,\\n      feePayerData\\n    );\\n\\n    positionData.tokensOutstanding = positionData.tokensOutstanding.sub(\\n      tokensToRemove\\n    );\\n    require(\\n      positionData.tokensOutstanding.isGreaterThanOrEqual(\\n        positionManagerData.minSponsorTokens\\n      ),\\n      'Below minimum sponsor position'\\n    );\\n\\n    positionData.withdrawalRequestAmount = positionData\\n      .withdrawalRequestAmount\\n      .sub(withdrawalAmountToRemove);\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(tokensToRemove);\\n  }\\n\\n  function getOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external view returns (FixedPoint.Unsigned memory price) {\\n    return _getOraclePrice(positionManagerData, requestedTime, feePayerData);\\n  }\\n\\n  function decimalsScalingFactor(\\n    FixedPoint.Unsigned memory oraclePrice,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external view returns (FixedPoint.Unsigned memory scaledPrice) {\\n    return _decimalsScalingFactor(oraclePrice, feePayerData);\\n  }\\n\\n  function _incrementCollateralBalances(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData memory feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.addCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.addCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _decrementCollateralBalances(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.removeCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.removeCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _decrementCollateralBalancesCheckGCR(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.removeCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    require(\\n      _checkPositionCollateralization(\\n        positionData,\\n        globalPositionData,\\n        feePayerData\\n      ),\\n      'CR below GCR'\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.removeCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _checkPositionCollateralization(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (bool) {\\n    return\\n      _checkCollateralization(\\n        globalPositionData,\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        positionData.tokensOutstanding,\\n        feePayerData\\n      );\\n  }\\n\\n  function _checkCollateralization(\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (bool) {\\n    FixedPoint.Unsigned memory global =\\n      _getCollateralizationRatio(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        globalPositionData.totalTokensOutstanding\\n      );\\n    FixedPoint.Unsigned memory thisChange =\\n      _getCollateralizationRatio(collateral, numTokens);\\n    return !global.isGreaterThan(thisChange);\\n  }\\n\\n  function _getCollateralizationRatio(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal pure returns (FixedPoint.Unsigned memory ratio) {\\n    return\\n      numTokens.isLessThanOrEqual(0)\\n        ? FixedPoint.fromUnscaledUint(0)\\n        : collateral.div(numTokens);\\n  }\\n\\n  function _resetWithdrawalRequest(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData\\n  ) internal {\\n    positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\\n    positionData.withdrawalRequestPassTimestamp = 0;\\n  }\\n\\n  function _deleteSponsorPosition(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    FixedPoint.Unsigned memory startingGlobalCollateral =\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n    globalPositionData.rawTotalPositionCollateral = globalPositionData\\n      .rawTotalPositionCollateral\\n      .sub(positionToLiquidate.rawCollateral);\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(positionToLiquidate.tokensOutstanding);\\n\\n    PerpetualPositionManagerPoolParty(address(this)).deleteSponsorPosition(\\n      sponsor\\n    );\\n\\n    emit EndedSponsorPosition(sponsor);\\n\\n    return\\n      startingGlobalCollateral.sub(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n  }\\n\\n  function _getOracleEmergencyShutdownPrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory) {\\n    return\\n      positionManagerData._getOraclePrice(\\n        positionManagerData.emergencyShutdownTimestamp,\\n        feePayerData\\n      );\\n  }\\n\\n  function _getOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory price) {\\n    OracleInterface oracle = feePayerData._getOracle();\\n    require(\\n      oracle.hasPrice(positionManagerData.priceIdentifier, requestedTime),\\n      'Unresolved oracle price'\\n    );\\n    int256 oraclePrice =\\n      oracle.getPrice(positionManagerData.priceIdentifier, requestedTime);\\n\\n    if (oraclePrice < 0) {\\n      oraclePrice = 0;\\n    }\\n    return FixedPoint.Unsigned(uint256(oraclePrice));\\n  }\\n\\n  function _getOracle(FeePayerPoolParty.FeePayerData storage feePayerData)\\n    internal\\n    view\\n    returns (OracleInterface)\\n  {\\n    return\\n      OracleInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Oracle)\\n      );\\n  }\\n\\n  function _decimalsScalingFactor(\\n    FixedPoint.Unsigned memory oraclePrice,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory scaledPrice) {\\n    uint8 collateralDecimalsNumber =\\n      IERC20Standard(address(feePayerData.collateralCurrency)).decimals();\\n    scaledPrice = oraclePrice.div(\\n      (10**(uint256(18)).sub(collateralDecimalsNumber))\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\nimport '../../utils/Address.sol';\\n\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance =\\n      token.allowance(address(this), spender).sub(\\n        value,\\n        'SafeERC20: decreased allowance below zero'\\n      );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata =\\n      address(token).functionCall(data, 'SafeERC20: low-level call failed');\\n    if (returndata.length > 0) {\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/IERC20Standard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IERC20Standard is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SignedSafeMath.sol';\\n\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  function mul(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function mulCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  function mulCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function div(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  function div(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  function divCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  function divCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  function pow(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory output)\\n  {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, 'Negative value provided');\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    require(a.rawValue <= uint256(type(int256).max), 'Unsigned too large');\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThan(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  function mul(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function div(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  function div(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  function divAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  function divAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  function pow(Signed memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Signed memory output)\\n  {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/MintableBurnableIERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\nabstract contract MintableBurnableIERC20 is ERC20 {\\n  function burn(uint256 value) external virtual;\\n\\n  function mint(address to, uint256 value) external virtual returns (bool);\\n\\n  function addMinter(address account) external virtual;\\n\\n  function addBurner(address account) external virtual;\\n\\n  function addAdmin(address account) external virtual;\\n\\n  function addAdminAndMinterAndBurner(address account) external virtual;\\n\\n  function renounceMinter() external virtual;\\n\\n  function renounceBurner() external virtual;\\n\\n  function renounceAdmin() external virtual;\\n\\n  function renounceAdminAndMinterAndBurner() external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nabstract contract OracleInterface {\\n  function requestPrice(bytes32 identifier, uint256 time) public virtual;\\n\\n  function hasPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    virtual\\n    returns (bool);\\n\\n  function getPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    virtual\\n    returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nlibrary OracleInterfaces {\\n  bytes32 public constant Oracle = 'Oracle';\\n  bytes32 public constant IdentifierWhitelist = 'IdentifierWhitelist';\\n  bytes32 public constant Store = 'Store';\\n  bytes32 public constant FinancialContractsAdmin = 'FinancialContractsAdmin';\\n  bytes32 public constant Registry = 'Registry';\\n  bytes32 public constant CollateralWhitelist = 'CollateralWhitelist';\\n  bytes32 public constant OptimisticOracle = 'OptimisticOracle';\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\n\\nimport '../../oracle/interfaces/OracleInterface.sol';\\nimport '../../oracle/interfaces/IdentifierWhitelistInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nimport '../common/FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract PerpetualPositionManagerPoolParty is AccessControl, FeePayerPoolParty {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using PerpetualPositionManagerPoolPartyLib for PositionData;\\n  using PerpetualPositionManagerPoolPartyLib for PositionManagerData;\\n\\n  bytes32 public constant POOL_ROLE = keccak256('Pool');\\n\\n  struct Roles {\\n    address[] admins;\\n    address[] pools;\\n  }\\n\\n  struct PositionManagerParams {\\n    uint256 withdrawalLiveness;\\n    address collateralAddress;\\n    address tokenAddress;\\n    address finderAddress;\\n    bytes32 priceFeedIdentifier;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    address timerAddress;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  struct PositionData {\\n    FixedPoint.Unsigned tokensOutstanding;\\n    uint256 withdrawalRequestPassTimestamp;\\n    FixedPoint.Unsigned withdrawalRequestAmount;\\n    FixedPoint.Unsigned rawCollateral;\\n  }\\n\\n  struct GlobalPositionData {\\n    FixedPoint.Unsigned totalTokensOutstanding;\\n    FixedPoint.Unsigned rawTotalPositionCollateral;\\n  }\\n\\n  struct PositionManagerData {\\n    MintableBurnableIERC20 tokenCurrency;\\n    bytes32 priceIdentifier;\\n    uint256 withdrawalLiveness;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    FixedPoint.Unsigned emergencyShutdownPrice;\\n    uint256 emergencyShutdownTimestamp;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  mapping(address => PositionData) public positions;\\n\\n  GlobalPositionData public globalPositionData;\\n\\n  PositionManagerData public positionManagerData;\\n\\n  event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\\n  event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\\n  event RequestWithdrawal(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalExecuted(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalCanceled(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event PositionCreated(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event NewSponsor(address indexed sponsor);\\n  event EndedSponsorPosition(address indexed sponsor);\\n  event Redeem(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event Repay(\\n    address indexed sponsor,\\n    uint256 indexed numTokensRepaid,\\n    uint256 indexed newTokenCount\\n  );\\n  event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\\n  event SettleEmergencyShutdown(\\n    address indexed caller,\\n    uint256 indexed collateralReturned,\\n    uint256 indexed tokensBurned\\n  );\\n\\n  modifier onlyPool() {\\n    require(hasRole(POOL_ROLE, msg.sender), 'Sender must be a pool');\\n    _;\\n  }\\n\\n  modifier onlyCollateralizedPosition(address sponsor) {\\n    _onlyCollateralizedPosition(sponsor);\\n    _;\\n  }\\n\\n  modifier notEmergencyShutdown() {\\n    _notEmergencyShutdown();\\n    _;\\n  }\\n\\n  modifier isEmergencyShutdown() {\\n    _isEmergencyShutdown();\\n    _;\\n  }\\n\\n  modifier noPendingWithdrawal(address sponsor) {\\n    _positionHasNoPendingWithdrawal(sponsor);\\n    _;\\n  }\\n\\n  constructor(\\n    PositionManagerParams memory _positionManagerData,\\n    Roles memory _roles\\n  )\\n    public\\n    FeePayerPoolParty(\\n      _positionManagerData.collateralAddress,\\n      _positionManagerData.finderAddress,\\n      _positionManagerData.timerAddress\\n    )\\n    nonReentrant()\\n  {\\n    require(\\n      _getIdentifierWhitelist().isIdentifierSupported(\\n        _positionManagerData.priceFeedIdentifier\\n      ),\\n      'Unsupported price identifier'\\n    );\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(POOL_ROLE, DEFAULT_ADMIN_ROLE);\\n    for (uint256 j = 0; j < _roles.admins.length; j++) {\\n      _setupRole(DEFAULT_ADMIN_ROLE, _roles.admins[j]);\\n    }\\n    for (uint256 j = 0; j < _roles.pools.length; j++) {\\n      _setupRole(POOL_ROLE, _roles.pools[j]);\\n    }\\n    positionManagerData.withdrawalLiveness = _positionManagerData\\n      .withdrawalLiveness;\\n    positionManagerData.tokenCurrency = MintableBurnableIERC20(\\n      _positionManagerData.tokenAddress\\n    );\\n    positionManagerData.minSponsorTokens = _positionManagerData\\n      .minSponsorTokens;\\n    positionManagerData.priceIdentifier = _positionManagerData\\n      .priceFeedIdentifier;\\n    positionManagerData.excessTokenBeneficiary = _positionManagerData\\n      .excessTokenBeneficiary;\\n  }\\n\\n  function depositTo(\\n    address sponsor,\\n    FixedPoint.Unsigned memory collateralAmount\\n  )\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(sponsor)\\n    fees()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(sponsor);\\n\\n    positionData.depositTo(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData,\\n      sponsor\\n    );\\n  }\\n\\n  function deposit(FixedPoint.Unsigned memory collateralAmount) public {\\n    depositTo(msg.sender, collateralAmount);\\n  }\\n\\n  function withdraw(FixedPoint.Unsigned memory collateralAmount)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n\\n    amountWithdrawn = positionData.withdraw(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n  }\\n\\n  function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    nonReentrant()\\n  {\\n    uint256 actualTime = getCurrentTime();\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.requestWithdrawal(\\n      positionManagerData,\\n      collateralAmount,\\n      actualTime,\\n      feePayerData\\n    );\\n  }\\n\\n  function withdrawPassedRequest()\\n    external\\n    onlyPool()\\n    notEmergencyShutdown()\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    uint256 actualTime = getCurrentTime();\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    amountWithdrawn = positionData.withdrawPassedRequest(\\n      globalPositionData,\\n      actualTime,\\n      feePayerData\\n    );\\n  }\\n\\n  function cancelWithdrawal()\\n    external\\n    onlyPool()\\n    notEmergencyShutdown()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.cancelWithdrawal();\\n  }\\n\\n  function create(\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) public onlyPool() notEmergencyShutdown() fees() nonReentrant() {\\n    PositionData storage positionData = positions[msg.sender];\\n\\n    positionData.create(\\n      globalPositionData,\\n      positionManagerData,\\n      collateralAmount,\\n      numTokens,\\n      feePayerData\\n    );\\n  }\\n\\n  function redeem(FixedPoint.Unsigned memory numTokens)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n\\n    amountWithdrawn = positionData.redeeem(\\n      globalPositionData,\\n      positionManagerData,\\n      numTokens,\\n      feePayerData,\\n      msg.sender\\n    );\\n  }\\n\\n  function repay(FixedPoint.Unsigned memory numTokens)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.repay(globalPositionData, positionManagerData, numTokens);\\n  }\\n\\n  function settleEmergencyShutdown()\\n    external\\n    onlyPool()\\n    isEmergencyShutdown()\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = positions[msg.sender];\\n    amountWithdrawn = positionData.settleEmergencyShutdown(\\n      globalPositionData,\\n      positionManagerData,\\n      feePayerData\\n    );\\n  }\\n\\n  function emergencyShutdown()\\n    external\\n    override\\n    notEmergencyShutdown()\\n    nonReentrant()\\n  {\\n    require(\\n      hasRole(POOL_ROLE, msg.sender) ||\\n        msg.sender == _getFinancialContractsAdminAddress(),\\n      'Caller must be a pool or the UMA governor'\\n    );\\n    positionManagerData.emergencyShutdownTimestamp = getCurrentTime();\\n    positionManagerData.requestOraclePrice(\\n      positionManagerData.emergencyShutdownTimestamp,\\n      feePayerData\\n    );\\n    emit EmergencyShutdown(\\n      msg.sender,\\n      positionManagerData.emergencyShutdownTimestamp\\n    );\\n  }\\n\\n  function remargin() external override {\\n    return;\\n  }\\n\\n  function trimExcess(IERC20 token)\\n    external\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amount)\\n  {\\n    FixedPoint.Unsigned memory pfcAmount = _pfc();\\n    amount = positionManagerData.trimExcess(token, pfcAmount, feePayerData);\\n  }\\n\\n  function deleteSponsorPosition(address sponsor) external onlyThisContract {\\n    delete positions[sponsor];\\n  }\\n\\n  function addPool(address pool) external {\\n    grantRole(POOL_ROLE, pool);\\n  }\\n\\n  function addAdmin(address admin) external {\\n    grantRole(DEFAULT_ADMIN_ROLE, admin);\\n  }\\n\\n  function addAdminAndPool(address adminAndPool) external {\\n    grantRole(DEFAULT_ADMIN_ROLE, adminAndPool);\\n    grantRole(POOL_ROLE, adminAndPool);\\n  }\\n\\n  function renouncePool() external {\\n    renounceRole(POOL_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdmin() external {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdminAndPool() external {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    renounceRole(POOL_ROLE, msg.sender);\\n  }\\n\\n  function addSyntheticTokenMinter(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addMinter(derivative);\\n  }\\n\\n  function addSyntheticTokenBurner(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addBurner(derivative);\\n  }\\n\\n  function addSyntheticTokenAdmin(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addAdmin(derivative);\\n  }\\n\\n  function addSyntheticTokenAdminAndMinterAndBurner(address derivative)\\n    external\\n    onlyPool()\\n  {\\n    positionManagerData.tokenCurrency.addAdminAndMinterAndBurner(derivative);\\n  }\\n\\n  function renounceSyntheticTokenMinter() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceMinter();\\n  }\\n\\n  function renounceSyntheticTokenBurner() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceBurner();\\n  }\\n\\n  function renounceSyntheticTokenAdmin() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceAdmin();\\n  }\\n\\n  function renounceSyntheticTokenAdminAndMinterAndBurner() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceAdminAndMinterAndBurner();\\n  }\\n\\n  function getCollateral(address sponsor)\\n    external\\n    view\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory collateralAmount)\\n  {\\n    return\\n      positions[sponsor].rawCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function tokenCurrency() external view nonReentrantView() returns (IERC20) {\\n    return positionManagerData.tokenCurrency;\\n  }\\n\\n  function totalPositionCollateral()\\n    external\\n    view\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory totalCollateral)\\n  {\\n    return\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function emergencyShutdownPrice()\\n    external\\n    view\\n    isEmergencyShutdown()\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return positionManagerData.emergencyShutdownPrice;\\n  }\\n\\n  function getAdminMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(DEFAULT_ADMIN_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(DEFAULT_ADMIN_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function getPoolMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(POOL_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(POOL_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function _pfc()\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _getPositionData(address sponsor)\\n    internal\\n    view\\n    onlyCollateralizedPosition(sponsor)\\n    returns (PositionData storage)\\n  {\\n    return positions[sponsor];\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    internal\\n    view\\n    returns (IdentifierWhitelistInterface)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        feePayerData.finder.getImplementationAddress(\\n          OracleInterfaces.IdentifierWhitelist\\n        )\\n      );\\n  }\\n\\n  function _onlyCollateralizedPosition(address sponsor) internal view {\\n    require(\\n      positions[sponsor]\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isGreaterThan(0),\\n      'Position has no collateral'\\n    );\\n  }\\n\\n  function _notEmergencyShutdown() internal view {\\n    require(\\n      positionManagerData.emergencyShutdownTimestamp == 0,\\n      'Contract emergency shutdown'\\n    );\\n  }\\n\\n  function _isEmergencyShutdown() internal view {\\n    require(\\n      positionManagerData.emergencyShutdownTimestamp != 0,\\n      'Contract not emergency shutdown'\\n    );\\n  }\\n\\n  function _positionHasNoPendingWithdrawal(address sponsor) internal view {\\n    require(\\n      _getPositionData(sponsor).withdrawalRequestPassTimestamp == 0,\\n      'Pending withdrawal'\\n    );\\n  }\\n\\n  function _getFinancialContractsAdminAddress()\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return\\n      feePayerData.finder.getImplementationAddress(\\n        OracleInterfaces.FinancialContractsAdmin\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../oracle/interfaces/StoreInterface.sol';\\n\\nlibrary FeePayerPoolPartyLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  function payRegularFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    uint256 time,\\n    FixedPoint.Unsigned memory collateralPool\\n  ) external returns (FixedPoint.Unsigned memory totalPaid) {\\n    if (collateralPool.isEqual(0)) {\\n      feePayerData.lastPaymentTime = time;\\n      return totalPaid;\\n    }\\n\\n    if (feePayerData.lastPaymentTime == time) {\\n      return totalPaid;\\n    }\\n\\n    FixedPoint.Unsigned memory regularFee;\\n    FixedPoint.Unsigned memory latePenalty;\\n\\n    (regularFee, latePenalty) = store.computeRegularFee(\\n      feePayerData.lastPaymentTime,\\n      time,\\n      collateralPool\\n    );\\n    feePayerData.lastPaymentTime = time;\\n\\n    totalPaid = regularFee.add(latePenalty);\\n    if (totalPaid.isEqual(0)) {\\n      return totalPaid;\\n    }\\n\\n    if (totalPaid.isGreaterThan(collateralPool)) {\\n      FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\\n      FixedPoint.Unsigned memory latePenaltyReduction =\\n        FixedPoint.min(latePenalty, deficit);\\n      latePenalty = latePenalty.sub(latePenaltyReduction);\\n      deficit = deficit.sub(latePenaltyReduction);\\n      regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\\n      totalPaid = collateralPool;\\n    }\\n\\n    emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\\n\\n    feePayerData.cumulativeFeeMultiplier._adjustCumulativeFeeMultiplier(\\n      totalPaid,\\n      collateralPool\\n    );\\n\\n    if (regularFee.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeIncreaseAllowance(\\n        address(store),\\n        regularFee.rawValue\\n      );\\n      store.payOracleFeesErc20(\\n        address(feePayerData.collateralCurrency),\\n        regularFee\\n      );\\n    }\\n\\n    if (latePenalty.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeTransfer(\\n        msg.sender,\\n        latePenalty.rawValue\\n      );\\n    }\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    address payer,\\n    FixedPoint.Unsigned memory amount\\n  ) external {\\n    if (amount.isEqual(0)) {\\n      return;\\n    }\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      payer,\\n      address(this),\\n      amount.rawValue\\n    );\\n\\n    emit FinalFeesPaid(amount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeIncreaseAllowance(\\n      address(store),\\n      amount.rawValue\\n    );\\n    store.payOracleFeesErc20(address(feePayerData.collateralCurrency), amount);\\n  }\\n\\n  function getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral._convertToRawCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function removeCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory removedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToRemove._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\\n    removedCollateral = initialBalance.sub(\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n    );\\n  }\\n\\n  function addCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToAdd,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory addedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToAdd._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\\n    addedCollateral = rawCollateral\\n      ._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n      .sub(initialBalance);\\n  }\\n\\n  function _adjustCumulativeFeeMultiplier(\\n    FixedPoint.Unsigned storage cumulativeFeeMultiplier,\\n    FixedPoint.Unsigned memory amount,\\n    FixedPoint.Unsigned memory currentPfc\\n  ) internal {\\n    FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\\n    cumulativeFeeMultiplier.rawValue = cumulativeFeeMultiplier\\n      .mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee))\\n      .rawValue;\\n  }\\n\\n  function _getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral.mul(cumulativeFeeMultiplier);\\n  }\\n\\n  function _convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral.div(cumulativeFeeMultiplier);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SignedSafeMath {\\n  int256 private constant _INT256_MIN = -2**255;\\n\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      !(a == -1 && b == _INT256_MIN),\\n      'SignedSafeMath: multiplication overflow'\\n    );\\n\\n    int256 c = a * b;\\n    require(c / a == b, 'SignedSafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, 'SignedSafeMath: division by zero');\\n    require(\\n      !(b == -1 && a == _INT256_MIN),\\n      'SignedSafeMath: division overflow'\\n    );\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require(\\n      (b >= 0 && c <= a) || (b < 0 && c > a),\\n      'SignedSafeMath: subtraction overflow'\\n    );\\n\\n    return c;\\n  }\\n\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require(\\n      (b >= 0 && c >= a) || (b < 0 && c < a),\\n      'SignedSafeMath: addition overflow'\\n    );\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../../GSN/Context.sol';\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\n\\ncontract ERC20 is Context, IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string memory name_, string memory symbol_) public {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = 18;\\n  }\\n\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(\\n        amount,\\n        'ERC20: transfer amount exceeds allowance'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].add(addedValue)\\n    );\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(\\n        subtractedValue,\\n        'ERC20: decreased allowance below zero'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    _beforeTokenTransfer(sender, recipient, amount);\\n\\n    _balances[sender] = _balances[sender].sub(\\n      amount,\\n      'ERC20: transfer amount exceeds balance'\\n    );\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    _balances[account] = _balances[account].sub(\\n      amount,\\n      'ERC20: burn amount exceeds balance'\\n    );\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    require(owner != address(0), 'ERC20: approve from the zero address');\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IdentifierWhitelistInterface {\\n  function addSupportedIdentifier(bytes32 identifier) external;\\n\\n  function removeSupportedIdentifier(bytes32 identifier) external;\\n\\n  function isIdentifierSupported(bytes32 identifier)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/AdministrateeInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface AdministrateeInterface {\\n  function emergencyShutdown() external;\\n\\n  function remargin() external;\\n\\n  function pfc() external view returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/Lockable.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolPartyLib.sol';\\nimport '../../common/implementation/Testable.sol';\\n\\nimport '../../oracle/interfaces/StoreInterface.sol';\\nimport '../../oracle/interfaces/FinderInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nabstract contract FeePayerPoolParty is\\n  AdministrateeInterface,\\n  Testable,\\n  Lockable\\n{\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FeePayerData;\\n  using SafeERC20 for IERC20;\\n\\n  struct FeePayerData {\\n    IERC20 collateralCurrency;\\n    FinderInterface finder;\\n    uint256 lastPaymentTime;\\n    FixedPoint.Unsigned cumulativeFeeMultiplier;\\n  }\\n\\n  FeePayerData public feePayerData;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  modifier fees {\\n    payRegularFees();\\n    _;\\n  }\\n  modifier onlyThisContract {\\n    require(msg.sender == address(this), 'Caller is not this contract');\\n    _;\\n  }\\n\\n  constructor(\\n    address _collateralAddress,\\n    address _finderAddress,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    feePayerData.collateralCurrency = IERC20(_collateralAddress);\\n    feePayerData.finder = FinderInterface(_finderAddress);\\n    feePayerData.lastPaymentTime = getCurrentTime();\\n    feePayerData.cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\\n  }\\n\\n  function payRegularFees()\\n    public\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory totalPaid)\\n  {\\n    StoreInterface store = _getStore();\\n    uint256 time = getCurrentTime();\\n    FixedPoint.Unsigned memory collateralPool = _pfc();\\n    totalPaid = feePayerData.payRegularFees(store, time, collateralPool);\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    external\\n    onlyThisContract\\n  {\\n    _payFinalFees(payer, amount);\\n  }\\n\\n  function pfc()\\n    public\\n    view\\n    override\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return _pfc();\\n  }\\n\\n  function collateralCurrency()\\n    public\\n    view\\n    nonReentrantView()\\n    returns (IERC20)\\n  {\\n    return feePayerData.collateralCurrency;\\n  }\\n\\n  function _payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    internal\\n  {\\n    StoreInterface store = _getStore();\\n    feePayerData.payFinalFees(store, payer, amount);\\n  }\\n\\n  function _pfc() internal view virtual returns (FixedPoint.Unsigned memory);\\n\\n  function _getStore() internal view returns (StoreInterface) {\\n    return\\n      StoreInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Store)\\n      );\\n  }\\n\\n  function _computeFinalFees()\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory finalFees)\\n  {\\n    StoreInterface store = _getStore();\\n    return store.computeFinalFee(address(feePayerData.collateralCurrency));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../GSN/Context.sol';\\n\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/StoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface StoreInterface {\\n  function payOracleFees() external payable;\\n\\n  function payOracleFeesErc20(\\n    address erc20Address,\\n    FixedPoint.Unsigned calldata amount\\n  ) external;\\n\\n  function computeRegularFee(\\n    uint256 startTime,\\n    uint256 endTime,\\n    FixedPoint.Unsigned calldata pfc\\n  )\\n    external\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory regularFee,\\n      FixedPoint.Unsigned memory latePenalty\\n    );\\n\\n  function computeFinalFee(address currency)\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Lockable {\\n  bool private _notEntered;\\n\\n  constructor() internal {\\n    _notEntered = true;\\n  }\\n\\n  modifier nonReentrant() {\\n    _preEntranceCheck();\\n    _preEntranceSet();\\n    _;\\n    _postEntranceReset();\\n  }\\n\\n  modifier nonReentrantView() {\\n    _preEntranceCheck();\\n    _;\\n  }\\n\\n  function _preEntranceCheck() internal view {\\n    require(_notEntered, 'ReentrancyGuard: reentrant call');\\n  }\\n\\n  function _preEntranceSet() internal {\\n    _notEntered = false;\\n  }\\n\\n  function _postEntranceReset() internal {\\n    _notEntered = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport './Timer.sol';\\n\\nabstract contract Testable {\\n  address public timerAddress;\\n\\n  constructor(address _timerAddress) internal {\\n    timerAddress = _timerAddress;\\n  }\\n\\n  modifier onlyIfTest {\\n    require(timerAddress != address(0x0));\\n    _;\\n  }\\n\\n  function setCurrentTime(uint256 time) external onlyIfTest {\\n    Timer(timerAddress).setCurrentTime(time);\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    if (timerAddress != address(0x0)) {\\n      return Timer(timerAddress).getCurrentTime();\\n    } else {\\n      return now;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ninterface FinderInterface {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Timer {\\n  uint256 private currentTime;\\n\\n  constructor() public {\\n    currentTime = now;\\n  }\\n\\n  function setCurrentTime(uint256 time) external {\\n    currentTime = time;\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    return currentTime;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolPartyLib.sol\": {\r\n        \"FeePayerPoolPartyLib\": \"0xb0d0a057060c266b76b110c762471c91a80ed292\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shutdownTimestamp\",\"type\":\"uint256\"}],\"name\":\"EmergencyShutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"EndedSponsorPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"NewSponsor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"PositionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"numTokensRepaid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTokenCount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdrawalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdrawalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralReturned\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"}],\"name\":\"SettleEmergencyShutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"PerpetualPositionManagerPoolPartyLib","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}