{"status":"1","message":"OK","result":[{"SourceCode":"{\"Teazers.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity 0.6.11;\\n\\nimport \\u0027./TeazersBase.sol\\u0027;\\n\\ncontract Teazers is TeazersBase {\\n    constructor(address _addr) public {\\n        owner = msg.sender;\\n\\n        reentry_status = ENTRY_ENABLED;\\n\\n        levelCost[1] = 0.003 ether;\\n        for (uint8 i = 2; i \\u003c= TOP_LEVEL; i++) {\\n            levelCost[i] = levelCost[i - 1] * 2;\\n        }\\n\\n        createAccount(_addr, _addr, true);\\n\\n        for (uint8 j = 1; j \\u003c= TOP_LEVEL; j++) {\\n            handlePositionX3(_addr, _addr, _addr, j, true);\\n            handlePositionX4(_addr, _addr, _addr, j, true);\\n        }\\n    }\\n}\\n\"},\"TeazersBase.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./TeazersStorage.sol\\\";\\nimport \\\"./TeazersEvents.sol\\\";\\n\\ncontract TeazersBase is TeazersStorage, TeazersEvents {\\n    function registration(address _referrer) external payable blockReEntry() {\\n        preRegistration(msg.sender, _referrer);\\n    }\\n\\n    function preRegistration(address _addr, address _referrer) internal {\\n        require((levelCost[1]) == msg.value, \\\"Require .003 eth to register!\\\");\\n\\n        createAccount(_addr, _referrer, false);\\n\\n        users[_referrer].directSales++;\\n\\n        handlePositionX3(_addr, _referrer, _referrer, 1, false);\\n        handlePositionX4(_addr, _referrer, _referrer, 1, false);\\n\\n        handlePayout(_addr, 0, 1);\\n        handlePayout(_addr, 1, 1);\\n    }\\n\\n    function createAccount(\\n        address _addr,\\n        address _referrer,\\n        bool _initial\\n    ) internal {\\n        require(!users[_addr].exists, \\\"Already a member!\\\");\\n\\n        if (!_initial) {\\n            require(users[_referrer].exists, \\\"referrer dont exist!\\\");\\n        }\\n\\n        lastId++;\\n\\n        users[_addr] = Account({\\n            id: lastId,\\n            referrer: _referrer,\\n            exists: true,\\n            directSales: 0,\\n            activeLevel: new uint8[](2)\\n        });\\n         \\n        idToAddress[lastId] = _addr;\\n\\n        emit Registration(_addr, lastId, _referrer);\\n    }\\n\\n    function purchaseLevel(uint8 _matrix, uint8 _level)\\n        external\\n        payable\\n        isMember(msg.sender)\\n        blockReEntry()\\n    {\\n        require((_matrix == 1 || _matrix == 2), \\\"Invalid matrix identifier.\\\");\\n        require((_level \\u003e 0 \\u0026\\u0026 _level \\u003c= TOP_LEVEL), \\\"Invalid matrix level.\\\");\\n\\n        uint8 activeLevel = users[msg.sender].activeLevel[(_matrix - 1)];\\n\\n        require((activeLevel \\u003c _level), \\\"Already active at level!\\\");\\n        require((activeLevel == (_level - 1)), \\\"Level upgrade req. in order!\\\");\\n        require((msg.value == levelCost[_level]), \\\"Wrong amount transferred.\\\");\\n\\n        address referrer = users[msg.sender].referrer;\\n\\n        emit Upgrade(msg.sender, referrer, _matrix, _level);\\n\\n        if (_matrix == 1) {\\n            handlePositionX3(\\n                msg.sender,\\n                referrer,\\n                findActiveReferrer(msg.sender, referrer, 0, _level, true),\\n                _level,\\n                false\\n            );\\n        } else {\\n            handlePositionX4(\\n                msg.sender,\\n                referrer,\\n                findActiveReferrer(msg.sender, referrer, 1, _level, true),\\n                _level,\\n                false\\n            );\\n        }\\n\\n        handlePayout(msg.sender, (_matrix - 1), _level);\\n    }\\n\\n    function handlePositionX3(\\n        address _addr,\\n        address _mainReferrer,\\n        address _referrer,\\n        uint8 _level,\\n        bool _initial\\n    ) internal {\\n        Account storage member = users[_addr];\\n\\n        member.activeLevel[0] = _level;\\n        member.x3Positions[_level] = X3({\\n            referrer: _referrer,\\n            placement: 0,\\n            directSales: 0,\\n            cycles: 0,\\n            passup: 0,\\n            reEntryCheck: 0\\n        });\\n\\n        if (_initial) {\\n            return;\\n        } else if (_mainReferrer == _referrer) {\\n            users[_mainReferrer].x3Positions[_level].directSales++;\\n        } else {\\n            member.x3Positions[_level].reEntryCheck = 1;\\n        }\\n\\n        referrerPlaceX3(_addr, _referrer, _level, false);\\n    }\\n\\n    function referrerPlaceX3(\\n        address _addr,\\n        address _referrer,\\n        uint8 _level,\\n        bool passup\\n    ) internal {\\n        X3 storage position = users[_referrer].x3Positions[_level];\\n\\n        emit PlacementX3(\\n            _addr,\\n            _referrer,\\n            _level,\\n            (position.placement + 1),\\n            passup\\n        );\\n\\n        if (position.placement \\u003e= 2) {\\n            emit Cycle(_referrer, _addr, 1, _level);\\n\\n            position.placement = 0;\\n            position.cycles++;\\n\\n            if (_referrer != idToAddress[1]) {\\n                position.passup++;\\n\\n                referrerPlaceX3(_referrer, position.referrer, _level, true);\\n            }\\n        } else {\\n            position.placement++;\\n        }\\n    }\\n\\n    function handlePositionX4(\\n        address _addr,\\n        address _mainReferrer,\\n        address _referrer,\\n        uint8 _level,\\n        bool _initial\\n    ) internal {\\n        Account storage member = users[_addr];\\n\\n        member.activeLevel[1] = _level;\\n        member.x4Positions[_level] = X4({\\n            referrer: _referrer,\\n            directSales: 0,\\n            cycles: 0,\\n            passup: 0,\\n            cycle: 0,\\n            reEntryCheck: 0,\\n            placementSide: 0,\\n            placedUnder: _referrer,\\n            placementFirstLevel: new address[](0),\\n            placementLastLevel: 0\\n        });\\n\\n        if (_initial) {\\n            return;\\n        } else if (_mainReferrer == _referrer) {\\n            users[_mainReferrer].x4Positions[_level].directSales++;\\n        } else {\\n            member.x4Positions[_level].reEntryCheck = 1;\\n        }\\n\\n        referrerPlaceX4(_addr, _referrer, _level, false);\\n    }\\n\\n    function referrerPlaceX4(\\n        address _addr,\\n        address _referrer,\\n        uint8 _level,\\n        bool passup\\n    ) internal {\\n        X4 storage member = users[_addr].x4Positions[_level];\\n        X4 storage position = users[_referrer].x4Positions[_level];\\n\\n        if (position.placementFirstLevel.length \\u003c 2) {\\n            if (position.placementFirstLevel.length == 0) {\\n                member.placementSide = 1;\\n            } else {\\n                member.placementSide = 2;\\n            }\\n\\n            member.placedUnder = _referrer;\\n            position.placementFirstLevel.push(_addr);\\n\\n            if (_referrer != idToAddress[1]) {\\n                position.passup++;\\n            }\\n\\n            positionPlaceLastLevelX4(\\n                _addr,\\n                _referrer,\\n                position.placedUnder,\\n                position.placementSide,\\n                _level\\n            );\\n        } else {\\n            if (position.placementLastLevel == 0) {\\n                member.placementSide = 1;\\n                member.placedUnder = position.placementFirstLevel[0];\\n                position.placementLastLevel += 1;\\n            } else if ((position.placementLastLevel \\u0026 2) == 0) {\\n                member.placementSide = 2;\\n                member.placedUnder = position.placementFirstLevel[0];\\n                position.placementLastLevel += 2;\\n            } else if ((position.placementLastLevel \\u0026 4) == 0) {\\n                member.placementSide = 1;\\n                member.placedUnder = position.placementFirstLevel[1];\\n                position.placementLastLevel += 4;\\n            } else {\\n                member.placementSide = 2;\\n                member.placedUnder = position.placementFirstLevel[1];\\n                position.placementLastLevel += 8;\\n            }\\n\\n            if (member.placedUnder != idToAddress[1]) {\\n                users[member.placedUnder].x4Positions[_level]\\n                    .placementFirstLevel\\n                    .push(_addr);\\n            }\\n        }\\n\\n        if ((position.placementLastLevel \\u0026 15) == 15) {\\n            emit Cycle(_referrer, _addr, 2, _level);\\n\\n            position.placementFirstLevel = new address[](0);\\n            position.placementLastLevel = 0;\\n            position.cycles++;\\n\\n            if (_referrer != idToAddress[1]) {\\n                position.cycle++;\\n\\n                referrerPlaceX4(_referrer, position.referrer, _level, true);\\n            }\\n        }\\n\\n        emit PlacementX4(\\n            _addr,\\n            _referrer,\\n            _level,\\n            member.placementSide,\\n            member.placedUnder,\\n            passup\\n        );\\n    }\\n\\n    function positionPlaceLastLevelX4(\\n        address _addr,\\n        address _referrer,\\n        address _position,\\n        uint8 _placementSide,\\n        uint8 _level\\n    ) internal {\\n        X4 storage position = users[_position].x4Positions[_level];\\n\\n        if (position.placementSide == 0 \\u0026\\u0026 _referrer == idToAddress[1]) {\\n            return;\\n        }\\n\\n        if (_placementSide == 1) {\\n            if ((position.placementLastLevel \\u0026 1) == 0) {\\n                position.placementLastLevel += 1;\\n            } else {\\n                position.placementLastLevel += 2;\\n            }\\n        } else {\\n            if ((position.placementLastLevel \\u0026 4) == 0) {\\n                position.placementLastLevel += 4;\\n            } else {\\n                position.placementLastLevel += 8;\\n            }\\n        }\\n\\n        if ((position.placementLastLevel \\u0026 15) == 15) {\\n            emit Cycle(_position, _addr, 2, _level);\\n\\n            position.placementFirstLevel = new address[](0);\\n            position.placementLastLevel = 0;\\n            position.cycles++;\\n\\n            if (_position != idToAddress[1]) {\\n                position.cycle++;\\n\\n                referrerPlaceX4(_position, position.referrer, _level, true);\\n            }\\n        }\\n    }\\n\\n    function findActiveReferrer(\\n        address _addr,\\n        address _referrer,\\n        uint8 _matrix,\\n        uint8 _level,\\n        bool _emit\\n    ) internal returns (address) {\\n        address referrerAddress = _referrer;\\n\\n        while (true) {\\n            if (users[referrerAddress].activeLevel[_matrix] \\u003e= _level) {\\n                return referrerAddress;\\n            }\\n            referrerAddress = users[referrerAddress].referrer;\\n            if (_emit) {\\n                emit FundsPassup(referrerAddress, _addr, (_matrix + 1), _level);\\n            }\\n        }\\n    }\\n\\n    function handleReEntryX3(address _addr, uint8 _level) internal {\\n        X3 storage member = users[_addr].x3Positions[_level];\\n        bool reentry = false;\\n\\n        member.reEntryCheck++;\\n\\n        if (member.reEntryCheck \\u003e= REENTRY_REQ) {\\n            address referrer = users[_addr].referrer;\\n\\n            if (users[referrer].activeLevel[0] \\u003e= _level) {\\n                member.reEntryCheck = 0;\\n                reentry = true;\\n            } else {\\n                referrer = findActiveReferrer(\\n                    _addr,\\n                    referrer,\\n                    0,\\n                    _level,\\n                    false\\n                );\\n\\n                if (\\n                    member.referrer != referrer \\u0026\\u0026\\n                    users[referrer].activeLevel[0] \\u003e= _level\\n                ) {\\n                    reentry = true;\\n                }\\n            }\\n\\n            if (reentry) {\\n                member.referrer = referrer;\\n\\n                emit PlacementReEntry(referrer, _addr, 1, _level);\\n            }\\n        }\\n    }\\n\\n    function handleReEntryX4(address _addr, uint8 _level) internal {\\n        X4 storage member = users[_addr].x4Positions[_level];\\n        bool reentry = false;\\n\\n        member.reEntryCheck++;\\n\\n        if (member.reEntryCheck \\u003e= REENTRY_REQ) {\\n            address referrer = users[_addr].referrer;\\n\\n            if (users[referrer].activeLevel[1] \\u003e= _level) {\\n                member.reEntryCheck = 0;\\n                member.referrer = referrer;\\n                reentry = true;\\n            } else {\\n                address active_referrer =\\n                    findActiveReferrer(_addr, referrer, 1, _level, false);\\n\\n                if (\\n                    member.referrer != active_referrer \\u0026\\u0026\\n                    users[active_referrer].activeLevel[1] \\u003e= _level\\n                ) {\\n                    member.referrer = active_referrer;\\n                    reentry = true;\\n                }\\n            }\\n\\n            if (reentry) {\\n                emit PlacementReEntry(member.referrer, _addr, 2, _level);\\n            }\\n        }\\n    }\\n\\n    function findPayoutReceiver(\\n        address _addr,\\n        uint8 _matrix,\\n        uint8 _level\\n    ) internal returns (address) {\\n        address from;\\n        address receiver;\\n\\n        if (_matrix == 0) {\\n            receiver = users[_addr].x3Positions[_level].referrer;\\n\\n            while (true) {\\n                X3 storage member = users[receiver].x3Positions[_level];\\n\\n                if (member.passup == 0) {\\n                    return receiver;\\n                }\\n\\n                member.passup--;\\n                from = receiver;\\n                receiver = member.referrer;\\n\\n                if (_level \\u003e 1 \\u0026\\u0026 member.reEntryCheck \\u003e 0) {\\n                    handleReEntryX3(from, _level);\\n                }\\n            }\\n        } else {\\n            receiver = users[_addr].x4Positions[_level].referrer;\\n\\n            while (true) {\\n                X4 storage member = users[receiver].x4Positions[_level];\\n\\n                if (member.passup == 0 \\u0026\\u0026 member.cycle == 0) {\\n                    return receiver;\\n                }\\n\\n                if (member.passup \\u003e 0) {\\n                    member.passup--;\\n                    receiver = member.placedUnder;\\n                } else {\\n                    member.cycle--;\\n                    from = receiver;\\n                    receiver = member.referrer;\\n\\n                    if (_level \\u003e 1 \\u0026\\u0026 member.reEntryCheck \\u003e 0) {\\n                        handleReEntryX4(from, _level);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function handlePayout(\\n        address _addr,\\n        uint8 _matrix,\\n        uint8 _level\\n    ) internal {\\n        address receiver = findPayoutReceiver(_addr, _matrix, _level);\\n\\n        emit FundsPayout(receiver, _addr, (_matrix + 1), _level);\\n\\n        uint256 cost = levelCost[_level];\\n        \\n        bool success = address(uint160(receiver)).send(cost);\\n        if (!success) {\\n            uint256 balance = address(this).balance;\\n            return address(uint160(idToAddress[1])).transfer(balance);\\n        }\\n        require(success, \\\"Transfer Failed\\\");\\n    }\\n\\n    function getAffiliateWallet(uint32 memberId)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return idToAddress[memberId];\\n    }\\n\\n    function usersX3Matrix(address _addr, uint8 _level)\\n        external\\n        view\\n        returns (\\n            uint32,\\n            uint16,\\n            uint8,\\n            uint8,\\n            uint8,\\n            address\\n        )\\n    {\\n        return (\\n            users[_addr].x3Positions[_level].directSales,\\n            users[_addr].x3Positions[_level].cycles,\\n            users[_addr].x3Positions[_level].passup,\\n            users[_addr].x3Positions[_level].reEntryCheck,\\n            users[_addr].x3Positions[_level].placement,\\n            users[_addr].x3Positions[_level].referrer\\n        );\\n    }\\n\\n    function usersX4Matrix(address _addr, uint8 _level)\\n        external\\n        view\\n        returns (\\n            uint32,\\n            uint16,\\n            uint8,\\n            uint8,\\n            address\\n        )\\n    {\\n        return (\\n            users[_addr].x4Positions[_level].directSales,\\n            users[_addr].x4Positions[_level].cycles,\\n            users[_addr].x4Positions[_level].passup,\\n            users[_addr].x4Positions[_level].reEntryCheck,\\n            users[_addr].x4Positions[_level].referrer\\n        );\\n    }\\n\\n    function usersX4MatrixPlacements(address _addr, uint8 _level)\\n        external\\n        view\\n        returns (\\n            uint8,\\n            uint8,\\n            address,\\n            address[] memory\\n        )\\n    {\\n        return (\\n            users[_addr].x4Positions[_level].placementLastLevel,\\n            users[_addr].x4Positions[_level].placementSide,\\n            users[_addr].x4Positions[_level].placedUnder,\\n            users[_addr].x4Positions[_level].placementFirstLevel\\n        );\\n    }\\n}\"},\"TeazersEvents.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity 0.6.11;\\n\\ncontract TeazersEvents {\\n    event Registration(address member, uint256 memberId, address referrer);\\n    event Upgrade(address member, address referrer, uint8 matrix, uint8 level);\\n    \\n    event PlacementX3(\\n        address member,\\n        address referrer,\\n        uint8 level,\\n        uint8 placement,\\n        bool passup\\n    );\\n    \\n    event PlacementX4(\\n        address member,\\n        address referrer,\\n        uint8 level,\\n        uint8 placementSide,\\n        address placedUnder,\\n        bool passup\\n    );\\n    \\n    event Cycle(\\n        address indexed member,\\n        address fromPosition,\\n        uint8 matrix,\\n        uint8 level\\n    );\\n    event PlacementReEntry(\\n        address indexed member,\\n        address reEntryFrom,\\n        uint8 matrix,\\n        uint8 level\\n    );\\n    event FundsPayout(\\n        address indexed member,\\n        address payoutFrom,\\n        uint8 matrix,\\n        uint8 level\\n    );\\n    event FundsPassup(\\n        address indexed member,\\n        address passupFrom,\\n        uint8 matrix,\\n        uint8 level\\n    );\\n}\"},\"TeazersStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity 0.6.11;\\n\\ncontract TeazersStorage {\\n    uint8 public constant TOP_LEVEL = 16;\\n    uint32 public lastId;\\n    uint256 internal constant ENTRY_ENABLED = 1;\\n    uint256 internal constant ENTRY_DISABLED = 2;\\n    uint256 public constant REENTRY_REQ = 2;\\n    uint256 internal reentry_status;\\n    address internal owner;\\n    \\n    struct Account {\\n        uint32 id;\\n        uint32 directSales;\\n        uint8[] activeLevel;\\n        bool exists;\\n        address referrer;\\n        mapping(uint8 =\\u003e X3) x3Positions;\\n        mapping(uint8 =\\u003e X4) x4Positions;\\n    }\\n\\n    struct X3 {\\n        uint8 passup;\\n        uint8 reEntryCheck;\\n        uint8 placement;\\n        uint16 cycles;\\n        uint32 directSales;\\n        address referrer;\\n    }\\n\\n    struct X4 {\\n        uint8 passup;\\n        uint8 cycle;\\n        uint8 reEntryCheck;\\n        uint8 placementLastLevel;\\n        uint8 placementSide;\\n        uint16 cycles;\\n        uint32 directSales;\\n        address referrer;\\n        address placedUnder;\\n        address[] placementFirstLevel;\\n    }\\n\\n\\n    mapping(uint8 =\\u003e uint256) public levelCost;\\n    mapping(address =\\u003e Account) public users;\\n    mapping(uint32 =\\u003e address) public idToAddress;\\n\\n    modifier isOwner(address _user) {\\n        require(owner == _user, \\u0027Restricted Access!\\u0027);\\n        _;\\n    }\\n\\n    modifier isMember(address _addr) {\\n        require(users[_addr].exists, \\u0027Register Account First!\\u0027);\\n        _;\\n    }\\n\\n    modifier blockReEntry() {\\n        require(reentry_status != ENTRY_DISABLED, \\u0027Security Block\\u0027);\\n        reentry_status = ENTRY_DISABLED;\\n\\n        _;\\n        reentry_status = ENTRY_ENABLED;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromPosition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Cycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"passupFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"FundsPassup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"FundsPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reEntryFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"PlacementReEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"placement\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passup\",\"type\":\"bool\"}],\"name\":\"PlacementX3\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"placementSide\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"placedUnder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passup\",\"type\":\"bool\"}],\"name\":\"PlacementX4\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memberId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REENTRY_REQ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOP_LEVEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"memberId\",\"type\":\"uint32\"}],\"name\":\"getAffiliateWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_matrix\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"purchaseLevel\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registration\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"directSales\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"usersX3Matrix\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"usersX4Matrix\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"usersX4MatrixPlacements\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Teazers","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000003559435f2f36ba710c729c66798ab30cc05f306","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f5418b4ab4f3c4b62a63c58a0d19d7740f4a30c0fbcd42817966297c75a37205"}]}