{"status":"1","message":"OK","result":[{"SourceCode":"//\"SPDX-License-Identifier: UNLICENSED\"\r\n\r\npragma solidity ^0.6.6;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Multiplier{\r\n    //instantiating SafeMath library\r\n    using SafeMath for uint;\r\n    \r\n    //instance of utility token\r\n    IERC20 private _token;\r\n    \r\n    //struct\r\n    struct User {\r\n        uint balance;\r\n        uint release;\r\n        address approved;\r\n    }\r\n    \r\n    //address to User mapping\r\n    mapping(address => User) private _users;\r\n    \r\n    //multiplier constance for multiplying rewards\r\n    uint private constant _MULTIPLIER_CEILING = 2;\r\n    \r\n    //events\r\n    event Deposited(address indexed user, uint amount);\r\n    event Withdrawn(address indexed user, uint amount, uint time);\r\n    event NewLockup(address indexed poolstake, address indexed user, uint lockup);\r\n    event ContractApproved(address indexed user, address contractAddress);\r\n    \r\n    /* \r\n     * @dev instantiate the multiplier.\r\n     * --------------------------------\r\n     * @param token--> the token that will be locked up.\r\n     */    \r\n    constructor(address token) public {\r\n        require(token != address(0), \"token must not be the zero address\");\r\n        _token = IERC20(token);\r\n    }\r\n\r\n    /* \r\n     * @dev top up the available balance.\r\n     * --------------------------------\r\n     * @param _amount --> the amount to lock up.\r\n     * -------------------------------\r\n     * returns whether successfully topped up or not.\r\n     */  \r\n    function deposit(uint _amount) external returns(bool) {\r\n        \r\n        require(_amount > 0, \"amount must be larger than zero\");\r\n        \r\n        require(_token.transferFrom(msg.sender, address(this), _amount), \"amount must be approved\");\r\n        _users[msg.sender].balance = balance(msg.sender).add(_amount);\r\n        \r\n        emit Deposited(msg.sender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /* \r\n     * @dev approve a contract to use Multiplier\r\n     * -------------------------------------------\r\n     * @param _traditional --> the contract address to approve\r\n     * -------------------------------------------------------\r\n     * returns whether successfully approved or not\r\n     */ \r\n    function approveContract(address _traditional) external returns(bool) {\r\n        \r\n        require(_users[msg.sender].approved != _traditional, \"already approved\");\r\n        require(Address.isContract(_traditional), \"can only approve a contract\");\r\n        \r\n        _users[msg.sender].approved = _traditional;\r\n        \r\n        emit ContractApproved(msg.sender, _traditional);\r\n        return true;\r\n    } \r\n    \r\n    /* \r\n     * @dev withdraw released multiplier balance.\r\n     * ----------------------------------------\r\n     * @param _amount --> the amount to be withdrawn.\r\n     * -------------------------------------------\r\n     * returns whether successfully withdrawn or not.\r\n     */\r\n    function withdraw(uint _amount) external returns(bool) {\r\n        \r\n        require(now >= _users[msg.sender].release, \"must wait for release\");\r\n        require(_amount > 0, \"amount must be larger than zero\");\r\n        require(balance(msg.sender) >= _amount, \"must have a sufficient balance\");\r\n        \r\n        _users[msg.sender].balance = balance(msg.sender).sub(_amount);\r\n        require(_token.transfer(msg.sender, _amount), \"token transfer failed\");\r\n        \r\n        emit Withdrawn(msg.sender, _amount, now);\r\n        return true;\r\n    }\r\n    \r\n    /* \r\n     * @dev updates the lockup period (called by pool contract)\r\n     * ----------------------------------------------------------\r\n     * IMPORTANT - can only be used to increase lockup\r\n     * -----------------------------------------------\r\n     * @param _lockup --> the vesting period\r\n     * -------------------------------------------\r\n     * returns whether successfully withdrawn or not.\r\n     */\r\n    function updateLockupPeriod(address _user, uint _lockup) external returns(bool) {\r\n        \r\n        require(Address.isContract(msg.sender), \"only a smart contract can call\");\r\n        require(_users[_user].approved == msg.sender, \"contract is not approved\");\r\n        require(now.add(_lockup) > _users[_user].release, \"cannot reduce current lockup\");\r\n        \r\n        _users[_user].release = now.add(_lockup);\r\n        \r\n        emit NewLockup(msg.sender, _user, _lockup);\r\n        return true;\r\n    }\r\n    \r\n    /* \r\n     * @dev get the multiplier ceiling for percentage calculations.\r\n     * ----------------------------------------------------------\r\n     * returns the multiplication factor.\r\n     */     \r\n    function getMultiplierCeiling() external pure returns(uint) {\r\n        \r\n        return _MULTIPLIER_CEILING;\r\n    }\r\n\r\n    /* \r\n     * @dev get the multiplier user balance.\r\n     * -----------------------------------\r\n     * @param _user --> the address of the user.\r\n     * ---------------------------------------\r\n     * returns the multiplier balance.\r\n     */ \r\n    function balance(address _user) public view returns(uint) {\r\n        \r\n        return _users[_user].balance;\r\n    }\r\n    \r\n    /* \r\n     * @dev get the approved Traditional contract address\r\n     * --------------------------------------------------\r\n     * @param _user --> the address of the user\r\n     * ----------------------------------------\r\n     * returns the approved contract address\r\n     */ \r\n    function approvedContract(address _user) external view returns(address) {\r\n        \r\n        return _users[_user].approved;\r\n    }\r\n    \r\n    /* \r\n     * @dev get the release of the multiplier balance.\r\n     * ---------------------------------------------\r\n     * @param user --> the address of the user.\r\n     * ---------------------------------------\r\n     * returns the release timestamp.\r\n     */     \r\n    function lockupPeriod(address _user) external view returns(uint) {\r\n        \r\n        uint release = _users[_user].release;\r\n        if (release > now) return (release.sub(now));\r\n        else return 0;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolstake\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockup\",\"type\":\"uint256\"}],\"name\":\"NewLockup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_traditional\",\"type\":\"address\"}],\"name\":\"approveContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"approvedContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultiplierCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"lockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockup\",\"type\":\"uint256\"}],\"name\":\"updateLockupPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Multiplier","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009ed8e7c9604790f7ec589f99b94361d8aab64e5e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0ac9d9ba9c459dbce5a07fdb93c23e735e522c0e59e3560edb19d7a7d8363de6"}]}