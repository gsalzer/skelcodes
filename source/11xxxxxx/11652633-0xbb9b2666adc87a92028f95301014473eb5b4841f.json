{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address _who) public view returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool);\n    function allowance(address _ocwner, address _spender) public view returns (uint256);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\ncontract IKyberNetworkProxy {\n    function swapEtherToToken(\n        ERC20 token,\n        uint minConversionRate\n    )\n    public\n    payable\n    returns(uint);\n\n    function swapTokenToToken(\n        ERC20 src,\n        uint srcAmount,\n        ERC20 dest,\n        uint minConversionRate\n    )\n    public\n    returns (uint);\n\n    function getExpectedRate(\n        ERC20 src,\n        ERC20 dest,\n        uint srcQty\n    )\n    public\n    view\n    returns (uint expectedRate, uint slippageRate);\n}\n\ncontract IKyberReserveInterface {\n\n    // Pricing contract\n    uint public collectedFeesInTwei;\n    // Pricing contract\n    function resetCollectedFees() public;\n    // Pricing contract\n    function setLiquidityParams(\n        uint _rInFp,\n        uint _pMinInFp,\n        uint _numFpBits,\n        uint _maxCapBuyInWei,\n        uint _maxCapSellInWei,\n        uint _feeInBps,\n        uint _maxTokenToEthRateInPrecision,\n        uint _minTokenToEthRateInPrecision\n    ) public;\n\n    function withdraw(ERC20 token, uint amount, address destination) public returns(bool);\n    function disableTrade() public returns (bool);\n    function enableTrade() public returns (bool);\n    function withdrawEther(uint amount, address sendTo) external;\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external;\n    function setContracts(address _kyberNetwork, address _conversionRates, address _sanityRates) public;\n    function getDestQty(ERC20 src, ERC20 dest, uint srcQty, uint rate) public view returns(uint);\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyCampaignValidator {\n    function isCampaignValidated(address campaign) public view returns (bool);\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\n    function validateCPCCampaign(address campaign, string nonSingletonHash) public;\n}\n\ncontract ITwoKeyEventSource {\n\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external;\n    function rejected(address _campaign, address _converter) external;\n\n    function convertedAcquisition(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonation(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external;\n\n    function executed(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external;\n\n    function tokensWithdrawnFromPurchasesHandler(\n        address campaignAddress,\n        uint _conversionID,\n        uint _tokensAmountWithdrawn\n    )\n    external;\n\n    function emitDebtEvent(\n        address _plasmaAddress,\n        uint _amount,\n        bool _isAddition,\n        string _currency\n    )\n    external;\n\n    function emitReceivedTokensToDeepFreezeTokenPool(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitReceivedTokensAsModerator(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitDAIReleasedAsIncome(\n        address _campaignContractAddress,\n        uint _amountOfDAI\n    )\n    public;\n\n    function emitEndedBudgetCampaign(\n        address campaignPlasmaAddress,\n        uint contractorLeftover,\n        uint moderatorEarningsDistributed\n    )\n    public;\n\n\n    function emitUserWithdrawnNetworkEarnings(\n        address user,\n        uint amountOfTokens\n    )\n    public;\n\n    function emitRebalancedRewards(\n        uint cycleId,\n        uint difference,\n        string action\n    )\n    public;\n}\n\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n    function getStableCoinTo2KEYQuota(address stableCoinAddress) public view returns (uint,uint);\n    function getStableCoinToUSDQuota(address stableCoin) public view returns (uint);\n}\n\ncontract ITwoKeyFactory {\n    function addressToCampaignType(address _key) public view returns (string);\n}\n\ncontract ITwoKeyFeeManager {\n    function payDebtWhenConvertingOrWithdrawingProceeds(address _plasmaAddress, uint _debtPaying) public payable;\n    function getDebtForUser(address _userPlasma) public view returns (uint);\n    function payDebtWithDAI(address _plasmaAddress, uint _totalDebt, uint _debtPaid) public;\n    function payDebtWith2Key(address _beneficiaryPublic, address _plasmaAddress, uint _amountOf2keyForRewards) public;\n    function payDebtWith2KeyV2(\n        address _beneficiaryPublic,\n        address _plasmaAddress,\n        uint _amountOf2keyForRewards,\n        address _twoKeyEconomy,\n        address _twoKeyAdmin\n    ) public;\n    function setRegistrationFeeForUser(address _plasmaAddress, uint _registrationFee) public;\n    function addDebtForUser(address _plasmaAddress, uint _debtAmount, string _debtType) public;\n    function withdrawEtherCollected() public returns (uint);\n    function withdraw2KEYCollected() public returns (uint);\n    function withdrawDAICollected(address _dai) public returns (uint);\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeyReg {\n    function addTwoKeyEventSource(address _twoKeyEventSource) public;\n    function changeTwoKeyEventSource(address _twoKeyEventSource) public;\n    function addWhereContractor(address _userAddress, address _contractAddress) public;\n    function addWhereModerator(address _userAddress, address _contractAddress) public;\n    function addWhereReferrer(address _userAddress, address _contractAddress) public;\n    function addWhereConverter(address _userAddress, address _contractAddress) public;\n    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n    function getTwoKeyEventSourceAddress() public view returns (address);\n    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n    function addNameByUser(string _name) public;\n    function getName2Owner(string _name) public view returns (address);\n    function getOwner2Name(address _sender) public view returns (string);\n    function getPlasmaToEthereum(address plasma) public view returns (address);\n    function getEthereumToPlasma(address ethereum) public view returns (address);\n    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);\n    function getUserData(address _user) external view returns (bytes);\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] path) external view returns (uint[] memory amounts);\n}\n\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract ITwoKeyUpgradableExchangeStorage is IStructuredStorage{\n\n}\n\nlibrary GetCode {\n    function at(address _addr) internal view returns (bytes o_code) {\n        assembly {\n        // retrieve the size of the code, this needs assembly\n            let size := extcodesize(_addr)\n        // allocate output byte array - this could also be done without assembly\n        // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n        // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n        // store length in memory\n            mstore(o_code, size)\n        // actually retrieve the code, this needs assembly\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n        }\n    }\n}\n\nlibrary PriceDiscovery {\n\n\n    using SafeMath for uint;\n\n\n\n    /**\n     * @notice          Function to calculate token price based on amount of tokens in the pool\n     *                  currently and initial worth of pool in USD\n     *\n     * @param           poolInitialAmountInUSD (wei) is the amount how much all tokens in pool should be worth\n     * @param           amountOfTokensLeftInPool (wei) is the amount of tokens left in the pool after somebody\n     *                  bought them\n     * @return          new token price in USD  -> in wei units\n     */\n    function recalculatePrice(\n        uint poolInitialAmountInUSD,\n        uint amountOfTokensLeftInPool\n    )\n    public\n    pure\n    returns (uint)\n    {\n        return (poolInitialAmountInUSD.mul(10**18)).div(amountOfTokensLeftInPool);\n\n    }\n\n\n    /**\n     * @notice          Function to calculate how many iterations to recompute price we need\n     *\n     * @param           amountOfUSDSpendingForBuyingTokens is the dollar amount user is spending\n     *                  to buy the tokens\n     * @param           tokenPriceBeforeBuying is the price of the token when user expressed\n     *                  a will to buy the tokens\n     * @param           totalAmountOfTokensInThePool is the amount of the tokens that are currently present in the pool\n     *\n     * @dev             All input values are in WEI units\n     *\n     * @return          tuple containing number of iterations and how many dollars will be spent per iteration\n     */\n    function calculateNumberOfIterationsNecessary(\n        uint amountOfUSDSpendingForBuyingTokens,\n        uint tokenPriceBeforeBuying,\n        uint totalAmountOfTokensInThePool\n    )\n    public\n    pure\n    returns (uint, uint)\n    {\n        uint ONE_WEI = 10**18;\n        uint HUNDRED_WEI = 100*(10**18);\n\n        uint numberOfIterations = 1;\n\n        if(amountOfUSDSpendingForBuyingTokens > HUNDRED_WEI) {\n            uint amountOfTokensToBeBought;\n            uint percentageOfThePoolWei;\n\n            /**\n             Function to calculate how many tokens will be bought and how much percentage is that\n             out of the current pool supply\n             */\n            (amountOfTokensToBeBought, percentageOfThePoolWei) = calculatePercentageOfThePoolWei(\n                amountOfUSDSpendingForBuyingTokens,\n                tokenPriceBeforeBuying,\n                totalAmountOfTokensInThePool\n            );\n\n\n            if(percentageOfThePoolWei < ONE_WEI) {\n                // Case less than 1%\n                numberOfIterations = 5;\n\n            } else if(percentageOfThePoolWei < ONE_WEI.mul(10)) {\n                // Case between 1% and 10%\n                numberOfIterations = 10;\n            } else if(percentageOfThePoolWei < ONE_WEI.mul(30)) {\n                // Case between 10% and 30%\n                numberOfIterations = 30;\n            } else {\n                // Cases where 30% or above\n                numberOfIterations = 100;\n            }\n        }\n\n        return (numberOfIterations, amountOfUSDSpendingForBuyingTokens.div(numberOfIterations));\n    }\n\n\n    /**\n     * @notice          Function to calculate how many tokens would be bought in case the token price\n     *                  is static, and how many in percentage is that out of the pool amount\n     *\n     * @param           usdAmountSpendingToBuyTokens is the amount of dollars user is spending for\n     *                  buying tokens\n     * @param           tokenPriceBeforeBuying is the price of the token at the moment of\n     *                  purchase initialization\n     * @param           totalAmountOfTokensInThePool is the total amount of the tokens in the pool at\n     *                  the moment\n     *\n     * @dev             All input values are in WEI units\n     */\n    function calculatePercentageOfThePoolWei(\n        uint usdAmountSpendingToBuyTokens,\n        uint tokenPriceBeforeBuying,\n        uint totalAmountOfTokensInThePool\n    )\n    public\n    pure\n    returns (uint,uint)\n    {\n        uint HUNDRED_WEI = 100*(10**18);\n\n        // Amount of tokens that user would receive in case he bought for the whole money at initial price\n        uint amountOfTokensToBeBought = usdAmountSpendingToBuyTokens.mul(10**18).div(tokenPriceBeforeBuying);\n        // Percentage of the current amount in the pool in tokens user is buying\n        uint percentageOfThePoolWei = amountOfTokensToBeBought.mul(HUNDRED_WEI).div(totalAmountOfTokensInThePool);\n\n        return (amountOfTokensToBeBought, percentageOfThePoolWei);\n    }\n\n\n    /**\n     * @notice          Function to calculate total tokens user will get and what will be the new\n     *                  price after his purchase of tokens is done\n     *\n     * @param           amountOfUSDSpendingForBuyingTokens is the dollar amount user is spending\n     * @param           tokenPriceBeforeBuying is the price of the token before purchase\n     * @param           totalAmountOfTokensInThePool is the total amount of the tokens in the pool atm\n     * @param           poolInitialWorthUSD is how much all 2KEY tokens in the pool should be worth together\n     *\n     * @dev             All input values are in WEI units\n     */\n    function calculateTotalTokensUserIsGetting(\n        uint amountOfUSDSpendingForBuyingTokens,\n        uint tokenPriceBeforeBuying,\n        uint totalAmountOfTokensInThePool,\n        uint poolInitialWorthUSD\n    )\n    public\n    pure\n    returns (uint,uint)\n    {\n        uint totalTokensBought;\n\n        uint numberOfIterations;\n        uint amountBuyingPerIteration;\n\n        (numberOfIterations, amountBuyingPerIteration) = calculateNumberOfIterationsNecessary(\n            amountOfUSDSpendingForBuyingTokens,\n            tokenPriceBeforeBuying,\n            totalAmountOfTokensInThePool\n        );\n\n        uint index;\n        uint amountOfTokensReceived;\n        uint newPrice = tokenPriceBeforeBuying;\n\n        // We're looping here without any issues because number of iterations is limited to maximal 100\n        for(index = 0; index < numberOfIterations; index ++) {\n            // Function which will calculate the amount of tokens we got for specific iteration\n            // and also besides that what will be the new token price\n            (amountOfTokensReceived, newPrice, totalAmountOfTokensInThePool) = calculateAmountOfTokensPerIterationAndNewPrice(\n                totalAmountOfTokensInThePool,\n                newPrice,\n                amountBuyingPerIteration,\n                poolInitialWorthUSD\n            );\n            // Update total tokens which user have bought\n            totalTokensBought = totalTokensBought.add(amountOfTokensReceived);\n        }\n\n        return (totalTokensBought, newPrice);\n    }\n\n\n    /**\n     * @notice          Function which will be used always when we're buying tokens from upgradable exchange\n     *                  and will take care of calculations of tokens to be bought, average token price paid\n     *                  in this purchase, and what will be the new token price after purchase\n     *\n     * @param           amountOfUSDSpendingForBuyingTokens is the dollar amount user is spending\n     * @param           tokenPriceBeforeBuying is the price of the token before purchase\n     * @param           totalAmountOfTokensInThePool is the total amount of the tokens in the pool atm\n     * @param           poolInitialWorthUSD is how much all 2KEY tokens in the pool should be worth together\n     *\n     * @dev             All input values are in WEI units\n     */\n    function buyTokensFromExchangeRealignPrice(\n        uint amountOfUSDSpendingForBuyingTokens,\n        uint tokenPriceBeforeBuying,\n        uint totalAmountOfTokensInThePool,\n        uint poolInitialWorthUSD\n    )\n    public\n    pure\n    returns (uint,uint,uint)\n    {\n        uint totalTokensBought;\n        uint newTokenPrice;\n\n        (totalTokensBought, newTokenPrice) = calculateTotalTokensUserIsGetting(\n            amountOfUSDSpendingForBuyingTokens,\n            tokenPriceBeforeBuying,\n            totalAmountOfTokensInThePool,\n            poolInitialWorthUSD\n        );\n\n        uint averageTokenPriceForPurchase = amountOfUSDSpendingForBuyingTokens.mul(10**18).div(totalTokensBought);\n\n        return (totalTokensBought, averageTokenPriceForPurchase, newTokenPrice);\n    }\n\n\n    /**\n     * @notice          Function to calculate amount of tokens per iteration and what will be the new price\n     * @param           totalAmountOfTokensInThePool is the total amount of tokens in the pool at the moment\n     * @param           tokenPrice is the price of the token at the moment\n     * @param           iterationAmount is the amount user is spending in this iteration\n     */\n    function calculateAmountOfTokensPerIterationAndNewPrice(\n        uint totalAmountOfTokensInThePool,\n        uint tokenPrice,\n        uint iterationAmount,\n        uint poolInitialWorthUSD\n    )\n    public\n    pure\n    returns (uint,uint,uint)\n    {\n        // Calculate amount of tokens user is getting\n        uint amountOfTokens = iterationAmount.mul(10**18).div(tokenPrice);\n        // Calculate the new price for the pool\n        uint tokensLeftInThePool = totalAmountOfTokensInThePool.sub(amountOfTokens);\n        // The new price after the tokens are being bought\n        uint newPrice = recalculatePrice(poolInitialWorthUSD, tokensLeftInThePool);\n\n        return (amountOfTokens,newPrice,tokensLeftInThePool);\n    }\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n\n    using SafeMath for uint256;\n\n    bool initialized;\n    address constant ETH_TOKEN_ADDRESS = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n\n    string constant _twoKeyCampaignValidator = \"TwoKeyCampaignValidator\";\n    string constant _twoKeyEconomy = \"TwoKeyEconomy\";\n    string constant _twoKeyExchangeRateContract = \"TwoKeyExchangeRateContract\";\n    string constant _twoKeyAdmin = \"TwoKeyAdmin\";\n    string constant _kyberNetworkProxy = \"KYBER_NETWORK_PROXY\";\n    string constant _kyberReserveContract = \"KYBER_RESERVE_CONTRACT\";\n\n\n    ITwoKeyUpgradableExchangeStorage public PROXY_STORAGE_CONTRACT;\n\n\n\n    /**\n     * @notice          This event will be fired every time a withdraw is executed\n     */\n    event WithdrawExecuted(\n        address caller,\n        address beneficiary,\n        uint stableCoinsReserveBefore,\n        uint stableCoinsReserveAfter,\n        uint etherBalanceBefore,\n        uint etherBalanceAfter,\n        uint stableCoinsToWithdraw,\n        uint twoKeyAmount\n    );\n\n\n    event HedgedEther (\n        uint _daisReceived,\n        uint _ratio,\n        uint _numberOfContracts\n    );\n\n    /**\n     * @notice          Constructor of the contract, can be called only once\n     *\n     * @param           _daiAddress is the address of DAI on ropsten\n     * @param           _kyberNetworkProxyAddress is the address of Kyber network contract\n     * @param           _twoKeySingletonesRegistry is the address of TWO_KEY_SINGLETON_REGISTRY\n     * @param           _proxyStorageContract is the address of proxy of storage contract\n     */\n    function setInitialParams(\n        address _daiAddress,\n        address _kyberNetworkProxyAddress,\n        address _twoKeySingletonesRegistry,\n        address _proxyStorageContract\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyUpgradableExchangeStorage(_proxyStorageContract);\n        setUint(keccak256(\"spreadWei\"), 3**16); // 3% wei\n\n        setUint(keccak256(\"sellRate2key\"),6 * (10**16));// When anyone send Ether to contract, 2key in exchange will be calculated on it's sell rate\n        setUint(keccak256(\"numberOfContracts\"), 0); //Number of contracts which have interacted with this contract through buyTokens function\n\n        setAddress(keccak256(_kyberNetworkProxy), _kyberNetworkProxyAddress);\n\n        initialized = true;\n    }\n\n\n    /**\n     * @notice          Modifier which will validate if contract is allowed to buy tokens\n     */\n    modifier onlyValidatedContracts {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(_twoKeyCampaignValidator);\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n\n    /**\n     * @notice          Modifier which will validate if msg sender is TwoKeyAdmin contract\n     */\n    modifier onlyTwoKeyAdmin {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(_twoKeyAdmin);\n        require(msg.sender == twoKeyAdmin);\n        _;\n    }\n\n\n    /**\n     * @dev             Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\n     *                  Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     *\n     * @param           _beneficiary Address performing the token purchase\n     * @param           _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(\n        address _beneficiary,\n        uint256 _weiAmount\n    )\n    private\n    {\n        require(_weiAmount != 0);\n    }\n\n\n    /**\n     * @dev             Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n     * @param           _beneficiary Address performing the token purchase\n     * @param           _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        //Take the address of token from storage\n        address tokenAddress = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n        ERC20(tokenAddress).transfer(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev             Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n     * @param           _beneficiary Address receiving the tokens\n     * @param           _tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @notice          Function to calculate how much pnercentage will be deducted from values\n     */\n    function calculatePercentageToDeduct(\n        uint _ethWeiHedged,\n        uint _sumOfAmounts\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return _ethWeiHedged.mul(10**18).div(_sumOfAmounts);\n    }\n\n\n    /**\n     * @notice          Function to calculate ratio between eth and dai in WEI's\n     */\n    function calculateRatioBetweenDAIandETH(\n        uint _ethWeiHedged,\n        uint _daiReceived\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return _daiReceived.mul(10**18).div(_ethWeiHedged);\n    }\n\n\n    /**\n     * @notice          Setter for EthWeiAvailableToHedge\n     * @param           _contractID is the ID of the contract\n     * @param           _msgValue is the amount sent\n     */\n    function updateEthWeiAvailableToHedge(\n        uint _contractID,\n        uint _msgValue\n    )\n    internal {\n        // Update EthWeiAvailableToHedge per contract\n        bytes32 ethWeiAvailableToHedgeKeyHash = keccak256(\"ethWeiAvailableToHedge\", _contractID);\n        setUint(ethWeiAvailableToHedgeKeyHash, getUint(ethWeiAvailableToHedgeKeyHash).add(_msgValue));\n    }\n\n\n    /**\n     * @notice          Function to register new contract with corresponding ID\n     * @param           _contractAddress is the address of the contract we're adding\n     */\n    function addNewContract(\n        address _contractAddress\n    )\n    internal\n    returns (uint)\n    {\n        // Get number of currently different contracts and increment by 1\n        uint numberOfContractsExisting = numberOfContracts();\n        uint id = numberOfContractsExisting.add(1);\n\n        bytes32 keyHashContractAddressToId = keccak256(\"contractAddressToId\", _contractAddress);\n        bytes32 keyHashIdToContractAddress = keccak256(\"idToContractAddress\", id);\n\n        // Set mappings id=>contractAddress and contractAddress=>id\n        setUint(keyHashContractAddressToId, id);\n        setAddress(keyHashIdToContractAddress, _contractAddress);\n\n        // Increment number of existing contracts\n        setUint(keccak256(\"numberOfContracts\"), id);\n\n        // Return contract ID\n        return id;\n    }\n\n\n    /**\n     * @notice          Function to emit an event, created separately because of stack depth\n     */\n    function emitEventWithdrawExecuted(\n        address _beneficiary,\n        uint _stableCoinsOnContractBefore,\n        uint _stableCoinsAfter,\n        uint _etherBalanceOnContractBefore,\n        uint _stableCoinUnits,\n        uint twoKeyUnits\n    )\n    internal\n    {\n        emit WithdrawExecuted(\n            msg.sender,\n            _beneficiary,\n            _stableCoinsOnContractBefore,\n            _stableCoinsAfter,\n            _etherBalanceOnContractBefore,\n            this.balance,\n            _stableCoinUnits,\n            twoKeyUnits\n        );\n    }\n\n\n    /**\n     * @notice          Internal function to get uint from storage contract\n     *\n     * @param           key is the to which value is allocated in storage\n     */\n    function getUint(\n        bytes32 key\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(key);\n    }\n\n\n    /**\n     * @notice          Internal function to set uint on the storage contract\n     *\n     * @param           key is the key to which value is (will be) allocated in storage\n     * @param           value is the value (uint) we're saving in the state\n     */\n    function setUint(\n        bytes32 key,\n        uint value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setUint(key, value);\n    }\n\n\n    /**\n     * @notice          Internal function to get bool from storage contract\n     *\n     * @param           key is the to which value is allocated in storage\n     */\n    function getBool(\n        bytes32 key\n    )\n    internal\n    view\n    returns (bool)\n    {\n        return PROXY_STORAGE_CONTRACT.getBool(key);\n    }\n\n\n    /**\n     * @notice          Internal function to set boolean on the storage contract\n     *\n     * @param           key is the key to which value is (will be) allocated in storage\n     * @param           value is the value (boolean) we're saving in the state\n     */\n    function setBool(\n        bytes32 key,\n        bool value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setBool(key,value);\n    }\n\n\n    /**\n     * @notice          Internal function to get address from storage contract\n     *\n     * @param           key is the to which value is allocated in storage\n     */\n    function getAddress(\n        bytes32 key\n    )\n    internal\n    view\n    returns (address)\n    {\n        return PROXY_STORAGE_CONTRACT.getAddress(key);\n    }\n\n\n    /**\n     * @notice          Internal function to set address on the storage contract\n     *\n     * @param           key is the key to which value is (will be) allocated in storage\n     * @param           value is the value (address) we're saving in the state\n     */\n    function setAddress(\n        bytes32 key,\n        address value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setAddress(key, value);\n    }\n\n\n    /**\n     * @notice          Function to get eth received from contract for specific contract ID\n     *\n     * @param           _contractID is the ID of the contract we're requesting information\n     */\n    function ethReceivedFromContract(\n        uint _contractID\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"ethReceivedFromContract\", _contractID));\n    }\n\n\n    /**\n     * @notice          Function to get how many 2keys are sent to selected contract\n     *\n     * @param           _contractID is the ID of the contract we're requesting information\n     */\n    function sent2keyToContract(\n        uint _contractID\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"sent2keyToContract\", _contractID));\n    }\n\n\n    /**\n     * @notice          Function to get how much ethWei hedged per contract\n     *\n     * @param           _contractID is the ID of the contract we're requesting information\n     */\n    function ethWeiHedgedPerContract(\n        uint _contractID\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"ethWeiHedgedPerContract\", _contractID));\n    }\n\n\n    /**\n     * @notice          Function to determine how many dai received from hedging per contract\n     *\n     * @param           _contractID is the ID of the contract we're requesting information\n     */\n    function daiWeiReceivedFromHedgingPerContract(\n        uint _contractID\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"daiWeiReceivedFromHedgingPerContract\", _contractID));\n    }\n\n\n    /**\n     * @notice          Function to report that 2KEY tokens are withdrawn from the network\n     *\n     * @param           amountOfTokensWithdrawn is the amount of tokens he wants to withdraw\n     * @param           _contractID is the id of the contract\n     */\n    function report2KEYWithdrawnFromNetworkInternal(\n        uint amountOfTokensWithdrawn,\n        uint _contractID\n    )\n    internal\n    {\n        bytes32 _daiWeiAvailableToWithdrawKeyHash = keccak256(\"daiWeiAvailableToWithdraw\",_contractID);\n        bytes32 _daiWeiAvailableToFill2KEYReserveKeyHash = keccak256(\"daiWeiAvailableToFill2KEYReserve\");\n\n        uint _daiWeiAvailable = daiWeiAvailableToWithdraw(_contractID);\n        uint _daiWeiToReduceFromAvailableAndFillReserve = getUSDStableCoinAmountFrom2keyUnits(amountOfTokensWithdrawn, _contractID);\n\n        uint _daiWeiAvailableToFill2keyReserveCurrently = daiWeiAvailableToFill2KEYReserve();\n\n        setUint(_daiWeiAvailableToFill2KEYReserveKeyHash, _daiWeiAvailableToFill2keyReserveCurrently.add(_daiWeiToReduceFromAvailableAndFillReserve));\n        setUint(_daiWeiAvailableToWithdrawKeyHash, _daiWeiAvailable.sub(_daiWeiToReduceFromAvailableAndFillReserve));\n\n        // Emit the event that DAI is released\n        ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitDAIReleasedAsIncome(\n            msg.sender,\n            _daiWeiToReduceFromAvailableAndFillReserve\n        );\n    }\n\n    function updateWithdrawOrReservePoolDependingOnCampaignType(\n        uint contractID,\n        uint _daisReceived,\n        address twoKeyFactory\n    )\n    internal\n    {\n        address campaignAddress = getContractAddressFromID(contractID);\n        string memory campaignType = ITwoKeyFactory(twoKeyFactory).addressToCampaignType(campaignAddress);\n        if(keccak256(\"CPC_PUBLIC\") == keccak256(campaignType)) {\n            // Means everything gets immediately released to support filling reserve\n            bytes32 daiWeiAvailableToFill2KEYReserveKeyHash = keccak256(\"daiWeiAvailableToFill2KEYReserve\");\n            setUint(daiWeiAvailableToFill2KEYReserveKeyHash, _daisReceived.add(getUint(daiWeiAvailableToFill2KEYReserveKeyHash)));\n        } else {\n            // Means funds are being able to withdrawn by influencers\n            bytes32 daiWeiAvailableToWithdrawKeyHash = keccak256(\"daiWeiAvailableToWithdraw\", contractID);\n            setUint(daiWeiAvailableToWithdrawKeyHash, daiWeiAvailableToWithdraw(contractID).add(_daisReceived));\n        }\n    }\n\n    /**\n     * @notice          Internal function created to update specific values, separated because of stack depth\n     *\n     * @param           _daisReceived is the amount of received dais\n     * @param           _hedgedEthWei is the amount of ethWei hedged\n     * @param           _afterHedgingAvailableEthWei is the amount available after hedging\n     * @param           _contractID is the ID of the contract\n     */\n    function updateAccountingValues(\n        uint _daisReceived,\n        uint _hedgedEthWei,\n        uint _afterHedgingAvailableEthWei,\n        uint _contractID\n    )\n    internal\n    {\n        bytes32 ethWeiAvailableToHedgeKeyHash = keccak256(\"ethWeiAvailableToHedge\", _contractID);\n        bytes32 ethWeiHedgedPerContractKeyHash = keccak256(\"ethWeiHedgedPerContract\", _contractID);\n        bytes32 daiWeiReceivedFromHedgingPerContractKeyHash = keccak256(\"daiWeiReceivedFromHedgingPerContract\",_contractID);\n\n        setUint(daiWeiReceivedFromHedgingPerContractKeyHash, daiWeiReceivedFromHedgingPerContract(_contractID).add(_daisReceived));\n        setUint(ethWeiHedgedPerContractKeyHash, ethWeiHedgedPerContract(_contractID).add(_hedgedEthWei));\n        setUint(ethWeiAvailableToHedgeKeyHash, _afterHedgingAvailableEthWei);\n    }\n\n    /**\n     * @notice          Function to reduce amount of dai available to be withdrawn from selected contract\n     *\n     * @param           contractAddress is the address of the contract\n     * @param           daiAmount is the amount of dais\n     */\n    function reduceDaiWeiAvailableToWithdraw(\n        address contractAddress,\n        uint daiAmount\n    )\n    internal\n    {\n        uint contractId = getContractId(contractAddress);\n        bytes32 keyHashDaiWeiAvailableToWithdraw = keccak256('daiWeiAvailableToWithdraw', contractId);\n        setUint(keyHashDaiWeiAvailableToWithdraw, daiWeiAvailableToWithdraw(contractId).sub(daiAmount));\n    }\n\n\n    /**\n     * @notice          Function to pay Fees to a manager and transfer the tokens forward to the referrers\n     *\n     * @param           _beneficiary is the address who's receiving tokens\n     * @param           _contractId is the id of the contract\n     * @param           _totalStableCoins is the total amount of DAIs\n     */\n    function payFeesToManagerAndTransferTokens(\n        address _beneficiary,\n        uint _contractId,\n        uint _totalStableCoins,\n        ERC20 dai\n    )\n    internal\n    {\n        address _userPlasma = ITwoKeyReg(getAddressFromTwoKeySingletonRegistry(\"TwoKeyRegistry\")).getEthereumToPlasma(_beneficiary);\n        // Handle if there's any existing debt\n        address twoKeyFeeManager = getAddressFromTwoKeySingletonRegistry(\"TwoKeyFeeManager\");\n        uint usersDebtInEth = ITwoKeyFeeManager(twoKeyFeeManager).getDebtForUser(_userPlasma);\n        uint amountToPay = 0;\n\n        if(usersDebtInEth > 0) {\n            uint eth2DAI = getEth2DaiAverageExchangeRatePerContract(_contractId); // DAI / ETH\n            uint totalDebtInDAI = (usersDebtInEth.mul(eth2DAI)).div(10**18); // ETH * (DAI/ETH) = DAI\n\n            amountToPay = totalDebtInDAI;\n\n            if (_totalStableCoins > totalDebtInDAI){\n                if(_totalStableCoins < 3 * totalDebtInDAI) {\n                    amountToPay = totalDebtInDAI / 2;\n                }\n            }\n            else {\n                amountToPay = _totalStableCoins / 4;\n            }\n\n            // Funds are going to admin\n            dai.transfer(getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\"), amountToPay);\n            ITwoKeyFeeManager(twoKeyFeeManager).payDebtWithDAI(_userPlasma, totalDebtInDAI, amountToPay);\n        }\n\n        dai.transfer(_beneficiary, _totalStableCoins.sub(amountToPay)); // Transfer the rest of the DAI to users\n    }\n\n\n    /**\n     * @notice          Function to calculate available to hedge sum on all contracts\n     */\n    function calculateSumOnContracts(\n        uint startIndex,\n        uint endIndex\n    )\n    public\n    view\n    returns (uint)\n    {\n        uint sumOfAmounts = 0; //Will represent total sum we have on the contract\n        uint i;\n\n        // Sum all amounts on all contracts\n        for(i=startIndex; i<=endIndex; i++) {\n            sumOfAmounts = sumOfAmounts.add(ethWeiAvailableToHedge(i));\n        }\n        return sumOfAmounts;\n    }\n\n\n    /**\n     * @notice          Function to get contract id, if return 0 means contract is not existing\n     */\n    function getContractId(\n        address _contractAddress\n    )\n    public\n    view\n    returns (uint) {\n        bytes32 keyHashContractAddressToId = keccak256(\"contractAddressToId\", _contractAddress);\n        uint id = getUint(keyHashContractAddressToId);\n        return id;\n    }\n\n\n    /**\n     * @notice          Function to get amount of the tokens user will receive\n     *\n     * @param           _weiAmount Value in wei to be converted into tokens\n     *\n     * @return          Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function getTokenAmountToBeSold(\n        uint256 _weiAmount\n    )\n    public\n    view\n    returns (uint256,uint256,uint256)\n    {\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(_twoKeyExchangeRateContract);\n\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD\");\n        uint dollarAmountWei = _weiAmount.mul(rate).div(10**18);\n\n        return get2KEYTokenPriceAndAmountOfTokensReceiving(dollarAmountWei);\n    }\n\n\n    /**\n     * @notice          Function to calculate how many stable coins we can get for specific amount of 2keys\n     *\n     * @dev             This is happening in case we're receiving (buying) 2key\n     *\n     * @param           _2keyAmount is the amount of 2keys sent to the contract\n     * @param           _campaignID is the ID of the campaign\n     */\n    function getUSDStableCoinAmountFrom2keyUnits(\n        uint256 _2keyAmount,\n        uint _campaignID\n    )\n    public\n    view\n    returns (uint256)\n    {\n        uint activeHedgeRate = get2KEY2DAIHedgedRate(_campaignID);\n\n        uint hundredPercent = 10**18;\n        uint rateWithSpread = activeHedgeRate.mul(hundredPercent.sub(spreadWei())).div(10**18);\n        uint amountOfDAIs = _2keyAmount.mul(rateWithSpread).div(10**18);\n\n        return amountOfDAIs;\n    }\n\n\n    function getMore2KeyTokensForRebalancingV1(\n        uint amountOfTokensRequested\n    )\n    public\n    {\n        require(msg.sender == getAddressFromTwoKeySingletonRegistry(\"TwoKeyBudgetCampaignsPaymentsHandler\"));\n        _processPurchase(msg.sender, amountOfTokensRequested);\n    }\n\n    function returnTokensBackToExchangeV1(\n        uint amountOfTokensToReturn\n    )\n    public\n    {\n        require(msg.sender == getAddressFromTwoKeySingletonRegistry(\"TwoKeyBudgetCampaignsPaymentsHandler\"));\n        // Take the tokens from the contract\n        IERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy)).transferFrom(\n            msg.sender,\n            address(this),\n            amountOfTokensToReturn\n        );\n    }\n\n\n    /**\n     * @notice          Function to buyTokens from TwoKeyUpgradableExchange\n     * @param           _beneficiary is the address which will receive the tokens\n     * @return          amount of tokens bought\n     */\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    onlyValidatedContracts\n    returns (uint,uint)\n    {\n        _preValidatePurchase(_beneficiary, msg.value);\n\n        uint totalTokensBought;\n        uint averageTokenPriceForPurchase;\n        uint newTokenPrice;\n\n        (totalTokensBought, averageTokenPriceForPurchase, newTokenPrice) = getTokenAmountToBeSold(msg.value);\n\n\n        set2KEYSellRateInternal(newTokenPrice);\n\n        // check if contract is first time interacting with this one\n        uint contractId = getContractId(msg.sender);\n\n        // Check if the contract exists\n        if(contractId == 0) {\n            contractId = addNewContract(msg.sender);\n        }\n\n        setHedgingInformationAndContractStats(\n            contractId,\n            totalTokensBought,\n            msg.value\n        );\n\n        _processPurchase(_beneficiary, totalTokensBought);\n\n        return (totalTokensBought, averageTokenPriceForPurchase);\n    }\n\n    function buyTokensWithERC20(\n        uint amountOfTokens,\n        address tokenAddress\n    )\n    public\n    returns (uint,uint)\n    {\n        require(msg.sender == getAddressFromTwoKeySingletonRegistry(\"TwoKeyBudgetCampaignsPaymentsHandler\"));\n\n        uint totalTokensBought;\n        uint averageTokenPriceForPurchase;\n        uint newTokenPrice;\n\n        // Increment amount of this stable tokens to fill reserve\n        addStableCoinsAvailableToFillReserve(amountOfTokens, tokenAddress);\n\n        uint amountInUSDOfPurchase = computeAmountInUsd(amountOfTokens, tokenAddress);\n\n        // Process price discovery, buy tokens, and get new price\n        (totalTokensBought, averageTokenPriceForPurchase, newTokenPrice) = get2KEYTokenPriceAndAmountOfTokensReceiving(amountInUSDOfPurchase);\n\n        // Set new token price\n        set2KEYSellRateInternal(newTokenPrice);\n\n        // Transfer tokens\n        _processPurchase(msg.sender, totalTokensBought);\n\n        // Return amount of tokens received and average token price for purchase\n        return (totalTokensBought, averageTokenPriceForPurchase);\n    }\n\n    function computeAmountInUsd(\n        uint amountInTokenDecimals,\n        address tokenAddress\n    )\n    internal\n    view\n    returns (uint)\n    {\n        // Get the address of twoKeyExchangeRateContract\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(_twoKeyExchangeRateContract);\n\n        // Get stable coin to dollar rate\n        uint tokenToUsd = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getStableCoinToUSDQuota(tokenAddress);\n\n        // Get token decimals\n        uint tokenDecimals = IERC20(tokenAddress).decimals();\n\n        uint oneEth = 10 ** 18;\n\n        return amountInTokenDecimals.mul(oneEth.div(10 ** tokenDecimals)).mul(tokenToUsd).div(oneEth);\n    }\n\n\n\n    /**\n     * @notice          Internal function to update the state in case tokens were bought for influencers\n     *yes\n     * @param           contractID is the ID of the contract\n     * @param           amountOfTokensBeingSentToContract is the amount of 2KEY tokens being sent to the contract\n     * @param           purchaseAmountETH is the amount of ETH spent to purchase tokens\n     */\n    function setHedgingInformationAndContractStats(\n        uint contractID,\n        uint amountOfTokensBeingSentToContract,\n        uint purchaseAmountETH\n    )\n    internal\n    {\n        // Update how much ether we received from msg.sender contract\n        bytes32 ethReceivedFromContractKeyHash = keccak256(\"ethReceivedFromContract\", contractID);\n        setUint(ethReceivedFromContractKeyHash, ethReceivedFromContract(contractID).add(purchaseAmountETH));\n\n        // Update how much 2KEY tokens we sent to msg.sender contract\n        bytes32 sent2keyToContractKeyHash = keccak256(\"sent2keyToContract\", contractID);\n        setUint(sent2keyToContractKeyHash, sent2keyToContract(contractID).add(amountOfTokensBeingSentToContract));\n\n        updateEthWeiAvailableToHedge(contractID, purchaseAmountETH);\n\n    }\n\n    function set2KEYSellRateInternal(\n        uint newRate\n    )\n    internal\n    {\n        setUint(\n            keccak256(\"sellRate2key\"),\n            newRate\n        );\n    }\n\n    function setStableCoinsAvailableToFillReserve(\n        uint amountOfStableCoins,\n        address stableCoinAddress\n    )\n    internal\n    {\n        bytes32 key = keccak256(\"stableCoinToAmountAvailableToFillReserve\", stableCoinAddress);\n\n        setUint(\n            key,\n            amountOfStableCoins\n        );\n    }\n\n\n    function addStableCoinsAvailableToFillReserve(\n        uint amountOfStableCoins,\n        address stableCoinAddress\n    )\n    internal\n    {\n        bytes32 key = keccak256(\"stableCoinToAmountAvailableToFillReserve\", stableCoinAddress);\n\n        uint currentBalance = getUint(key);\n        setUint(\n            key,\n            currentBalance.add(amountOfStableCoins)\n        );\n    }\n\n    function getAvailableAmountToFillReserveInternal(\n        address tokenAddress\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"stableCoinToAmountAvailableToFillReserve\", tokenAddress));\n    }\n\n    /**\n     * @notice          Function to get array containing how much of the tokens are available to fill reserve\n     * @param           stableCoinAddresses is array of stable coin\n     */\n    function getAvailableAmountToFillReserve(\n        address [] stableCoinAddresses\n    )\n    public\n    view\n    returns (uint[])\n    {\n        uint numberOfTokens = stableCoinAddresses.length;\n        uint[] memory availableAmounts = new uint[](numberOfTokens);\n\n        uint i;\n        for(i=0; i<numberOfTokens; i++) {\n            availableAmounts[i] = getAvailableAmountToFillReserveInternal(stableCoinAddresses[i]);\n        }\n\n        return availableAmounts;\n    }\n\n\n    function releaseAllDAIFromContractToReserve()\n    public\n    onlyValidatedContracts\n    {\n        uint _contractID = getContractId(msg.sender);\n        bytes32 _daiWeiAvailableToWithdrawKeyHash = keccak256(\"daiWeiAvailableToWithdraw\",_contractID);\n        bytes32 _daiWeiAvailableToFill2KEYReserveKeyHash = keccak256(\"daiWeiAvailableToFill2KEYReserve\");\n\n        uint _daiWeiAvailableToWithdrawAndFillReserve = daiWeiAvailableToWithdraw(_contractID);\n\n        uint _daiWeiAvailableToFill2keyReserveCurrently = daiWeiAvailableToFill2KEYReserve();\n\n        setUint(_daiWeiAvailableToFill2KEYReserveKeyHash, _daiWeiAvailableToFill2keyReserveCurrently.add(_daiWeiAvailableToWithdrawAndFillReserve));\n        setUint(_daiWeiAvailableToWithdrawKeyHash, 0);\n\n        // Emit the event that DAI is released\n        ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitDAIReleasedAsIncome(\n            msg.sender,\n            _daiWeiAvailableToWithdrawAndFillReserve\n        );\n\n    }\n\n    /**\n     * @notice          Function which will be called every time by campaign when referrer select to withdraw directly 2key token\n     *\n     * @param           amountOfTokensWithdrawn is the amount of tokens he wants to withdraw\n     */\n    function report2KEYWithdrawnFromNetwork(\n        uint amountOfTokensWithdrawn\n    )\n    public\n    onlyValidatedContracts\n    {\n        uint _contractID = getContractId(msg.sender);\n        if(ethReceivedFromContract(_contractID) > 0 ) {\n            report2KEYWithdrawnFromNetworkInternal(amountOfTokensWithdrawn, _contractID);\n        }\n    }\n\n\n    /**\n     * @notice          Function to get expected rate from Kyber contract\n     * @param           amountSrcWei is the amount we'd like to exchange\n     * @param           srcToken is the address of src token we want to swap\n     * @param           destToken is the address of destination token we want to get\n     * @return          if the value is 0 that means we can't\n     */\n    function getKyberExpectedRate(\n        uint amountSrcWei,\n        address srcToken,\n        address destToken\n    )\n    public\n    view\n    returns (uint)\n    {\n        address kyberProxyContract = getAddress(keccak256(_kyberNetworkProxy));\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        ERC20 src = ERC20(srcToken);\n        ERC20 dest = ERC20(destToken);\n\n        uint minConversionRate;\n        (minConversionRate,) = proxyContract.getExpectedRate(src, dest, amountSrcWei);\n\n        return minConversionRate;\n    }\n\n\n    /**\n     * @notice          Function to relay demand of stable coins we have in exchange to\n     *                  uniswap exchange.\n     * @param           stableCoinsAddresses is array of addresses of stable coins we're going to swap\n     * @param           amounts are corresponding amounts of tokens that are going to be swapped.\n     */\n    function swapStableCoinsAvailableToFillReserveFor2KEY(\n        address [] stableCoinsAddresses,\n        uint [] amounts\n    )\n    public\n    onlyMaintainer\n    {\n        uint numberOfTokens = stableCoinsAddresses.length;\n        uint i;\n\n        address uniswapRouter = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"UniswapV2Router02\");\n\n        // Create a path array\n        address [] memory path = new address[](3);\n\n        for (i = 0; i < numberOfTokens; i++) {\n            // Load the token address\n            address tokenAddress = stableCoinsAddresses[i];\n\n            // Get how much is available to fill reserve\n            uint availableForReserve = getAvailableAmountToFillReserveInternal(tokenAddress);\n\n            // Require that amount wanted to swap is less or equal to amount present in reserve\n            require(amounts[i] <= availableForReserve);\n\n            uint amountToSwap = amounts[i];\n\n            // Reduce amount used to swap from available in reserve\n            setStableCoinsAvailableToFillReserve(\n                availableForReserve.sub(amountToSwap),\n                tokenAddress\n            );\n\n            // Approve uniswap router to take tokens from the contract\n            IERC20(tokenAddress).approve(\n                uniswapRouter,\n                amountToSwap\n            );\n\n            // Override always the path array\n            path[0] = tokenAddress;\n            path[1] = IUniswapV2Router02(uniswapRouter).WETH();\n            path[2] = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n\n            // Get minimum received\n            uint minimumToReceive = uniswapPriceDiscover(\n                uniswapRouter,\n                amountToSwap,\n                path\n            );\n\n            // Execute swap\n            IUniswapV2Router01(uniswapRouter).swapExactTokensForTokens(\n                amountToSwap,\n                minimumToReceive.mul(97).div(100), // Allow 3 percent to drop\n                path,\n                address(this),\n                block.timestamp + (10 minutes)\n            );\n        }\n    }\n\n\n    /**\n     * @notice          Function to start hedging some ether amount\n     * @param           amountToBeHedged is the amount we'd like to hedge\n     * @dev             only maintainer can call this function\n     */\n    function startHedging(\n        uint amountToBeHedged,\n        uint approvedMinConversionRate\n    )\n    public\n    onlyMaintainer\n    {\n        ERC20 dai = ERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"DAI\"));\n\n        if(amountToBeHedged > address(this).balance) {\n            amountToBeHedged = address(this).balance;\n        }\n\n        address kyberProxyContract = getAddress(keccak256(_kyberNetworkProxy));\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        // Get minimal conversion rate for the swap of ETH->DAI token\n        uint minConversionRate = getKyberExpectedRate(amountToBeHedged, ETH_TOKEN_ADDRESS, address(dai));\n\n        require(minConversionRate >= approvedMinConversionRate.mul(95).div(100)); //Means our rate can be at most same as their rate, because they're giving the best rate\n        uint stableCoinUnits = proxyContract.swapEtherToToken.value(amountToBeHedged)(dai,minConversionRate);\n        // Get the ratio between ETH and DAI for this hedging\n        uint ratio = calculateRatioBetweenDAIandETH(amountToBeHedged, stableCoinUnits);\n        //Emit event with important data\n        emit HedgedEther(stableCoinUnits, ratio, numberOfContracts());\n    }\n\n\n    function calculateHedgedAndReceivedForDefinedChunk(\n        uint numberOfContractsCurrently,\n        uint amountHedged,\n        uint stableCoinsReceived,\n        uint startIndex,\n        uint endIndex\n    )\n    public\n    view\n    returns (uint,uint)\n    {\n        //We're calculating sum on contracts between start and end index\n        uint sumInRange = calculateSumOnContracts(startIndex,endIndex);\n        //Now we need how much was hedged from this contracts between start and end index\n        uint stableCoinsReceivedForThisChunkOfContracts = (sumInRange.mul(stableCoinsReceived)).div(amountHedged);\n        // Returning for this piece of contracts\n        return (sumInRange, stableCoinsReceivedForThisChunkOfContracts);\n    }\n\n    /**\n     * @notice          Function to reduce available amount to hedge and increase available DAI to withdraw\n     *\n     * @param           _ethWeiHedgedForThisChunk is how much eth was hedged\n     * @param           _daiReceivedForThisChunk is how much DAI's we got for that hedging\n     */\n    function reduceHedgedAmountFromContractsAndIncreaseDaiAvailable(\n        uint _ethWeiHedgedForThisChunk,\n        uint _daiReceivedForThisChunk,\n        uint _ratio,\n        uint _startIndex,\n        uint _endIndex\n    )\n    public\n    onlyMaintainer\n    {\n        uint i;\n        uint percentageToDeductWei = calculatePercentageToDeduct(_ethWeiHedgedForThisChunk, _ethWeiHedgedForThisChunk); // Percentage to deduct in WEI (less than 1)\n        address twoKeyFactory = getAddressFromTwoKeySingletonRegistry(\"TwoKeyFactory\");\n        for(i=_startIndex; i<=_endIndex; i++) {\n            if(ethWeiAvailableToHedge(i) > 0) {\n                uint beforeHedgingAvailableEthWeiForContract = ethWeiAvailableToHedge(i);\n                uint hundredPercentWei = 10**18;\n                uint afterHedgingAvailableEthWei = beforeHedgingAvailableEthWeiForContract.mul(hundredPercentWei.sub(percentageToDeductWei)).div(10**18);\n\n                uint hedgedEthWei = beforeHedgingAvailableEthWeiForContract.sub(afterHedgingAvailableEthWei);\n                uint daisReceived = hedgedEthWei.mul(_ratio).div(10**18);\n                updateWithdrawOrReservePoolDependingOnCampaignType(i, daisReceived, twoKeyFactory);\n                updateAccountingValues(daisReceived, hedgedEthWei, afterHedgingAvailableEthWei, i);\n            }\n        }\n    }\n\n\n    /**\n     * @notice          Function which will be called by 2key campaigns if user wants to withdraw his earnings in stableCoins\n     *\n     * @param           _twoKeyUnits is the amount of 2key tokens which will be taken from campaign\n     * @param           _beneficiary is the user who will receive the tokens\n     */\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    public\n    onlyValidatedContracts\n    {\n        ERC20 dai = ERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"DAI\"));\n        ERC20 token = ERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy));\n\n        uint contractId = getContractId(msg.sender); // Get the contract ID\n\n        uint stableCoinUnits = getUSDStableCoinAmountFrom2keyUnits(_twoKeyUnits, contractId); // Calculate how much stable coins he's getting\n        uint etherBalanceOnContractBefore = this.balance; // get ether balance on contract\n        uint stableCoinsOnContractBefore = dai.balanceOf(address(this)); // get dai balance on contract\n\n        reduceDaiWeiAvailableToWithdraw(msg.sender, stableCoinUnits); // reducing amount of DAI available for withdrawal\n\n        emitEventWithdrawExecuted(\n            _beneficiary,\n            stableCoinsOnContractBefore,\n            stableCoinsOnContractBefore.sub(stableCoinUnits),\n            etherBalanceOnContractBefore,\n            stableCoinUnits,\n            _twoKeyUnits\n        );\n\n        token.transferFrom(msg.sender, address(this), _twoKeyUnits); //Take all 2key tokens from campaign contract\n        payFeesToManagerAndTransferTokens(_beneficiary, contractId, stableCoinUnits, dai);\n    }\n\n\n    /**\n     * @notice          Function to return number of campaign contracts (different) interacted with this contract\n     */\n    function numberOfContracts()\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"numberOfContracts\"));\n    }\n\n\n    /**\n     * @notice          Function to get 2key to DAI hedged rate\n     *\n     * @param           _contractID is the ID of the contract we're fetching this rate (avg)\n     */\n    function get2KEY2DAIHedgedRate(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getEth2DaiAverageExchangeRatePerContract(_contractID).mul(10**18).div(getEth2KeyAverageRatePerContract(_contractID));\n    }\n\n    /**\n     * @notice          Function to get Eth2DAI average exchange rate per contract\n     *\n     * @param           _contractID is the ID of the contract we're requesting information\n     */\n    function getEth2DaiAverageExchangeRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint)\n    {\n        uint ethWeiHedgedPerContractByNow = ethWeiHedgedPerContract(_contractID); //total hedged\n        uint daiWeiReceivedFromHedgingPerContractByNow = daiWeiReceivedFromHedgingPerContract(_contractID); //total received\n        // Average weighted by eth\n        return daiWeiReceivedFromHedgingPerContractByNow.mul(10**18).div(ethWeiHedgedPerContractByNow); //dai/eth\n    }\n\n\n    /**\n     * @notice          Function to get Eth22key average exchange rate per contract\n     *\n     * @param           _contractID is the ID of the contract we're requesting information\n     */\n    function getEth2KeyAverageRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint)\n    {\n        uint ethReceivedFromContractByNow = ethReceivedFromContract(_contractID);\n        uint sent2keyToContractByNow = sent2keyToContract(_contractID);\n        if(sent2keyToContractByNow == 0 || ethReceivedFromContractByNow == 0) {\n            return 0;\n        }\n        // Average weighted by eth 2key/eth\n        return sent2keyToContractByNow.mul(10**18).div(ethReceivedFromContractByNow);\n    }\n\n\n    /**\n     * @notice          Function to check how much dai is available to fill reserve\n     */\n    function daiWeiAvailableToFill2KEYReserve()\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"daiWeiAvailableToFill2KEYReserve\"));\n    }\n\n\n    /**\n     * @notice          Getter for mapping \"daiWeiAvailableToWithdraw\" (per contract)\n     */\n    function daiWeiAvailableToWithdraw(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"daiWeiAvailableToWithdraw\", _contractID));\n    }\n\n\n    /**\n     * @notice          Getter for \"mapping\" ethWeiAvailableToHedge (per contract)\n     */\n    function ethWeiAvailableToHedge(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"ethWeiAvailableToHedge\", _contractID));\n    }\n\n\n    /**\n     * @notice          Getter wrapping all information about income/outcome for every contract\n     * @param           _contractAddress is the main campaign address\n     */\n    function getAllStatsForContract(\n        address _contractAddress\n    )\n    public\n    view\n    returns (uint,uint,uint,uint,uint,uint)\n    {\n        uint _contractID = getContractId(_contractAddress);\n        return (\n            ethWeiAvailableToHedge(_contractID),\n            daiWeiAvailableToWithdraw(_contractID),\n            daiWeiReceivedFromHedgingPerContract(_contractID),\n            ethWeiHedgedPerContract(_contractID),\n            sent2keyToContract(_contractID),\n            ethReceivedFromContract(_contractID)\n        );\n    }\n\n\n    /**\n     * @notice          Getter function to check if campaign has been hedged ever\n     *                  Assuming that this function regarding flow will be called at point where there must be\n     *                  executed conversions, and in that case, if there are no any ETH received from contract,\n     *                  that means that this campaign is not hedgeable\n     *\n     * @param           _contractAddress is the campaign address\n     */\n    function isCampaignHedgeable(\n        address _contractAddress\n    )\n    public\n    view\n    returns (bool)\n    {\n        uint _contractID = getContractId(_contractAddress);\n        return ethReceivedFromContract(_contractID) > 0 ? true : false;\n    }\n\n\n    /**\n     * @notice          Function to get contract address from it's ID\n     * @param           contractID is the ID assigned to contract\n     */\n    function getContractAddressFromID(\n        uint contractID\n    )\n    internal\n    view\n    returns (address)\n    {\n        return getAddress(keccak256(\"idToContractAddress\", contractID));\n    }\n\n\n    /**\n     * @notice          Getter to check how much is pool worth in USD\n     */\n    function poolWorthUSD(\n        uint amountOfTokensInThePool,\n        uint averagePriceFrom3MainSources\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return (averagePriceFrom3MainSources.mul(amountOfTokensInThePool).div(10 ** 18));\n    }\n\n\n    /**\n     * @notice          Getter to get spreadWei value\n     */\n    function spreadWei()\n    internal\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(\"spreadWei\"));\n    }\n\n    /**\n     * @notice          Function to be used to fetch 2KEY-DAI rate from uniswap\n     * @notice          amountToSwap is in wei value\n     * @param           path is the path of swap (TOKEN_A - TOKEN_B) or (TOKEN_A - WETH - TOKEN_B)\n     */\n    function uniswapPriceDiscover(\n        address uniswapRouter,\n        uint amountToSwap,\n        address [] path\n    )\n    public\n    view\n    returns (uint)\n    {\n        uint[] memory amountsOut = new uint[](2);\n\n        amountsOut = IUniswapV2Router02(uniswapRouter).getAmountsOut(\n            amountToSwap,\n            path\n        );\n\n        return amountsOut[1];\n    }\n\n    /**\n     * @notice          Getter for 2key sell rate\n     */\n    function sellRate2key()\n    public\n    view\n    returns (uint)\n    {\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(_twoKeyExchangeRateContract);\n\n        address [] memory path = new address[](2);\n        address uniswapRouter = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"UniswapV2Router02\");\n\n        path[0] = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n        path[1] = IUniswapV2Router02(uniswapRouter).WETH();\n\n        // Represents how much 1 2KEY is worth ETH\n        uint rateFromUniswap = uniswapPriceDiscover(uniswapRouter, 10 ** 18, path);\n\n        // Rate from ETH-USD oracle\n        uint eth_usdRate = ITwoKeyExchangeRateContract(getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\"))\n            .getBaseToTargetRate(\"USD\");\n\n\n        // Rate computed by combination of ChainLink oracle (ETH-USD) and Uniswap (2KEY-ETH)\n\n        // Which will represent final 2KEY-USD rate\n        uint finalRate = rateFromUniswap.mul(eth_usdRate).div(10**18);\n\n        uint rateFromContract = getUint(keccak256(\"sellRate2key\"));\n\n        return (finalRate.add(rateFromContract)).div(2);\n    }\n\n\n    function withdrawDAIAvailableToFill2KEYReserve(\n        uint amountOfDAI\n    )\n    public\n    onlyTwoKeyAdmin\n    returns (uint)\n    {\n        uint daiWeiAvailableToFill2keyReserve = daiWeiAvailableToFill2KEYReserve();\n        if(amountOfDAI == 0) {\n            amountOfDAI = daiWeiAvailableToFill2keyReserve;\n        } else {\n            require(amountOfDAI <= daiWeiAvailableToFill2keyReserve);\n        }\n\n        ERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"DAI\")).transfer(msg.sender, amountOfDAI);\n        bytes32 key = keccak256(\"daiWeiAvailableToFill2KEYReserve\");\n\n        // Set that there's not DAI to fill reserve anymore\n        setUint(key, daiWeiAvailableToFill2keyReserve.sub(amountOfDAI));\n\n        // Return how much have been withdrawn\n        return amountOfDAI;\n    }\n\n    /**\n     * @notice          Function to get amount of 2KEY receiving, new token price, and average price per token\n     *i\n     * @param           purchaseAmountUSDWei is the amount of USD user is spending to buy tokens\n     */\n    function get2KEYTokenPriceAndAmountOfTokensReceiving(\n        uint purchaseAmountUSDWei\n    )\n    public\n    view\n    returns (uint,uint,uint)\n    {\n        uint currentPrice = sellRate2key();\n\n        // In case 0 USD is inputted, return 0 as bought, and current price as average and new.\n        if(purchaseAmountUSDWei == 0) {\n            return (0, currentPrice, currentPrice);\n        }\n\n        uint balanceOfTokens = getPoolBalanceOf2KeyTokens();\n\n        return PriceDiscovery.buyTokensFromExchangeRealignPrice(\n            purchaseAmountUSDWei,\n            currentPrice,\n            balanceOfTokens,\n            poolWorthUSD(balanceOfTokens, currentPrice)\n        );\n    }\n\n\n    function getPoolBalanceOf2KeyTokens()\n    internal\n    view\n    returns (uint)\n    {\n        address tokenAddress = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n        return ERC20(tokenAddress).balanceOf(address(this));\n    }\n\n\n    /**\n     * @notice          Fallback function to handle incoming ether\n     */\n    function()\n    public\n    payable\n    {\n\n    }\n\n}\n\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"amountSrcWei\",\"type\":\"uint256\"},{\"name\":\"srcToken\",\"type\":\"address\"},{\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getKyberExpectedRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"purchaseAmountUSDWei\",\"type\":\"uint256\"}],\"name\":\"get2KEYTokenPriceAndAmountOfTokensReceiving\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractID\",\"type\":\"uint256\"}],\"name\":\"get2KEY2DAIHedgedRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"calculateSumOnContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractID\",\"type\":\"uint256\"}],\"name\":\"getEth2KeyAverageRatePerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stableCoinAddresses\",\"type\":\"address[]\"}],\"name\":\"getAvailableAmountToFillReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountToBeSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeyUnits\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyStableCoinWith2key\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_2keyAmount\",\"type\":\"uint256\"},{\"name\":\"_campaignID\",\"type\":\"uint256\"}],\"name\":\"getUSDStableCoinAmountFrom2keyUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"buyTokensWithERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numberOfContractsCurrently\",\"type\":\"uint256\"},{\"name\":\"amountHedged\",\"type\":\"uint256\"},{\"name\":\"stableCoinsReceived\",\"type\":\"uint256\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"calculateHedgedAndReceivedForDefinedChunk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethWeiHedgedForThisChunk\",\"type\":\"uint256\"},{\"name\":\"_daiReceivedForThisChunk\",\"type\":\"uint256\"},{\"name\":\"_ratio\",\"type\":\"uint256\"},{\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"name\":\"_endIndex\",\"type\":\"uint256\"}],\"name\":\"reduceHedgedAmountFromContractsAndIncreaseDaiAvailable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokensRequested\",\"type\":\"uint256\"}],\"name\":\"getMore2KeyTokensForRebalancingV1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToBeHedged\",\"type\":\"uint256\"},{\"name\":\"approvedMinConversionRate\",\"type\":\"uint256\"}],\"name\":\"startHedging\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"getAllStatsForContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractID\",\"type\":\"uint256\"}],\"name\":\"getEth2DaiAverageExchangeRatePerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractID\",\"type\":\"uint256\"}],\"name\":\"ethWeiAvailableToHedge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellRate2key\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokensWithdrawn\",\"type\":\"uint256\"}],\"name\":\"report2KEYWithdrawnFromNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiWeiAvailableToFill2KEYReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractID\",\"type\":\"uint256\"}],\"name\":\"daiWeiAvailableToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseAllDAIFromContractToReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokensToReturn\",\"type\":\"uint256\"}],\"name\":\"returnTokensBackToExchangeV1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfDAI\",\"type\":\"uint256\"}],\"name\":\"withdrawDAIAvailableToFill2KEYReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"isCampaignHedgeable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_daiAddress\",\"type\":\"address\"},{\"name\":\"_kyberNetworkProxyAddress\",\"type\":\"address\"},{\"name\":\"_twoKeySingletonesRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorageContract\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uniswapRouter\",\"type\":\"address\"},{\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"uniswapPriceDiscover\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stableCoinsAddresses\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"swapStableCoinsAvailableToFillReserveFor2KEY\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"getContractId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stableCoinsReserveBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stableCoinsReserveAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherBalanceBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherBalanceAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stableCoinsToWithdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"twoKeyAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_daisReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_numberOfContracts\",\"type\":\"uint256\"}],\"name\":\"HedgedEther\",\"type\":\"event\"}]","ContractName":"TwoKeyUpgradableExchange","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"PriceDiscovery:6b1367b4fde82224b25e8162f023bf4a4a8c8094","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}