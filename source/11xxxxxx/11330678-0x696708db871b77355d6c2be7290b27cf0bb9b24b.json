{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/LinkswapFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/ILinkswapFactory.sol\\\";\\nimport \\\"./interfaces/ILinkswapPriceOracle.sol\\\";\\nimport \\\"./libraries/SafeMathLinkswap.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./LinkswapPair.sol\\\";\\n\\ncontract LinkswapFactory is ILinkswapFactory, ReentrancyGuard {\\n    using SafeMathLinkswap for uint256;\\n\\n    address public immutable override LINK;\\n    address public immutable override WETH;\\n    address public immutable override YFL;\\n\\n    address public override governance;\\n    address public override treasury;\\n    address public override priceOracle;\\n    uint256 public override linkListingFeeInUsd;\\n    uint256 public override wethListingFeeInUsd;\\n    uint256 public override yflListingFeeInUsd;\\n    uint256 public override treasuryListingFeeShare = 1000000;\\n    uint256 public override minListingLockupAmountInUsd;\\n    uint256 public override targetListingLockupAmountInUsd;\\n    uint256 public override minListingLockupPeriod;\\n    uint256 public override targetListingLockupPeriod;\\n    uint256 public override lockupAmountListingFeeDiscountShare;\\n    uint256 public override defaultLinkTradingFeePercent = 2500; // 0.2500%\\n    uint256 public override defaultNonLinkTradingFeePercent = 3000; // 0.3000%\\n    uint256 public override treasuryProtocolFeeShare = 1000000; // 100%\\n    uint256 public override protocolFeeFractionInverse; // protocol fee off initially\\n    uint256 public override maxSlippagePercent;\\n    uint256 public override maxSlippageBlocks = 1;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    mapping(address => mapping(address => bool)) public override approvedPair;\\n    address[] public override allPairs;\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == governance);\\n        _;\\n    }\\n\\n    constructor(\\n        address _governance,\\n        address _treasury,\\n        address _priceOracle,\\n        uint256 _linkListingFeeInUsd,\\n        uint256 _wethListingFeeInUsd,\\n        uint256 _yflListingFeeInUsd,\\n        uint256 _treasuryListingFeeShare,\\n        uint256 _minListingLockupAmountInUsd,\\n        uint256 _targetListingLockupAmountInUsd,\\n        uint256 _minListingLockupPeriod,\\n        uint256 _targetListingLockupPeriod,\\n        uint256 _lockupAmountListingFeeDiscountShare,\\n        address _linkToken,\\n        address _WETH,\\n        address _yflToken\\n    ) public {\\n        governance = _governance;\\n        treasury = _treasury;\\n        priceOracle = _priceOracle;\\n        linkListingFeeInUsd = _linkListingFeeInUsd;\\n        wethListingFeeInUsd = _wethListingFeeInUsd;\\n        yflListingFeeInUsd = _yflListingFeeInUsd;\\n        treasuryListingFeeShare = _treasuryListingFeeShare;\\n        _setTargetListingLockupAmountInUsd(_targetListingLockupAmountInUsd);\\n        _setMinListingLockupAmountInUsd(_minListingLockupAmountInUsd);\\n        _setTargetListingLockupPeriod(_targetListingLockupPeriod);\\n        _setMinListingLockupPeriod(_minListingLockupPeriod);\\n        lockupAmountListingFeeDiscountShare = _lockupAmountListingFeeDiscountShare;\\n        LINK = _linkToken;\\n        WETH = _WETH;\\n        YFL = _yflToken;\\n    }\\n\\n    function allPairsLength() external view override returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    function _validatePair(address tokenA, address tokenB) private view returns (address token0, address token1) {\\n        require(tokenA != tokenB);\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0));\\n        require(getPair[token0][token1] == address(0)); // single check is sufficient\\n    }\\n\\n    function _createPair(address token0, address token1) private returns (address pair) {\\n        {\\n            bytes memory bytecode = type(LinkswapPair).creationCode;\\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n            assembly {\\n                pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n            }\\n        }\\n        LinkswapPair(pair).initialize(\\n            token0,\\n            token1,\\n            token0 == address(LINK) || token1 == address(LINK)\\n                ? defaultLinkTradingFeePercent\\n                : defaultNonLinkTradingFeePercent\\n        );\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function approvePairViaGovernance(address tokenA, address tokenB) external override onlyGovernance nonReentrant {\\n        (address token0, address token1) = _validatePair(tokenA, tokenB);\\n        approvedPair[token0][token1] = true;\\n    }\\n\\n    function _payListingFee(\\n        address listingFeeToken,\\n        uint256 lockupAmountInUsd,\\n        uint256 lockupPeriod\\n    ) private {\\n        require(listingFeeToken == LINK || listingFeeToken == WETH || listingFeeToken == YFL);\\n        uint256 listingFeeTokenAmount;\\n        if (listingFeeToken == LINK) {\\n            listingFeeTokenAmount = ILinkswapPriceOracle(priceOracle).calculateTokenAmountFromUsdAmount(\\n                LINK,\\n                linkListingFeeInUsd\\n            );\\n        } else if (listingFeeToken == WETH) {\\n            listingFeeTokenAmount = ILinkswapPriceOracle(priceOracle).calculateTokenAmountFromUsdAmount(\\n                WETH,\\n                wethListingFeeInUsd\\n            );\\n        } else if (listingFeeToken == YFL) {\\n            ILinkswapPriceOracle(priceOracle).update();\\n            listingFeeTokenAmount = ILinkswapPriceOracle(priceOracle).calculateTokenAmountFromUsdAmount(\\n                YFL,\\n                yflListingFeeInUsd\\n            );\\n        }\\n        uint256 discount;\\n        if (targetListingLockupAmountInUsd > minListingLockupAmountInUsd) {\\n            discount =\\n                lockupAmountListingFeeDiscountShare.mul(lockupAmountInUsd.sub(minListingLockupAmountInUsd)) /\\n                (targetListingLockupAmountInUsd.sub(minListingLockupAmountInUsd));\\n        }\\n        if (targetListingLockupPeriod > minListingLockupPeriod) {\\n            discount = discount.add(\\n                (uint256(1000000).sub(lockupAmountListingFeeDiscountShare)).mul(\\n                    lockupPeriod.sub(minListingLockupPeriod)\\n                ) / (targetListingLockupPeriod.sub(minListingLockupPeriod))\\n            );\\n        }\\n        uint256 discountedListingFeeTokenAmount = listingFeeTokenAmount.mul(uint256(1000000).sub(discount)) / 1000000;\\n        TransferHelper.safeTransferFrom(\\n            listingFeeToken,\\n            msg.sender,\\n            treasury,\\n            discountedListingFeeTokenAmount.mul(treasuryListingFeeShare) / 1000000\\n        );\\n        TransferHelper.safeTransferFrom(\\n            listingFeeToken,\\n            msg.sender,\\n            governance,\\n            discountedListingFeeTokenAmount.mul(uint256(1000000).sub(treasuryListingFeeShare)) / 1000000\\n        );\\n    }\\n\\n    function createPair(\\n        address newToken,\\n        uint256 newTokenAmount,\\n        address lockupToken, // LINK or WETH, or part of a governance-approved pair\\n        uint256 lockupTokenAmount,\\n        uint256 lockupPeriod,\\n        address listingFeeToken // can be zero address if governance-approved pair\\n    ) external override nonReentrant returns (address pair) {\\n        require(msg.sender != governance);\\n        require(newToken != address(0) && lockupToken != address(0));\\n        (address token0, address token1) = _validatePair(newToken, lockupToken);\\n        if (!approvedPair[token0][token1]) {\\n            require(lockupToken == LINK || lockupToken == WETH);\\n            require(lockupPeriod >= minListingLockupPeriod);\\n            uint256 lockupAmountInUsd = ILinkswapPriceOracle(priceOracle).calculateUsdAmountFromTokenAmount(\\n                lockupToken,\\n                lockupTokenAmount\\n            );\\n            require(lockupAmountInUsd >= minListingLockupAmountInUsd);\\n            _payListingFee(listingFeeToken, lockupAmountInUsd, lockupPeriod);\\n        }\\n        pair = _createPair(token0, token1);\\n        if (!approvedPair[token0][token1] && lockupTokenAmount > 0 && lockupPeriod > 0) {\\n            TransferHelper.safeTransferFrom(newToken, msg.sender, pair, newTokenAmount);\\n            TransferHelper.safeTransferFrom(lockupToken, msg.sender, pair, lockupTokenAmount);\\n            uint256 liquidity = LinkswapPair(pair).mint(msg.sender);\\n            LinkswapPair(pair).listingLock(msg.sender, lockupPeriod, liquidity);\\n        }\\n    }\\n\\n    function setPriceOracle(address _priceOracle) external override onlyGovernance {\\n        priceOracle = _priceOracle;\\n    }\\n\\n    function setTreasury(address _treasury) external override onlyGovernance {\\n        treasury = _treasury;\\n    }\\n\\n    function setGovernance(address _governance) external override onlyGovernance {\\n        require(_governance != address(0));\\n        governance = _governance;\\n    }\\n\\n    function setTreasuryProtocolFeeShare(uint256 _treasuryProtocolFeeShare) external override onlyGovernance {\\n        require(_treasuryProtocolFeeShare <= 1000000);\\n        treasuryProtocolFeeShare = _treasuryProtocolFeeShare;\\n    }\\n\\n    function setProtocolFeeFractionInverse(uint256 _protocolFeeFractionInverse) external override onlyGovernance {\\n        // max 50% of trading fee (2/1 * 1000)\\n        require(_protocolFeeFractionInverse >= 2000 || _protocolFeeFractionInverse == 0);\\n        protocolFeeFractionInverse = _protocolFeeFractionInverse;\\n    }\\n\\n    function setLinkListingFeeInUsd(uint256 _linkListingFeeInUsd) external override onlyGovernance {\\n        linkListingFeeInUsd = _linkListingFeeInUsd;\\n    }\\n\\n    function setWethListingFeeInUsd(uint256 _wethListingFeeInUsd) external override onlyGovernance {\\n        wethListingFeeInUsd = _wethListingFeeInUsd;\\n    }\\n\\n    function setYflListingFeeInUsd(uint256 _yflListingFeeInUsd) external override onlyGovernance {\\n        yflListingFeeInUsd = _yflListingFeeInUsd;\\n    }\\n\\n    function setTreasuryListingFeeShare(uint256 _treasuryListingFeeShare) external override onlyGovernance {\\n        require(_treasuryListingFeeShare <= 1000000);\\n        treasuryListingFeeShare = _treasuryListingFeeShare;\\n    }\\n\\n    function _setMinListingLockupAmountInUsd(uint256 _minListingLockupAmountInUsd) private {\\n        require(_minListingLockupAmountInUsd <= targetListingLockupAmountInUsd);\\n        if (_minListingLockupAmountInUsd > 0) {\\n            // needs to be at least 1000 due to LinkswapPair MINIMUM_LIQUIDITY subtraction\\n            require(_minListingLockupAmountInUsd >= 1000);\\n        }\\n        minListingLockupAmountInUsd = _minListingLockupAmountInUsd;\\n    }\\n\\n    function setMinListingLockupAmountInUsd(uint256 _minListingLockupAmountInUsd) external override onlyGovernance {\\n        _setMinListingLockupAmountInUsd(_minListingLockupAmountInUsd);\\n    }\\n\\n    function _setTargetListingLockupAmountInUsd(uint256 _targetListingLockupAmountInUsd) private {\\n        require(_targetListingLockupAmountInUsd >= minListingLockupAmountInUsd);\\n        targetListingLockupAmountInUsd = _targetListingLockupAmountInUsd;\\n    }\\n\\n    function setTargetListingLockupAmountInUsd(uint256 _targetListingLockupAmountInUsd)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        _setTargetListingLockupAmountInUsd(_targetListingLockupAmountInUsd);\\n    }\\n\\n    function _setMinListingLockupPeriod(uint256 _minListingLockupPeriod) private {\\n        require(_minListingLockupPeriod <= targetListingLockupPeriod);\\n        minListingLockupPeriod = _minListingLockupPeriod;\\n    }\\n\\n    function setMinListingLockupPeriod(uint256 _minListingLockupPeriod) external override onlyGovernance {\\n        _setMinListingLockupPeriod(_minListingLockupPeriod);\\n    }\\n\\n    function _setTargetListingLockupPeriod(uint256 _targetListingLockupPeriod) private {\\n        require(_targetListingLockupPeriod >= minListingLockupPeriod);\\n        targetListingLockupPeriod = _targetListingLockupPeriod;\\n    }\\n\\n    function setTargetListingLockupPeriod(uint256 _targetListingLockupPeriod) external override onlyGovernance {\\n        _setTargetListingLockupPeriod(_targetListingLockupPeriod);\\n    }\\n\\n    function setLockupAmountListingFeeDiscountShare(uint256 _lockupAmountListingFeeDiscountShare)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        require(_lockupAmountListingFeeDiscountShare <= 1000000);\\n        lockupAmountListingFeeDiscountShare = _lockupAmountListingFeeDiscountShare;\\n    }\\n\\n    function setDefaultLinkTradingFeePercent(uint256 _defaultLinkTradingFeePercent) external override onlyGovernance {\\n        // max 1%\\n        require(_defaultLinkTradingFeePercent <= 10000);\\n        defaultLinkTradingFeePercent = _defaultLinkTradingFeePercent;\\n    }\\n\\n    function setDefaultNonLinkTradingFeePercent(uint256 _defaultNonLinkTradingFeePercent)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        // max 1%\\n        require(_defaultNonLinkTradingFeePercent <= 10000);\\n        defaultNonLinkTradingFeePercent = _defaultNonLinkTradingFeePercent;\\n    }\\n\\n    function setMaxSlippagePercent(uint256 _maxSlippagePercent) external override onlyGovernance {\\n        // max 100%\\n        require(_maxSlippagePercent <= 100);\\n        maxSlippagePercent = _maxSlippagePercent;\\n    }\\n\\n    function setMaxSlippageBlocks(uint256 _maxSlippageBlocks) external override onlyGovernance {\\n        // min 1 block, max 7 days (15s/block)\\n        require(_maxSlippageBlocks >= 1 && _maxSlippageBlocks <= 40320);\\n        maxSlippageBlocks = _maxSlippageBlocks;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/LinkswapPair.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./libraries/SafeMathLinkswap.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./interfaces/ILinkswapCallee.sol\\\";\\nimport \\\"./interfaces/ILinkswapFactory.sol\\\";\\nimport \\\"./interfaces/ILinkswapPair.sol\\\";\\n\\ncontract LinkswapPair is ILinkswapPair, ReentrancyGuard {\\n    using SafeMathLinkswap for uint256;\\n    using UQ112x112 for uint224;\\n\\n    string public constant override name = \\\"LinkSwap LP Token\\\";\\n    string public constant override symbol = \\\"LSLP\\\";\\n    uint8 public constant override decimals = 18;\\n    uint256 public override totalSupply;\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        public constant\\n        override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public override nonces;\\n\\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    mapping(address => uint256) public override addressToLockupExpiry;\\n    mapping(address => uint256) public override addressToLockupAmount;\\n\\n    address public override factory;\\n    address public override token0;\\n    address public override token1;\\n\\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint256 public override price0CumulativeLast;\\n    uint256 public override price1CumulativeLast;\\n    uint256 public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    uint256 public override tradingFeePercent; // need to divide by 1,000,000, e.g. 3000 = 0.3%\\n    uint256 public override lastSlippageBlocks;\\n    uint256 public override priceAtLastSlippageBlocks;\\n    uint256 public override lastSwapPrice;\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == ILinkswapFactory(factory).governance(), \\\"Pair: FORBIDDEN\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        factory = msg.sender;\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        uint256 _tradingFeePercent\\n    ) external override {\\n        require(msg.sender == factory, \\\"Pair: FORBIDDEN\\\"); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n        tradingFeePercent = _tradingFeePercent;\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, \\\"Pair: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"Pair: INVALID_SIGNATURE\\\");\\n        _approve(owner, spender, value);\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        override\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Pair: TRANSFER_FAILED\\\");\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    ) private {\\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), \\\"Pair: OVERFLOW\\\");\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\\n        uint256 protocolFeeFractionInverse = ILinkswapFactory(factory).protocolFeeFractionInverse();\\n        feeOn = protocolFeeFractionInverse != 0;\\n        uint256 _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint256 liquidity = totalSupply.mul(rootK.sub(rootKLast)).mul(1000) /\\n                        ((rootK.mul(protocolFeeFractionInverse.sub(1000))).add(rootKLast.mul(1000)));\\n                    if (liquidity > 0) {\\n                        ILinkswapFactory linkswapFactory = ILinkswapFactory(factory);\\n                        uint256 treasuryProtocolFeeShare = linkswapFactory.treasuryProtocolFeeShare();\\n                        _mint(linkswapFactory.treasury(), liquidity.mul(treasuryProtocolFeeShare) / 1000000);\\n                        _mint(\\n                            linkswapFactory.governance(),\\n                            liquidity.mul(uint256(1000000).sub(treasuryProtocolFeeShare)) / 1000000\\n                        );\\n                    }\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) public override nonReentrant returns (uint256 liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0.sub(_reserve0);\\n        uint256 amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n        }\\n        require(liquidity > 0, \\\"Pair: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    function _lock(\\n        address locker,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    ) private {\\n        if (lockupPeriod == 0 && liquidityLockupAmount == 0) return;\\n        if (addressToLockupExpiry[locker] == 0) {\\n            // not currently locked\\n            require(lockupPeriod > 0, \\\"Pair: ZERO_LOCKUP_PERIOD\\\");\\n            require(liquidityLockupAmount > 0, \\\"Pair: ZERO_LOCKUP_AMOUNT\\\");\\n            addressToLockupExpiry[locker] = block.timestamp.add(lockupPeriod);\\n        } else {\\n            // locking when already locked will extend lockup period\\n            addressToLockupExpiry[locker] = addressToLockupExpiry[locker].add(lockupPeriod);\\n        }\\n        addressToLockupAmount[locker] = addressToLockupAmount[locker].add(liquidityLockupAmount);\\n        _transfer(locker, address(this), liquidityLockupAmount);\\n        emit Lock(locker, lockupPeriod, liquidityLockupAmount);\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function listingLock(\\n        address lister,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    ) external override {\\n        require(msg.sender == factory, \\\"Pair: FORBIDDEN\\\");\\n        _lock(lister, lockupPeriod, liquidityLockupAmount);\\n    }\\n\\n    function lock(uint256 lockupPeriod, uint256 liquidityLockupAmount) external override {\\n        _lock(msg.sender, lockupPeriod, liquidityLockupAmount);\\n    }\\n\\n    function unlock() external override {\\n        require(addressToLockupExpiry[msg.sender] <= block.timestamp, \\\"Pair: BEFORE_EXPIRY\\\");\\n        _transfer(address(this), msg.sender, addressToLockupAmount[msg.sender]);\\n        emit Unlock(msg.sender, addressToLockupAmount[msg.sender]);\\n        addressToLockupAmount[msg.sender] = 0;\\n        addressToLockupExpiry[msg.sender] = 0;\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(amount0 > 0 && amount1 > 0, \\\"Pair: INSUFFICIENT_LIQUIDITY_BURNED\\\");\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override nonReentrant {\\n        require(amount0Out > 0 || amount1Out > 0, \\\"Pair: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \\\"Pair: INSUFFICIENT_LIQUIDITY\\\");\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(to != _token0 && to != _token1, \\\"Pair: INVALID_TO\\\");\\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length > 0) ILinkswapCallee(to).linkswapCall(msg.sender, amount0Out, amount1Out, data);\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n            if (ILinkswapFactory(factory).maxSlippagePercent() > 0) {\\n                uint256 currentPrice = balance0.mul(1e18) / balance1;\\n                if (priceAtLastSlippageBlocks == 0) {\\n                    priceAtLastSlippageBlocks = currentPrice;\\n                    lastSlippageBlocks = block.number;\\n                } else {\\n                    bool resetSlippage = lastSlippageBlocks.add(ILinkswapFactory(factory).maxSlippageBlocks()) <\\n                        block.number;\\n                    uint256 lastPrice = resetSlippage ? lastSwapPrice : priceAtLastSlippageBlocks;\\n                    require(\\n                        currentPrice >=\\n                            lastPrice.mul(uint256(100).sub(ILinkswapFactory(factory).maxSlippagePercent())) / 100 &&\\n                            currentPrice <=\\n                            lastPrice.mul(uint256(100).add(ILinkswapFactory(factory).maxSlippagePercent())) / 100,\\n                        \\\"Pair: SlipLock\\\"\\n                    );\\n                    if (resetSlippage) {\\n                        priceAtLastSlippageBlocks = currentPrice;\\n                        lastSlippageBlocks = block.number;\\n                    }\\n                }\\n                lastSwapPrice = currentPrice;\\n            }\\n        }\\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, \\\"Pair: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        {\\n            // scope for balance{0,1}Adjusted, avoids stack too deep errors\\n            uint256 balance0Adjusted = balance0.mul(1e6).sub(amount0In.mul(tradingFeePercent));\\n            uint256 balance1Adjusted = balance1.mul(1e6).sub(amount1In.mul(tradingFeePercent));\\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1e6**2), \\\"Pair: K\\\");\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override nonReentrant {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override nonReentrant {\\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\\n    }\\n\\n    function _setTradingFeePercent(uint256 _tradingFeePercent) private {\\n        // max 1%\\n        require(_tradingFeePercent <= 10000, \\\"Pair: INVALID_TRADING_FEE_PERCENT\\\");\\n        tradingFeePercent = _tradingFeePercent;\\n    }\\n\\n    function setTradingFeePercent(uint256 _tradingFeePercent) external override onlyGovernance {\\n        _setTradingFeePercent(_tradingFeePercent);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/interfaces/ILinkswapCallee.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ILinkswapCallee {\\n    function linkswapCall(\\n        address sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/interfaces/ILinkswapERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ILinkswapERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/interfaces/ILinkswapFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ILinkswapFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256 pairNum);\\n\\n    function LINK() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function YFL() external view returns (address);\\n\\n    function governance() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function priceOracle() external view returns (address);\\n\\n    // USD amounts should be 8 dp precision\\n    // frontend should approve transfer of higher amount (e.g. 1.1x) due to price fluctuations\\n    function linkListingFeeInUsd() external view returns (uint256);\\n\\n    function wethListingFeeInUsd() external view returns (uint256);\\n\\n    function yflListingFeeInUsd() external view returns (uint256);\\n\\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\\n    // the rest goes to governance\\n    function treasuryListingFeeShare() external view returns (uint256);\\n\\n    function minListingLockupAmountInUsd() external view returns (uint256);\\n\\n    // if lockup amount is set to this or more, the lockup amount proportion of listing fee discount is fully unlocked\\n    // if less than this amount, then lockup amount proportion of listing fee discount is linearly interpolated from the distance between min and target lockup amounts e.g. 60% towards target from min means 60% of lockup amount discount\\n    function targetListingLockupAmountInUsd() external view returns (uint256);\\n\\n    // in seconds since unix epoch\\n    // min lockup period for the listing lockup amount\\n    function minListingLockupPeriod() external view returns (uint256);\\n\\n    // in seconds since unix epoch\\n    // if lockup period is set to this or longer, the lockup time proportion of listing fee discount is fully unlocked\\n    // if less than this period, then lockup time proportion of listing fee discount is linearly interpolated from the distance between min and target lockup times e.g. 60% towards target from min means 60% of lockup time discount\\n    function targetListingLockupPeriod() external view returns (uint256);\\n\\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\\n    // rest of listing fee discount is determined by lockup period\\n    function lockupAmountListingFeeDiscountShare() external view returns (uint256);\\n\\n    // need to divide fee percents by 1,000,000 e.g. 3000 is 0.3000%\\n    function defaultLinkTradingFeePercent() external view returns (uint256);\\n\\n    function defaultNonLinkTradingFeePercent() external view returns (uint256);\\n\\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\\n    // the rest goes to governance\\n    function treasuryProtocolFeeShare() external view returns (uint256);\\n\\n    // inverse of protocol fee fraction, then multiplied by 1000.\\n    // e.g. if protocol fee is 3/7th of trading fee, then value = 7/3 * 1000 = 2333\\n    // set to 0 to disable protocol fee\\n    function protocolFeeFractionInverse() external view returns (uint256);\\n\\n    // need to divide by 100 e.g. 50 is 50%\\n    function maxSlippagePercent() external view returns (uint256);\\n\\n    // max slippage resets after this many blocks\\n    function maxSlippageBlocks() external view returns (uint256);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function approvedPair(address tokenA, address tokenB) external view returns (bool approved);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function approvePairViaGovernance(address tokenA, address tokenB) external;\\n\\n    function createPair(\\n        address newToken,\\n        uint256 newTokenAmount,\\n        address lockupToken, // LINK or WETH\\n        uint256 lockupTokenAmount,\\n        uint256 lockupPeriod,\\n        address listingFeeToken\\n    ) external returns (address pair);\\n\\n    function setPriceOracle(address) external;\\n\\n    function setTreasury(address) external;\\n\\n    function setGovernance(address) external;\\n\\n    function setTreasuryProtocolFeeShare(uint256) external;\\n\\n    function setProtocolFeeFractionInverse(uint256) external;\\n\\n    function setLinkListingFeeInUsd(uint256) external;\\n\\n    function setWethListingFeeInUsd(uint256) external;\\n\\n    function setYflListingFeeInUsd(uint256) external;\\n\\n    function setTreasuryListingFeeShare(uint256) external;\\n\\n    function setMinListingLockupAmountInUsd(uint256) external;\\n\\n    function setTargetListingLockupAmountInUsd(uint256) external;\\n\\n    function setMinListingLockupPeriod(uint256) external;\\n\\n    function setTargetListingLockupPeriod(uint256) external;\\n\\n    function setLockupAmountListingFeeDiscountShare(uint256) external;\\n\\n    function setDefaultLinkTradingFeePercent(uint256) external;\\n\\n    function setDefaultNonLinkTradingFeePercent(uint256) external;\\n\\n    function setMaxSlippagePercent(uint256) external;\\n\\n    function setMaxSlippageBlocks(uint256) external;\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/interfaces/ILinkswapPair.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./ILinkswapERC20.sol\\\";\\n\\ninterface ILinkswapPair is ILinkswapERC20 {\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Lock(address indexed sender, uint256 lockupPeriod, uint256 liquidityLockupAmount);\\n    event Unlock(address indexed sender, uint256 liquidityUnlocked);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function addressToLockupExpiry(address) external view returns (uint256);\\n\\n    function addressToLockupAmount(address) external view returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function tradingFeePercent() external view returns (uint256);\\n\\n    function lastSlippageBlocks() external view returns (uint256);\\n\\n    function priceAtLastSlippageBlocks() external view returns (uint256);\\n\\n    function lastSwapPrice() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function lock(uint256 lockupPeriod, uint256 liquidityLockupAmount) external;\\n\\n    function unlock() external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function setTradingFeePercent(uint256 _tradingFeePercent) external;\\n\\n    // functions only callable by LinkswapFactory\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        uint256 _tradingFeePercent\\n    ) external;\\n\\n    function listingLock(\\n        address lister,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/interfaces/ILinkswapPriceOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ILinkswapPriceOracle {\\n    function update() external;\\n\\n    // tokenAmount is to 18 dp, usdAmount is to 8 dp\\n    // token must be LINK / WETH / YFL\\n    function calculateTokenAmountFromUsdAmount(address token, uint256 usdAmount)\\n        external\\n        view\\n        returns (uint256 tokenAmount);\\n\\n    // token must be LINK / WETH\\n    function calculateUsdAmountFromTokenAmount(address token, uint256 tokenAmount)\\n        external\\n        view\\n        returns (uint256 usdAmount);\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/libraries/SafeMathLinkswap.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMathLinkswap {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper: ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/kroll/Dev/LinkDeployment1/contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_linkListingFeeInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wethListingFeeInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_yflListingFeeInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryListingFeeShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minListingLockupAmountInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupAmountInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minListingLockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockupAmountListingFeeDiscountShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_linkToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yflToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pairNum\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YFL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"approvePairViaGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lockupToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockupTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"listingFeeToken\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultLinkTradingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultNonLinkTradingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkListingFeeInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupAmountListingFeeDiscountShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippageBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippagePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minListingLockupAmountInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minListingLockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeFractionInverse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_defaultLinkTradingFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultLinkTradingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_defaultNonLinkTradingFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultNonLinkTradingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_linkListingFeeInUsd\",\"type\":\"uint256\"}],\"name\":\"setLinkListingFeeInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockupAmountListingFeeDiscountShare\",\"type\":\"uint256\"}],\"name\":\"setLockupAmountListingFeeDiscountShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippageBlocks\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippageBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippagePercent\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippagePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minListingLockupAmountInUsd\",\"type\":\"uint256\"}],\"name\":\"setMinListingLockupAmountInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minListingLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setMinListingLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"setPriceOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFeeFractionInverse\",\"type\":\"uint256\"}],\"name\":\"setProtocolFeeFractionInverse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupAmountInUsd\",\"type\":\"uint256\"}],\"name\":\"setTargetListingLockupAmountInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setTargetListingLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryListingFeeShare\",\"type\":\"uint256\"}],\"name\":\"setTreasuryListingFeeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryProtocolFeeShare\",\"type\":\"uint256\"}],\"name\":\"setTreasuryProtocolFeeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wethListingFeeInUsd\",\"type\":\"uint256\"}],\"name\":\"setWethListingFeeInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_yflListingFeeInUsd\",\"type\":\"uint256\"}],\"name\":\"setYflListingFeeInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetListingLockupAmountInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetListingLockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryListingFeeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryProtocolFeeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethListingFeeInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yflListingFeeInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LinkswapFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000389d755c1833c9b350d4e8b619eae16defc1cba000000000000000000000000e69a81b96fbf5cb6cae95d2ce5323eff2ba0eae4000000000000000000000000dfa5e7989c98446ffea622266e18df563e8598720000000000000000000000000000000000000000000000000000003a3529440000000000000000000000000000000000000000000000000000000045d964b8000000000000000000000000000000000000000000000000000000002e90edd00000000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000746a52880000000000000000000000000000000000000000000000000000000246139ca8000000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000007a120000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000028cb7e841ee97947a86b06fa4090c8451f64c0be","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}