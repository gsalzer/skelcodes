{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/IMultisigCarrier.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract IMultisigCarrier {\n\n    function vaultParties(\n        address vaultAddress\n    ) public view returns (address[] memory);\n\n    function approveFrom(\n        address caller,\n        address payable destination,\n        address currencyAddress,\n        uint256 amount\n    ) public returns (bool);\n\n}\n\n// File: contracts/MultisigVault.sol\n\npragma solidity ^0.5.0;\n\n\ncontract MultisigVault {\n\n    address private _carrier;\n\n    constructor() public {\n        _carrier = msg.sender;\n    }\n\n    function parties() public view returns (address[] memory) {\n        IMultisigCarrier multisigCarrier = IMultisigCarrier(_carrier);\n        return multisigCarrier.vaultParties(address(this));\n    }\n\n    function carrier() public view returns (address) {\n        return _carrier;\n    }\n\n    function approve(\n        address payable destination,\n        address currencyAddress,\n        uint256 amount\n    ) public returns (bool) {\n        IMultisigCarrier multisigCarrier = IMultisigCarrier(_carrier);\n        return multisigCarrier.approveFrom(msg.sender, destination, currencyAddress, amount);\n    }\n\n    function external_call(address destination, uint value, bytes memory data) public returns (bool) {\n        require(msg.sender == _carrier, \"Carriable: caller is not the carrier\");\n\n        bool result;\n        assembly {\n            let dataLength := mload(data)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n                destination,\n                value,\n                d,\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n                0,\n                0                  // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n\n    function () external payable {}\n}\n\n// File: contracts/MultisigCarrier.sol\n\npragma solidity ^0.5.0;\n\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract MultisigCarrier {\n\n    using SafeMath for uint256;\n\n    struct VaultInfo {\n        bool initiated;\n        uint8 signatureMinThreshold;\n        address[] parties;\n    }\n\n    struct Approval {\n        uint32 nonce;\n        uint8  coincieded;\n        bool   finished;\n        address[] parties;\n    }\n\n    uint32 private _nonce;\n    address private _owner;\n\n    mapping(\n        address => VaultInfo\n    ) private _vaultInfos;\n\n    mapping(\n        // MutlisigVault\n        address => mapping(\n            // Destination\n            address => mapping(\n                // Currency\n                address => mapping(\n                    // Amount\n                    uint256 => Approval\n                )\n            )\n        )\n    ) public _approvals;\n\n    mapping(uint256 => bool) public _finished;\n\n    event NewMultisigCarrierCreated(address multisigCarrierAddress);\n\n    /**\n      * @dev Construcor.\n      *\n      * Requirements:\n      * - `_signatureMinThreshold` .\n      * - `_parties`.\n      */\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Caller is not the owner\");\n        _;\n    }\n\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n\n    function createMultisigVault() public returns (address) {\n        MultisigVault multisigVault = new MultisigVault();\n        VaultInfo storage vaultInfo = _vaultInfos[address(multisigVault)];\n        vaultInfo.initiated = true;\n\n        emit NewMultisigCarrierCreated(address(multisigVault));\n\n        return address(multisigVault);\n    }\n\n\n    function setVaultInfo(\n        address vaultAddress,\n        uint8 signatureMinThreshold,\n        address[] memory parties\n    ) public onlyOwner() returns (bool) {\n        require(signatureMinThreshold > 0, \"Parties are already set\");\n        require(parties.length > 0 && parties.length <= 10, \"Minimum 1, maximum 10 parties\");\n        require(signatureMinThreshold <= parties.length, \"Min signatures mismatches parties array\");\n\n        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\n        vaultInfo.signatureMinThreshold = signatureMinThreshold;\n        vaultInfo.parties = parties;\n\n        return true;\n    }\n\n\n    function vaultParties(\n        address vaultAddress\n    ) public view returns (address[] memory) {\n        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\n        return vaultInfo.parties;\n    }\n\n\n    function approve(\n        address payable vaultAddress,\n        address payable destination,\n        address currencyAddress,\n        uint256 amount\n    ) public returns (bool) {\n        approveAndRelease(msg.sender, vaultAddress, destination, currencyAddress, amount);\n    }\n\n    function approveFrom(\n        address caller,\n        address payable destination,\n        address currencyAddress,\n        uint256 amount\n    ) public returns (bool) {\n        approveAndRelease(caller, msg.sender, destination, currencyAddress, amount);\n    }\n\n\n    function approveAndRelease(\n        address caller,\n        address payable vaultAddress,\n        address payable destination,\n        address currencyAddress,\n        uint256 amount\n    ) internal returns (bool) {\n        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\n\n        require(vaultInfo.initiated, \"Vault does not exist\");\n        require(containsParty(vaultInfo.parties, caller), \"Not a member\");\n\n        if (currencyAddress == etherAddress()) {\n            address multisig = address(vaultAddress);  // https://biboknow.com/page-ethereum/78597/solidity-0-6-0-addressthis-balance-throws-error-invalid-opcode\n            require(multisig.balance >= amount, \"Insufficient balance\");\n        } else {\n            require(IERC20(currencyAddress).balanceOf(address(vaultAddress)) >= amount, \"Insufficient balance\");\n        }\n\n        Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\n\n        require(!containsParty(approval.parties, caller), \"Party already approved\");\n\n        if (approval.coincieded == 0) {\n            _nonce += 1;\n            approval.nonce = _nonce;\n        }\n\n        approval.parties.push(caller);\n        approval.coincieded += 1;\n\n        if ( approval.coincieded >= vaultInfo.signatureMinThreshold ) {\n            _finished[approval.nonce] = true;\n            delete _approvals[vaultAddress][destination][currencyAddress][amount];\n\n            releaseFunds(vaultAddress, destination, currencyAddress, amount);\n        }\n\n        return false;\n    }\n\n\n    function getNonce(\n        address vaultAddress,\n        address destination,\n        address currencyAddress,\n        uint256 amount\n    ) public view returns (uint256) {\n        Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\n\n        return approval.nonce;\n    }\n\n\n    function partyCoincieded(\n        address vaultAddress,\n        address destination,\n        address currencyAddress,\n        uint256 amount,\n        uint256 nonce,\n        address partyAddress\n    ) public view returns (bool) {\n        if ( _finished[nonce] ) {\n          return true;\n        } else {\n          Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\n\n          require(approval.nonce == nonce, \"Nonce does not match\");\n\n          return containsParty(approval.parties, partyAddress);\n        }\n    }\n\n\n    function releaseFunds(\n        address payable vaultAddress,\n        address payable destination,\n        address currencyAddress,\n        uint256 amount\n    ) internal {\n        MultisigVault multisigVault = MultisigVault(vaultAddress);\n\n        if (currencyAddress == etherAddress()) {\n            multisigVault.external_call(destination, amount, \"\");\n        } else {\n            multisigVault.external_call(currencyAddress, 0, abi.encodeWithSelector(IERC20(currencyAddress).transfer.selector, destination, amount));\n        }\n    }\n\n\n    function containsParty(address[] memory parties, address party) internal pure returns (bool) {\n        for (uint256 i = 0; i < parties.length; i++) {\n          if ( parties[i] == party ) {\n            return true;\n          }\n        }\n\n        return false;\n    }\n\n\n    function etherAddress() public pure returns (address) {\n        return address(0x0);\n    }\n}\n","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"multisigCarrierAddress\",\"type\":\"address\"}],\"name\":\"NewMultisigCarrierCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_approvals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"coincieded\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_finished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createMultisigVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"partyAddress\",\"type\":\"address\"}],\"name\":\"partyCoincieded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"signatureMinThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"parties\",\"type\":\"address[]\"}],\"name\":\"setVaultInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"vaultParties\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultisigCarrier","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}