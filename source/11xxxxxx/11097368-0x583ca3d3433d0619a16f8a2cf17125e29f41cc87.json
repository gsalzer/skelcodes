{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title VersionedInitializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n *\r\n * @author Aave, inspired by the OpenZeppelin Initializable contract\r\n */\r\nabstract contract VersionedInitializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    uint256 private lastInitializedRevision;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initializer() {\r\n        uint256 revision = getRevision();\r\n        require(\r\n            initializing ||\r\n                isConstructor() ||\r\n                revision > lastInitializedRevision,\r\n            \"Contract instance has already been initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            lastInitializedRevision = revision;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns the revision number of the contract.\r\n    /// Needs to be defined in the inherited class as a constant.\r\n    function getRevision() internal virtual pure returns (uint256);\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            cs := extcodesize(address())\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[16] private ______gap;\r\n}\r\n\r\ncontract Ownable {\r\n    /** events */\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /** member */\r\n\r\n    address public owner;\r\n\r\n    /** constructor */\r\n\r\n    function initializeOwnable(address _owner) internal {\r\n        owner = _owner;\r\n    }\r\n\r\n    /** modifers */\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable.onlyOwner.EID00001\");\r\n        _;\r\n    }\r\n\r\n    /** functions */\r\n    \r\n    function transferOwnership(address _owner) public onlyOwner {\r\n        require(_owner != address(0), \"Ownable.transferOwnership.EID00090\");\r\n        emit OwnershipTransferred(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\ncontract Orderbase is Ownable, VersionedInitializable {\r\n    event Insert(address indexed owner, address indexed token, uint256 id);\r\n\r\n    struct hold_t {\r\n        address owner;\r\n        address token;\r\n    }\r\n    uint256 public size;\r\n    //id => hold_t\r\n    mapping(uint256 => hold_t) private _holds; //@_indexes start with 1\r\n    //owner => token => id;\r\n    mapping(address => mapping(address => uint256)) private _indexes;\r\n    //token => owners\r\n    mapping(address => address[]) private _owners;\r\n    //owner => tokens\r\n    mapping(address => address[]) private _tokens;\r\n\r\n    function getRevision() internal override pure returns (uint256) {\r\n        return uint256(0x1);\r\n    }\r\n\r\n    function initialize(address owner) public initializer {\r\n        Ownable.initializeOwnable(owner);\r\n    }\r\n\r\n    function insert(address _owner, address _token) public returns (uint256) {\r\n        uint256 _id = _indexes[_owner][_token];\r\n        if (_id == 0) {\r\n            ++size;\r\n            _holds[size] = hold_t(_owner, _token);\r\n            _indexes[_owner][_token] = size;\r\n            _owners[_token].push(_owner);\r\n            _tokens[_owner].push(_token);\r\n            emit Insert(_owner, _token, size);\r\n            return size;\r\n        }\r\n        return _id;\r\n    }\r\n    \r\n    function holder(uint256 id) public view returns (address, address) {\r\n        return (_holds[id].owner, _holds[id].token);\r\n    }\r\n\r\n    //csa-index\r\n    function index(address _owner, address _token) public view returns (uint256) {\r\n        return _indexes[_owner][_token];\r\n    }\r\n\r\n    function owners(\r\n        address token,\r\n        uint256 begin, //@begin start with 0\r\n        uint256 end\r\n    ) public view returns (address[] memory) {\r\n        address[] memory sources = _owners[token];\r\n        address[] memory values;\r\n        (uint256 _begin, uint256 _end) = (begin, end);\r\n\r\n        if (begin >= end) return values;\r\n        if (begin >= sources.length) return values;\r\n        if (_end > sources.length) {\r\n            _end = sources.length;\r\n        }\r\n\r\n        values = new address[](_end - begin);\r\n        uint256 i = 0;\r\n        for (; _begin != _end; ++_begin) {\r\n            values[i++] = sources[_begin];\r\n        }\r\n        return values;\r\n    }\r\n\r\n    function owners(address _token) public view returns (address[] memory) {\r\n        return _owners[_token];\r\n    }\r\n\r\n    function tokens(address _owner) public view returns (address[] memory) {\r\n        return _tokens[_owner];\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Insert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"holder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"insert\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"begin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Orderbase","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f67cf8b8f87b7a26e68227c5f3df33fed980ae6828c7d50f3ed505e031725ff6"}]}