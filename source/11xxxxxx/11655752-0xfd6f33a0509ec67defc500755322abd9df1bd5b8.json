{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.8\r\n\"\"\"\r\n@title Curve Factory\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Permissionless pool deployer and registry\r\n\"\"\"\r\n\r\nstruct PoolArray:\r\n    base_pool: address\r\n    coins: address[2]\r\n    decimals: uint256\r\n\r\nstruct BasePoolArray:\r\n    implementation: address\r\n    lp_token: address\r\n    coins: address[MAX_COINS]\r\n    decimals: uint256\r\n    n_coins: uint256\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_registry() -> address: view\r\n\r\ninterface Registry:\r\n    def get_lp_token(pool: address) -> address: view\r\n    def get_n_coins(pool: address) -> uint256: view\r\n    def get_coins(pool: address) -> address[MAX_COINS]: view\r\n\r\ninterface ERC20:\r\n    def balanceOf(_addr: address) -> uint256: view\r\n    def decimals() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n\r\ninterface CurvePool:\r\n    def A() -> uint256: view\r\n    def fee() -> uint256: view\r\n    def admin_fee() -> uint256: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def admin_balances(i: uint256) -> uint256: view\r\n    def get_virtual_price() -> uint256: view\r\n    def initialize(\r\n        _name: String[32],\r\n        _symbol: String[10],\r\n        _coin: address,\r\n        _decimals: uint256,\r\n        _A: uint256,\r\n        _fee: uint256,\r\n        _owner: address,\r\n    ): nonpayable\r\n\r\n\r\nevent BasePoolAdded:\r\n    base_pool: address\r\n    implementat: address\r\n\r\nevent MetaPoolDeployed:\r\n    coin: address\r\n    base_pool: address\r\n    A: uint256\r\n    fee: uint256\r\n    deployer: address\r\n\r\n\r\nMAX_COINS: constant(int128) = 8\r\nADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\n\r\npool_list: public(address[4294967296])   # master list of pools\r\npool_count: public(uint256)              # actual length of pool_list\r\npool_data: HashMap[address, PoolArray]\r\n\r\nbase_pool_list: public(address[4294967296])   # master list of pools\r\nbase_pool_count: public(uint256)         # actual length of pool_list\r\nbase_pool_data: HashMap[address, BasePoolArray]\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, address[4294967296]]\r\nmarket_counts: HashMap[uint256, uint256]\r\n\r\n\r\n@external\r\ndef __init__():\r\n    self.admin = msg.sender\r\n\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.markets[key][i]\r\n\r\n\r\n@view\r\n@external\r\ndef get_n_coins(_pool: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the number of coins in a pool\r\n    @param _pool Pool address\r\n    @return Number of wrapped coins, number of underlying coins\r\n    \"\"\"\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    return 2, self.base_pool_data[base_pool].n_coins + 1\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[2]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    return self.pool_data[_pool].coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the underlying coins within a pool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    coins[0] = self.pool_data[_pool].coins[0]\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    for i in range(1, MAX_COINS):\r\n        coins[i] = self.base_pool_data[base_pool].coins[i - 1]\r\n        if coins[i] == ZERO_ADDRESS:\r\n            break\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    decimals: uint256[2] = [0, 18]\r\n    decimals[0] = self.pool_data[_pool].decimals\r\n    return decimals\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each underlying coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\r\n    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals[0] = self.pool_data[_pool].decimals\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    packed_decimals: uint256 = self.base_pool_data[base_pool].decimals\r\n    for i in range(MAX_COINS):\r\n        unpacked: uint256 = shift(packed_decimals, -8 * i) % 256\r\n        if unpacked == 0:\r\n            break\r\n        decimals[i+1] = unpacked\r\n\r\n    return decimals\r\n\r\n\r\n@view\r\n@external\r\ndef get_rates(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get rates for coins within a pool\r\n    @param _pool Pool address\r\n    @return Rates for each coin, precision normalized to 10**18\r\n    \"\"\"\r\n    rates: uint256[2] = [10**18, 0]\r\n    rates[1] = CurvePool(self.pool_data[_pool].base_pool).get_virtual_price()\r\n    return rates\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return [CurvePool(_pool).balances(0), CurvePool(_pool).balances(1)]\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each underlying coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of underlying balances\r\n    \"\"\"\r\n\r\n    underlying_balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    underlying_balances[0] = CurvePool(_pool).balances(0)\r\n\r\n    base_total_supply: uint256 = ERC20(self.pool_data[_pool].coins[1]).totalSupply()\r\n    if base_total_supply > 0:\r\n        underlying_pct: uint256 = CurvePool(_pool).balances(1) * 10**36 / base_total_supply\r\n        base_pool: address = self.pool_data[_pool].base_pool\r\n        n_coins: uint256 = self.base_pool_data[base_pool].n_coins\r\n        for i in range(MAX_COINS):\r\n            if i == n_coins:\r\n                break\r\n            underlying_balances[i + 1] = CurvePool(base_pool).balances(i) * underlying_pct / 10**36\r\n\r\n    return underlying_balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_A(_pool: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the amplfication co-efficient for a pool\r\n    @param _pool Pool address\r\n    @return uint256 A\r\n    \"\"\"\r\n    return CurvePool(_pool).A()\r\n\r\n\r\n@view\r\n@external\r\ndef get_fees(_pool: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the fees for a pool\r\n    @dev Fees are expressed as integers\r\n    @return Pool fee as uint256 with 1e10 precision\r\n    \"\"\"\r\n    return CurvePool(_pool).fee(), CurvePool(_pool).admin_fee()\r\n\r\n\r\n@view\r\n@external\r\ndef get_admin_balances(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get the current admin balances (uncollected fees) for a pool\r\n    @param _pool Pool address\r\n    @return List of uint256 admin balances\r\n    \"\"\"\r\n    return [CurvePool(_pool).admin_balances(0), CurvePool(_pool).admin_balances(1)]\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (int128, int128, bool):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\r\n    \"\"\"\r\n    coin: address = self.pool_data[_pool].coins[0]\r\n    if coin in [_from, _to]:\r\n        base_lp_token: address = self.pool_data[_pool].coins[1]\r\n        if base_lp_token in [_from, _to]:\r\n            # True and False convert to 1 and 0 - a bit of voodoo that\r\n            # works because we only ever have 2 non-underlying coins\r\n            return convert(_to == coin, int128), convert(_from == coin, int128), False\r\n\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    found_market: bool = False\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    for x in range(MAX_COINS):\r\n        if x != 0:\r\n            coin = self.base_pool_data[base_pool].coins[x-1]\r\n        if coin == ZERO_ADDRESS:\r\n            raise \"No available market\"\r\n        if coin == _from:\r\n            i = x\r\n        elif coin == _to:\r\n            j = x\r\n        else:\r\n            continue\r\n        if found_market:\r\n            # the second time we find a match, break out of the loop\r\n            break\r\n        # the first time we find a match, set `found_market` to True\r\n        found_market = True\r\n\r\n    return i, j, True\r\n\r\n\r\n@external\r\ndef add_base_pool(\r\n    _base_pool: address,\r\n    _metapool_implementation: address,\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _base_pool Pool address to add\r\n    @param _metapool_implementation Implementation address to use when deploying metapools\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.base_pool_data[_base_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_base_pool)\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.base_pool_count\r\n    self.base_pool_list[length] = _base_pool\r\n    self.base_pool_count = length + 1\r\n    self.base_pool_data[_base_pool].implementation = _metapool_implementation\r\n    self.base_pool_data[_base_pool].lp_token = Registry(registry).get_lp_token(_base_pool)\r\n    self.base_pool_data[_base_pool].n_coins = n_coins\r\n\r\n    decimals: uint256 = 0\r\n    coins: address[MAX_COINS] = Registry(registry).get_coins(_base_pool)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coin: address = coins[i]\r\n        self.base_pool_data[_base_pool].coins[i] = coin\r\n        decimals += shift(ERC20(coin).decimals(), convert(i*8, int128))\r\n\r\n    self.base_pool_data[_base_pool].decimals = decimals\r\n\r\n    log BasePoolAdded(_base_pool, _metapool_implementation)\r\n\r\n\r\n@external\r\ndef deploy_metapool(\r\n    _base_pool: address,\r\n    _name: String[32],\r\n    _symbol: String[10],\r\n    _coin: address,\r\n    _A: uint256,\r\n    _fee: uint256,\r\n) -> address:\r\n    \"\"\"\r\n    @notice Deploy a new metapool\r\n    @param _base_pool Address of the base pool to use\r\n                      within the metapool\r\n    @param _name Name of the new metapool\r\n    @param _symbol Symbol for the new metapool - will be\r\n                   concatenated with the base pool symbol\r\n    @param _coin Address of the coin being used in the metapool\r\n    @param _A Amplification co-efficient - a higher value here means\r\n              less tolerance for imbalance within the pool's assets.\r\n              Suggested values include:\r\n               * Uncollateralized algorithmic stablecoins: 5-10\r\n               * Non-redeemable, collateralized assets: 100\r\n               * Redeemable assets: 200-400\r\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\r\n                minimum fee is 0.04% (4000000), the maximum is 1% (100000000).\r\n                50% of the fee is distributed to veCRV holders.\r\n    @return Address of the deployed pool\r\n    \"\"\"\r\n    implementation: address = self.base_pool_data[_base_pool].implementation\r\n    assert implementation != ZERO_ADDRESS\r\n\r\n    decimals: uint256 = ERC20(_coin).decimals()\r\n    pool: address = create_forwarder_to(implementation)\r\n    CurvePool(pool).initialize(_name, _symbol, _coin, decimals, _A, _fee, self.admin)\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = pool\r\n    self.pool_count = length + 1\r\n\r\n    base_lp_token: address = self.base_pool_data[_base_pool].lp_token\r\n\r\n    self.pool_data[pool].decimals = decimals\r\n    self.pool_data[pool].base_pool = _base_pool\r\n    self.pool_data[pool].coins = [_coin, self.base_pool_data[_base_pool].lp_token]\r\n\r\n    is_finished: bool = False\r\n    for i in range(MAX_COINS):\r\n        swappable_coin: address = self.base_pool_data[_base_pool].coins[i]\r\n        if swappable_coin == ZERO_ADDRESS:\r\n            is_finished = True\r\n            swappable_coin = base_lp_token\r\n\r\n        key: uint256 = bitwise_xor(convert(_coin, uint256), convert(swappable_coin, uint256))\r\n        length = self.market_counts[key]\r\n        self.markets[key][length] = pool\r\n        self.market_counts[key] = length + 1\r\n        if is_finished:\r\n            break\r\n\r\n    log MetaPoolDeployed(_coin, _base_pool, _A, _fee, msg.sender)\r\n    return pool\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of this contract to `addr`\r\n    @param addr Address of the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    self.future_admin = addr\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    @dev Only callable by the new owner\r\n    \"\"\"\r\n    _admin: address = self.future_admin\r\n    assert msg.sender == _admin  # dev: future admin only\r\n\r\n    self.admin = _admin\r\n    self.future_admin = ZERO_ADDRESS","ABI":"[{\"name\":\"BasePoolAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"base_pool\",\"indexed\":false},{\"type\":\"address\",\"name\":\"implementat\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"MetaPoolDeployed\",\"inputs\":[{\"type\":\"address\",\"name\":\"coin\",\"indexed\":false},{\"type\":\"address\",\"name\":\"base_pool\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"A\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"fee\",\"indexed\":false},{\"type\":\"address\",\"name\":\"deployer\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"i\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"get_n_coins\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2795},{\"name\":\"get_coins\",\"outputs\":[{\"type\":\"address[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2427},{\"name\":\"get_underlying_coins\",\"outputs\":[{\"type\":\"address[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":12195},{\"name\":\"get_decimals\",\"outputs\":[{\"type\":\"uint256[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1501},{\"name\":\"get_underlying_decimals\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":10155},{\"name\":\"get_rates\",\"outputs\":[{\"type\":\"uint256[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1876},{\"name\":\"get_balances\",\"outputs\":[{\"type\":\"uint256[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1268},{\"name\":\"get_underlying_balances\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":13247},{\"name\":\"get_A\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":958},{\"name\":\"get_fees\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1584},{\"name\":\"get_admin_balances\",\"outputs\":[{\"type\":\"uint256[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1388},{\"name\":\"get_coin_indices\",\"outputs\":[{\"type\":\"int128\",\"name\":\"\"},{\"type\":\"int128\",\"name\":\"\"},{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":20309},{\"name\":\"add_base_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_base_pool\"},{\"type\":\"address\",\"name\":\"_metapool_implementation\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":509110},{\"name\":\"deploy_metapool\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_base_pool\"},{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"},{\"type\":\"address\",\"name\":\"_coin\"},{\"type\":\"uint256\",\"name\":\"_A\"},{\"type\":\"uint256\",\"name\":\"_fee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":850296},{\"name\":\"commit_transfer_ownership\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36668},{\"name\":\"accept_transfer_ownership\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":56619},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1571},{\"name\":\"future_admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1601},{\"name\":\"pool_list\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1740},{\"name\":\"pool_count\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1661},{\"name\":\"base_pool_list\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1800},{\"name\":\"base_pool_count\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1721}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.8","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}