{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PermanentStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"./interface/IPermanentStorage.sol\\\";\\nimport \\\"./utils/lib_storage/PSStorage.sol\\\";\\n\\ncontract PermanentStorage is IPermanentStorage {\\n\\n    // Constants do not have storage slot.\\n    bytes32 public constant curveTokenIndexStorageId = 0xf4c750cdce673f6c35898d215e519b86e3846b1f0532fb48b84fe9d80f6de2fc; // keccak256(\\\"curveTokenIndex\\\")\\n    bytes32 public constant transactionSeenStorageId = 0x695d523b8578c6379a2121164fd8de334b9c5b6b36dff5408bd4051a6b1704d0;  // keccak256(\\\"transactionSeen\\\")\\n    bytes32 public constant relayerValidStorageId = 0x2c97779b4deaf24e9d46e02ec2699240a957d92782b51165b93878b09dd66f61;  // keccak256(\\\"relayerValid\\\")\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    string public version;  // Current version of the contract\\n    mapping(bytes32 => mapping(address => bool)) private permission;\\n\\n    // Supported Curve pools\\n    address public constant CURVE_COMPOUND_POOL = 0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56;\\n    address public constant CURVE_USDT_POOL = 0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C;\\n    address public constant CURVE_Y_POOL = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\\n    address public constant CURVE_3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    address public constant CURVE_sUSD_POOL = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\\n    address public constant CURVE_BUSD_POOL = 0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27;\\n\\n    // Curve coins\\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address private constant cDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\\n    address private constant cUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address private constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\\n    address private constant Y_POOL_yDAI = 0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01;\\n    address private constant Y_POOL_yUSDC = 0xd6aD7a6750A7593E092a9B218d66C0A814a3436e;\\n    address private constant Y_POOL_yUSDT = 0x83f798e925BcD4017Eb265844FDDAbb448f1707D;\\n    address private constant Y_POOL_yTUSD = 0x73a052500105205d34Daf004eAb301916DA8190f;\\n    address private constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n    address private constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\\n    address private constant BUSD_POOL_yDAI = 0xC2cB1040220768554cf699b0d863A3cd4324ce32;\\n    address private constant BUSD_POOL_yUSDC = 0x26EA744E5B887E5205727f55dFBE8685e3b21951;\\n    address private constant BUSD_POOL_yUSDT = 0xE6354ed5bC4b393a5Aad09f21c46E101e692d447;\\n    address private constant BUSD_POOL_yBUSD = 0x04bC0Ab673d88aE9dbC9DA2380cB6B79C4BCa9aE;\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"PermanentStorage: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier validRole(bool _enabled, address _role) {\\n        if (_enabled) {\\n            require(\\n                (_role == operator) || (_role == ammWrapperAddr()) || (_role == pmmAddr()),\\n                \\\"PermanentStorage: not a valid role\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    modifier isPermitted(bytes32 _storageId, address _role) {\\n        require(permission[_storageId][_role], \\\"PermanentStorage: has no permission\\\");\\n        _;\\n    }\\n\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"PermanentStorage: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n    /// @dev Set permission for entity to write certain storage.\\n    function setPermission(bytes32 _storageId, address _role, bool _enabled) external onlyOperator validRole(_enabled, _role) {\\n        permission[_storageId][_role] = _enabled;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\\n    function initialize() external {\\n        require(\\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"5.0.0\\\")),\\n            \\\"PermanentStorage: not upgrading from 5.0.0 version\\\"\\n        );\\n\\n        version = \\\"5.1.0\\\";\\n        // register Compound pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_COMPOUND_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_COMPOUND_POOL][USDC] = 2;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_COMPOUND_POOL][cDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_COMPOUND_POOL][cUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_COMPOUND_POOL] = true; // support get_dx or get_dx_underlying for quoting\\n\\n        // register USDT pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_USDT_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_USDT_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_USDT_POOL][USDT] = 3;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_USDT_POOL][cDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_USDT_POOL][cUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_USDT_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_USDT_POOL] = true;\\n\\n        // register Y pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][TUSD] = 4;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yUSDT] = 3;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yTUSD] = 4;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_Y_POOL] = true;\\n\\n        // register 3 pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_3_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_3_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_3_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_3_POOL] = false; // only support get_dy and get_dy_underlying for exactly the same functionality\\n\\n        // register sUSD pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][sUSD] = 4;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sUSD_POOL] = false;\\n\\n        // register BUSD pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][BUSD] = 4;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yUSDT] = 3;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yBUSD] = 4;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_BUSD_POOL] = true;\\n    }\\n\\n\\n    /************************************************************\\n    *                     Getter functions                      *\\n    *************************************************************/\\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool) {\\n        return permission[_storageId][_role];\\n    }\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return PSStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PSStorage.getStorage().pmmAddr;\\n    }\\n\\n    function wethAddr() override external view returns (address) {\\n        return PSStorage.getStorage().wethAddr;\\n    }\\n\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) override external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx) {\\n        // underlying_coins\\n        int128 i = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_takerAssetAddr];\\n        int128 j = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_makerAssetAddr];\\n        supportGetDx = AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr];\\n\\n        swapMethod = 0;\\n        if (i != 0 && j != 0) {\\n            // in underlying_coins list\\n            takerAssetIndex = i;\\n            makerAssetIndex = j;\\n            // exchange_underlying\\n            swapMethod = 2;\\n        } else {\\n            // in coins list\\n            int128 iWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_takerAssetAddr];\\n            int128 jWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_makerAssetAddr];\\n            if (iWrapped != 0 && jWrapped != 0) {\\n                takerAssetIndex = iWrapped;\\n                makerAssetIndex = jWrapped;\\n                // exchange\\n                swapMethod = 1;\\n            } else {\\n                revert(\\\"PermanentStorage: invalid pair\\\");\\n            }\\n        }\\n        return (takerAssetIndex, makerAssetIndex, swapMethod, supportGetDx);\\n    }\\n\\n    function isTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRelayerValid(address _relayer) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().relayerValid[_relayer];\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /// @dev Update AMMWrapper contract address.\\n    function upgradeAMMWrapper(address _newAMMWrapper) external onlyOperator {\\n        PSStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\\n    }\\n\\n    /// @dev Update PMM contract address.\\n    function upgradePMM(address _newPMM) external onlyOperator {\\n        PSStorage.getStorage().pmmAddr = _newPMM;\\n    }\\n\\n    /// @dev Update WETH contract address.\\n    function upgradeWETH(address _newWETH) external onlyOperator {\\n        PSStorage.getStorage().wethAddr = _newWETH;\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) override external isPermitted(curveTokenIndexStorageId, msg.sender) {\\n        int128 underlyingCoinsLength = int128(_underlyingCoins.length);\\n        for (int128 i = 0 ; i < underlyingCoinsLength; i++) {\\n            address assetAddr = _underlyingCoins[uint256(i)];\\n            // underlying coins for original DAI, USDC, TUSD\\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i + 1;  // Start the index from 1\\n        }\\n\\n        int128 coinsLength = int128(_coins.length);\\n        for (int128 i = 0 ; i < coinsLength; i++) {\\n            address assetAddr = _coins[uint256(i)];\\n            // wrapped coins for cDAI, cUSDC, yDAI, yUSDC, yTUSD, yBUSD\\n            AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][assetAddr] = i + 1;  // Start the index from 1\\n        }\\n\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr] = _supportGetDx;\\n    }\\n\\n    function setTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRelayersValid(address[] calldata _relayers, bool[] calldata _isValids) override external isPermitted(relayerValidStorageId, msg.sender) {\\n        require(_relayers.length == _isValids.length, \\\"PermanentStorage: inputs length mismatch\\\");\\n        for (uint256 i = 0; i < _relayers.length; i++) {\\n            AMMWrapperStorage.getStorage().relayerValid[_relayers[i]] = _isValids[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPermanentStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IPermanentStorage {\\n    function wethAddr() external view returns (address);\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx);\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) external;\\n    function isTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRelayerValid(address _relayer) external view returns (bool);\\n    function setTransactionSeen(bytes32 _transactionHash) external;\\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\\n}\"\r\n    },\r\n    \"contracts/utils/lib_storage/PSStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary PSStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x92dd52b981a2dd69af37d8a3febca29ed6a974aede38ae66e4ef773173aba471;\\n\\n    struct Storage {\\n        address ammWrapperAddr;\\n        address pmmAddr;\\n        address wethAddr;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.storage.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xd38d862c9fa97c2fa857a46e08022d272a3579c114ca4f335f1e5fcb692c045e;\\n\\n    struct Storage {\\n        mapping(bytes32 => bool) transactionSeen;\\n        // curve pool => underlying token address => underlying token index\\n        mapping(address => mapping(address => int128)) curveTokenIndexes;\\n        mapping(address => bool) relayerValid;\\n        // 5.1.0 appended storage\\n        // curve pool => wrapped token address => wrapped token index\\n        mapping(address => mapping(address => int128)) curveWrappedTokenIndexes;\\n        mapping(address => bool) curveSupportGetDx;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary PMMStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xf9faf013fe1696003dca3723ade1a1b88f21762ea39d9dfa2c55c5bd9c4ae6e9;\\n\\n    struct Storage {\\n        mapping(bytes32 => address) transactions;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.pmm.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"CURVE_3_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_BUSD_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_COMPOUND_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_USDT_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_Y_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_sUSD_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ammWrapperAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveTokenIndexStorageId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"}],\"name\":\"getCurvePoolInfo\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"takerAssetIndex\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"makerAssetIndex\",\"type\":\"int128\"},{\"internalType\":\"uint16\",\"name\":\"swapMethod\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"supportGetDx\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_storageId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_role\",\"type\":\"address\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"isRelayerValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"isTransactionSeen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pmmAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayerValidStorageId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_underlyingCoins\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_coins\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_supportGetDx\",\"type\":\"bool\"}],\"name\":\"setCurvePoolInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_storageId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_role\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_relayers\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isValids\",\"type\":\"bool[]\"}],\"name\":\"setRelayersValid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"}],\"name\":\"setTransactionSeen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionSeenStorageId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAMMWrapper\",\"type\":\"address\"}],\"name\":\"upgradeAMMWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPMM\",\"type\":\"address\"}],\"name\":\"upgradePMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWETH\",\"type\":\"address\"}],\"name\":\"upgradeWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PermanentStorage","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}