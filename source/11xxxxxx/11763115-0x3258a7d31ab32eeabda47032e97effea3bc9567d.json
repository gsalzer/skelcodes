{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/oracle/uniswap-twap/ArcUniswapV2Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"../../lib/SafeMath.sol\\\";\\nimport {Ownable} from \\\"../../lib/Ownable.sol\\\";\\nimport {FixedPoint} from \\\"../../lib/FixedPoint.sol\\\";\\n\\nimport {IKeep3rV1} from \\\"./IKeep3rV1.sol\\\";\\nimport {UniswapV2OracleLibrary} from \\\"./UniswapV2OracleLibrary.sol\\\";\\nimport {UniswapV2Library} from \\\"./UniswapV2Library.sol\\\";\\n\\n/**\\n * @notice A Time-weighted average prices oracle and Keeper job for any uniswap pair\\n */\\ncontract ArcUniswapV2Oracle is Ownable {\\n    /* ========== Libraries ========== */\\n\\n    using SafeMath for uint;\\n\\n    /* ========== Storage ========== */\\n\\n    IKeep3rV1 public KP3R;\\n\\n    address public uniV2Factory;\\n\\n    uint public periodWindow = 1 hours;\\n\\n    // mapping from pair address to a list of price observations of that pair\\n    mapping(address => Observation[]) public pairObservations;\\n\\n    address[] internal _pairs;\\n\\n    mapping(address => bool) internal _known;\\n\\n    /* ========== Types ========== */\\n\\n    struct Observation {\\n        uint timestamp;\\n        uint price0Cumulative;\\n        uint price1Cumulative;\\n    }\\n\\n    /* ========== Events ========== */\\n\\n    event WorkDone(address keeper);\\n\\n    event UpdatedAll(address caller);\\n\\n    event PairUpdated(address pair);\\n\\n    event PairAdded(address pair);\\n\\n    event PairRemoved(address pair);\\n\\n    event Keep3rV1AddressSet(address kp3r);\\n\\n    event PeriodWindowSet(uint newPeriodWindow);\\n\\n    event UniV2FactorySet(address newUniV2Factory);\\n\\n    /* ========== Modifiers ========== */\\n\\n    modifier keeper() {\\n        require(\\n            KP3R.isKeeper(msg.sender),\\n            \\\"isKeeper(): keeper is not registered\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(\\n        address _kp3r,\\n        address _uniV2Factory\\n    )\\n        public\\n    {\\n        require(\\n            _kp3r != address(0) && _uniV2Factory != address(0),\\n            \\\"ArcUniswapV2Oracle: Keeper and univ2Factory address must not be null\\\"\\n        );\\n\\n        KP3R = IKeep3rV1(_kp3r);\\n        uniV2Factory = _uniV2Factory;\\n    }\\n\\n    /* ========== Keeper Functions ========== */\\n\\n    /**\\n     * @notice Updates all pairs. The function to be called by the keeper to be rewarded.\\n     */\\n    function work() external keeper {\\n        bool worked = _updateAll();\\n\\n        require(\\n            worked,\\n            \\\"ArcUniswapV2Oracle:work: the work was not completed!\\\"\\n        );\\n\\n        KP3R.worked(msg.sender);\\n\\n        emit WorkDone(msg.sender);\\n    }\\n\\n    /* ========== External Functions ========== */\\n\\n    /**\\n     * @notice Updates the pair if it is known\\n     * @return `true` if the pair was successfully updated\\n     */\\n    function updateTokensPair(\\n        address _token0,\\n        address _token1\\n    )\\n        external\\n        returns (bool)\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\\n        return updatePair(pair);\\n    }\\n\\n    /**\\n     * @notice Updates the given pair\\n     * @param _pair The pair to be updated\\n     */\\n    function updatePair(address _pair)\\n        public\\n        returns (bool)\\n    {\\n        require(\\n            _known[_pair],\\n            \\\"ArcUniswapV2Oracle:updatePair(): The pair is not known\\\"\\n        );\\n\\n        bool updated = _update(_pair);\\n\\n        if (updated) {\\n            emit PairUpdated(_pair);\\n        }\\n\\n        return updated;\\n    }\\n\\n    /**\\n     * @notice Updates all pairs\\n     */\\n    function updateAll() external returns (bool) {\\n        bool worked = _updateAll();\\n\\n        if (worked) {\\n            emit UpdatedAll(msg.sender);\\n        }\\n\\n        return worked;\\n    }\\n\\n    /* ========== Public Getters ========== */\\n\\n    function getPairObservations(address _pair)\\n        external\\n        view\\n        returns (Observation[] memory)\\n    {\\n        return pairObservations[_pair];\\n    }\\n\\n    function getPairs()\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return _pairs;\\n    }\\n\\n    /**\\n     * @notice Returns the last recorded observation for the pair\\n     * @param _pair The pair we want the last observation for\\n     */\\n    function lastObservation(address _pair)\\n        public\\n        view\\n        returns (Observation memory)\\n    {\\n        require(\\n            _known[_pair],\\n            \\\"ArcUniswapV2Oracle:lastObservation(): The pair is not known\\\"\\n        );\\n\\n        Observation[] memory foundPairObservations = pairObservations[_pair];\\n        return pairObservations[_pair][foundPairObservations.length - 1];\\n    }\\n\\n    /**\\n     * @notice returns the last observation for the token pair\\n     */\\n    function lastObservationTokens(\\n        address _token0,\\n        address _token1\\n    )\\n        external\\n        view\\n        returns (Observation memory)\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\\n\\n        require(\\n            _known[pair],\\n            \\\"ArcUniswapV2Oracle:lastObservationTokens(): The pair is not known\\\"\\n        );\\n\\n        Observation[] memory foundPairObservations = pairObservations[pair];\\n        return pairObservations[pair][foundPairObservations.length - 1];\\n    }\\n\\n    /**\\n     * @notice Returns true if pair is updatable given the period window. Therefore calling work() will yield a reward\\n     * @param _pair The pair to make the check for\\n     */\\n    function workablePair(address _pair)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            _known[_pair],\\n            \\\"ArcUniswapV2Oracle:workablePair(): pair is not known\\\"\\n        );\\n\\n        Observation memory observation = lastObservation(_pair);\\n        uint timeElapsed = block.timestamp.sub(observation.timestamp);\\n\\n        return timeElapsed > periodWindow;\\n    }\\n\\n    /**\\n     * @notice Returns true if pair is updatable given the period window. Therefore calling work() will yield a reward\\n     */\\n    function workableTokens(\\n        address _token0,\\n        address _token1\\n    )\\n        external\\n        view\\n        returns (bool)\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\\n\\n        require(\\n            _known[pair],\\n            \\\"ArcUniswapV2Oracle:workableTokens(): pair is not known\\\"\\n        );\\n\\n        Observation memory observation = lastObservation(pair);\\n        uint timeElapsed = block.timestamp.sub(observation.timestamp);\\n\\n        return timeElapsed > periodWindow;\\n    }\\n\\n    /**\\n     * @notice Iterates over all known pairs and checks wether there is at least one pair that is updatable\\n     */\\n    function workable()\\n        external\\n        view\\n        returns (bool)\\n    {\\n        for (uint i = 0; i < _pairs.length; i++) {\\n            if (workablePair(_pairs[i])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Returns the pair address of the two tokens\\n     */\\n    function pairFor(address _token0, address _token1)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\\n    }\\n\\n    /**\\n     * @notice Computes and returns how much of `_tokenOut` you would get if you give `_amountIn` of `_tokenIn`\\n     *\\n     * @param _tokenIn the address of the token in\\n     * @param _amountIn the amount in terms of `_tokenIn`\\n     * @param _tokenOut the address of the token out\\n     */\\n    function current(\\n        address _tokenIn,\\n        uint _amountIn,\\n        address _tokenOut\\n    )\\n        external\\n        view\\n        returns (uint)\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _tokenIn, _tokenOut);\\n\\n        require(\\n            _valid(pair, periodWindow.mul(2)),\\n            \\\"ArcUniswapV2Oracle:current(): stale prices\\\"\\n        );\\n\\n        (address token0, ) = UniswapV2Library.sortTokens(_tokenIn, _tokenOut);\\n        Observation memory observation = lastObservation(pair);\\n        (uint price0Cumulative, uint price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n\\n        if (block.timestamp == observation.timestamp) {\\n            Observation[] memory observationsForPair = pairObservations[pair];\\n            observation = pairObservations[pair][observationsForPair.length.sub(2)];\\n        }\\n\\n        uint timeElapsed = block.timestamp.sub(observation.timestamp);\\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\\n\\n        if (token0 == _tokenIn) {\\n            // prettier-ignore\\n            return _computeAmountOut(\\n                observation.price0Cumulative,\\n                price0Cumulative,\\n                timeElapsed,\\n                _amountIn\\n            );\\n        } else {\\n            // prettier-ignore\\n            return _computeAmountOut(\\n                observation.price1Cumulative,\\n                price1Cumulative,\\n                timeElapsed,\\n                _amountIn\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Gives a price quote based on the granularity\\n     * @param _tokenIn the token that `_amountIn` is denominated in\\n     * @param _amountIn the amount to get the quote for\\n     * @param _tokenOut the token that the result is denominated in\\n     * @param _granularity the granularity of the quote in terms of time.\\n     *                     Ex. if `_granularity` = 2, the quote will be return a\\n     *                     price based on the `periodWindow` * 2\\n     */\\n    function quote(\\n        address _tokenIn,\\n        uint _amountIn,\\n        address _tokenOut,\\n        uint _granularity\\n    )\\n        external\\n        view\\n        returns (uint)\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _tokenIn, _tokenOut);\\n\\n        require(\\n            _valid(pair, periodWindow.mul(_granularity)),\\n            \\\"ArcUniswapV2Oracle:quote(): stale prices\\\"\\n        );\\n\\n        (address token0, ) = UniswapV2Library.sortTokens(_tokenIn, _tokenOut);\\n\\n        uint priceAverageCumulative = 0;\\n        uint length = pairObservations[pair].length - 1;\\n        uint i = length.sub(_granularity);\\n\\n        uint nextIndex = 0;\\n        if (token0 == _tokenIn) {\\n            for (; i < length; i++) {\\n                nextIndex = i + 1;\\n                priceAverageCumulative += _computeAmountOut(\\n                    pairObservations[pair][i].price0Cumulative,\\n                    pairObservations[pair][nextIndex].price0Cumulative,\\n                    pairObservations[pair][nextIndex].timestamp.sub(pairObservations[pair][i].timestamp),\\n                    _amountIn\\n                );\\n            }\\n        } else {\\n            for (; i < length; i++) {\\n                nextIndex = i + 1;\\n                priceAverageCumulative += _computeAmountOut(\\n                    pairObservations[pair][i].price1Cumulative,\\n                    pairObservations[pair][nextIndex].price1Cumulative,\\n                    pairObservations[pair][nextIndex].timestamp.sub(pairObservations[pair][i].timestamp),\\n                    _amountIn\\n                );\\n            }\\n        }\\n\\n        return priceAverageCumulative.div(_granularity);\\n    }\\n\\n    /* ========== Owner functions ========== */\\n\\n    /**\\n     * @notice Sets the period window\\n     */\\n    function setPeriodWindow(uint _periodWindow) external onlyOwner {\\n\\n        require(\\n            _periodWindow != 0,\\n            \\\"ArcUniswapV2Oracle:setPeriodWindow(): period window cannot be 0!\\\"\\n        );\\n\\n        periodWindow = _periodWindow;\\n        emit PeriodWindowSet(_periodWindow);\\n    }\\n\\n    /**\\n     * @notice Sets the Keep3rV1 address\\n     */\\n    function setKeep3rAddress(address _kp3r) external onlyOwner {\\n        require(\\n            _kp3r != address(0),\\n            \\\"ArcUniswapV2Oracle:setKeep3rAddress(): _kp3r must not be null\\\"\\n        );\\n\\n        KP3R = IKeep3rV1(_kp3r);\\n        emit Keep3rV1AddressSet(_kp3r);\\n    }\\n\\n    /**\\n     * @notice Adds the pair to the known pairs. Will start updating the given pair\\n     * @dev the order doesn't matter because they are be sorted later down the road\\n     * @param _token0 first token of the pair\\n     * @param _token1 second token of the pair\\n     */\\n    function addPair(\\n        address _token0,\\n        address _token1\\n    )\\n        external\\n        onlyOwner\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\\n\\n        require(!_known[pair], \\\"ArcUniswapV2Oracle:addPair(): already known\\\");\\n\\n        _known[pair] = true;\\n        _pairs.push(pair);\\n\\n        // Add an observation\\n        (uint price0Cumulative, uint price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n        pairObservations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\\n\\n        emit PairAdded(pair);\\n        emit PairUpdated(pair);\\n    }\\n\\n    /**\\n     * @notice Removes a pair\\n     */\\n    function removePair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        onlyOwner\\n    {\\n        address pair = UniswapV2Library.pairFor(uniV2Factory, _tokenA, _tokenB);\\n\\n        require(\\n            _known[pair],\\n            \\\"ArcUniswapV2Oracle:removePair(): pair not added\\\"\\n        );\\n\\n        // Remove the pair from the pairs array\\n        for (uint i = 0; i < _pairs.length; i++) {\\n            if (_pairs[i] == pair) {\\n                delete _pairs[i];\\n                _pairs[i] = _pairs[_pairs.length - 1];\\n                _pairs.length--;\\n\\n                break;\\n            }\\n        }\\n\\n        delete _known[pair];\\n        delete pairObservations[pair];\\n\\n        emit PairRemoved(pair);\\n    }\\n\\n    /**\\n     * @notice sets the univ2 factory address\\n     */\\n    function setUniV2FactoryAddress(address _uniV2Factory)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _uniV2Factory != address(0),\\n            \\\"ArcUniswapV2Oracle:setUniV2FactoryAddress(): _uniV2Factory cannot be 0\\\"\\n        );\\n\\n        uniV2Factory = _uniV2Factory;\\n        emit UniV2FactorySet(_uniV2Factory);\\n    }\\n\\n    /* ========== Internal Functions ========== */\\n\\n    /**\\n     * @dev Updates the pair if within the time window\\n     * @param _pair The pair to update\\n     */\\n    function _update(address _pair)\\n        internal\\n        returns (bool)\\n    {\\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\\n        uint timeElapsed = block.timestamp - lastObservation(_pair).timestamp;\\n\\n        if (timeElapsed > periodWindow) {\\n            (uint price0Cumulative, uint price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(_pair);\\n\\n            pairObservations[_pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Loops over all registered pairs and updates them\\n     */\\n    function _updateAll()\\n        internal\\n        returns (bool updated)\\n    {\\n        for (uint i = 0; i < _pairs.length; i++) {\\n            if (_update(_pairs[i])) {\\n                updated = true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks wether the pair was updated within `age` time\\n     */\\n    function _valid(\\n        address _pair,\\n        uint _age\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return block.timestamp.sub(lastObservation(_pair).timestamp) <= _age;\\n    }\\n\\n    function _computeAmountOut(\\n        uint _priceCumulativeStart,\\n        uint _priceCumulativeEnd,\\n        uint _timeElapsed,\\n        uint _amountIn\\n    )\\n        private\\n        pure\\n        returns (uint amountOut)\\n    {\\n        // overflow is desired.\\n        FixedPoint.uq112x112 memory priceAverage =\\n            FixedPoint.uq112x112(uint224((_priceCumulativeEnd - _priceCumulativeStart) / _timeElapsed));\\n        FixedPoint.uq144x112 memory priceAverageMultiplied = FixedPoint.mul(priceAverage, _amountIn);\\n\\n        return FixedPoint.decode144(priceAverageMultiplied);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.5.16;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    // solium-disable-next-line camelcase\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    // solium-disable-next-line camelcase\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/uniswap-twap/IKeep3rV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\ninterface IKeep3rV1 {\\n\\n    function isKeeper(address) external returns (bool);\\n\\n    function worked(address keeper) external;\\n\\n    function bond(address bonding, uint amount) external;\\n\\n    function activate(address bonding) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/uniswap-twap/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {FixedPoint} from \\\"../../lib/FixedPoint.sol\\\";\\n\\nimport {IUniswapV2Pair} from \\\"./IUniswapV2Pair.sol\\\";\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2**32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(address _pair)\\n        internal\\n        view\\n        returns (\\n            uint price0Cumulative,\\n            uint price1Cumulative,\\n            uint32 blockTimestamp\\n        )\\n    {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(_pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(_pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(_pair).getReserves();\\n\\n        if (blockTimestampLast != blockTimestamp) {\\n            // TODO discuss this w/ kerman\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/uniswap-twap/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\ninterface IUniswapV2Pair {\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint);\\n\\n    function price1CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/uniswap-twap/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"../../lib/SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        pure\\n        returns (address pair)\\n    {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n\\n        pair = address(\\n            uint(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        factory,\\n                        keccak256(abi.encodePacked(token0, token1)),\\n                        hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kp3r\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniV2Factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"kp3r\",\"type\":\"address\"}],\"name\":\"Keep3rV1AddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"PairAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"PairRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"PairUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriodWindow\",\"type\":\"uint256\"}],\"name\":\"PeriodWindowSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newUniV2Factory\",\"type\":\"address\"}],\"name\":\"UniV2FactorySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"UpdatedAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"WorkDone\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"KP3R\",\"outputs\":[{\"internalType\":\"contract IKeep3rV1\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"getPairObservations\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"internalType\":\"struct ArcUniswapV2Oracle.Observation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPairs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"lastObservation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"internalType\":\"struct ArcUniswapV2Oracle.Observation\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"lastObservationTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"internalType\":\"struct ArcUniswapV2Oracle.Observation\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_granularity\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"removePair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kp3r\",\"type\":\"address\"}],\"name\":\"setKeep3rAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_periodWindow\",\"type\":\"uint256\"}],\"name\":\"setPeriodWindow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniV2Factory\",\"type\":\"address\"}],\"name\":\"setUniV2FactoryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniV2Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"updatePair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"updateTokensPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"work\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"workable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"workablePair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"workableTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ArcUniswapV2Oracle","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001ceb5cb57c4d4e2b2433641b95dd330a33185a440000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}