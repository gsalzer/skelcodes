{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/curve/StableSwapGusd.sol\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.6.11;\r\n\r\ninterface StableSwapGusd {\r\n    function get_virtual_price() external view returns (uint);\r\n\r\n    /*\r\n    0 GUSD\r\n    1 3CRV\r\n    */\r\n    function balances(uint index) external view returns (uint);\r\n}\r\n\r\n// File: contracts/interfaces/curve/DepositGusd.sol\r\n\r\ninterface DepositGusd {\r\n    /*\r\n    0 GUSD\r\n    1 DAI\r\n    2 USDC\r\n    3 USDT\r\n    */\r\n    function add_liquidity(uint[4] memory amounts, uint min) external returns (uint);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint amount,\r\n        int128 index,\r\n        uint min\r\n    ) external returns (uint);\r\n}\r\n\r\n// File: contracts/interfaces/curve/StableSwap3.sol\r\n\r\ninterface StableSwap3 {\r\n    /*\r\n    @dev Returns price of 1 Curve LP token in USD\r\n    */\r\n    function get_virtual_price() external view returns (uint);\r\n\r\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint token_amount,\r\n        int128 i,\r\n        uint min_uamount\r\n    ) external;\r\n\r\n    function balances(uint index) external view returns (uint);\r\n}\r\n\r\n// File: contracts/interfaces/curve/Gauge.sol\r\n\r\n// https://github.com/curvefi/curve-contract/blob/master/contracts/gauges/LiquidityGauge.vy\r\ninterface Gauge {\r\n    function deposit(uint) external;\r\n\r\n    function balanceOf(address) external view returns (uint);\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\n// File: contracts/interfaces/curve/Minter.sol\r\n\r\n// https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/Minter.vy\r\ninterface Minter {\r\n    function mint(address) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint a,\r\n        uint b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint a,\r\n        uint b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b) internal pure returns (uint) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint a,\r\n        uint b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint value\r\n    ) internal {\r\n        uint newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint value\r\n    ) internal {\r\n        uint newAllowance =\r\n            token.allowance(address(this), spender).sub(\r\n                value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata =\r\n            address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/IStrategy.sol\r\n\r\ninterface IStrategy {\r\n    function admin() external view returns (address);\r\n\r\n    function controller() external view returns (address);\r\n\r\n    function vault() external view returns (address);\r\n\r\n    /*\r\n    @notice Returns address of underlying token\r\n    */\r\n    function underlying() external view returns (address);\r\n\r\n    /*\r\n    @notice Returns total amount of underlying transferred from vault\r\n    */\r\n    function totalDebt() external view returns (uint);\r\n\r\n    function performanceFee() external view returns (uint);\r\n\r\n    /*\r\n    @notice Returns true if token cannot be swept\r\n    */\r\n    function assets(address _token) external view returns (bool);\r\n\r\n    function setAdmin(address _admin) external;\r\n\r\n    function setController(address _controller) external;\r\n\r\n    function setPerformanceFee(uint _fee) external;\r\n\r\n    /*\r\n    @notice Returns amount of underlying stable coin locked in this contract\r\n    @dev Output may vary depending on price of liquidity provider token\r\n         where the underlying token is invested\r\n    */\r\n    function totalAssets() external view returns (uint);\r\n\r\n    /*\r\n    @notice Deposit `amount` underlying token for yield token\r\n    @param amount Amount of underlying token to deposit\r\n    */\r\n    function deposit(uint _amount) external;\r\n\r\n    /*\r\n    @notice Withdraw `amount` yield token to withdraw\r\n    @param amount Amount of yield token to withdraw\r\n    */\r\n    function withdraw(uint _amount) external;\r\n\r\n    /*\r\n    @notice Withdraw all underlying token from strategy\r\n    */\r\n    function withdrawAll() external;\r\n\r\n    function harvest() external;\r\n\r\n    /*\r\n    @notice Exit from strategy\r\n    @dev Must transfer all underlying tokens back to vault\r\n    */\r\n    function exit() external;\r\n\r\n    /*\r\n    @notice Transfer profit over total debt to vault\r\n    */\r\n    function skim() external;\r\n\r\n    /*\r\n    @notice Transfer token in strategy to admin\r\n    @param _token Address of token to transfer\r\n    @dev Must transfer token to admin\r\n    @dev _token must not be equal to underlying token\r\n    @dev Used to transfer token that was accidentally sent or\r\n         claim dust created from this strategy\r\n    */\r\n    function sweep(address _token) external;\r\n}\r\n\r\n// File: contracts/protocol/IController.sol\r\n\r\ninterface IController {\r\n    function ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    function HARVESTER_ROLE() external view returns (bytes32);\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function treasury() external view returns (address);\r\n\r\n    function setAdmin(address _admin) external;\r\n\r\n    function setTreasury(address _treasury) external;\r\n\r\n    function grantRole(bytes32 _role, address _addr) external;\r\n\r\n    function revokeRole(bytes32 _role, address _addr) external;\r\n\r\n    /*\r\n    @notice Set strategy for vault\r\n    @param _vault Address of vault\r\n    @param _strategy Address of strategy\r\n    @param _min Minimum undelying token current strategy must return. Prevents slippage\r\n    */\r\n    function setStrategy(\r\n        address _vault,\r\n        address _strategy,\r\n        uint _min\r\n    ) external;\r\n\r\n    // calls to strategy\r\n    /*\r\n    @notice Invest token in vault into strategy\r\n    @param _vault Address of vault\r\n    */\r\n    function invest(address _vault) external;\r\n\r\n    function harvest(address _strategy) external;\r\n\r\n    function skim(address _strategy) external;\r\n\r\n    /*\r\n    @notice Withdraw from strategy to vault\r\n    @param _strategy Address of strategy\r\n    @param _amount Amount of underlying token to withdraw\r\n    @param _min Minimum amount of underlying token to withdraw\r\n    */\r\n    function withdraw(\r\n        address _strategy,\r\n        uint _amount,\r\n        uint _min\r\n    ) external;\r\n\r\n    /*\r\n    @notice Withdraw all from strategy to vault\r\n    @param _strategy Address of strategy\r\n    @param _min Minimum amount of underlying token to withdraw\r\n    */\r\n    function withdrawAll(address _strategy, uint _min) external;\r\n\r\n    /*\r\n    @notice Exit from strategy\r\n    @param _strategy Address of strategy\r\n    @param _min Minimum amount of underlying token to withdraw\r\n    */\r\n    function exit(address _strategy, uint _min) external;\r\n}\r\n\r\n// File: contracts/StrategyBase.sol\r\n\r\nabstract contract StrategyBase is IStrategy {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n\r\n    address public override admin;\r\n    address public override controller;\r\n    address public override vault;\r\n    address public override underlying;\r\n\r\n    // total amount of underlying transferred from vault\r\n    uint public override totalDebt;\r\n\r\n    // performance fee sent to treasury when harvest() generates profit\r\n    uint public override performanceFee = 500;\r\n    uint internal constant PERFORMANCE_FEE_MAX = 10000;\r\n\r\n    // valuable tokens that cannot be swept\r\n    mapping(address => bool) public override assets;\r\n\r\n    constructor(\r\n        address _controller,\r\n        address _vault,\r\n        address _underlying\r\n    ) public {\r\n        require(_controller != address(0), \"controller = zero address\");\r\n        require(_vault != address(0), \"vault = zero address\");\r\n        require(_underlying != address(0), \"underlying = zero address\");\r\n\r\n        admin = msg.sender;\r\n        controller = _controller;\r\n        vault = _vault;\r\n        underlying = _underlying;\r\n\r\n        assets[underlying] = true;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"!admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(\r\n            msg.sender == admin || msg.sender == controller || msg.sender == vault,\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address _admin) external override onlyAdmin {\r\n        require(_admin != address(0), \"admin = zero address\");\r\n        admin = _admin;\r\n    }\r\n\r\n    function setController(address _controller) external override onlyAdmin {\r\n        require(_controller != address(0), \"controller = zero address\");\r\n        controller = _controller;\r\n    }\r\n\r\n    function setPerformanceFee(uint _fee) external override onlyAdmin {\r\n        require(_fee <= PERFORMANCE_FEE_MAX, \"performance fee > max\");\r\n        performanceFee = _fee;\r\n    }\r\n\r\n    function _increaseDebt(uint _underlyingAmount) private {\r\n        uint balBefore = IERC20(underlying).balanceOf(address(this));\r\n        IERC20(underlying).safeTransferFrom(vault, address(this), _underlyingAmount);\r\n        uint balAfter = IERC20(underlying).balanceOf(address(this));\r\n\r\n        totalDebt = totalDebt.add(balAfter.sub(balBefore));\r\n    }\r\n\r\n    function _decreaseDebt(uint _underlyingAmount) private {\r\n        uint balBefore = IERC20(underlying).balanceOf(address(this));\r\n        IERC20(underlying).safeTransfer(vault, _underlyingAmount);\r\n        uint balAfter = IERC20(underlying).balanceOf(address(this));\r\n\r\n        uint diff = balBefore.sub(balAfter);\r\n        if (diff > totalDebt) {\r\n            totalDebt = 0;\r\n        } else {\r\n            totalDebt = totalDebt - diff;\r\n        }\r\n    }\r\n\r\n    function _totalAssets() internal view virtual returns (uint);\r\n\r\n    /*\r\n    @notice Returns amount of underlying tokens locked in this contract\r\n    */\r\n    function totalAssets() external view override returns (uint) {\r\n        return _totalAssets();\r\n    }\r\n\r\n    function _depositUnderlying() internal virtual;\r\n\r\n    /*\r\n    @notice Deposit underlying token into this strategy\r\n    @param _underlyingAmount Amount of underlying token to deposit\r\n    */\r\n    function deposit(uint _underlyingAmount) external override onlyAuthorized {\r\n        require(_underlyingAmount > 0, \"underlying = 0\");\r\n\r\n        _increaseDebt(_underlyingAmount);\r\n        _depositUnderlying();\r\n    }\r\n\r\n    /*\r\n    @notice Returns total shares owned by this contract for depositing underlying\r\n            into external Defi\r\n    */\r\n    function _getTotalShares() internal view virtual returns (uint);\r\n\r\n    function _getShares(uint _underlyingAmount, uint _totalUnderlying)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        /*\r\n        calculate shares to withdraw\r\n\r\n        w = amount of underlying to withdraw\r\n        U = total redeemable underlying\r\n        s = shares to withdraw\r\n        P = total shares deposited into external liquidity pool\r\n\r\n        w / U = s / P\r\n        s = w / U * P\r\n        */\r\n        if (_totalUnderlying > 0) {\r\n            uint totalShares = _getTotalShares();\r\n            return _underlyingAmount.mul(totalShares) / _totalUnderlying;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function _withdrawUnderlying(uint _shares) internal virtual;\r\n\r\n    /*\r\n    @notice Withdraw undelying token to vault\r\n    @param _underlyingAmount Amount of underlying token to withdraw\r\n    @dev Caller should implement guard agains slippage\r\n    */\r\n    function withdraw(uint _underlyingAmount) external override onlyAuthorized {\r\n        require(_underlyingAmount > 0, \"underlying = 0\");\r\n        uint totalUnderlying = _totalAssets();\r\n        require(_underlyingAmount <= totalUnderlying, \"underlying > total\");\r\n\r\n        uint shares = _getShares(_underlyingAmount, totalUnderlying);\r\n        if (shares > 0) {\r\n            _withdrawUnderlying(shares);\r\n        }\r\n\r\n        // transfer underlying token to vault\r\n        uint underlyingBal = IERC20(underlying).balanceOf(address(this));\r\n        if (underlyingBal > 0) {\r\n            _decreaseDebt(underlyingBal);\r\n        }\r\n    }\r\n\r\n    function _withdrawAll() internal {\r\n        uint totalShares = _getTotalShares();\r\n        if (totalShares > 0) {\r\n            _withdrawUnderlying(totalShares);\r\n        }\r\n\r\n        uint underlyingBal = IERC20(underlying).balanceOf(address(this));\r\n        if (underlyingBal > 0) {\r\n            _decreaseDebt(underlyingBal);\r\n            totalDebt = 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n    @notice Withdraw all underlying to vault\r\n    @dev Caller should implement guard agains slippage\r\n    */\r\n    function withdrawAll() external override onlyAuthorized {\r\n        _withdrawAll();\r\n    }\r\n\r\n    /*\r\n    @notice Sell any staking rewards for underlying, deposit or transfer undelying\r\n            depending on total debt\r\n    */\r\n    function harvest() external virtual override;\r\n\r\n    /*\r\n    @notice Transfer profit over total debt to vault\r\n    */\r\n    function skim() external override onlyAuthorized {\r\n        uint totalUnderlying = _totalAssets();\r\n\r\n        if (totalUnderlying > totalDebt) {\r\n            uint profit = totalUnderlying - totalDebt;\r\n            uint shares = _getShares(profit, totalUnderlying);\r\n            if (shares > 0) {\r\n                uint balBefore = IERC20(underlying).balanceOf(address(this));\r\n                _withdrawUnderlying(shares);\r\n                uint balAfter = IERC20(underlying).balanceOf(address(this));\r\n\r\n                uint diff = balAfter.sub(balBefore);\r\n                if (diff > 0) {\r\n                    IERC20(underlying).safeTransfer(vault, diff);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function exit() external virtual override;\r\n\r\n    function sweep(address _token) external override onlyAdmin {\r\n        require(!assets[_token], \"asset\");\r\n\r\n        IERC20(_token).safeTransfer(admin, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/uniswap/Uniswap.sol\r\n\r\ninterface Uniswap {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts/UseUniswap.sol\r\n\r\ncontract UseUniswap {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n\r\n    // Uniswap //\r\n    address private constant UNISWAP = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    function _swap(\r\n        address _from,\r\n        address _to,\r\n        uint _amount\r\n    ) internal {\r\n        require(_to != address(0), \"to = zero address\");\r\n\r\n        // Swap with uniswap\r\n        IERC20(_from).safeApprove(UNISWAP, 0);\r\n        IERC20(_from).safeApprove(UNISWAP, _amount);\r\n\r\n        address[] memory path;\r\n\r\n        if (_from == WETH || _to == WETH) {\r\n            path = new address[](2);\r\n            path[0] = _from;\r\n            path[1] = _to;\r\n        } else {\r\n            path = new address[](3);\r\n            path[0] = _from;\r\n            path[1] = WETH;\r\n            path[2] = _to;\r\n        }\r\n\r\n        Uniswap(UNISWAP).swapExactTokensForTokens(\r\n            _amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            now.add(60)\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/strategies/StrategyCurve.sol\r\n\r\nabstract contract StrategyCurve is StrategyBase, UseUniswap {\r\n    // DAI = 0 | USDC = 1 | USDT = 2\r\n    uint internal underlyingIndex;\r\n    // precision to convert 10 ** 18  to underlying decimals\r\n    uint internal precisionDiv = 1;\r\n\r\n    // Curve //\r\n    // liquidity provider token (cDAI/cUSDC or 3Crv)\r\n    address internal lp;\r\n    // ICurveFi2 or ICurveFi3\r\n    address internal pool;\r\n    // Gauge\r\n    address internal gauge;\r\n    // Minter\r\n    address internal minter;\r\n    // DAO\r\n    address internal crv;\r\n\r\n    constructor(\r\n        address _controller,\r\n        address _vault,\r\n        address _underlying\r\n    ) public StrategyBase(_controller, _vault, _underlying) {}\r\n\r\n    function _getVirtualPrice() internal view virtual returns (uint);\r\n\r\n    function _totalAssets() internal view override returns (uint) {\r\n        uint lpBal = Gauge(gauge).balanceOf(address(this));\r\n        uint pricePerShare = _getVirtualPrice();\r\n\r\n        return lpBal.mul(pricePerShare).div(precisionDiv) / 1e18;\r\n    }\r\n\r\n    function _addLiquidity(uint _amount, uint _index) internal virtual;\r\n\r\n    /*\r\n    @notice deposit token into curve\r\n    */\r\n    function _deposit(address _token, uint _index) private {\r\n        // token to lp\r\n        uint bal = IERC20(_token).balanceOf(address(this));\r\n        if (bal > 0) {\r\n            IERC20(_token).safeApprove(pool, 0);\r\n            IERC20(_token).safeApprove(pool, bal);\r\n            // mint lp\r\n            _addLiquidity(bal, _index);\r\n        }\r\n\r\n        // stake into Gauge\r\n        uint lpBal = IERC20(lp).balanceOf(address(this));\r\n        if (lpBal > 0) {\r\n            IERC20(lp).safeApprove(gauge, 0);\r\n            IERC20(lp).safeApprove(gauge, lpBal);\r\n            Gauge(gauge).deposit(lpBal);\r\n        }\r\n    }\r\n\r\n    /*\r\n    @notice Deposits underlying to Gauge\r\n    */\r\n    function _depositUnderlying() internal override {\r\n        _deposit(underlying, underlyingIndex);\r\n    }\r\n\r\n    function _removeLiquidityOneCoin(uint _lpAmount) internal virtual;\r\n\r\n    function _getTotalShares() internal view override returns (uint) {\r\n        return Gauge(gauge).balanceOf(address(this));\r\n    }\r\n\r\n    function _withdrawUnderlying(uint _lpAmount) internal override {\r\n        // withdraw lp from  Gauge\r\n        Gauge(gauge).withdraw(_lpAmount);\r\n        // withdraw underlying\r\n        uint lpBal = IERC20(lp).balanceOf(address(this));\r\n        // creates lp dust\r\n        _removeLiquidityOneCoin(lpBal);\r\n        // Now we have underlying\r\n    }\r\n\r\n    /*\r\n    @notice Returns address and index of token with lowest balance in Curve pool\r\n    */\r\n    function _getMostPremiumToken() internal view virtual returns (address, uint);\r\n\r\n    function _swapCrvFor(address _token) private {\r\n        Minter(minter).mint(gauge);\r\n\r\n        uint crvBal = IERC20(crv).balanceOf(address(this));\r\n        if (crvBal > 0) {\r\n            _swap(crv, _token, crvBal);\r\n            // Now this contract has token\r\n        }\r\n    }\r\n\r\n    /*\r\n    @notice Claim CRV and deposit most premium token into Curve\r\n    */\r\n    function harvest() external override onlyAuthorized {\r\n        (address token, uint index) = _getMostPremiumToken();\r\n\r\n        _swapCrvFor(token);\r\n\r\n        uint bal = IERC20(token).balanceOf(address(this));\r\n        if (bal > 0) {\r\n            // transfer fee to treasury\r\n            uint fee = bal.mul(performanceFee) / PERFORMANCE_FEE_MAX;\r\n            if (fee > 0) {\r\n                address treasury = IController(controller).treasury();\r\n                require(treasury != address(0), \"treasury = zero address\");\r\n\r\n                IERC20(token).safeTransfer(treasury, fee);\r\n            }\r\n\r\n            _deposit(token, index);\r\n        }\r\n    }\r\n\r\n    /*\r\n    @notice Exit strategy by harvesting CRV to underlying token and then\r\n            withdrawing all underlying to vault\r\n    @dev Must return all underlying token to vault\r\n    @dev Caller should implement guard agains slippage\r\n    */\r\n    function exit() external override onlyAuthorized {\r\n        _swapCrvFor(underlying);\r\n        _withdrawAll();\r\n    }\r\n}\r\n\r\n// File: contracts/strategies/StrategyGusd.sol\r\n\r\ncontract StrategyGusd is StrategyCurve {\r\n    // 3Pool StableSwap\r\n    address private constant BASE_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\r\n    // GUSD StableSwap\r\n    address private constant SWAP = 0x4f062658EaAF2C1ccf8C8e36D6824CDf41167956;\r\n    address private constant GUSD = 0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd;\r\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\r\n    constructor(\r\n        address _controller,\r\n        address _vault,\r\n        address _underlying\r\n    ) public StrategyCurve(_controller, _vault, _underlying) {\r\n        // Curve\r\n        // GUSD / 3CRV\r\n        lp = 0xD2967f45c4f384DEEa880F807Be904762a3DeA07;\r\n        // DepositGusd\r\n        pool = 0x64448B78561690B70E17CBE8029a3e5c1bB7136e;\r\n        // Gauge\r\n        gauge = 0xC5cfaDA84E902aD92DD40194f0883ad49639b023;\r\n        // Minter\r\n        minter = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\r\n        // DAO\r\n        crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\r\n    }\r\n\r\n    function _getVirtualPrice() internal view override returns (uint) {\r\n        return StableSwapGusd(SWAP).get_virtual_price();\r\n    }\r\n\r\n    function _addLiquidity(uint _amount, uint _index) internal override {\r\n        uint[4] memory amounts;\r\n        amounts[_index] = _amount;\r\n        DepositGusd(pool).add_liquidity(amounts, 0);\r\n    }\r\n\r\n    function _removeLiquidityOneCoin(uint _lpAmount) internal override {\r\n        IERC20(lp).safeApprove(pool, 0);\r\n        IERC20(lp).safeApprove(pool, _lpAmount);\r\n\r\n        DepositGusd(pool).remove_liquidity_one_coin(\r\n            _lpAmount,\r\n            int128(underlyingIndex),\r\n            0\r\n        );\r\n    }\r\n\r\n    function _getMostPremiumToken() internal view override returns (address, uint) {\r\n        /*\r\n        Swapping small amount of CRV (< $0.01) with GUSD can cause Uniswap to fail\r\n        since 0 GUSD is returned from the trade.\r\n        So we skip buying GUSD\r\n        */\r\n        uint[3] memory balances;\r\n        balances[0] = StableSwap3(BASE_POOL).balances(0); // DAI\r\n        balances[1] = StableSwap3(BASE_POOL).balances(1).mul(1e12); // USDC\r\n        balances[2] = StableSwap3(BASE_POOL).balances(2).mul(1e12); // USDT\r\n\r\n        uint minIndex = 0;\r\n        for (uint i = 1; i < balances.length; i++) {\r\n            if (balances[i] <= balances[minIndex]) {\r\n                minIndex = i;\r\n            }\r\n        }\r\n\r\n        /*\r\n        DAI  1\r\n        USDC 2\r\n        USDT 3\r\n        */\r\n\r\n        if (minIndex == 0) {\r\n            return (DAI, 1);\r\n        }\r\n        if (minIndex == 1) {\r\n            return (USDC, 2);\r\n        }\r\n        return (USDT, 3);\r\n    }\r\n}\r\n\r\n// File: contracts/strategies/StrategyGusdDai.sol\r\n\r\ncontract StrategyGusdDai is StrategyGusd {\r\n    constructor(address _controller, address _vault)\r\n        public\r\n        StrategyGusd(_controller, _vault, DAI)\r\n    {\r\n        // dai\r\n        underlyingIndex = 1;\r\n        precisionDiv = 1;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StrategyGusdDai","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000013195fa27de3fc1b5adcfb9b005989157600efcc0000000000000000000000004ad0b81f92b16624bbcf46fc0030cfbbf8d02376","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c00eb8e7f854510c1c009f5a6a9eab386a166555fba647416f4a668dc2f61709"}]}