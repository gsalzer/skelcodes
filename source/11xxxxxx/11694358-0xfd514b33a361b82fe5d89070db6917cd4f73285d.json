{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/marketManagerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface marketManagerInterface  {\r\n\tfunction setBreakerTable(address _target, bool _status) external returns (bool);\r\n\r\n\tfunction getCircuitBreaker() external view returns (bool);\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory);\r\n\r\n\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) external returns (bool);\r\n\r\n\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256);\r\n\r\n\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256);\r\n\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256);\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\r\n\r\n\tfunction getTokenHandlersLength() external view returns (uint256);\r\n\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) external returns (bool);\r\n\r\n\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\r\n\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256);\r\n\r\n\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\r\n\r\n\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\r\n\r\n\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256);\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) external returns (uint256);\r\n\r\n\tfunction setLiquidationManager(address liquidationManagerAddr) external returns (bool);\r\n\r\n\tfunction rewardClaimAll(address payable userAddr) external returns (bool);\r\n\r\n\tfunction updateRewardParams(address payable userAddr) external returns (bool);\r\n\tfunction interestUpdateReward() external returns (bool);\r\n\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction setOracleProxy(address oracleProxyAddr) external returns (bool);\r\n\r\n\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool);\r\n\tfunction ownerRewardTransfer(uint256 _amount) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/managerDataStorageInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface managerDataStorageInterface  {\r\n\tfunction getGlobalRewardPerBlock() external view returns (uint256);\r\n\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\r\n\r\n\tfunction getGlobalRewardDecrement() external view returns (uint256);\r\n\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\r\n\r\n\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\r\n\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\r\n\r\n\tfunction getAlphaRate() external view returns (uint256);\r\n\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\r\n\r\n\tfunction getAlphaLastUpdated() external view returns (uint256);\r\n\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\r\n\r\n\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\r\n\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\r\n\r\n\tfunction getRewardParamUpdated() external view returns (uint256);\r\n\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\r\n\r\n\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\r\n\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\r\n\r\n\tfunction getInterestRewardUpdated() external view returns (uint256);\r\n\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\r\n\r\n\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\r\n\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\r\n\r\n\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\r\n\r\n\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\r\n\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\r\n\r\n\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\r\n\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\r\n\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\r\n\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\r\n\r\n\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\r\n\tfunction getLiquidationManagerAddr() external view returns (address);\r\n\r\n\tfunction setManagerAddr(address _managerAddr) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/marketHandlerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface marketHandlerInterface  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\r\n\r\n\tfunction getTokenName() external view returns (string memory);\r\n\r\n\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\r\n\r\n\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\r\n\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\r\n\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\r\n\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\r\n\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\r\n\r\n\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\r\n    function getTokenHandlerBorrowLimit() external view returns (uint256);\r\n\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\r\n\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\r\n\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\r\n\r\n\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\r\n\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction checkFirstAction() external returns (bool);\r\n\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\r\n\r\n\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\r\n\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\r\n\r\n\tfunction getDepositTotalAmount() external view returns (uint256);\r\n\tfunction getBorrowTotalAmount() external view returns (uint256);\r\n\r\n\tfunction getSIRandBIR() external view returns (uint256, uint256);\r\n}\r\n\r\n// File: contracts/interfaces/liquidationManagerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface liquidationManagerInterface  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\tfunction partialLiquidation(address payable delinquentBorrower, uint256 targetHandler, uint256 liquidateAmount, uint256 receiveHandler) external returns (uint256);\r\n\tfunction checkLiquidation(address payable userAddr) external view returns (bool);\r\n}\r\n\r\n// File: contracts/Errors.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Modifier {\r\n    string internal constant ONLY_OWNER = \"O\";\r\n    string internal constant ONLY_MANAGER = \"M\";\r\n    string internal constant CIRCUIT_BREAKER = \"emergency\";\r\n}\r\n\r\ncontract ManagerModifier is Modifier {\r\n    string internal constant ONLY_HANDLER = \"H\";\r\n    string internal constant ONLY_LIQUIDATION_MANAGER = \"LM\";\r\n    string internal constant ONLY_BREAKER = \"B\";\r\n}\r\n\r\ncontract HandlerDataStorageModifier is Modifier {\r\n    string internal constant ONLY_BIFI_CONTRACT = \"BF\";\r\n}\r\n\r\ncontract SIDataStorageModifier is Modifier {\r\n    string internal constant ONLY_SI_HANDLER = \"SI\";\r\n}\r\n\r\ncontract HandlerErrors is Modifier {\r\n    string internal constant USE_VAULE = \"use value\";\r\n    string internal constant USE_ARG = \"use arg\";\r\n    string internal constant EXCEED_LIMIT = \"exceed limit\";\r\n    string internal constant NO_LIQUIDATION = \"no liquidation\";\r\n    string internal constant NO_LIQUIDATION_REWARD = \"no enough reward\";\r\n    string internal constant NO_EFFECTIVE_BALANCE = \"not enough balance\";\r\n    string internal constant TRANSFER = \"err transfer\";\r\n}\r\n\r\ncontract SIErrors is Modifier { }\r\n\r\ncontract InterestErrors is Modifier { }\r\n\r\ncontract LiquidationManagerErrors is Modifier {\r\n    string internal constant NO_DELINQUENT = \"not delinquent\";\r\n}\r\n\r\ncontract ManagerErrors is ManagerModifier {\r\n    string internal constant REWARD_TRANSFER = \"RT\";\r\n    string internal constant UNSUPPORTED_TOKEN = \"UT\";\r\n}\r\n\r\ncontract OracleProxyErrors is Modifier {\r\n    string internal constant ZERO_PRICE = \"price zero\";\r\n}\r\n\r\ncontract RequestProxyErrors is Modifier { }\r\n\r\ncontract ManagerDataStorageErrors is ManagerModifier {\r\n    string internal constant NULL_ADDRESS = \"err addr null\";\r\n}\r\n\r\n// File: contracts/marketManager/liquidationManager.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi Liquidation Manager Contract\r\n *\r\n * @author BiFi\r\n */\r\ncontract etherLiquidationManager is liquidationManagerInterface, LiquidationManagerErrors {\r\n\tevent CircuitBreaked(bool breaked, uint256 blockNumber);\r\n\r\n\taddress payable owner;\r\n\r\n\tbool emergency = false;\r\n\r\n\tuint256 constant unifiedPoint = 10 ** 18;\r\n\r\n\tmarketManagerInterface public marketManager;\r\n\r\n\tstruct LiquidationModel {\r\n\t\tuint256 delinquentDepositAsset;\r\n\t\tuint256 delinquentBorrowAsset;\r\n\t\tuint256 liquidatePrice;\r\n\t\tuint256 receivePrice;\r\n\t\tuint256 liquidateAmount;\r\n\t\tuint256 liquidateAsset;\r\n\t\tuint256 rewardAsset;\r\n\t\tuint256 rewardAmount;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner, ONLY_OWNER);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyManager {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((msgSender == address(marketManager)) || (msgSender == owner), ONLY_MANAGER);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier circuitBreaker {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((!emergency) || (msgSender == owner), CIRCUIT_BREAKER);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Construct a new liquidationManager\r\n\t* @param marketManagerAddr The address of marketManager contract\r\n\t*/\r\n\tconstructor (address marketManagerAddr) public\r\n\t{\r\n\t\towner = msg.sender;\r\n\t\tmarketManager = marketManagerInterface(marketManagerAddr);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set new market manager address\r\n\t* @param marketManagerAddr The address of marketManager contract\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setMarketManagerAddr(address marketManagerAddr) external onlyOwner returns (bool) {\r\n\t\tmarketManager = marketManagerInterface(marketManagerAddr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer ownership\r\n\t* @param _owner the address of the new owner\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction ownershipTransfer(address payable _owner) onlyOwner public returns (bool)\r\n\t{\r\n\t\towner = _owner;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the address of owner\r\n\t* @return the address of owner\r\n\t*/\r\n\tfunction getOwner() public view returns (address)\r\n\t{\r\n\t\treturn owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set circuitBreak to freeze/unfreeze all handlers by marketManager\r\n\t* @param _emergency The status of circuitBreak\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setCircuitBreaker(bool _emergency) onlyManager external override returns (bool)\r\n\t{\r\n\t\temergency = _emergency;\r\n\t\temit CircuitBreaked(_emergency, block.number);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Liquidate asset of the user in default (or margin call) status\r\n\t* @param delinquentBorrower the liquidation target\r\n\t* @param targetHandler The hander ID of the liquidating asset (the\r\n\t  liquidator repay the tokens of the targetHandler instead)\r\n\t* @param liquidateAmount The amount to liquidate\r\n\t* @param receiveHandler The handler ID of the reward token for the liquidator\r\n\t* @return The amount of reward token\r\n\t*/\r\n\tfunction partialLiquidation(address payable delinquentBorrower, uint256 targetHandler, uint256 liquidateAmount, uint256 receiveHandler) circuitBreaker external override returns (uint256)\r\n\t{\r\n\t\t/* msg.sender is liquidator */\r\n\t\taddress payable liquidator = msg.sender;\r\n\t\tLiquidationModel memory vars;\r\n\t\t/* Check whether the user is in liquidation.*/\r\n\t\tif (_checkLiquidation(delinquentBorrower) == false)\r\n\t\t{\r\n\t\t\trevert(NO_DELINQUENT);\r\n\t\t}\r\n\r\n\t\t/* Liquidate */\r\n\t\t(vars.liquidateAmount, vars.delinquentDepositAsset, vars.delinquentBorrowAsset) = marketManager.partialLiquidationUser(delinquentBorrower, liquidateAmount, liquidator, targetHandler, receiveHandler);\r\n\r\n\t\t/* Compute the price of the liquidated tokens */\r\n\t\tvars.liquidatePrice = marketManager.getTokenHandlerPrice(targetHandler);\r\n\t\tvars.liquidateAsset = unifiedMul(vars.liquidateAmount, vars.liquidatePrice);\r\n\r\n\t\t/* Calculates the number of tokens to receive as rewards. */\r\n\t\tvars.rewardAsset = unifiedDiv(unifiedMul(vars.liquidateAsset, vars.delinquentDepositAsset), vars.delinquentBorrowAsset);\r\n\t\tvars.receivePrice = marketManager.getTokenHandlerPrice(receiveHandler);\r\n\t\tvars.rewardAmount = unifiedDiv(vars.rewardAsset, vars.receivePrice);\r\n\r\n\t\t/* Receive reward */\r\n\t\treturn marketManager.partialLiquidationUserReward(delinquentBorrower, vars.rewardAmount, liquidator, receiveHandler);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Checks the given user is eligible for delinquentBorrower (external)\r\n\t* @param userAddr The address of user\r\n\t* @return Eligibility as delinquentBorrower\r\n\t*/\r\n\tfunction checkLiquidation(address payable userAddr) external view override returns (bool)\r\n\t{\r\n\t\treturn _checkLiquidation(userAddr);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Checks the given user is eligible for delinquentBorrower (internal)\r\n\t* @param userAddr The address of user\r\n\t* @return Eligibility as delinquentBorrower\r\n\t*/\r\n\tfunction _checkLiquidation(address payable userAddr) internal view returns (bool)\r\n\t{\r\n\t\tuint256 userBorrowAssetSum;\r\n\t\tuint256 liquidationLimitAssetSum;\r\n\t\tuint256 tokenListLength = marketManager.getTokenHandlersLength();\r\n\t\tfor (uint256 handlerID = 0; handlerID < tokenListLength; handlerID++)\r\n\t\t{\r\n\t\t\tif (marketManager.getTokenHandlerSupport(handlerID))\r\n\t\t\t{\r\n\t\t\t\t/* Get the deposit and borrow amount including interest */\r\n\t\t\t\tuint256 depositAsset;\r\n\t\t\t\tuint256 borrowAsset;\r\n\t\t\t\t(depositAsset, borrowAsset) = marketManager.getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\r\n\r\n\r\n\t\t\t\t/* Compute the liquidation limit and the sum of borrow of the\r\n\t\t\t\tuser */\r\n\t\t\t\tuint256 marginCallLimit = marketManager.getTokenHandlerMarginCallLimit(handlerID);\r\n\t\t\t\tliquidationLimitAssetSum = add(liquidationLimitAssetSum, unifiedMul(depositAsset, marginCallLimit));\r\n\t\t\t\tuserBorrowAssetSum = add(userBorrowAssetSum, borrowAsset);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/* If the borrowed amount exceeds the liquidation limit, the user is a delinquent borrower. */\r\n\t\tif (liquidationLimitAssetSum <= userBorrowAssetSum)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t\t/* Margin call */\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/* ******************* Safe Math ******************* */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"add overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _sub(a, b, \"sub overflow\");\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _mul(a, b);\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(a, b, \"div by zero\");\r\n\t}\r\n\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _mod(a, b, \"mod by zero\");\r\n\t}\r\n\r\n\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b <= a, errorMessage);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire((c / a) == b, \"mul overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b > 0, errorMessage);\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction _mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b != 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, unifiedPoint), b, \"unified div by zero\");\r\n\t}\r\n\r\n\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, b), unifiedPoint, \"unified mul by zero\");\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketManagerAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"breaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CircuitBreaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"checkLiquidation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketManager\",\"outputs\":[{\"internalType\":\"contract marketManagerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ownershipTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"delinquentBorrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetHandler\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receiveHandler\",\"type\":\"uint256\"}],\"name\":\"partialLiquidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergency\",\"type\":\"bool\"}],\"name\":\"setCircuitBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketManagerAddr\",\"type\":\"address\"}],\"name\":\"setMarketManagerAddr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"etherLiquidationManager","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006e464417a4523ae2f3d59665b0b1fc37c1d17a2f","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7b99141926b1212fc5b8f57b1b97e189a1cc4f5e8b7a48c8bece90eeb7314687"}]}