{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-12-28\r\n*/\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.2;\r\n\r\n\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n\r\n  /**\r\n   * @dev Current owner address.\r\n   */\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based on the\r\n * source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\r\n */\r\nlibrary SafeMath\r\n{\r\n  /**\r\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return product The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return quotient The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return difference Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return sum Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return remainder Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder)\r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev signature of external (deployed) contract (ERC20 token)\r\n * only methods we will use\r\n */\r\ncontract ERC20Token {\r\n \r\n    function totalSupply() external view returns (uint256){}\r\n    function balanceOf(address account) external view returns (uint256){}\r\n    function allowance(address owner, address spender) external view returns (uint256){}\r\n    function transfer(address recipient, uint256 amount) external returns (bool){}\r\n    function approve(address spender, uint256 amount) external returns (bool){}\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool){}\r\n    function decimals()  external view returns (uint8){}\r\n  \r\n}\r\n\r\n\r\n\r\ncontract TokenSale is\r\n  Ownable, ReentrancyGuard\r\n{\r\n    using SafeMath for uint256;\r\n   \r\n    modifier onlyPriceManager() {\r\n      require(\r\n          msg.sender == price_manager,\r\n          \"only price manager can call this function\"\r\n          );\r\n          _;\r\n    }\r\n  \r\n    modifier onlyOwnerOrPriceManager() {\r\n      require(\r\n          msg.sender == price_manager || msg.sender == owner,\r\n          \"only owner or price manager can call this function\"\r\n          );\r\n          _;\r\n    }\r\n   \r\n    ERC20Token token;\r\n    \r\n    /**\r\n    * @dev some non-working address from the start to ensure owner will set correct one\r\n    */\r\n   \r\n    address ERC20Contract = 0x0000000000000000000000000000000000000000;\r\n    address price_manager = 0x0000000000000000000000000000000000000000;\r\n    \r\n    uint256 ref_commission = 5;\r\n    mapping(address => uint256) private ref_balances;\r\n    \r\n    /**\r\n    * @dev 10**18 for tokens with 18 digits, need to be changed accordingly (setter/getter)\r\n    */\r\n    uint256 adj_constant = 1000000000000000000; \r\n    \r\n    //initial in wei\r\n    uint256  sell_price = 100000000000000000; \r\n    \r\n    //initial in wei\r\n    uint256  buyout_price = 70000000000000000; \r\n    \r\n    uint256 constant curve_scale = 100000; \r\n    uint256 price_curve = 200; // in 1/100000  i.e. 1% == 1000, 0.1% == 100\r\n    uint256 sell_threshold = 250000000000000000;\r\n    \r\n    //events\r\n    event Bought(uint256 tokens_amount, uint256 amount_wei, address wallet);\r\n    event BoughtWithRef(uint256 tokens_amount, uint256 wei_amount, address buyer, address ref_wallet);\r\n    event Sold(uint256 tokens_amount, uint256 amount_wei, address wallet);\r\n    event TokensDeposited(uint256 amount, address wallet);\r\n    event FinneyDeposited(uint256 amount, address wallet);\r\n    event Withdrawn(uint256 amount, address wallet);\r\n    event RefWithdrawnEther(uint256 amount, address wallet);\r\n    event RefWithdrawnTokens(uint256 amount, address wallet);\r\n    event TokensWithdrawn(uint256 amount, address wallet);\r\n    event UpdateSellPrice(uint256 timestamp, uint256 new_price);\r\n    event UpdateBuyoutPrice(uint256 timestamp, uint256 new_price);\r\n   \r\n    /**\r\n    * @dev set price_manager == owner in the beginning, but could be changed by setter, below\r\n    */\r\n    constructor() public {\r\n        price_manager = owner;\r\n    }\r\n    \r\n    \r\n    function setPriceManagerRight(address newPriceManager) external onlyOwner{\r\n          price_manager = newPriceManager;\r\n    }\r\n      \r\n      \r\n    function getPriceManager() public view returns(address){\r\n        return price_manager;\r\n    }\r\n    \r\n    \r\n    function setPriceCurve(uint256 new_curve) external onlyOwnerOrPriceManager{\r\n          price_curve = new_curve;\r\n    }\r\n      \r\n    \r\n    function getPriceCurve() public view returns(uint256){\r\n        return price_curve;\r\n    }\r\n    \r\n    function setSellTreshold(uint256 new_treshold) external onlyOwnerOrPriceManager{\r\n          sell_threshold = new_treshold;\r\n    }\r\n      \r\n    \r\n    function getSellTreshold() public view returns(uint256){\r\n        return sell_threshold;\r\n    }\r\n    \r\n    \r\n    function upForecastPrice(uint256 current_price, uint256 num_tokens) public view returns(uint256) {\r\n        uint256 change =0;\r\n        uint256 forecast_price = current_price;\r\n        for (uint32 i=0; i < num_tokens; i++){\r\n             change = forecast_price.div(curve_scale).mul(price_curve);\r\n             forecast_price = forecast_price.add(change);\r\n        }\r\n        return forecast_price;\r\n    }\r\n    \r\n    function downForecastPrice(uint256 current_price, uint256 num_tokens) public view returns (uint256) {\r\n        uint256 change =0;\r\n        uint256 forecast_price = current_price;\r\n        for (uint32 i=0; i < num_tokens; i++){\r\n             change = forecast_price.div(curve_scale).mul(price_curve);\r\n             forecast_price = forecast_price.sub(change);\r\n        }\r\n        return forecast_price;\r\n    }\r\n    \r\n    function effectiveBuyAmount(uint256 current_price, uint256 num_tokens) public view returns(uint256) {\r\n        uint256 change =0;\r\n        uint256 forecast_price = current_price;\r\n        uint256 total_amount = current_price;\r\n        for (uint32 i=0; i < num_tokens-1; i++){\r\n             change = forecast_price.div(curve_scale).mul(price_curve);\r\n             forecast_price = forecast_price.add(change);\r\n             total_amount += forecast_price;\r\n        }\r\n        return total_amount;\r\n    }\r\n    \r\n    function effectiveSellAmount(uint256 current_price, uint256 num_tokens) public view returns(uint256) {\r\n       uint256 change =0;\r\n        uint256 forecast_price = current_price;\r\n        uint256 total_amount = current_price;\r\n        for (uint32 i=0; i < num_tokens-1; i++){\r\n             change = forecast_price.div(curve_scale).mul(price_curve);\r\n             forecast_price = forecast_price.sub(change);\r\n             total_amount += forecast_price;\r\n        }\r\n        return total_amount;\r\n    }\r\n    \r\n   \r\n    \r\n    function updatePricesBuy(uint256 num_tokens) internal {\r\n        sell_price = upForecastPrice(sell_price, num_tokens);\r\n        buyout_price = upForecastPrice(buyout_price, num_tokens);\r\n        uint256 timestamp = now;\r\n        emit UpdateSellPrice(timestamp,sell_price);\r\n        emit UpdateBuyoutPrice(timestamp, buyout_price);\r\n    }\r\n    \r\n    function updatePricesSell(uint256 num_tokens) internal {\r\n        sell_price = downForecastPrice(sell_price, num_tokens);\r\n        buyout_price = downForecastPrice(buyout_price, num_tokens);\r\n        uint256 timestamp = now;\r\n        emit UpdateSellPrice(timestamp,sell_price);\r\n        emit UpdateBuyoutPrice(timestamp, buyout_price);\r\n    }\r\n    \r\n    /**\r\n    * @dev setter/getter for ERC20 linked to exchange (current) smartcontract\r\n    */\r\n    function setERC20(address newERC20Contract) external onlyOwner returns(bool){\r\n        \r\n        ERC20Contract = newERC20Contract;\r\n        token = ERC20Token(ERC20Contract); \r\n    }\r\n    \r\n    \r\n    function getERC20() external view returns(address){\r\n        return ERC20Contract;\r\n    }\r\n\r\n    /**\r\n    * @dev setter/getter for digits constant (current 10**18)\r\n    */\r\n    function setAdjConstant(uint256 new_adj_constant) external onlyOwner{\r\n        adj_constant = new_adj_constant;\r\n    }\r\n    \r\n    function getAdjConstant() external view returns(uint256){  \r\n        return adj_constant;\r\n    }\r\n \r\n    /**\r\n    * @dev setter/getter for digits constant (current 10**18)\r\n    */\r\n    function setRefCommission(uint256 new_ref_commission) external onlyOwner{\r\n        ref_commission = new_ref_commission;\r\n    }\r\n    \r\n    function getRefCommission() external view returns(uint256){  \r\n        return ref_commission;\r\n    }\r\n \r\n \r\n    /**\r\n    * @dev setters/getters for prices \r\n    */\r\n    function setSellPrice(uint256 new_sell_price) external onlyPriceManager{\r\n        sell_price = new_sell_price;\r\n    }\r\n    \r\n    function setBuyOutPrice(uint256 new_buyout_price) external onlyPriceManager{\r\n        buyout_price = new_buyout_price;\r\n    }\r\n    \r\n    function getSellPrice() external view returns(uint256){  \r\n        return sell_price;\r\n    }\r\n    \r\n    function getBuyOutPrice() external view returns(uint256){  \r\n        return buyout_price;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n    * @dev user buys tokens \r\n    * ref_wallet parameter, set 0x0 if not used\r\n    */\r\n    function buy(address ref_wallet, uint256 num_tokens) payable external notContract nonReentrant returns (bool) {\r\n        uint256 amountSent = msg.value; //in wei..\r\n        require(amountSent == effectiveBuyAmount(sell_price,num_tokens), \"amount do not correspond\");\r\n        require(ref_wallet == address(0x0) || ref_wallet != msg.sender, \"you cannot use ref. code for yourself\");\r\n        \r\n         uint256 dexBalance = token.balanceOf(address(this));\r\n        //calc number of tokens (real ones, not converted based on decimals..)\r\n        uint256 amountTobuy = num_tokens; //tokens as user see them\r\n       \r\n        uint256 realAmountTobuy = amountTobuy.mul(adj_constant); //tokens adjusted to real ones\r\n        \r\n       \r\n        \r\n        require(realAmountTobuy > 0, \"not enough ether to buy any feasible amount of tokens\");\r\n        require(realAmountTobuy <= dexBalance, \"Not enough tokens in the reserve\");\r\n        \r\n    \r\n        \r\n        try token.transfer(msg.sender, realAmountTobuy) { //ensure we revert in case of failure\r\n            if (ref_wallet == address(0x0)){\r\n                emit Bought(amountTobuy, amountSent, msg.sender);\r\n            } else {\r\n                uint256 ref_comiss = amountSent.div(100).mul(ref_commission);\r\n                ref_balances[ref_wallet] = ref_balances[ref_wallet].add(ref_comiss);\r\n                \r\n                emit BoughtWithRef(amountTobuy, amountSent, msg.sender, ref_wallet);\r\n            }\r\n            updatePricesBuy(num_tokens);\r\n            return true;\r\n        } catch {\r\n            require(false,\"transfer failed\");\r\n        }\r\n        \r\n         //we could not get here, i.e. it is error if we here\r\n        return false;\r\n    }\r\n    \r\n    \r\n    receive() external payable {// called when ether is send, just do not allow it\r\n        revert();\r\n    }\r\n    \r\n    \r\n    /**\r\n    * @dev user sells tokens\r\n    */\r\n    function sell(uint256 amount_tokens) external notContract nonReentrant returns(bool) {\r\n        require(sell_price >= sell_threshold, \"price should reach threshold\");\r\n        uint256 amount_wei = 0;\r\n        require(amount_tokens > 0, \"You need to sell at least some tokens\");\r\n        uint256 realAmountTokens = amount_tokens.mul(adj_constant);\r\n        \r\n        uint256 token_bal = token.balanceOf(msg.sender);\r\n        require(token_bal >= realAmountTokens, \"Check the token balance on your wallet\");\r\n        uint256 allowance = token.allowance(msg.sender, address(this));\r\n        require(allowance >= realAmountTokens, \"Check the token allowance\");\r\n       \r\n        \r\n        amount_wei = effectiveSellAmount(buyout_price,amount_tokens);\r\n        \r\n        \r\n        \r\n        require(address(this).balance > amount_wei, \"unsufficient funds\");\r\n        bool success = false;\r\n       \r\n        //ensure we revert in case of failure \r\n        try token.transferFrom(msg.sender, address(this), realAmountTokens) { \r\n            //just continue if all good..\r\n        } catch {\r\n            require(false,\"tokens transfer failed\");\r\n            return false;\r\n        }\r\n        \r\n        \r\n        // **   msg.sender.transfer(amount_wei); .** \r\n       \r\n        (success, ) = msg.sender.call.value(amount_wei)(\"\");\r\n        require(success, \"Transfer failed.\");\r\n        // ** end **\r\n        updatePricesSell(amount_tokens);\r\n      \r\n            // all done..\r\n        emit Sold(amount_tokens, amount_wei, msg.sender);\r\n        return true; //normal completion\r\n       \r\n    }\r\n\r\n\r\n    \r\n    /**\r\n    * @dev returns contract balance, in wei\r\n    */\r\n    function getContractBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    /**\r\n    * @dev returns contract tokens balance\r\n    */\r\n    function getContractTokensBalance() external view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n    * @dev use of msg.sender in view function is not security measure (it doesnt work for view functions),\r\n    * it is used only for convinience here. And etherscan do not support it (limitation of etherscan view \r\n    * functions support, but web3 supports).\r\n    */\r\n    function checkRefBalance(address ref_wallet) external onlyOwner view returns (uint256) {\r\n        return ref_balances[ref_wallet];\r\n    }\r\n    \r\n    function setRefBalance(address ref_wallet, uint256 balance) external onlyOwner{\r\n         ref_balances[ref_wallet] = balance;\r\n    }\r\n    \r\n    /**\r\n    * @dev use of msg.sender in view function is not security measure (it doesnt work for view functions),\r\n    * it is used only for convinience here. And etherscan do not support it (limitation of etherscan view \r\n    * functions support, but web3 supports).\r\n    */\r\n    function checkOwnRefBalance() external view returns (uint256) {\r\n        return ref_balances[msg.sender];\r\n    }\r\n    \r\n    /**\r\n    * @dev - ref. withdraw ether\r\n    */\r\n    function ref_withdraw_ether() external notContract nonReentrant  {\r\n        require(ref_balances[msg.sender] >0,\"no balance\");\r\n       \r\n        uint256 amount = ref_balances[msg.sender]; //ether\r\n        \r\n        require(address(this).balance >= amount, \"unsufficient funds\");\r\n       \r\n        bool success = false;\r\n        // ** sendTo.transfer(amount);** \r\n        (success, ) = (payable(msg.sender)).call.value(amount)(\"\");\r\n        require(success, \"Transfer failed.\");\r\n        ref_balances[msg.sender] = 0;\r\n        // ** end **\r\n        emit RefWithdrawnEther(amount, msg.sender); //wei\r\n    }\r\n    \r\n     /**\r\n    * @dev - ref. withdraw ether\r\n    */\r\n    function ref_withdraw_tokens() external notContract nonReentrant  {\r\n        require(ref_balances[msg.sender] >0,\"no balance\");\r\n       \r\n        uint256 amount = ref_balances[msg.sender];//wei\r\n        \r\n        \r\n        uint256 dexBalance = token.balanceOf(address(this));\r\n        //calc number of tokens (real ones, not converted based on decimals..)\r\n        \r\n        //to ensure that divider is smaller\r\n        amount = amount.mul(100000);\r\n        \r\n        uint256 amount_tokens = amount.div(sell_price); //tokens as user see them\r\n       \r\n        uint256 real_amount_tokens = amount_tokens.mul(adj_constant); //tokens adjusted to real ones\r\n        \r\n        //convert back\r\n        real_amount_tokens = real_amount_tokens.div(100000);\r\n        \r\n        require(real_amount_tokens > 0, \"not enough balance to buy any feasible amount of tokens\");\r\n        require(real_amount_tokens <= dexBalance, \"Not enough tokens in the reserve\");\r\n        \r\n    \r\n        try token.transfer(msg.sender, real_amount_tokens) { //ensure we revert in case of failure\r\n            ref_balances[msg.sender] = 0;\r\n            emit RefWithdrawnTokens(real_amount_tokens, msg.sender); //wei\r\n        } catch {\r\n            require(false,\"transfer failed\");\r\n        }\r\n\r\n    }\r\n    \r\n    /**\r\n    * @dev - four functions below are for owner to \r\n    * deposit/withdraw eth/tokens to exchange contract\r\n    */\r\n    function withdraw(address payable sendTo, uint256 amount) external onlyOwner {\r\n        require(address(this).balance >= amount, \"unsufficient funds\");\r\n        bool success = false;\r\n        // ** sendTo.transfer(amount);** \r\n        (success, ) = sendTo.call.value(amount)(\"\");\r\n        require(success, \"Transfer failed.\");\r\n        // ** end **\r\n        emit Withdrawn(amount, sendTo); //wei\r\n    }\r\n  \r\n    \r\n    function deposit(uint256 amount) payable external onlyOwner { //amount in finney\r\n        require(amount*(1 finney) == msg.value,\"please provide value in finney\");\r\n        emit FinneyDeposited(amount, owner); //in finney\r\n    }\r\n\r\n    function depositTokens(uint256 amount) external onlyOwner {\r\n        require(amount > 0, \"You need to deposit at least some tokens\");\r\n        uint256 allowance = token.allowance(msg.sender, address(this));\r\n        require(allowance >= amount, \"Check the token allowance\");\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n        \r\n        emit TokensDeposited(amount.div(adj_constant), owner);\r\n    }\r\n    \r\n  \r\n    function withdrawTokens(address to_wallet, uint256 amount_tokens) external onlyOwner{\r\n        require(amount_tokens > 0, \"You need to withdraw at least some tokens\");\r\n        uint256 realAmountTokens = amount_tokens.mul(adj_constant);\r\n        uint256 contractTokenBalance = token.balanceOf(address(this));\r\n        \r\n        require(contractTokenBalance >= realAmountTokens, \"unsufficient funds\");\r\n      \r\n       \r\n        \r\n        //ensure we revert in case of failure \r\n        try token.transfer(to_wallet, realAmountTokens) { \r\n            //just continue if all good..\r\n        } catch {\r\n            require(false,\"tokens transfer failed\");\r\n           \r\n        }\r\n        \r\n    \r\n        // all done..\r\n        emit TokensWithdrawn(amount_tokens, to_wallet);\r\n    }\r\n    \r\n    \r\n    /**\r\n    * @dev service function to check tokens on wallet and allowance of wallet\r\n    */\r\n    function walletTokenBalance(address wallet) external view returns(uint256){\r\n        return token.balanceOf(wallet);\r\n    }\r\n    \r\n    /**\r\n    * @dev service function to check allowance of wallet for tokens\r\n    */\r\n    function walletTokenAllowance(address wallet) external view returns (uint256){\r\n        return  token.allowance(wallet, address(this)); \r\n    }\r\n    \r\n    \r\n    /**\r\n    * @dev not bullet-proof check, but additional measure, not to allow buy & sell from contracts\r\n    */\r\n    function isContract(address _addr) internal view returns (bool){\r\n      uint32 size;\r\n      assembly {\r\n          size := extcodesize(_addr)\r\n      }\r\n      \r\n      return (size > 0);\r\n    }\r\n    \r\n    modifier notContract(){\r\n      require(\r\n          (!isContract(msg.sender)),\r\n          \"external contracts are not allowed\"\r\n          );\r\n          _;\r\n    }\r\n    \r\n    //*** fire exit ***\r\n    function kill(address payable killAddress) external onlyOwner\r\n    {\r\n        uint256 contractTokenBalance = token.balanceOf(address(this));\r\n        token.transfer(killAddress, contractTokenBalance);\r\n        selfdestruct(killAddress);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_wei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wei_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ref_wallet\",\"type\":\"address\"}],\"name\":\"BoughtWithRef\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"FinneyDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"RefWithdrawnEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"RefWithdrawnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_wei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_price\",\"type\":\"uint256\"}],\"name\":\"UpdateBuyoutPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_price\",\"type\":\"uint256\"}],\"name\":\"UpdateSellPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num_tokens\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkOwnRefBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref_wallet\",\"type\":\"address\"}],\"name\":\"checkRefBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_tokens\",\"type\":\"uint256\"}],\"name\":\"downForecastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_tokens\",\"type\":\"uint256\"}],\"name\":\"effectiveBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_tokens\",\"type\":\"uint256\"}],\"name\":\"effectiveSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdjConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyOutPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractTokensBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRefCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"killAddress\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ref_withdraw_ether\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ref_withdraw_tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_tokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_adj_constant\",\"type\":\"uint256\"}],\"name\":\"setAdjConstant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_buyout_price\",\"type\":\"uint256\"}],\"name\":\"setBuyOutPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newERC20Contract\",\"type\":\"address\"}],\"name\":\"setERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_curve\",\"type\":\"uint256\"}],\"name\":\"setPriceCurve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPriceManager\",\"type\":\"address\"}],\"name\":\"setPriceManagerRight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"setRefBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_ref_commission\",\"type\":\"uint256\"}],\"name\":\"setRefCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_sell_price\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_treshold\",\"type\":\"uint256\"}],\"name\":\"setSellTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_tokens\",\"type\":\"uint256\"}],\"name\":\"upForecastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"walletTokenAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"walletTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_tokens\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TokenSale","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://102c037189cfae2c31b32ce47263db557a3b36c267ec86bca1834fab756d6611"}]}