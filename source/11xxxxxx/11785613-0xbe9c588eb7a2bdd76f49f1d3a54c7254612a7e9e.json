{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/AddressWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/access/Ownable.sol';\\nimport './Lockable.sol';\\n\\ncontract AddressWhitelist is Ownable, Lockable {\\n  enum Status {None, In, Out}\\n  mapping(address => Status) public whitelist;\\n\\n  address[] public whitelistIndices;\\n\\n  event AddedToWhitelist(address indexed addedAddress);\\n  event RemovedFromWhitelist(address indexed removedAddress);\\n\\n  function addToWhitelist(address newElement)\\n    external\\n    nonReentrant()\\n    onlyOwner\\n  {\\n    if (whitelist[newElement] == Status.In) {\\n      return;\\n    }\\n\\n    if (whitelist[newElement] == Status.None) {\\n      whitelistIndices.push(newElement);\\n    }\\n\\n    whitelist[newElement] = Status.In;\\n\\n    emit AddedToWhitelist(newElement);\\n  }\\n\\n  function removeFromWhitelist(address elementToRemove)\\n    external\\n    nonReentrant()\\n    onlyOwner\\n  {\\n    if (whitelist[elementToRemove] != Status.Out) {\\n      whitelist[elementToRemove] = Status.Out;\\n      emit RemovedFromWhitelist(elementToRemove);\\n    }\\n  }\\n\\n  function isOnWhitelist(address elementToCheck)\\n    external\\n    view\\n    nonReentrantView()\\n    returns (bool)\\n  {\\n    return whitelist[elementToCheck] == Status.In;\\n  }\\n\\n  function getWhitelist()\\n    external\\n    view\\n    nonReentrantView()\\n    returns (address[] memory activeWhitelist)\\n  {\\n    uint256 activeCount = 0;\\n    for (uint256 i = 0; i < whitelistIndices.length; i++) {\\n      if (whitelist[whitelistIndices[i]] == Status.In) {\\n        activeCount++;\\n      }\\n    }\\n\\n    activeWhitelist = new address[](activeCount);\\n    activeCount = 0;\\n    for (uint256 i = 0; i < whitelistIndices.length; i++) {\\n      address addr = whitelistIndices[i];\\n      if (whitelist[addr] == Status.In) {\\n        activeWhitelist[activeCount] = addr;\\n        activeCount++;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../GSN/Context.sol';\\n\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  constructor() internal {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Lockable {\\n  bool private _notEntered;\\n\\n  constructor() internal {\\n    _notEntered = true;\\n  }\\n\\n  modifier nonReentrant() {\\n    _preEntranceCheck();\\n    _preEntranceSet();\\n    _;\\n    _postEntranceReset();\\n  }\\n\\n  modifier nonReentrantView() {\\n    _preEntranceCheck();\\n    _;\\n  }\\n\\n  function _preEntranceCheck() internal view {\\n    require(_notEntered, 'ReentrancyGuard: reentrant call');\\n  }\\n\\n  function _preEntranceSet() internal {\\n    _notEntered = false;\\n  }\\n\\n  function _postEntranceReset() internal {\\n    _notEntered = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/OptimisticOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '../interfaces/StoreInterface.sol';\\nimport '../interfaces/OracleAncillaryInterface.sol';\\nimport '../interfaces/FinderInterface.sol';\\nimport '../interfaces/IdentifierWhitelistInterface.sol';\\nimport '../interfaces/OptimisticOracleInterface.sol';\\nimport './Constants.sol';\\n\\nimport '../../common/implementation/Testable.sol';\\nimport '../../common/implementation/Lockable.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/implementation/AddressWhitelist.sol';\\n\\ninterface OptimisticRequester {\\n  function priceProposed(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external;\\n\\n  function priceDisputed(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    uint256 refund\\n  ) external;\\n\\n  function priceSettled(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    int256 price\\n  ) external;\\n}\\n\\ncontract OptimisticOracle is OptimisticOracleInterface, Testable, Lockable {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using Address for address;\\n\\n  event RequestPrice(\\n    address indexed requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes ancillaryData,\\n    address currency,\\n    uint256 reward,\\n    uint256 finalFee\\n  );\\n  event ProposePrice(\\n    address indexed requester,\\n    address indexed proposer,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes ancillaryData,\\n    int256 proposedPrice\\n  );\\n  event DisputePrice(\\n    address indexed requester,\\n    address indexed proposer,\\n    address indexed disputer,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes ancillaryData\\n  );\\n  event Settle(\\n    address indexed requester,\\n    address indexed proposer,\\n    address indexed disputer,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes ancillaryData,\\n    int256 price,\\n    uint256 payout\\n  );\\n\\n  mapping(bytes32 => Request) public requests;\\n\\n  FinderInterface public finder;\\n\\n  uint256 public defaultLiveness;\\n\\n  constructor(\\n    uint256 _liveness,\\n    address _finderAddress,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    finder = FinderInterface(_finderAddress);\\n    _validateLiveness(_liveness);\\n    defaultLiveness = _liveness;\\n  }\\n\\n  function requestPrice(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    IERC20 currency,\\n    uint256 reward\\n  ) external override nonReentrant() returns (uint256 totalBond) {\\n    require(\\n      getState(msg.sender, identifier, timestamp, ancillaryData) ==\\n        State.Invalid,\\n      'requestPrice: Invalid'\\n    );\\n    require(\\n      _getIdentifierWhitelist().isIdentifierSupported(identifier),\\n      'Unsupported identifier'\\n    );\\n    require(\\n      _getCollateralWhitelist().isOnWhitelist(address(currency)),\\n      'Unsupported currency'\\n    );\\n    require(timestamp <= getCurrentTime(), 'Timestamp in future');\\n    require(\\n      ancillaryData.length <= ancillaryBytesLimit,\\n      'Invalid ancillary data'\\n    );\\n    uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\\n    requests[\\n      _getId(msg.sender, identifier, timestamp, ancillaryData)\\n    ] = Request({\\n      proposer: address(0),\\n      disputer: address(0),\\n      currency: currency,\\n      settled: false,\\n      refundOnDispute: false,\\n      proposedPrice: 0,\\n      resolvedPrice: 0,\\n      expirationTime: 0,\\n      reward: reward,\\n      finalFee: finalFee,\\n      bond: finalFee,\\n      customLiveness: 0\\n    });\\n\\n    if (reward > 0) {\\n      currency.safeTransferFrom(msg.sender, address(this), reward);\\n    }\\n\\n    emit RequestPrice(\\n      msg.sender,\\n      identifier,\\n      timestamp,\\n      ancillaryData,\\n      address(currency),\\n      reward,\\n      finalFee\\n    );\\n\\n    return finalFee.mul(2);\\n  }\\n\\n  function setBond(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    uint256 bond\\n  ) external override nonReentrant() returns (uint256 totalBond) {\\n    require(\\n      getState(msg.sender, identifier, timestamp, ancillaryData) ==\\n        State.Requested,\\n      'setBond: Requested'\\n    );\\n    Request storage request =\\n      _getRequest(msg.sender, identifier, timestamp, ancillaryData);\\n    request.bond = bond;\\n\\n    return bond.add(request.finalFee);\\n  }\\n\\n  function setRefundOnDispute(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external override nonReentrant() {\\n    require(\\n      getState(msg.sender, identifier, timestamp, ancillaryData) ==\\n        State.Requested,\\n      'setRefundOnDispute: Requested'\\n    );\\n    _getRequest(msg.sender, identifier, timestamp, ancillaryData)\\n      .refundOnDispute = true;\\n  }\\n\\n  function setCustomLiveness(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    uint256 customLiveness\\n  ) external override nonReentrant() {\\n    require(\\n      getState(msg.sender, identifier, timestamp, ancillaryData) ==\\n        State.Requested,\\n      'setCustomLiveness: Requested'\\n    );\\n    _validateLiveness(customLiveness);\\n    _getRequest(msg.sender, identifier, timestamp, ancillaryData)\\n      .customLiveness = customLiveness;\\n  }\\n\\n  function proposePriceFor(\\n    address proposer,\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    int256 proposedPrice\\n  ) public override nonReentrant() returns (uint256 totalBond) {\\n    require(proposer != address(0), 'proposer address must be non 0');\\n    require(\\n      getState(requester, identifier, timestamp, ancillaryData) ==\\n        State.Requested,\\n      'proposePriceFor: Requested'\\n    );\\n    Request storage request =\\n      _getRequest(requester, identifier, timestamp, ancillaryData);\\n    request.proposer = proposer;\\n    request.proposedPrice = proposedPrice;\\n\\n    request.expirationTime = getCurrentTime().add(\\n      request.customLiveness != 0 ? request.customLiveness : defaultLiveness\\n    );\\n\\n    totalBond = request.bond.add(request.finalFee);\\n    if (totalBond > 0) {\\n      request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\\n    }\\n\\n    emit ProposePrice(\\n      requester,\\n      proposer,\\n      identifier,\\n      timestamp,\\n      ancillaryData,\\n      proposedPrice\\n    );\\n\\n    if (address(requester).isContract())\\n      try\\n        OptimisticRequester(requester).priceProposed(\\n          identifier,\\n          timestamp,\\n          ancillaryData\\n        )\\n      {} catch {}\\n  }\\n\\n  function proposePrice(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    int256 proposedPrice\\n  ) external override returns (uint256 totalBond) {\\n    return\\n      proposePriceFor(\\n        msg.sender,\\n        requester,\\n        identifier,\\n        timestamp,\\n        ancillaryData,\\n        proposedPrice\\n      );\\n  }\\n\\n  function disputePriceFor(\\n    address disputer,\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public override nonReentrant() returns (uint256 totalBond) {\\n    require(disputer != address(0), 'disputer address must be non 0');\\n    require(\\n      getState(requester, identifier, timestamp, ancillaryData) ==\\n        State.Proposed,\\n      'disputePriceFor: Proposed'\\n    );\\n    Request storage request =\\n      _getRequest(requester, identifier, timestamp, ancillaryData);\\n    request.disputer = disputer;\\n\\n    uint256 finalFee = request.finalFee;\\n    uint256 bond = request.bond;\\n    totalBond = bond.add(finalFee);\\n    if (totalBond > 0) {\\n      request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\\n    }\\n\\n    StoreInterface store = _getStore();\\n    if (finalFee > 0) {\\n      uint256 burnedBond = _computeBurnedBond(request);\\n\\n      uint256 totalFee = finalFee.add(burnedBond);\\n      request.currency.safeIncreaseAllowance(address(store), totalFee);\\n      _getStore().payOracleFeesErc20(\\n        address(request.currency),\\n        FixedPoint.Unsigned(totalFee)\\n      );\\n    }\\n\\n    _getOracle().requestPrice(\\n      identifier,\\n      timestamp,\\n      _stampAncillaryData(ancillaryData, requester)\\n    );\\n\\n    uint256 refund = 0;\\n    if (request.reward > 0 && request.refundOnDispute) {\\n      refund = request.reward;\\n      request.reward = 0;\\n      request.currency.safeTransfer(requester, refund);\\n    }\\n\\n    emit DisputePrice(\\n      requester,\\n      request.proposer,\\n      disputer,\\n      identifier,\\n      timestamp,\\n      ancillaryData\\n    );\\n\\n    if (address(requester).isContract())\\n      try\\n        OptimisticRequester(requester).priceDisputed(\\n          identifier,\\n          timestamp,\\n          ancillaryData,\\n          refund\\n        )\\n      {} catch {}\\n  }\\n\\n  function disputePrice(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external override returns (uint256 totalBond) {\\n    return\\n      disputePriceFor(\\n        msg.sender,\\n        requester,\\n        identifier,\\n        timestamp,\\n        ancillaryData\\n      );\\n  }\\n\\n  function settleAndGetPrice(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external override nonReentrant() returns (int256) {\\n    if (\\n      getState(msg.sender, identifier, timestamp, ancillaryData) !=\\n      State.Settled\\n    ) {\\n      _settle(msg.sender, identifier, timestamp, ancillaryData);\\n    }\\n\\n    return\\n      _getRequest(msg.sender, identifier, timestamp, ancillaryData)\\n        .resolvedPrice;\\n  }\\n\\n  function settle(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external override nonReentrant() returns (uint256 payout) {\\n    return _settle(requester, identifier, timestamp, ancillaryData);\\n  }\\n\\n  function getRequest(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public view override returns (Request memory) {\\n    return _getRequest(requester, identifier, timestamp, ancillaryData);\\n  }\\n\\n  function getState(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public view override returns (State) {\\n    Request storage request =\\n      _getRequest(requester, identifier, timestamp, ancillaryData);\\n\\n    if (address(request.currency) == address(0)) {\\n      return State.Invalid;\\n    }\\n\\n    if (request.proposer == address(0)) {\\n      return State.Requested;\\n    }\\n\\n    if (request.settled) {\\n      return State.Settled;\\n    }\\n\\n    if (request.disputer == address(0)) {\\n      return\\n        request.expirationTime <= getCurrentTime()\\n          ? State.Expired\\n          : State.Proposed;\\n    }\\n\\n    return\\n      _getOracle().hasPrice(\\n        identifier,\\n        timestamp,\\n        _stampAncillaryData(ancillaryData, requester)\\n      )\\n        ? State.Resolved\\n        : State.Disputed;\\n  }\\n\\n  function hasPrice(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public view override returns (bool) {\\n    State state = getState(requester, identifier, timestamp, ancillaryData);\\n    return\\n      state == State.Settled ||\\n      state == State.Resolved ||\\n      state == State.Expired;\\n  }\\n\\n  function stampAncillaryData(bytes memory ancillaryData, address requester)\\n    public\\n    pure\\n    returns (bytes memory)\\n  {\\n    return _stampAncillaryData(ancillaryData, requester);\\n  }\\n\\n  function _getId(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) private pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encodePacked(requester, identifier, timestamp, ancillaryData)\\n      );\\n  }\\n\\n  function _settle(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) private returns (uint256 payout) {\\n    State state = getState(requester, identifier, timestamp, ancillaryData);\\n\\n    Request storage request =\\n      _getRequest(requester, identifier, timestamp, ancillaryData);\\n    request.settled = true;\\n\\n    if (state == State.Expired) {\\n      request.resolvedPrice = request.proposedPrice;\\n      payout = request.bond.add(request.finalFee).add(request.reward);\\n      request.currency.safeTransfer(request.proposer, payout);\\n    } else if (state == State.Resolved) {\\n      request.resolvedPrice = _getOracle().getPrice(\\n        identifier,\\n        timestamp,\\n        _stampAncillaryData(ancillaryData, requester)\\n      );\\n      bool disputeSuccess = request.resolvedPrice != request.proposedPrice;\\n      uint256 bond = request.bond;\\n\\n      uint256 unburnedBond = bond.sub(_computeBurnedBond(request));\\n\\n      payout = bond.add(unburnedBond).add(request.finalFee).add(request.reward);\\n      request.currency.safeTransfer(\\n        disputeSuccess ? request.disputer : request.proposer,\\n        payout\\n      );\\n    } else {\\n      revert('_settle: not settleable');\\n    }\\n\\n    emit Settle(\\n      requester,\\n      request.proposer,\\n      request.disputer,\\n      identifier,\\n      timestamp,\\n      ancillaryData,\\n      request.resolvedPrice,\\n      payout\\n    );\\n\\n    if (address(requester).isContract())\\n      try\\n        OptimisticRequester(requester).priceSettled(\\n          identifier,\\n          timestamp,\\n          ancillaryData,\\n          request.resolvedPrice\\n        )\\n      {} catch {}\\n  }\\n\\n  function _getRequest(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) private view returns (Request storage) {\\n    return requests[_getId(requester, identifier, timestamp, ancillaryData)];\\n  }\\n\\n  function _computeBurnedBond(Request storage request)\\n    private\\n    view\\n    returns (uint256)\\n  {\\n    return request.bond.div(2);\\n  }\\n\\n  function _validateLiveness(uint256 _liveness) private pure {\\n    require(_liveness < 5200 weeks, 'Liveness too large');\\n    require(_liveness > 0, 'Liveness cannot be 0');\\n  }\\n\\n  function _getOracle() internal view returns (OracleAncillaryInterface) {\\n    return\\n      OracleAncillaryInterface(\\n        finder.getImplementationAddress(OracleInterfaces.Oracle)\\n      );\\n  }\\n\\n  function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\\n    return\\n      AddressWhitelist(\\n        finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)\\n      );\\n  }\\n\\n  function _getStore() internal view returns (StoreInterface) {\\n    return\\n      StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    internal\\n    view\\n    returns (IdentifierWhitelistInterface)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\\n      );\\n  }\\n\\n  function _stampAncillaryData(bytes memory ancillaryData, address requester)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    return abi.encodePacked(ancillaryData, 'OptimisticOracle', requester);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\nimport '../../utils/Address.sol';\\n\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance =\\n      token.allowance(address(this), spender).sub(\\n        value,\\n        'SafeERC20: decreased allowance below zero'\\n      );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata =\\n      address(token).functionCall(data, 'SafeERC20: low-level call failed');\\n    if (returndata.length > 0) {\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/StoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface StoreInterface {\\n  function payOracleFees() external payable;\\n\\n  function payOracleFeesErc20(\\n    address erc20Address,\\n    FixedPoint.Unsigned calldata amount\\n  ) external;\\n\\n  function computeRegularFee(\\n    uint256 startTime,\\n    uint256 endTime,\\n    FixedPoint.Unsigned calldata pfc\\n  )\\n    external\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory regularFee,\\n      FixedPoint.Unsigned memory latePenalty\\n    );\\n\\n  function computeFinalFee(address currency)\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/OracleAncillaryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nabstract contract OracleAncillaryInterface {\\n  function requestPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) public virtual;\\n\\n  function hasPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) public view virtual returns (bool);\\n\\n  function getPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) public view virtual returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ninterface FinderInterface {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IdentifierWhitelistInterface {\\n  function addSupportedIdentifier(bytes32 identifier) external;\\n\\n  function removeSupportedIdentifier(bytes32 identifier) external;\\n\\n  function isIdentifierSupported(bytes32 identifier)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/OptimisticOracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nabstract contract OptimisticOracleInterface {\\n  enum State {\\n    Invalid,\\n    Requested,\\n    Proposed,\\n    Expired,\\n    Disputed,\\n    Resolved,\\n    Settled\\n  }\\n\\n  struct Request {\\n    address proposer;\\n    address disputer;\\n    IERC20 currency;\\n    bool settled;\\n    bool refundOnDispute;\\n    int256 proposedPrice;\\n    int256 resolvedPrice;\\n    uint256 expirationTime;\\n    uint256 reward;\\n    uint256 finalFee;\\n    uint256 bond;\\n    uint256 customLiveness;\\n  }\\n\\n  uint256 public constant ancillaryBytesLimit = 8192;\\n\\n  function requestPrice(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    IERC20 currency,\\n    uint256 reward\\n  ) external virtual returns (uint256 totalBond);\\n\\n  function setBond(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    uint256 bond\\n  ) external virtual returns (uint256 totalBond);\\n\\n  function setRefundOnDispute(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external virtual;\\n\\n  function setCustomLiveness(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    uint256 customLiveness\\n  ) external virtual;\\n\\n  function proposePriceFor(\\n    address proposer,\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    int256 proposedPrice\\n  ) public virtual returns (uint256 totalBond);\\n\\n  function proposePrice(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData,\\n    int256 proposedPrice\\n  ) external virtual returns (uint256 totalBond);\\n\\n  function disputePriceFor(\\n    address disputer,\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public virtual returns (uint256 totalBond);\\n\\n  function disputePrice(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external virtual returns (uint256 totalBond);\\n\\n  function settleAndGetPrice(\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external virtual returns (int256);\\n\\n  function settle(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) external virtual returns (uint256 payout);\\n\\n  function getRequest(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public view virtual returns (Request memory);\\n\\n  function getState(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public view virtual returns (State);\\n\\n  function hasPrice(\\n    address requester,\\n    bytes32 identifier,\\n    uint256 timestamp,\\n    bytes memory ancillaryData\\n  ) public view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nlibrary OracleInterfaces {\\n  bytes32 public constant Oracle = 'Oracle';\\n  bytes32 public constant IdentifierWhitelist = 'IdentifierWhitelist';\\n  bytes32 public constant Store = 'Store';\\n  bytes32 public constant FinancialContractsAdmin = 'FinancialContractsAdmin';\\n  bytes32 public constant Registry = 'Registry';\\n  bytes32 public constant CollateralWhitelist = 'CollateralWhitelist';\\n  bytes32 public constant OptimisticOracle = 'OptimisticOracle';\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport './Timer.sol';\\n\\nabstract contract Testable {\\n  address public timerAddress;\\n\\n  constructor(address _timerAddress) internal {\\n    timerAddress = _timerAddress;\\n  }\\n\\n  modifier onlyIfTest {\\n    require(timerAddress != address(0x0));\\n    _;\\n  }\\n\\n  function setCurrentTime(uint256 time) external onlyIfTest {\\n    Timer(timerAddress).setCurrentTime(time);\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    if (timerAddress != address(0x0)) {\\n      return Timer(timerAddress).getCurrentTime();\\n    } else {\\n      return now;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SignedSafeMath.sol';\\n\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  function mul(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function mulCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  function mulCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function div(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  function div(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  function divCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  function divCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  function pow(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory output)\\n  {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, 'Negative value provided');\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    require(a.rawValue <= uint256(type(int256).max), 'Unsigned too large');\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThan(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  function mul(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function div(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  function div(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  function divAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  function divAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  function pow(Signed memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Signed memory output)\\n  {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SignedSafeMath {\\n  int256 private constant _INT256_MIN = -2**255;\\n\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      !(a == -1 && b == _INT256_MIN),\\n      'SignedSafeMath: multiplication overflow'\\n    );\\n\\n    int256 c = a * b;\\n    require(c / a == b, 'SignedSafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, 'SignedSafeMath: division by zero');\\n    require(\\n      !(b == -1 && a == _INT256_MIN),\\n      'SignedSafeMath: division overflow'\\n    );\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require(\\n      (b >= 0 && c <= a) || (b < 0 && c > a),\\n      'SignedSafeMath: subtraction overflow'\\n    );\\n\\n    return c;\\n  }\\n\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require(\\n      (b >= 0 && c >= a) || (b < 0 && c < a),\\n      'SignedSafeMath: addition overflow'\\n    );\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Timer {\\n  uint256 private currentTime;\\n\\n  constructor() public {\\n    currentTime = now;\\n  }\\n\\n  function setCurrentTime(uint256 time) external {\\n    currentTime = time;\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    return currentTime;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/test/UmaInfrastructure.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  Finder\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/Finder.sol';\\nimport {\\n  Timer\\n} from '../../@jarvis-network/uma-core/contracts/common/implementation/Timer.sol';\\nimport {\\n  VotingToken\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/VotingToken.sol';\\nimport {\\n  TokenMigrator\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/TokenMigrator.sol';\\nimport {\\n  Voting\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/Voting.sol';\\nimport {\\n  IdentifierWhitelist\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/IdentifierWhitelist.sol';\\nimport {\\n  Registry\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/Registry.sol';\\nimport {\\n  FinancialContractsAdmin\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/FinancialContractsAdmin.sol';\\nimport {\\n  Store\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/Store.sol';\\nimport {\\n  Governor\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/Governor.sol';\\nimport {\\n  DesignatedVotingFactory\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/DesignatedVotingFactory.sol';\\nimport {\\n  TestnetERC20\\n} from '../../@jarvis-network/uma-core/contracts/common/implementation/TestnetERC20.sol';\\nimport {\\n  OptimisticOracle\\n} from '../../@jarvis-network/uma-core/contracts/oracle/implementation/OptimisticOracle.sol';\\nimport {\\n  MockOracle\\n} from '../../@jarvis-network/uma-core/contracts/oracle/test/MockOracle.sol';\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Finder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/access/Ownable.sol';\\nimport '../interfaces/FinderInterface.sol';\\n\\ncontract Finder is FinderInterface, Ownable {\\n  mapping(bytes32 => address) public interfacesImplemented;\\n\\n  event InterfaceImplementationChanged(\\n    bytes32 indexed interfaceName,\\n    address indexed newImplementationAddress\\n  );\\n\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external override onlyOwner {\\n    interfacesImplemented[interfaceName] = implementationAddress;\\n\\n    emit InterfaceImplementationChanged(interfaceName, implementationAddress);\\n  }\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    override\\n    returns (address)\\n  {\\n    address implementationAddress = interfacesImplemented[interfaceName];\\n    require(implementationAddress != address(0x0), 'Implementation not found');\\n    return implementationAddress;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/VotingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../common/implementation/ExpandedERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol';\\n\\ncontract VotingToken is ExpandedERC20, ERC20Snapshot {\\n  constructor() public ExpandedERC20('UMA Voting Token v1', 'UMA', 18) {}\\n\\n  function snapshot() external returns (uint256) {\\n    return _snapshot();\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20, ERC20Snapshot) {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/TokenMigrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/ExpandedIERC20.sol';\\nimport './VotingToken.sol';\\n\\ncontract TokenMigrator {\\n  using FixedPoint for FixedPoint.Unsigned;\\n\\n  VotingToken public oldToken;\\n  ExpandedIERC20 public newToken;\\n\\n  uint256 public snapshotId;\\n  FixedPoint.Unsigned public rate;\\n\\n  mapping(address => bool) public hasMigrated;\\n\\n  constructor(\\n    FixedPoint.Unsigned memory _rate,\\n    address _oldToken,\\n    address _newToken\\n  ) public {\\n    require(_rate.isGreaterThan(0), \\\"Rate can't be 0\\\");\\n    rate = _rate;\\n    newToken = ExpandedIERC20(_newToken);\\n    oldToken = VotingToken(_oldToken);\\n    snapshotId = oldToken.snapshot();\\n  }\\n\\n  function migrateTokens(address tokenHolder) external {\\n    require(!hasMigrated[tokenHolder], 'Already migrated tokens');\\n    hasMigrated[tokenHolder] = true;\\n\\n    FixedPoint.Unsigned memory oldBalance =\\n      FixedPoint.Unsigned(oldToken.balanceOfAt(tokenHolder, snapshotId));\\n\\n    if (!oldBalance.isGreaterThan(0)) {\\n      return;\\n    }\\n\\n    FixedPoint.Unsigned memory newBalance = oldBalance.div(rate);\\n    require(newToken.mint(tokenHolder, newBalance.rawValue), 'Mint failed');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Voting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/implementation/Testable.sol';\\nimport '../interfaces/FinderInterface.sol';\\nimport '../interfaces/OracleInterface.sol';\\nimport '../interfaces/OracleAncillaryInterface.sol';\\nimport '../interfaces/VotingInterface.sol';\\nimport '../interfaces/VotingAncillaryInterface.sol';\\nimport '../interfaces/IdentifierWhitelistInterface.sol';\\nimport './Registry.sol';\\nimport './ResultComputation.sol';\\nimport './VoteTiming.sol';\\nimport './VotingToken.sol';\\nimport './Constants.sol';\\n\\nimport '../../../../../@openzeppelin/contracts/access/Ownable.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/cryptography/ECDSA.sol';\\n\\ncontract Voting is\\n  Testable,\\n  Ownable,\\n  OracleInterface,\\n  OracleAncillaryInterface,\\n  VotingInterface,\\n  VotingAncillaryInterface\\n{\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeMath for uint256;\\n  using VoteTiming for VoteTiming.Data;\\n  using ResultComputation for ResultComputation.Data;\\n\\n  struct PriceRequest {\\n    bytes32 identifier;\\n    uint256 time;\\n    mapping(uint256 => VoteInstance) voteInstances;\\n    uint256 lastVotingRound;\\n    uint256 index;\\n    bytes ancillaryData;\\n  }\\n\\n  struct VoteInstance {\\n    mapping(address => VoteSubmission) voteSubmissions;\\n    ResultComputation.Data resultComputation;\\n  }\\n\\n  struct VoteSubmission {\\n    bytes32 commit;\\n    bytes32 revealHash;\\n  }\\n\\n  struct Round {\\n    uint256 snapshotId;\\n    FixedPoint.Unsigned inflationRate;\\n    FixedPoint.Unsigned gatPercentage;\\n    uint256 rewardsExpirationTime;\\n  }\\n\\n  enum RequestStatus {NotRequested, Active, Resolved, Future}\\n\\n  struct RequestState {\\n    RequestStatus status;\\n    uint256 lastVotingRound;\\n  }\\n\\n  mapping(uint256 => Round) public rounds;\\n\\n  mapping(bytes32 => PriceRequest) private priceRequests;\\n\\n  bytes32[] internal pendingPriceRequests;\\n\\n  VoteTiming.Data public voteTiming;\\n\\n  FixedPoint.Unsigned public gatPercentage;\\n\\n  FixedPoint.Unsigned public inflationRate;\\n\\n  uint256 public rewardsExpirationTimeout;\\n\\n  VotingToken public votingToken;\\n\\n  FinderInterface private finder;\\n\\n  address public migratedAddress;\\n\\n  uint256 private constant UINT_MAX = ~uint256(0);\\n\\n  uint256 public constant ancillaryBytesLimit = 8192;\\n\\n  bytes32 public snapshotMessageHash =\\n    ECDSA.toEthSignedMessageHash(keccak256(bytes('Sign For Snapshot')));\\n\\n  event VoteCommitted(\\n    address indexed voter,\\n    uint256 indexed roundId,\\n    bytes32 indexed identifier,\\n    uint256 time,\\n    bytes ancillaryData\\n  );\\n\\n  event EncryptedVote(\\n    address indexed voter,\\n    uint256 indexed roundId,\\n    bytes32 indexed identifier,\\n    uint256 time,\\n    bytes ancillaryData,\\n    bytes encryptedVote\\n  );\\n\\n  event VoteRevealed(\\n    address indexed voter,\\n    uint256 indexed roundId,\\n    bytes32 indexed identifier,\\n    uint256 time,\\n    int256 price,\\n    bytes ancillaryData,\\n    uint256 numTokens\\n  );\\n\\n  event RewardsRetrieved(\\n    address indexed voter,\\n    uint256 indexed roundId,\\n    bytes32 indexed identifier,\\n    uint256 time,\\n    bytes ancillaryData,\\n    uint256 numTokens\\n  );\\n\\n  event PriceRequestAdded(\\n    uint256 indexed roundId,\\n    bytes32 indexed identifier,\\n    uint256 time\\n  );\\n\\n  event PriceResolved(\\n    uint256 indexed roundId,\\n    bytes32 indexed identifier,\\n    uint256 time,\\n    int256 price,\\n    bytes ancillaryData\\n  );\\n\\n  constructor(\\n    uint256 _phaseLength,\\n    FixedPoint.Unsigned memory _gatPercentage,\\n    FixedPoint.Unsigned memory _inflationRate,\\n    uint256 _rewardsExpirationTimeout,\\n    address _votingToken,\\n    address _finder,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    voteTiming.init(_phaseLength);\\n    require(\\n      _gatPercentage.isLessThanOrEqual(1),\\n      'GAT percentage must be <= 100%'\\n    );\\n    gatPercentage = _gatPercentage;\\n    inflationRate = _inflationRate;\\n    votingToken = VotingToken(_votingToken);\\n    finder = FinderInterface(_finder);\\n    rewardsExpirationTimeout = _rewardsExpirationTimeout;\\n  }\\n\\n  modifier onlyRegisteredContract() {\\n    if (migratedAddress != address(0)) {\\n      require(msg.sender == migratedAddress, 'Caller must be migrated address');\\n    } else {\\n      Registry registry =\\n        Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\\n      require(\\n        registry.isContractRegistered(msg.sender),\\n        'Called must be registered'\\n      );\\n    }\\n    _;\\n  }\\n\\n  modifier onlyIfNotMigrated() {\\n    require(migratedAddress == address(0), 'Only call this if not migrated');\\n    _;\\n  }\\n\\n  function requestPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) public override onlyRegisteredContract() {\\n    uint256 blockTime = getCurrentTime();\\n    require(time <= blockTime, 'Can only request in past');\\n    require(\\n      _getIdentifierWhitelist().isIdentifierSupported(identifier),\\n      'Unsupported identifier request'\\n    );\\n    require(\\n      ancillaryData.length <= ancillaryBytesLimit,\\n      'Invalid ancillary data'\\n    );\\n\\n    bytes32 priceRequestId =\\n      _encodePriceRequest(identifier, time, ancillaryData);\\n    PriceRequest storage priceRequest = priceRequests[priceRequestId];\\n    uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\\n\\n    RequestStatus requestStatus =\\n      _getRequestStatus(priceRequest, currentRoundId);\\n\\n    if (requestStatus == RequestStatus.NotRequested) {\\n      uint256 nextRoundId = currentRoundId.add(1);\\n\\n      priceRequests[priceRequestId] = PriceRequest({\\n        identifier: identifier,\\n        time: time,\\n        lastVotingRound: nextRoundId,\\n        index: pendingPriceRequests.length,\\n        ancillaryData: ancillaryData\\n      });\\n      pendingPriceRequests.push(priceRequestId);\\n      emit PriceRequestAdded(nextRoundId, identifier, time);\\n    }\\n  }\\n\\n  function requestPrice(bytes32 identifier, uint256 time) public override {\\n    requestPrice(identifier, time, '');\\n  }\\n\\n  /**\\n   * @notice Whether the price for `identifier` and `time` is available.\\n   * @dev Time must be in the past and the identifier must be supported.\\n   * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\n   * @param time unix timestamp of for the price request.\\n   * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\n   * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\\n   */\\n  function hasPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) public view override onlyRegisteredContract() returns (bool) {\\n    (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\\n    return _hasPrice;\\n  }\\n\\n  // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\n  function hasPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    return hasPrice(identifier, time, '');\\n  }\\n\\n  /**\\n   * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\\n   * @dev If the price is not available, the method reverts.\\n   * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\n   * @param time unix timestamp of for the price request.\\n   * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\n   * @return int256 representing the resolved price for the given identifier and timestamp.\\n   */\\n  function getPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) public view override onlyRegisteredContract() returns (int256) {\\n    (bool _hasPrice, int256 price, string memory message) =\\n      _getPriceOrError(identifier, time, ancillaryData);\\n\\n    // If the price wasn't available, revert with the provided message.\\n    require(_hasPrice, message);\\n    return price;\\n  }\\n\\n  // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\n  function getPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    override\\n    returns (int256)\\n  {\\n    return getPrice(identifier, time, '');\\n  }\\n\\n  /**\\n   * @notice Gets the status of a list of price requests, identified by their identifier and time.\\n   * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\\n   * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.\\n   * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.\\n   */\\n  function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\\n    public\\n    view\\n    returns (RequestState[] memory)\\n  {\\n    RequestState[] memory requestStates = new RequestState[](requests.length);\\n    uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\n    for (uint256 i = 0; i < requests.length; i++) {\\n      PriceRequest storage priceRequest =\\n        _getPriceRequest(\\n          requests[i].identifier,\\n          requests[i].time,\\n          requests[i].ancillaryData\\n        );\\n\\n      RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\\n\\n      // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\\n      if (status == RequestStatus.Active) {\\n        requestStates[i].lastVotingRound = currentRoundId;\\n      } else {\\n        requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\\n      }\\n      requestStates[i].status = status;\\n    }\\n    return requestStates;\\n  }\\n\\n  // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\n  function getPriceRequestStatuses(PendingRequest[] memory requests)\\n    public\\n    view\\n    returns (RequestState[] memory)\\n  {\\n    PendingRequestAncillary[] memory requestsAncillary =\\n      new PendingRequestAncillary[](requests.length);\\n\\n    for (uint256 i = 0; i < requests.length; i++) {\\n      requestsAncillary[i].identifier = requests[i].identifier;\\n      requestsAncillary[i].time = requests[i].time;\\n      requestsAncillary[i].ancillaryData = '';\\n    }\\n    return getPriceRequestStatuses(requestsAncillary);\\n  }\\n\\n  /****************************************\\n   *            VOTING FUNCTIONS          *\\n   ****************************************/\\n\\n  /**\\n   * @notice Commit a vote for a price request for `identifier` at `time`.\\n   * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\\n   * Commits can be changed.\\n   * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system’s expected behavior,\\n   * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\\n   * they can determine the vote pre-reveal.\\n   * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\\n   * @param time unix timestamp of the price being voted on.\\n   * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\n   * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\\n   */\\n  function commitVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData,\\n    bytes32 hash\\n  ) public override onlyIfNotMigrated() {\\n    require(hash != bytes32(0), 'Invalid provided hash');\\n\\n    uint256 blockTime = getCurrentTime();\\n    require(\\n      voteTiming.computeCurrentPhase(blockTime) ==\\n        VotingAncillaryInterface.Phase.Commit,\\n      'Cannot commit in reveal phase'\\n    );\\n\\n    uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\\n\\n    PriceRequest storage priceRequest =\\n      _getPriceRequest(identifier, time, ancillaryData);\\n    require(\\n      _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\\n      'Cannot commit inactive request'\\n    );\\n\\n    priceRequest.lastVotingRound = currentRoundId;\\n    VoteInstance storage voteInstance =\\n      priceRequest.voteInstances[currentRoundId];\\n    voteInstance.voteSubmissions[msg.sender].commit = hash;\\n\\n    emit VoteCommitted(\\n      msg.sender,\\n      currentRoundId,\\n      identifier,\\n      time,\\n      ancillaryData\\n    );\\n  }\\n\\n  function commitVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes32 hash\\n  ) public override onlyIfNotMigrated() {\\n    commitVote(identifier, time, '', hash);\\n  }\\n\\n  /**\\n   * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.\\n   * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`\\n   * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.\\n   * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\\n   * snapshot.\\n   */\\n  function snapshotCurrentRound(bytes calldata signature)\\n    external\\n    override(VotingInterface, VotingAncillaryInterface)\\n    onlyIfNotMigrated()\\n  {\\n    uint256 blockTime = getCurrentTime();\\n    require(\\n      voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal,\\n      'Only snapshot in reveal phase'\\n    );\\n\\n    require(\\n      ECDSA.recover(snapshotMessageHash, signature) == msg.sender,\\n      'Signature must match sender'\\n    );\\n    uint256 roundId = voteTiming.computeCurrentRoundId(blockTime);\\n    _freezeRoundVariables(roundId);\\n  }\\n\\n  function revealVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    int256 price,\\n    bytes memory ancillaryData,\\n    int256 salt\\n  ) public override onlyIfNotMigrated() {\\n    require(\\n      voteTiming.computeCurrentPhase(getCurrentTime()) == Phase.Reveal,\\n      'Cannot reveal in commit phase'\\n    );\\n\\n    uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\n\\n    PriceRequest storage priceRequest =\\n      _getPriceRequest(identifier, time, ancillaryData);\\n    VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\\n    VoteSubmission storage voteSubmission =\\n      voteInstance.voteSubmissions[msg.sender];\\n\\n    {\\n      require(voteSubmission.commit != bytes32(0), 'Invalid hash reveal');\\n      require(\\n        keccak256(\\n          abi.encodePacked(\\n            price,\\n            salt,\\n            msg.sender,\\n            time,\\n            ancillaryData,\\n            roundId,\\n            identifier\\n          )\\n        ) == voteSubmission.commit,\\n        'Revealed data != commit hash'\\n      );\\n\\n      require(rounds[roundId].snapshotId != 0, 'Round has no snapshot');\\n    }\\n\\n    uint256 snapshotId = rounds[roundId].snapshotId;\\n\\n    delete voteSubmission.commit;\\n\\n    FixedPoint.Unsigned memory balance =\\n      FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\\n\\n    voteSubmission.revealHash = keccak256(abi.encode(price));\\n\\n    voteInstance.resultComputation.addVote(price, balance);\\n\\n    emit VoteRevealed(\\n      msg.sender,\\n      roundId,\\n      identifier,\\n      time,\\n      price,\\n      ancillaryData,\\n      balance.rawValue\\n    );\\n  }\\n\\n  function revealVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    int256 price,\\n    int256 salt\\n  ) public override {\\n    revealVote(identifier, time, price, '', salt);\\n  }\\n\\n  /**\\n   * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\\n   * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\\n   * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\\n   * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\\n   * @param time unix timestamp of for the price request.\\n   * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\n   * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\\n   * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\\n   */\\n  function commitAndEmitEncryptedVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData,\\n    bytes32 hash,\\n    bytes memory encryptedVote\\n  ) public override {\\n    commitVote(identifier, time, ancillaryData, hash);\\n\\n    uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\n    emit EncryptedVote(\\n      msg.sender,\\n      roundId,\\n      identifier,\\n      time,\\n      ancillaryData,\\n      encryptedVote\\n    );\\n  }\\n\\n  // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\n  function commitAndEmitEncryptedVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes32 hash,\\n    bytes memory encryptedVote\\n  ) public override {\\n    commitVote(identifier, time, '', hash);\\n\\n    commitAndEmitEncryptedVote(identifier, time, '', hash, encryptedVote);\\n  }\\n\\n  /**\\n   * @notice Submit a batch of commits in a single transaction.\\n   * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.\\n   * Look at `project-root/common/Constants.js` for the tested maximum number of\\n   * commitments that can fit in one transaction.\\n   * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\\n   */\\n  function batchCommit(CommitmentAncillary[] memory commits) public override {\\n    for (uint256 i = 0; i < commits.length; i++) {\\n      if (commits[i].encryptedVote.length == 0) {\\n        commitVote(\\n          commits[i].identifier,\\n          commits[i].time,\\n          commits[i].ancillaryData,\\n          commits[i].hash\\n        );\\n      } else {\\n        commitAndEmitEncryptedVote(\\n          commits[i].identifier,\\n          commits[i].time,\\n          commits[i].ancillaryData,\\n          commits[i].hash,\\n          commits[i].encryptedVote\\n        );\\n      }\\n    }\\n  }\\n\\n  // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\n  function batchCommit(Commitment[] memory commits) public override {\\n    CommitmentAncillary[] memory commitsAncillary =\\n      new CommitmentAncillary[](commits.length);\\n\\n    for (uint256 i = 0; i < commits.length; i++) {\\n      commitsAncillary[i].identifier = commits[i].identifier;\\n      commitsAncillary[i].time = commits[i].time;\\n      commitsAncillary[i].ancillaryData = '';\\n      commitsAncillary[i].hash = commits[i].hash;\\n      commitsAncillary[i].encryptedVote = commits[i].encryptedVote;\\n    }\\n    batchCommit(commitsAncillary);\\n  }\\n\\n  /**\\n   * @notice Reveal multiple votes in a single transaction.\\n   * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\\n   * that can fit in one transaction.\\n   * @dev For more info on reveals, review the comment for `revealVote`.\\n   * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\\n   */\\n  function batchReveal(RevealAncillary[] memory reveals) public override {\\n    for (uint256 i = 0; i < reveals.length; i++) {\\n      revealVote(\\n        reveals[i].identifier,\\n        reveals[i].time,\\n        reveals[i].price,\\n        reveals[i].ancillaryData,\\n        reveals[i].salt\\n      );\\n    }\\n  }\\n\\n  // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\n  function batchReveal(Reveal[] memory reveals) public override {\\n    RevealAncillary[] memory revealsAncillary =\\n      new RevealAncillary[](reveals.length);\\n\\n    for (uint256 i = 0; i < reveals.length; i++) {\\n      revealsAncillary[i].identifier = reveals[i].identifier;\\n      revealsAncillary[i].time = reveals[i].time;\\n      revealsAncillary[i].price = reveals[i].price;\\n      revealsAncillary[i].ancillaryData = '';\\n      revealsAncillary[i].salt = reveals[i].salt;\\n    }\\n    batchReveal(revealsAncillary);\\n  }\\n\\n  /**\\n   * @notice Retrieves rewards owed for a set of resolved price requests.\\n   * @dev Can only retrieve rewards if calling for a valid round and if the call is done within the timeout threshold\\n   * (not expired). Note that a named return value is used here to avoid a stack to deep error.\\n   * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\\n   * @param roundId the round from which voting rewards will be retrieved from.\\n   * @param toRetrieve array of PendingRequests which rewards are retrieved from.\\n   * @return totalRewardToIssue total amount of rewards returned to the voter.\\n   */\\n  function retrieveRewards(\\n    address voterAddress,\\n    uint256 roundId,\\n    PendingRequestAncillary[] memory toRetrieve\\n  ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\\n    if (migratedAddress != address(0)) {\\n      require(msg.sender == migratedAddress, 'Can only call from migrated');\\n    }\\n    require(\\n      roundId < voteTiming.computeCurrentRoundId(getCurrentTime()),\\n      'Invalid roundId'\\n    );\\n\\n    Round storage round = rounds[roundId];\\n    bool isExpired = getCurrentTime() > round.rewardsExpirationTime;\\n    FixedPoint.Unsigned memory snapshotBalance =\\n      FixedPoint.Unsigned(\\n        votingToken.balanceOfAt(voterAddress, round.snapshotId)\\n      );\\n\\n    FixedPoint.Unsigned memory snapshotTotalSupply =\\n      FixedPoint.Unsigned(votingToken.totalSupplyAt(round.snapshotId));\\n    FixedPoint.Unsigned memory totalRewardPerVote =\\n      round.inflationRate.mul(snapshotTotalSupply);\\n\\n    totalRewardToIssue = FixedPoint.Unsigned(0);\\n\\n    for (uint256 i = 0; i < toRetrieve.length; i++) {\\n      PriceRequest storage priceRequest =\\n        _getPriceRequest(\\n          toRetrieve[i].identifier,\\n          toRetrieve[i].time,\\n          toRetrieve[i].ancillaryData\\n        );\\n      VoteInstance storage voteInstance =\\n        priceRequest.voteInstances[priceRequest.lastVotingRound];\\n\\n      require(\\n        priceRequest.lastVotingRound == roundId,\\n        'Retrieve for votes same round'\\n      );\\n\\n      _resolvePriceRequest(priceRequest, voteInstance);\\n\\n      if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\\n        continue;\\n      } else if (isExpired) {\\n        emit RewardsRetrieved(\\n          voterAddress,\\n          roundId,\\n          toRetrieve[i].identifier,\\n          toRetrieve[i].time,\\n          toRetrieve[i].ancillaryData,\\n          0\\n        );\\n      } else if (\\n        voteInstance.resultComputation.wasVoteCorrect(\\n          voteInstance.voteSubmissions[voterAddress].revealHash\\n        )\\n      ) {\\n        FixedPoint.Unsigned memory reward =\\n          snapshotBalance.mul(totalRewardPerVote).div(\\n            voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\\n          );\\n        totalRewardToIssue = totalRewardToIssue.add(reward);\\n\\n        emit RewardsRetrieved(\\n          voterAddress,\\n          roundId,\\n          toRetrieve[i].identifier,\\n          toRetrieve[i].time,\\n          toRetrieve[i].ancillaryData,\\n          reward.rawValue\\n        );\\n      } else {\\n        emit RewardsRetrieved(\\n          voterAddress,\\n          roundId,\\n          toRetrieve[i].identifier,\\n          toRetrieve[i].time,\\n          toRetrieve[i].ancillaryData,\\n          0\\n        );\\n      }\\n\\n      delete voteInstance.voteSubmissions[voterAddress].revealHash;\\n    }\\n\\n    if (totalRewardToIssue.isGreaterThan(0)) {\\n      require(\\n        votingToken.mint(voterAddress, totalRewardToIssue.rawValue),\\n        'Voting token issuance failed'\\n      );\\n    }\\n  }\\n\\n  function retrieveRewards(\\n    address voterAddress,\\n    uint256 roundId,\\n    PendingRequest[] memory toRetrieve\\n  ) public override returns (FixedPoint.Unsigned memory) {\\n    PendingRequestAncillary[] memory toRetrieveAncillary =\\n      new PendingRequestAncillary[](toRetrieve.length);\\n\\n    for (uint256 i = 0; i < toRetrieve.length; i++) {\\n      toRetrieveAncillary[i].identifier = toRetrieve[i].identifier;\\n      toRetrieveAncillary[i].time = toRetrieve[i].time;\\n      toRetrieveAncillary[i].ancillaryData = '';\\n    }\\n\\n    return retrieveRewards(voterAddress, roundId, toRetrieveAncillary);\\n  }\\n\\n  /****************************************\\n   *        VOTING GETTER FUNCTIONS       *\\n   ****************************************/\\n\\n  /**\\n   * @notice Gets the queries that are being voted on this round.\\n   * @return pendingRequests array containing identifiers of type `PendingRequest`.\\n   * and timestamps for all pending requests.\\n   */\\n  function getPendingRequests()\\n    external\\n    view\\n    override(VotingInterface, VotingAncillaryInterface)\\n    returns (PendingRequestAncillary[] memory)\\n  {\\n    uint256 blockTime = getCurrentTime();\\n    uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\\n\\n    // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\\n    // `pendingPriceRequests` only to those requests that have an Active RequestStatus.\\n    PendingRequestAncillary[] memory unresolved =\\n      new PendingRequestAncillary[](pendingPriceRequests.length);\\n    uint256 numUnresolved = 0;\\n\\n    for (uint256 i = 0; i < pendingPriceRequests.length; i++) {\\n      PriceRequest storage priceRequest =\\n        priceRequests[pendingPriceRequests[i]];\\n      if (\\n        _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active\\n      ) {\\n        unresolved[numUnresolved] = PendingRequestAncillary({\\n          identifier: priceRequest.identifier,\\n          time: priceRequest.time,\\n          ancillaryData: priceRequest.ancillaryData\\n        });\\n        numUnresolved++;\\n      }\\n    }\\n\\n    PendingRequestAncillary[] memory pendingRequests =\\n      new PendingRequestAncillary[](numUnresolved);\\n    for (uint256 i = 0; i < numUnresolved; i++) {\\n      pendingRequests[i] = unresolved[i];\\n    }\\n    return pendingRequests;\\n  }\\n\\n  /**\\n   * @notice Returns the current voting phase, as a function of the current time.\\n   * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\\n   */\\n  function getVotePhase()\\n    external\\n    view\\n    override(VotingInterface, VotingAncillaryInterface)\\n    returns (Phase)\\n  {\\n    return voteTiming.computeCurrentPhase(getCurrentTime());\\n  }\\n\\n  /**\\n   * @notice Returns the current round ID, as a function of the current time.\\n   * @return uint256 representing the unique round ID.\\n   */\\n  function getCurrentRoundId()\\n    external\\n    view\\n    override(VotingInterface, VotingAncillaryInterface)\\n    returns (uint256)\\n  {\\n    return voteTiming.computeCurrentRoundId(getCurrentTime());\\n  }\\n\\n  /****************************************\\n   *        OWNER ADMIN FUNCTIONS         *\\n   ****************************************/\\n\\n  /**\\n   * @notice Disables this Voting contract in favor of the migrated one.\\n   * @dev Can only be called by the contract owner.\\n   * @param newVotingAddress the newly migrated contract address.\\n   */\\n  function setMigrated(address newVotingAddress)\\n    external\\n    override(VotingInterface, VotingAncillaryInterface)\\n    onlyOwner\\n  {\\n    migratedAddress = newVotingAddress;\\n  }\\n\\n  /**\\n   * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\\n   * @dev This method is public because calldata structs are not currently supported by solidity.\\n   * @param newInflationRate sets the next round's inflation rate.\\n   */\\n  function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\\n    public\\n    override(VotingInterface, VotingAncillaryInterface)\\n    onlyOwner\\n  {\\n    inflationRate = newInflationRate;\\n  }\\n\\n  /**\\n   * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\\n   * @dev This method is public because calldata structs are not currently supported by solidity.\\n   * @param newGatPercentage sets the next round's Gat percentage.\\n   */\\n  function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\\n    public\\n    override(VotingInterface, VotingAncillaryInterface)\\n    onlyOwner\\n  {\\n    require(newGatPercentage.isLessThan(1), 'GAT percentage must be < 100%');\\n    gatPercentage = newGatPercentage;\\n  }\\n\\n  /**\\n   * @notice Resets the rewards expiration timeout.\\n   * @dev This change only applies to rounds that have not yet begun.\\n   * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\\n   */\\n  function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout)\\n    public\\n    override(VotingInterface, VotingAncillaryInterface)\\n    onlyOwner\\n  {\\n    rewardsExpirationTimeout = NewRewardsExpirationTimeout;\\n  }\\n\\n  /****************************************\\n   *    PRIVATE AND INTERNAL FUNCTIONS    *\\n   ****************************************/\\n\\n  // Returns the price for a given identifer. Three params are returns: bool if there was an error, int to represent\\n  // the resolved price and a string which is filled with an error message, if there was an error or \\\"\\\".\\n  function _getPriceOrError(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  )\\n    private\\n    view\\n    returns (\\n      bool,\\n      int256,\\n      string memory\\n    )\\n  {\\n    PriceRequest storage priceRequest =\\n      _getPriceRequest(identifier, time, ancillaryData);\\n    uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\n\\n    RequestStatus requestStatus =\\n      _getRequestStatus(priceRequest, currentRoundId);\\n    if (requestStatus == RequestStatus.Active) {\\n      return (false, 0, 'Current voting round not ended');\\n    } else if (requestStatus == RequestStatus.Resolved) {\\n      VoteInstance storage voteInstance =\\n        priceRequest.voteInstances[priceRequest.lastVotingRound];\\n      (, int256 resolvedPrice) =\\n        voteInstance.resultComputation.getResolvedPrice(\\n          _computeGat(priceRequest.lastVotingRound)\\n        );\\n      return (true, resolvedPrice, '');\\n    } else if (requestStatus == RequestStatus.Future) {\\n      return (false, 0, 'Price is still to be voted on');\\n    } else {\\n      return (false, 0, 'Price was never requested');\\n    }\\n  }\\n\\n  function _getPriceRequest(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) private view returns (PriceRequest storage) {\\n    return priceRequests[_encodePriceRequest(identifier, time, ancillaryData)];\\n  }\\n\\n  function _encodePriceRequest(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encode(identifier, time, ancillaryData));\\n  }\\n\\n  function _freezeRoundVariables(uint256 roundId) private {\\n    Round storage round = rounds[roundId];\\n\\n    if (round.snapshotId == 0) {\\n      round.snapshotId = votingToken.snapshot();\\n\\n      rounds[roundId].inflationRate = inflationRate;\\n\\n      rounds[roundId].gatPercentage = gatPercentage;\\n\\n      rounds[roundId].rewardsExpirationTime = voteTiming\\n        .computeRoundEndTime(roundId)\\n        .add(rewardsExpirationTimeout);\\n    }\\n  }\\n\\n  function _resolvePriceRequest(\\n    PriceRequest storage priceRequest,\\n    VoteInstance storage voteInstance\\n  ) private {\\n    if (priceRequest.index == UINT_MAX) {\\n      return;\\n    }\\n    (bool isResolved, int256 resolvedPrice) =\\n      voteInstance.resultComputation.getResolvedPrice(\\n        _computeGat(priceRequest.lastVotingRound)\\n      );\\n    require(isResolved, \\\"Can't resolve unresolved request\\\");\\n\\n    uint256 lastIndex = pendingPriceRequests.length - 1;\\n    PriceRequest storage lastPriceRequest =\\n      priceRequests[pendingPriceRequests[lastIndex]];\\n    lastPriceRequest.index = priceRequest.index;\\n    pendingPriceRequests[priceRequest.index] = pendingPriceRequests[lastIndex];\\n    pendingPriceRequests.pop();\\n\\n    priceRequest.index = UINT_MAX;\\n    emit PriceResolved(\\n      priceRequest.lastVotingRound,\\n      priceRequest.identifier,\\n      priceRequest.time,\\n      resolvedPrice,\\n      priceRequest.ancillaryData\\n    );\\n  }\\n\\n  function _computeGat(uint256 roundId)\\n    private\\n    view\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    uint256 snapshotId = rounds[roundId].snapshotId;\\n    if (snapshotId == 0) {\\n      return FixedPoint.Unsigned(UINT_MAX);\\n    }\\n\\n    FixedPoint.Unsigned memory snapshottedSupply =\\n      FixedPoint.Unsigned(votingToken.totalSupplyAt(snapshotId));\\n\\n    return snapshottedSupply.mul(rounds[roundId].gatPercentage);\\n  }\\n\\n  function _getRequestStatus(\\n    PriceRequest storage priceRequest,\\n    uint256 currentRoundId\\n  ) private view returns (RequestStatus) {\\n    if (priceRequest.lastVotingRound == 0) {\\n      return RequestStatus.NotRequested;\\n    } else if (priceRequest.lastVotingRound < currentRoundId) {\\n      VoteInstance storage voteInstance =\\n        priceRequest.voteInstances[priceRequest.lastVotingRound];\\n      (bool isResolved, ) =\\n        voteInstance.resultComputation.getResolvedPrice(\\n          _computeGat(priceRequest.lastVotingRound)\\n        );\\n      return isResolved ? RequestStatus.Resolved : RequestStatus.Active;\\n    } else if (priceRequest.lastVotingRound == currentRoundId) {\\n      return RequestStatus.Active;\\n    } else {\\n      return RequestStatus.Future;\\n    }\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    private\\n    view\\n    returns (IdentifierWhitelistInterface supportedIdentifiers)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/IdentifierWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../interfaces/IdentifierWhitelistInterface.sol';\\nimport '../../../../../@openzeppelin/contracts/access/Ownable.sol';\\n\\ncontract IdentifierWhitelist is IdentifierWhitelistInterface, Ownable {\\n  mapping(bytes32 => bool) private supportedIdentifiers;\\n\\n  event SupportedIdentifierAdded(bytes32 indexed identifier);\\n  event SupportedIdentifierRemoved(bytes32 indexed identifier);\\n\\n  function addSupportedIdentifier(bytes32 identifier)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    if (!supportedIdentifiers[identifier]) {\\n      supportedIdentifiers[identifier] = true;\\n      emit SupportedIdentifierAdded(identifier);\\n    }\\n  }\\n\\n  function removeSupportedIdentifier(bytes32 identifier)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    if (supportedIdentifiers[identifier]) {\\n      supportedIdentifiers[identifier] = false;\\n      emit SupportedIdentifierRemoved(identifier);\\n    }\\n  }\\n\\n  function isIdentifierSupported(bytes32 identifier)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    return supportedIdentifiers[identifier];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/MultiRole.sol';\\nimport '../interfaces/RegistryInterface.sol';\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\n\\ncontract Registry is RegistryInterface, MultiRole {\\n  using SafeMath for uint256;\\n\\n  enum Roles {Owner, ContractCreator}\\n\\n  enum Validity {Invalid, Valid}\\n\\n  struct FinancialContract {\\n    Validity valid;\\n    uint128 index;\\n  }\\n\\n  struct Party {\\n    address[] contracts;\\n    mapping(address => uint256) contractIndex;\\n  }\\n\\n  address[] public registeredContracts;\\n\\n  mapping(address => FinancialContract) public contractMap;\\n\\n  mapping(address => Party) private partyMap;\\n\\n  event NewContractRegistered(\\n    address indexed contractAddress,\\n    address indexed creator,\\n    address[] parties\\n  );\\n  event PartyAdded(address indexed contractAddress, address indexed party);\\n  event PartyRemoved(address indexed contractAddress, address indexed party);\\n\\n  constructor() public {\\n    _createExclusiveRole(\\n      uint256(Roles.Owner),\\n      uint256(Roles.Owner),\\n      msg.sender\\n    );\\n\\n    _createSharedRole(\\n      uint256(Roles.ContractCreator),\\n      uint256(Roles.Owner),\\n      new address[](0)\\n    );\\n  }\\n\\n  function registerContract(address[] calldata parties, address contractAddress)\\n    external\\n    override\\n    onlyRoleHolder(uint256(Roles.ContractCreator))\\n  {\\n    FinancialContract storage financialContract = contractMap[contractAddress];\\n    require(\\n      contractMap[contractAddress].valid == Validity.Invalid,\\n      'Can only register once'\\n    );\\n\\n    registeredContracts.push(contractAddress);\\n\\n    financialContract.index = uint128(registeredContracts.length.sub(1));\\n\\n    financialContract.valid = Validity.Valid;\\n    for (uint256 i = 0; i < parties.length; i = i.add(1)) {\\n      _addPartyToContract(parties[i], contractAddress);\\n    }\\n\\n    emit NewContractRegistered(contractAddress, msg.sender, parties);\\n  }\\n\\n  function addPartyToContract(address party) external override {\\n    address contractAddress = msg.sender;\\n    require(\\n      contractMap[contractAddress].valid == Validity.Valid,\\n      'Can only add to valid contract'\\n    );\\n\\n    _addPartyToContract(party, contractAddress);\\n  }\\n\\n  function removePartyFromContract(address partyAddress) external override {\\n    address contractAddress = msg.sender;\\n    Party storage party = partyMap[partyAddress];\\n    uint256 numberOfContracts = party.contracts.length;\\n\\n    require(numberOfContracts != 0, 'Party has no contracts');\\n    require(\\n      contractMap[contractAddress].valid == Validity.Valid,\\n      'Remove only from valid contract'\\n    );\\n    require(\\n      isPartyMemberOfContract(partyAddress, contractAddress),\\n      'Can only remove existing party'\\n    );\\n\\n    uint256 deleteIndex = party.contractIndex[contractAddress];\\n\\n    address lastContractAddress = party.contracts[numberOfContracts - 1];\\n\\n    party.contracts[deleteIndex] = lastContractAddress;\\n\\n    party.contractIndex[lastContractAddress] = deleteIndex;\\n\\n    party.contracts.pop();\\n    delete party.contractIndex[contractAddress];\\n\\n    emit PartyRemoved(contractAddress, partyAddress);\\n  }\\n\\n  function isContractRegistered(address contractAddress)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    return contractMap[contractAddress].valid == Validity.Valid;\\n  }\\n\\n  function getRegisteredContracts(address party)\\n    external\\n    view\\n    override\\n    returns (address[] memory)\\n  {\\n    return partyMap[party].contracts;\\n  }\\n\\n  function getAllRegisteredContracts()\\n    external\\n    view\\n    override\\n    returns (address[] memory)\\n  {\\n    return registeredContracts;\\n  }\\n\\n  function isPartyMemberOfContract(address party, address contractAddress)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    uint256 index = partyMap[party].contractIndex[contractAddress];\\n    return\\n      partyMap[party].contracts.length > index &&\\n      partyMap[party].contracts[index] == contractAddress;\\n  }\\n\\n  function _addPartyToContract(address party, address contractAddress)\\n    internal\\n  {\\n    require(\\n      !isPartyMemberOfContract(party, contractAddress),\\n      'Can only register a party once'\\n    );\\n    uint256 contractIndex = partyMap[party].contracts.length;\\n    partyMap[party].contracts.push(contractAddress);\\n    partyMap[party].contractIndex[contractAddress] = contractIndex;\\n\\n    emit PartyAdded(contractAddress, party);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/FinancialContractsAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../interfaces/AdministrateeInterface.sol';\\nimport '../../../../../@openzeppelin/contracts/access/Ownable.sol';\\n\\ncontract FinancialContractsAdmin is Ownable {\\n  function callEmergencyShutdown(address financialContract) external onlyOwner {\\n    AdministrateeInterface administratee =\\n      AdministrateeInterface(financialContract);\\n    administratee.emergencyShutdown();\\n  }\\n\\n  function callRemargin(address financialContract) external onlyOwner {\\n    AdministrateeInterface administratee =\\n      AdministrateeInterface(financialContract);\\n    administratee.remargin();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Store.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/implementation/MultiRole.sol';\\nimport '../../common/implementation/Withdrawable.sol';\\nimport '../../common/implementation/Testable.sol';\\nimport '../interfaces/StoreInterface.sol';\\n\\ncontract Store is StoreInterface, Withdrawable, Testable {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FixedPoint for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  enum Roles {Owner, Withdrawer}\\n\\n  FixedPoint.Unsigned public fixedOracleFeePerSecondPerPfc;\\n  FixedPoint.Unsigned public weeklyDelayFeePerSecondPerPfc;\\n\\n  mapping(address => FixedPoint.Unsigned) public finalFees;\\n  uint256 public constant SECONDS_PER_WEEK = 604800;\\n\\n  event NewFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned newOracleFee);\\n  event NewWeeklyDelayFeePerSecondPerPfc(\\n    FixedPoint.Unsigned newWeeklyDelayFeePerSecondPerPfc\\n  );\\n  event NewFinalFee(FixedPoint.Unsigned newFinalFee);\\n\\n  constructor(\\n    FixedPoint.Unsigned memory _fixedOracleFeePerSecondPerPfc,\\n    FixedPoint.Unsigned memory _weeklyDelayFeePerSecondPerPfc,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    _createExclusiveRole(\\n      uint256(Roles.Owner),\\n      uint256(Roles.Owner),\\n      msg.sender\\n    );\\n    _createWithdrawRole(\\n      uint256(Roles.Withdrawer),\\n      uint256(Roles.Owner),\\n      msg.sender\\n    );\\n    setFixedOracleFeePerSecondPerPfc(_fixedOracleFeePerSecondPerPfc);\\n    setWeeklyDelayFeePerSecondPerPfc(_weeklyDelayFeePerSecondPerPfc);\\n  }\\n\\n  function payOracleFees() external payable override {\\n    require(msg.value > 0, \\\"Value sent can't be zero\\\");\\n  }\\n\\n  function payOracleFeesErc20(\\n    address erc20Address,\\n    FixedPoint.Unsigned calldata amount\\n  ) external override {\\n    IERC20 erc20 = IERC20(erc20Address);\\n    require(amount.isGreaterThan(0), \\\"Amount sent can't be zero\\\");\\n    erc20.safeTransferFrom(msg.sender, address(this), amount.rawValue);\\n  }\\n\\n  function computeRegularFee(\\n    uint256 startTime,\\n    uint256 endTime,\\n    FixedPoint.Unsigned calldata pfc\\n  )\\n    external\\n    view\\n    override\\n    returns (\\n      FixedPoint.Unsigned memory regularFee,\\n      FixedPoint.Unsigned memory latePenalty\\n    )\\n  {\\n    uint256 timeDiff = endTime.sub(startTime);\\n\\n    regularFee = pfc.mul(timeDiff).mul(fixedOracleFeePerSecondPerPfc);\\n\\n    uint256 paymentDelay = getCurrentTime().sub(startTime);\\n\\n    FixedPoint.Unsigned memory penaltyPercentagePerSecond =\\n      weeklyDelayFeePerSecondPerPfc.mul(paymentDelay.div(SECONDS_PER_WEEK));\\n\\n    latePenalty = pfc.mul(timeDiff).mul(penaltyPercentagePerSecond);\\n  }\\n\\n  function computeFinalFee(address currency)\\n    external\\n    view\\n    override\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return finalFees[currency];\\n  }\\n\\n  function setFixedOracleFeePerSecondPerPfc(\\n    FixedPoint.Unsigned memory newFixedOracleFeePerSecondPerPfc\\n  ) public onlyRoleHolder(uint256(Roles.Owner)) {\\n    require(\\n      newFixedOracleFeePerSecondPerPfc.isLessThan(1),\\n      'Fee must be < 100% per second.'\\n    );\\n    fixedOracleFeePerSecondPerPfc = newFixedOracleFeePerSecondPerPfc;\\n    emit NewFixedOracleFeePerSecondPerPfc(newFixedOracleFeePerSecondPerPfc);\\n  }\\n\\n  function setWeeklyDelayFeePerSecondPerPfc(\\n    FixedPoint.Unsigned memory newWeeklyDelayFeePerSecondPerPfc\\n  ) public onlyRoleHolder(uint256(Roles.Owner)) {\\n    require(\\n      newWeeklyDelayFeePerSecondPerPfc.isLessThan(1),\\n      'weekly delay fee must be < 100%'\\n    );\\n    weeklyDelayFeePerSecondPerPfc = newWeeklyDelayFeePerSecondPerPfc;\\n    emit NewWeeklyDelayFeePerSecondPerPfc(newWeeklyDelayFeePerSecondPerPfc);\\n  }\\n\\n  function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\\n    public\\n    onlyRoleHolder(uint256(Roles.Owner))\\n  {\\n    finalFees[currency] = newFinalFee;\\n    emit NewFinalFee(newFinalFee);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Governor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/MultiRole.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/implementation/Testable.sol';\\nimport '../interfaces/FinderInterface.sol';\\nimport '../interfaces/IdentifierWhitelistInterface.sol';\\nimport '../interfaces/OracleInterface.sol';\\nimport './Constants.sol';\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/utils/Address.sol';\\n\\ncontract Governor is MultiRole, Testable {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  enum Roles {Owner, Proposer}\\n\\n  struct Transaction {\\n    address to;\\n    uint256 value;\\n    bytes data;\\n  }\\n\\n  struct Proposal {\\n    Transaction[] transactions;\\n    uint256 requestTime;\\n  }\\n\\n  FinderInterface private finder;\\n  Proposal[] public proposals;\\n\\n  event NewProposal(uint256 indexed id, Transaction[] transactions);\\n\\n  event ProposalExecuted(uint256 indexed id, uint256 transactionIndex);\\n\\n  constructor(\\n    address _finderAddress,\\n    uint256 _startingId,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    finder = FinderInterface(_finderAddress);\\n    _createExclusiveRole(\\n      uint256(Roles.Owner),\\n      uint256(Roles.Owner),\\n      msg.sender\\n    );\\n    _createExclusiveRole(\\n      uint256(Roles.Proposer),\\n      uint256(Roles.Owner),\\n      msg.sender\\n    );\\n\\n    uint256 maxStartingId = 10**18;\\n    require(\\n      _startingId <= maxStartingId,\\n      'Cannot set startingId larger than 10^18'\\n    );\\n\\n    assembly {\\n      sstore(proposals_slot, _startingId)\\n    }\\n  }\\n\\n  function propose(Transaction[] memory transactions)\\n    public\\n    onlyRoleHolder(uint256(Roles.Proposer))\\n  {\\n    uint256 id = proposals.length;\\n    uint256 time = getCurrentTime();\\n\\n    proposals.push();\\n\\n    Proposal storage proposal = proposals[id];\\n    proposal.requestTime = time;\\n\\n    for (uint256 i = 0; i < transactions.length; i++) {\\n      require(\\n        transactions[i].to != address(0),\\n        'The `to` address cannot be 0x0'\\n      );\\n\\n      if (transactions[i].data.length > 0) {\\n        require(\\n          transactions[i].to.isContract(),\\n          \\\"EOA can't accept tx with data\\\"\\n        );\\n      }\\n      proposal.transactions.push(transactions[i]);\\n    }\\n\\n    bytes32 identifier = _constructIdentifier(id);\\n\\n    OracleInterface oracle = _getOracle();\\n    IdentifierWhitelistInterface supportedIdentifiers =\\n      _getIdentifierWhitelist();\\n    supportedIdentifiers.addSupportedIdentifier(identifier);\\n\\n    oracle.requestPrice(identifier, time);\\n    supportedIdentifiers.removeSupportedIdentifier(identifier);\\n\\n    emit NewProposal(id, transactions);\\n  }\\n\\n  function executeProposal(uint256 id, uint256 transactionIndex)\\n    external\\n    payable\\n  {\\n    Proposal storage proposal = proposals[id];\\n    int256 price =\\n      _getOracle().getPrice(_constructIdentifier(id), proposal.requestTime);\\n\\n    Transaction memory transaction = proposal.transactions[transactionIndex];\\n\\n    require(\\n      transactionIndex == 0 ||\\n        proposal.transactions[transactionIndex.sub(1)].to == address(0),\\n      'Previous tx not yet executed'\\n    );\\n    require(transaction.to != address(0), 'Tx already executed');\\n    require(price != 0, 'Proposal was rejected');\\n    require(msg.value == transaction.value, 'Must send exact amount of ETH');\\n\\n    delete proposal.transactions[transactionIndex];\\n\\n    require(\\n      _executeCall(transaction.to, transaction.value, transaction.data),\\n      'Tx execution failed'\\n    );\\n\\n    emit ProposalExecuted(id, transactionIndex);\\n  }\\n\\n  function numProposals() external view returns (uint256) {\\n    return proposals.length;\\n  }\\n\\n  function getProposal(uint256 id) external view returns (Proposal memory) {\\n    return proposals[id];\\n  }\\n\\n  function _executeCall(\\n    address to,\\n    uint256 value,\\n    bytes memory data\\n  ) private returns (bool) {\\n    bool success;\\n    assembly {\\n      let inputData := add(data, 0x20)\\n      let inputDataSize := mload(data)\\n      success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\\n    }\\n    return success;\\n  }\\n\\n  function _getOracle() private view returns (OracleInterface) {\\n    return\\n      OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    private\\n    view\\n    returns (IdentifierWhitelistInterface supportedIdentifiers)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\\n      );\\n  }\\n\\n  function _constructIdentifier(uint256 id) internal pure returns (bytes32) {\\n    bytes32 bytesId = _uintToUtf8(id);\\n    return _addPrefix(bytesId, 'Admin ', 6);\\n  }\\n\\n  function _uintToUtf8(uint256 v) internal pure returns (bytes32) {\\n    bytes32 ret;\\n    if (v == 0) {\\n      ret = '0';\\n    } else {\\n      uint256 bitsPerByte = 8;\\n      uint256 base = 10;\\n      uint256 utf8NumberOffset = 48;\\n      while (v > 0) {\\n        ret = ret >> bitsPerByte;\\n\\n        uint256 leastSignificantDigit = v % base;\\n\\n        bytes32 utf8Digit = bytes32(leastSignificantDigit + utf8NumberOffset);\\n\\n        ret |= utf8Digit << (31 * bitsPerByte);\\n\\n        v /= base;\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  function _addPrefix(\\n    bytes32 input,\\n    bytes32 prefix,\\n    uint256 prefixLength\\n  ) internal pure returns (bytes32) {\\n    bytes32 shiftedInput = input >> (prefixLength * 8);\\n    return shiftedInput | prefix;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/DesignatedVotingFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/Withdrawable.sol';\\nimport './DesignatedVoting.sol';\\n\\ncontract DesignatedVotingFactory is Withdrawable {\\n  enum Roles {Withdrawer}\\n\\n  address private finder;\\n  mapping(address => DesignatedVoting) public designatedVotingContracts;\\n\\n  constructor(address finderAddress) public {\\n    finder = finderAddress;\\n\\n    _createWithdrawRole(\\n      uint256(Roles.Withdrawer),\\n      uint256(Roles.Withdrawer),\\n      msg.sender\\n    );\\n  }\\n\\n  function newDesignatedVoting(address ownerAddress)\\n    external\\n    returns (DesignatedVoting)\\n  {\\n    require(\\n      address(designatedVotingContracts[msg.sender]) == address(0),\\n      'Duplicate hot key not permitted'\\n    );\\n\\n    DesignatedVoting designatedVoting =\\n      new DesignatedVoting(finder, ownerAddress, msg.sender);\\n    designatedVotingContracts[msg.sender] = designatedVoting;\\n    return designatedVoting;\\n  }\\n\\n  function setDesignatedVoting(address designatedVotingAddress) external {\\n    require(\\n      address(designatedVotingContracts[msg.sender]) == address(0),\\n      'Duplicate hot key not permitted'\\n    );\\n    designatedVotingContracts[msg.sender] = DesignatedVoting(\\n      designatedVotingAddress\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/TestnetERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\ncontract TestnetERC20 is ERC20 {\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals\\n  ) public ERC20(_name, _symbol) {\\n    _setupDecimals(_decimals);\\n  }\\n\\n  function allocateTo(address ownerAddress, uint256 value) external {\\n    _mint(ownerAddress, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/test/MockOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/Testable.sol';\\nimport '../interfaces/OracleInterface.sol';\\nimport '../interfaces/IdentifierWhitelistInterface.sol';\\nimport '../interfaces/FinderInterface.sol';\\nimport '../implementation/Constants.sol';\\n\\ncontract MockOracle is OracleInterface, Testable {\\n  struct Price {\\n    bool isAvailable;\\n    int256 price;\\n    uint256 verifiedTime;\\n  }\\n\\n  struct QueryIndex {\\n    bool isValid;\\n    uint256 index;\\n  }\\n\\n  struct QueryPoint {\\n    bytes32 identifier;\\n    uint256 time;\\n  }\\n\\n  FinderInterface private finder;\\n\\n  mapping(bytes32 => mapping(uint256 => Price)) private verifiedPrices;\\n\\n  mapping(bytes32 => mapping(uint256 => QueryIndex)) private queryIndices;\\n  QueryPoint[] private requestedPrices;\\n\\n  constructor(address _finderAddress, address _timerAddress)\\n    public\\n    Testable(_timerAddress)\\n  {\\n    finder = FinderInterface(_finderAddress);\\n  }\\n\\n  function requestPrice(bytes32 identifier, uint256 time) public override {\\n    require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\\n    Price storage lookup = verifiedPrices[identifier][time];\\n    if (!lookup.isAvailable && !queryIndices[identifier][time].isValid) {\\n      queryIndices[identifier][time] = QueryIndex(true, requestedPrices.length);\\n      requestedPrices.push(QueryPoint(identifier, time));\\n    }\\n  }\\n\\n  function pushPrice(\\n    bytes32 identifier,\\n    uint256 time,\\n    int256 price\\n  ) external {\\n    verifiedPrices[identifier][time] = Price(true, price, getCurrentTime());\\n\\n    QueryIndex storage queryIndex = queryIndices[identifier][time];\\n    require(\\n      queryIndex.isValid,\\n      \\\"Can't push prices that haven't been requested\\\"\\n    );\\n\\n    uint256 indexToReplace = queryIndex.index;\\n    delete queryIndices[identifier][time];\\n    uint256 lastIndex = requestedPrices.length - 1;\\n    if (lastIndex != indexToReplace) {\\n      QueryPoint storage queryToCopy = requestedPrices[lastIndex];\\n      queryIndices[queryToCopy.identifier][queryToCopy.time]\\n        .index = indexToReplace;\\n      requestedPrices[indexToReplace] = queryToCopy;\\n    }\\n  }\\n\\n  function hasPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\\n    Price storage lookup = verifiedPrices[identifier][time];\\n    return lookup.isAvailable;\\n  }\\n\\n  function getPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    override\\n    returns (int256)\\n  {\\n    require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\\n    Price storage lookup = verifiedPrices[identifier][time];\\n    require(lookup.isAvailable);\\n    return lookup.price;\\n  }\\n\\n  function getPendingQueries() external view returns (QueryPoint[] memory) {\\n    return requestedPrices;\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    private\\n    view\\n    returns (IdentifierWhitelistInterface supportedIdentifiers)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/ExpandedERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport './MultiRole.sol';\\nimport '../interfaces/ExpandedIERC20.sol';\\n\\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\\n  enum Roles {Owner, Minter, Burner}\\n\\n  constructor(\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    uint8 _tokenDecimals\\n  ) public ERC20(_tokenName, _tokenSymbol) {\\n    _setupDecimals(_tokenDecimals);\\n    _createExclusiveRole(\\n      uint256(Roles.Owner),\\n      uint256(Roles.Owner),\\n      msg.sender\\n    );\\n    _createSharedRole(\\n      uint256(Roles.Minter),\\n      uint256(Roles.Owner),\\n      new address[](0)\\n    );\\n    _createSharedRole(\\n      uint256(Roles.Burner),\\n      uint256(Roles.Owner),\\n      new address[](0)\\n    );\\n  }\\n\\n  function mint(address recipient, uint256 value)\\n    external\\n    override\\n    onlyRoleHolder(uint256(Roles.Minter))\\n    returns (bool)\\n  {\\n    _mint(recipient, value);\\n    return true;\\n  }\\n\\n  function burn(uint256 value)\\n    external\\n    override\\n    onlyRoleHolder(uint256(Roles.Burner))\\n  {\\n    _burn(msg.sender, value);\\n  }\\n\\n  function addMinter(address account) external virtual override {\\n    addMember(uint256(Roles.Minter), account);\\n  }\\n\\n  function addBurner(address account) external virtual override {\\n    addMember(uint256(Roles.Burner), account);\\n  }\\n\\n  function resetOwner(address account) external virtual override {\\n    resetMember(uint256(Roles.Owner), account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../../math/SafeMath.sol';\\nimport '../../utils/Arrays.sol';\\nimport '../../utils/Counters.sol';\\nimport './ERC20.sol';\\n\\nabstract contract ERC20Snapshot is ERC20 {\\n  using SafeMath for uint256;\\n  using Arrays for uint256[];\\n  using Counters for Counters.Counter;\\n\\n  struct Snapshots {\\n    uint256[] ids;\\n    uint256[] values;\\n  }\\n\\n  mapping(address => Snapshots) private _accountBalanceSnapshots;\\n  Snapshots private _totalSupplySnapshots;\\n\\n  Counters.Counter private _currentSnapshotId;\\n\\n  event Snapshot(uint256 id);\\n\\n  function _snapshot() internal virtual returns (uint256) {\\n    _currentSnapshotId.increment();\\n\\n    uint256 currentId = _currentSnapshotId.current();\\n    emit Snapshot(currentId);\\n    return currentId;\\n  }\\n\\n  function balanceOfAt(address account, uint256 snapshotId)\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    (bool snapshotted, uint256 value) =\\n      _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n    return snapshotted ? value : balanceOf(account);\\n  }\\n\\n  function totalSupplyAt(uint256 snapshotId) public view returns (uint256) {\\n    (bool snapshotted, uint256 value) =\\n      _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n    return snapshotted ? value : totalSupply();\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override {\\n    super._beforeTokenTransfer(from, to, amount);\\n\\n    if (from == address(0)) {\\n      _updateAccountSnapshot(to);\\n      _updateTotalSupplySnapshot();\\n    } else if (to == address(0)) {\\n      _updateAccountSnapshot(from);\\n      _updateTotalSupplySnapshot();\\n    } else {\\n      _updateAccountSnapshot(from);\\n      _updateAccountSnapshot(to);\\n    }\\n  }\\n\\n  function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\\n    private\\n    view\\n    returns (bool, uint256)\\n  {\\n    require(snapshotId > 0, 'ERC20Snapshot: id is 0');\\n\\n    require(\\n      snapshotId <= _currentSnapshotId.current(),\\n      'ERC20Snapshot: nonexistent id'\\n    );\\n\\n    uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n    if (index == snapshots.ids.length) {\\n      return (false, 0);\\n    } else {\\n      return (true, snapshots.values[index]);\\n    }\\n  }\\n\\n  function _updateAccountSnapshot(address account) private {\\n    _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n  }\\n\\n  function _updateTotalSupplySnapshot() private {\\n    _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n  }\\n\\n  function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue)\\n    private\\n  {\\n    uint256 currentId = _currentSnapshotId.current();\\n    if (_lastSnapshotId(snapshots.ids) < currentId) {\\n      snapshots.ids.push(currentId);\\n      snapshots.values.push(currentValue);\\n    }\\n  }\\n\\n  function _lastSnapshotId(uint256[] storage ids)\\n    private\\n    view\\n    returns (uint256)\\n  {\\n    if (ids.length == 0) {\\n      return 0;\\n    } else {\\n      return ids[ids.length - 1];\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../../GSN/Context.sol';\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\n\\ncontract ERC20 is Context, IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string memory name_, string memory symbol_) public {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = 18;\\n  }\\n\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(\\n        amount,\\n        'ERC20: transfer amount exceeds allowance'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].add(addedValue)\\n    );\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(\\n        subtractedValue,\\n        'ERC20: decreased allowance below zero'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    _beforeTokenTransfer(sender, recipient, amount);\\n\\n    _balances[sender] = _balances[sender].sub(\\n      amount,\\n      'ERC20: transfer amount exceeds balance'\\n    );\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    _balances[account] = _balances[account].sub(\\n      amount,\\n      'ERC20: burn amount exceeds balance'\\n    );\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    require(owner != address(0), 'ERC20: approve from the zero address');\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/MultiRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nlibrary Exclusive {\\n  struct RoleMembership {\\n    address member;\\n  }\\n\\n  function isMember(\\n    RoleMembership storage roleMembership,\\n    address memberToCheck\\n  ) internal view returns (bool) {\\n    return roleMembership.member == memberToCheck;\\n  }\\n\\n  function resetMember(RoleMembership storage roleMembership, address newMember)\\n    internal\\n  {\\n    require(newMember != address(0x0), 'Cannot set an exclusive role to 0x0');\\n    roleMembership.member = newMember;\\n  }\\n\\n  function getMember(RoleMembership storage roleMembership)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return roleMembership.member;\\n  }\\n\\n  function init(RoleMembership storage roleMembership, address initialMember)\\n    internal\\n  {\\n    resetMember(roleMembership, initialMember);\\n  }\\n}\\n\\nlibrary Shared {\\n  struct RoleMembership {\\n    mapping(address => bool) members;\\n  }\\n\\n  function isMember(\\n    RoleMembership storage roleMembership,\\n    address memberToCheck\\n  ) internal view returns (bool) {\\n    return roleMembership.members[memberToCheck];\\n  }\\n\\n  function addMember(RoleMembership storage roleMembership, address memberToAdd)\\n    internal\\n  {\\n    require(memberToAdd != address(0x0), 'Cannot add 0x0 to a shared role');\\n    roleMembership.members[memberToAdd] = true;\\n  }\\n\\n  function removeMember(\\n    RoleMembership storage roleMembership,\\n    address memberToRemove\\n  ) internal {\\n    roleMembership.members[memberToRemove] = false;\\n  }\\n\\n  function init(\\n    RoleMembership storage roleMembership,\\n    address[] memory initialMembers\\n  ) internal {\\n    for (uint256 i = 0; i < initialMembers.length; i++) {\\n      addMember(roleMembership, initialMembers[i]);\\n    }\\n  }\\n}\\n\\nabstract contract MultiRole {\\n  using Exclusive for Exclusive.RoleMembership;\\n  using Shared for Shared.RoleMembership;\\n\\n  enum RoleType {Invalid, Exclusive, Shared}\\n\\n  struct Role {\\n    uint256 managingRole;\\n    RoleType roleType;\\n    Exclusive.RoleMembership exclusiveRoleMembership;\\n    Shared.RoleMembership sharedRoleMembership;\\n  }\\n\\n  mapping(uint256 => Role) private roles;\\n\\n  event ResetExclusiveMember(\\n    uint256 indexed roleId,\\n    address indexed newMember,\\n    address indexed manager\\n  );\\n  event AddedSharedMember(\\n    uint256 indexed roleId,\\n    address indexed newMember,\\n    address indexed manager\\n  );\\n  event RemovedSharedMember(\\n    uint256 indexed roleId,\\n    address indexed oldMember,\\n    address indexed manager\\n  );\\n\\n  modifier onlyRoleHolder(uint256 roleId) {\\n    require(\\n      holdsRole(roleId, msg.sender),\\n      'Sender does not hold required role'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyRoleManager(uint256 roleId) {\\n    require(\\n      holdsRole(roles[roleId].managingRole, msg.sender),\\n      'Can only be called by a role manager'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyExclusive(uint256 roleId) {\\n    require(\\n      roles[roleId].roleType == RoleType.Exclusive,\\n      'Must be called on an initialized Exclusive role'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyShared(uint256 roleId) {\\n    require(\\n      roles[roleId].roleType == RoleType.Shared,\\n      'Must be called on an initialized Shared role'\\n    );\\n    _;\\n  }\\n\\n  function holdsRole(uint256 roleId, address memberToCheck)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    Role storage role = roles[roleId];\\n    if (role.roleType == RoleType.Exclusive) {\\n      return role.exclusiveRoleMembership.isMember(memberToCheck);\\n    } else if (role.roleType == RoleType.Shared) {\\n      return role.sharedRoleMembership.isMember(memberToCheck);\\n    }\\n    revert('Invalid roleId');\\n  }\\n\\n  function resetMember(uint256 roleId, address newMember)\\n    public\\n    onlyExclusive(roleId)\\n    onlyRoleManager(roleId)\\n  {\\n    roles[roleId].exclusiveRoleMembership.resetMember(newMember);\\n    emit ResetExclusiveMember(roleId, newMember, msg.sender);\\n  }\\n\\n  function getMember(uint256 roleId)\\n    public\\n    view\\n    onlyExclusive(roleId)\\n    returns (address)\\n  {\\n    return roles[roleId].exclusiveRoleMembership.getMember();\\n  }\\n\\n  function addMember(uint256 roleId, address newMember)\\n    public\\n    onlyShared(roleId)\\n    onlyRoleManager(roleId)\\n  {\\n    roles[roleId].sharedRoleMembership.addMember(newMember);\\n    emit AddedSharedMember(roleId, newMember, msg.sender);\\n  }\\n\\n  function removeMember(uint256 roleId, address memberToRemove)\\n    public\\n    onlyShared(roleId)\\n    onlyRoleManager(roleId)\\n  {\\n    roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\\n    emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\\n  }\\n\\n  function renounceMembership(uint256 roleId)\\n    public\\n    onlyShared(roleId)\\n    onlyRoleHolder(roleId)\\n  {\\n    roles[roleId].sharedRoleMembership.removeMember(msg.sender);\\n    emit RemovedSharedMember(roleId, msg.sender, msg.sender);\\n  }\\n\\n  modifier onlyValidRole(uint256 roleId) {\\n    require(\\n      roles[roleId].roleType != RoleType.Invalid,\\n      'Attempted to use an invalid roleId'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyInvalidRole(uint256 roleId) {\\n    require(\\n      roles[roleId].roleType == RoleType.Invalid,\\n      'Cannot use a pre-existing role'\\n    );\\n    _;\\n  }\\n\\n  function _createSharedRole(\\n    uint256 roleId,\\n    uint256 managingRoleId,\\n    address[] memory initialMembers\\n  ) internal onlyInvalidRole(roleId) {\\n    Role storage role = roles[roleId];\\n    role.roleType = RoleType.Shared;\\n    role.managingRole = managingRoleId;\\n    role.sharedRoleMembership.init(initialMembers);\\n    require(\\n      roles[managingRoleId].roleType != RoleType.Invalid,\\n      'Attempted to use an invalid role to manage a shared role'\\n    );\\n  }\\n\\n  function _createExclusiveRole(\\n    uint256 roleId,\\n    uint256 managingRoleId,\\n    address initialMember\\n  ) internal onlyInvalidRole(roleId) {\\n    Role storage role = roles[roleId];\\n    role.roleType = RoleType.Exclusive;\\n    role.managingRole = managingRoleId;\\n    role.exclusiveRoleMembership.init(initialMember);\\n    require(\\n      roles[managingRoleId].roleType != RoleType.Invalid,\\n      'Attempted to use an invalid role to manage an exclusive role'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/ExpandedIERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nabstract contract ExpandedIERC20 is IERC20 {\\n  function burn(uint256 value) external virtual;\\n\\n  function mint(address to, uint256 value) external virtual returns (bool);\\n\\n  function addMinter(address account) external virtual;\\n\\n  function addBurner(address account) external virtual;\\n\\n  function resetOwner(address account) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../math/Math.sol';\\n\\nlibrary Arrays {\\n  function findUpperBound(uint256[] storage array, uint256 element)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    if (array.length == 0) {\\n      return 0;\\n    }\\n\\n    uint256 low = 0;\\n    uint256 high = array.length;\\n\\n    while (low < high) {\\n      uint256 mid = Math.average(low, high);\\n\\n      if (array[mid] > element) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n\\n    if (low > 0 && array[low - 1] == element) {\\n      return low - 1;\\n    } else {\\n      return low;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../math/SafeMath.sol';\\n\\nlibrary Counters {\\n  using SafeMath for uint256;\\n\\n  struct Counter {\\n    uint256 _value;\\n  }\\n\\n  function current(Counter storage counter) internal view returns (uint256) {\\n    return counter._value;\\n  }\\n\\n  function increment(Counter storage counter) internal {\\n    counter._value += 1;\\n  }\\n\\n  function decrement(Counter storage counter) internal {\\n    counter._value = counter._value.sub(1);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary Math {\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nabstract contract OracleInterface {\\n  function requestPrice(bytes32 identifier, uint256 time) public virtual;\\n\\n  function hasPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    virtual\\n    returns (bool);\\n\\n  function getPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    virtual\\n    returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/VotingInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './VotingAncillaryInterface.sol';\\n\\nabstract contract VotingInterface {\\n  struct PendingRequest {\\n    bytes32 identifier;\\n    uint256 time;\\n  }\\n\\n  struct Commitment {\\n    bytes32 identifier;\\n    uint256 time;\\n    bytes32 hash;\\n    bytes encryptedVote;\\n  }\\n\\n  struct Reveal {\\n    bytes32 identifier;\\n    uint256 time;\\n    int256 price;\\n    int256 salt;\\n  }\\n\\n  function commitVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes32 hash\\n  ) external virtual;\\n\\n  function batchCommit(Commitment[] memory commits) public virtual;\\n\\n  function commitAndEmitEncryptedVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes32 hash,\\n    bytes memory encryptedVote\\n  ) public virtual;\\n\\n  function snapshotCurrentRound(bytes calldata signature) external virtual;\\n\\n  function revealVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    int256 price,\\n    int256 salt\\n  ) public virtual;\\n\\n  function batchReveal(Reveal[] memory reveals) public virtual;\\n\\n  function getPendingRequests()\\n    external\\n    view\\n    virtual\\n    returns (VotingAncillaryInterface.PendingRequestAncillary[] memory);\\n\\n  function getVotePhase()\\n    external\\n    view\\n    virtual\\n    returns (VotingAncillaryInterface.Phase);\\n\\n  function getCurrentRoundId() external view virtual returns (uint256);\\n\\n  function retrieveRewards(\\n    address voterAddress,\\n    uint256 roundId,\\n    PendingRequest[] memory toRetrieve\\n  ) public virtual returns (FixedPoint.Unsigned memory);\\n\\n  function setMigrated(address newVotingAddress) external virtual;\\n\\n  function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\\n    public\\n    virtual;\\n\\n  function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\\n    public\\n    virtual;\\n\\n  function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout)\\n    public\\n    virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/VotingAncillaryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\n\\nabstract contract VotingAncillaryInterface {\\n  struct PendingRequestAncillary {\\n    bytes32 identifier;\\n    uint256 time;\\n    bytes ancillaryData;\\n  }\\n\\n  struct CommitmentAncillary {\\n    bytes32 identifier;\\n    uint256 time;\\n    bytes ancillaryData;\\n    bytes32 hash;\\n    bytes encryptedVote;\\n  }\\n\\n  struct RevealAncillary {\\n    bytes32 identifier;\\n    uint256 time;\\n    int256 price;\\n    bytes ancillaryData;\\n    int256 salt;\\n  }\\n\\n  enum Phase {Commit, Reveal, NUM_PHASES_PLACEHOLDER}\\n\\n  function commitVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData,\\n    bytes32 hash\\n  ) public virtual;\\n\\n  function batchCommit(CommitmentAncillary[] memory commits) public virtual;\\n\\n  function commitAndEmitEncryptedVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData,\\n    bytes32 hash,\\n    bytes memory encryptedVote\\n  ) public virtual;\\n\\n  function snapshotCurrentRound(bytes calldata signature) external virtual;\\n\\n  function revealVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    int256 price,\\n    bytes memory ancillaryData,\\n    int256 salt\\n  ) public virtual;\\n\\n  function batchReveal(RevealAncillary[] memory reveals) public virtual;\\n\\n  function getPendingRequests()\\n    external\\n    view\\n    virtual\\n    returns (PendingRequestAncillary[] memory);\\n\\n  function getVotePhase() external view virtual returns (Phase);\\n\\n  function getCurrentRoundId() external view virtual returns (uint256);\\n\\n  function retrieveRewards(\\n    address voterAddress,\\n    uint256 roundId,\\n    PendingRequestAncillary[] memory toRetrieve\\n  ) public virtual returns (FixedPoint.Unsigned memory);\\n\\n  function setMigrated(address newVotingAddress) external virtual;\\n\\n  function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\\n    public\\n    virtual;\\n\\n  function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\\n    public\\n    virtual;\\n\\n  function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout)\\n    public\\n    virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/ResultComputation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\n\\nlibrary ResultComputation {\\n  using FixedPoint for FixedPoint.Unsigned;\\n\\n  struct Data {\\n    mapping(int256 => FixedPoint.Unsigned) voteFrequency;\\n    FixedPoint.Unsigned totalVotes;\\n    int256 currentMode;\\n  }\\n\\n  function addVote(\\n    Data storage data,\\n    int256 votePrice,\\n    FixedPoint.Unsigned memory numberTokens\\n  ) internal {\\n    data.totalVotes = data.totalVotes.add(numberTokens);\\n    data.voteFrequency[votePrice] = data.voteFrequency[votePrice].add(\\n      numberTokens\\n    );\\n    if (\\n      votePrice != data.currentMode &&\\n      data.voteFrequency[votePrice].isGreaterThan(\\n        data.voteFrequency[data.currentMode]\\n      )\\n    ) {\\n      data.currentMode = votePrice;\\n    }\\n  }\\n\\n  function getResolvedPrice(\\n    Data storage data,\\n    FixedPoint.Unsigned memory minVoteThreshold\\n  ) internal view returns (bool isResolved, int256 price) {\\n    FixedPoint.Unsigned memory modeThreshold =\\n      FixedPoint.fromUnscaledUint(50).div(100);\\n\\n    if (\\n      data.totalVotes.isGreaterThan(minVoteThreshold) &&\\n      data.voteFrequency[data.currentMode].div(data.totalVotes).isGreaterThan(\\n        modeThreshold\\n      )\\n    ) {\\n      isResolved = true;\\n      price = data.currentMode;\\n    } else {\\n      isResolved = false;\\n    }\\n  }\\n\\n  function wasVoteCorrect(Data storage data, bytes32 voteHash)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return voteHash == keccak256(abi.encode(data.currentMode));\\n  }\\n\\n  function getTotalCorrectlyVotedTokens(Data storage data)\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return data.voteFrequency[data.currentMode];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/VoteTiming.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../interfaces/VotingInterface.sol';\\n\\nlibrary VoteTiming {\\n  using SafeMath for uint256;\\n\\n  struct Data {\\n    uint256 phaseLength;\\n  }\\n\\n  function init(Data storage data, uint256 phaseLength) internal {\\n    require(phaseLength > 0);\\n    data.phaseLength = phaseLength;\\n  }\\n\\n  function computeCurrentRoundId(Data storage data, uint256 currentTime)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 roundLength =\\n      data.phaseLength.mul(\\n        uint256(VotingAncillaryInterface.Phase.NUM_PHASES_PLACEHOLDER)\\n      );\\n    return currentTime.div(roundLength);\\n  }\\n\\n  function computeRoundEndTime(Data storage data, uint256 roundId)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 roundLength =\\n      data.phaseLength.mul(\\n        uint256(VotingAncillaryInterface.Phase.NUM_PHASES_PLACEHOLDER)\\n      );\\n    return roundLength.mul(roundId.add(1));\\n  }\\n\\n  function computeCurrentPhase(Data storage data, uint256 currentTime)\\n    internal\\n    view\\n    returns (VotingAncillaryInterface.Phase)\\n  {\\n    return\\n      VotingAncillaryInterface.Phase(\\n        currentTime.div(data.phaseLength).mod(\\n          uint256(VotingAncillaryInterface.Phase.NUM_PHASES_PLACEHOLDER)\\n        )\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary ECDSA {\\n  function recover(bytes32 hash, bytes memory signature)\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    if (signature.length != 65) {\\n      revert('ECDSA: invalid signature length');\\n    }\\n\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n\\n    assembly {\\n      r := mload(add(signature, 0x20))\\n      s := mload(add(signature, 0x40))\\n      v := byte(0, mload(add(signature, 0x60)))\\n    }\\n\\n    require(\\n      uint256(s) <=\\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n      \\\"ECDSA: invalid signature 's' value\\\"\\n    );\\n    require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n    address signer = ecrecover(hash, v, r, s);\\n    require(signer != address(0), 'ECDSA: invalid signature');\\n\\n    return signer;\\n  }\\n\\n  function toEthSignedMessageHash(bytes32 hash)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return\\n      keccak256(abi.encodePacked('\\\\x19Ethereum Signed Message:\\\\n32', hash));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/RegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface RegistryInterface {\\n  function registerContract(address[] calldata parties, address contractAddress)\\n    external;\\n\\n  function isContractRegistered(address contractAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  function getRegisteredContracts(address party)\\n    external\\n    view\\n    returns (address[] memory);\\n\\n  function getAllRegisteredContracts() external view returns (address[] memory);\\n\\n  function addPartyToContract(address party) external;\\n\\n  function removePartyFromContract(address party) external;\\n\\n  function isPartyMemberOfContract(address party, address contractAddress)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/AdministrateeInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface AdministrateeInterface {\\n  function emergencyShutdown() external;\\n\\n  function remargin() external;\\n\\n  function pfc() external view returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Withdrawable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/utils/Address.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport './MultiRole.sol';\\n\\nabstract contract Withdrawable is MultiRole {\\n  using SafeERC20 for IERC20;\\n\\n  uint256 private roleId;\\n\\n  function withdraw(uint256 amount) external onlyRoleHolder(roleId) {\\n    Address.sendValue(msg.sender, amount);\\n  }\\n\\n  function withdrawErc20(address erc20Address, uint256 amount)\\n    external\\n    onlyRoleHolder(roleId)\\n  {\\n    IERC20 erc20 = IERC20(erc20Address);\\n    erc20.safeTransfer(msg.sender, amount);\\n  }\\n\\n  function _createWithdrawRole(\\n    uint256 newRoleId,\\n    uint256 managingRoleId,\\n    address withdrawerAddress\\n  ) internal {\\n    roleId = newRoleId;\\n    _createExclusiveRole(newRoleId, managingRoleId, withdrawerAddress);\\n  }\\n\\n  function _setWithdrawRole(uint256 setRoleId)\\n    internal\\n    onlyValidRole(setRoleId)\\n  {\\n    roleId = setRoleId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/DesignatedVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/MultiRole.sol';\\nimport '../../common/implementation/Withdrawable.sol';\\nimport '../interfaces/VotingAncillaryInterface.sol';\\nimport '../interfaces/FinderInterface.sol';\\nimport './Constants.sol';\\n\\ncontract DesignatedVoting is Withdrawable {\\n  enum Roles {Owner, Voter}\\n\\n  FinderInterface private finder;\\n\\n  constructor(\\n    address finderAddress,\\n    address ownerAddress,\\n    address voterAddress\\n  ) public {\\n    _createExclusiveRole(\\n      uint256(Roles.Owner),\\n      uint256(Roles.Owner),\\n      ownerAddress\\n    );\\n    _createExclusiveRole(\\n      uint256(Roles.Voter),\\n      uint256(Roles.Owner),\\n      voterAddress\\n    );\\n    _setWithdrawRole(uint256(Roles.Owner));\\n\\n    finder = FinderInterface(finderAddress);\\n  }\\n\\n  function commitVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    bytes memory ancillaryData,\\n    bytes32 hash\\n  ) external onlyRoleHolder(uint256(Roles.Voter)) {\\n    _getVotingAddress().commitVote(identifier, time, ancillaryData, hash);\\n  }\\n\\n  function batchCommit(\\n    VotingAncillaryInterface.CommitmentAncillary[] calldata commits\\n  ) external onlyRoleHolder(uint256(Roles.Voter)) {\\n    _getVotingAddress().batchCommit(commits);\\n  }\\n\\n  function revealVote(\\n    bytes32 identifier,\\n    uint256 time,\\n    int256 price,\\n    bytes memory ancillaryData,\\n    int256 salt\\n  ) external onlyRoleHolder(uint256(Roles.Voter)) {\\n    _getVotingAddress().revealVote(\\n      identifier,\\n      time,\\n      price,\\n      ancillaryData,\\n      salt\\n    );\\n  }\\n\\n  function batchReveal(\\n    VotingAncillaryInterface.RevealAncillary[] calldata reveals\\n  ) external onlyRoleHolder(uint256(Roles.Voter)) {\\n    _getVotingAddress().batchReveal(reveals);\\n  }\\n\\n  function retrieveRewards(\\n    uint256 roundId,\\n    VotingAncillaryInterface.PendingRequestAncillary[] memory toRetrieve\\n  )\\n    public\\n    onlyRoleHolder(uint256(Roles.Voter))\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return\\n      _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\\n  }\\n\\n  function _getVotingAddress() private view returns (VotingAncillaryInterface) {\\n    return\\n      VotingAncillaryInterface(\\n        finder.getImplementationAddress(OracleInterfaces.Oracle)\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v0/TICHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {SynthereumTIC} from './TIC.sol';\\nimport {SynthereumTICInterface} from './interfaces/ITIC.sol';\\nimport {SafeMath} from '../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\nimport {HitchensUnorderedKeySetLib} from './HitchensUnorderedKeySet.sol';\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\n\\nlibrary SynthereumTICHelper {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;\\n  using SynthereumTICHelper for SynthereumTIC.Storage;\\n\\n  function initialize(\\n    SynthereumTIC.Storage storage self,\\n    IDerivative _derivative,\\n    ISynthereumFinder _finder,\\n    uint8 _version,\\n    address _liquidityProvider,\\n    address _validator,\\n    FixedPoint.Unsigned memory _startingCollateralization\\n  ) public {\\n    self.derivative = _derivative;\\n    self.finder = _finder;\\n    self.version = _version;\\n    self.liquidityProvider = _liquidityProvider;\\n    self.validator = _validator;\\n    self.startingCollateralization = _startingCollateralization;\\n    self.collateralToken = IERC20(\\n      address(self.derivative.collateralCurrency())\\n    );\\n  }\\n\\n  function mintRequest(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) public returns (bytes32) {\\n    bytes32 mintID =\\n      keccak256(\\n        abi.encodePacked(\\n          msg.sender,\\n          collateralAmount.rawValue,\\n          numTokens.rawValue,\\n          now\\n        )\\n      );\\n\\n    SynthereumTICInterface.MintRequest memory mint =\\n      SynthereumTICInterface.MintRequest(\\n        mintID,\\n        now,\\n        msg.sender,\\n        collateralAmount,\\n        numTokens\\n      );\\n\\n    self.mintRequestSet.insert(mintID);\\n    self.mintRequests[mintID] = mint;\\n\\n    return mintID;\\n  }\\n\\n  function approveMint(SynthereumTIC.Storage storage self, bytes32 mintID)\\n    public\\n  {\\n    FixedPoint.Unsigned memory globalCollateralization =\\n      self.getGlobalCollateralizationRatio();\\n\\n    FixedPoint.Unsigned memory targetCollateralization =\\n      globalCollateralization.isGreaterThan(0)\\n        ? globalCollateralization\\n        : self.startingCollateralization;\\n\\n    require(self.mintRequestSet.exists(mintID), 'Mint request does not exist');\\n    SynthereumTICInterface.MintRequest memory mint = self.mintRequests[mintID];\\n\\n    require(\\n      self.checkCollateralizationRatio(\\n        targetCollateralization,\\n        mint.collateralAmount,\\n        mint.numTokens\\n      ),\\n      'Insufficient collateral available from Liquidity Provider'\\n    );\\n\\n    self.mintRequestSet.remove(mintID);\\n    delete self.mintRequests[mintID];\\n\\n    FixedPoint.Unsigned memory feeTotal =\\n      mint.collateralAmount.mul(self.fee.feePercentage);\\n\\n    self.pullCollateral(mint.sender, mint.collateralAmount.add(feeTotal));\\n\\n    self.mintSynTokens(\\n      mint.numTokens.mulCeil(targetCollateralization),\\n      mint.numTokens\\n    );\\n\\n    self.transferSynTokens(mint.sender, mint.numTokens);\\n\\n    self.sendFee(feeTotal);\\n  }\\n\\n  function rejectMint(SynthereumTIC.Storage storage self, bytes32 mintID)\\n    public\\n  {\\n    require(self.mintRequestSet.exists(mintID), 'Mint request does not exist');\\n    self.mintRequestSet.remove(mintID);\\n    delete self.mintRequests[mintID];\\n  }\\n\\n  function deposit(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) public {\\n    self.pullCollateral(msg.sender, collateralAmount);\\n  }\\n\\n  function withdraw(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) public {\\n    require(\\n      self.collateralToken.transfer(msg.sender, collateralAmount.rawValue)\\n    );\\n  }\\n\\n  function exchangeMint(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) public {\\n    FixedPoint.Unsigned memory globalCollateralization =\\n      self.getGlobalCollateralizationRatio();\\n\\n    FixedPoint.Unsigned memory targetCollateralization =\\n      globalCollateralization.isGreaterThan(0)\\n        ? globalCollateralization\\n        : self.startingCollateralization;\\n\\n    require(\\n      self.checkCollateralizationRatio(\\n        targetCollateralization,\\n        collateralAmount,\\n        numTokens\\n      ),\\n      'Insufficient collateral available from Liquidity Provider'\\n    );\\n\\n    require(self.pullCollateral(msg.sender, collateralAmount));\\n\\n    self.mintSynTokens(numTokens.mulCeil(targetCollateralization), numTokens);\\n\\n    self.transferSynTokens(msg.sender, numTokens);\\n  }\\n\\n  function depositIntoDerivative(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) public {\\n    IDerivative derivative = self.derivative;\\n    self.collateralToken.approve(\\n      address(derivative),\\n      collateralAmount.rawValue\\n    );\\n    derivative.deposit(collateralAmount);\\n  }\\n\\n  function withdrawRequest(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) public {\\n    self.derivative.requestWithdrawal(collateralAmount);\\n  }\\n\\n  function withdrawPassedRequest(SynthereumTIC.Storage storage self) public {\\n    uint256 prevBalance = self.collateralToken.balanceOf(address(this));\\n\\n    self.derivative.withdrawPassedRequest();\\n\\n    FixedPoint.Unsigned memory amountWithdrawn =\\n      FixedPoint.Unsigned(\\n        self.collateralToken.balanceOf(address(this)).sub(prevBalance)\\n      );\\n    require(amountWithdrawn.isGreaterThan(0), 'No tokens were redeemed');\\n    require(\\n      self.collateralToken.transfer(msg.sender, amountWithdrawn.rawValue)\\n    );\\n  }\\n\\n  function redeemRequest(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) public returns (bytes32) {\\n    bytes32 redeemID =\\n      keccak256(\\n        abi.encodePacked(\\n          msg.sender,\\n          collateralAmount.rawValue,\\n          numTokens.rawValue,\\n          now\\n        )\\n      );\\n\\n    SynthereumTICInterface.RedeemRequest memory redeem =\\n      SynthereumTICInterface.RedeemRequest(\\n        redeemID,\\n        now,\\n        msg.sender,\\n        collateralAmount,\\n        numTokens\\n      );\\n\\n    self.redeemRequestSet.insert(redeemID);\\n    self.redeemRequests[redeemID] = redeem;\\n\\n    return redeemID;\\n  }\\n\\n  function approveRedeem(SynthereumTIC.Storage storage self, bytes32 redeemID)\\n    public\\n  {\\n    require(\\n      self.redeemRequestSet.exists(redeemID),\\n      'Redeem request does not exist'\\n    );\\n    SynthereumTICInterface.RedeemRequest memory redeem =\\n      self.redeemRequests[redeemID];\\n\\n    require(redeem.numTokens.isGreaterThan(0));\\n\\n    IERC20 tokenCurrency = self.derivative.tokenCurrency();\\n    require(\\n      tokenCurrency.balanceOf(redeem.sender) >= redeem.numTokens.rawValue\\n    );\\n\\n    self.redeemRequestSet.remove(redeemID);\\n    delete self.redeemRequests[redeemID];\\n\\n    require(\\n      tokenCurrency.transferFrom(\\n        redeem.sender,\\n        address(this),\\n        redeem.numTokens.rawValue\\n      ),\\n      'Token transfer failed'\\n    );\\n\\n    require(\\n      tokenCurrency.approve(\\n        address(self.derivative),\\n        redeem.numTokens.rawValue\\n      ),\\n      'Token approve failed'\\n    );\\n\\n    uint256 prevBalance = self.collateralToken.balanceOf(address(this));\\n\\n    self.derivative.redeem(redeem.numTokens);\\n\\n    FixedPoint.Unsigned memory amountWithdrawn =\\n      FixedPoint.Unsigned(\\n        self.collateralToken.balanceOf(address(this)).sub(prevBalance)\\n      );\\n\\n    require(amountWithdrawn.isGreaterThan(redeem.collateralAmount));\\n\\n    FixedPoint.Unsigned memory feeTotal =\\n      redeem.collateralAmount.mul(self.fee.feePercentage);\\n\\n    self.collateralToken.transfer(\\n      redeem.sender,\\n      redeem.collateralAmount.sub(feeTotal).rawValue\\n    );\\n\\n    self.sendFee(feeTotal);\\n  }\\n\\n  function rejectRedeem(SynthereumTIC.Storage storage self, bytes32 redeemID)\\n    public\\n  {\\n    require(\\n      self.redeemRequestSet.exists(redeemID),\\n      'Mint request does not exist'\\n    );\\n    self.redeemRequestSet.remove(redeemID);\\n    delete self.redeemRequests[redeemID];\\n  }\\n\\n  function emergencyShutdown(SynthereumTIC.Storage storage self) external {\\n    self.derivative.emergencyShutdown();\\n  }\\n\\n  function settleEmergencyShutdown(SynthereumTIC.Storage storage self) public {\\n    IERC20 tokenCurrency = self.derivative.tokenCurrency();\\n\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\\n\\n    require(\\n      numTokens.isGreaterThan(0) || msg.sender == self.liquidityProvider,\\n      'Account has nothing to settle'\\n    );\\n\\n    if (numTokens.isGreaterThan(0)) {\\n      require(\\n        tokenCurrency.transferFrom(\\n          msg.sender,\\n          address(this),\\n          numTokens.rawValue\\n        ),\\n        'Token transfer failed'\\n      );\\n\\n      require(\\n        tokenCurrency.approve(address(self.derivative), numTokens.rawValue),\\n        'Token approve failed'\\n      );\\n    }\\n\\n    uint256 prevBalance = self.collateralToken.balanceOf(address(this));\\n\\n    self.derivative.settleEmergencyShutdown();\\n\\n    FixedPoint.Unsigned memory amountWithdrawn =\\n      FixedPoint.Unsigned(\\n        self.collateralToken.balanceOf(address(this)).sub(prevBalance)\\n      );\\n\\n    require(amountWithdrawn.isGreaterThan(0), 'No collateral was withdrawn');\\n\\n    FixedPoint.Unsigned memory totalToRedeem;\\n\\n    if (msg.sender == self.liquidityProvider) {\\n      totalToRedeem = FixedPoint.Unsigned(\\n        self.collateralToken.balanceOf(address(this))\\n      );\\n    } else {\\n      totalToRedeem = numTokens.mul(self.derivative.emergencyShutdownPrice());\\n      require(\\n        amountWithdrawn.isGreaterThanOrEqual(totalToRedeem),\\n        'Insufficient collateral withdrawn to redeem tokens'\\n      );\\n    }\\n\\n    require(self.collateralToken.transfer(msg.sender, totalToRedeem.rawValue));\\n  }\\n\\n  function exchangeRequest(\\n    SynthereumTIC.Storage storage self,\\n    SynthereumTICInterface destTIC,\\n    FixedPoint.Unsigned memory numTokens,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory destNumTokens\\n  ) public returns (bytes32) {\\n    bytes32 exchangeID =\\n      keccak256(\\n        abi.encodePacked(\\n          msg.sender,\\n          address(destTIC),\\n          numTokens.rawValue,\\n          destNumTokens.rawValue,\\n          now\\n        )\\n      );\\n\\n    SynthereumTICInterface.ExchangeRequest memory exchange =\\n      SynthereumTICInterface.ExchangeRequest(\\n        exchangeID,\\n        now,\\n        msg.sender,\\n        destTIC,\\n        numTokens,\\n        collateralAmount,\\n        destNumTokens\\n      );\\n\\n    self.exchangeRequestSet.insert(exchangeID);\\n    self.exchangeRequests[exchangeID] = exchange;\\n\\n    return exchangeID;\\n  }\\n\\n  function approveExchange(\\n    SynthereumTIC.Storage storage self,\\n    bytes32 exchangeID\\n  ) public {\\n    require(\\n      self.exchangeRequestSet.exists(exchangeID),\\n      'Exchange request does not exist'\\n    );\\n    SynthereumTICInterface.ExchangeRequest memory exchange =\\n      self.exchangeRequests[exchangeID];\\n\\n    self.exchangeRequestSet.remove(exchangeID);\\n    delete self.exchangeRequests[exchangeID];\\n\\n    uint256 prevBalance = self.collateralToken.balanceOf(address(this));\\n\\n    self.redeemForCollateral(exchange.sender, exchange.numTokens);\\n\\n    FixedPoint.Unsigned memory amountWithdrawn =\\n      FixedPoint.Unsigned(\\n        self.collateralToken.balanceOf(address(this)).sub(prevBalance)\\n      );\\n\\n    require(\\n      amountWithdrawn.isGreaterThan(exchange.collateralAmount),\\n      'No tokens were redeemed'\\n    );\\n\\n    FixedPoint.Unsigned memory feeTotal =\\n      exchange.collateralAmount.mul(self.fee.feePercentage);\\n\\n    self.sendFee(feeTotal);\\n\\n    FixedPoint.Unsigned memory destinationCollateral =\\n      amountWithdrawn.sub(feeTotal);\\n\\n    require(\\n      self.collateralToken.approve(\\n        address(exchange.destTIC),\\n        destinationCollateral.rawValue\\n      )\\n    );\\n\\n    exchange.destTIC.exchangeMint(\\n      destinationCollateral.rawValue,\\n      exchange.destNumTokens.rawValue\\n    );\\n\\n    require(\\n      exchange.destTIC.derivative().tokenCurrency().transfer(\\n        exchange.sender,\\n        exchange.destNumTokens.rawValue\\n      )\\n    );\\n  }\\n\\n  function rejectExchange(\\n    SynthereumTIC.Storage storage self,\\n    bytes32 exchangeID\\n  ) public {\\n    require(\\n      self.exchangeRequestSet.exists(exchangeID),\\n      'Exchange request does not exist'\\n    );\\n    self.exchangeRequestSet.remove(exchangeID);\\n    delete self.exchangeRequests[exchangeID];\\n  }\\n\\n  function setFeePercentage(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory _feePercentage\\n  ) public {\\n    self.fee.feePercentage = _feePercentage;\\n  }\\n\\n  function setFeeRecipients(\\n    SynthereumTIC.Storage storage self,\\n    address[] memory _feeRecipients,\\n    uint32[] memory _feeProportions\\n  ) public {\\n    require(\\n      _feeRecipients.length == _feeProportions.length,\\n      'Fee recipients and fee proportions do not match'\\n    );\\n\\n    uint256 totalActualFeeProportions;\\n\\n    for (uint256 i = 0; i < _feeProportions.length; i++) {\\n      totalActualFeeProportions += _feeProportions[i];\\n    }\\n\\n    self.fee.feeRecipients = _feeRecipients;\\n    self.fee.feeProportions = _feeProportions;\\n    self.totalFeeProportions = totalActualFeeProportions;\\n  }\\n\\n  function getMintRequests(SynthereumTIC.Storage storage self)\\n    public\\n    view\\n    returns (SynthereumTICInterface.MintRequest[] memory)\\n  {\\n    SynthereumTICInterface.MintRequest[] memory mintRequests =\\n      new SynthereumTICInterface.MintRequest[](self.mintRequestSet.count());\\n\\n    for (uint256 i = 0; i < self.mintRequestSet.count(); i++) {\\n      mintRequests[i] = self.mintRequests[self.mintRequestSet.keyAtIndex(i)];\\n    }\\n\\n    return mintRequests;\\n  }\\n\\n  function getRedeemRequests(SynthereumTIC.Storage storage self)\\n    public\\n    view\\n    returns (SynthereumTICInterface.RedeemRequest[] memory)\\n  {\\n    SynthereumTICInterface.RedeemRequest[] memory redeemRequests =\\n      new SynthereumTICInterface.RedeemRequest[](self.redeemRequestSet.count());\\n\\n    for (uint256 i = 0; i < self.redeemRequestSet.count(); i++) {\\n      redeemRequests[i] = self.redeemRequests[\\n        self.redeemRequestSet.keyAtIndex(i)\\n      ];\\n    }\\n\\n    return redeemRequests;\\n  }\\n\\n  function getExchangeRequests(SynthereumTIC.Storage storage self)\\n    public\\n    view\\n    returns (SynthereumTICInterface.ExchangeRequest[] memory)\\n  {\\n    SynthereumTICInterface.ExchangeRequest[] memory exchangeRequests =\\n      new SynthereumTICInterface.ExchangeRequest[](\\n        self.exchangeRequestSet.count()\\n      );\\n\\n    for (uint256 i = 0; i < self.exchangeRequestSet.count(); i++) {\\n      exchangeRequests[i] = self.exchangeRequests[\\n        self.exchangeRequestSet.keyAtIndex(i)\\n      ];\\n    }\\n\\n    return exchangeRequests;\\n  }\\n\\n  function pullCollateral(\\n    SynthereumTIC.Storage storage self,\\n    address from,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal returns (bool) {\\n    return\\n      self.collateralToken.transferFrom(\\n        from,\\n        address(this),\\n        numTokens.rawValue\\n      );\\n  }\\n\\n  function mintSynTokens(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    require(\\n      self.collateralToken.approve(\\n        address(self.derivative),\\n        collateralAmount.rawValue\\n      )\\n    );\\n    self.derivative.create(collateralAmount, numTokens);\\n  }\\n\\n  function transferSynTokens(\\n    SynthereumTIC.Storage storage self,\\n    address recipient,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    require(\\n      self.derivative.tokenCurrency().transfer(recipient, numTokens.rawValue)\\n    );\\n  }\\n\\n  function sendFee(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory _feeAmount\\n  ) internal {\\n    for (uint256 i = 0; i < self.fee.feeRecipients.length; i++) {\\n      require(\\n        self.collateralToken.transfer(\\n          self.fee.feeRecipients[i],\\n          _feeAmount\\n            .mul(self.fee.feeProportions[i])\\n            .div(self.totalFeeProportions)\\n            .rawValue\\n        )\\n      );\\n    }\\n  }\\n\\n  function redeemForCollateral(\\n    SynthereumTIC.Storage storage self,\\n    address tokenHolder,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    require(numTokens.isGreaterThan(0));\\n\\n    IERC20 tokenCurrency = self.derivative.tokenCurrency();\\n    require(tokenCurrency.balanceOf(tokenHolder) >= numTokens.rawValue);\\n\\n    require(\\n      tokenCurrency.transferFrom(\\n        tokenHolder,\\n        address(this),\\n        numTokens.rawValue\\n      ),\\n      'Token transfer failed'\\n    );\\n\\n    require(\\n      tokenCurrency.approve(address(self.derivative), numTokens.rawValue),\\n      'Token approve failed'\\n    );\\n\\n    self.derivative.redeem(numTokens);\\n  }\\n\\n  function getGlobalCollateralizationRatio(SynthereumTIC.Storage storage self)\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    FixedPoint.Unsigned memory totalTokensOutstanding =\\n      self.derivative.globalPositionData().totalTokensOutstanding;\\n\\n    if (totalTokensOutstanding.isGreaterThan(0)) {\\n      return\\n        self.derivative.totalPositionCollateral().div(totalTokensOutstanding);\\n    } else {\\n      return FixedPoint.fromUnscaledUint(0);\\n    }\\n  }\\n\\n  function checkCollateralizationRatio(\\n    SynthereumTIC.Storage storage self,\\n    FixedPoint.Unsigned memory globalCollateralization,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal view returns (bool) {\\n    FixedPoint.Unsigned memory newCollateralization =\\n      collateralAmount\\n        .add(FixedPoint.Unsigned(self.collateralToken.balanceOf(address(this))))\\n        .div(numTokens);\\n\\n    return newCollateralization.isGreaterThanOrEqual(globalCollateralization);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v0/TIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  AccessControl\\n} from '../../../@openzeppelin/contracts/access/AccessControl.sol';\\nimport {SynthereumTICInterface} from './interfaces/ITIC.sol';\\nimport '../../../@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\nimport {SafeMath} from '../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\nimport {HitchensUnorderedKeySetLib} from './HitchensUnorderedKeySet.sol';\\nimport {SynthereumTICHelper} from './TICHelper.sol';\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\n\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\n\\ncontract SynthereumTIC is\\n  AccessControl,\\n  SynthereumTICInterface,\\n  ReentrancyGuard\\n{\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  bytes32 public constant LIQUIDITY_PROVIDER_ROLE =\\n    keccak256('Liquidity Provider');\\n\\n  bytes32 public constant VALIDATOR_ROLE = keccak256('Validator');\\n\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;\\n  using SynthereumTICHelper for Storage;\\n\\n  struct Storage {\\n    ISynthereumFinder finder;\\n    uint8 version;\\n    IDerivative derivative;\\n    FixedPoint.Unsigned startingCollateralization;\\n    address liquidityProvider;\\n    address validator;\\n    IERC20 collateralToken;\\n    Fee fee;\\n    uint256 totalFeeProportions;\\n    mapping(bytes32 => MintRequest) mintRequests;\\n    HitchensUnorderedKeySetLib.Set mintRequestSet;\\n    mapping(bytes32 => ExchangeRequest) exchangeRequests;\\n    HitchensUnorderedKeySetLib.Set exchangeRequestSet;\\n    mapping(bytes32 => RedeemRequest) redeemRequests;\\n    HitchensUnorderedKeySetLib.Set redeemRequestSet;\\n  }\\n\\n  event MintRequested(\\n    bytes32 mintID,\\n    uint256 timestamp,\\n    address indexed sender,\\n    uint256 collateralAmount,\\n    uint256 numTokens\\n  );\\n  event MintApproved(bytes32 mintID, address indexed sender);\\n  event MintRejected(bytes32 mintID, address indexed sender);\\n\\n  event ExchangeRequested(\\n    bytes32 exchangeID,\\n    uint256 timestamp,\\n    address indexed sender,\\n    address destTIC,\\n    uint256 numTokens,\\n    uint256 destNumTokens\\n  );\\n  event ExchangeApproved(bytes32 exchangeID, address indexed sender);\\n  event ExchangeRejected(bytes32 exchangeID, address indexed sender);\\n\\n  event RedeemRequested(\\n    bytes32 redeemID,\\n    uint256 timestamp,\\n    address indexed sender,\\n    uint256 collateralAmount,\\n    uint256 numTokens\\n  );\\n  event RedeemApproved(bytes32 redeemID, address indexed sender);\\n  event RedeemRejected(bytes32 redeemID, address indexed sender);\\n  event SetFeePercentage(uint256 feePercentage);\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  Storage private ticStorage;\\n\\n  constructor(\\n    IDerivative _derivative,\\n    ISynthereumFinder _finder,\\n    uint8 _version,\\n    Roles memory _roles,\\n    uint256 _startingCollateralization,\\n    Fee memory _fee\\n  ) public nonReentrant {\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(LIQUIDITY_PROVIDER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(VALIDATOR_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n    _setupRole(LIQUIDITY_PROVIDER_ROLE, _roles.liquidityProvider);\\n    _setupRole(VALIDATOR_ROLE, _roles.validator);\\n    ticStorage.initialize(\\n      _derivative,\\n      _finder,\\n      _version,\\n      _roles.liquidityProvider,\\n      _roles.validator,\\n      FixedPoint.Unsigned(_startingCollateralization)\\n    );\\n    _setFeePercentage(_fee.feePercentage.rawValue);\\n    _setFeeRecipients(_fee.feeRecipients, _fee.feeProportions);\\n  }\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyLiquidityProvider() {\\n    require(\\n      hasRole(LIQUIDITY_PROVIDER_ROLE, msg.sender),\\n      'Sender must be the liquidity provider'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyValidator() {\\n    require(\\n      hasRole(VALIDATOR_ROLE, msg.sender),\\n      'Sender must be the validator'\\n    );\\n    _;\\n  }\\n\\n  function mintRequest(uint256 collateralAmount, uint256 numTokens)\\n    external\\n    override\\n    nonReentrant\\n  {\\n    bytes32 mintID =\\n      ticStorage.mintRequest(\\n        FixedPoint.Unsigned(collateralAmount),\\n        FixedPoint.Unsigned(numTokens)\\n      );\\n\\n    emit MintRequested(mintID, now, msg.sender, collateralAmount, numTokens);\\n  }\\n\\n  function approveMint(bytes32 mintID)\\n    external\\n    override\\n    nonReentrant\\n    onlyValidator\\n  {\\n    address sender = ticStorage.mintRequests[mintID].sender;\\n\\n    ticStorage.approveMint(mintID);\\n\\n    emit MintApproved(mintID, sender);\\n  }\\n\\n  function rejectMint(bytes32 mintID)\\n    external\\n    override\\n    nonReentrant\\n    onlyValidator\\n  {\\n    address sender = ticStorage.mintRequests[mintID].sender;\\n\\n    ticStorage.rejectMint(mintID);\\n\\n    emit MintRejected(mintID, sender);\\n  }\\n\\n  function deposit(uint256 collateralAmount)\\n    external\\n    override\\n    nonReentrant\\n    onlyLiquidityProvider\\n  {\\n    ticStorage.deposit(FixedPoint.Unsigned(collateralAmount));\\n  }\\n\\n  function withdraw(uint256 collateralAmount)\\n    external\\n    override\\n    nonReentrant\\n    onlyLiquidityProvider\\n  {\\n    ticStorage.withdraw(FixedPoint.Unsigned(collateralAmount));\\n  }\\n\\n  function exchangeMint(uint256 collateralAmount, uint256 numTokens)\\n    external\\n    override\\n    nonReentrant\\n  {\\n    ticStorage.exchangeMint(\\n      FixedPoint.Unsigned(collateralAmount),\\n      FixedPoint.Unsigned(numTokens)\\n    );\\n  }\\n\\n  function depositIntoDerivative(uint256 collateralAmount)\\n    external\\n    override\\n    nonReentrant\\n    onlyLiquidityProvider\\n  {\\n    ticStorage.depositIntoDerivative(FixedPoint.Unsigned(collateralAmount));\\n  }\\n\\n  function withdrawRequest(uint256 collateralAmount)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n  {\\n    ticStorage.withdrawRequest(FixedPoint.Unsigned(collateralAmount));\\n  }\\n\\n  function withdrawPassedRequest()\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n  {\\n    ticStorage.withdrawPassedRequest();\\n  }\\n\\n  function redeemRequest(uint256 collateralAmount, uint256 numTokens)\\n    external\\n    override\\n    nonReentrant\\n  {\\n    bytes32 redeemID =\\n      ticStorage.redeemRequest(\\n        FixedPoint.Unsigned(collateralAmount),\\n        FixedPoint.Unsigned(numTokens)\\n      );\\n\\n    emit RedeemRequested(\\n      redeemID,\\n      now,\\n      msg.sender,\\n      collateralAmount,\\n      numTokens\\n    );\\n  }\\n\\n  function approveRedeem(bytes32 redeemID)\\n    external\\n    override\\n    nonReentrant\\n    onlyValidator\\n  {\\n    address sender = ticStorage.redeemRequests[redeemID].sender;\\n\\n    ticStorage.approveRedeem(redeemID);\\n\\n    emit RedeemApproved(redeemID, sender);\\n  }\\n\\n  function rejectRedeem(bytes32 redeemID)\\n    external\\n    override\\n    nonReentrant\\n    onlyValidator\\n  {\\n    address sender = ticStorage.redeemRequests[redeemID].sender;\\n\\n    ticStorage.rejectRedeem(redeemID);\\n\\n    emit RedeemRejected(redeemID, sender);\\n  }\\n\\n  function emergencyShutdown() external override onlyMaintainer nonReentrant {\\n    ticStorage.emergencyShutdown();\\n  }\\n\\n  function settleEmergencyShutdown() external override nonReentrant {\\n    ticStorage.settleEmergencyShutdown();\\n  }\\n\\n  function exchangeRequest(\\n    SynthereumTICInterface destTIC,\\n    uint256 numTokens,\\n    uint256 collateralAmount,\\n    uint256 destNumTokens\\n  ) external override nonReentrant {\\n    bytes32 exchangeID =\\n      ticStorage.exchangeRequest(\\n        destTIC,\\n        FixedPoint.Unsigned(numTokens),\\n        FixedPoint.Unsigned(collateralAmount),\\n        FixedPoint.Unsigned(destNumTokens)\\n      );\\n\\n    emit ExchangeRequested(\\n      exchangeID,\\n      now,\\n      msg.sender,\\n      address(destTIC),\\n      numTokens,\\n      destNumTokens\\n    );\\n  }\\n\\n  function approveExchange(bytes32 exchangeID)\\n    external\\n    override\\n    onlyValidator\\n    nonReentrant\\n  {\\n    address sender = ticStorage.exchangeRequests[exchangeID].sender;\\n\\n    ticStorage.approveExchange(exchangeID);\\n\\n    emit ExchangeApproved(exchangeID, sender);\\n  }\\n\\n  function rejectExchange(bytes32 exchangeID)\\n    external\\n    override\\n    onlyValidator\\n    nonReentrant\\n  {\\n    address sender = ticStorage.exchangeRequests[exchangeID].sender;\\n\\n    ticStorage.rejectExchange(exchangeID);\\n\\n    emit ExchangeRejected(exchangeID, sender);\\n  }\\n\\n  function synthereumFinder()\\n    external\\n    view\\n    override\\n    returns (ISynthereumFinder finder)\\n  {\\n    finder = ticStorage.finder;\\n  }\\n\\n  function version() external view override returns (uint8 poolVersion) {\\n    poolVersion = ticStorage.version;\\n  }\\n\\n  function derivative() external view override returns (IDerivative) {\\n    return ticStorage.derivative;\\n  }\\n\\n  function collateralToken() external view override returns (IERC20) {\\n    return ticStorage.collateralToken;\\n  }\\n\\n  function syntheticToken() external view override returns (IERC20) {\\n    return ticStorage.derivative.tokenCurrency();\\n  }\\n\\n  function syntheticTokenSymbol()\\n    external\\n    view\\n    override\\n    returns (string memory symbol)\\n  {\\n    symbol = IStandardERC20(address(ticStorage.derivative.tokenCurrency()))\\n      .symbol();\\n  }\\n\\n  function calculateFee(uint256 collateralAmount)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return\\n      FixedPoint\\n        .Unsigned(collateralAmount)\\n        .mul(ticStorage.fee.feePercentage)\\n        .rawValue;\\n  }\\n\\n  function getMintRequests()\\n    external\\n    view\\n    override\\n    returns (MintRequest[] memory)\\n  {\\n    return ticStorage.getMintRequests();\\n  }\\n\\n  function getRedeemRequests()\\n    external\\n    view\\n    override\\n    returns (RedeemRequest[] memory)\\n  {\\n    return ticStorage.getRedeemRequests();\\n  }\\n\\n  function getExchangeRequests()\\n    external\\n    view\\n    override\\n    returns (ExchangeRequest[] memory)\\n  {\\n    return ticStorage.getExchangeRequests();\\n  }\\n\\n  function setFee(Fee memory _fee)\\n    external\\n    override\\n    nonReentrant\\n    onlyMaintainer\\n  {\\n    _setFeePercentage(_fee.feePercentage.rawValue);\\n    _setFeeRecipients(_fee.feeRecipients, _fee.feeProportions);\\n  }\\n\\n  function setFeePercentage(uint256 _feePercentage)\\n    external\\n    override\\n    nonReentrant\\n    onlyMaintainer\\n  {\\n    _setFeePercentage(_feePercentage);\\n  }\\n\\n  function setFeeRecipients(\\n    address[] memory _feeRecipients,\\n    uint32[] memory _feeProportions\\n  ) external override nonReentrant onlyMaintainer {\\n    _setFeeRecipients(_feeRecipients, _feeProportions);\\n  }\\n\\n  function _setFeePercentage(uint256 _feePercentage) private {\\n    ticStorage.setFeePercentage(FixedPoint.Unsigned(_feePercentage));\\n    emit SetFeePercentage(_feePercentage);\\n  }\\n\\n  function _setFeeRecipients(\\n    address[] memory _feeRecipients,\\n    uint32[] memory _feeProportions\\n  ) private {\\n    ticStorage.setFeeRecipients(_feeRecipients, _feeProportions);\\n    emit SetFeeRecipients(_feeRecipients, _feeProportions);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v0/interfaces/ITIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  FixedPoint\\n} from '../../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {\\n  IDerivative\\n} from '../../../derivative/common/interfaces/IDerivative.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../../common/interfaces/IPoolDeployment.sol';\\n\\ninterface SynthereumTICInterface is ISynthereumPoolDeployment {\\n  struct Fee {\\n    FixedPoint.Unsigned feePercentage;\\n    address[] feeRecipients;\\n    uint32[] feeProportions;\\n  }\\n\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n    address liquidityProvider;\\n    address validator;\\n  }\\n\\n  struct MintRequest {\\n    bytes32 mintID;\\n    uint256 timestamp;\\n    address sender;\\n    FixedPoint.Unsigned collateralAmount;\\n    FixedPoint.Unsigned numTokens;\\n  }\\n\\n  struct ExchangeRequest {\\n    bytes32 exchangeID;\\n    uint256 timestamp;\\n    address sender;\\n    SynthereumTICInterface destTIC;\\n    FixedPoint.Unsigned numTokens;\\n    FixedPoint.Unsigned collateralAmount;\\n    FixedPoint.Unsigned destNumTokens;\\n  }\\n\\n  struct RedeemRequest {\\n    bytes32 redeemID;\\n    uint256 timestamp;\\n    address sender;\\n    FixedPoint.Unsigned collateralAmount;\\n    FixedPoint.Unsigned numTokens;\\n  }\\n\\n  function mintRequest(uint256 collateralAmount, uint256 numTokens) external;\\n\\n  function approveMint(bytes32 mintID) external;\\n\\n  function rejectMint(bytes32 mintID) external;\\n\\n  function deposit(uint256 collateralAmount) external;\\n\\n  function withdraw(uint256 collateralAmount) external;\\n\\n  function exchangeMint(uint256 collateralAmount, uint256 numTokens) external;\\n\\n  function depositIntoDerivative(uint256 collateralAmount) external;\\n\\n  function withdrawRequest(uint256 collateralAmount) external;\\n\\n  function withdrawPassedRequest() external;\\n\\n  function redeemRequest(uint256 collateralAmount, uint256 numTokens) external;\\n\\n  function approveRedeem(bytes32 redeemID) external;\\n\\n  function rejectRedeem(bytes32 redeemID) external;\\n\\n  function emergencyShutdown() external;\\n\\n  function settleEmergencyShutdown() external;\\n\\n  function exchangeRequest(\\n    SynthereumTICInterface destTIC,\\n    uint256 numTokens,\\n    uint256 collateralAmount,\\n    uint256 destNumTokens\\n  ) external;\\n\\n  function approveExchange(bytes32 exchangeID) external;\\n\\n  function rejectExchange(bytes32 exchangeID) external;\\n\\n  function setFee(Fee calldata _fee) external;\\n\\n  function setFeePercentage(uint256 _feePercentage) external;\\n\\n  function setFeeRecipients(\\n    address[] calldata _feeRecipients,\\n    uint32[] calldata _feeProportions\\n  ) external;\\n\\n  function derivative() external view returns (IDerivative);\\n\\n  function calculateFee(uint256 collateralAmount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function getMintRequests() external view returns (MintRequest[] memory);\\n\\n  function getRedeemRequests() external view returns (RedeemRequest[] memory);\\n\\n  function getExchangeRequests()\\n    external\\n    view\\n    returns (ExchangeRequest[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v0/HitchensUnorderedKeySet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nlibrary HitchensUnorderedKeySetLib {\\n  struct Set {\\n    mapping(bytes32 => uint256) keyPointers;\\n    bytes32[] keyList;\\n  }\\n\\n  function insert(Set storage self, bytes32 key) internal {\\n    require(key != 0x0, 'UnorderedKeySet(100) - Key cannot be 0x0');\\n    require(\\n      !exists(self, key),\\n      'UnorderedKeySet(101) - Key already exists in the set.'\\n    );\\n    self.keyList.push(key);\\n    self.keyPointers[key] = self.keyList.length - 1;\\n  }\\n\\n  function remove(Set storage self, bytes32 key) internal {\\n    require(\\n      exists(self, key),\\n      'UnorderedKeySet(102) - Key does not exist in the set.'\\n    );\\n    bytes32 keyToMove = self.keyList[count(self) - 1];\\n    uint256 rowToReplace = self.keyPointers[key];\\n    self.keyPointers[keyToMove] = rowToReplace;\\n    self.keyList[rowToReplace] = keyToMove;\\n    delete self.keyPointers[key];\\n    self.keyList.pop();\\n  }\\n\\n  function count(Set storage self) internal view returns (uint256) {\\n    return (self.keyList.length);\\n  }\\n\\n  function exists(Set storage self, bytes32 key) internal view returns (bool) {\\n    if (self.keyList.length == 0) return false;\\n    return self.keyList[self.keyPointers[key]] == key;\\n  }\\n\\n  function keyAtIndex(Set storage self, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return self.keyList[index];\\n  }\\n\\n  function nukeSet(Set storage self) public {\\n    delete self.keyList;\\n  }\\n}\\n\\ncontract HitchensUnorderedKeySet {\\n  using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;\\n  HitchensUnorderedKeySetLib.Set set;\\n\\n  event LogUpdate(address sender, string action, bytes32 key);\\n\\n  function exists(bytes32 key) public view returns (bool) {\\n    return set.exists(key);\\n  }\\n\\n  function insert(bytes32 key) public {\\n    set.insert(key);\\n    emit LogUpdate(msg.sender, 'insert', key);\\n  }\\n\\n  function remove(bytes32 key) public {\\n    set.remove(key);\\n    emit LogUpdate(msg.sender, 'remove', key);\\n  }\\n\\n  function count() public view returns (uint256) {\\n    return set.count();\\n  }\\n\\n  function keyAtIndex(uint256 index) public view returns (bytes32) {\\n    return set.keyAtIndex(index);\\n  }\\n\\n  function nukeSet() public {\\n    set.nukeSet();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/common/interfaces/IDerivative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDerivativeDeployment} from './IDerivativeDeployment.sol';\\nimport {\\n  FinderInterface\\n} from '../../../../@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol';\\nimport {\\n  FixedPoint\\n} from '../../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\n\\ninterface IDerivative is IDerivativeDeployment {\\n  struct FeePayerData {\\n    IERC20 collateralCurrency;\\n    FinderInterface finder;\\n    uint256 lastPaymentTime;\\n    FixedPoint.Unsigned cumulativeFeeMultiplier;\\n  }\\n\\n  struct PositionManagerData {\\n    IERC20 tokenCurrency;\\n    bytes32 priceIdentifier;\\n    uint256 withdrawalLiveness;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    FixedPoint.Unsigned emergencyShutdownPrice;\\n    uint256 emergencyShutdownTimestamp;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  struct GlobalPositionData {\\n    FixedPoint.Unsigned totalTokensOutstanding;\\n    FixedPoint.Unsigned rawTotalPositionCollateral;\\n  }\\n\\n  function feePayerData() external view returns (FeePayerData memory data);\\n\\n  function positionManagerData()\\n    external\\n    view\\n    returns (PositionManagerData memory data);\\n\\n  function globalPositionData()\\n    external\\n    view\\n    returns (GlobalPositionData memory data);\\n\\n  function depositTo(\\n    address sponsor,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) external;\\n\\n  function deposit(FixedPoint.Unsigned memory collateralAmount) external;\\n\\n  function withdraw(FixedPoint.Unsigned memory collateralAmount)\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\\n    external;\\n\\n  function withdrawPassedRequest()\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function cancelWithdrawal() external;\\n\\n  function create(\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) external;\\n\\n  function redeem(FixedPoint.Unsigned memory numTokens)\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function repay(FixedPoint.Unsigned memory numTokens) external;\\n\\n  function settleEmergencyShutdown()\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function emergencyShutdown() external;\\n\\n  function remargin() external;\\n\\n  function trimExcess(IERC20 token)\\n    external\\n    returns (FixedPoint.Unsigned memory amount);\\n\\n  function addPool(address pool) external;\\n\\n  function addAdmin(address admin) external;\\n\\n  function renouncePool() external;\\n\\n  function renounceAdminAndPool() external;\\n\\n  function addSyntheticTokenMinter(address derivative) external;\\n\\n  function addSyntheticTokenBurner(address derivative) external;\\n\\n  function addSyntheticTokenAdmin(address derivative) external;\\n\\n  function addSyntheticTokenAdminAndMinterAndBurner(address derivative)\\n    external;\\n\\n  function renounceSyntheticTokenMinter() external;\\n\\n  function renounceSyntheticTokenBurner() external;\\n\\n  function renounceSyntheticTokenAdmin() external;\\n\\n  function renounceSyntheticTokenAdminAndMinterAndBurner() external;\\n\\n  function getCollateral(address sponsor)\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory collateralAmount);\\n\\n  function totalPositionCollateral()\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory totalCollateral);\\n\\n  function emergencyShutdownPrice()\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory emergencyPrice);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IFinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFinder {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../GSN/Context.sol';\\n\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract ReentrancyGuard {\\n  uint256 private constant _NOT_ENTERED = 1;\\n  uint256 private constant _ENTERED = 2;\\n\\n  uint256 private _status;\\n\\n  constructor() internal {\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  modifier nonReentrant() {\\n    require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');\\n\\n    _status = _ENTERED;\\n\\n    _;\\n\\n    _status = _NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/base/interfaces/IStandardERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IStandardERC20 is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/common/interfaces/IPoolDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumFinder} from '../../../versioning/interfaces/IFinder.sol';\\n\\ninterface ISynthereumPoolDeployment {\\n  function synthereumFinder() external view returns (ISynthereumFinder finder);\\n\\n  function version() external view returns (uint8 poolVersion);\\n\\n  function collateralToken() external view returns (IERC20 collateralCurrency);\\n\\n  function syntheticToken() external view returns (IERC20 syntheticCurrency);\\n\\n  function syntheticTokenSymbol() external view returns (string memory symbol);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/common/interfaces/IDerivativeDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IDerivativeDeployment {\\n  function addAdminAndPool(address adminAndPool) external;\\n\\n  function renounceAdmin() external;\\n\\n  function collateralCurrency() external view returns (IERC20 collateral);\\n\\n  function tokenCurrency() external view returns (IERC20 syntheticCurrency);\\n\\n  function getAdminMembers() external view returns (address[] memory);\\n\\n  function getPoolMembers() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/PoolRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {ISynthereumPoolRegistry} from './interfaces/IPoolRegistry.sol';\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {IERC20} from '../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {SynthereumInterfaces} from './Constants.sol';\\nimport {\\n  EnumerableSet\\n} from '../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\nimport {\\n  Lockable\\n} from '../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\n\\ncontract SynthereumPoolRegistry is ISynthereumPoolRegistry, Lockable {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  ISynthereumFinder public synthereumFinder;\\n\\n  mapping(string => mapping(IERC20 => mapping(uint8 => EnumerableSet.AddressSet)))\\n    private symbolToPools;\\n\\n  EnumerableSet.AddressSet private collaterals;\\n\\n  constructor(ISynthereumFinder _synthereumFinder) public {\\n    synthereumFinder = _synthereumFinder;\\n  }\\n\\n  function registerPool(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 poolVersion,\\n    address pool\\n  ) external override nonReentrant {\\n    address deployer =\\n      ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n        SynthereumInterfaces.Deployer\\n      );\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    symbolToPools[syntheticTokenSymbol][collateralToken][poolVersion].add(pool);\\n    collaterals.add(address(collateralToken));\\n  }\\n\\n  function isPoolDeployed(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion,\\n    address pool\\n  ) external view override nonReentrantView returns (bool isDeployed) {\\n    isDeployed = symbolToPools[poolSymbol][collateral][poolVersion].contains(\\n      pool\\n    );\\n  }\\n\\n  function getPools(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion\\n  ) external view override nonReentrantView returns (address[] memory) {\\n    EnumerableSet.AddressSet storage poolSet =\\n      symbolToPools[poolSymbol][collateral][poolVersion];\\n    uint256 numberOfPools = poolSet.length();\\n    address[] memory pools = new address[](numberOfPools);\\n    for (uint256 j = 0; j < numberOfPools; j++) {\\n      pools[j] = poolSet.at(j);\\n    }\\n    return pools;\\n  }\\n\\n  function getCollaterals()\\n    external\\n    view\\n    override\\n    nonReentrantView\\n    returns (address[] memory)\\n  {\\n    uint256 numberOfCollaterals = collaterals.length();\\n    address[] memory collateralAddresses = new address[](numberOfCollaterals);\\n    for (uint256 j = 0; j < numberOfCollaterals; j++) {\\n      collateralAddresses[j] = collaterals.at(j);\\n    }\\n    return collateralAddresses;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IPoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface ISynthereumPoolRegistry {\\n  function registerPool(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 poolVersion,\\n    address pool\\n  ) external;\\n\\n  function isPoolDeployed(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion,\\n    address pool\\n  ) external view returns (bool isDeployed);\\n\\n  function getPools(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion\\n  ) external view returns (address[] memory);\\n\\n  function getCollaterals() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nlibrary SynthereumInterfaces {\\n  bytes32 public constant Deployer = 'Deployer';\\n  bytes32 public constant FactoryVersioning = 'FactoryVersioning';\\n  bytes32 public constant PoolRegistry = 'PoolRegistry';\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {ISynthereumDeployer} from './interfaces/IDeployer.sol';\\nimport {\\n  ISynthereumFactoryVersioning\\n} from './interfaces/IFactoryVersioning.sol';\\nimport {ISynthereumPoolRegistry} from './interfaces/IPoolRegistry.sol';\\nimport {IERC20} from '../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDeploymentSignature} from './interfaces/IDeploymentSignature.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../synthereum-pool/common/interfaces/IPoolDeployment.sol';\\nimport {\\n  IDerivativeDeployment\\n} from '../derivative/common/interfaces/IDerivativeDeployment.sol';\\nimport {SynthereumInterfaces} from './Constants.sol';\\nimport {Address} from '../../@openzeppelin/contracts/utils/Address.sol';\\nimport {\\n  EnumerableSet\\n} from '../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\nimport {\\n  Lockable\\n} from '../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\nimport {\\n  AccessControl\\n} from '../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumDeployer is ISynthereumDeployer, AccessControl, Lockable {\\n  using Address for address;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  ISynthereumFinder public synthereumFinder;\\n\\n  event PoolDeployed(\\n    uint8 indexed poolVersion,\\n    address indexed derivative,\\n    address newPool\\n  );\\n  event DerivativeDeployed(\\n    uint8 indexed derivativeVersion,\\n    address indexed pool,\\n    address newDerivative\\n  );\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  constructor(ISynthereumFinder _synthereumFinder, Roles memory _roles) public {\\n    synthereumFinder = _synthereumFinder;\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n  }\\n\\n  function deployPoolAndDerivative(\\n    uint8 derivativeVersion,\\n    uint8 poolVersion,\\n    bytes calldata derivativeParamsData,\\n    bytes calldata poolParamsData\\n  )\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n    returns (IDerivativeDeployment derivative, ISynthereumPoolDeployment pool)\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning = getFactoryVersioning();\\n    derivative = deployDerivative(\\n      factoryVersioning,\\n      derivativeVersion,\\n      derivativeParamsData\\n    );\\n    checkDerivativeRoles(derivative);\\n    pool = deployPool(\\n      factoryVersioning,\\n      poolVersion,\\n      derivative,\\n      poolParamsData\\n    );\\n    checkPoolDeployment(pool, poolVersion);\\n    checkPoolAndDerivativeMatching(pool, derivative);\\n    setDerivativeRoles(derivative, pool);\\n    ISynthereumPoolRegistry poolRegister = getPoolRegister();\\n    poolRegister.registerPool(\\n      pool.syntheticTokenSymbol(),\\n      pool.collateralToken(),\\n      poolVersion,\\n      address(pool)\\n    );\\n    emit PoolDeployed(poolVersion, address(derivative), address(pool));\\n    emit DerivativeDeployed(\\n      derivativeVersion,\\n      address(pool),\\n      address(derivative)\\n    );\\n  }\\n\\n  function deployOnlyPool(\\n    uint8 poolVersion,\\n    bytes calldata poolParamsData,\\n    IDerivativeDeployment derivative\\n  )\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n    returns (ISynthereumPoolDeployment pool)\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning = getFactoryVersioning();\\n    pool = deployPool(\\n      factoryVersioning,\\n      poolVersion,\\n      derivative,\\n      poolParamsData\\n    );\\n    checkPoolDeployment(pool, poolVersion);\\n    checkPoolAndDerivativeMatching(pool, derivative);\\n    ISynthereumPoolRegistry poolRegister = getPoolRegister();\\n    poolRegister.registerPool(\\n      pool.syntheticTokenSymbol(),\\n      pool.collateralToken(),\\n      poolVersion,\\n      address(pool)\\n    );\\n    emit PoolDeployed(poolVersion, address(derivative), address(pool));\\n  }\\n\\n  function deployOnlyDerivative(\\n    uint8 derivativeVersion,\\n    bytes calldata derivativeParamsData,\\n    ISynthereumPoolDeployment pool\\n  )\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n    returns (IDerivativeDeployment derivative)\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning = getFactoryVersioning();\\n    derivative = deployDerivative(\\n      factoryVersioning,\\n      derivativeVersion,\\n      derivativeParamsData\\n    );\\n    checkDerivativeRoles(derivative);\\n    checkPoolAndDerivativeMatching(pool, derivative);\\n    setDerivativeRoles(derivative, pool);\\n    emit DerivativeDeployed(\\n      derivativeVersion,\\n      address(pool),\\n      address(derivative)\\n    );\\n  }\\n\\n  function deployDerivative(\\n    ISynthereumFactoryVersioning factoryVersioning,\\n    uint8 derivativeVersion,\\n    bytes memory derivativeParamsData\\n  ) internal returns (IDerivativeDeployment derivative) {\\n    address derivativeFactory =\\n      factoryVersioning.getDerivativeFactoryVersion(derivativeVersion);\\n    bytes memory derivativeDeploymentResult =\\n      derivativeFactory.functionCall(\\n        abi.encodePacked(\\n          getDeploymentSignature(derivativeFactory),\\n          derivativeParamsData\\n        ),\\n        'Wrong derivative deployment'\\n      );\\n    derivative = IDerivativeDeployment(\\n      abi.decode(derivativeDeploymentResult, (address))\\n    );\\n  }\\n\\n  function deployPool(\\n    ISynthereumFactoryVersioning factoryVersioning,\\n    uint8 poolVersion,\\n    IDerivativeDeployment derivative,\\n    bytes memory poolParamsData\\n  ) internal returns (ISynthereumPoolDeployment pool) {\\n    address poolFactory = factoryVersioning.getPoolFactoryVersion(poolVersion);\\n    bytes memory poolDeploymentResult =\\n      poolFactory.functionCall(\\n        abi.encodePacked(\\n          getDeploymentSignature(poolFactory),\\n          bytes32(uint256(address(derivative))),\\n          poolParamsData\\n        ),\\n        'Wrong pool deployment'\\n      );\\n    pool = ISynthereumPoolDeployment(\\n      abi.decode(poolDeploymentResult, (address))\\n    );\\n  }\\n\\n  function setDerivativeRoles(\\n    IDerivativeDeployment derivative,\\n    ISynthereumPoolDeployment pool\\n  ) internal {\\n    address poolAddr = address(pool);\\n    derivative.addAdminAndPool(poolAddr);\\n    derivative.renounceAdmin();\\n  }\\n\\n  function getFactoryVersioning()\\n    internal\\n    view\\n    returns (ISynthereumFactoryVersioning factoryVersioning)\\n  {\\n    factoryVersioning = ISynthereumFactoryVersioning(\\n      synthereumFinder.getImplementationAddress(\\n        SynthereumInterfaces.FactoryVersioning\\n      )\\n    );\\n  }\\n\\n  function getPoolRegister()\\n    internal\\n    view\\n    returns (ISynthereumPoolRegistry poolRegister)\\n  {\\n    poolRegister = ISynthereumPoolRegistry(\\n      synthereumFinder.getImplementationAddress(\\n        SynthereumInterfaces.PoolRegistry\\n      )\\n    );\\n  }\\n\\n  function getDeploymentSignature(address deploymentContract)\\n    internal\\n    view\\n    returns (bytes4 signature)\\n  {\\n    signature = IDeploymentSignature(deploymentContract).deploymentSignature();\\n  }\\n\\n  function checkDerivativeRoles(IDerivativeDeployment derivative)\\n    internal\\n    view\\n  {\\n    address[] memory derivativeAdmins = derivative.getAdminMembers();\\n    require(derivativeAdmins.length == 1, 'The derivative must have one admin');\\n    require(\\n      derivativeAdmins[0] == address(this),\\n      'The derivative admin must be the deployer'\\n    );\\n    address[] memory derivativePools = derivative.getPoolMembers();\\n    require(derivativePools.length == 0, 'The derivative must have no pools');\\n  }\\n\\n  function checkPoolDeployment(ISynthereumPoolDeployment pool, uint8 version)\\n    internal\\n    view\\n  {\\n    require(\\n      pool.synthereumFinder() == synthereumFinder,\\n      'Wrong finder in pool deployment'\\n    );\\n    require(pool.version() == version, 'Wrong version in pool deployment');\\n  }\\n\\n  function checkPoolAndDerivativeMatching(\\n    ISynthereumPoolDeployment pool,\\n    IDerivativeDeployment derivative\\n  ) internal view {\\n    require(\\n      pool.collateralToken() == derivative.collateralCurrency(),\\n      'Wrong collateral matching'\\n    );\\n    require(\\n      pool.syntheticToken() == derivative.tokenCurrency(),\\n      'Wrong synthetic token matching'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../../synthereum-pool/common/interfaces/IPoolDeployment.sol';\\nimport {\\n  IDerivativeDeployment\\n} from '../../derivative/common/interfaces/IDerivativeDeployment.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\n\\ninterface ISynthereumDeployer {\\n  function deployPoolAndDerivative(\\n    uint8 derivativeVersion,\\n    uint8 poolVersion,\\n    bytes calldata derivativeParamsData,\\n    bytes calldata poolParamsData\\n  )\\n    external\\n    returns (IDerivativeDeployment derivative, ISynthereumPoolDeployment pool);\\n\\n  function deployOnlyPool(\\n    uint8 poolVersion,\\n    bytes calldata poolParamsData,\\n    IDerivativeDeployment derivative\\n  ) external returns (ISynthereumPoolDeployment pool);\\n\\n  function deployOnlyDerivative(\\n    uint8 derivativeVersion,\\n    bytes calldata derivativeParamsData,\\n    ISynthereumPoolDeployment pool\\n  ) external returns (IDerivativeDeployment derivative);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IFactoryVersioning.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFactoryVersioning {\\n  function setPoolFactory(uint8 version, address poolFactory) external;\\n\\n  function removePoolFactory(uint8 version) external;\\n\\n  function setDerivativeFactory(uint8 version, address derivativeFactory)\\n    external;\\n\\n  function removeDerivativeFactory(uint8 version) external;\\n\\n  function getPoolFactoryVersion(uint8 version) external view returns (address);\\n\\n  function numberOfVerisonsOfPoolFactory() external view returns (uint256);\\n\\n  function getDerivativeFactoryVersion(uint8 version)\\n    external\\n    view\\n    returns (address);\\n\\n  function numberOfVerisonsOfDerivativeFactory()\\n    external\\n    view\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IDeploymentSignature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface IDeploymentSignature {\\n  function deploymentSignature() external view returns (bytes4 signature);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/Finder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {\\n  AccessControl\\n} from '../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumFinder is ISynthereumFinder, AccessControl {\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  mapping(bytes32 => address) public interfacesImplemented;\\n\\n  event InterfaceImplementationChanged(\\n    bytes32 indexed interfaceName,\\n    address indexed newImplementationAddress\\n  );\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  constructor(Roles memory _roles) public {\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n  }\\n\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external override onlyMaintainer {\\n    interfacesImplemented[interfaceName] = implementationAddress;\\n\\n    emit InterfaceImplementationChanged(interfaceName, implementationAddress);\\n  }\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    override\\n    returns (address)\\n  {\\n    address implementationAddress = interfacesImplemented[interfaceName];\\n    require(implementationAddress != address(0x0), 'Implementation not found');\\n    return implementationAddress;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/FactoryVersioning.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  ISynthereumFactoryVersioning\\n} from './interfaces/IFactoryVersioning.sol';\\nimport {\\n  EnumerableMap\\n} from '../../@openzeppelin/contracts/utils/EnumerableMap.sol';\\nimport {\\n  AccessControl\\n} from '../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumFactoryVersioning is\\n  ISynthereumFactoryVersioning,\\n  AccessControl\\n{\\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  EnumerableMap.UintToAddressMap private _poolsFactory;\\n\\n  EnumerableMap.UintToAddressMap private _derivativeFactory;\\n\\n  event AddPoolFactory(uint8 indexed version, address poolFactory);\\n\\n  event RemovePoolFactory(uint8 indexed version);\\n\\n  event AddDerivativeFactory(uint8 indexed version, address derivativeFactory);\\n\\n  event RemoveDerivativeFactory(uint8 indexed version);\\n\\n  constructor(Roles memory _roles) public {\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n  }\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  function setPoolFactory(uint8 version, address poolFactory)\\n    external\\n    override\\n    onlyMaintainer\\n  {\\n    _poolsFactory.set(version, poolFactory);\\n    emit AddPoolFactory(version, poolFactory);\\n  }\\n\\n  function removePoolFactory(uint8 version) external override onlyMaintainer {\\n    require(\\n      _poolsFactory.remove(version),\\n      'Version of the pool factory does not exist'\\n    );\\n    emit RemovePoolFactory(version);\\n  }\\n\\n  function setDerivativeFactory(uint8 version, address derivativeFactory)\\n    external\\n    override\\n    onlyMaintainer\\n  {\\n    _derivativeFactory.set(version, derivativeFactory);\\n    emit AddDerivativeFactory(version, derivativeFactory);\\n  }\\n\\n  function removeDerivativeFactory(uint8 version)\\n    external\\n    override\\n    onlyMaintainer\\n  {\\n    require(\\n      _derivativeFactory.remove(version),\\n      'Version of the pool factory does not exist'\\n    );\\n    emit RemoveDerivativeFactory(version);\\n  }\\n\\n  function getPoolFactoryVersion(uint8 version)\\n    external\\n    view\\n    override\\n    returns (address poolFactory)\\n  {\\n    poolFactory = _poolsFactory.get(version);\\n  }\\n\\n  function numberOfVerisonsOfPoolFactory()\\n    external\\n    view\\n    override\\n    returns (uint256 numberOfVersions)\\n  {\\n    numberOfVersions = _poolsFactory.length();\\n  }\\n\\n  function getDerivativeFactoryVersion(uint8 version)\\n    external\\n    view\\n    override\\n    returns (address derivativeFactory)\\n  {\\n    derivativeFactory = _derivativeFactory.get(version);\\n  }\\n\\n  function numberOfVerisonsOfDerivativeFactory()\\n    external\\n    view\\n    override\\n    returns (uint256 numberOfVersions)\\n  {\\n    numberOfVersions = _derivativeFactory.length();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableMap {\\n  struct MapEntry {\\n    bytes32 _key;\\n    bytes32 _value;\\n  }\\n\\n  struct Map {\\n    MapEntry[] _entries;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _set(\\n    Map storage map,\\n    bytes32 key,\\n    bytes32 value\\n  ) private returns (bool) {\\n    uint256 keyIndex = map._indexes[key];\\n\\n    if (keyIndex == 0) {\\n      map._entries.push(MapEntry({_key: key, _value: value}));\\n\\n      map._indexes[key] = map._entries.length;\\n      return true;\\n    } else {\\n      map._entries[keyIndex - 1]._value = value;\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Map storage map, bytes32 key) private returns (bool) {\\n    uint256 keyIndex = map._indexes[key];\\n\\n    if (keyIndex != 0) {\\n      uint256 toDeleteIndex = keyIndex - 1;\\n      uint256 lastIndex = map._entries.length - 1;\\n\\n      MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n      map._entries[toDeleteIndex] = lastEntry;\\n\\n      map._indexes[lastEntry._key] = toDeleteIndex + 1;\\n\\n      map._entries.pop();\\n\\n      delete map._indexes[key];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n    return map._indexes[key] != 0;\\n  }\\n\\n  function _length(Map storage map) private view returns (uint256) {\\n    return map._entries.length;\\n  }\\n\\n  function _at(Map storage map, uint256 index)\\n    private\\n    view\\n    returns (bytes32, bytes32)\\n  {\\n    require(map._entries.length > index, 'EnumerableMap: index out of bounds');\\n\\n    MapEntry storage entry = map._entries[index];\\n    return (entry._key, entry._value);\\n  }\\n\\n  function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n    return _get(map, key, 'EnumerableMap: nonexistent key');\\n  }\\n\\n  function _get(\\n    Map storage map,\\n    bytes32 key,\\n    string memory errorMessage\\n  ) private view returns (bytes32) {\\n    uint256 keyIndex = map._indexes[key];\\n    require(keyIndex != 0, errorMessage);\\n    return map._entries[keyIndex - 1]._value;\\n  }\\n\\n  struct UintToAddressMap {\\n    Map _inner;\\n  }\\n\\n  function set(\\n    UintToAddressMap storage map,\\n    uint256 key,\\n    address value\\n  ) internal returns (bool) {\\n    return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\n  }\\n\\n  function remove(UintToAddressMap storage map, uint256 key)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(map._inner, bytes32(key));\\n  }\\n\\n  function contains(UintToAddressMap storage map, uint256 key)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(map._inner, bytes32(key));\\n  }\\n\\n  function length(UintToAddressMap storage map)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return _length(map._inner);\\n  }\\n\\n  function at(UintToAddressMap storage map, uint256 index)\\n    internal\\n    view\\n    returns (uint256, address)\\n  {\\n    (bytes32 key, bytes32 value) = _at(map._inner, index);\\n    return (uint256(key), address(uint256(value)));\\n  }\\n\\n  function get(UintToAddressMap storage map, uint256 key)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_get(map._inner, bytes32(key))));\\n  }\\n\\n  function get(\\n    UintToAddressMap storage map,\\n    uint256 key,\\n    string memory errorMessage\\n  ) internal view returns (address) {\\n    return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/v1/SyntheticTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumFactoryVersioning\\n} from '../../versioning/interfaces/IFactoryVersioning.sol';\\nimport {\\n  MintableBurnableIERC20\\n} from '../../../@jarvis-network/uma-core/contracts/common/interfaces/MintableBurnableIERC20.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {\\n  MintableBurnableTokenFactory\\n} from '../../../@jarvis-network/uma-core/contracts/financial-templates/common/MintableBurnableTokenFactory.sol';\\n\\ncontract SynthereumSyntheticTokenFactory is MintableBurnableTokenFactory {\\n  address public synthereumFinder;\\n\\n  uint8 public derivativeVersion;\\n\\n  constructor(address _synthereumFinder, uint8 _derivativeVersion) public {\\n    synthereumFinder = _synthereumFinder;\\n    derivativeVersion = _derivativeVersion;\\n  }\\n\\n  function createToken(\\n    string calldata tokenName,\\n    string calldata tokenSymbol,\\n    uint8 tokenDecimals\\n  ) public override returns (MintableBurnableIERC20 newToken) {\\n    ISynthereumFactoryVersioning factoryVersioning =\\n      ISynthereumFactoryVersioning(\\n        ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n          SynthereumInterfaces.FactoryVersioning\\n        )\\n      );\\n    require(\\n      msg.sender ==\\n        factoryVersioning.getDerivativeFactoryVersion(derivativeVersion),\\n      'Sender must be a Derivative Factory'\\n    );\\n    newToken = super.createToken(tokenName, tokenSymbol, tokenDecimals);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/MintableBurnableIERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\nabstract contract MintableBurnableIERC20 is ERC20 {\\n  function burn(uint256 value) external virtual;\\n\\n  function mint(address to, uint256 value) external virtual returns (bool);\\n\\n  function addMinter(address account) external virtual;\\n\\n  function addBurner(address account) external virtual;\\n\\n  function addAdmin(address account) external virtual;\\n\\n  function addAdminAndMinterAndBurner(address account) external virtual;\\n\\n  function renounceMinter() external virtual;\\n\\n  function renounceBurner() external virtual;\\n\\n  function renounceAdmin() external virtual;\\n\\n  function renounceAdminAndMinterAndBurner() external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/MintableBurnableTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport './MintableBurnableSyntheticToken.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport '../../common/implementation/Lockable.sol';\\n\\ncontract MintableBurnableTokenFactory is Lockable {\\n  function createToken(\\n    string memory tokenName,\\n    string memory tokenSymbol,\\n    uint8 tokenDecimals\\n  ) public virtual nonReentrant() returns (MintableBurnableIERC20 newToken) {\\n    MintableBurnableSyntheticToken mintableToken =\\n      new MintableBurnableSyntheticToken(tokenName, tokenSymbol, tokenDecimals);\\n    mintableToken.addAdmin(msg.sender);\\n    mintableToken.renounceAdmin();\\n    newToken = MintableBurnableIERC20(address(mintableToken));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/MintableBurnableSyntheticToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\nimport '../../common/implementation/MintableBurnableERC20.sol';\\nimport '../../common/implementation/Lockable.sol';\\n\\ncontract MintableBurnableSyntheticToken is MintableBurnableERC20, Lockable {\\n  constructor(\\n    string memory tokenName,\\n    string memory tokenSymbol,\\n    uint8 tokenDecimals\\n  )\\n    public\\n    MintableBurnableERC20(tokenName, tokenSymbol, tokenDecimals)\\n    nonReentrant()\\n  {}\\n\\n  function addMinter(address account) public override nonReentrant() {\\n    super.addMinter(account);\\n  }\\n\\n  function addBurner(address account) public override nonReentrant() {\\n    super.addBurner(account);\\n  }\\n\\n  function addAdmin(address account) public override nonReentrant() {\\n    super.addAdmin(account);\\n  }\\n\\n  function addAdminAndMinterAndBurner(address account)\\n    public\\n    override\\n    nonReentrant()\\n  {\\n    super.addAdminAndMinterAndBurner(account);\\n  }\\n\\n  function renounceMinter() public override nonReentrant() {\\n    super.renounceMinter();\\n  }\\n\\n  function renounceBurner() public override nonReentrant() {\\n    super.renounceBurner();\\n  }\\n\\n  function renounceAdmin() public override nonReentrant() {\\n    super.renounceAdmin();\\n  }\\n\\n  function renounceAdminAndMinterAndBurner() public override nonReentrant() {\\n    super.renounceAdminAndMinterAndBurner();\\n  }\\n\\n  function isMinter(address account)\\n    public\\n    view\\n    nonReentrantView()\\n    returns (bool)\\n  {\\n    return hasRole(MINTER_ROLE, account);\\n  }\\n\\n  function isBurner(address account)\\n    public\\n    view\\n    nonReentrantView()\\n    returns (bool)\\n  {\\n    return hasRole(BURNER_ROLE, account);\\n  }\\n\\n  function isAdmin(address account)\\n    public\\n    view\\n    nonReentrantView()\\n    returns (bool)\\n  {\\n    return hasRole(DEFAULT_ADMIN_ROLE, account);\\n  }\\n\\n  function getAdminMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(DEFAULT_ADMIN_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(DEFAULT_ADMIN_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function getMinterMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(MINTER_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(MINTER_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function getBurnerMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(BURNER_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(BURNER_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/MintableBurnableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/access/AccessControl.sol';\\nimport '../interfaces/MintableBurnableIERC20.sol';\\n\\ncontract MintableBurnableERC20 is ERC20, MintableBurnableIERC20, AccessControl {\\n  bytes32 public constant MINTER_ROLE = keccak256('Minter');\\n\\n  bytes32 public constant BURNER_ROLE = keccak256('Burner');\\n\\n  modifier onlyMinter() {\\n    require(hasRole(MINTER_ROLE, msg.sender), 'Sender must be the minter');\\n    _;\\n  }\\n\\n  modifier onlyBurner() {\\n    require(hasRole(BURNER_ROLE, msg.sender), 'Sender must be the burner');\\n    _;\\n  }\\n\\n  constructor(\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    uint8 _tokenDecimals\\n  ) public ERC20(_tokenName, _tokenSymbol) {\\n    _setupDecimals(_tokenDecimals);\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  function mint(address recipient, uint256 value)\\n    external\\n    override\\n    onlyMinter()\\n    returns (bool)\\n  {\\n    _mint(recipient, value);\\n    return true;\\n  }\\n\\n  function burn(uint256 value) external override onlyBurner() {\\n    _burn(msg.sender, value);\\n  }\\n\\n  function addMinter(address account) public virtual override {\\n    grantRole(MINTER_ROLE, account);\\n  }\\n\\n  function addBurner(address account) public virtual override {\\n    grantRole(BURNER_ROLE, account);\\n  }\\n\\n  function addAdmin(address account) public virtual override {\\n    grantRole(DEFAULT_ADMIN_ROLE, account);\\n  }\\n\\n  function addAdminAndMinterAndBurner(address account) public virtual override {\\n    grantRole(DEFAULT_ADMIN_ROLE, account);\\n    grantRole(MINTER_ROLE, account);\\n    grantRole(BURNER_ROLE, account);\\n  }\\n\\n  function renounceMinter() public virtual override {\\n    renounceRole(MINTER_ROLE, msg.sender);\\n  }\\n\\n  function renounceBurner() public virtual override {\\n    renounceRole(BURNER_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdmin() public virtual override {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdminAndMinterAndBurner() public virtual override {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    renounceRole(MINTER_ROLE, msg.sender);\\n    renounceRole(BURNER_ROLE, msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetutalPoolPartyCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport '../../oracle/implementation/ContractCreator.sol';\\nimport '../../common/implementation/Testable.sol';\\nimport '../../common/implementation/AddressWhitelist.sol';\\nimport '../../common/implementation/Lockable.sol';\\nimport '../common/MintableBurnableTokenFactory.sol';\\nimport './PerpetualPoolPartyLib.sol';\\n\\ncontract PerpetualPoolPartyCreator is ContractCreator, Testable, Lockable {\\n  using FixedPoint for FixedPoint.Unsigned;\\n\\n  struct Params {\\n    address collateralAddress;\\n    bytes32 priceFeedIdentifier;\\n    string syntheticName;\\n    string syntheticSymbol;\\n    address syntheticToken;\\n    FixedPoint.Unsigned collateralRequirement;\\n    FixedPoint.Unsigned disputeBondPct;\\n    FixedPoint.Unsigned sponsorDisputeRewardPct;\\n    FixedPoint.Unsigned disputerDisputeRewardPct;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    uint256 withdrawalLiveness;\\n    uint256 liquidationLiveness;\\n    address excessTokenBeneficiary;\\n    address[] admins;\\n    address[] pools;\\n  }\\n\\n  address public tokenFactoryAddress;\\n\\n  event CreatedPerpetual(\\n    address indexed perpetualAddress,\\n    address indexed deployerAddress\\n  );\\n\\n  constructor(\\n    address _finderAddress,\\n    address _tokenFactoryAddress,\\n    address _timerAddress\\n  )\\n    public\\n    ContractCreator(_finderAddress)\\n    Testable(_timerAddress)\\n    nonReentrant()\\n  {\\n    tokenFactoryAddress = _tokenFactoryAddress;\\n  }\\n\\n  function createPerpetual(Params memory params)\\n    public\\n    virtual\\n    nonReentrant()\\n    returns (address)\\n  {\\n    require(bytes(params.syntheticName).length != 0, 'Missing synthetic name');\\n    require(\\n      bytes(params.syntheticSymbol).length != 0,\\n      'Missing synthetic symbol'\\n    );\\n    MintableBurnableTokenFactory tf =\\n      MintableBurnableTokenFactory(tokenFactoryAddress);\\n    address derivative;\\n    if (params.syntheticToken == address(0)) {\\n      MintableBurnableIERC20 tokenCurrency =\\n        tf.createToken(params.syntheticName, params.syntheticSymbol, 18);\\n      derivative = PerpetualPoolPartyLib.deploy(\\n        _convertParams(params, tokenCurrency)\\n      );\\n\\n      tokenCurrency.addAdminAndMinterAndBurner(derivative);\\n      tokenCurrency.renounceAdmin();\\n    } else {\\n      MintableBurnableIERC20 tokenCurrency =\\n        MintableBurnableIERC20(params.syntheticToken);\\n      require(\\n        keccak256(abi.encodePacked(tokenCurrency.name())) ==\\n          keccak256(abi.encodePacked(params.syntheticName)),\\n        'Wrong synthetic token name'\\n      );\\n      require(\\n        keccak256(abi.encodePacked(tokenCurrency.symbol())) ==\\n          keccak256(abi.encodePacked(params.syntheticSymbol)),\\n        'Wrong synthetic token symbol'\\n      );\\n      require(\\n        tokenCurrency.decimals() == uint8(18),\\n        'Decimals of synthetic token must be 18'\\n      );\\n      derivative = PerpetualPoolPartyLib.deploy(\\n        _convertParams(params, tokenCurrency)\\n      );\\n    }\\n\\n    _registerContract(new address[](0), address(derivative));\\n\\n    emit CreatedPerpetual(address(derivative), msg.sender);\\n\\n    return address(derivative);\\n  }\\n\\n  function _convertParams(\\n    Params memory params,\\n    MintableBurnableIERC20 newTokenCurrency\\n  )\\n    private\\n    view\\n    returns (PerpetualPoolParty.ConstructorParams memory constructorParams)\\n  {\\n    constructorParams.positionManagerParams.finderAddress = finderAddress;\\n    constructorParams.positionManagerParams.timerAddress = timerAddress;\\n\\n    require(params.withdrawalLiveness != 0, 'Withdrawal liveness cannot be 0');\\n    require(\\n      params.liquidationLiveness != 0,\\n      'Liquidation liveness cannot be 0'\\n    );\\n    require(\\n      params.excessTokenBeneficiary != address(0),\\n      'Token Beneficiary cannot be 0x0'\\n    );\\n    require(params.admins.length > 0, 'No admin addresses set');\\n    _requireWhitelistedCollateral(params.collateralAddress);\\n\\n    require(\\n      params.withdrawalLiveness < 5200 weeks,\\n      'Withdrawal liveness too large'\\n    );\\n    require(\\n      params.liquidationLiveness < 5200 weeks,\\n      'Liquidation liveness too large'\\n    );\\n\\n    constructorParams.positionManagerParams.tokenAddress = address(\\n      newTokenCurrency\\n    );\\n    constructorParams.positionManagerParams.collateralAddress = params\\n      .collateralAddress;\\n    constructorParams.positionManagerParams.priceFeedIdentifier = params\\n      .priceFeedIdentifier;\\n    constructorParams.liquidatableParams.collateralRequirement = params\\n      .collateralRequirement;\\n    constructorParams.liquidatableParams.disputeBondPct = params.disputeBondPct;\\n    constructorParams.liquidatableParams.sponsorDisputeRewardPct = params\\n      .sponsorDisputeRewardPct;\\n    constructorParams.liquidatableParams.disputerDisputeRewardPct = params\\n      .disputerDisputeRewardPct;\\n    constructorParams.positionManagerParams.minSponsorTokens = params\\n      .minSponsorTokens;\\n    constructorParams.positionManagerParams.withdrawalLiveness = params\\n      .withdrawalLiveness;\\n    constructorParams.liquidatableParams.liquidationLiveness = params\\n      .liquidationLiveness;\\n    constructorParams.positionManagerParams.excessTokenBeneficiary = params\\n      .excessTokenBeneficiary;\\n    constructorParams.roles.admins = params.admins;\\n    constructorParams.roles.pools = params.pools;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/ContractCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../interfaces/FinderInterface.sol';\\nimport '../../common/implementation/AddressWhitelist.sol';\\nimport './Registry.sol';\\nimport './Constants.sol';\\n\\nabstract contract ContractCreator {\\n  address internal finderAddress;\\n\\n  constructor(address _finderAddress) public {\\n    finderAddress = _finderAddress;\\n  }\\n\\n  function _requireWhitelistedCollateral(address collateralAddress)\\n    internal\\n    view\\n  {\\n    FinderInterface finder = FinderInterface(finderAddress);\\n    AddressWhitelist collateralWhitelist =\\n      AddressWhitelist(\\n        finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)\\n      );\\n    require(\\n      collateralWhitelist.isOnWhitelist(collateralAddress),\\n      'Collateral not whitelisted'\\n    );\\n  }\\n\\n  function _registerContract(\\n    address[] memory parties,\\n    address contractToRegister\\n  ) internal {\\n    FinderInterface finder = FinderInterface(finderAddress);\\n    Registry registry =\\n      Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\\n    registry.registerContract(parties, contractToRegister);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport './PerpetualPoolParty.sol';\\n\\nlibrary PerpetualPoolPartyLib {\\n  function deploy(PerpetualPoolParty.ConstructorParams memory params)\\n    public\\n    returns (address)\\n  {\\n    PerpetualPoolParty derivative = new PerpetualPoolParty(params);\\n    return address(derivative);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport './PerpetualLiquidatablePoolParty.sol';\\n\\ncontract PerpetualPoolParty is PerpetualLiquidatablePoolParty {\\n  constructor(ConstructorParams memory params)\\n    public\\n    PerpetualLiquidatablePoolParty(params)\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualLiquidatablePoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport './PerpetualPositionManagerPoolParty.sol';\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\nimport './PerpetualLiquidatablePoolPartyLib.sol';\\n\\ncontract PerpetualLiquidatablePoolParty is PerpetualPositionManagerPoolParty {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using PerpetualLiquidatablePoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using PerpetualLiquidatablePoolPartyLib for LiquidationData;\\n\\n  enum Status {\\n    Uninitialized,\\n    PreDispute,\\n    PendingDispute,\\n    DisputeSucceeded,\\n    DisputeFailed\\n  }\\n\\n  struct LiquidatableParams {\\n    uint256 liquidationLiveness;\\n    FixedPoint.Unsigned collateralRequirement;\\n    FixedPoint.Unsigned disputeBondPct;\\n    FixedPoint.Unsigned sponsorDisputeRewardPct;\\n    FixedPoint.Unsigned disputerDisputeRewardPct;\\n  }\\n\\n  struct LiquidationData {\\n    address sponsor;\\n    address liquidator;\\n    Status state;\\n    uint256 liquidationTime;\\n    FixedPoint.Unsigned tokensOutstanding;\\n    FixedPoint.Unsigned lockedCollateral;\\n    FixedPoint.Unsigned liquidatedCollateral;\\n    FixedPoint.Unsigned rawUnitCollateral;\\n    address disputer;\\n    FixedPoint.Unsigned settlementPrice;\\n    FixedPoint.Unsigned finalFee;\\n  }\\n\\n  struct ConstructorParams {\\n    PerpetualPositionManagerPoolParty.PositionManagerParams positionManagerParams;\\n    PerpetualPositionManagerPoolParty.Roles roles;\\n    LiquidatableParams liquidatableParams;\\n  }\\n\\n  struct LiquidatableData {\\n    FixedPoint.Unsigned rawLiquidationCollateral;\\n    uint256 liquidationLiveness;\\n    FixedPoint.Unsigned collateralRequirement;\\n    FixedPoint.Unsigned disputeBondPct;\\n    FixedPoint.Unsigned sponsorDisputeRewardPct;\\n    FixedPoint.Unsigned disputerDisputeRewardPct;\\n  }\\n\\n  struct RewardsData {\\n    FixedPoint.Unsigned payToSponsor;\\n    FixedPoint.Unsigned payToLiquidator;\\n    FixedPoint.Unsigned payToDisputer;\\n    FixedPoint.Unsigned paidToSponsor;\\n    FixedPoint.Unsigned paidToLiquidator;\\n    FixedPoint.Unsigned paidToDisputer;\\n  }\\n\\n  mapping(address => LiquidationData[]) public liquidations;\\n\\n  LiquidatableData public liquidatableData;\\n\\n  event LiquidationCreated(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    uint256 indexed liquidationId,\\n    uint256 tokensOutstanding,\\n    uint256 lockedCollateral,\\n    uint256 liquidatedCollateral,\\n    uint256 liquidationTime\\n  );\\n  event LiquidationDisputed(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address indexed disputer,\\n    uint256 liquidationId,\\n    uint256 disputeBondAmount\\n  );\\n  event DisputeSettled(\\n    address indexed caller,\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address disputer,\\n    uint256 liquidationId,\\n    bool disputeSucceeded\\n  );\\n  event LiquidationWithdrawn(\\n    address indexed caller,\\n    uint256 paidToLiquidator,\\n    uint256 paidToDisputer,\\n    uint256 paidToSponsor,\\n    Status indexed liquidationStatus,\\n    uint256 settlementPrice\\n  );\\n\\n  modifier disputable(uint256 liquidationId, address sponsor) {\\n    _disputable(liquidationId, sponsor);\\n    _;\\n  }\\n\\n  modifier withdrawable(uint256 liquidationId, address sponsor) {\\n    _withdrawable(liquidationId, sponsor);\\n    _;\\n  }\\n\\n  constructor(ConstructorParams memory params)\\n    public\\n    PerpetualPositionManagerPoolParty(\\n      params.positionManagerParams,\\n      params.roles\\n    )\\n  {\\n    require(\\n      params.liquidatableParams.collateralRequirement.isGreaterThan(1),\\n      'CR is more than 100%'\\n    );\\n    require(\\n      params\\n        .liquidatableParams\\n        .sponsorDisputeRewardPct\\n        .add(params.liquidatableParams.disputerDisputeRewardPct)\\n        .isLessThan(1),\\n      'Rewards are more than 100%'\\n    );\\n\\n    liquidatableData.liquidationLiveness = params\\n      .liquidatableParams\\n      .liquidationLiveness;\\n    liquidatableData.collateralRequirement = params\\n      .liquidatableParams\\n      .collateralRequirement;\\n    liquidatableData.disputeBondPct = params.liquidatableParams.disputeBondPct;\\n    liquidatableData.sponsorDisputeRewardPct = params\\n      .liquidatableParams\\n      .sponsorDisputeRewardPct;\\n    liquidatableData.disputerDisputeRewardPct = params\\n      .liquidatableParams\\n      .disputerDisputeRewardPct;\\n  }\\n\\n  function createLiquidation(\\n    address sponsor,\\n    FixedPoint.Unsigned calldata minCollateralPerToken,\\n    FixedPoint.Unsigned calldata maxCollateralPerToken,\\n    FixedPoint.Unsigned calldata maxTokensToLiquidate,\\n    uint256 deadline\\n  )\\n    external\\n    fees()\\n    notEmergencyShutdown()\\n    nonReentrant()\\n    returns (\\n      uint256 liquidationId,\\n      FixedPoint.Unsigned memory tokensLiquidated,\\n      FixedPoint.Unsigned memory finalFeeBond\\n    )\\n  {\\n    PositionData storage positionToLiquidate = _getPositionData(sponsor);\\n\\n    LiquidationData[] storage TokenSponsorLiquidations = liquidations[sponsor];\\n\\n    FixedPoint.Unsigned memory finalFee = _computeFinalFees();\\n\\n    uint256 actualTime = getCurrentTime();\\n\\n    PerpetualLiquidatablePoolPartyLib.CreateLiquidationParams memory params =\\n      PerpetualLiquidatablePoolPartyLib.CreateLiquidationParams(\\n        minCollateralPerToken,\\n        maxCollateralPerToken,\\n        maxTokensToLiquidate,\\n        actualTime,\\n        deadline,\\n        finalFee,\\n        sponsor\\n      );\\n\\n\\n      PerpetualLiquidatablePoolPartyLib.CreateLiquidationReturnParams\\n        memory returnValues\\n    ;\\n\\n    returnValues = positionToLiquidate.createLiquidation(\\n      globalPositionData,\\n      positionManagerData,\\n      liquidatableData,\\n      TokenSponsorLiquidations,\\n      params,\\n      feePayerData\\n    );\\n\\n    return (\\n      returnValues.liquidationId,\\n      returnValues.tokensLiquidated,\\n      returnValues.finalFeeBond\\n    );\\n  }\\n\\n  function dispute(uint256 liquidationId, address sponsor)\\n    external\\n    disputable(liquidationId, sponsor)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory totalPaid)\\n  {\\n    LiquidationData storage disputedLiquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n\\n    totalPaid = disputedLiquidation.dispute(\\n      liquidatableData,\\n      positionManagerData,\\n      feePayerData,\\n      liquidationId,\\n      sponsor\\n    );\\n  }\\n\\n  function withdrawLiquidation(uint256 liquidationId, address sponsor)\\n    public\\n    withdrawable(liquidationId, sponsor)\\n    fees()\\n    nonReentrant()\\n    returns (RewardsData memory)\\n  {\\n    LiquidationData storage liquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n\\n    RewardsData memory rewardsData =\\n      liquidation.withdrawLiquidation(\\n        liquidatableData,\\n        positionManagerData,\\n        feePayerData,\\n        liquidationId,\\n        sponsor\\n      );\\n\\n    return rewardsData;\\n  }\\n\\n  function deleteLiquidation(uint256 liquidationId, address sponsor)\\n    external\\n    onlyThisContract\\n  {\\n    delete liquidations[sponsor][liquidationId];\\n  }\\n\\n  function _pfc() internal view override returns (FixedPoint.Unsigned memory) {\\n    return\\n      super._pfc().add(\\n        liquidatableData.rawLiquidationCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n  }\\n\\n  function _getLiquidationData(address sponsor, uint256 liquidationId)\\n    internal\\n    view\\n    returns (LiquidationData storage liquidation)\\n  {\\n    LiquidationData[] storage liquidationArray = liquidations[sponsor];\\n\\n    require(\\n      liquidationId < liquidationArray.length &&\\n        liquidationArray[liquidationId].state != Status.Uninitialized,\\n      'Invalid liquidation ID'\\n    );\\n    return liquidationArray[liquidationId];\\n  }\\n\\n  function _getLiquidationExpiry(LiquidationData storage liquidation)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return\\n      liquidation.liquidationTime.add(liquidatableData.liquidationLiveness);\\n  }\\n\\n  function _disputable(uint256 liquidationId, address sponsor) internal view {\\n    LiquidationData storage liquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n    require(\\n      (getCurrentTime() < _getLiquidationExpiry(liquidation)) &&\\n        (liquidation.state == Status.PreDispute),\\n      'Liquidation not disputable'\\n    );\\n  }\\n\\n  function _withdrawable(uint256 liquidationId, address sponsor) internal view {\\n    LiquidationData storage liquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n    Status state = liquidation.state;\\n\\n    require(\\n      (state > Status.PreDispute) ||\\n        ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) &&\\n          (state == Status.PreDispute)),\\n      'Liquidation not withdrawable'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\n\\nimport '../../oracle/interfaces/OracleInterface.sol';\\nimport '../../oracle/interfaces/IdentifierWhitelistInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nimport '../common/FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract PerpetualPositionManagerPoolParty is AccessControl, FeePayerPoolParty {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using PerpetualPositionManagerPoolPartyLib for PositionData;\\n  using PerpetualPositionManagerPoolPartyLib for PositionManagerData;\\n\\n  bytes32 public constant POOL_ROLE = keccak256('Pool');\\n\\n  struct Roles {\\n    address[] admins;\\n    address[] pools;\\n  }\\n\\n  struct PositionManagerParams {\\n    uint256 withdrawalLiveness;\\n    address collateralAddress;\\n    address tokenAddress;\\n    address finderAddress;\\n    bytes32 priceFeedIdentifier;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    address timerAddress;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  struct PositionData {\\n    FixedPoint.Unsigned tokensOutstanding;\\n    uint256 withdrawalRequestPassTimestamp;\\n    FixedPoint.Unsigned withdrawalRequestAmount;\\n    FixedPoint.Unsigned rawCollateral;\\n  }\\n\\n  struct GlobalPositionData {\\n    FixedPoint.Unsigned totalTokensOutstanding;\\n    FixedPoint.Unsigned rawTotalPositionCollateral;\\n  }\\n\\n  struct PositionManagerData {\\n    MintableBurnableIERC20 tokenCurrency;\\n    bytes32 priceIdentifier;\\n    uint256 withdrawalLiveness;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    FixedPoint.Unsigned emergencyShutdownPrice;\\n    uint256 emergencyShutdownTimestamp;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  mapping(address => PositionData) public positions;\\n\\n  GlobalPositionData public globalPositionData;\\n\\n  PositionManagerData public positionManagerData;\\n\\n  event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\\n  event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\\n  event RequestWithdrawal(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalExecuted(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalCanceled(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event PositionCreated(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event NewSponsor(address indexed sponsor);\\n  event EndedSponsorPosition(address indexed sponsor);\\n  event Redeem(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event Repay(\\n    address indexed sponsor,\\n    uint256 indexed numTokensRepaid,\\n    uint256 indexed newTokenCount\\n  );\\n  event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\\n  event SettleEmergencyShutdown(\\n    address indexed caller,\\n    uint256 indexed collateralReturned,\\n    uint256 indexed tokensBurned\\n  );\\n\\n  modifier onlyPool() {\\n    require(hasRole(POOL_ROLE, msg.sender), 'Sender must be a pool');\\n    _;\\n  }\\n\\n  modifier onlyCollateralizedPosition(address sponsor) {\\n    _onlyCollateralizedPosition(sponsor);\\n    _;\\n  }\\n\\n  modifier notEmergencyShutdown() {\\n    _notEmergencyShutdown();\\n    _;\\n  }\\n\\n  modifier isEmergencyShutdown() {\\n    _isEmergencyShutdown();\\n    _;\\n  }\\n\\n  modifier noPendingWithdrawal(address sponsor) {\\n    _positionHasNoPendingWithdrawal(sponsor);\\n    _;\\n  }\\n\\n  constructor(\\n    PositionManagerParams memory _positionManagerData,\\n    Roles memory _roles\\n  )\\n    public\\n    FeePayerPoolParty(\\n      _positionManagerData.collateralAddress,\\n      _positionManagerData.finderAddress,\\n      _positionManagerData.timerAddress\\n    )\\n    nonReentrant()\\n  {\\n    require(\\n      _getIdentifierWhitelist().isIdentifierSupported(\\n        _positionManagerData.priceFeedIdentifier\\n      ),\\n      'Unsupported price identifier'\\n    );\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(POOL_ROLE, DEFAULT_ADMIN_ROLE);\\n    for (uint256 j = 0; j < _roles.admins.length; j++) {\\n      _setupRole(DEFAULT_ADMIN_ROLE, _roles.admins[j]);\\n    }\\n    for (uint256 j = 0; j < _roles.pools.length; j++) {\\n      _setupRole(POOL_ROLE, _roles.pools[j]);\\n    }\\n    positionManagerData.withdrawalLiveness = _positionManagerData\\n      .withdrawalLiveness;\\n    positionManagerData.tokenCurrency = MintableBurnableIERC20(\\n      _positionManagerData.tokenAddress\\n    );\\n    positionManagerData.minSponsorTokens = _positionManagerData\\n      .minSponsorTokens;\\n    positionManagerData.priceIdentifier = _positionManagerData\\n      .priceFeedIdentifier;\\n    positionManagerData.excessTokenBeneficiary = _positionManagerData\\n      .excessTokenBeneficiary;\\n  }\\n\\n  function depositTo(\\n    address sponsor,\\n    FixedPoint.Unsigned memory collateralAmount\\n  )\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(sponsor)\\n    fees()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(sponsor);\\n\\n    positionData.depositTo(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData,\\n      sponsor\\n    );\\n  }\\n\\n  function deposit(FixedPoint.Unsigned memory collateralAmount) public {\\n    depositTo(msg.sender, collateralAmount);\\n  }\\n\\n  function withdraw(FixedPoint.Unsigned memory collateralAmount)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n\\n    amountWithdrawn = positionData.withdraw(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n  }\\n\\n  function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    nonReentrant()\\n  {\\n    uint256 actualTime = getCurrentTime();\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.requestWithdrawal(\\n      positionManagerData,\\n      collateralAmount,\\n      actualTime,\\n      feePayerData\\n    );\\n  }\\n\\n  function withdrawPassedRequest()\\n    external\\n    onlyPool()\\n    notEmergencyShutdown()\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    uint256 actualTime = getCurrentTime();\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    amountWithdrawn = positionData.withdrawPassedRequest(\\n      globalPositionData,\\n      actualTime,\\n      feePayerData\\n    );\\n  }\\n\\n  function cancelWithdrawal()\\n    external\\n    onlyPool()\\n    notEmergencyShutdown()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.cancelWithdrawal();\\n  }\\n\\n  function create(\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) public onlyPool() notEmergencyShutdown() fees() nonReentrant() {\\n    PositionData storage positionData = positions[msg.sender];\\n\\n    positionData.create(\\n      globalPositionData,\\n      positionManagerData,\\n      collateralAmount,\\n      numTokens,\\n      feePayerData\\n    );\\n  }\\n\\n  function redeem(FixedPoint.Unsigned memory numTokens)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n\\n    amountWithdrawn = positionData.redeeem(\\n      globalPositionData,\\n      positionManagerData,\\n      numTokens,\\n      feePayerData,\\n      msg.sender\\n    );\\n  }\\n\\n  function repay(FixedPoint.Unsigned memory numTokens)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.repay(globalPositionData, positionManagerData, numTokens);\\n  }\\n\\n  function settleEmergencyShutdown()\\n    external\\n    onlyPool()\\n    isEmergencyShutdown()\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = positions[msg.sender];\\n    amountWithdrawn = positionData.settleEmergencyShutdown(\\n      globalPositionData,\\n      positionManagerData,\\n      feePayerData\\n    );\\n  }\\n\\n  function emergencyShutdown()\\n    external\\n    override\\n    notEmergencyShutdown()\\n    nonReentrant()\\n  {\\n    require(\\n      hasRole(POOL_ROLE, msg.sender) ||\\n        msg.sender == _getFinancialContractsAdminAddress(),\\n      'Caller must be a pool or the UMA governor'\\n    );\\n    positionManagerData.emergencyShutdownTimestamp = getCurrentTime();\\n    positionManagerData.requestOraclePrice(\\n      positionManagerData.emergencyShutdownTimestamp,\\n      feePayerData\\n    );\\n    emit EmergencyShutdown(\\n      msg.sender,\\n      positionManagerData.emergencyShutdownTimestamp\\n    );\\n  }\\n\\n  function remargin() external override {\\n    return;\\n  }\\n\\n  function trimExcess(IERC20 token)\\n    external\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amount)\\n  {\\n    FixedPoint.Unsigned memory pfcAmount = _pfc();\\n    amount = positionManagerData.trimExcess(token, pfcAmount, feePayerData);\\n  }\\n\\n  function deleteSponsorPosition(address sponsor) external onlyThisContract {\\n    delete positions[sponsor];\\n  }\\n\\n  function addPool(address pool) external {\\n    grantRole(POOL_ROLE, pool);\\n  }\\n\\n  function addAdmin(address admin) external {\\n    grantRole(DEFAULT_ADMIN_ROLE, admin);\\n  }\\n\\n  function addAdminAndPool(address adminAndPool) external {\\n    grantRole(DEFAULT_ADMIN_ROLE, adminAndPool);\\n    grantRole(POOL_ROLE, adminAndPool);\\n  }\\n\\n  function renouncePool() external {\\n    renounceRole(POOL_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdmin() external {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdminAndPool() external {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    renounceRole(POOL_ROLE, msg.sender);\\n  }\\n\\n  function addSyntheticTokenMinter(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addMinter(derivative);\\n  }\\n\\n  function addSyntheticTokenBurner(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addBurner(derivative);\\n  }\\n\\n  function addSyntheticTokenAdmin(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addAdmin(derivative);\\n  }\\n\\n  function addSyntheticTokenAdminAndMinterAndBurner(address derivative)\\n    external\\n    onlyPool()\\n  {\\n    positionManagerData.tokenCurrency.addAdminAndMinterAndBurner(derivative);\\n  }\\n\\n  function renounceSyntheticTokenMinter() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceMinter();\\n  }\\n\\n  function renounceSyntheticTokenBurner() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceBurner();\\n  }\\n\\n  function renounceSyntheticTokenAdmin() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceAdmin();\\n  }\\n\\n  function renounceSyntheticTokenAdminAndMinterAndBurner() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceAdminAndMinterAndBurner();\\n  }\\n\\n  function getCollateral(address sponsor)\\n    external\\n    view\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory collateralAmount)\\n  {\\n    return\\n      positions[sponsor].rawCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function tokenCurrency() external view nonReentrantView() returns (IERC20) {\\n    return positionManagerData.tokenCurrency;\\n  }\\n\\n  function totalPositionCollateral()\\n    external\\n    view\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory totalCollateral)\\n  {\\n    return\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function emergencyShutdownPrice()\\n    external\\n    view\\n    isEmergencyShutdown()\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return positionManagerData.emergencyShutdownPrice;\\n  }\\n\\n  function getAdminMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(DEFAULT_ADMIN_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(DEFAULT_ADMIN_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function getPoolMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(POOL_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(POOL_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function _pfc()\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _getPositionData(address sponsor)\\n    internal\\n    view\\n    onlyCollateralizedPosition(sponsor)\\n    returns (PositionData storage)\\n  {\\n    return positions[sponsor];\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    internal\\n    view\\n    returns (IdentifierWhitelistInterface)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        feePayerData.finder.getImplementationAddress(\\n          OracleInterfaces.IdentifierWhitelist\\n        )\\n      );\\n  }\\n\\n  function _onlyCollateralizedPosition(address sponsor) internal view {\\n    require(\\n      positions[sponsor]\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isGreaterThan(0),\\n      'Position has no collateral'\\n    );\\n  }\\n\\n  function _notEmergencyShutdown() internal view {\\n    require(\\n      positionManagerData.emergencyShutdownTimestamp == 0,\\n      'Contract emergency shutdown'\\n    );\\n  }\\n\\n  function _isEmergencyShutdown() internal view {\\n    require(\\n      positionManagerData.emergencyShutdownTimestamp != 0,\\n      'Contract not emergency shutdown'\\n    );\\n  }\\n\\n  function _positionHasNoPendingWithdrawal(address sponsor) internal view {\\n    require(\\n      _getPositionData(sponsor).withdrawalRequestPassTimestamp == 0,\\n      'Pending withdrawal'\\n    );\\n  }\\n\\n  function _getFinancialContractsAdminAddress()\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return\\n      feePayerData.finder.getImplementationAddress(\\n        OracleInterfaces.FinancialContractsAdmin\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../common/interfaces/IERC20Standard.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport '../../oracle/interfaces/OracleInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\nimport './PerpetualPositionManagerPoolParty.sol';\\nimport '../common/FeePayerPoolPartyLib.sol';\\n\\nlibrary PerpetualPositionManagerPoolPartyLib {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionManagerData;\\n  using PerpetualPositionManagerPoolPartyLib for FeePayerPoolParty.FeePayerData;\\n  using PerpetualPositionManagerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n\\n  event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\\n  event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\\n  event RequestWithdrawal(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalExecuted(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalCanceled(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event PositionCreated(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event NewSponsor(address indexed sponsor);\\n  event EndedSponsorPosition(address indexed sponsor);\\n  event Redeem(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event Repay(\\n    address indexed sponsor,\\n    uint256 indexed numTokensRepaid,\\n    uint256 indexed newTokenCount\\n  );\\n  event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\\n  event SettleEmergencyShutdown(\\n    address indexed caller,\\n    uint256 indexed collateralReturned,\\n    uint256 indexed tokensBurned\\n  );\\n\\n  function depositTo(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external {\\n    require(collateralAmount.isGreaterThan(0), 'Invalid collateral amount');\\n\\n    positionData._incrementCollateralBalances(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    emit Deposit(sponsor, collateralAmount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      collateralAmount.rawValue\\n    );\\n  }\\n\\n  function withdraw(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(collateralAmount.isGreaterThan(0), 'Invalid collateral amount');\\n\\n    amountWithdrawn = _decrementCollateralBalancesCheckGCR(\\n      positionData,\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n  }\\n\\n  function requestWithdrawal(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    uint256 actualTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    require(\\n      collateralAmount.isGreaterThan(0) &&\\n        collateralAmount.isLessThanOrEqual(\\n          positionData.rawCollateral.getFeeAdjustedCollateral(\\n            feePayerData.cumulativeFeeMultiplier\\n          )\\n        ),\\n      'Invalid collateral amount'\\n    );\\n\\n    positionData.withdrawalRequestPassTimestamp = actualTime.add(\\n      positionManagerData.withdrawalLiveness\\n    );\\n    positionData.withdrawalRequestAmount = collateralAmount;\\n\\n    emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\\n  }\\n\\n  function withdrawPassedRequest(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    uint256 actualTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(\\n      positionData.withdrawalRequestPassTimestamp != 0 &&\\n        positionData.withdrawalRequestPassTimestamp <= actualTime,\\n      'Invalid withdraw request'\\n    );\\n\\n    FixedPoint.Unsigned memory amountToWithdraw =\\n      positionData.withdrawalRequestAmount;\\n    if (\\n      positionData.withdrawalRequestAmount.isGreaterThan(\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      )\\n    ) {\\n      amountToWithdraw = positionData.rawCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n    }\\n\\n    amountWithdrawn = positionData._decrementCollateralBalances(\\n      globalPositionData,\\n      amountToWithdraw,\\n      feePayerData\\n    );\\n\\n    positionData._resetWithdrawalRequest();\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n\\n    emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\\n  }\\n\\n  function cancelWithdrawal(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData\\n  ) external {\\n    require(\\n      positionData.withdrawalRequestPassTimestamp != 0,\\n      'No pending withdrawal'\\n    );\\n\\n    emit RequestWithdrawalCanceled(\\n      msg.sender,\\n      positionData.withdrawalRequestAmount.rawValue\\n    );\\n\\n    _resetWithdrawalRequest(positionData);\\n  }\\n\\n  function create(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    require(\\n      (_checkCollateralization(\\n        globalPositionData,\\n        positionData\\n          .rawCollateral\\n          .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n          .add(collateralAmount),\\n        positionData.tokensOutstanding.add(numTokens),\\n        feePayerData\\n      ) ||\\n        _checkCollateralization(\\n          globalPositionData,\\n          collateralAmount,\\n          numTokens,\\n          feePayerData\\n        )),\\n      'Insufficient collateral'\\n    );\\n\\n    require(\\n      positionData.withdrawalRequestPassTimestamp == 0,\\n      'Pending withdrawal'\\n    );\\n    if (positionData.tokensOutstanding.isEqual(0)) {\\n      require(\\n        numTokens.isGreaterThanOrEqual(positionManagerData.minSponsorTokens),\\n        'Below minimum sponsor position'\\n      );\\n      emit NewSponsor(msg.sender);\\n    }\\n\\n    _incrementCollateralBalances(\\n      positionData,\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    positionData.tokensOutstanding = positionData.tokensOutstanding.add(\\n      numTokens\\n    );\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .add(numTokens);\\n\\n    emit PositionCreated(\\n      msg.sender,\\n      collateralAmount.rawValue,\\n      numTokens.rawValue\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      collateralAmount.rawValue\\n    );\\n    require(\\n      positionManagerData.tokenCurrency.mint(msg.sender, numTokens.rawValue),\\n      'Minting synthetic tokens failed'\\n    );\\n  }\\n\\n  function redeeem(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(\\n      numTokens.isLessThanOrEqual(positionData.tokensOutstanding),\\n      'Invalid token amount'\\n    );\\n\\n    FixedPoint.Unsigned memory fractionRedeemed =\\n      numTokens.div(positionData.tokensOutstanding);\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      fractionRedeemed.mul(\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n\\n    if (positionData.tokensOutstanding.isEqual(numTokens)) {\\n      amountWithdrawn = positionData._deleteSponsorPosition(\\n        globalPositionData,\\n        feePayerData,\\n        sponsor\\n      );\\n    } else {\\n      amountWithdrawn = positionData._decrementCollateralBalances(\\n        globalPositionData,\\n        collateralRedeemed,\\n        feePayerData\\n      );\\n\\n      FixedPoint.Unsigned memory newTokenCount =\\n        positionData.tokensOutstanding.sub(numTokens);\\n      require(\\n        newTokenCount.isGreaterThanOrEqual(\\n          positionManagerData.minSponsorTokens\\n        ),\\n        'Below minimum sponsor position'\\n      );\\n      positionData.tokensOutstanding = newTokenCount;\\n\\n      globalPositionData.totalTokensOutstanding = globalPositionData\\n        .totalTokensOutstanding\\n        .sub(numTokens);\\n    }\\n\\n    emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(numTokens.rawValue);\\n  }\\n\\n  function repay(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory numTokens\\n  ) external {\\n    require(\\n      numTokens.isLessThanOrEqual(positionData.tokensOutstanding),\\n      'Invalid token amount'\\n    );\\n\\n    FixedPoint.Unsigned memory newTokenCount =\\n      positionData.tokensOutstanding.sub(numTokens);\\n    require(\\n      newTokenCount.isGreaterThanOrEqual(positionManagerData.minSponsorTokens),\\n      'Below minimum sponsor position'\\n    );\\n    positionData.tokensOutstanding = newTokenCount;\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(numTokens);\\n\\n    emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\\n\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(numTokens.rawValue);\\n  }\\n\\n  function settleEmergencyShutdown(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    if (\\n      positionManagerData.emergencyShutdownPrice.isEqual(\\n        FixedPoint.fromUnscaledUint(0)\\n      )\\n    ) {\\n      FixedPoint.Unsigned memory oraclePrice =\\n        positionManagerData._getOracleEmergencyShutdownPrice(feePayerData);\\n      positionManagerData.emergencyShutdownPrice = oraclePrice\\n        ._decimalsScalingFactor(feePayerData);\\n    }\\n\\n    FixedPoint.Unsigned memory tokensToRedeem =\\n      FixedPoint.Unsigned(\\n        positionManagerData.tokenCurrency.balanceOf(msg.sender)\\n      );\\n\\n    FixedPoint.Unsigned memory totalRedeemableCollateral =\\n      tokensToRedeem.mul(positionManagerData.emergencyShutdownPrice);\\n\\n    if (\\n      positionData\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isGreaterThan(0)\\n    ) {\\n      FixedPoint.Unsigned memory tokenDebtValueInCollateral =\\n        positionData.tokensOutstanding.mul(\\n          positionManagerData.emergencyShutdownPrice\\n        );\\n      FixedPoint.Unsigned memory positionCollateral =\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        );\\n\\n      FixedPoint.Unsigned memory positionRedeemableCollateral =\\n        tokenDebtValueInCollateral.isLessThan(positionCollateral)\\n          ? positionCollateral.sub(tokenDebtValueInCollateral)\\n          : FixedPoint.Unsigned(0);\\n\\n      totalRedeemableCollateral = totalRedeemableCollateral.add(\\n        positionRedeemableCollateral\\n      );\\n\\n      PerpetualPositionManagerPoolParty(address(this)).deleteSponsorPosition(\\n        msg.sender\\n      );\\n      emit EndedSponsorPosition(msg.sender);\\n    }\\n\\n    FixedPoint.Unsigned memory payout =\\n      FixedPoint.min(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        totalRedeemableCollateral\\n      );\\n\\n    amountWithdrawn = globalPositionData\\n      .rawTotalPositionCollateral\\n      .removeCollateral(payout, feePayerData.cumulativeFeeMultiplier);\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(tokensToRedeem);\\n\\n    emit SettleEmergencyShutdown(\\n      msg.sender,\\n      amountWithdrawn.rawValue,\\n      tokensToRedeem.rawValue\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      tokensToRedeem.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(tokensToRedeem.rawValue);\\n  }\\n\\n  function trimExcess(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    IERC20 token,\\n    FixedPoint.Unsigned memory pfcAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amount) {\\n    FixedPoint.Unsigned memory balance =\\n      FixedPoint.Unsigned(token.balanceOf(address(this)));\\n    if (address(token) == address(feePayerData.collateralCurrency)) {\\n      amount = balance.sub(pfcAmount);\\n    } else {\\n      amount = balance;\\n    }\\n    token.safeTransfer(\\n      positionManagerData.excessTokenBeneficiary,\\n      amount.rawValue\\n    );\\n  }\\n\\n  function requestOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    feePayerData._getOracle().requestPrice(\\n      positionManagerData.priceIdentifier,\\n      requestedTime\\n    );\\n  }\\n\\n  function reduceSponsorPosition(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory tokensToRemove,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory withdrawalAmountToRemove,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external {\\n    if (\\n      tokensToRemove.isEqual(positionData.tokensOutstanding) &&\\n      positionData\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isEqual(collateralToRemove)\\n    ) {\\n      positionData._deleteSponsorPosition(\\n        globalPositionData,\\n        feePayerData,\\n        sponsor\\n      );\\n      return;\\n    }\\n\\n    positionData._decrementCollateralBalances(\\n      globalPositionData,\\n      collateralToRemove,\\n      feePayerData\\n    );\\n\\n    positionData.tokensOutstanding = positionData.tokensOutstanding.sub(\\n      tokensToRemove\\n    );\\n    require(\\n      positionData.tokensOutstanding.isGreaterThanOrEqual(\\n        positionManagerData.minSponsorTokens\\n      ),\\n      'Below minimum sponsor position'\\n    );\\n\\n    positionData.withdrawalRequestAmount = positionData\\n      .withdrawalRequestAmount\\n      .sub(withdrawalAmountToRemove);\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(tokensToRemove);\\n  }\\n\\n  function getOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external view returns (FixedPoint.Unsigned memory price) {\\n    return _getOraclePrice(positionManagerData, requestedTime, feePayerData);\\n  }\\n\\n  function decimalsScalingFactor(\\n    FixedPoint.Unsigned memory oraclePrice,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external view returns (FixedPoint.Unsigned memory scaledPrice) {\\n    return _decimalsScalingFactor(oraclePrice, feePayerData);\\n  }\\n\\n  function _incrementCollateralBalances(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData memory feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.addCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.addCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _decrementCollateralBalances(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.removeCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.removeCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _decrementCollateralBalancesCheckGCR(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.removeCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    require(\\n      _checkPositionCollateralization(\\n        positionData,\\n        globalPositionData,\\n        feePayerData\\n      ),\\n      'CR below GCR'\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.removeCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _checkPositionCollateralization(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (bool) {\\n    return\\n      _checkCollateralization(\\n        globalPositionData,\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        positionData.tokensOutstanding,\\n        feePayerData\\n      );\\n  }\\n\\n  function _checkCollateralization(\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (bool) {\\n    FixedPoint.Unsigned memory global =\\n      _getCollateralizationRatio(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        globalPositionData.totalTokensOutstanding\\n      );\\n    FixedPoint.Unsigned memory thisChange =\\n      _getCollateralizationRatio(collateral, numTokens);\\n    return !global.isGreaterThan(thisChange);\\n  }\\n\\n  function _getCollateralizationRatio(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal pure returns (FixedPoint.Unsigned memory ratio) {\\n    return\\n      numTokens.isLessThanOrEqual(0)\\n        ? FixedPoint.fromUnscaledUint(0)\\n        : collateral.div(numTokens);\\n  }\\n\\n  function _resetWithdrawalRequest(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData\\n  ) internal {\\n    positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\\n    positionData.withdrawalRequestPassTimestamp = 0;\\n  }\\n\\n  function _deleteSponsorPosition(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    FixedPoint.Unsigned memory startingGlobalCollateral =\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n    globalPositionData.rawTotalPositionCollateral = globalPositionData\\n      .rawTotalPositionCollateral\\n      .sub(positionToLiquidate.rawCollateral);\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(positionToLiquidate.tokensOutstanding);\\n\\n    PerpetualPositionManagerPoolParty(address(this)).deleteSponsorPosition(\\n      sponsor\\n    );\\n\\n    emit EndedSponsorPosition(sponsor);\\n\\n    return\\n      startingGlobalCollateral.sub(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n  }\\n\\n  function _getOracleEmergencyShutdownPrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory) {\\n    return\\n      positionManagerData._getOraclePrice(\\n        positionManagerData.emergencyShutdownTimestamp,\\n        feePayerData\\n      );\\n  }\\n\\n  function _getOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory price) {\\n    OracleInterface oracle = feePayerData._getOracle();\\n    require(\\n      oracle.hasPrice(positionManagerData.priceIdentifier, requestedTime),\\n      'Unresolved oracle price'\\n    );\\n    int256 oraclePrice =\\n      oracle.getPrice(positionManagerData.priceIdentifier, requestedTime);\\n\\n    if (oraclePrice < 0) {\\n      oraclePrice = 0;\\n    }\\n    return FixedPoint.Unsigned(uint256(oraclePrice));\\n  }\\n\\n  function _getOracle(FeePayerPoolParty.FeePayerData storage feePayerData)\\n    internal\\n    view\\n    returns (OracleInterface)\\n  {\\n    return\\n      OracleInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Oracle)\\n      );\\n  }\\n\\n  function _decimalsScalingFactor(\\n    FixedPoint.Unsigned memory oraclePrice,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory scaledPrice) {\\n    uint8 collateralDecimalsNumber =\\n      IERC20Standard(address(feePayerData.collateralCurrency)).decimals();\\n    scaledPrice = oraclePrice.div(\\n      (10**(uint256(18)).sub(collateralDecimalsNumber))\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualLiquidatablePoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\nimport './PerpetualLiquidatablePoolParty.sol';\\nimport '../common/FeePayerPoolPartyLib.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\n\\nlibrary PerpetualLiquidatablePoolPartyLib {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionManagerData;\\n  using PerpetualLiquidatablePoolPartyLib for PerpetualLiquidatablePoolParty.LiquidationData;\\n  using PerpetualPositionManagerPoolPartyLib for FixedPoint.Unsigned;\\n\\n  struct CreateLiquidationParams {\\n    FixedPoint.Unsigned minCollateralPerToken;\\n    FixedPoint.Unsigned maxCollateralPerToken;\\n    FixedPoint.Unsigned maxTokensToLiquidate;\\n    uint256 actualTime;\\n    uint256 deadline;\\n    FixedPoint.Unsigned finalFee;\\n    address sponsor;\\n  }\\n\\n  struct CreateLiquidationCollateral {\\n    FixedPoint.Unsigned startCollateral;\\n    FixedPoint.Unsigned startCollateralNetOfWithdrawal;\\n    FixedPoint.Unsigned tokensLiquidated;\\n    FixedPoint.Unsigned finalFeeBond;\\n    address sponsor;\\n  }\\n\\n  struct CreateLiquidationReturnParams {\\n    uint256 liquidationId;\\n    FixedPoint.Unsigned lockedCollateral;\\n    FixedPoint.Unsigned liquidatedCollateral;\\n    FixedPoint.Unsigned tokensLiquidated;\\n    FixedPoint.Unsigned finalFeeBond;\\n  }\\n\\n  struct SettleParams {\\n    FixedPoint.Unsigned feeAttenuation;\\n    FixedPoint.Unsigned settlementPrice;\\n    FixedPoint.Unsigned tokenRedemptionValue;\\n    FixedPoint.Unsigned collateral;\\n    FixedPoint.Unsigned disputerDisputeReward;\\n    FixedPoint.Unsigned sponsorDisputeReward;\\n    FixedPoint.Unsigned disputeBondAmount;\\n    FixedPoint.Unsigned finalFee;\\n    FixedPoint.Unsigned withdrawalAmount;\\n  }\\n\\n  event LiquidationCreated(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    uint256 indexed liquidationId,\\n    uint256 tokensOutstanding,\\n    uint256 lockedCollateral,\\n    uint256 liquidatedCollateral,\\n    uint256 liquidationTime\\n  );\\n  event LiquidationDisputed(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address indexed disputer,\\n    uint256 liquidationId,\\n    uint256 disputeBondAmount\\n  );\\n\\n  event DisputeSettled(\\n    address indexed caller,\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address disputer,\\n    uint256 liquidationId,\\n    bool disputeSucceeded\\n  );\\n\\n  event LiquidationWithdrawn(\\n    address indexed caller,\\n    uint256 paidToLiquidator,\\n    uint256 paidToDisputer,\\n    uint256 paidToSponsor,\\n    PerpetualLiquidatablePoolParty.Status indexed liquidationStatus,\\n    uint256 settlementPrice\\n  );\\n\\n  function createLiquidation(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    PerpetualLiquidatablePoolParty.LiquidationData[] storage liquidations,\\n    CreateLiquidationParams memory params,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (CreateLiquidationReturnParams memory returnValues) {\\n    FixedPoint.Unsigned memory startCollateral;\\n    FixedPoint.Unsigned memory startCollateralNetOfWithdrawal;\\n\\n    (\\n      startCollateral,\\n      startCollateralNetOfWithdrawal,\\n      returnValues.tokensLiquidated\\n    ) = calculateNetLiquidation(positionToLiquidate, params, feePayerData);\\n\\n    {\\n      FixedPoint.Unsigned memory startTokens =\\n        positionToLiquidate.tokensOutstanding;\\n\\n      require(\\n        params.maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(\\n          startCollateralNetOfWithdrawal\\n        ),\\n        'CR is more than max liq. price'\\n      );\\n\\n      require(\\n        params.minCollateralPerToken.mul(startTokens).isLessThanOrEqual(\\n          startCollateralNetOfWithdrawal\\n        ),\\n        'CR is less than min liq. price'\\n      );\\n    }\\n    {\\n      returnValues.finalFeeBond = params.finalFee;\\n\\n      CreateLiquidationCollateral memory liquidationCollateral =\\n        CreateLiquidationCollateral(\\n          startCollateral,\\n          startCollateralNetOfWithdrawal,\\n          returnValues.tokensLiquidated,\\n          returnValues.finalFeeBond,\\n          params.sponsor\\n        );\\n\\n      (\\n        returnValues.lockedCollateral,\\n        returnValues.liquidatedCollateral\\n      ) = liquidateCollateral(\\n        positionToLiquidate,\\n        globalPositionData,\\n        positionManagerData,\\n        liquidatableData,\\n        feePayerData,\\n        liquidationCollateral\\n      );\\n\\n      returnValues.liquidationId = liquidations.length;\\n      liquidations.push(\\n        PerpetualLiquidatablePoolParty.LiquidationData({\\n          sponsor: params.sponsor,\\n          liquidator: msg.sender,\\n          state: PerpetualLiquidatablePoolParty.Status.PreDispute,\\n          liquidationTime: params.actualTime,\\n          tokensOutstanding: returnValues.tokensLiquidated,\\n          lockedCollateral: returnValues.lockedCollateral,\\n          liquidatedCollateral: returnValues.liquidatedCollateral,\\n          rawUnitCollateral: FixedPoint\\n            .fromUnscaledUint(1)\\n            .convertToRawCollateral(feePayerData.cumulativeFeeMultiplier),\\n          disputer: address(0),\\n          settlementPrice: FixedPoint.fromUnscaledUint(0),\\n          finalFee: returnValues.finalFeeBond\\n        })\\n      );\\n    }\\n\\n    {\\n      FixedPoint.Unsigned memory griefingThreshold =\\n        positionManagerData.minSponsorTokens;\\n      if (\\n        positionToLiquidate.withdrawalRequestPassTimestamp > 0 &&\\n        positionToLiquidate.withdrawalRequestPassTimestamp >\\n        params.actualTime &&\\n        returnValues.tokensLiquidated.isGreaterThanOrEqual(griefingThreshold)\\n      ) {\\n        positionToLiquidate.withdrawalRequestPassTimestamp = params\\n          .actualTime\\n          .add(positionManagerData.withdrawalLiveness);\\n      }\\n    }\\n    emit LiquidationCreated(\\n      params.sponsor,\\n      msg.sender,\\n      returnValues.liquidationId,\\n      returnValues.tokensLiquidated.rawValue,\\n      returnValues.lockedCollateral.rawValue,\\n      returnValues.liquidatedCollateral.rawValue,\\n      params.actualTime\\n    );\\n\\n    burnAndLiquidateFee(\\n      positionManagerData,\\n      feePayerData,\\n      returnValues.tokensLiquidated,\\n      returnValues.finalFeeBond\\n    );\\n  }\\n\\n  function dispute(\\n    PerpetualLiquidatablePoolParty.LiquidationData storage disputedLiquidation,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    uint256 liquidationId,\\n    address sponsor\\n  ) external returns (FixedPoint.Unsigned memory totalPaid) {\\n    FixedPoint.Unsigned memory disputeBondAmount =\\n      disputedLiquidation\\n        .lockedCollateral\\n        .mul(liquidatableData.disputeBondPct)\\n        .mul(\\n        disputedLiquidation.rawUnitCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n    liquidatableData.rawLiquidationCollateral.addCollateral(\\n      disputeBondAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n\\n    disputedLiquidation.state = PerpetualLiquidatablePoolParty\\n      .Status\\n      .PendingDispute;\\n    disputedLiquidation.disputer = msg.sender;\\n\\n    positionManagerData.requestOraclePrice(\\n      disputedLiquidation.liquidationTime,\\n      feePayerData\\n    );\\n\\n    emit LiquidationDisputed(\\n      sponsor,\\n      disputedLiquidation.liquidator,\\n      msg.sender,\\n      liquidationId,\\n      disputeBondAmount.rawValue\\n    );\\n\\n    totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\\n\\n    FeePayerPoolParty(address(this)).payFinalFees(\\n      msg.sender,\\n      disputedLiquidation.finalFee\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      disputeBondAmount.rawValue\\n    );\\n  }\\n\\n  function withdrawLiquidation(\\n    PerpetualLiquidatablePoolParty.LiquidationData storage liquidation,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    uint256 liquidationId,\\n    address sponsor\\n  )\\n    external\\n    returns (PerpetualLiquidatablePoolParty.RewardsData memory rewards)\\n  {\\n    liquidation._settle(\\n      positionManagerData,\\n      liquidatableData,\\n      feePayerData,\\n      liquidationId,\\n      sponsor\\n    );\\n\\n    SettleParams memory settleParams;\\n\\n    settleParams.feeAttenuation = liquidation\\n      .rawUnitCollateral\\n      .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier);\\n    settleParams.settlementPrice = liquidation.settlementPrice;\\n    settleParams.tokenRedemptionValue = liquidation\\n      .tokensOutstanding\\n      .mul(settleParams.settlementPrice)\\n      .mul(settleParams.feeAttenuation);\\n    settleParams.collateral = liquidation.lockedCollateral.mul(\\n      settleParams.feeAttenuation\\n    );\\n    settleParams.disputerDisputeReward = liquidatableData\\n      .disputerDisputeRewardPct\\n      .mul(settleParams.tokenRedemptionValue);\\n    settleParams.sponsorDisputeReward = liquidatableData\\n      .sponsorDisputeRewardPct\\n      .mul(settleParams.tokenRedemptionValue);\\n    settleParams.disputeBondAmount = settleParams.collateral.mul(\\n      liquidatableData.disputeBondPct\\n    );\\n    settleParams.finalFee = liquidation.finalFee.mul(\\n      settleParams.feeAttenuation\\n    );\\n\\n    if (\\n      liquidation.state ==\\n      PerpetualLiquidatablePoolParty.Status.DisputeSucceeded\\n    ) {\\n      rewards.payToDisputer = settleParams\\n        .disputerDisputeReward\\n        .add(settleParams.disputeBondAmount)\\n        .add(settleParams.finalFee);\\n\\n      rewards.payToSponsor = settleParams.sponsorDisputeReward.add(\\n        settleParams.collateral.sub(settleParams.tokenRedemptionValue)\\n      );\\n\\n      rewards.payToLiquidator = settleParams\\n        .tokenRedemptionValue\\n        .sub(settleParams.sponsorDisputeReward)\\n        .sub(settleParams.disputerDisputeReward);\\n\\n      rewards.paidToLiquidator = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToLiquidator,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n      rewards.paidToSponsor = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToSponsor,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n      rewards.paidToDisputer = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToDisputer,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.disputer,\\n        rewards.paidToDisputer.rawValue\\n      );\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.liquidator,\\n        rewards.paidToLiquidator.rawValue\\n      );\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.sponsor,\\n        rewards.paidToSponsor.rawValue\\n      );\\n    } else if (\\n      liquidation.state == PerpetualLiquidatablePoolParty.Status.DisputeFailed\\n    ) {\\n      rewards.payToLiquidator = settleParams\\n        .collateral\\n        .add(settleParams.disputeBondAmount)\\n        .add(settleParams.finalFee);\\n\\n      rewards.paidToLiquidator = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToLiquidator,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.liquidator,\\n        rewards.paidToLiquidator.rawValue\\n      );\\n    } else if (\\n      liquidation.state == PerpetualLiquidatablePoolParty.Status.PreDispute\\n    ) {\\n      rewards.payToLiquidator = settleParams.collateral.add(\\n        settleParams.finalFee\\n      );\\n\\n      rewards.paidToLiquidator = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToLiquidator,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.liquidator,\\n        rewards.paidToLiquidator.rawValue\\n      );\\n    }\\n\\n    emit LiquidationWithdrawn(\\n      msg.sender,\\n      rewards.paidToLiquidator.rawValue,\\n      rewards.paidToDisputer.rawValue,\\n      rewards.paidToSponsor.rawValue,\\n      liquidation.state,\\n      settleParams.settlementPrice.rawValue\\n    );\\n\\n    PerpetualLiquidatablePoolParty(address(this)).deleteLiquidation(\\n      liquidationId,\\n      sponsor\\n    );\\n\\n    return rewards;\\n  }\\n\\n  function calculateNetLiquidation(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    CreateLiquidationParams memory params,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory startCollateral,\\n      FixedPoint.Unsigned memory startCollateralNetOfWithdrawal,\\n      FixedPoint.Unsigned memory tokensLiquidated\\n    )\\n  {\\n    tokensLiquidated = FixedPoint.min(\\n      params.maxTokensToLiquidate,\\n      positionToLiquidate.tokensOutstanding\\n    );\\n    require(tokensLiquidated.isGreaterThan(0), 'Liquidating 0 tokens');\\n\\n    require(params.actualTime <= params.deadline, 'Mined after deadline');\\n\\n    startCollateral = positionToLiquidate\\n      .rawCollateral\\n      .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier);\\n    startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\\n\\n    if (\\n      positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(\\n        startCollateral\\n      )\\n    ) {\\n      startCollateralNetOfWithdrawal = startCollateral.sub(\\n        positionToLiquidate.withdrawalRequestAmount\\n      );\\n    }\\n  }\\n\\n  function liquidateCollateral(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    CreateLiquidationCollateral memory liquidationCollateralParams\\n  )\\n    internal\\n    returns (\\n      FixedPoint.Unsigned memory lockedCollateral,\\n      FixedPoint.Unsigned memory liquidatedCollateral\\n    )\\n  {\\n    {\\n      FixedPoint.Unsigned memory ratio =\\n        liquidationCollateralParams.tokensLiquidated.div(\\n          positionToLiquidate.tokensOutstanding\\n        );\\n\\n      lockedCollateral = liquidationCollateralParams.startCollateral.mul(ratio);\\n\\n      liquidatedCollateral = liquidationCollateralParams\\n        .startCollateralNetOfWithdrawal\\n        .mul(ratio);\\n\\n      FixedPoint.Unsigned memory withdrawalAmountToRemove =\\n        positionToLiquidate.withdrawalRequestAmount.mul(ratio);\\n\\n      positionToLiquidate.reduceSponsorPosition(\\n        globalPositionData,\\n        positionManagerData,\\n        liquidationCollateralParams.tokensLiquidated,\\n        lockedCollateral,\\n        withdrawalAmountToRemove,\\n        feePayerData,\\n        liquidationCollateralParams.sponsor\\n      );\\n    }\\n\\n    liquidatableData.rawLiquidationCollateral.addCollateral(\\n      lockedCollateral.add(liquidationCollateralParams.finalFeeBond),\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n  }\\n\\n  function burnAndLiquidateFee(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    FixedPoint.Unsigned memory tokensLiquidated,\\n    FixedPoint.Unsigned memory finalFeeBond\\n  ) internal {\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      tokensLiquidated.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(tokensLiquidated.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      finalFeeBond.rawValue\\n    );\\n  }\\n\\n  function _settle(\\n    PerpetualLiquidatablePoolParty.LiquidationData storage liquidation,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    uint256 liquidationId,\\n    address sponsor\\n  ) internal {\\n    if (\\n      liquidation.state != PerpetualLiquidatablePoolParty.Status.PendingDispute\\n    ) {\\n      return;\\n    }\\n\\n    FixedPoint.Unsigned memory oraclePrice =\\n      positionManagerData.getOraclePrice(\\n        liquidation.liquidationTime,\\n        feePayerData\\n      );\\n\\n    liquidation.settlementPrice = oraclePrice.decimalsScalingFactor(\\n      feePayerData\\n    );\\n\\n    FixedPoint.Unsigned memory tokenRedemptionValue =\\n      liquidation.tokensOutstanding.mul(liquidation.settlementPrice);\\n\\n    FixedPoint.Unsigned memory requiredCollateral =\\n      tokenRedemptionValue.mul(liquidatableData.collateralRequirement);\\n\\n    bool disputeSucceeded =\\n      liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\\n    liquidation.state = disputeSucceeded\\n      ? PerpetualLiquidatablePoolParty.Status.DisputeSucceeded\\n      : PerpetualLiquidatablePoolParty.Status.DisputeFailed;\\n\\n    emit DisputeSettled(\\n      msg.sender,\\n      sponsor,\\n      liquidation.liquidator,\\n      liquidation.disputer,\\n      liquidationId,\\n      disputeSucceeded\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/Lockable.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolPartyLib.sol';\\nimport '../../common/implementation/Testable.sol';\\n\\nimport '../../oracle/interfaces/StoreInterface.sol';\\nimport '../../oracle/interfaces/FinderInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nabstract contract FeePayerPoolParty is\\n  AdministrateeInterface,\\n  Testable,\\n  Lockable\\n{\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FeePayerData;\\n  using SafeERC20 for IERC20;\\n\\n  struct FeePayerData {\\n    IERC20 collateralCurrency;\\n    FinderInterface finder;\\n    uint256 lastPaymentTime;\\n    FixedPoint.Unsigned cumulativeFeeMultiplier;\\n  }\\n\\n  FeePayerData public feePayerData;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  modifier fees {\\n    payRegularFees();\\n    _;\\n  }\\n  modifier onlyThisContract {\\n    require(msg.sender == address(this), 'Caller is not this contract');\\n    _;\\n  }\\n\\n  constructor(\\n    address _collateralAddress,\\n    address _finderAddress,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    feePayerData.collateralCurrency = IERC20(_collateralAddress);\\n    feePayerData.finder = FinderInterface(_finderAddress);\\n    feePayerData.lastPaymentTime = getCurrentTime();\\n    feePayerData.cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\\n  }\\n\\n  function payRegularFees()\\n    public\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory totalPaid)\\n  {\\n    StoreInterface store = _getStore();\\n    uint256 time = getCurrentTime();\\n    FixedPoint.Unsigned memory collateralPool = _pfc();\\n    totalPaid = feePayerData.payRegularFees(store, time, collateralPool);\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    external\\n    onlyThisContract\\n  {\\n    _payFinalFees(payer, amount);\\n  }\\n\\n  function pfc()\\n    public\\n    view\\n    override\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return _pfc();\\n  }\\n\\n  function collateralCurrency()\\n    public\\n    view\\n    nonReentrantView()\\n    returns (IERC20)\\n  {\\n    return feePayerData.collateralCurrency;\\n  }\\n\\n  function _payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    internal\\n  {\\n    StoreInterface store = _getStore();\\n    feePayerData.payFinalFees(store, payer, amount);\\n  }\\n\\n  function _pfc() internal view virtual returns (FixedPoint.Unsigned memory);\\n\\n  function _getStore() internal view returns (StoreInterface) {\\n    return\\n      StoreInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Store)\\n      );\\n  }\\n\\n  function _computeFinalFees()\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory finalFees)\\n  {\\n    StoreInterface store = _getStore();\\n    return store.computeFinalFee(address(feePayerData.collateralCurrency));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/IERC20Standard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IERC20Standard is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../oracle/interfaces/StoreInterface.sol';\\n\\nlibrary FeePayerPoolPartyLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  function payRegularFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    uint256 time,\\n    FixedPoint.Unsigned memory collateralPool\\n  ) external returns (FixedPoint.Unsigned memory totalPaid) {\\n    if (collateralPool.isEqual(0)) {\\n      feePayerData.lastPaymentTime = time;\\n      return totalPaid;\\n    }\\n\\n    if (feePayerData.lastPaymentTime == time) {\\n      return totalPaid;\\n    }\\n\\n    FixedPoint.Unsigned memory regularFee;\\n    FixedPoint.Unsigned memory latePenalty;\\n\\n    (regularFee, latePenalty) = store.computeRegularFee(\\n      feePayerData.lastPaymentTime,\\n      time,\\n      collateralPool\\n    );\\n    feePayerData.lastPaymentTime = time;\\n\\n    totalPaid = regularFee.add(latePenalty);\\n    if (totalPaid.isEqual(0)) {\\n      return totalPaid;\\n    }\\n\\n    if (totalPaid.isGreaterThan(collateralPool)) {\\n      FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\\n      FixedPoint.Unsigned memory latePenaltyReduction =\\n        FixedPoint.min(latePenalty, deficit);\\n      latePenalty = latePenalty.sub(latePenaltyReduction);\\n      deficit = deficit.sub(latePenaltyReduction);\\n      regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\\n      totalPaid = collateralPool;\\n    }\\n\\n    emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\\n\\n    feePayerData.cumulativeFeeMultiplier._adjustCumulativeFeeMultiplier(\\n      totalPaid,\\n      collateralPool\\n    );\\n\\n    if (regularFee.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeIncreaseAllowance(\\n        address(store),\\n        regularFee.rawValue\\n      );\\n      store.payOracleFeesErc20(\\n        address(feePayerData.collateralCurrency),\\n        regularFee\\n      );\\n    }\\n\\n    if (latePenalty.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeTransfer(\\n        msg.sender,\\n        latePenalty.rawValue\\n      );\\n    }\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    address payer,\\n    FixedPoint.Unsigned memory amount\\n  ) external {\\n    if (amount.isEqual(0)) {\\n      return;\\n    }\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      payer,\\n      address(this),\\n      amount.rawValue\\n    );\\n\\n    emit FinalFeesPaid(amount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeIncreaseAllowance(\\n      address(store),\\n      amount.rawValue\\n    );\\n    store.payOracleFeesErc20(address(feePayerData.collateralCurrency), amount);\\n  }\\n\\n  function getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral._convertToRawCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function removeCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory removedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToRemove._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\\n    removedCollateral = initialBalance.sub(\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n    );\\n  }\\n\\n  function addCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToAdd,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory addedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToAdd._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\\n    addedCollateral = rawCollateral\\n      ._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n      .sub(initialBalance);\\n  }\\n\\n  function _adjustCumulativeFeeMultiplier(\\n    FixedPoint.Unsigned storage cumulativeFeeMultiplier,\\n    FixedPoint.Unsigned memory amount,\\n    FixedPoint.Unsigned memory currentPfc\\n  ) internal {\\n    FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\\n    cumulativeFeeMultiplier.rawValue = cumulativeFeeMultiplier\\n      .mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee))\\n      .rawValue;\\n  }\\n\\n  function _getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral.mul(cumulativeFeeMultiplier);\\n  }\\n\\n  function _convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral.div(cumulativeFeeMultiplier);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/v1/DerivativeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {\\n  IDeploymentSignature\\n} from '../../versioning/interfaces/IDeploymentSignature.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {\\n  PerpetualPoolPartyCreator\\n} from '../../../@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetutalPoolPartyCreator.sol';\\n\\ncontract SynthereumDerivativeFactory is\\n  PerpetualPoolPartyCreator,\\n  IDeploymentSignature\\n{\\n  address public synthereumFinder;\\n\\n  bytes4 public override deploymentSignature;\\n\\n  constructor(\\n    address _synthereumFinder,\\n    address _umaFinder,\\n    address _tokenFactoryAddress,\\n    address _timerAddress\\n  )\\n    public\\n    PerpetualPoolPartyCreator(_umaFinder, _tokenFactoryAddress, _timerAddress)\\n  {\\n    synthereumFinder = _synthereumFinder;\\n    deploymentSignature = this.createPerpetual.selector;\\n  }\\n\\n  function createPerpetual(Params memory params)\\n    public\\n    override\\n    returns (address derivative)\\n  {\\n    address deployer =\\n      ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n        SynthereumInterfaces.Deployer\\n      );\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    derivative = super.createPerpetual(params);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/PoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {ISynthereumPool} from './interfaces/IPool.sol';\\nimport {SynthereumPool} from './Pool.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {\\n  IDeploymentSignature\\n} from '../../versioning/interfaces/IDeploymentSignature.sol';\\nimport {SynthereumPoolCreator} from './PoolCreator.sol';\\n\\ncontract SynthereumPoolFactory is SynthereumPoolCreator, IDeploymentSignature {\\n  address public synthereumFinder;\\n\\n  bytes4 public override deploymentSignature;\\n\\n  constructor(address _synthereumFinder) public {\\n    synthereumFinder = _synthereumFinder;\\n    deploymentSignature = this.createPool.selector;\\n  }\\n\\n  function createPool(\\n    IDerivative derivative,\\n    ISynthereumFinder finder,\\n    uint8 version,\\n    ISynthereumPool.Roles memory roles,\\n    bool isContractAllowed,\\n    uint256 startingCollateralization,\\n    ISynthereumPool.Fee memory fee\\n  ) public override returns (SynthereumPool poolDeployed) {\\n    address deployer =\\n      ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n        SynthereumInterfaces.Deployer\\n      );\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    poolDeployed = super.createPool(\\n      derivative,\\n      finder,\\n      version,\\n      roles,\\n      isContractAllowed,\\n      startingCollateralization,\\n      fee\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  FixedPoint\\n} from '../../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {\\n  IDerivative\\n} from '../../../derivative/common/interfaces/IDerivative.sol';\\nimport {\\n  ISynthereumDeployer\\n} from '../../../versioning/interfaces/IDeployer.sol';\\nimport {ISynthereumFinder} from '../../../versioning/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../../common/interfaces/IPoolDeployment.sol';\\n\\ninterface ISynthereumPool is ISynthereumPoolDeployment {\\n  struct Fee {\\n    FixedPoint.Unsigned feePercentage;\\n    address[] feeRecipients;\\n    uint32[] feeProportions;\\n  }\\n\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n    address liquidityProvider;\\n    address validator;\\n  }\\n\\n  struct MintParameters {\\n    address sender;\\n    address derivativeAddr;\\n    uint256 collateralAmount;\\n    uint256 numTokens;\\n    uint256 feePercentage;\\n    uint256 nonce;\\n    uint256 expiration;\\n  }\\n\\n  struct RedeemParameters {\\n    address sender;\\n    address derivativeAddr;\\n    uint256 collateralAmount;\\n    uint256 numTokens;\\n    uint256 feePercentage;\\n    uint256 nonce;\\n    uint256 expiration;\\n  }\\n\\n  struct ExchangeParameters {\\n    address sender;\\n    address derivativeAddr;\\n    address destPoolAddr;\\n    address destDerivativeAddr;\\n    uint256 numTokens;\\n    uint256 collateralAmount;\\n    uint256 destNumTokens;\\n    uint256 feePercentage;\\n    uint256 nonce;\\n    uint256 expiration;\\n  }\\n\\n  struct Signature {\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n  }\\n\\n  struct SignatureVerificationParams {\\n    bytes32 domain_separator;\\n    bytes32 typeHash;\\n    ISynthereumPool.Signature signature;\\n    bytes32 validator_role;\\n  }\\n\\n  enum DerivativeRoles {ADMIN, POOL, ADMIN_AND_POOL}\\n\\n  enum SynthTokenRoles {ADMIN, MINTER, BURNER, ADMIN_AND_MINTER_AND_BURNER}\\n\\n  function addDerivative(IDerivative derivative) external;\\n\\n  function removeDerivative(IDerivative derivative) external;\\n\\n  function mint(MintParameters memory mintMetaTx, Signature memory signature)\\n    external\\n    returns (uint256 feePaid);\\n\\n  function redeem(\\n    RedeemParameters memory redeemMetaTx,\\n    Signature memory signature\\n  ) external returns (uint256 feePaid);\\n\\n  function exchange(\\n    ExchangeParameters memory exchangeMetaTx,\\n    Signature memory signature\\n  ) external returns (uint256 feePaid);\\n\\n  function exchangeMint(\\n    IDerivative srcDerivative,\\n    IDerivative derivative,\\n    uint256 collateralAmount,\\n    uint256 numTokens\\n  ) external;\\n\\n  function withdrawFromPool(uint256 collateralAmount) external;\\n\\n  function depositIntoDerivative(\\n    IDerivative derivative,\\n    uint256 collateralAmount\\n  ) external;\\n\\n  function slowWithdrawRequest(IDerivative derivative, uint256 collateralAmount)\\n    external;\\n\\n  function slowWithdrawPassedRequest(IDerivative derivative)\\n    external\\n    returns (uint256 amountWithdrawn);\\n\\n  function fastWithdraw(IDerivative derivative, uint256 collateralAmount)\\n    external\\n    returns (uint256 amountWithdrawn);\\n\\n  function emergencyShutdown(IDerivative derivative) external;\\n\\n  function settleEmergencyShutdown(IDerivative derivative)\\n    external\\n    returns (uint256 amountSettled);\\n\\n  function setFee(Fee memory _fee) external;\\n\\n  function setFeePercentage(uint256 _feePercentage) external;\\n\\n  function setFeeRecipients(\\n    address[] memory _feeRecipients,\\n    uint32[] memory _feeProportions\\n  ) external;\\n\\n  function setStartingCollateralization(uint256 startingCollateralRatio)\\n    external;\\n\\n  function addRoleInDerivative(\\n    IDerivative derivative,\\n    DerivativeRoles derivativeRole,\\n    address addressToAdd\\n  ) external;\\n\\n  function renounceRoleInDerivative(\\n    IDerivative derivative,\\n    DerivativeRoles derivativeRole\\n  ) external;\\n\\n  function addRoleInSynthToken(\\n    IDerivative derivative,\\n    SynthTokenRoles synthTokenRole,\\n    address addressToAdd\\n  ) external;\\n\\n  function renounceRoleInSynthToken(\\n    IDerivative derivative,\\n    SynthTokenRoles synthTokenRole\\n  ) external;\\n\\n  function setIsContractAllowed(bool isContractAllowed) external;\\n\\n  function getAllDerivatives() external view returns (IDerivative[] memory);\\n\\n  function isDerivativeAdmitted(IDerivative derivative)\\n    external\\n    view\\n    returns (bool isAdmitted);\\n\\n  function getStartingCollateralization()\\n    external\\n    view\\n    returns (uint256 startingCollateralRatio);\\n\\n  function isContractAllowed() external view returns (bool isAllowed);\\n\\n  function getFeeInfo() external view returns (Fee memory fee);\\n\\n  function getUserNonce(address user) external view returns (uint256 nonce);\\n\\n  function calculateFee(uint256 collateralAmount)\\n    external\\n    view\\n    returns (uint256 fee);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {ISynthereumPool} from './interfaces/IPool.sol';\\nimport {ISynthereumPoolStorage} from './interfaces/IPoolStorage.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {ISynthereumDeployer} from '../../versioning/interfaces/IDeployer.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {Strings} from '../../../@openzeppelin/contracts/utils/Strings.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\nimport {SynthereumPoolLib} from './PoolLib.sol';\\nimport {\\n  Lockable\\n} from '../../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\nimport {\\n  AccessControl\\n} from '../../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumPool is\\n  AccessControl,\\n  ISynthereumPoolStorage,\\n  ISynthereumPool,\\n  Lockable\\n{\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SynthereumPoolLib for Storage;\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  bytes32 public constant LIQUIDITY_PROVIDER_ROLE =\\n    keccak256('Liquidity Provider');\\n\\n  bytes32 public constant VALIDATOR_ROLE = keccak256('Validator');\\n\\n  bytes32 public immutable MINT_TYPEHASH;\\n\\n  bytes32 public immutable REDEEM_TYPEHASH;\\n\\n  bytes32 public immutable EXCHANGE_TYPEHASH;\\n\\n  bytes32 public DOMAIN_SEPARATOR;\\n\\n  Storage private poolStorage;\\n\\n  event Mint(\\n    address indexed account,\\n    address indexed pool,\\n    uint256 collateralSent,\\n    uint256 numTokensReceived,\\n    uint256 feePaid\\n  );\\n\\n  event Redeem(\\n    address indexed account,\\n    address indexed pool,\\n    uint256 numTokensSent,\\n    uint256 collateralReceived,\\n    uint256 feePaid\\n  );\\n\\n  event Exchange(\\n    address indexed account,\\n    address indexed sourcePool,\\n    address indexed destPool,\\n    uint256 numTokensSent,\\n    uint256 destNumTokensReceived,\\n    uint256 feePaid\\n  );\\n\\n  event Settlement(\\n    address indexed account,\\n    address indexed pool,\\n    uint256 numTokens,\\n    uint256 collateralSettled\\n  );\\n\\n  event SetFeePercentage(uint256 feePercentage);\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  event AddDerivative(address indexed pool, address indexed derivative);\\n  event RemoveDerivative(address indexed pool, address indexed derivative);\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyLiquidityProvider() {\\n    require(\\n      hasRole(LIQUIDITY_PROVIDER_ROLE, msg.sender),\\n      'Sender must be the liquidity provider'\\n    );\\n    _;\\n  }\\n\\n  constructor(\\n    IDerivative _derivative,\\n    ISynthereumFinder _finder,\\n    uint8 _version,\\n    Roles memory _roles,\\n    bool _isContractAllowed,\\n    uint256 _startingCollateralization,\\n    Fee memory _fee\\n  ) public nonReentrant {\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(LIQUIDITY_PROVIDER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(VALIDATOR_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n    _setupRole(LIQUIDITY_PROVIDER_ROLE, _roles.liquidityProvider);\\n    _setupRole(VALIDATOR_ROLE, _roles.validator);\\n    poolStorage.initialize(\\n      _version,\\n      _finder,\\n      _derivative,\\n      FixedPoint.Unsigned(_startingCollateralization),\\n      _isContractAllowed\\n    );\\n    poolStorage.setFeePercentage(_fee.feePercentage);\\n    poolStorage.setFeeRecipients(_fee.feeRecipients, _fee.feeProportions);\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n        ),\\n        keccak256(bytes('Synthereum Pool')),\\n        keccak256(bytes(Strings.toString(_version))),\\n        getChainID(),\\n        address(this)\\n      )\\n    );\\n    MINT_TYPEHASH = keccak256(\\n      'MintParameters(address sender,address derivativeAddr,uint256 collateralAmount,uint256 numTokens,uint256 feePercentage,uint256 nonce,uint256 expiration)'\\n    );\\n    REDEEM_TYPEHASH = keccak256(\\n      'RedeemParameters(address sender,address derivativeAddr,uint256 collateralAmount,uint256 numTokens,uint256 feePercentage,uint256 nonce,uint256 expiration)'\\n    );\\n    EXCHANGE_TYPEHASH = keccak256(\\n      'ExchangeParameters(address sender,address derivativeAddr,address destPoolAddr,address destDerivativeAddr,uint256 numTokens,uint256 collateralAmount,uint256 destNumTokens,uint256 feePercentage,uint256 nonce,uint256 expiration)'\\n    );\\n  }\\n\\n  function addDerivative(IDerivative derivative)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.addDerivative(derivative);\\n  }\\n\\n  function removeDerivative(IDerivative derivative)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.removeDerivative(derivative);\\n  }\\n\\n  function mint(MintParameters memory mintMetaTx, Signature memory signature)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 feePaid)\\n  {\\n    feePaid = poolStorage.mint(\\n      mintMetaTx,\\n      SignatureVerificationParams(\\n        DOMAIN_SEPARATOR,\\n        MINT_TYPEHASH,\\n        signature,\\n        VALIDATOR_ROLE\\n      )\\n    );\\n  }\\n\\n  function redeem(\\n    RedeemParameters memory redeemMetaTx,\\n    Signature memory signature\\n  ) external override nonReentrant returns (uint256 feePaid) {\\n    feePaid = poolStorage.redeem(\\n      redeemMetaTx,\\n      SignatureVerificationParams(\\n        DOMAIN_SEPARATOR,\\n        REDEEM_TYPEHASH,\\n        signature,\\n        VALIDATOR_ROLE\\n      )\\n    );\\n  }\\n\\n  function exchange(\\n    ExchangeParameters memory exchangeMetaTx,\\n    Signature memory signature\\n  ) external override nonReentrant returns (uint256 feePaid) {\\n    feePaid = poolStorage.exchange(\\n      exchangeMetaTx,\\n      SignatureVerificationParams(\\n        DOMAIN_SEPARATOR,\\n        EXCHANGE_TYPEHASH,\\n        signature,\\n        VALIDATOR_ROLE\\n      )\\n    );\\n  }\\n\\n  function exchangeMint(\\n    IDerivative srcDerivative,\\n    IDerivative derivative,\\n    uint256 collateralAmount,\\n    uint256 numTokens\\n  ) external override nonReentrant {\\n    poolStorage.exchangeMint(\\n      srcDerivative,\\n      derivative,\\n      FixedPoint.Unsigned(collateralAmount),\\n      FixedPoint.Unsigned(numTokens)\\n    );\\n  }\\n\\n  function withdrawFromPool(uint256 collateralAmount)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n  {\\n    poolStorage.withdrawFromPool(FixedPoint.Unsigned(collateralAmount));\\n  }\\n\\n  function depositIntoDerivative(\\n    IDerivative derivative,\\n    uint256 collateralAmount\\n  ) external override onlyLiquidityProvider nonReentrant {\\n    poolStorage.depositIntoDerivative(\\n      derivative,\\n      FixedPoint.Unsigned(collateralAmount)\\n    );\\n  }\\n\\n  function slowWithdrawRequest(IDerivative derivative, uint256 collateralAmount)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n  {\\n    poolStorage.slowWithdrawRequest(\\n      derivative,\\n      FixedPoint.Unsigned(collateralAmount)\\n    );\\n  }\\n\\n  function slowWithdrawPassedRequest(IDerivative derivative)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n    returns (uint256 amountWithdrawn)\\n  {\\n    amountWithdrawn = poolStorage.slowWithdrawPassedRequest(derivative);\\n  }\\n\\n  function fastWithdraw(IDerivative derivative, uint256 collateralAmount)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n    returns (uint256 amountWithdrawn)\\n  {\\n    amountWithdrawn = poolStorage.fastWithdraw(\\n      derivative,\\n      FixedPoint.Unsigned(collateralAmount)\\n    );\\n  }\\n\\n  function emergencyShutdown(IDerivative derivative)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.emergencyShutdown(derivative);\\n  }\\n\\n  function settleEmergencyShutdown(IDerivative derivative)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 amountSettled)\\n  {\\n    amountSettled = poolStorage.settleEmergencyShutdown(\\n      derivative,\\n      LIQUIDITY_PROVIDER_ROLE\\n    );\\n  }\\n\\n  function setFeePercentage(uint256 _feePercentage)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setFeePercentage(FixedPoint.Unsigned(_feePercentage));\\n  }\\n\\n  function setFeeRecipients(\\n    address[] calldata _feeRecipients,\\n    uint32[] calldata _feeProportions\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.setFeeRecipients(_feeRecipients, _feeProportions);\\n  }\\n\\n  function setStartingCollateralization(uint256 startingCollateralRatio)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setStartingCollateralization(\\n      FixedPoint.Unsigned(startingCollateralRatio)\\n    );\\n  }\\n\\n  function addRoleInDerivative(\\n    IDerivative derivative,\\n    DerivativeRoles derivativeRole,\\n    address addressToAdd\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.addRoleInDerivative(derivative, derivativeRole, addressToAdd);\\n  }\\n\\n  function renounceRoleInDerivative(\\n    IDerivative derivative,\\n    DerivativeRoles derivativeRole\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.renounceRoleInDerivative(derivative, derivativeRole);\\n  }\\n\\n  function addRoleInSynthToken(\\n    IDerivative derivative,\\n    SynthTokenRoles synthTokenRole,\\n    address addressToAdd\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.addRoleInSynthToken(derivative, synthTokenRole, addressToAdd);\\n  }\\n\\n  function renounceRoleInSynthToken(\\n    IDerivative derivative,\\n    SynthTokenRoles synthTokenRole\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.renounceRoleInSynthToken(derivative, synthTokenRole);\\n  }\\n\\n  function setIsContractAllowed(bool isContractAllowed)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setIsContractAllowed(isContractAllowed);\\n  }\\n\\n  function synthereumFinder()\\n    external\\n    view\\n    override\\n    returns (ISynthereumFinder finder)\\n  {\\n    finder = poolStorage.finder;\\n  }\\n\\n  function version() external view override returns (uint8 poolVersion) {\\n    poolVersion = poolStorage.version;\\n  }\\n\\n  function collateralToken()\\n    external\\n    view\\n    override\\n    returns (IERC20 collateralCurrency)\\n  {\\n    collateralCurrency = poolStorage.collateralToken;\\n  }\\n\\n  function syntheticToken()\\n    external\\n    view\\n    override\\n    returns (IERC20 syntheticCurrency)\\n  {\\n    syntheticCurrency = poolStorage.syntheticToken;\\n  }\\n\\n  function getAllDerivatives()\\n    external\\n    view\\n    override\\n    returns (IDerivative[] memory)\\n  {\\n    EnumerableSet.AddressSet storage derivativesSet = poolStorage.derivatives;\\n    uint256 numberOfDerivatives = derivativesSet.length();\\n    IDerivative[] memory derivatives = new IDerivative[](numberOfDerivatives);\\n    for (uint256 j = 0; j < numberOfDerivatives; j++) {\\n      derivatives[j] = (IDerivative(derivativesSet.at(j)));\\n    }\\n    return derivatives;\\n  }\\n\\n  function isDerivativeAdmitted(IDerivative derivative)\\n    external\\n    view\\n    override\\n    returns (bool isAdmitted)\\n  {\\n    isAdmitted = poolStorage.derivatives.contains(address(derivative));\\n  }\\n\\n  function getStartingCollateralization()\\n    external\\n    view\\n    override\\n    returns (uint256 startingCollateralRatio)\\n  {\\n    startingCollateralRatio = poolStorage.startingCollateralization.rawValue;\\n  }\\n\\n  function syntheticTokenSymbol()\\n    external\\n    view\\n    override\\n    returns (string memory symbol)\\n  {\\n    symbol = IStandardERC20(address(poolStorage.syntheticToken)).symbol();\\n  }\\n\\n  function isContractAllowed() external view override returns (bool isAllowed) {\\n    isAllowed = poolStorage.isContractAllowed;\\n  }\\n\\n  function getFeeInfo() external view override returns (Fee memory fee) {\\n    fee = poolStorage.fee;\\n  }\\n\\n  function getUserNonce(address user)\\n    external\\n    view\\n    override\\n    returns (uint256 nonce)\\n  {\\n    nonce = poolStorage.nonces[user];\\n  }\\n\\n  function calculateFee(uint256 collateralAmount)\\n    external\\n    view\\n    override\\n    returns (uint256 fee)\\n  {\\n    fee = FixedPoint\\n      .Unsigned(collateralAmount)\\n      .mul(poolStorage.fee.feePercentage)\\n      .rawValue;\\n  }\\n\\n  function setFee(Fee memory _fee) public override onlyMaintainer nonReentrant {\\n    poolStorage.setFeePercentage(_fee.feePercentage);\\n    poolStorage.setFeeRecipients(_fee.feeRecipients, _fee.feeProportions);\\n  }\\n\\n  function getChainID() private pure returns (uint256) {\\n    uint256 id;\\n    assembly {\\n      id := chainid()\\n    }\\n    return id;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/PoolCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {ISynthereumPool} from './interfaces/IPool.sol';\\nimport {SynthereumPool} from './Pool.sol';\\nimport '../../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\n\\ncontract SynthereumPoolCreator is Lockable {\\n  function createPool(\\n    IDerivative derivative,\\n    ISynthereumFinder finder,\\n    uint8 version,\\n    ISynthereumPool.Roles memory roles,\\n    bool isContractAllowed,\\n    uint256 startingCollateralization,\\n    ISynthereumPool.Fee memory fee\\n  ) public virtual nonReentrant returns (SynthereumPool poolDeployed) {\\n    poolDeployed = new SynthereumPool(\\n      derivative,\\n      finder,\\n      version,\\n      roles,\\n      isContractAllowed,\\n      startingCollateralization,\\n      fee\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/interfaces/IPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumPool} from './IPool.sol';\\nimport {ISynthereumFinder} from '../../../versioning/interfaces/IFinder.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\nimport {\\n  FixedPoint\\n} from '../../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\n\\ninterface ISynthereumPoolStorage {\\n  struct Storage {\\n    ISynthereumFinder finder;\\n    uint8 version;\\n    IERC20 collateralToken;\\n    IERC20 syntheticToken;\\n    bool isContractAllowed;\\n    EnumerableSet.AddressSet derivatives;\\n    FixedPoint.Unsigned startingCollateralization;\\n    ISynthereumPool.Fee fee;\\n    uint256 totalFeeProportions;\\n    mapping(address => uint256) nonces;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary Strings {\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0';\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    uint256 index = digits - 1;\\n    temp = value;\\n    while (temp != 0) {\\n      buffer[index--] = bytes1(uint8(48 + (temp % 10)));\\n      temp /= 10;\\n    }\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/PoolLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumPool} from './interfaces/IPool.sol';\\nimport {ISynthereumPoolStorage} from './interfaces/IPoolStorage.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {IRole} from './interfaces/IRole.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumPoolRegistry\\n} from '../../versioning/interfaces/IPoolRegistry.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {\\n  SafeERC20\\n} from '../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\n\\nlibrary SynthereumPoolLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SynthereumPoolLib for ISynthereumPoolStorage.Storage;\\n  using SynthereumPoolLib for IDerivative;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  event Mint(\\n    address indexed account,\\n    address indexed pool,\\n    uint256 collateralSent,\\n    uint256 numTokensReceived,\\n    uint256 feePaid\\n  );\\n\\n  event Redeem(\\n    address indexed account,\\n    address indexed pool,\\n    uint256 numTokensSent,\\n    uint256 collateralReceived,\\n    uint256 feePaid\\n  );\\n\\n  event Exchange(\\n    address indexed account,\\n    address indexed sourcePool,\\n    address indexed destPool,\\n    uint256 numTokensSent,\\n    uint256 destNumTokensReceived,\\n    uint256 feePaid\\n  );\\n\\n  event Settlement(\\n    address indexed account,\\n    address indexed pool,\\n    uint256 numTokens,\\n    uint256 collateralSettled\\n  );\\n\\n  event SetFeePercentage(uint256 feePercentage);\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  event AddDerivative(address indexed pool, address indexed derivative);\\n  event RemoveDerivative(address indexed pool, address indexed derivative);\\n\\n  modifier checkDerivative(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative\\n  ) {\\n    require(self.derivatives.contains(address(derivative)), 'Wrong derivative');\\n    _;\\n  }\\n\\n  modifier checkIsSenderContract(ISynthereumPoolStorage.Storage storage self) {\\n    if (!self.isContractAllowed) {\\n      require(tx.origin == msg.sender, 'Account must be an EOA');\\n    }\\n    _;\\n  }\\n\\n  function initialize(\\n    ISynthereumPoolStorage.Storage storage self,\\n    uint8 _version,\\n    ISynthereumFinder _finder,\\n    IDerivative _derivative,\\n    FixedPoint.Unsigned memory _startingCollateralization,\\n    bool _isContractAllowed\\n  ) external {\\n    self.derivatives.add(address(_derivative));\\n    emit AddDerivative(address(this), address(_derivative));\\n    self.version = _version;\\n    self.finder = _finder;\\n    self.startingCollateralization = _startingCollateralization;\\n    self.isContractAllowed = _isContractAllowed;\\n    self.collateralToken = getDerivativeCollateral(_derivative);\\n    self.syntheticToken = _derivative.tokenCurrency();\\n  }\\n\\n  function addDerivative(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative\\n  ) external {\\n    require(\\n      self.collateralToken == getDerivativeCollateral(derivative),\\n      'Wrong collateral of the new derivative'\\n    );\\n    require(\\n      self.syntheticToken == derivative.tokenCurrency(),\\n      'Wrong synthetic token'\\n    );\\n    require(\\n      self.derivatives.add(address(derivative)),\\n      'Derivative has already been included'\\n    );\\n    emit AddDerivative(address(this), address(derivative));\\n  }\\n\\n  function removeDerivative(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative\\n  ) external {\\n    require(\\n      self.derivatives.remove(address(derivative)),\\n      'Derivative not included'\\n    );\\n    emit RemoveDerivative(address(this), address(derivative));\\n  }\\n\\n  function mint(\\n    ISynthereumPoolStorage.Storage storage self,\\n    ISynthereumPool.MintParameters memory mintMetaTx,\\n    ISynthereumPool.SignatureVerificationParams\\n      memory signatureVerificationParams\\n  ) external checkIsSenderContract(self) returns (uint256 feePaid) {\\n    bytes32 digest =\\n      generateMintDigest(\\n        mintMetaTx,\\n        signatureVerificationParams.domain_separator,\\n        signatureVerificationParams.typeHash\\n      );\\n    checkSignature(\\n      signatureVerificationParams.validator_role,\\n      digest,\\n      signatureVerificationParams.signature\\n    );\\n    self.checkMetaTxParams(\\n      mintMetaTx.sender,\\n      mintMetaTx.derivativeAddr,\\n      mintMetaTx.feePercentage,\\n      mintMetaTx.nonce,\\n      mintMetaTx.expiration\\n    );\\n\\n    FixedPoint.Unsigned memory collateralAmount =\\n      FixedPoint.Unsigned(mintMetaTx.collateralAmount);\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(mintMetaTx.numTokens);\\n    IDerivative derivative = IDerivative(mintMetaTx.derivativeAddr);\\n    FixedPoint.Unsigned memory globalCollateralization =\\n      derivative.getGlobalCollateralizationRatio();\\n\\n    FixedPoint.Unsigned memory targetCollateralization =\\n      globalCollateralization.isGreaterThan(0)\\n        ? globalCollateralization\\n        : self.startingCollateralization;\\n\\n    require(\\n      self.checkCollateralizationRatio(\\n        targetCollateralization,\\n        collateralAmount,\\n        numTokens\\n      ),\\n      'Insufficient collateral available from Liquidity Provider'\\n    );\\n\\n    FixedPoint.Unsigned memory feeTotal =\\n      collateralAmount.mul(self.fee.feePercentage);\\n\\n    self.pullCollateral(mintMetaTx.sender, collateralAmount.add(feeTotal));\\n\\n    self.mintSynTokens(\\n      derivative,\\n      numTokens.mulCeil(targetCollateralization),\\n      numTokens\\n    );\\n\\n    self.transferSynTokens(mintMetaTx.sender, numTokens);\\n\\n    self.sendFee(feeTotal);\\n\\n    feePaid = feeTotal.rawValue;\\n\\n    emit Mint(\\n      mintMetaTx.sender,\\n      address(this),\\n      collateralAmount.add(feeTotal).rawValue,\\n      numTokens.rawValue,\\n      feePaid\\n    );\\n  }\\n\\n  function redeem(\\n    ISynthereumPoolStorage.Storage storage self,\\n    ISynthereumPool.RedeemParameters memory redeemMetaTx,\\n    ISynthereumPool.SignatureVerificationParams\\n      memory signatureVerificationParams\\n  ) external checkIsSenderContract(self) returns (uint256 feePaid) {\\n    bytes32 digest =\\n      generateRedeemDigest(\\n        redeemMetaTx,\\n        signatureVerificationParams.domain_separator,\\n        signatureVerificationParams.typeHash\\n      );\\n    checkSignature(\\n      signatureVerificationParams.validator_role,\\n      digest,\\n      signatureVerificationParams.signature\\n    );\\n    self.checkMetaTxParams(\\n      redeemMetaTx.sender,\\n      redeemMetaTx.derivativeAddr,\\n      redeemMetaTx.feePercentage,\\n      redeemMetaTx.nonce,\\n      redeemMetaTx.expiration\\n    );\\n    FixedPoint.Unsigned memory collateralAmount =\\n      FixedPoint.Unsigned(redeemMetaTx.collateralAmount);\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(redeemMetaTx.numTokens);\\n    IDerivative derivative = IDerivative(redeemMetaTx.derivativeAddr);\\n\\n    FixedPoint.Unsigned memory amountWithdrawn =\\n      redeemForCollateral(redeemMetaTx.sender, derivative, numTokens);\\n    require(\\n      amountWithdrawn.isGreaterThan(collateralAmount),\\n      'Collateral amount bigger than collateral in the derivative'\\n    );\\n\\n    FixedPoint.Unsigned memory feeTotal =\\n      collateralAmount.mul(self.fee.feePercentage);\\n\\n    uint256 netReceivedCollateral = (collateralAmount.sub(feeTotal)).rawValue;\\n\\n    self.collateralToken.safeTransfer(\\n      redeemMetaTx.sender,\\n      netReceivedCollateral\\n    );\\n\\n    self.sendFee(feeTotal);\\n\\n    feePaid = feeTotal.rawValue;\\n\\n    emit Redeem(\\n      redeemMetaTx.sender,\\n      address(this),\\n      numTokens.rawValue,\\n      netReceivedCollateral,\\n      feePaid\\n    );\\n  }\\n\\n  function exchange(\\n    ISynthereumPoolStorage.Storage storage self,\\n    ISynthereumPool.ExchangeParameters memory exchangeMetaTx,\\n    ISynthereumPool.SignatureVerificationParams\\n      memory signatureVerificationParams\\n  ) external checkIsSenderContract(self) returns (uint256 feePaid) {\\n    {\\n      bytes32 digest =\\n        generateExchangeDigest(\\n          exchangeMetaTx,\\n          signatureVerificationParams.domain_separator,\\n          signatureVerificationParams.typeHash\\n        );\\n      checkSignature(\\n        signatureVerificationParams.validator_role,\\n        digest,\\n        signatureVerificationParams.signature\\n      );\\n    }\\n    self.checkMetaTxParams(\\n      exchangeMetaTx.sender,\\n      exchangeMetaTx.derivativeAddr,\\n      exchangeMetaTx.feePercentage,\\n      exchangeMetaTx.nonce,\\n      exchangeMetaTx.expiration\\n    );\\n    FixedPoint.Unsigned memory collateralAmount =\\n      FixedPoint.Unsigned(exchangeMetaTx.collateralAmount);\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(exchangeMetaTx.numTokens);\\n    IDerivative derivative = IDerivative(exchangeMetaTx.derivativeAddr);\\n    IDerivative destDerivative = IDerivative(exchangeMetaTx.destDerivativeAddr);\\n\\n    FixedPoint.Unsigned memory amountWithdrawn =\\n      redeemForCollateral(exchangeMetaTx.sender, derivative, numTokens);\\n    self.checkPool(\\n      ISynthereumPool(exchangeMetaTx.destPoolAddr),\\n      destDerivative\\n    );\\n    require(\\n      amountWithdrawn.isGreaterThan(collateralAmount),\\n      'Collateral amount bigger than collateral in the derivative'\\n    );\\n\\n    FixedPoint.Unsigned memory feeTotal =\\n      collateralAmount.mul(self.fee.feePercentage);\\n\\n    self.sendFee(feeTotal);\\n\\n    FixedPoint.Unsigned memory destinationCollateral =\\n      amountWithdrawn.sub(feeTotal);\\n\\n    self.collateralToken.safeApprove(\\n      exchangeMetaTx.destPoolAddr,\\n      destinationCollateral.rawValue\\n    );\\n\\n    ISynthereumPool(exchangeMetaTx.destPoolAddr).exchangeMint(\\n      derivative,\\n      destDerivative,\\n      destinationCollateral.rawValue,\\n      exchangeMetaTx.destNumTokens\\n    );\\n\\n    destDerivative.tokenCurrency().safeTransfer(\\n      exchangeMetaTx.sender,\\n      exchangeMetaTx.destNumTokens\\n    );\\n\\n    feePaid = feeTotal.rawValue;\\n\\n    emit Exchange(\\n      exchangeMetaTx.sender,\\n      address(this),\\n      exchangeMetaTx.destPoolAddr,\\n      numTokens.rawValue,\\n      exchangeMetaTx.destNumTokens,\\n      feePaid\\n    );\\n  }\\n\\n  function exchangeMint(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative srcDerivative,\\n    IDerivative derivative,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) external {\\n    self.checkPool(ISynthereumPool(msg.sender), srcDerivative);\\n    FixedPoint.Unsigned memory globalCollateralization =\\n      derivative.getGlobalCollateralizationRatio();\\n\\n    FixedPoint.Unsigned memory targetCollateralization =\\n      globalCollateralization.isGreaterThan(0)\\n        ? globalCollateralization\\n        : self.startingCollateralization;\\n\\n    require(\\n      self.checkCollateralizationRatio(\\n        targetCollateralization,\\n        collateralAmount,\\n        numTokens\\n      ),\\n      'Insufficient collateral available from Liquidity Provider'\\n    );\\n\\n    self.pullCollateral(msg.sender, collateralAmount);\\n\\n    self.mintSynTokens(\\n      derivative,\\n      numTokens.mulCeil(targetCollateralization),\\n      numTokens\\n    );\\n\\n    self.transferSynTokens(msg.sender, numTokens);\\n  }\\n\\n  function withdrawFromPool(\\n    ISynthereumPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) external {\\n    self.collateralToken.safeTransfer(msg.sender, collateralAmount.rawValue);\\n  }\\n\\n  function depositIntoDerivative(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) external checkDerivative(self, derivative) {\\n    self.collateralToken.safeApprove(\\n      address(derivative),\\n      collateralAmount.rawValue\\n    );\\n    derivative.deposit(collateralAmount);\\n  }\\n\\n  function slowWithdrawRequest(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) external checkDerivative(self, derivative) {\\n    derivative.requestWithdrawal(collateralAmount);\\n  }\\n\\n  function slowWithdrawPassedRequest(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative\\n  )\\n    external\\n    checkDerivative(self, derivative)\\n    returns (uint256 amountWithdrawn)\\n  {\\n    FixedPoint.Unsigned memory totalAmountWithdrawn =\\n      derivative.withdrawPassedRequest();\\n    amountWithdrawn = liquidateWithdrawal(\\n      self,\\n      totalAmountWithdrawn,\\n      msg.sender\\n    );\\n  }\\n\\n  function fastWithdraw(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    FixedPoint.Unsigned memory collateralAmount\\n  )\\n    external\\n    checkDerivative(self, derivative)\\n    returns (uint256 amountWithdrawn)\\n  {\\n    FixedPoint.Unsigned memory totalAmountWithdrawn =\\n      derivative.withdraw(collateralAmount);\\n    amountWithdrawn = liquidateWithdrawal(\\n      self,\\n      totalAmountWithdrawn,\\n      msg.sender\\n    );\\n  }\\n\\n  function emergencyShutdown(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative\\n  ) external checkDerivative(self, derivative) {\\n    derivative.emergencyShutdown();\\n  }\\n\\n  function settleEmergencyShutdown(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    bytes32 liquidity_provider_role\\n  ) external returns (uint256 amountSettled) {\\n    IERC20 tokenCurrency = self.syntheticToken;\\n\\n    IERC20 collateralToken = self.collateralToken;\\n\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\\n\\n    bool isLiquidityProvider =\\n      IRole(address(this)).hasRole(liquidity_provider_role, msg.sender);\\n\\n    require(\\n      numTokens.isGreaterThan(0) || isLiquidityProvider,\\n      'Account has nothing to settle'\\n    );\\n\\n    if (numTokens.isGreaterThan(0)) {\\n      tokenCurrency.safeTransferFrom(\\n        msg.sender,\\n        address(this),\\n        numTokens.rawValue\\n      );\\n\\n      tokenCurrency.safeApprove(address(derivative), numTokens.rawValue);\\n    }\\n\\n    derivative.settleEmergencyShutdown();\\n\\n    FixedPoint.Unsigned memory totalToRedeem;\\n\\n    if (isLiquidityProvider) {\\n      totalToRedeem = FixedPoint.Unsigned(\\n        collateralToken.balanceOf(address(this))\\n      );\\n    } else {\\n      FixedPoint.Unsigned memory dueCollateral =\\n        numTokens.mul(derivative.emergencyShutdownPrice());\\n\\n      totalToRedeem = FixedPoint.min(\\n        dueCollateral,\\n        FixedPoint.Unsigned(collateralToken.balanceOf(address(this)))\\n      );\\n    }\\n    amountSettled = totalToRedeem.rawValue;\\n\\n    collateralToken.safeTransfer(msg.sender, amountSettled);\\n\\n    emit Settlement(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue,\\n      amountSettled\\n    );\\n  }\\n\\n  function setFeePercentage(\\n    ISynthereumPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory _feePercentage\\n  ) external {\\n    require(\\n      _feePercentage.rawValue < 10**(18),\\n      'Fee Percentage must be less than 100%'\\n    );\\n    self.fee.feePercentage = _feePercentage;\\n    emit SetFeePercentage(_feePercentage.rawValue);\\n  }\\n\\n  function setFeeRecipients(\\n    ISynthereumPoolStorage.Storage storage self,\\n    address[] calldata _feeRecipients,\\n    uint32[] calldata _feeProportions\\n  ) external {\\n    require(\\n      _feeRecipients.length == _feeProportions.length,\\n      'Fee recipients and fee proportions do not match'\\n    );\\n    uint256 totalActualFeeProportions;\\n\\n    for (uint256 i = 0; i < _feeProportions.length; i++) {\\n      totalActualFeeProportions += _feeProportions[i];\\n    }\\n    self.fee.feeRecipients = _feeRecipients;\\n    self.fee.feeProportions = _feeProportions;\\n    self.totalFeeProportions = totalActualFeeProportions;\\n    emit SetFeeRecipients(_feeRecipients, _feeProportions);\\n  }\\n\\n  function setStartingCollateralization(\\n    ISynthereumPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory startingCollateralRatio\\n  ) external {\\n    self.startingCollateralization = startingCollateralRatio;\\n  }\\n\\n  function addRoleInDerivative(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    ISynthereumPool.DerivativeRoles derivativeRole,\\n    address addressToAdd\\n  ) external checkDerivative(self, derivative) {\\n    if (derivativeRole == ISynthereumPool.DerivativeRoles.ADMIN) {\\n      derivative.addAdmin(addressToAdd);\\n    } else {\\n      ISynthereumPool pool = ISynthereumPool(addressToAdd);\\n      IERC20 collateralToken = self.collateralToken;\\n      require(\\n        collateralToken == pool.collateralToken(),\\n        'Collateral tokens do not match'\\n      );\\n      require(\\n        self.syntheticToken == pool.syntheticToken(),\\n        'Synthetic tokens do not match'\\n      );\\n      ISynthereumFinder finder = self.finder;\\n      require(finder == pool.synthereumFinder(), 'Finders do not match');\\n      ISynthereumPoolRegistry poolRegister =\\n        ISynthereumPoolRegistry(\\n          finder.getImplementationAddress(SynthereumInterfaces.PoolRegistry)\\n        );\\n      poolRegister.isPoolDeployed(\\n        pool.syntheticTokenSymbol(),\\n        collateralToken,\\n        pool.version(),\\n        address(pool)\\n      );\\n      if (derivativeRole == ISynthereumPool.DerivativeRoles.POOL) {\\n        derivative.addPool(addressToAdd);\\n      } else if (\\n        derivativeRole == ISynthereumPool.DerivativeRoles.ADMIN_AND_POOL\\n      ) {\\n        derivative.addAdminAndPool(addressToAdd);\\n      }\\n    }\\n  }\\n\\n  function renounceRoleInDerivative(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    ISynthereumPool.DerivativeRoles derivativeRole\\n  ) external checkDerivative(self, derivative) {\\n    if (derivativeRole == ISynthereumPool.DerivativeRoles.ADMIN) {\\n      derivative.renounceAdmin();\\n    } else if (derivativeRole == ISynthereumPool.DerivativeRoles.POOL) {\\n      derivative.renouncePool();\\n    } else if (\\n      derivativeRole == ISynthereumPool.DerivativeRoles.ADMIN_AND_POOL\\n    ) {\\n      derivative.renounceAdminAndPool();\\n    }\\n  }\\n\\n  function addRoleInSynthToken(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    ISynthereumPool.SynthTokenRoles synthTokenRole,\\n    address addressToAdd\\n  ) external checkDerivative(self, derivative) {\\n    if (synthTokenRole == ISynthereumPool.SynthTokenRoles.ADMIN) {\\n      derivative.addSyntheticTokenAdmin(addressToAdd);\\n    } else {\\n      require(\\n        self.syntheticToken == IDerivative(addressToAdd).tokenCurrency(),\\n        'Synthetic tokens do not match'\\n      );\\n      if (synthTokenRole == ISynthereumPool.SynthTokenRoles.MINTER) {\\n        derivative.addSyntheticTokenMinter(addressToAdd);\\n      } else if (synthTokenRole == ISynthereumPool.SynthTokenRoles.BURNER) {\\n        derivative.addSyntheticTokenBurner(addressToAdd);\\n      } else if (\\n        synthTokenRole ==\\n        ISynthereumPool.SynthTokenRoles.ADMIN_AND_MINTER_AND_BURNER\\n      ) {\\n        derivative.addSyntheticTokenAdminAndMinterAndBurner(addressToAdd);\\n      }\\n    }\\n  }\\n\\n  function renounceRoleInSynthToken(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    ISynthereumPool.SynthTokenRoles synthTokenRole\\n  ) external checkDerivative(self, derivative) {\\n    if (synthTokenRole == ISynthereumPool.SynthTokenRoles.ADMIN) {\\n      derivative.renounceSyntheticTokenAdmin();\\n    } else if (synthTokenRole == ISynthereumPool.SynthTokenRoles.MINTER) {\\n      derivative.renounceSyntheticTokenMinter();\\n    } else if (synthTokenRole == ISynthereumPool.SynthTokenRoles.BURNER) {\\n      derivative.renounceSyntheticTokenBurner();\\n    } else if (\\n      synthTokenRole ==\\n      ISynthereumPool.SynthTokenRoles.ADMIN_AND_MINTER_AND_BURNER\\n    ) {\\n      derivative.renounceSyntheticTokenAdminAndMinterAndBurner();\\n    }\\n  }\\n\\n  function setIsContractAllowed(\\n    ISynthereumPoolStorage.Storage storage self,\\n    bool isContractAllowed\\n  ) external {\\n    require(\\n      self.isContractAllowed != isContractAllowed,\\n      'Contract flag already set'\\n    );\\n    self.isContractAllowed = isContractAllowed;\\n  }\\n\\n  function checkMetaTxParams(\\n    ISynthereumPoolStorage.Storage storage self,\\n    address sender,\\n    address derivativeAddr,\\n    uint256 feePercentage,\\n    uint256 nonce,\\n    uint256 expiration\\n  ) internal checkDerivative(self, IDerivative(derivativeAddr)) {\\n    require(sender == msg.sender, 'Wrong user account');\\n    require(now <= expiration, 'Meta-signature expired');\\n    require(\\n      feePercentage == self.fee.feePercentage.rawValue,\\n      'Wrong fee percentage'\\n    );\\n    require(nonce == self.nonces[sender]++, 'Invalid nonce');\\n  }\\n\\n  function pullCollateral(\\n    ISynthereumPoolStorage.Storage storage self,\\n    address from,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    self.collateralToken.safeTransferFrom(\\n      from,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n  }\\n\\n  function mintSynTokens(\\n    ISynthereumPoolStorage.Storage storage self,\\n    IDerivative derivative,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    self.collateralToken.safeApprove(\\n      address(derivative),\\n      collateralAmount.rawValue\\n    );\\n    derivative.create(collateralAmount, numTokens);\\n  }\\n\\n  function transferSynTokens(\\n    ISynthereumPoolStorage.Storage storage self,\\n    address recipient,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    self.syntheticToken.safeTransfer(recipient, numTokens.rawValue);\\n  }\\n\\n  function redeemForCollateral(\\n    address tokenHolder,\\n    IDerivative derivative,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(numTokens.isGreaterThan(0), 'Number of tokens to redeem is 0');\\n\\n    IERC20 tokenCurrency = derivative.positionManagerData().tokenCurrency;\\n    require(\\n      tokenCurrency.balanceOf(tokenHolder) >= numTokens.rawValue,\\n      'Token balance less than token to redeem'\\n    );\\n\\n    tokenCurrency.safeTransferFrom(\\n      tokenHolder,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n\\n    tokenCurrency.safeApprove(address(derivative), numTokens.rawValue);\\n\\n    amountWithdrawn = derivative.redeem(numTokens);\\n  }\\n\\n  function liquidateWithdrawal(\\n    ISynthereumPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    address recipient\\n  ) internal returns (uint256 amountWithdrawn) {\\n    amountWithdrawn = collateralAmount.rawValue;\\n    self.collateralToken.safeTransfer(recipient, amountWithdrawn);\\n  }\\n\\n  function sendFee(\\n    ISynthereumPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory _feeAmount\\n  ) internal {\\n    for (uint256 i = 0; i < self.fee.feeRecipients.length; i++) {\\n      self.collateralToken.safeTransfer(\\n        self.fee.feeRecipients[i],\\n        _feeAmount\\n          .mul(self.fee.feeProportions[i])\\n          .div(self.totalFeeProportions)\\n          .rawValue\\n      );\\n    }\\n  }\\n\\n  function getDerivativeCollateral(IDerivative derivative)\\n    internal\\n    view\\n    returns (IERC20 collateral)\\n  {\\n    collateral = derivative.collateralCurrency();\\n  }\\n\\n  function getGlobalCollateralizationRatio(IDerivative derivative)\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    FixedPoint.Unsigned memory totalTokensOutstanding =\\n      derivative.globalPositionData().totalTokensOutstanding;\\n    if (totalTokensOutstanding.isGreaterThan(0)) {\\n      return derivative.totalPositionCollateral().div(totalTokensOutstanding);\\n    } else {\\n      return FixedPoint.fromUnscaledUint(0);\\n    }\\n  }\\n\\n  function checkCollateralizationRatio(\\n    ISynthereumPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory globalCollateralization,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal view returns (bool) {\\n    FixedPoint.Unsigned memory newCollateralization =\\n      collateralAmount\\n        .add(FixedPoint.Unsigned(self.collateralToken.balanceOf(address(this))))\\n        .div(numTokens);\\n\\n    return newCollateralization.isGreaterThanOrEqual(globalCollateralization);\\n  }\\n\\n  function checkPool(\\n    ISynthereumPoolStorage.Storage storage self,\\n    ISynthereumPool poolToCheck,\\n    IDerivative derivativeToCheck\\n  ) internal view {\\n    require(\\n      poolToCheck.isDerivativeAdmitted(derivativeToCheck),\\n      'Wrong derivative'\\n    );\\n\\n    IERC20 collateralToken = self.collateralToken;\\n    require(\\n      collateralToken == poolToCheck.collateralToken(),\\n      'Collateral tokens do not match'\\n    );\\n    ISynthereumFinder finder = self.finder;\\n    require(finder == poolToCheck.synthereumFinder(), 'Finders do not match');\\n    ISynthereumPoolRegistry poolRegister =\\n      ISynthereumPoolRegistry(\\n        finder.getImplementationAddress(SynthereumInterfaces.PoolRegistry)\\n      );\\n    require(\\n      poolRegister.isPoolDeployed(\\n        poolToCheck.syntheticTokenSymbol(),\\n        collateralToken,\\n        poolToCheck.version(),\\n        address(poolToCheck)\\n      ),\\n      'Destination pool not registred'\\n    );\\n  }\\n\\n  function generateMintDigest(\\n    ISynthereumPool.MintParameters memory mintMetaTx,\\n    bytes32 domain_separator,\\n    bytes32 typeHash\\n  ) internal pure returns (bytes32 digest) {\\n    digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        domain_separator,\\n        keccak256(\\n          abi.encode(\\n            typeHash,\\n            mintMetaTx.sender,\\n            mintMetaTx.derivativeAddr,\\n            mintMetaTx.collateralAmount,\\n            mintMetaTx.numTokens,\\n            mintMetaTx.feePercentage,\\n            mintMetaTx.nonce,\\n            mintMetaTx.expiration\\n          )\\n        )\\n      )\\n    );\\n  }\\n\\n  function generateRedeemDigest(\\n    ISynthereumPool.RedeemParameters memory redeemMetaTx,\\n    bytes32 domain_separator,\\n    bytes32 typeHash\\n  ) internal pure returns (bytes32 digest) {\\n    digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        domain_separator,\\n        keccak256(\\n          abi.encode(\\n            typeHash,\\n            redeemMetaTx.sender,\\n            redeemMetaTx.derivativeAddr,\\n            redeemMetaTx.collateralAmount,\\n            redeemMetaTx.numTokens,\\n            redeemMetaTx.feePercentage,\\n            redeemMetaTx.nonce,\\n            redeemMetaTx.expiration\\n          )\\n        )\\n      )\\n    );\\n  }\\n\\n  function generateExchangeDigest(\\n    ISynthereumPool.ExchangeParameters memory exchangeMetaTx,\\n    bytes32 domain_separator,\\n    bytes32 typeHash\\n  ) internal pure returns (bytes32 digest) {\\n    digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        domain_separator,\\n        keccak256(\\n          abi.encode(\\n            typeHash,\\n            exchangeMetaTx.sender,\\n            exchangeMetaTx.derivativeAddr,\\n            exchangeMetaTx.destPoolAddr,\\n            exchangeMetaTx.destDerivativeAddr,\\n            exchangeMetaTx.numTokens,\\n            exchangeMetaTx.collateralAmount,\\n            exchangeMetaTx.destNumTokens,\\n            exchangeMetaTx.feePercentage,\\n            exchangeMetaTx.nonce,\\n            exchangeMetaTx.expiration\\n          )\\n        )\\n      )\\n    );\\n  }\\n\\n  function checkSignature(\\n    bytes32 validator_role,\\n    bytes32 digest,\\n    ISynthereumPool.Signature memory signature\\n  ) internal view {\\n    address signatureAddr =\\n      ecrecover(digest, signature.v, signature.r, signature.s);\\n    require(\\n      IRole(address(this)).hasRole(validator_role, signatureAddr),\\n      'Invalid meta-signature'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v1/interfaces/IRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface IRole {\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/test/ContractAllowed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumPool} from '../synthereum-pool/v1/interfaces/IPool.sol';\\nimport {IERC20} from '../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ncontract ContractAllowed {\\n  ISynthereumPool public pool;\\n  IERC20 public collateral;\\n\\n  constructor(address _pool, address _collateral) public {\\n    pool = ISynthereumPool(_pool);\\n    collateral = IERC20(_collateral);\\n  }\\n\\n  function mintInPool(\\n    ISynthereumPool.MintParameters memory mintParams,\\n    ISynthereumPool.Signature memory signature,\\n    uint256 approveAmount\\n  ) external {\\n    collateral.approve(address(pool), approveAmount);\\n    pool.mint(mintParams, signature);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v0/TICFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {SynthereumTICInterface} from './interfaces/ITIC.sol';\\nimport {SynthereumTIC} from './TIC.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {\\n  IDeploymentSignature\\n} from '../../versioning/interfaces/IDeploymentSignature.sol';\\nimport {TICCreator} from './TICCreator.sol';\\n\\ncontract SynthereumTICFactory is TICCreator, IDeploymentSignature {\\n  address public synthereumFinder;\\n\\n  bytes4 public override deploymentSignature;\\n\\n  constructor(address _synthereumFinder) public {\\n    synthereumFinder = _synthereumFinder;\\n    deploymentSignature = this.createTIC.selector;\\n  }\\n\\n  function createTIC(\\n    IDerivative derivative,\\n    ISynthereumFinder finder,\\n    uint8 version,\\n    SynthereumTICInterface.Roles memory roles,\\n    uint256 startingCollateralization,\\n    SynthereumTICInterface.Fee memory fee\\n  ) public override returns (SynthereumTIC poolDeployed) {\\n    address deployer =\\n      ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n        SynthereumInterfaces.Deployer\\n      );\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    poolDeployed = super.createTIC(\\n      derivative,\\n      finder,\\n      version,\\n      roles,\\n      startingCollateralization,\\n      fee\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/v0/TICCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {SynthereumTICInterface} from './interfaces/ITIC.sol';\\nimport {\\n  Lockable\\n} from '../../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\nimport {SynthereumTIC} from './TIC.sol';\\n\\ncontract TICCreator is Lockable {\\n  function createTIC(\\n    IDerivative derivative,\\n    ISynthereumFinder finder,\\n    uint8 version,\\n    SynthereumTICInterface.Roles memory roles,\\n    uint256 startingCollateralization,\\n    SynthereumTICInterface.Fee memory fee\\n  ) public virtual nonReentrant returns (SynthereumTIC poolDeployed) {\\n    poolDeployed = new SynthereumTIC(\\n      derivative,\\n      finder,\\n      version,\\n      roles,\\n      startingCollateralization,\\n      fee\\n    );\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/contracts/synthereum-pool/v1/PoolLib.sol\": {\r\n        \"SynthereumPoolLib\": \"0xdb026d6c3450f5f28f3a035e158e1b68afce8f9f\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"_derivative\",\"type\":\"address\"},{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"_finder\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_version\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"internalType\":\"struct ISynthereumPool.Roles\",\"name\":\"_roles\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_isContractAllowed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_startingCollateralization\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"feePercentage\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"feeProportions\",\"type\":\"uint32[]\"}],\"internalType\":\"struct ISynthereumPool.Fee\",\"name\":\"_fee\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"AddDerivative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sourcePool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokensSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destNumTokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokensSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"RemoveDerivative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"name\":\"SetFeePercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"feeRecipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"feeProportions\",\"type\":\"uint32[]\"}],\"name\":\"SetFeeRecipients\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralSettled\",\"type\":\"uint256\"}],\"name\":\"Settlement\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXCHANGE_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_PROVIDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REDEEM_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"addDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"enum ISynthereumPool.DerivativeRoles\",\"name\":\"derivativeRole\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addressToAdd\",\"type\":\"address\"}],\"name\":\"addRoleInDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"enum ISynthereumPool.SynthTokenRoles\",\"name\":\"synthTokenRole\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addressToAdd\",\"type\":\"address\"}],\"name\":\"addRoleInSynthToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralCurrency\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"depositIntoDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"emergencyShutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"derivativeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destPoolAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destDerivativeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destNumTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct ISynthereumPool.ExchangeParameters\",\"name\":\"exchangeMetaTx\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISynthereumPool.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"srcDerivative\",\"type\":\"address\"},{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"exchangeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"fastWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDerivatives\",\"outputs\":[{\"internalType\":\"contract IDerivative[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeInfo\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"feePercentage\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"feeProportions\",\"type\":\"uint32[]\"}],\"internalType\":\"struct ISynthereumPool.Fee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartingCollateralization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingCollateralRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isContractAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"isDerivativeAdmitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAdmitted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"derivativeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct ISynthereumPool.MintParameters\",\"name\":\"mintMetaTx\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISynthereumPool.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"derivativeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"internalType\":\"struct ISynthereumPool.RedeemParameters\",\"name\":\"redeemMetaTx\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISynthereumPool.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"removeDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"enum ISynthereumPool.DerivativeRoles\",\"name\":\"derivativeRole\",\"type\":\"uint8\"}],\"name\":\"renounceRoleInDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"enum ISynthereumPool.SynthTokenRoles\",\"name\":\"synthTokenRole\",\"type\":\"uint8\"}],\"name\":\"renounceRoleInSynthToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"feePercentage\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"feeProportions\",\"type\":\"uint32[]\"}],\"internalType\":\"struct ISynthereumPool.Fee\",\"name\":\"_fee\",\"type\":\"tuple\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_feeProportions\",\"type\":\"uint32[]\"}],\"name\":\"setFeeRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isContractAllowed\",\"type\":\"bool\"}],\"name\":\"setIsContractAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingCollateralRatio\",\"type\":\"uint256\"}],\"name\":\"setStartingCollateralization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"settleEmergencyShutdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountSettled\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"slowWithdrawPassedRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"slowWithdrawRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthereumFinder\",\"outputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"finder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syntheticToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"syntheticCurrency\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syntheticTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SynthereumPool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000048546bdd57d34cb110f011cdd1ccaae75ee17a70000000000000000000000000d451de78e297b496ee8a4f06dcf991c17580b4520000000000000000000000000000000000000000000000000000000000000002000000000000000000000000128c8e20dd4f2d8519dd605632660686ba35d21200000000000000000000000010d7c10a2f25ba6212968d8918eb687d589c6e0a00000000000000000000000085e0d7f67b909f1a815fbc8bb39ea76b8ba6994f000000000000000000000000cb3508a63176c8a2d24f1d048374e80befe8a8a20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018315c000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000071afd498d0000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000cc3528125499d168adfb5ef99895c98a7c430ed4000000000000000000000000535ac9f9b46e515a3af364434061181a504d5bfb000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000032","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}