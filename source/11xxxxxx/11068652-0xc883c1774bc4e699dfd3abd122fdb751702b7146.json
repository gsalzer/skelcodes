{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Governance.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport { Address } from \\u0027./Address.sol\\u0027;\\nimport {\\n  SafeMath as SafeMath256\\n} from \\u0027./SafeMath.sol\\u0027;\\n\\nimport { ICustodian } from \\u0027./Interfaces.sol\\u0027;\\nimport { Owned } from \\u0027./Owned.sol\\u0027;\\n\\n\\ncontract Governance is Owned {\\n  using SafeMath256 for uint256;\\n\\n  /**\\n   * @notice Emitted when admin initiates upgrade of `Exchange` contract address on `Custodian` via\\n   * `initiateExchangeUpgrade`\\n   */\\n  event ExchangeUpgradeInitiated(\\n    address oldExchange,\\n    address newExchange,\\n    uint256 blockThreshold\\n  );\\n  /**\\n   * @notice Emitted when admin cancels previously started `Exchange` upgrade with `cancelExchangeUpgrade`\\n   */\\n  event ExchangeUpgradeCanceled(address oldExchange, address newExchange);\\n  /**\\n   * @notice Emitted when admin finalizes `Exchange` upgrade via `finalizeExchangeUpgrade`\\n   */\\n  event ExchangeUpgradeFinalized(address oldExchange, address newExchange);\\n  /**\\n   * @notice Emitted when admin initiates upgrade of `Governance` contract address on `Custodian` via\\n   * `initiateGovernanceUpgrade`\\n   */\\n  event GovernanceUpgradeInitiated(\\n    address oldGovernance,\\n    address newGovernance,\\n    uint256 blockThreshold\\n  );\\n  /**\\n   * @notice Emitted when admin cancels previously started `Governance` upgrade with `cancelGovernanceUpgrade`\\n   */\\n  event GovernanceUpgradeCanceled(address oldGovernance, address newGovernance);\\n  /**\\n   * @notice Emitted when admin finalizes `Governance` upgrade via `finalizeGovernanceUpgrade`, effectively replacing\\n   * this contract and rendering it non-functioning\\n   */\\n  event GovernanceUpgradeFinalized(\\n    address oldGovernance,\\n    address newGovernance\\n  );\\n\\n  // Internally used structs //\\n\\n  struct ContractUpgrade {\\n    bool exists;\\n    address newContract;\\n    uint256 blockThreshold;\\n  }\\n\\n  // Storage //\\n\\n  uint256 immutable _blockDelay;\\n  ICustodian _custodian;\\n  ContractUpgrade _currentExchangeUpgrade;\\n  ContractUpgrade _currentGovernanceUpgrade;\\n\\n  /**\\n   * @notice Instantiate a new `Governance` contract\\n   *\\n   * @dev Sets `owner` and `admin` to `msg.sender`. Sets the values for `_blockDelay` governing `Exchange`\\n   * and `Governance` upgrades. This value is immutable, and cannot be changed after construction\\n   *\\n   * @param blockDelay The minimum number of blocks that must be mined after initiating an `Exchange`\\n   * or `Governance` upgrade before the upgrade may be finalized\\n   */\\n  constructor(uint256 blockDelay) public Owned() {\\n    _blockDelay = blockDelay;\\n  }\\n\\n  /**\\n   * @notice Sets the address of the `Custodian` contract. The `Custodian` accepts `Exchange` and\\n   * `Governance` addresses in its constructor, after which they can only be changed by the\\n   * `Governance` contract itself. Therefore the `Custodian` must be deployed last and its address\\n   * set here on an existing `Governance` contract. This value is immutable once set and cannot be\\n   * changed again\\n   *\\n   * @param newCustodian The address of the `Custodian` contract deployed against this `Governance`\\n   * contract\\u0027s address\\n   */\\n  function setCustodian(ICustodian newCustodian) external onlyAdmin {\\n    require(_custodian == ICustodian(0x0), \\u0027Custodian can only be set once\\u0027);\\n    require(Address.isContract(address(newCustodian)), \\u0027Invalid address\\u0027);\\n\\n    _custodian = newCustodian;\\n  }\\n\\n  // Exchange upgrade //\\n\\n  /**\\n   * @notice Initiates `Exchange` contract upgrade proccess on `Custodian`. Once `blockDelay` has passed\\n   * the process can be finalized with `finalizeExchangeUpgrade`\\n   *\\n   * @param newExchange The address of the new `Exchange` contract\\n   */\\n  function initiateExchangeUpgrade(address newExchange) external onlyAdmin {\\n    require(Address.isContract(address(newExchange)), \\u0027Invalid address\\u0027);\\n    require(\\n      newExchange != _custodian.loadExchange(),\\n      \\u0027Must be different from current Exchange\\u0027\\n    );\\n    require(\\n      !_currentExchangeUpgrade.exists,\\n      \\u0027Exchange upgrade already in progress\\u0027\\n    );\\n\\n    _currentExchangeUpgrade = ContractUpgrade(\\n      true,\\n      newExchange,\\n      block.number.add(_blockDelay)\\n    );\\n\\n    emit ExchangeUpgradeInitiated(\\n      _custodian.loadExchange(),\\n      newExchange,\\n      _currentExchangeUpgrade.blockThreshold\\n    );\\n  }\\n\\n  /**\\n   * @notice Cancels an in-flight `Exchange` contract upgrade that has not yet been finalized\\n   */\\n  function cancelExchangeUpgrade() external onlyAdmin {\\n    require(_currentExchangeUpgrade.exists, \\u0027No Exchange upgrade in progress\\u0027);\\n\\n    address newExchange = _currentExchangeUpgrade.newContract;\\n    delete _currentExchangeUpgrade;\\n\\n    emit ExchangeUpgradeCanceled(_custodian.loadExchange(), newExchange);\\n  }\\n\\n  /**\\n   * @notice Finalizes the `Exchange` contract upgrade by changing the contract address on the `Custodian`\\n   * contract with `setExchange`. The number of blocks specified by `_blockDelay` must have passed since calling\\n   * `initiateExchangeUpgrade`\\n   *\\n   * @param newExchange The address of the new `Exchange` contract. Must equal the address provided to\\n   * `initiateExchangeUpgrade`\\n   */\\n  function finalizeExchangeUpgrade(address newExchange) external onlyAdmin {\\n    require(_currentExchangeUpgrade.exists, \\u0027No Exchange upgrade in progress\\u0027);\\n    require(\\n      _currentExchangeUpgrade.newContract == newExchange,\\n      \\u0027Address mismatch\\u0027\\n    );\\n    require(\\n      block.number \\u003e= _currentExchangeUpgrade.blockThreshold,\\n      \\u0027Block threshold not yet reached\\u0027\\n    );\\n\\n    address oldExchange = _custodian.loadExchange();\\n    _custodian.setExchange(newExchange);\\n    delete _currentExchangeUpgrade;\\n\\n    emit ExchangeUpgradeFinalized(oldExchange, newExchange);\\n  }\\n\\n  // Governance upgrade //\\n\\n  /**\\n   * @notice Initiates `Governance` contract upgrade proccess on `Custodian`. Once `blockDelay` has passed\\n   * the process can be finalized with `finalizeGovernanceUpgrade`\\n   *\\n   * @param newGovernance The address of the new `Governance` contract\\n   */\\n  function initiateGovernanceUpgrade(address newGovernance) external onlyAdmin {\\n    require(Address.isContract(address(newGovernance)), \\u0027Invalid address\\u0027);\\n    require(\\n      newGovernance != _custodian.loadGovernance(),\\n      \\u0027Must be different from current Governance\\u0027\\n    );\\n    require(\\n      !_currentGovernanceUpgrade.exists,\\n      \\u0027Governance upgrade already in progress\\u0027\\n    );\\n\\n    _currentGovernanceUpgrade = ContractUpgrade(\\n      true,\\n      newGovernance,\\n      block.number.add(_blockDelay)\\n    );\\n\\n    emit GovernanceUpgradeInitiated(\\n      _custodian.loadGovernance(),\\n      newGovernance,\\n      _currentGovernanceUpgrade.blockThreshold\\n    );\\n  }\\n\\n  /**\\n   * @notice Cancels an in-flight `Governance` contract upgrade that has not yet been finalized\\n   */\\n  function cancelGovernanceUpgrade() external onlyAdmin {\\n    require(\\n      _currentGovernanceUpgrade.exists,\\n      \\u0027No Governance upgrade in progress\\u0027\\n    );\\n\\n    address newGovernance = _currentGovernanceUpgrade.newContract;\\n    delete _currentGovernanceUpgrade;\\n\\n    emit GovernanceUpgradeCanceled(_custodian.loadGovernance(), newGovernance);\\n  }\\n\\n  /**\\n   * @notice Finalizes the `Governance` contract upgrade by changing the contract address on the `Custodian`\\n   * contract with `setGovernance`. The number of blocks specified by `_blockDelay` must have passed since calling\\n   * `initiateGovernanceUpgrade`.\\n   *\\n   * @dev After successfully calling this function, this contract will become useless since it is no\\n   * longer whitelisted in the `Custodian`\\n   *\\n   * @param newGovernance The address of the new `Governance` contract. Must equal the address provided to\\n   * `initiateGovernanceUpgrade`\\n   */\\n  function finalizeGovernanceUpgrade(address newGovernance) external onlyAdmin {\\n    require(\\n      _currentGovernanceUpgrade.exists,\\n      \\u0027No Governance upgrade in progress\\u0027\\n    );\\n    require(\\n      _currentGovernanceUpgrade.newContract == newGovernance,\\n      \\u0027Address mismatch\\u0027\\n    );\\n    require(\\n      block.number \\u003e= _currentGovernanceUpgrade.blockThreshold,\\n      \\u0027Block threshold not yet reached\\u0027\\n    );\\n\\n    address oldGovernance = _custodian.loadGovernance();\\n    _custodian.setGovernance(newGovernance);\\n    delete _currentGovernanceUpgrade;\\n\\n    emit GovernanceUpgradeFinalized(oldGovernance, newGovernance);\\n  }\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @notice Enums used in `Order` and `Withdrawal` structs\\n */\\ncontract Enums {\\n  enum OrderSelfTradePrevention {\\n    // Decrement and cancel\\n    dc,\\n    // Cancel oldest\\n    co,\\n    // Cancel newest\\n    cn,\\n    // Cancel both\\n    cb\\n  }\\n  enum OrderSide { Buy, Sell }\\n  enum OrderTimeInForce {\\n    // Good until cancelled\\n    gtc,\\n    // Good until time\\n    gtt,\\n    // Immediate or cancel\\n    ioc,\\n    // Fill or kill\\n    fok\\n  }\\n  enum OrderType {\\n    Market,\\n    Limit,\\n    LimitMaker,\\n    StopLoss,\\n    StopLossLimit,\\n    TakeProfit,\\n    TakeProfitLimit\\n  }\\n  enum WithdrawalType { BySymbol, ByAddress }\\n}\\n\\n\\n/**\\n * @notice Struct definitions\\n */\\ncontract Structs {\\n  /**\\n   * @notice Argument type for `Exchange.executeTrade` and `Signatures.getOrderWalletHash`\\n   */\\n  struct Order {\\n    // Not currently used but reserved for future use. Must be 1\\n    uint8 signatureHashVersion;\\n    // UUIDv1 unique to wallet\\n    uint128 nonce;\\n    // Wallet address that placed order and signed hash\\n    address walletAddress;\\n    // Type of order\\n    Enums.OrderType orderType;\\n    // Order side wallet is on\\n    Enums.OrderSide side;\\n    // Order quantity in base or quote asset terms depending on isQuantityInQuote flag\\n    uint64 quantityInPips;\\n    // Is quantityInPips in quote terms\\n    bool isQuantityInQuote;\\n    // For limit orders, price in decimal pips * 10^8 in quote terms\\n    uint64 limitPriceInPips;\\n    // For stop orders, stop loss or take profit price in decimal pips * 10^8 in quote terms\\n    uint64 stopPriceInPips;\\n    // Optional custom client order ID\\n    string clientOrderId;\\n    // TIF option specified by wallet for order\\n    Enums.OrderTimeInForce timeInForce;\\n    // STP behavior specified by wallet for order\\n    Enums.OrderSelfTradePrevention selfTradePrevention;\\n    // Cancellation time specified by wallet for GTT TIF order\\n    uint64 cancelAfter;\\n    // The ECDSA signature of the order hash as produced by Signatures.getOrderWalletHash\\n    bytes walletSignature;\\n  }\\n\\n  /**\\n   * @notice Return type for `Exchange.loadAssetBySymbol`, and `Exchange.loadAssetByAddress`; also\\n   * used internally by `AssetRegistry`\\n   */\\n  struct Asset {\\n    // Flag to distinguish from empty struct\\n    bool exists;\\n    // The asset\\u0027s address\\n    address assetAddress;\\n    // The asset\\u0027s symbol\\n    string symbol;\\n    // The asset\\u0027s decimal precision\\n    uint8 decimals;\\n    // Flag set when asset registration confirmed. Asset deposits, trades, or withdrawals only allowed if true\\n    bool isConfirmed;\\n    // Timestamp as ms since Unix epoch when isConfirmed was asserted\\n    uint64 confirmedTimestampInMs;\\n  }\\n\\n  /**\\n   * @notice Argument type for `Exchange.executeTrade` specifying execution parameters for matching orders\\n   */\\n  struct Trade {\\n    // Base asset symbol\\n    string baseAssetSymbol;\\n    // Quote asset symbol\\n    string quoteAssetSymbol;\\n    // Base asset address\\n    address baseAssetAddress;\\n    // Quote asset address\\n    address quoteAssetAddress;\\n    // Gross amount including fees of base asset executed\\n    uint64 grossBaseQuantityInPips;\\n    // Gross amount including fees of quote asset executed\\n    uint64 grossQuoteQuantityInPips;\\n    // Net amount of base asset received by buy side wallet after fees\\n    uint64 netBaseQuantityInPips;\\n    // Net amount of quote asset received by sell side wallet after fees\\n    uint64 netQuoteQuantityInPips;\\n    // Asset address for liquidity maker\\u0027s fee\\n    address makerFeeAssetAddress;\\n    // Asset address for liquidity taker\\u0027s fee\\n    address takerFeeAssetAddress;\\n    // Fee paid by liquidity maker\\n    uint64 makerFeeQuantityInPips;\\n    // Fee paid by liquidity taker\\n    uint64 takerFeeQuantityInPips;\\n    // Execution price of trade in decimal pips * 10^8 in quote terms\\n    uint64 priceInPips;\\n    // Which side of the order (buy or sell) the liquidity maker was on\\n    Enums.OrderSide makerSide;\\n  }\\n\\n  /**\\n   * @notice Argument type for `Exchange.withdraw` and `Signatures.getWithdrawalWalletHash`\\n   */\\n  struct Withdrawal {\\n    // Distinguishes between withdrawals by asset symbol or address\\n    Enums.WithdrawalType withdrawalType;\\n    // UUIDv1 unique to wallet\\n    uint128 nonce;\\n    // Address of wallet to which funds will be returned\\n    address payable walletAddress;\\n    // Asset symbol\\n    string assetSymbol;\\n    // Asset address\\n    address assetAddress; // Used when assetSymbol not specified\\n    // Withdrawal quantity\\n    uint64 quantityInPips;\\n    // Gas fee deducted from withdrawn quantity to cover dispatcher tx costs\\n    uint64 gasFeeInPips;\\n    // Not currently used but reserved for future use. Must be true\\n    bool autoDispatchEnabled;\\n    // The ECDSA signature of the withdrawal hash as produced by Signatures.getWithdrawalWalletHash\\n    bytes walletSignature;\\n  }\\n}\\n\\n\\n/**\\n * @notice Interface of the ERC20 standard as defined in the EIP, but with no return values for\\n * transfer and transferFrom. By asserting expected balance changes when calling these two methods\\n * we can safely ignore their return values. This allows support of non-compliant tokens that do not\\n * return a boolean. See https://github.com/ethereum/solidity/issues/4116\\n */\\ninterface IERC20 {\\n  /**\\n   * @notice Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external;\\n\\n  /**\\n   * @notice Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @notice Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @notice Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @notice Interface to Custodian contract. Used by Exchange and Governance contracts for internal\\n * delegate calls\\n */\\ninterface ICustodian {\\n  /**\\n   * @notice ETH can only be sent by the Exchange\\n   */\\n  receive() external payable;\\n\\n  /**\\n   * @notice Withdraw any asset and amount to a target wallet\\n   *\\n   * @dev No balance checking performed\\n   *\\n   * @param wallet The wallet to which assets will be returned\\n   * @param asset The address of the asset to withdraw (ETH or ERC-20 contract)\\n   * @param quantityInAssetUnits The quantity in asset units to withdraw\\n   */\\n  function withdraw(\\n    address payable wallet,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Exchange contract\\n   *\\n   * @return The address of the currently whitelisted Exchange contract\\n   */\\n  function loadExchange() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Exchange contract address\\n   *\\n   * @param newExchange The address of the new whitelisted Exchange contract\\n   */\\n  function setExchange(address newExchange) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Governance contract\\n   *\\n   * @return The address of the currently whitelisted Governance contract\\n   */\\n  function loadGovernance() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Governance contract address\\n   *\\n   * @param newGovernance The address of the new whitelisted Governance contract\\n   */\\n  function setGovernance(address newGovernance) external;\\n}\\n\\n\\n/**\\n * @notice Interface to Exchange contract. Provided only to document struct usage\\n */\\ninterface IExchange {\\n  /**\\n   * @notice Settles a trade between two orders submitted and matched off-chain\\n   *\\n   * @param buy A `Structs.Order` struct encoding the parameters of the buy-side order (receiving base, giving quote)\\n   * @param sell A `Structs.Order` struct encoding the parameters of the sell-side order (giving base, receiving quote)\\n   * @param trade A `Structs.Trade` struct encoding the parameters of this trade execution of the counterparty orders\\n   */\\n  function executeTrade(\\n    Structs.Order calldata buy,\\n    Structs.Order calldata sell,\\n    Structs.Trade calldata trade\\n  ) external;\\n\\n  /**\\n   * @notice Settles a user withdrawal submitted off-chain. Calls restricted to currently whitelisted Dispatcher wallet\\n   *\\n   * @param withdrawal A `Structs.Withdrawal` struct encoding the parameters of the withdrawal\\n   */\\n  function withdraw(Structs.Withdrawal calldata withdrawal) external;\\n}\\n\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\n\\n\\n/**\\n * @notice Mixin that provide separate owner and admin roles for RBAC\\n */\\nabstract contract Owned {\\n  address immutable _owner;\\n  address _admin;\\n\\n  modifier onlyOwner {\\n    require(msg.sender == _owner, \\u0027Caller must be owner\\u0027);\\n    _;\\n  }\\n  modifier onlyAdmin {\\n    require(msg.sender == _admin, \\u0027Caller must be admin\\u0027);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Sets both the owner and admin roles to the contract creator\\n   */\\n  constructor() public {\\n    _owner = msg.sender;\\n    _admin = msg.sender;\\n  }\\n\\n  /**\\n   * @notice Sets a new whitelisted admin wallet\\n   *\\n   * @param newAdmin The new whitelisted admin wallet. Must be different from the current one\\n   */\\n  function setAdmin(address newAdmin) external onlyOwner {\\n    require(newAdmin != address(0x0), \\u0027Invalid wallet address\\u0027);\\n    require(newAdmin != _admin, \\u0027Must be different from current admin\\u0027);\\n\\n    _admin = newAdmin;\\n  }\\n\\n  /**\\n   * @notice Clears the currently whitelisted admin wallet, effectively disabling any functions requiring\\n   * the admin role\\n   */\\n  function removeAdmin() external onlyOwner {\\n    _admin = address(0x0);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldExchange\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"ExchangeUpgradeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldExchange\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"ExchangeUpgradeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldExchange\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockThreshold\",\"type\":\"uint256\"}],\"name\":\"ExchangeUpgradeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceUpgradeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceUpgradeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockThreshold\",\"type\":\"uint256\"}],\"name\":\"GovernanceUpgradeInitiated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"cancelExchangeUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelGovernanceUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"finalizeExchangeUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"finalizeGovernanceUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"initiateExchangeUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"initiateGovernanceUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICustodian\",\"name\":\"newCustodian\",\"type\":\"address\"}],\"name\":\"setCustodian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"49","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000004380","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c6670eff6f32a673c6e53870d62be4210c4b0691a2c7c84b74fd60c8c33935c2"}]}