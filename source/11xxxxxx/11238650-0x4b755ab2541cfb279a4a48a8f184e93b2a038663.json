{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/BetToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\n\\nimport \\\"./BetToken/BetTokenHolder.sol\\\";\\nimport \\\"./BetToken/BetTokenRecipient.sol\\\";\\nimport \\\"./BetToken/BetTokenSender.sol\\\";\\n\\nabstract contract BetToken is BetTokenHolder, BetTokenSender, BetTokenRecipient {\\n    constructor (\\n        address tokenAddress\\n    ) public BetTokenHolder(tokenAddress) {}\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/BetToken/BetTokenHolder.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\ncontract BetTokenHolder {\\n    IERC777 token;\\n\\n    constructor (address tokenAddress) public {\\n        token = IERC777(tokenAddress);\\n    }\\n\\n    modifier isRightToken () {\\n        require(msg.sender == address(token), \\\"Not a valid token\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/BetToken/BetTokenRecipient.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\n\\nimport \\\"./BetTokenHolder.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/IERC1820Registry.sol\\\";\\n\\n\\nabstract contract BetTokenRecipient is BetTokenHolder, IERC777Recipient {\\n    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\\\"ERC777TokensRecipient\\\");\\n\\n    constructor () public {\\n        _erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\\n    }\\n\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override isRightToken {\\n        bet(from, amount, userData);\\n    }\\n\\n    function bet (address from, uint amount, bytes memory betData) internal virtual {}\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/BetToken/BetTokenSender.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\n\\nimport \\\"./BetTokenHolder.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC1820Implementer.sol\\\";\\n\\nabstract contract BetTokenSender is BetTokenHolder, IERC777Sender, ERC1820Implementer {\\n    bytes32 constant public TOKENS_SENDER_INTERFACE_HASH = keccak256(\\\"ERC777TokensSender\\\");\\n\\n    constructor () public {\\n        _registerInterfaceForAddress(TOKENS_SENDER_INTERFACE_HASH, address(this));\\n    }\\n\\n    function tokensToSend(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override isRightToken {}\\n\\n    function send (address to, uint amount) internal {\\n        token.send(to, amount, \\\"\\\");\\n    }\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/Deathbet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\n\\nimport \\\"./BetToken.sol\\\";\\nimport \\\"./Logic/BetBettingLogic.sol\\\";\\n\\ncontract Deathbet is BetBettingLogic, BetToken {\\n    constructor (\\n        address tokenAddress,\\n        uint _ticketPrice\\n    ) public\\n        BetToken(tokenAddress)\\n        BetBettingLogic(_ticketPrice)\\n    {}\\n\\n    // Implements \\\"./BetToken/BetTokenSender.sol\\\"\\n    function bet (address better, uint amountSent, bytes memory betData) internal override {\\n    // Routs to \\\"./Logic/BetBettingLogic\\\"\\n        _bet(better, amountSent, betData);\\n    }\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/Logic/BetBettingLogic.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BetDataStructure.sol\\\";\\n\\nimport \\\"../../../imty-token/contracts/Statistics.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./BetWinner.sol\\\";\\nimport \\\"../BetToken/BetTokenSender.sol\\\";\\n\\nabstract contract BetBettingLogic is ReentrancyGuard, BetDataStructure, Ownable, BetWinner, BetTokenSender {\\n    SignableStatistics public stats;\\n\\n    uint public ticketPrice;\\n\\n    constructor (uint _ticketPrice) public {\\n        ticketPrice = _ticketPrice;\\n    }\\n\\n    function setTicketPrice (uint _ticketPrice) public onlyOwner {\\n        ticketPrice = _ticketPrice;\\n    }\\n\\n    function changeClaimPercentage (uint _claimPercentage) public onlyOwner {\\n        claimPercentage = _claimPercentage;\\n    }\\n\\n    event AddedBet (uint weekId, address better, uint ticketPrice, uint32 deaths, uint32 infections, uint betId);\\n    event WeekConcluded (uint weekId, uint32 deaths, uint32 infections, address winner, uint32 winningDeaths, uint32 winningInfections, uint winningBetId);\\n\\n    function _bet (address better, uint amountSent, bytes memory betData) internal _allowedToBet nonReentrant {\\n        require(amountSent == ticketPrice);\\n        (uint32 deaths, uint32 infections) = abi.decode(betData, (uint32, uint32));\\n\\n        BetWeek storage betWeek = betWeeks[getWeek()];\\n\\n        betWeek.betters.push(better);\\n        betWeek.deaths.push(deaths);\\n        betWeek.infections.push(infections);\\n        betWeek.total += ticketPrice;\\n\\n        emit AddedBet(getWeek(), better, amountSent, deaths, infections, (betWeek.infections.length - 1));\\n    }\\n\\n    function concludeWeek (uint weekId, uint32 deaths, uint32 infections, uint winnerIndex) public onlyOwner {\\n        require(weekId < getWeek(), \\\"Still in week\\\");\\n        BetWeek storage week = betWeeks[weekId];\\n        require(week.concluded == false, \\\"Week already concluded\\\");\\n\\n        week.finalDeaths = deaths;\\n        week.finalInfections = infections;\\n        week.concluded = true;\\n\\n        address winnerAddress = week.betters[winnerIndex];\\n        uint32 winningDeaths = week.deaths[winnerIndex];\\n        uint32 winningInfections = week.infections[winnerIndex];\\n\\n        send(winnerAddress, (week.total / 100) * (100 - claimPercentage));\\n        send(owner(), (week.total / 100) * claimPercentage);\\n\\n        emit WeekConcluded (weekId, deaths, infections, winnerAddress, winningDeaths, winningInfections, winnerIndex);\\n\\n        week.concluded = true;\\n    }\\n\\n    modifier _allowedToBet () {\\n        require(allowedToBet(), \\\"Betting is not open today\\\");\\n        _;\\n    }\\n\\n    uint8 closeDay = 4;\\n    uint8 startDay = 10;\\n\\n    function setCloseDay (uint8 _closeDay) onlyOwner public {\\n        closeDay = _closeDay;\\n    }\\n\\n    function setStartDay (uint8 _startDay) onlyOwner public {\\n        startDay = _startDay;\\n    }\\n\\n    function allowedToBet () public view returns (bool) {\\n        uint8 currentDay = getDay();\\n        // uint currentWeek = getWeek();\\n        if (startDay == 10) {\\n            return currentDay < closeDay;\\n        } else {\\n            return currentDay > startDay && currentDay < closeDay;\\n        }\\n    }\\n\\n    function getDay () public view returns (uint8 _day) {\\n        _day = uint8((block.timestamp / 1 days) % 7);\\n    }\\n\\n    function getWeek () public view returns (uint _week) {\\n        _week = block.timestamp / 1 weeks;       \\n    }\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/Logic/BetDataStructure.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\npragma experimental ABIEncoderV2;\\n\\ncontract BetDataStructure {\\n    uint public claimPercentage = 20;\\n\\n    struct BetWeek {\\n        uint total;\\n        bool concluded;\\n        address[] betters;\\n        uint32[] deaths;\\n        uint32[] infections;\\n        uint32 finalDeaths;\\n        uint32 finalInfections;\\n    }\\n\\n    mapping(uint => BetWeek) public betWeeks;\\n\\n    function getBetWeek (uint _weekId) public view returns (\\n        uint total,\\n        bool concluded,\\n        address[] memory betters,\\n        uint32[] memory deaths,\\n        uint32[] memory infections,\\n        uint32 finalDeaths,\\n        uint32 finalInfections\\n\\n    ) {\\n        BetWeek memory betWeek = betWeeks[_weekId];\\n\\n        total = betWeek.total;\\n        concluded = betWeek.concluded;\\n        betters = betWeek.betters;\\n        deaths = betWeek.deaths;\\n        infections = betWeek.infections;\\n        finalDeaths = betWeek.finalDeaths;\\n        finalInfections = betWeek.finalInfections;\\n    }\\n}   \"\r\n    },\r\n    \"/home/hellowodl/projects/games/eth-bet/contracts/Logic/BetWinner.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.9;\\n\\nimport \\\"./BetDataStructure.sol\\\";\\n\\n\\n\\n\\ncontract BetWinner is BetDataStructure {\\n}\\n\\nlibrary UIntArrayUtils {\\n    function merge (uint32[] memory a, uint32[] memory b)\\n        internal\\n        pure\\n        returns (uint32[] memory)\\n    {\\n        uint32[] memory res = new uint32[](a.length);\\n        for (uint32 i = 0; i < a.length; i++) {\\n            res[i] = a[i] + b[i];\\n        }\\n        return res;\\n    }\\n\\n    function reduce (uint[] memory a, function(uint, uint) pure returns (uint) f)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        uint r = a[0];\\n        for (uint i = 1; i < a.length; i++) {\\n            r = f(r, a[i]);\\n        }\\n        return r;\\n    }\\n}\"\r\n    },\r\n    \"/home/hellowodl/projects/games/imty-token/contracts/Statistics.sol\": {\r\n      \"content\": \"//Write your own contracts here. Currently compiles using solc v0.4.15+commit.bbb8e64f.\\r\\npragma solidity ^0.6.10;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract StatisticsDataStructure {\\r\\n    uint public lastFilledWeek;\\r\\n    uint public startWeek;\\r\\n\\r\\n    mapping (uint => Datapoint) weeklyData;\\r\\n    struct Datapoint {\\r\\n        uint deaths;\\r\\n        uint infections;\\r\\n        bool filled;\\r\\n    }\\r\\n    event WeeklyData (uint deaths, uint infections, uint weekId);\\r\\n\\r\\n    constructor (uint deaths, uint infections) public {\\r\\n        lastFilledWeek = block.timestamp / 1 weeks;\\r\\n        startWeek = block.timestamp / 1 weeks;\\r\\n\\r\\n        pushWeeklyData(getCurrentWeek(), deaths, infections);\\r\\n    }\\r\\n\\r\\n    function pushWeeklyData (uint weekId, uint deaths, uint infections) internal {\\r\\n        Datapoint storage target = weeklyData[weekId];\\r\\n\\r\\n        require(target.filled == false, \\\"target week is already filled\\\");\\r\\n        \\r\\n        target.deaths = deaths;\\r\\n        target.infections = infections;\\r\\n        target.filled = true;\\r\\n\\r\\n        lastFilledWeek = weekId;\\r\\n\\r\\n        emit WeeklyData(deaths, infections, weekId);\\r\\n    }\\r\\n\\r\\n    function getCurrentWeek () public view returns (uint) {\\r\\n        return block.timestamp / 1 weeks;\\r\\n    }\\r\\n\\r\\n    function getNextWeek () public view returns (uint) {\\r\\n        return lastFilledWeek + 1;\\r\\n    }\\r\\n\\r\\n    function getWeeklyData (uint weekId) verifyWeekId(weekId) public view returns (uint deaths, uint infections) {\\r\\n        require(weeklyData[weekId].filled == true, \\\"No data for selected week\\\");\\r\\n        return (weeklyData[weekId].deaths, weeklyData[weekId].infections);\\r\\n    }\\r\\n\\r\\n    modifier verifyWeekId (uint weekId) {\\r\\n        require(weekId >= startWeek, \\\"No data recorded for given weekId\\\");\\r\\n        require(weekId <= getCurrentWeek(), \\\"weekId bigger than recorded weeklyData\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract SignableStatistics is StatisticsDataStructure {\\r\\n    address signerOne;\\r\\n    address signerTwo;\\r\\n\\r\\n    bool public signerOneApproval;\\r\\n    bool public signerTwoApproval;\\r\\n\\r\\n    uint public proposedDeaths;\\r\\n    uint public proposedInfections;\\r\\n    uint public proposedWeek;\\r\\n\\r\\n\\r\\n    function resetApproval () private {\\r\\n        signerOneApproval = false;\\r\\n        signerTwoApproval = false;\\r\\n    }\\r\\n\\r\\n    constructor (\\r\\n        address _signerOne,\\r\\n        address _signerTwo,\\r\\n        uint thisWeeksDeaths,\\r\\n        uint thisWeeksInfections\\r\\n    ) StatisticsDataStructure(\\r\\n        thisWeeksDeaths,\\r\\n        thisWeeksInfections\\r\\n    ) public {\\r\\n        signerOne = _signerOne;\\r\\n        signerTwo = _signerTwo;\\r\\n    }\\r\\n\\r\\n    function pushProposal () public isApproved {\\r\\n        pushWeeklyData(proposedWeek, proposedDeaths, proposedInfections);\\r\\n        _clearProposal();\\r\\n    }\\r\\n\\r\\n    function propose (uint _proposedDeaths, uint _proposedInfections) isSigner public {\\r\\n        uint nextWeek = getNextWeek();\\r\\n\\r\\n        require(lastFilledWeek < nextWeek, \\\"Data for this week has already been recorded\\\");\\r\\n        require(getCurrentWeek() >= nextWeek, \\\"Suggested data is for a date later than the current date\\\");\\r\\n\\r\\n        resetApproval();\\r\\n\\r\\n        proposedDeaths = _proposedDeaths;\\r\\n        proposedInfections = _proposedInfections;\\r\\n        proposedWeek = nextWeek;\\r\\n    }\\r\\n\\r\\n    function clearProposal () isSigner public {\\r\\n        _clearProposal();\\r\\n    }\\r\\n    function _clearProposal () isSigner private {\\r\\n        proposedDeaths = 0;\\r\\n        proposedInfections = 0;\\r\\n        proposedWeek = 0;\\r\\n        signerOneApproval = false;\\r\\n        signerTwoApproval = false;\\r\\n    }\\r\\n\\r\\n    function approve () public {\\r\\n        bool success;\\r\\n\\r\\n        if (msg.sender == signerOne) {\\r\\n            success = true;\\r\\n            signerOneApproval = true;\\r\\n        }\\r\\n        if (msg.sender == signerTwo) {\\r\\n           success = true;\\r\\n           signerTwoApproval = true;\\r\\n        }\\r\\n\\r\\n        require(success, 'Not authorized');\\r\\n    }\\r\\n\\r\\n    modifier isApproved () {\\r\\n        bool success;\\r\\n\\r\\n        if (signerOneApproval == true && signerTwoApproval == true) {\\r\\n            success = true;\\r\\n        }\\r\\n        require(success, \\\"Not everybody has approved the proposed values\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isSigner () {\\r\\n        bool isIndeedSigner;\\r\\n        if (msg.sender == signerOne || msg.sender == signerTwo) {\\r\\n            isIndeedSigner = true;\\r\\n        }\\r\\n        require(isIndeedSigner, \\\"\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC1820Implementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1820Implementer.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC1820Implementer} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\\n * declare their willingness to be implementers.\\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\\n * registration to be complete.\\n */\\ncontract ERC1820Implementer is IERC1820Implementer {\\n    bytes32 constant private _ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\\\"ERC1820_ACCEPT_MAGIC\\\"));\\n\\n    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\\n\\n    /**\\n     * See {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) public view override returns (bytes32) {\\n        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);\\n    }\\n\\n    /**\\n     * @dev Declares the contract as willing to be an implementer of\\n     * `interfaceHash` for `account`.\\n     *\\n     * See {IERC1820Registry-setInterfaceImplementer} and\\n     * {IERC1820Registry-interfaceHash}.\\n     */\\n    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {\\n        _supportedInterfaces[interfaceHash][account] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC1820Implementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface for an ERC1820 implementer, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].\\n * Used by contracts that will be registered as implementers in the\\n * {IERC1820Registry}.\\n */\\ninterface IERC1820Implementer {\\n    /**\\n     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract\\n     * implements `interfaceHash` for `account`.\\n     *\\n     * See {IERC1820Registry-setInterfaceImplementer}.\\n     */\\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\n * implementers for interfaces in this registry, as well as query support.\\n *\\n * Implementers may be shared by multiple accounts, and can also implement more\\n * than a single interface for each account. Contracts can implement interfaces\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\n * contract.\\n *\\n * {IERC165} interfaces can also be queried via the registry.\\n *\\n * For an in-depth explanation and source code analysis, see the EIP text.\\n */\\ninterface IERC1820Registry {\\n    /**\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\n     * account is able to set interface implementers for it.\\n     *\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\n     * `newManager` will reset the manager to this initial state.\\n     *\\n     * Emits a {ManagerChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     */\\n    function setManager(address account, address newManager) external;\\n\\n    /**\\n     * @dev Returns the manager for `account`.\\n     *\\n     * See {setManager}.\\n     */\\n    function getManager(address account) external view returns (address);\\n\\n    /**\\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\\n     * `interfaceHash`.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     * The zero address can also be used in `implementer` to remove an old one.\\n     *\\n     * See {interfaceHash} to learn how these are created.\\n     *\\n     * Emits an {InterfaceImplementerSet} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\n     * end in 28 zeroes).\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\n     * queried for support, unless `implementer` is the caller. See\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\\n\\n    /**\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\n     * implementer is registered, returns the zero address.\\n     *\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\n     * zeroes), `account` will be queried for support of it.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     */\\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\n     * corresponding\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\n     */\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\n\\n    /**\\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\n     *  @param account Address of the contract for which to update the cache.\\n     *  @param interfaceId ERC165 interface for which to update the cache.\\n     */\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\n\\n    /**\\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\\n     *  If the result is not cached a direct lookup on the contract address is performed.\\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\n     *  {updateERC165Cache} with the contract address.\\n     *  @param account Address of the contract to check.\\n     *  @param interfaceId ERC165 interface to check.\\n     *  @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\n     *  @param account Address of the contract to check.\\n     *  @param interfaceId ERC165 interface to check.\\n     *  @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\n\\n    event ManagerChanged(address indexed account, address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\\n *\\n * {IERC777} Token holders can be notified of operations performed on their\\n * tokens by having a contract implement this interface (contract holders can be\\n *  their own implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Sender {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\\n     * is conveyed by `to` being the zero address or not.\\n     *\\n     * This call occurs _before_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensToSend(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weekId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"better\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"deaths\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"infections\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"AddedBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weekId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"deaths\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"infections\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"winningDeaths\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"winningInfections\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningBetId\",\"type\":\"uint256\"}],\"name\":\"WeekConcluded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TOKENS_SENDER_INTERFACE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowedToBet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betWeeks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"concluded\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"finalDeaths\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"finalInfections\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimPercentage\",\"type\":\"uint256\"}],\"name\":\"changeClaimPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"deaths\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"infections\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"winnerIndex\",\"type\":\"uint256\"}],\"name\":\"concludeWeek\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weekId\",\"type\":\"uint256\"}],\"name\":\"getBetWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"concluded\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"betters\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"deaths\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"infections\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"finalDeaths\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"finalInfections\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDay\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"_day\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_week\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_closeDay\",\"type\":\"uint8\"}],\"name\":\"setCloseDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_startDay\",\"type\":\"uint8\"}],\"name\":\"setStartDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"internalType\":\"contract SignableStatistics\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensToSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Deathbet","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bec6cf25afb79b975e57b93f3216e468f8fed91000000000000000000000000000000000000000000000152d02c7e14af6800000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}