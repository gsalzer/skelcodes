{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/// UNIV2LPOracle.sol\r\n\r\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n///////////////////////////////////////////////////////\r\n//                                                   //\r\n//    Methodology for Calculating LP Token Price     //\r\n//                                                   //\r\n///////////////////////////////////////////////////////\r\n\r\n// INVARIANT k = reserve0 [num token0] * reserve1 [num token1]\r\n//\r\n// k = r_x * r_y\r\n// r_y = k / r_x\r\n//\r\n// 50-50 pools try to stay balanced in dollar terms\r\n// r_x * p_x = r_y * p_y    // Proportion of r_x and r_y can be manipulated so need to normalize them\r\n//\r\n// r_x * p_x = p_y * (k / r_x)\r\n// r_x^2 = k * p_y / p_x\r\n// r_x = sqrt(k * p_y / p_x) & r_y = sqrt(k * p_x / p_y)\r\n//\r\n// Now that we've calculated normalized values of r_x and r_y that are not prone to manipulation by an attacker,\r\n// we can calculate the price of an lp token using the following formula.\r\n//\r\n// p_lp = (r_x * p_x + r_y * p_y) / supply_lp\r\n//\r\npragma solidity ^0.6.11;\r\n\r\ninterface ERC20Like {\r\n    function decimals()         external view returns (uint8);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function totalSupply()      external view returns (uint256);\r\n}\r\n\r\ninterface UniswapV2PairLike {\r\n    function sync()        external;\r\n    function token0()      external view returns (address);\r\n    function token1()      external view returns (address);\r\n    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast\r\n}\r\n\r\ninterface OracleLike {\r\n    function read() external view returns (uint256);\r\n    function peek() external view returns (uint256,bool);\r\n}\r\n\r\n// Factory for creating Uniswap V2 LP Token Oracle instances\r\ncontract UNIV2LPOracleFactory {\r\n\r\n    mapping(address => bool) public isOracle;\r\n\r\n    event Created(address sender, address orcl, bytes32 wat, address tok0, address tok1, address orb0, address orb1);\r\n\r\n    // Create new Uniswap V2 LP Token Oracle instance\r\n    function build(address _src, bytes32 _wat, address _orb0, address _orb1) public returns (address orcl) {\r\n        address tok0 = UniswapV2PairLike(_src).token0();\r\n        address tok1 = UniswapV2PairLike(_src).token1();\r\n        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));\r\n        UNIV2LPOracle(orcl).rely(msg.sender);\r\n        isOracle[orcl] = true;\r\n        emit Created(msg.sender, orcl, _wat, tok0, tok1, _orb0, _orb1);\r\n    }\r\n}\r\n\r\ncontract UNIV2LPOracle {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;                                       // Addresses with admin authority\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }  // Add admin\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }  // Remove admin\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"UNIV2LPOracle/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Stop ---\r\n    uint256 public stopped;  // Stop/start ability to read\r\n    modifier stoppable { require(stopped == 0, \"UNIV2LPOracle/is-stopped\"); _; }\r\n\r\n    // --- Whitelisting ---\r\n    mapping (address => uint256) public bud;\r\n    modifier toll { require(bud[msg.sender] == 1, \"UNIV2LPOracle/contract-not-whitelisted\"); _; }\r\n\r\n    // --- Data ---\r\n    uint8   public immutable dec0;  // Decimals of token0\r\n    uint8   public immutable dec1;  // Decimals of token1\r\n    address public           orb0;  // Oracle for token0, ideally a Medianizer\r\n    address public           orb1;  // Oracle for token1, ideally a Medianizer\r\n    bytes32 public immutable wat;   // Token whose price is being tracked\r\n\r\n    uint32  public hop = 1 hours;   // Minimum time inbetween price updates\r\n    address public src;             // Price source\r\n    uint32  public zzz;             // Time of last price update\r\n\r\n    struct Feed {\r\n        uint128 val;  // Price\r\n        uint128 has;  // Is price valid\r\n    }\r\n\r\n    Feed    public cur;  // Current price\r\n    Feed    public nxt;  // Queued price\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0 && (z = x / y) * y == x, \"ds-math-divide-by-zero\");\r\n    }\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    // Compute the square root using the Babylonian method.\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event Change(address indexed src);\r\n    event Step(uint256 hop);\r\n    event Stop();\r\n    event Start();\r\n    event Value(uint128 curVal, uint128 nxtVal);\r\n    event Link(uint256 id, address orb);\r\n\r\n    // --- Init ---\r\n    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\r\n        require(_src  != address(0),                        \"UNIV2LPOracle/invalid-src-address\");\r\n        require(_orb0 != address(0) && _orb1 != address(0), \"UNIV2LPOracle/invalid-oracle-address\");\r\n        wards[msg.sender] = 1;\r\n        src  = _src;\r\n        zzz  = 0;\r\n        wat  = _wat;\r\n        dec0 = uint8(ERC20Like(UniswapV2PairLike(_src).token0()).decimals());  // Get decimals of token0\r\n        dec1 = uint8(ERC20Like(UniswapV2PairLike(_src).token1()).decimals());  // Get decimals of token1\r\n        orb0 = _orb0;\r\n        orb1 = _orb1;\r\n    }\r\n\r\n    function stop() external auth {\r\n        stopped = 1;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() external auth {\r\n        stopped = 0;\r\n        emit Start();\r\n    }\r\n\r\n    function change(address _src) external auth {\r\n        src = _src;\r\n        emit Change(src);\r\n    }\r\n\r\n    function step(uint256 _hop) external auth {\r\n        require(_hop <= uint32(-1), \"UNIV2LPOracle/invalid-hop\");\r\n        hop = uint32(_hop);\r\n        emit Step(hop);\r\n    }\r\n\r\n    function link(uint256 id, address orb) external auth {\r\n        require(orb != address(0), \"UNIV2LPOracle/no-contract-0\");\r\n        if(id == 0) {\r\n            orb0 = orb;\r\n        } else if (id == 1) {\r\n            orb1 = orb;\r\n        }\r\n        emit Link(id, orb);\r\n    }\r\n\r\n    function pass() public view returns (bool ok) {\r\n        return block.timestamp >= add(zzz, hop);\r\n    }\r\n\r\n    function seek() internal returns (uint128 quote, uint32 ts) {\r\n        // Sync up reserves of uniswap liquidity pool\r\n        UniswapV2PairLike(src).sync();\r\n\r\n        // Get reserves of uniswap liquidity pool\r\n        (uint112 res0, uint112 res1, uint32 _ts) = UniswapV2PairLike(src).getReserves();\r\n        require(res0 > 0 && res1 > 0, \"UNIV2LPOracle/invalid-reserves\");\r\n        ts = _ts;\r\n        require(ts == block.timestamp);\r\n\r\n        // Adjust reserves w/ respect to decimals\r\n        if (dec0 != uint8(18)) res0 = uint112(res0 * 10 ** sub(18, dec0));\r\n        if (dec1 != uint8(18)) res1 = uint112(res1 * 10 ** sub(18, dec1));\r\n\r\n        // Calculate constant product invariant k (WAD * WAD)\r\n        uint256 k = mul(res0, res1);\r\n\r\n        // All Oracle prices are priced with 18 decimals against USD\r\n        uint256 val0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\r\n        uint256 val1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\r\n        require(val0 != 0, \"UNIV2LPOracle/invalid-oracle-0-price\");\r\n        require(val1 != 0, \"UNIV2LPOracle/invalid-oracle-1-price\");\r\n\r\n        // Calculate normalized balances of token0 and token1\r\n        uint256 bal0 =\r\n            sqrt(\r\n                wmul(\r\n                    k,\r\n                    wdiv(\r\n                        val1,\r\n                        val0\r\n                    )\r\n                )\r\n            );\r\n        uint256 bal1 = wdiv(k, bal0) / WAD;\r\n\r\n        // Get LP token supply\r\n        uint256 supply = ERC20Like(src).totalSupply();\r\n        require(supply > 0, \"UNIV2LPOracle/invalid-lp-token-supply\");\r\n\r\n        // Calculate price quote of LP token\r\n        quote = uint128(\r\n            wdiv(\r\n                add(\r\n                    wmul(bal0, val0),  // (WAD)\r\n                    wmul(bal1, val1)   // (WAD)\r\n                ),\r\n                supply  // (WAD)\r\n            )\r\n        );\r\n    }\r\n\r\n    function poke() external stoppable {\r\n        require(pass(), \"UNIV2LPOracle/not-passed\");\r\n        (uint val, uint32 ts) = seek();\r\n        require(val != 0, \"UNIV2LPOracle/invalid-price\");\r\n        cur = nxt;\r\n        nxt = Feed(uint128(val), 1);\r\n        zzz = ts;\r\n        emit Value(cur.val, nxt.val);\r\n    }\r\n\r\n    function peek() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint(cur.val)), cur.has == 1);\r\n    }\r\n\r\n    function peep() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint(nxt.val)), nxt.has == 1);\r\n    }\r\n\r\n    function read() external view toll returns (bytes32) {\r\n        require(cur.has == 1, \"UNIV2LPOracle/no-current-value\");\r\n        return (bytes32(uint(cur.val)));\r\n    }\r\n\r\n    function kiss(address a) external auth {\r\n        require(a != address(0), \"UNIV2LPOracle/no-contract-0\");\r\n        bud[a] = 1;\r\n    }\r\n\r\n    function kiss(address[] calldata a) external auth {\r\n        for(uint i = 0; i < a.length; i++) {\r\n            require(a[i] != address(0), \"UNIV2LPOracle/no-contract-0\");\r\n            bud[a[i]] = 1;\r\n        }\r\n    }\r\n\r\n    function diss(address a) external auth {\r\n        bud[a] = 0;\r\n    }\r\n\r\n    function diss(address[] calldata a) external auth {\r\n        for(uint i = 0; i < a.length; i++) {\r\n            bud[a[i]] = 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_wat\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_orb0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orb1\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"}],\"name\":\"Change\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"orb\",\"type\":\"address\"}],\"name\":\"Link\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hop\",\"type\":\"uint256\"}],\"name\":\"Step\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"curVal\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nxtVal\",\"type\":\"uint128\"}],\"name\":\"Value\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bud\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"change\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cur\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"has\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dec0\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dec1\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"a\",\"type\":\"address[]\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hop\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"a\",\"type\":\"address[]\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"orb\",\"type\":\"address\"}],\"name\":\"link\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nxt\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"has\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orb0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orb1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pass\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peep\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"src\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hop\",\"type\":\"uint256\"}],\"name\":\"step\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wat\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zzz\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UNIV2LPOracle","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a478c2975ab1ea89e8196811f51a7b7ade33eb11554e49563244414945544800000000000000000000000000000000000000000000000000000000000000000047c3dc029825da43be595e21fffd0b66ffcb7f6e00000000000000000000000064de91f5a373cd4c28de3600cb34c7c6ce410c85","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e599d708073da5d75f40a1cf8a338fb7b59c9d8f808932a3645acb9baf2d7662"}]}