{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-10-02\r\n*/\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract MasterCopy is SelfAuthorized {\r\n\r\n    event ChangedMasterCopy(address masterCopy);\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n    // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address private masterCopy;\r\n\r\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n    /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n        emit ChangedMasterCopy(_masterCopy);\r\n    }\r\n}\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Executor {\r\n\r\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else\r\n            success = false;\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Module - Base class for modules.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n\r\n    function setupModules(address to, bytes memory data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Enables the module `module` for the Safe.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[address(module)] == address(0), \"Module has already been added\");\r\n        modules[address(module)] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = address(module);\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Disables the module `module` for the Safe.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[address(prevModule)] = modules[address(module)];\r\n        modules[address(module)] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n        else emit ExecutionFromModuleFailure(msg.sender);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        success = execTransactionFromModule(to, value, data, operation);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Load free memory location\r\n            let ptr := mload(0x40)\r\n            // We allocate memory for the return data by setting the free memory location to\r\n            // current free memory location + data size + 32 bytes for data size value\r\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\r\n            // Store the size\r\n            mstore(ptr, returndatasize())\r\n            // Store the data\r\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\r\n            // Point the return data to the correct memory location\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if an module is enabled\r\n    /// @return True if the module is enabled\r\n    function isModuleEnabled(Module module)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return SENTINEL_MODULES != address(module) && modules[address(module)] != address(0);\r\n    }\r\n\r\n    /// @dev Returns array of first 10 modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\r\n        return array;\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @param start Start of the page.\r\n    /// @param pageSize Maximum number of modules that should be returned.\r\n    /// @return Array of modules.\r\n    function getModulesPaginated(address start, uint256 pageSize)\r\n        public\r\n        view\r\n        returns (address[] memory array, address next)\r\n    {\r\n        // Init array with max page size\r\n        array = new address[](pageSize);\r\n\r\n        // Populate return array\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[start];\r\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount++;\r\n        }\r\n        next = currentModule;\r\n        // Set correct size of returned array\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            mstore(array, moduleCount)\r\n        }\r\n    }\r\n}\r\n\r\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract OwnerManager is SelfAuthorized {\r\n\r\n    event AddedOwner(address owner);\r\n    event RemovedOwner(address owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    address internal constant SENTINEL_OWNERS = address(0x1);\r\n\r\n    mapping(address => address) internal owners;\r\n    uint256 ownerCount;\r\n    uint256 internal threshold;\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    function setupOwners(address[] memory _owners, uint256 _threshold)\r\n        internal\r\n    {\r\n        // Threshold can only be 0 at initialization.\r\n        // Check ensures that setup function can only be called once.\r\n        require(threshold == 0, \"Owners have already been setup\");\r\n        // Validate that threshold is smaller than number of added owners.\r\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        // Initializing Safe owners.\r\n        address currentOwner = SENTINEL_OWNERS;\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            // Owner address cannot be null.\r\n            address owner = _owners[i];\r\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n            // No duplicate owners allowed.\r\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\r\n            owners[currentOwner] = owner;\r\n            currentOwner = owner;\r\n        }\r\n        owners[currentOwner] = SENTINEL_OWNERS;\r\n        ownerCount = _owners.length;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\r\n    /// @param owner New owner address.\r\n    /// @param _threshold New threshold.\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[owner] == address(0), \"Address is already an owner\");\r\n        owners[owner] = owners[SENTINEL_OWNERS];\r\n        owners[SENTINEL_OWNERS] = owner;\r\n        ownerCount++;\r\n        emit AddedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\r\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n    /// @param owner Owner address to be removed.\r\n    /// @param _threshold New threshold.\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Only allow to remove an owner, if threshold can still be reached.\r\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\r\n        // Validate owner address and check that it corresponds to owner index.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[prevOwner] = owners[owner];\r\n        owners[owner] = address(0);\r\n        ownerCount--;\r\n        emit RemovedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\r\n        // Validate oldOwner address and check that it corresponds to owner index.\r\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[newOwner] = owners[oldOwner];\r\n        owners[prevOwner] = newOwner;\r\n        owners[oldOwner] = address(0);\r\n        emit RemovedOwner(oldOwner);\r\n        emit AddedOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to update the number of required confirmations by Safe owners.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Changes the threshold of the Safe to `_threshold`.\r\n    /// @param _threshold New threshold.\r\n    function changeThreshold(uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate that threshold is smaller than number of owners.\r\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        threshold = _threshold;\r\n        emit ChangedThreshold(threshold);\r\n    }\r\n\r\n    function getThreshold()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return threshold;\r\n    }\r\n\r\n    function isOwner(address owner)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\r\n    }\r\n\r\n    /// @dev Returns array of owners.\r\n    /// @return Array of Safe owners.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory array = new address[](ownerCount);\r\n\r\n        // populate return array\r\n        uint256 index = 0;\r\n        address currentOwner = owners[SENTINEL_OWNERS];\r\n        while(currentOwner != SENTINEL_OWNERS) {\r\n            array[index] = currentOwner;\r\n            currentOwner = owners[currentOwner];\r\n            index ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n/// @title Confirmed Transaction Module - Enables the Safe to designate transactions that can be executed by an executor at any time. The set of executors is managed by the Safe.\r\ncontract ConfirmedTransactionModule is Module {\r\n\r\n    string public constant NAME = \"Confirmed Transaction Module\";\r\n    string public constant VERSION = \"0.1.0\";\r\n\r\n    event Confirmed(\r\n        bytes32 indexed transactionHash,\r\n        address indexed manager\r\n    );\r\n    event Revoked(\r\n        bytes32 indexed transactionHash,\r\n        address indexed manager\r\n    );\r\n    event Executed(\r\n        bytes32 indexed transactionHash,\r\n        address indexed executor\r\n    );\r\n    event ExecutorUpdated(\r\n        address indexed executor,\r\n        bool allowed\r\n    );\r\n\r\n\r\n    enum TransactionStatus {\r\n        Unknown,\r\n        Confirmed,\r\n        Executed\r\n    }\r\n\r\n    // transactionStatus maps transactionsHashes to their status\r\n    mapping (bytes32 => TransactionStatus) private transactionStatus;\r\n\r\n    // isExecutor mapping maps executor's address to executor status.\r\n    mapping (address => bool) public isExecutor;\r\n\r\n    modifier onlyExecutor() {\r\n        require(isExecutor[msg.sender], \"only executor can call\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Setup function sets manager\r\n    function setup()\r\n        public\r\n    {\r\n        setManager();\r\n    }\r\n\r\n    /// @dev Adds an address to the executor allowlist. This can only be done via a Safe transaction.\r\n    /// @param executor Executor address.\r\n    /// @param allowed true if executor should be allowed, false otherwise.\r\n    function setExecutor(address executor, bool allowed)\r\n        public\r\n        authorized\r\n    {\r\n        if (isExecutor[executor] != allowed) {\r\n            isExecutor[executor] = allowed;\r\n            emit ExecutorUpdated(executor, allowed);\r\n        }\r\n    }\r\n\r\n    /// @dev Confirms a transaction to make it executable. This can only be done via a Safe transaction.\r\n    /// @param transactionHash Transaction hash to be confirmed.\r\n    function confirmTransaction(bytes32 transactionHash)\r\n        public\r\n        authorized\r\n    {\r\n        require(transactionStatus[transactionHash] == TransactionStatus.Unknown, \"tx already confirmed\");\r\n        transactionStatus[transactionHash] = TransactionStatus.Confirmed;\r\n        emit Confirmed(transactionHash, msg.sender);\r\n    }\r\n\r\n    /// @dev Revokes a previous confirmation. This can only be done via a Safe transaction.\r\n    /// @param transactionHash Transaction hash to be revoked.\r\n    function revokeTransaction(bytes32 transactionHash)\r\n        public\r\n        authorized\r\n    {\r\n        require(transactionStatus[transactionHash] == TransactionStatus.Confirmed, \"tx unknown or already executed\");\r\n        transactionStatus[transactionHash] = TransactionStatus.Unknown;\r\n        emit Revoked(transactionHash, msg.sender);\r\n    }\r\n\r\n    /// @dev Executes a confirmed transaction. Only designated executors can execute.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param witness Witness for hash commitment.\r\n    function executeTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        bytes32 witness\r\n    )\r\n        public\r\n        onlyExecutor\r\n    {\r\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, witness);\r\n        require(transactionStatus[transactionHash] == TransactionStatus.Confirmed, \"tx unknown or already executed\");\r\n        transactionStatus[transactionHash] = TransactionStatus.Executed;\r\n        require(manager.execTransactionFromModule(to, value, data, operation), \"execution failed\");\r\n        emit Executed(transactionHash, msg.sender);\r\n    }\r\n\r\n    /// @dev Gets the status of a transaction.\r\n    /// @param transactionHash Hash of transaction whose status is queried.\r\n    /// @return A tuple of bools (confirmed, executed) indicating whether the\r\n    /// transactions has been confirmed and executed.\r\n    function getTransactionStatus(\r\n        bytes32 transactionHash\r\n    )\r\n        public\r\n        view\r\n        returns (bool confirmed, bool executed)\r\n    {\r\n        TransactionStatus status = transactionStatus[transactionHash];\r\n        if (status == TransactionStatus.Unknown) {\r\n            return (false, false);\r\n        } else if (status == TransactionStatus.Confirmed) {\r\n            return (true, false);\r\n        } else if (status == TransactionStatus.Executed) {\r\n            return (true, true);\r\n        } else {\r\n            // We should never reach this case\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns hash to be signed by owners.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param witness Witness for hash commitment.\r\n    /// @return Transaction hash.\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        bytes32 witness\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(operation == Enum.Operation.Call || operation == Enum.Operation.DelegateCall, \"unknown operation\");\r\n        return keccak256(abi.encode(to, value, data, operation, witness));\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"}],\"name\":\"ChangedMasterCopy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"Confirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"ExecutorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"Revoked\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"witness\",\"type\":\"bytes32\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"witness\",\"type\":\"bytes32\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"getTransactionStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExecutor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract ModuleManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"revokeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setExecutor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ConfirmedTransactionModule","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ef088e400f8572fd885e36348bcc199d7e0dd5d5ff73d8a70906daebcbe5fbf7"}]}