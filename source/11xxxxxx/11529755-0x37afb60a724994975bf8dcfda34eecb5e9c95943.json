{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BentoBox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n// The BentoBox\\n\\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ \\n//  ▐█ ▀█▪▀▄.▀·•█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· \\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌\\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\\n\\n// This contract stores funds, handles their transfers.\\n\\n// Copyright (c) 2020 BoringCrypto - All rights reserved\\n// Twitter: @Boring_Crypto\\n\\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\\n\\n// solhint-disable no-inline-assembly\\n// solhint-disable avoid-low-level-calls\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./libraries/BoringMath.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IMasterContract.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BentoBox is Ownable{\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n\\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool indexed approved);\\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\\n\\n    mapping(address => address) public masterContractOf; // Mapping from clone contracts to their masterContract\\n    mapping(address => mapping(address => bool)) public masterContractApproved; // masterContract to user to approval state\\n    mapping(IERC20 => mapping(address => uint256)) public balanceOf; // Balance per token per address/contract\\n    mapping(IERC20 => uint256) public totalSupply;\\n    // solhint-disable-next-line var-name-mixedcase\\n    IERC20 public immutable WethToken;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    mapping(address => bool) public whitelistedMasterContracts;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    constructor(IERC20 WethToken_) public {\\n        WethToken = WethToken_;\\n    }\\n\\n    // Deploys a given master Contract as a clone.\\n    function deploy(address masterContract, bytes calldata data) external {\\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\\n        address cloneAddress; // Address where the clone contract will reside.\\n\\n        // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(clone, 0x14), targetBytes)\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            cloneAddress := create(0, clone, 0x37)\\n        }\\n        masterContractOf[cloneAddress] = masterContract;\\n\\n        IMasterContract(cloneAddress).init(data);\\n\\n        emit LogDeploy(masterContract, data, cloneAddress);\\n    }\\n\\n    function domainSeparator() public view returns (bytes32) {\\n        uint256 chainId;\\n        assembly {chainId := chainid()}\\n        return keccak256(abi.encode(keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"), \\\"BentoBox V1\\\", chainId, address(this)));\\n    }\\n\\n    // *** Public actions *** //\\n    function whitelistMasterContract(address masterContract, bool approved) external onlyOwner{\\n        whitelistedMasterContracts[masterContract] = approved;\\n    }\\n\\n    function setMasterContractApprovalFallback(address masterContract, bool approved) external {\\n        require(masterContract != address(0), \\\"BentoBox: masterContract not set\\\"); // Important for security\\n        require(whitelistedMasterContracts[masterContract], \\\"BentoBox: not whitelisted\\\");\\n        masterContractApproved[masterContract][msg.sender] = approved;\\n        emit LogSetMasterContractApproval(masterContract, msg.sender, approved);\\n    }\\n\\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external {\\n        require(user != address(0), \\\"BentoBox: User cannot be 0\\\");\\n        require(masterContract != address(0), \\\"BentoBox: masterContract not set\\\"); // Important for security\\n\\n        bytes32 digest = keccak256(abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\", domainSeparator(),\\n            keccak256(abi.encode(\\n                // keccak256(\\\"SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)\\\");\\n                0x1962bc9f5484cb7a998701b81090e966ee1fce5771af884cceee7c081b14ade2,\\n                approved ? \\\"Give FULL access to funds in (and approved to) BentoBox?\\\" : \\\"Revoke access to BentoBox?\\\",\\n                user, masterContract, approved, nonces[user]++\\n            ))\\n        ));\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress == user, \\\"BentoBox: Invalid Signature\\\");\\n\\n        masterContractApproved[masterContract][user] = approved;\\n        emit LogSetMasterContractApproval(masterContract, user, approved);\\n    }\\n\\n    modifier allowed(address from) {\\n        require(msg.sender == from || masterContractApproved[masterContractOf[msg.sender]][from], \\\"BentoBox: Transfer not approved\\\");\\n        _;\\n    }\\n\\n    function permit(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        token.permit(from, address(this), amount, deadline, v, r, s);\\n    }\\n\\n    function deposit(IERC20 token, address from, uint256 amount) external payable { depositTo(token, from, msg.sender, amount); }\\n    function depositTo(IERC20 token, address from, address to, uint256 amount) public payable allowed(from) {\\n        _deposit(token, from, to, amount);\\n    }\\n\\n    function withdraw(IERC20 token, address to, uint256 amount) external { withdrawFrom(token, msg.sender, to, amount); }\\n    function withdrawFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\\n        _withdraw(token, from, to, amount);\\n    }\\n\\n    // *** Approved contract actions *** //\\n    // Clones of master contracts can transfer from any account that has approved them\\n    function transfer(IERC20 token, address to, uint256 amount) external { transferFrom(token, msg.sender, to, amount); }\\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\\n        require(to != address(0), \\\"BentoBox: to not set\\\"); // To avoid a bad UI from burning funds\\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\\n\\n        emit LogTransfer(token, from, to, amount);\\n    }\\n\\n    function transferMultiple(IERC20 token, address[] calldata tos, uint256[] calldata amounts) external\\n    {\\n        transferMultipleFrom(token, msg.sender, tos, amounts);\\n    }\\n    function transferMultipleFrom(IERC20 token, address from, address[] calldata tos, uint256[] calldata amounts) public allowed(from) {\\n        require(tos[0] != address(0), \\\"BentoBox: to[0] not set\\\"); // To avoid a bad UI from burning funds\\n        uint256 totalAmount;\\n        for (uint256 i=0; i < tos.length; i++) {\\n            address to = tos[i];\\n            balanceOf[token][to] = balanceOf[token][to].add(amounts[i]);\\n            totalAmount = totalAmount.add(amounts[i]);\\n            emit LogTransfer(token, from, to, amounts[i]);\\n        }\\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\\n    }\\n\\n    function skim(IERC20 token) external returns (uint256 amount) { amount = skimTo(token, msg.sender); }\\n    function skimTo(IERC20 token, address to) public returns (uint256 amount) {\\n        require(to != address(0), \\\"BentoBox: to not set\\\"); // To avoid a bad UI from burning funds\\n        amount = token.balanceOf(address(this)).sub(totalSupply[token]);\\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\\n        totalSupply[token] = totalSupply[token].add(amount);\\n        emit LogDeposit(token, address(this), to, amount);\\n    }\\n\\n    function skimETH() external returns (uint256 amount) { amount = skimETHTo(msg.sender); }\\n    function skimETHTo(address to) public returns (uint256 amount) {\\n        IWETH(address(WethToken)).deposit{value: address(this).balance}();\\n        amount = skimTo(WethToken, to);\\n    }\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\\n        successes = new bool[](calls.length);\\n        results = new bytes[](calls.length);\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\n            require(success || !revertOnFail, \\\"BentoBox: Transaction failed\\\");\\n            successes[i] = success;\\n            results[i] = result;\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    // *** Private functions *** //\\n    function _deposit(IERC20 token, address from, address to, uint256 amount) private {\\n        require(to != address(0), \\\"BentoBox: to not set\\\"); // To avoid a bad UI from burning funds\\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\\n        uint256 supply = totalSupply[token];\\n        totalSupply[token] = supply.add(amount);\\n\\n        if (address(token) == address(WethToken)) {\\n            IWETH(address(WethToken)).deposit{value: amount}();\\n        } else {\\n            if (supply == 0) { // During the first deposit, we check that this token is 'real'\\n                require(token.totalSupply() > 0, \\\"BentoBox: No tokens\\\");\\n            }\\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BentoBox: TransferFrom failed\\\");\\n        }\\n        emit LogDeposit(token, from, to, amount);\\n    }\\n\\n    function _withdraw(IERC20 token, address from, address to, uint256 amount) private {\\n        require(to != address(0), \\\"BentoBox: to not set\\\"); // To avoid a bad UI from burning funds\\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\\n        totalSupply[token] = totalSupply[token].sub(amount);\\n        if (address(token) == address(WethToken)) {\\n            IWETH(address(WethToken)).withdraw(amount);\\n            (bool success,) = to.call{value: amount}(new bytes(0));\\n            require(success, \\\"BentoBox: ETH transfer failed\\\");\\n        } else {\\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BentoBox: Transfer failed\\\");\\n        }\\n        emit LogWithdraw(token, from, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\\nlibrary BoringMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\n        require(a <= uint128(-1), \\\"BoringMath: uint128 Overflow\\\");\\n        c = uint128(a);\\n    }\\n}\\n\\nlibrary BoringMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    // non-standard\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    // EIP 2612\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IMasterContract {\\n    function init(bytes calldata data) external;\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Edited by BoringCrypto\\n\\ncontract OwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\ncontract Ownable is OwnableData {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        pendingOwner = newOwner;\\n    }\\n\\n    function transferOwnershipDirect(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: zero address\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(msg.sender == pendingOwner, \\\"Ownable: caller != pending owner\\\");\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/mocks/OwnableMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../Ownable.sol\\\";\\n\\ncontract OwnableMock is Ownable {}\\n\"\r\n    },\r\n    \"contracts/LendingPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n// Medium Risk LendingPair\\n\\n// ▄▄▌  ▄▄▄ . ▐ ▄ ·▄▄▄▄  ▪   ▐ ▄  ▄▄ •  ▄▄▄· ▄▄▄· ▪  ▄▄▄\\n// ██•  ▀▄.▀·•█▌▐███▪ ██ ██ •█▌▐█▐█ ▀ ▪▐█ ▄█▐█ ▀█ ██ ▀▄ █·\\n// ██▪  ▐▀▀▪▄▐█▐▐▌▐█· ▐█▌▐█·▐█▐▐▌▄█ ▀█▄ ██▀·▄█▀▀█ ▐█·▐▀▀▄\\n// ▐█▌▐▌▐█▄▄▌██▐█▌██. ██ ▐█▌██▐█▌▐█▄▪▐█▐█▪·•▐█ ▪▐▌▐█▌▐█•█▌\\n// .▀▀▀  ▀▀▀ ▀▀ █▪▀▀▀▀▀• ▀▀▀▀▀ █▪·▀▀▀▀ .▀    ▀  ▀ ▀▀▀.▀  ▀\\n\\n// Copyright (c) 2020 BoringCrypto - All rights reserved\\n// Twitter: @Boring_Crypto\\n\\n// Special thanks to:\\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\\n\\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\\n\\n// solhint-disable avoid-low-level-calls\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./libraries/BoringMath.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./interfaces/IMasterContract.sol\\\";\\nimport \\\"./interfaces/ISwapper.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\n\\n// TODO: check all reentrancy paths\\n// TODO: what to do when the entire pool is underwater?\\n// TODO: check that all actions on a users funds can only be initiated by that user as msg.sender\\n\\ncontract LendingPair is ERC20, Ownable, IMasterContract {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n\\n    // MasterContract variables\\n    IBentoBox public immutable bentoBox;\\n    LendingPair public immutable masterContract;\\n    address public feeTo;\\n    address public dev;\\n    mapping(ISwapper => bool) public swappers;\\n\\n    // Per clone variables\\n    // Clone settings\\n    IERC20 public collateral;\\n    IERC20 public asset;\\n    IOracle public oracle;\\n    bytes public oracleData;\\n\\n    // User balances\\n    mapping(address => uint256) public userCollateralAmount;\\n    // userAssetFraction is called balanceOf for ERC20 compatibility\\n    mapping(address => uint256) public userBorrowFraction;\\n\\n    struct TokenTotals {\\n        uint128 amount;\\n        uint128 fraction;\\n    }\\n\\n    // Total amounts\\n    uint256 public totalCollateralAmount;\\n    TokenTotals public totalAsset; // The total assets belonging to the suppliers (including any borrowed amounts).\\n    TokenTotals public totalBorrow; // Total units of asset borrowed\\n\\n    // totalSupply for ERC20 compatibility\\n    function totalSupply() public view returns(uint256) {\\n        return totalAsset.fraction;\\n    }\\n\\n    // Exchange and interest rate tracking\\n    uint256 public exchangeRate;\\n\\n    struct AccrueInfo {\\n        uint64 interestPerBlock;\\n        uint64 lastBlockAccrued;\\n        uint128 feesPendingAmount;\\n    }\\n    AccrueInfo public accrueInfo;\\n\\n    // ERC20 'variables'\\n    function symbol() public view returns(string memory) {\\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x95d89b41));\\n        string memory assetSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n\\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x95d89b41));\\n        string memory collateralSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n\\n        return string(abi.encodePacked(\\\"bm\\\", collateralSymbol, \\\">\\\", assetSymbol, \\\"-\\\", oracle.symbol(oracleData)));\\n    }\\n\\n    function name() public view returns(string memory) {\\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x06fdde03));\\n        string memory assetName = success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n\\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x06fdde03));\\n        string memory collateralName = success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n\\n        return string(abi.encodePacked(\\\"Bento Med Risk \\\", collateralName, \\\">\\\", assetName, \\\"-\\\", oracle.symbol(oracleData)));\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x313ce567));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    event LogExchangeRate(uint256 rate);\\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount, uint256 rate, uint256 utilization);\\n    event LogAddCollateral(address indexed user, uint256 amount);\\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\\n    event LogRemoveCollateral(address indexed user, uint256 amount);\\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\\n    event LogFeeTo(address indexed newFeeTo);\\n    event LogDev(address indexed newDev);\\n    event LogWithdrawFees();\\n\\n    constructor(IBentoBox bentoBox_) public {\\n        bentoBox = bentoBox_;\\n        masterContract = LendingPair(this);\\n        dev = msg.sender;\\n        feeTo = msg.sender;\\n        emit LogDev(msg.sender);\\n        emit LogFeeTo(msg.sender);\\n\\n        // Not really an issue, but https://blog.trailofbits.com/2020/12/16/breaking-aave-upgradeability/\\n        collateral = IERC20(address(1));\\n    }\\n\\n    // Settings for the Medium Risk LendingPair\\n    uint256 private constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\\n    uint256 private constant OPEN_COLLATERIZATION_RATE = 77000; // 77%\\n    uint256 private constant MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\\n    uint256 private constant MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\\n\\n    uint256 private constant STARTING_INTEREST_PER_BLOCK = 4566210045; // approx 1% APR\\n    uint256 private constant MINIMUM_INTEREST_PER_BLOCK = 1141552511; // approx 0.25% APR\\n    uint256 private constant MAXIMUM_INTEREST_PER_BLOCK = 4566210045000;  // approx 1000% APR\\n    uint256 private constant INTEREST_ELASTICITY = 2000e36; // Half or double in 2000 blocks (approx 8 hours)\\n\\n    uint256 private constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\\n\\n    // Fees\\n    uint256 private constant PROTOCOL_FEE = 10000; // 10%\\n    uint256 private constant DEV_FEE = 10000; // 10% of the PROTOCOL_FEE = 1%\\n    uint256 private constant BORROW_OPENING_FEE = 50; // 0.05%\\n\\n    // Serves as the constructor, as clones can't have a regular constructor\\n    function init(bytes calldata data) public override {\\n        require(address(collateral) == address(0), \\\"LendingPair: already initialized\\\");\\n        (collateral, asset, oracle, oracleData) = abi.decode(data, (IERC20, IERC20, IOracle, bytes));\\n\\n        accrueInfo.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);  // 1% APR, with 1e18 being 100%\\n        updateExchangeRate();\\n    }\\n\\n    function getInitData(IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) public pure returns(bytes memory data) {\\n        return abi.encode(collateral_, asset_, oracle_, oracleData_);\\n    }\\n\\n    function setApproval(address user, bool approved, uint8 v, bytes32 r, bytes32 s) external {\\n        bentoBox.setMasterContractApproval(user, address(masterContract), approved, v, r, s);\\n    }\\n\\n    function permitToken(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        bentoBox.permit(token, from, amount, deadline, v, r, s);\\n    }\\n\\n    // Accrues the interest on the borrowed tokens and handles the accumulation of fees\\n    function accrue() public {\\n        AccrueInfo memory info = accrueInfo;\\n        // Number of blocks since accrue was called\\n        uint256 blocks = block.number - info.lastBlockAccrued;\\n        if (blocks == 0) {return;}\\n        info.lastBlockAccrued = uint64(block.number);\\n\\n        uint256 extraAmount = 0;\\n        uint256 feeAmount = 0;\\n\\n        TokenTotals memory _totalBorrow = totalBorrow;\\n        TokenTotals memory _totalAsset = totalAsset;\\n        if (_totalBorrow.amount > 0) {\\n            // Accrue interest\\n            extraAmount = uint256(_totalBorrow.amount).mul(info.interestPerBlock).mul(blocks) / 1e18;\\n            feeAmount = extraAmount.mul(PROTOCOL_FEE) / 1e5; // % of interest paid goes to fee\\n            _totalBorrow.amount = _totalBorrow.amount.add(extraAmount.to128());\\n            totalBorrow = _totalBorrow;\\n            _totalAsset.amount = _totalAsset.amount.add(extraAmount.sub(feeAmount).to128());\\n            totalAsset = _totalAsset;\\n            info.feesPendingAmount = info.feesPendingAmount.add(feeAmount.to128());\\n        }\\n\\n        if (_totalAsset.amount == 0) {\\n            if (info.interestPerBlock != STARTING_INTEREST_PER_BLOCK) {\\n                info.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);\\n                emit LogAccrue(extraAmount, feeAmount, STARTING_INTEREST_PER_BLOCK, 0);\\n            }\\n            accrueInfo = info; return;\\n        }\\n\\n        // Update interest rate\\n        uint256 utilization = uint256(_totalBorrow.amount).mul(1e18) / _totalAsset.amount;\\n        uint256 newInterestPerBlock;\\n        if (utilization < MINIMUM_TARGET_UTILIZATION) {\\n            uint256 underFactor = MINIMUM_TARGET_UTILIZATION.sub(utilization).mul(1e18) / MINIMUM_TARGET_UTILIZATION;\\n            uint256 scale = INTEREST_ELASTICITY.add(underFactor.mul(underFactor).mul(blocks));\\n            newInterestPerBlock = uint256(info.interestPerBlock).mul(INTEREST_ELASTICITY) / scale;\\n            if (newInterestPerBlock < MINIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MINIMUM_INTEREST_PER_BLOCK;} // 0.25% APR minimum\\n       } else if (utilization > MAXIMUM_TARGET_UTILIZATION) {\\n            uint256 overFactor = utilization.sub(MAXIMUM_TARGET_UTILIZATION).mul(1e18) / uint256(1e18).sub(MAXIMUM_TARGET_UTILIZATION);\\n            uint256 scale = INTEREST_ELASTICITY.add(overFactor.mul(overFactor).mul(blocks));\\n            newInterestPerBlock = uint256(info.interestPerBlock).mul(scale) / INTEREST_ELASTICITY;\\n            if (newInterestPerBlock > MAXIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MAXIMUM_INTEREST_PER_BLOCK;} // 1000% APR maximum\\n        } else {\\n            emit LogAccrue(extraAmount, feeAmount, info.interestPerBlock, utilization);\\n            accrueInfo = info; return;\\n        }\\n\\n        info.interestPerBlock = uint64(newInterestPerBlock);\\n        emit LogAccrue(extraAmount, feeAmount, newInterestPerBlock, utilization);\\n        accrueInfo = info;\\n    }\\n\\n    // Checks if the user is solvent.\\n    // Has an option to check if the user is solvent in an open/closed liquidation case.\\n    function isSolvent(address user, bool open) public view returns (bool) {\\n        // accrue must have already been called!\\n        if (userBorrowFraction[user] == 0) return true;\\n        if (totalCollateralAmount == 0) return false;\\n\\n        TokenTotals memory _totalBorrow = totalBorrow;\\n\\n        return userCollateralAmount[user].mul(1e13).mul(open ? OPEN_COLLATERIZATION_RATE : CLOSED_COLLATERIZATION_RATE)\\n            >= userBorrowFraction[user].mul(_totalBorrow.amount).mul(exchangeRate) / _totalBorrow.fraction;\\n    }\\n\\n    function peekExchangeRate() public view returns (bool, uint256) {\\n        return oracle.peek(oracleData);\\n    }\\n\\n    // Gets the exchange rate. How much collateral to buy 1e18 asset.\\n    function updateExchangeRate() public returns (uint256) {\\n        (bool success, uint256 rate) = oracle.get(oracleData);\\n\\n        // TODO: How to deal with unsuccessful fetch\\n        if (success) {\\n            exchangeRate = rate;\\n            emit LogExchangeRate(rate);\\n        }\\n        return exchangeRate;\\n    }\\n\\n    // Handles internal variable updates when collateral is deposited\\n    function _addCollateralAmount(address user, uint256 amount) private {\\n        // Adds this amount to user\\n        userCollateralAmount[user] = userCollateralAmount[user].add(amount);\\n        // Adds the amount deposited to the total of collateral\\n        totalCollateralAmount = totalCollateralAmount.add(amount);\\n        emit LogAddCollateral(msg.sender, amount);\\n    }\\n\\n    // Handles internal variable updates when supply (the borrowable token) is deposited\\n    function _addAssetAmount(address user, uint256 amount) private {\\n        TokenTotals memory _totalAsset = totalAsset;\\n        // Calculates what amount of the pool the user gets for the amount deposited\\n        uint256 newFraction = _totalAsset.amount == 0 ? amount : amount.mul(_totalAsset.fraction) / _totalAsset.amount;\\n        // Adds this amount to user\\n        balanceOf[user] = balanceOf[user].add(newFraction);\\n        // Adds this amount to the total of supply amounts\\n        _totalAsset.fraction = _totalAsset.fraction.add(newFraction.to128());\\n        // Adds the amount deposited to the total of supply\\n        _totalAsset.amount = _totalAsset.amount.add(amount.to128());\\n        totalAsset = _totalAsset;\\n        emit LogAddAsset(msg.sender, amount, newFraction);\\n    }\\n\\n    // Handles internal variable updates when supply (the borrowable token) is borrowed\\n    function _addBorrowAmount(address user, uint256 amount) private {\\n        TokenTotals memory _totalBorrow = totalBorrow;\\n        // Calculates what amount of the borrowed funds the user gets for the amount borrowed\\n        uint256 newFraction = _totalBorrow.amount == 0 ? amount : amount.mul(_totalBorrow.fraction) / _totalBorrow.amount;\\n        // Adds this amount to the user\\n        userBorrowFraction[user] = userBorrowFraction[user].add(newFraction);\\n        // Adds amount borrowed to the total amount borrowed\\n        _totalBorrow.fraction = _totalBorrow.fraction.add(newFraction.to128());\\n        // Adds amount borrowed to the total amount borrowed\\n        _totalBorrow.amount = _totalBorrow.amount.add(amount.to128());\\n        totalBorrow = _totalBorrow;\\n        emit LogAddBorrow(msg.sender, amount, newFraction);\\n    }\\n\\n    // Handles internal variable updates when collateral is withdrawn and returns the amount of collateral withdrawn\\n    function _removeCollateralAmount(address user, uint256 amount) private {\\n        // Subtracts the amount from user\\n        userCollateralAmount[user] = userCollateralAmount[user].sub(amount);\\n        // Subtracts the amount from the total of collateral\\n        totalCollateralAmount = totalCollateralAmount.sub(amount);\\n        emit LogRemoveCollateral(msg.sender, amount);\\n    }\\n\\n    // Handles internal variable updates when supply is withdrawn and returns the amount of supply withdrawn\\n    function _removeAssetFraction(address user, uint256 fraction) private returns (uint256 amount) {\\n        TokenTotals memory _totalAsset = totalAsset;\\n        // Subtracts the fraction from user\\n        balanceOf[user] = balanceOf[user].sub(fraction);\\n        // Calculates the amount of tokens to withdraw\\n        amount = fraction.mul(_totalAsset.amount) / _totalAsset.fraction;\\n        // Subtracts the calculated fraction from the total of supply\\n        _totalAsset.fraction = _totalAsset.fraction.sub(fraction.to128());\\n        // Subtracts the amount from the total of supply amounts\\n        _totalAsset.amount = _totalAsset.amount.sub(amount.to128());\\n        totalAsset = _totalAsset;\\n        emit LogRemoveAsset(msg.sender, amount, fraction);\\n    }\\n\\n    // Handles internal variable updates when supply is repaid\\n    function _removeBorrowFraction(address user, uint256 fraction) private returns (uint256 amount) {\\n        TokenTotals memory _totalBorrow = totalBorrow;\\n        // Subtracts the fraction from user\\n        userBorrowFraction[user] = userBorrowFraction[user].sub(fraction);\\n        // Calculates the amount of tokens to repay\\n        amount = fraction.mul(_totalBorrow.amount) / _totalBorrow.fraction;\\n        // Subtracts the fraction from the total of amounts borrowed\\n        _totalBorrow.fraction = _totalBorrow.fraction.sub(fraction.to128());\\n        // Subtracts the calculated amount from the total amount borrowed\\n        _totalBorrow.amount = _totalBorrow.amount.sub(amount.to128());\\n        totalBorrow = _totalBorrow;\\n        emit LogRemoveBorrow(msg.sender, amount, fraction);\\n    }\\n\\n    // Deposits an amount of collateral from the caller\\n    function addCollateral(uint256 amount, bool useBento) public payable { addCollateralTo(amount, msg.sender, useBento); }\\n    function addCollateralTo(uint256 amount, address to, bool useBento) public payable {\\n        _addCollateralAmount(to, amount);\\n        useBento \\n            ? bentoBox.transferFrom(collateral, msg.sender, address(this), amount)\\n            : bentoBox.deposit{value: msg.value}(collateral, msg.sender, amount);\\n    }\\n\\n    // Deposits an amount of supply (the borrowable token) from the caller\\n    function addAsset(uint256 amount, bool useBento) public payable { addAssetTo(amount, msg.sender, useBento); }\\n    function addAssetTo(uint256 amount, address to, bool useBento) public payable {\\n        // Accrue interest before calculating pool amounts in _addAssetAmount\\n        accrue();\\n        _addAssetAmount(to, amount);\\n        useBento ? bentoBox.transferFrom(asset, msg.sender, address(this), amount) : bentoBox.deposit{value: msg.value}(asset, msg.sender, amount);\\n    }\\n\\n    // Withdraws a amount of collateral of the caller to the specified address\\n    function removeCollateral(uint256 amount, address to, bool useBento) public {\\n        accrue();\\n        _removeCollateralAmount(msg.sender, amount);\\n        // Only allow withdrawing if user is solvent (in case of a closed liquidation)\\n        require(isSolvent(msg.sender, false), \\\"LendingPair: user insolvent\\\");\\n        useBento ? bentoBox.transfer(collateral, to, amount) : bentoBox.withdraw(collateral, to, amount);\\n    }\\n\\n    // Withdraws a amount of supply (the borrowable token) of the caller to the specified address\\n    function removeAsset(uint256 fraction, address to, bool useBento) public {\\n        // Accrue interest before calculating pool amounts in _removeAssetFraction\\n        accrue();\\n        uint256 amount = _removeAssetFraction(msg.sender, fraction);\\n        useBento ? bentoBox.transfer(asset, to, amount) : bentoBox.withdraw(asset, to, amount);\\n    }\\n\\n    // Borrows the given amount from the supply to the specified address\\n    function borrow(uint256 amount, address to, bool useBento) public {\\n        accrue();\\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / 1e5; // A flat % fee is charged for any borrow\\n        _addBorrowAmount(msg.sender, amount.add(feeAmount));\\n        totalAsset.amount = totalAsset.amount.add(feeAmount.to128());\\n        useBento ? bentoBox.transfer(asset, to, amount) : bentoBox.withdraw(asset, to, amount);\\n        require(isSolvent(msg.sender, false), \\\"LendingPair: user insolvent\\\");\\n    }\\n\\n    // Repays the given fraction\\n    function repay(uint256 fraction, bool useBento) public { repayFor(fraction, msg.sender, useBento); }\\n    function repayFor(uint256 fraction, address beneficiary, bool useBento) public {\\n        accrue();\\n        uint256 amount = _removeBorrowFraction(beneficiary, fraction);\\n        useBento ? bentoBox.transferFrom(asset, msg.sender, address(this), amount) : bentoBox.deposit(asset, msg.sender, amount);\\n    }\\n\\n    // Handles shorting with an approved swapper\\n    function short(ISwapper swapper, uint256 assetAmount, uint256 minCollateralAmount) public {\\n        require(masterContract.swappers(swapper), \\\"LendingPair: Invalid swapper\\\");\\n        accrue();\\n        _addBorrowAmount(msg.sender, assetAmount);\\n        bentoBox.transferFrom(asset, address(this), address(swapper), assetAmount);\\n\\n        // Swaps the borrowable asset for collateral\\n        swapper.swap(asset, collateral, assetAmount, minCollateralAmount);\\n        uint256 returnedCollateralAmount = bentoBox.skim(collateral); // TODO: Reentrancy issue? Should we take a before and after balance?\\n        require(returnedCollateralAmount >= minCollateralAmount, \\\"LendingPair: not enough\\\");\\n        _addCollateralAmount(msg.sender, returnedCollateralAmount);\\n\\n        require(isSolvent(msg.sender, false), \\\"LendingPair: user insolvent\\\");\\n    }\\n\\n    // Handles unwinding shorts with an approved swapper\\n    function unwind(ISwapper swapper, uint256 borrowFraction, uint256 maxAmountCollateral) public {\\n        require(masterContract.swappers(swapper), \\\"LendingPair: Invalid swapper\\\");\\n        accrue();\\n        bentoBox.transferFrom(collateral, address(this), address(swapper), maxAmountCollateral);\\n\\n        uint256 borrowAmount = _removeBorrowFraction(msg.sender, borrowFraction);\\n\\n        // Swaps the collateral back for the borrowal asset\\n        uint256 usedAmount = swapper.swapExact(collateral, asset, maxAmountCollateral, borrowAmount, address(this));\\n        uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\\n        require(returnedAssetAmount >= borrowAmount, \\\"LendingPair: Not enough\\\");\\n\\n        _removeCollateralAmount(msg.sender, maxAmountCollateral.sub(usedAmount));\\n\\n        require(isSolvent(msg.sender, false), \\\"LendingPair: user insolvent\\\");\\n    }\\n\\n    // Handles the liquidation of users' balances, once the users' amount of collateral is too low\\n    function liquidate(address[] calldata users, uint256[] calldata borrowFractions, address to, ISwapper swapper, bool open) public {\\n        accrue();\\n        updateExchangeRate();\\n\\n        uint256 allCollateralAmount = 0;\\n        uint256 allBorrowAmount = 0;\\n        uint256 allBorrowFraction = 0;\\n        TokenTotals memory _totalBorrow = totalBorrow;\\n        for (uint256 i = 0; i < users.length; i++) {\\n            address user = users[i];\\n            if (!isSolvent(user, open)) {\\n                // Gets the user's amount of the total borrowed amount\\n                uint256 borrowFraction = borrowFractions[i];\\n                // Calculates the user's amount borrowed\\n                uint256 borrowAmount = borrowFraction.mul(_totalBorrow.amount) / _totalBorrow.fraction;\\n                // Calculates the amount of collateral that's going to be swapped for the asset\\n                uint256 collateralAmount = borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(exchangeRate) / 1e23;\\n\\n                // Removes the amount of collateral from the user's balance\\n                userCollateralAmount[user] = userCollateralAmount[user].sub(collateralAmount);\\n                // Removes the amount of user's borrowed tokens from the user\\n                userBorrowFraction[user] = userBorrowFraction[user].sub(borrowFraction);\\n                emit LogRemoveCollateral(user, collateralAmount);\\n                emit LogRemoveBorrow(user, borrowAmount, borrowFraction);\\n\\n                // Keep totals\\n                allCollateralAmount = allCollateralAmount.add(collateralAmount);\\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\\n                allBorrowFraction = allBorrowFraction.add(borrowFraction);\\n            }\\n        }\\n        require(allBorrowAmount != 0, \\\"LendingPair: all are solvent\\\");\\n        _totalBorrow.amount = _totalBorrow.amount.sub(allBorrowAmount.to128());\\n        _totalBorrow.fraction = _totalBorrow.fraction.sub(allBorrowFraction.to128());\\n        totalBorrow = _totalBorrow;\\n        totalCollateralAmount = totalCollateralAmount.sub(allCollateralAmount);\\n\\n        if (!open) {\\n            // Closed liquidation using a pre-approved swapper for the benefit of the LPs\\n            require(masterContract.swappers(swapper), \\\"LendingPair: Invalid swapper\\\");\\n\\n            // Swaps the users' collateral for the borrowed asset\\n            bentoBox.transferFrom(collateral, address(this), address(swapper), allCollateralAmount);\\n            swapper.swap(collateral, asset, allCollateralAmount, allBorrowAmount);\\n            uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\\n            uint256 extraAssetAmount = returnedAssetAmount.sub(allBorrowAmount);\\n\\n            // The extra asset gets added to the pool\\n            uint256 feeAmount = extraAssetAmount.mul(PROTOCOL_FEE) / 1e5; // % of profit goes to fee\\n            accrueInfo.feesPendingAmount = accrueInfo.feesPendingAmount.add(feeAmount.to128());\\n            totalAsset.amount = totalAsset.amount.add(extraAssetAmount.sub(feeAmount).to128());\\n            emit LogAddAsset(address(0), extraAssetAmount, 0);\\n        } else if (address(swapper) == address(0)) {\\n            // Open liquidation directly using the caller's funds, without swapping using token transfers\\n            bentoBox.deposit(asset, msg.sender, allBorrowAmount);\\n            bentoBox.withdraw(collateral, to, allCollateralAmount);\\n        } else if (address(swapper) == address(1)) {\\n            // Open liquidation directly using the caller's funds, without swapping using funds in BentoBox\\n            bentoBox.transferFrom(asset, msg.sender, address(this), allBorrowAmount);\\n            bentoBox.transfer(collateral, to, allCollateralAmount);\\n        } else {\\n            // Swap using a swapper freely chosen by the caller\\n            // Open (flash) liquidation: get proceeds first and provide the borrow after\\n            bentoBox.transferFrom(collateral, address(this), address(swapper), allCollateralAmount);\\n            swapper.swap(collateral, asset, allCollateralAmount, allBorrowAmount);\\n            uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\\n            uint256 extraAssetAmount = returnedAssetAmount.sub(allBorrowAmount);\\n\\n            totalAsset.amount = totalAsset.amount.add(extraAssetAmount.to128());\\n            emit LogAddAsset(address(0), extraAssetAmount, 0);\\n        }\\n    }\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory, bytes[] memory) {\\n        bool[] memory successes = new bool[](calls.length);\\n        bytes[] memory results = new bytes[](calls.length);\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\n            require(success || !revertOnFail, \\\"LendingPair: Transaction failed\\\");\\n            successes[i] = success;\\n            results[i] = result;\\n        }\\n        return (successes, results);\\n    }\\n\\n    // Withdraws the fees accumulated\\n    function withdrawFees() public {\\n        accrue();\\n        address _feeTo = masterContract.feeTo();\\n        address _dev = masterContract.dev();\\n        uint256 feeAmount = accrueInfo.feesPendingAmount.sub(1);\\n        uint256 devFeeAmount = _dev == address(0) ? 0 : feeAmount.mul(DEV_FEE) / 1e5;\\n        accrueInfo.feesPendingAmount = 1; // Don't set it to 0 as that would increase the gas cost for the next accrue called by a user.\\n        bentoBox.withdraw(asset, _feeTo, feeAmount.sub(devFeeAmount));\\n        if (devFeeAmount > 0) {\\n            bentoBox.withdraw(asset, _dev, devFeeAmount);\\n        }\\n        emit LogWithdrawFees();\\n    }\\n\\n    // MasterContract Only Admin functions\\n    function setSwapper(ISwapper swapper, bool enable) public onlyOwner {\\n        swappers[swapper] = enable;\\n    }\\n\\n    function setFeeTo(address newFeeTo) public onlyOwner\\n    {\\n        feeTo = newFeeTo;\\n        emit LogFeeTo(newFeeTo);\\n    }\\n\\n    function setDev(address newDev) public\\n    {\\n        require(msg.sender == dev || (dev == address(0) && msg.sender == owner), \\\"LendingPair: Not dev\\\");\\n        dev = newDev;\\n        emit LogDev(newDev);\\n    }\\n\\n    // Clone contract Admin functions\\n    function swipe(IERC20 token) public {\\n        require(msg.sender == masterContract.owner(), \\\"LendingPair: caller is not owner\\\");\\n\\n        if (address(token) == address(0)) {\\n            uint256 balanceETH = address(this).balance;\\n            if (balanceETH > 0) {\\n                (bool success,) = msg.sender.call{value: balanceETH}(new bytes(0));\\n                require(success, \\\"LendingPair: ETH transfer failed\\\");\\n            }\\n        } else if (address(token) != address(asset) && address(token) != address(collateral)) {\\n            uint256 balanceAmount = token.balanceOf(address(this));\\n            if (balanceAmount > 0) {\\n                (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, msg.sender, balanceAmount));\\n                require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"LendingPair: Transfer failed\\\");\\n            }\\n        } else {\\n            uint256 excessAmount = bentoBox.balanceOf(token, address(this)).sub(token == asset ? totalAsset.amount : totalCollateralAmount);\\n            bentoBox.transfer(token, msg.sender, excessAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IOracle {\\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\\n    function get(bytes calldata data) external returns (bool, uint256);\\n    function peek(bytes calldata data) external view returns (bool, uint256);\\n    function symbol(bytes calldata data) external view returns (string memory);\\n    function name(bytes calldata data) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable no-inline-assembly\\n// solhint-disable not-rely-on-time\\n\\npragma solidity 0.6.12;\\n\\n// Data part taken out for building of contracts that receive delegate calls\\ncontract ERC20Data {\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping (address => uint256)) public allowance;\\n    mapping(address => uint256) public nonces;\\n}\\n\\ncontract ERC20 is ERC20Data {\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    function transfer(address to, uint256 amount) public returns (bool success) {\\n        require(balanceOf[msg.sender] >= amount, \\\"ERC20: balance too low\\\");\\n        require(balanceOf[to] + amount >= balanceOf[to], \\\"ERC20: overflow detected\\\");\\n        balanceOf[msg.sender] -= amount;\\n        balanceOf[to] += amount;\\n        emit Transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\\n        require(balanceOf[from] >= amount, \\\"ERC20: balance too low\\\");\\n        require(allowance[from][msg.sender] >= amount, \\\"ERC20: allowance too low\\\");\\n        require(balanceOf[to] + amount >= balanceOf[to], \\\"ERC20: overflow detected\\\");\\n        balanceOf[from] -= amount;\\n        allowance[from][msg.sender] -= amount;\\n        balanceOf[to] += amount;\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) public returns (bool success) {\\n        allowance[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() public view returns (bytes32){\\n      uint256 chainId;\\n      assembly {chainId := chainid()}\\n      return keccak256(abi.encode(keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\"), chainId, address(this)));\\n    }\\n\\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(owner_ != address(0), \\\"ERC20: Owner cannot be 0\\\");\\n        require(block.timestamp < deadline, \\\"ERC20: Expired\\\");\\n        bytes32 digest = keccak256(abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(),\\n            keccak256(abi.encode(\\n                // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\\n                owner_, spender, value, nonces[owner_]++, deadline\\n            ))\\n        ));\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress == owner_, \\\"ERC20: Invalid Signature\\\");\\n        allowance[owner_][spender] = value;\\n        emit Approval(owner_, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IBentoBox.sol\\\";\\n\\ninterface ISwapper {\\n    // Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper\\n    // Swaps it for at least 'amountToMin' of token 'to'\\n    // Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer\\n    // Returns the amount of tokens 'to' transferred to BentoBox\\n    // (The BentoBox skim function will be used by the caller to get the swapped funds)\\n    function swap(IERC20 from, IERC20 to, uint256 amountFrom, uint256 amountToMin) external returns (uint256 amountTo);\\n\\n    // Calculates the amount of token 'from' needed to complete the swap (amountFrom), this should be less than or equal to amountFromMax\\n    // Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper\\n    // Swaps it for exactly 'exactAmountTo' of token 'to'\\n    // Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer\\n    // Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom)\\n    // Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom)\\n    // (The BentoBox skim function will be used by the caller to get the swapped funds)\\n    function swapExact(\\n        IERC20 from, IERC20 to, uint256 amountFromMax,\\n        uint256 exactAmountTo, address refundTo\\n    ) external returns (uint256 amountFrom);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBentoBox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IBentoBox {\\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount);\\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool indexed approved);\\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 amount);\\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH() external view returns (IERC20);\\n    function balanceOf(IERC20, address) external view returns (uint256);\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\n    function deploy(address masterContract, bytes calldata data) external;\\n    function deposit(IERC20 token, address from, uint256 amount) external payable;\\n    function depositTo(IERC20 token, address from, address to, uint256 amount) external payable;\\n    function masterContractApproved(address, address) external view returns (bool);\\n    function masterContractOf(address) external view returns (address);\\n    function nonces(address) external view returns (uint256);\\n    function permit(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\\n    function skim(IERC20 token) external returns (uint256 amount);\\n    function skimETH() external returns (uint256 amount);\\n    function skimETHTo(address to) external returns (uint256 amount);\\n    function skimTo(IERC20 token, address to) external returns (uint256 amount);\\n    function totalSupply(IERC20) external view returns (uint256);\\n    function transfer(IERC20 token, address to, uint256 amount) external;\\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) external;\\n    function transferMultiple(IERC20 token, address[] calldata tos, uint256[] calldata amounts) external;\\n    function transferMultipleFrom(IERC20 token, address from, address[] calldata tos, uint256[] calldata amounts) external;\\n    function withdraw(IERC20 token, address to, uint256 amount) external;\\n    function withdrawFrom(IERC20 token, address from, address to, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/mocks/LendingPairMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IBentoBox.sol\\\";\\nimport \\\"../LendingPair.sol\\\";\\n\\ncontract LendingPairMock is LendingPair {\\n    constructor(IBentoBox bentoBox) public LendingPair(bentoBox) {}\\n\\n    function setInterestPerBlock(uint64 interestPerBlock) public {\\n        accrueInfo.interestPerBlock = interestPerBlock;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swappers/SushiSwapSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/ISwapper.sol\\\";\\n\\ncontract SushiSwapSwapper is ISwapper {\\n    using BoringMath for uint256;\\n\\n    // Local variables\\n    IBentoBox public bentoBox;\\n    IUniswapV2Factory public factory;\\n\\n    constructor(IBentoBox bentoBox_, IUniswapV2Factory factory_) public {\\n        bentoBox = bentoBox_;\\n        factory = factory_;\\n    }\\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountOut) {\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountIn) {\\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // Swaps to a flexible amount, from an exact input amount\\n    function swap(IERC20 from, IERC20 to, uint256 amountFrom, uint256 amountToMin) public override returns (uint256) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(from), address(to)));\\n\\n        bentoBox.withdraw(from, address(pair), amountFrom);\\n\\n        (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\\n        uint256 amountTo;\\n        if (pair.token0() == address(from)) {\\n            amountTo = getAmountOut(amountFrom, reserve0, reserve1);\\n            require(amountTo >= amountToMin, \\\"SushiSwapSwapper: not enough\\\");\\n            pair.swap(0, amountTo, address(bentoBox), new bytes(0));\\n        } else {\\n            amountTo = getAmountOut(amountFrom, reserve1, reserve0);\\n            require(amountTo >= amountToMin, \\\"SushiSwapSwapper: not enough\\\");\\n            pair.swap(amountTo, 0, address(bentoBox), new bytes(0));\\n        }\\n        return amountTo;\\n    }\\n\\n    // Swaps to an exact amount, from a flexible input amount\\n    function swapExact(\\n        IERC20 from, IERC20 to, uint256 amountFromMax, uint256 exactAmountTo, address refundTo\\n    ) public override returns (uint256) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(from), address(to)));\\n\\n        (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\\n\\n        uint256 amountFrom;\\n        if (pair.token0() == address(from)) {\\n            amountFrom = getAmountIn(exactAmountTo, reserve0, reserve1);\\n            require(amountFrom <= amountFromMax, \\\"SushiSwapSwapper: not enough\\\");\\n            bentoBox.withdraw(from, address(pair), amountFrom);\\n            pair.swap(0, exactAmountTo, address(bentoBox), new bytes(0));\\n        } else {\\n            amountFrom = getAmountIn(exactAmountTo, reserve1, reserve0);\\n            require(amountFrom <= amountFromMax, \\\"SushiSwapSwapper: not enough\\\");\\n            bentoBox.withdraw(from, address(pair), amountFrom);\\n            pair.swap(exactAmountTo, 0, address(bentoBox), new bytes(0));\\n        }\\n\\n        bentoBox.transferFrom(from, address(this), refundTo, amountFromMax.sub(amountFrom));\\n\\n        return amountFrom;\\n    }\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILendingPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable func-name-mixedcase\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./ISwapper.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IBentoBox.sol\\\";\\n\\ninterface ILendingPair {\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount, uint256 rate, uint256 utilization);\\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\\n    event LogAddCollateral(address indexed user, uint256 amount);\\n    event LogDev(address indexed newDev);\\n    event LogExchangeRate(uint256 rate);\\n    event LogFeeTo(address indexed newFeeTo);\\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\\n    event LogRemoveCollateral(address indexed user, uint256 amount);\\n    event LogWithdrawFees();\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function accrue() external;\\n    function accrueInfo() external view returns (uint64 interestPerBlock, uint64 lastBlockAccrued, uint128 feesPendingAmount);\\n    function addAsset(uint256 amount, bool useBento) external payable;\\n    function addAssetTo(uint256 amount, address to, bool useBento) external payable;\\n    function addCollateral(uint256 amount, bool useBento) external payable;\\n    function addCollateralTo(uint256 amount, address to, bool useBento) external payable;\\n    function allowance(address, address) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n    function asset() external view returns (IERC20);\\n    function balanceOf(address) external view returns (uint256);\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory, bytes[] memory);\\n    function bentoBox() external view returns (IBentoBox);\\n    function borrow(uint256 amount, address to, bool useBento) external;\\n    function claimOwnership() external;\\n    function collateral() external view returns (IERC20);\\n    function decimals() external view returns (uint8);\\n    function dev() external view returns (address);\\n    function exchangeRate() external view returns (uint256);\\n    function feeTo() external view returns (address);\\n    function getInitData(\\n        IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) external pure returns (bytes memory data);\\n    function init(bytes calldata data) external;\\n    function isSolvent(address user, bool open) external view returns (bool);\\n    function liquidate(address[] calldata users, uint256[] calldata borrowFractions, address to, ISwapper swapper, bool open) external;\\n    function masterContract() external view returns (ILendingPair);\\n    function name() external view returns (string memory);\\n    function nonces(address) external view returns (uint256);\\n    function oracle() external view returns (IOracle);\\n    function oracleData() external view returns (bytes memory);\\n    function owner() external view returns (address);\\n    function peekExchangeRate() external view returns (bool, uint256);\\n    function pendingOwner() external view returns (address);\\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function permitToken(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function removeAsset(uint256 fraction, address to, bool useBento) external;\\n    function removeCollateral(uint256 amount, address to, bool useBento) external;\\n    function renounceOwnership() external;\\n    function repay(uint256 fraction, bool useBento) external;\\n    function repayFor(uint256 fraction, address beneficiary, bool useBento) external;\\n    function setApproval(address user, bool approved, uint8 v, bytes32 r, bytes32 s) external;\\n    function setDev(address newDev) external;\\n    function setFeeTo(address newFeeTo) external;\\n    function setSwapper(ISwapper swapper, bool enable) external;\\n    function short(ISwapper swapper, uint256 assetAmount, uint256 minCollateralAmount) external;\\n    function swappers(ISwapper) external view returns (bool);\\n    function swipe(IERC20 token) external;\\n    function symbol() external view returns (string memory);\\n    function totalAsset() external view returns (uint128 amount, uint128 fraction);\\n    function totalBorrow() external view returns (uint128 amount, uint128 fraction);\\n    function totalCollateralAmount() external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool success);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool success);\\n    function transferOwnership(address newOwner) external;\\n    function transferOwnershipDirect(address newOwner) external;\\n    function unwind(ISwapper swapper, uint256 borrowFraction, uint256 maxAmountCollateral) external;\\n    function updateExchangeRate() external returns (uint256);\\n    function userBorrowFraction(address) external view returns (uint256);\\n    function userCollateralAmount(address) external view returns (uint256);\\n    function withdrawFees() external;\\n}\"\r\n    },\r\n    \"contracts/oracles/SimpleSLPTWAP1Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\n// Using the same Copyleft License as in the original Repository\\n// solhint-disable not-rely-on-time\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\\n\\ncontract SimpleSLPTWAP1Oracle is IOracle {\\n    using FixedPoint for *;\\n    using BoringMath for uint256;\\n    uint256 public constant PERIOD = 5 minutes;\\n\\n    struct PairInfo {\\n        uint256 priceCumulativeLast;\\n        uint32 blockTimestampLast;\\n        FixedPoint.uq112x112 priceAverage;\\n    }\\n\\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\\n\\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\\n        uint256 priceCumulative = pair.price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            priceCumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\\n        }\\n\\n        // overflow is desired, casting never truncates\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        return priceCumulative;\\n    }\\n\\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) { return abi.encode(pair); }\\n\\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\\n    function get(bytes calldata data) external override returns (bool, uint256) {\\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n        if (pairs[pair].blockTimestampLast == 0) {\\n            pairs[pair].blockTimestampLast = blockTimestamp;\\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\\n            return (false, 0);\\n        }\\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\\n        if (timeElapsed < PERIOD) {\\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\\n        }\\n\\n        uint256 priceCumulative = _get(pair, blockTimestamp);\\n        pairs[pair].priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\\n        pairs[pair].blockTimestampLast = blockTimestamp;\\n        pairs[pair].priceCumulativeLast = priceCumulative;\\n\\n        return (true, pairs[pair].priceAverage.mul(10**18).decode144());\\n    }\\n\\n    // Check the last exchange rate without any state changes\\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n        if (pairs[pair].blockTimestampLast == 0) {\\n            return (false, 0);\\n        }\\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\\n        if (timeElapsed < PERIOD) {\\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\\n        }\\n\\n        uint256 priceCumulative = _get(pair, blockTimestamp);\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint\\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\\n\\n        return (true, priceAverage.mul(10**18).decode144());\\n    }\\n\\n    function name(bytes calldata) public override view returns (string memory) {\\n        return \\\"SushiSwap TWAP\\\";\\n    }\\n\\n    function symbol(bytes calldata) public override view returns (string memory) {\\n        return \\\"S\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\nimport \\\"./FullMath.sol\\\";\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // multiply a UQ112x112 by a uint256, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\n        uint256 z = 0;\\n        require(y == 0 || (z = self._x * y) / y == self._x, \\\"FixedPoint::mul: overflow\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // lossy if either numerator or denominator is greater than 112 bits\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint::fraction: div by 0\\\");\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= uint144(-1)) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= uint224(-1), \\\"FixedPoint::fraction: overflow\\\");\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= uint224(-1), \\\"FixedPoint::fraction: overflow\\\");\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC-BY-4.0\\n// solium-disable security/no-assign-params\\npragma solidity 0.6.12;\\n\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\n// license is CC-BY-4.0\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, uint256(-1));\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & -d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * ((-pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n        require(h < d, 'FullMath::mulDiv: overflow');\\n        return fullDiv(l, h, d);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/SimpleSLPTWAP0Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\n// Using the same Copyleft License as in the original Repository\\n// solhint-disable not-rely-on-time\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\\n\\ncontract SimpleSLPTWAP0Oracle is IOracle {\\n    using FixedPoint for *;\\n    using BoringMath for uint256;\\n    uint256 public constant PERIOD = 5 minutes;\\n\\n    struct PairInfo {\\n        uint256 priceCumulativeLast;\\n        uint32 blockTimestampLast;\\n        FixedPoint.uq112x112 priceAverage;\\n    }\\n\\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\\n\\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\\n        uint256 priceCumulative = pair.price0CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\\n        }\\n\\n        // overflow is desired, casting never truncates\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        return priceCumulative;\\n    }\\n\\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) { return abi.encode(pair); }\\n\\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\\n    function get(bytes calldata data) external override returns (bool, uint256) {\\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n        if (pairs[pair].blockTimestampLast == 0) {\\n            pairs[pair].blockTimestampLast = blockTimestamp;\\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\\n\\n            return (false, 0);\\n        }\\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\\n        if (timeElapsed < PERIOD) {\\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\\n        }\\n\\n        uint256 priceCumulative = _get(pair, blockTimestamp);\\n        pairs[pair].priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\\n        pairs[pair].blockTimestampLast = blockTimestamp;\\n        pairs[pair].priceCumulativeLast = priceCumulative;\\n\\n        return (true, pairs[pair].priceAverage.mul(10**18).decode144());\\n    }\\n\\n    // Check the last exchange rate without any state changes\\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n        if (pairs[pair].blockTimestampLast == 0) {\\n            return (false, 0);\\n        }\\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\\n        if (timeElapsed < PERIOD) {\\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\\n        }\\n\\n        uint256 priceCumulative = _get(pair, blockTimestamp);\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint\\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\\n\\n        return (true, priceAverage.mul(10**18).decode144());\\n    }\\n\\n    function name(bytes calldata) public override view returns (string memory) {\\n        return \\\"SushiSwap TWAP\\\";\\n    }\\n\\n    function symbol(bytes calldata) public override view returns (string memory) {\\n        return \\\"S\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\nimport './UniswapV2ERC20.sol';\\nimport './libraries/Math.sol';\\nimport './libraries/UQ112x112.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './interfaces/IUniswapV2Callee.sol';\\n\\n\\ninterface IMigrator {\\n    // Return the desired amount of liquidity token that the migrator wants.\\n    function desiredLiquidity() external view returns (uint256);\\n}\\n\\ncontract UniswapV2Pair is UniswapV2ERC20 {\\n    using SafeMathUniswap  for uint;\\n    using UQ112x112 for uint224;\\n\\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n\\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint public price0CumulativeLast;\\n    uint public price1CumulativeLast;\\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    uint private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'UniswapV2: LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(address token, address to, uint value) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\\n    }\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    constructor() public {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\\n        address feeTo = IUniswapV2Factory(factory).feeTo();\\n        feeOn = feeTo != address(0);\\n        uint _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\\n                uint rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                    uint denominator = rootK.mul(5).add(rootKLast);\\n                    uint liquidity = numerator / denominator;\\n                    if (liquidity > 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external lock returns (uint liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\\n        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\\n        uint amount0 = balance0.sub(_reserve0);\\n        uint amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            address migrator = IUniswapV2Factory(factory).migrator();\\n            if (msg.sender == migrator) {\\n                liquidity = IMigrator(migrator).desiredLiquidity();\\n                require(liquidity > 0 && liquidity != uint256(-1), \\\"Bad desired liquidity\\\");\\n            } else {\\n                require(migrator == address(0), \\\"Must not have migrator\\\");\\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            }\\n        } else {\\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n        }\\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        address _token0 = token0;                                // gas savings\\n        address _token1 = token1;                                // gas savings\\n        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        uint liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\\n\\n        uint balance0;\\n        uint balance1;\\n        { // scope for _token{0,1}, avoids stack too deep errors\\n        address _token0 = token0;\\n        address _token1 = token1;\\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        }\\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(_token0, to, IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0));\\n        _safeTransfer(_token1, to, IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(IERC20Uniswap(token0).balanceOf(address(this)), IERC20Uniswap(token1).balanceOf(address(this)), reserve0, reserve1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/UniswapV2ERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\nimport './libraries/SafeMath.sol';\\n\\ncontract UniswapV2ERC20 {\\n    using SafeMathUniswap for uint;\\n\\n    string public constant name = 'SushiSwap LP Token';\\n    string public constant symbol = 'SLP';\\n    uint8 public constant decimals = 18;\\n    uint  public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public nonces;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20Uniswap {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Callee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMathUniswap {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/SushiSwapPairMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol\\\";\\n\\ncontract SushiSwapPairMock is UniswapV2Pair {}\\n\"\r\n    },\r\n    \"@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity =0.6.12;\\n\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './UniswapV2Pair.sol';\\n\\ncontract UniswapV2Factory is IUniswapV2Factory {\\n    address public override feeTo;\\n    address public override feeToSetter;\\n    address public override migrator;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    constructor(address _feeToSetter) public {\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    function allPairsLength() external override view returns (uint) {\\n        return allPairs.length;\\n    }\\n\\n    function pairCodeHash() external pure returns (bytes32) {\\n        return keccak256(type(UniswapV2Pair).creationCode);\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        UniswapV2Pair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setFeeTo(address _feeTo) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeTo = _feeTo;\\n    }\\n\\n    function setMigrator(address _migrator) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        migrator = _migrator;\\n    }\\n\\n    function setFeeToSetter(address _feeToSetter) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/SushiSwapFactoryMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol\\\";\\n\\ncontract SushiSwapFactoryMock is UniswapV2Factory {\\n\\tconstructor() public UniswapV2Factory(msg.sender) {}\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/PeggedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\n\\ncontract PeggedOracle is IOracle {\\n    using BoringMath for uint256;\\n\\n    function getDataParameter(uint256 rate) public pure returns (bytes memory) { return abi.encode(rate); }\\n\\n    // Get the exchange rate\\n    function get(bytes calldata data) public override returns (bool, uint256) {\\n        uint256 rate = abi.decode(data, (uint256));\\n        return (rate != 0, rate);\\n    }\\n\\n    // Check the exchange rate without any state changes\\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\\n        uint256 rate = abi.decode(data, (uint256));\\n        return (rate != 0, rate);\\n    }\\n\\n    function name(bytes calldata) public override view returns (string memory) {\\n        return \\\"Pegged\\\";\\n    }\\n\\n    function symbol(bytes calldata) public override view returns (string memory) {\\n        return \\\"PEG\\\";\\n    }\\n}\"\r\n    },\r\n    \"contracts/oracles/CompoundOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\n\\ninterface IUniswapAnchoredView {\\n    function price(string memory symbol) external view returns (uint256);\\n}\\n\\ncontract CompoundOracle is IOracle {\\n    using BoringMath for uint256;\\n\\n    IUniswapAnchoredView constant private ORACLE = IUniswapAnchoredView(0x922018674c12a7F0D394ebEEf9B58F186CdE13c1);\\n\\n    struct PriceInfo {\\n        uint128 price;\\n        uint128 blockNumber;\\n    }\\n\\n    mapping(string => PriceInfo) public prices;\\n\\n    function _peekPrice(string memory symbol) internal view returns(uint256) {\\n        if (bytes(symbol).length == 0) {return 1000000;} // To allow only using collateralSymbol or assetSymbol if paired against USDx\\n        PriceInfo memory info = prices[symbol];\\n        if (block.number > info.blockNumber + 8) {\\n            return uint128(ORACLE.price(symbol)); // Prices are denominated with 6 decimals, so will fit in uint128\\n        }\\n        return info.price;\\n    }\\n\\n    function _getPrice(string memory symbol) internal returns(uint256) {\\n        if (bytes(symbol).length == 0) {return 1000000;} // To allow only using collateralSymbol or assetSymbol if paired against USDx\\n        PriceInfo memory info = prices[symbol];\\n        if (block.number > info.blockNumber + 8) {\\n            info.price = uint128(ORACLE.price(symbol)); // Prices are denominated with 6 decimals, so will fit in uint128\\n            info.blockNumber = uint128(block.number); // Blocknumber will fit in uint128\\n            prices[symbol] = info;\\n        }\\n        return info.price;\\n    }\\n\\n    function getDataParameter(string memory collateralSymbol, string memory assetSymbol, uint256 division) public pure returns (bytes memory) {\\n        return abi.encode(collateralSymbol, assetSymbol, division);\\n    }\\n\\n    // Get the latest exchange rate\\n    function get(bytes calldata data) public override returns (bool, uint256) {\\n        (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n        return (true, uint256(1e36).mul(_getPrice(assetSymbol)) / _getPrice(collateralSymbol) / division);\\n    }\\n\\n    // Check the last exchange rate without any state changes\\n    function peek(bytes calldata data) public override view returns(bool, uint256) {\\n        (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\\n        return (true, uint256(1e36).mul(_peekPrice(assetSymbol)) / _peekPrice(collateralSymbol) / division);\\n    }\\n\\n    function name(bytes calldata) public override view returns (string memory) {\\n        return \\\"Compound\\\";\\n    }\\n\\n    function symbol(bytes calldata) public override view returns (string memory) {\\n        return \\\"COMP\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/CompositeOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\n// Using the same Copyleft License as in the original Repository\\npragma solidity 0.6.12;\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\n\\ncontract CompositeOracle is IOracle {\\n    using BoringMath for uint256;\\n\\n    function getDataParameter(IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) public pure returns (bytes memory) {\\n        return abi.encode(oracle1, oracle2, data1, data2);\\n    }\\n\\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\\n    function get(bytes calldata data) external override returns (bool status, uint256 amountOut){\\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\\n        (bool success1, uint256 price1) = oracle1.get(data1);\\n        (bool success2, uint256 price2) = oracle2.get(data2);\\n        return (success1 && success2, price1.mul(price2) / 10**18);\\n    }\\n\\n    // Check the last exchange rate without any state changes\\n    function peek(bytes calldata data) public override view returns (bool success, uint256 amountOut) {\\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\\n        (bool success1, uint256 price1) = oracle1.peek(data1);\\n        (bool success2, uint256 price2) = oracle2.peek(data2);\\n        return (success1 && success2, price1.mul(price2) / 10**18);\\n    }\\n\\n    function name(bytes calldata data) public override view returns (string memory) {\\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\\n        return string(abi.encodePacked(oracle1.name(data1), \\\"+\\\", oracle2.name(data2)));\\n    }\\n\\n    function symbol(bytes calldata data) public override view returns (string memory) {\\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\\n        return string(abi.encodePacked(oracle1.symbol(data1), \\\"+\\\", oracle2.symbol(data2)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/ChainlinkOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\n\\n// Chainlink Aggregator\\ninterface IAggregator {\\n    function latestRoundData() external view returns (uint80, int256 answer, uint256, uint256, uint80);\\n}\\n\\ncontract ChainlinkOracle is IOracle {\\n    using BoringMath for uint256; // Keep everything in uint256\\n\\n    // Calculates the lastest exchange rate\\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\\n    function _get(address multiply, address divide, uint256 decimals) public view returns (uint256) {\\n        uint256 price = uint256(1e18);\\n        if (multiply != address(0)) {\\n            // We only care about the second value - the price\\n            (, int256 priceC,,,) = IAggregator(multiply).latestRoundData();\\n            price = price.mul(uint256(priceC));\\n        } else {\\n            price = price.mul(1e18);\\n        }\\n\\n        if (divide != address(0)) {\\n            // We only care about the second value - the price\\n            (, int256 priceC,,,) = IAggregator(divide).latestRoundData();\\n            price = price / uint256(priceC);\\n        }\\n\\n        return price / decimals;\\n    }\\n\\n    function getDataParameter(address multiply, address divide, uint256 decimals) public pure returns (bytes memory) {\\n        return abi.encode(multiply, divide, decimals);\\n    }\\n\\n    // Get the latest exchange rate\\n    function get(bytes calldata data) public override returns (bool, uint256) {\\n        (address multiply, address divide, uint256 decimals) = abi.decode(data, (address, address, uint256));\\n        return (true, _get(multiply, divide, decimals));\\n    }\\n\\n    // Check the last exchange rate without any state changes\\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\\n        (address multiply, address divide, uint256 decimals) = abi.decode(data, (address, address, uint256));\\n        return (true, _get(multiply, divide, decimals));\\n    }\\n\\n    function name(bytes calldata) public override view returns (string memory) {\\n        return \\\"Chainlink\\\";\\n    }\\n\\n    function symbol(bytes calldata) public override view returns (string memory) {\\n        return \\\"LINK\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/OracleMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\nimport \\\"../libraries/BoringMath.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\n\\n// WARNING: This oracle is only for testing, please use PeggedOracle for a fixed value oracle\\ncontract OracleMock is IOracle {\\n\\tusing BoringMath for uint256;\\n\\n\\tuint256 rate;\\n\\n\\tfunction set(uint256 rate_, address) public {\\n\\t\\t// The rate can be updated.\\n\\t\\trate = rate_;\\n\\t}\\n\\n\\tfunction getDataParameter() public pure returns (bytes memory) {\\n\\t\\treturn abi.encode(\\\"0x0\\\");\\n\\t}\\n\\n\\t// Get the latest exchange rate\\n\\tfunction get(bytes calldata) public override returns (bool, uint256) {\\n\\t\\treturn (true, rate);\\n\\t}\\n\\n\\t// Check the last exchange rate without any state changes\\n\\tfunction peek(bytes calldata) public view override returns (bool, uint256) {\\n\\t\\treturn (true, rate);\\n\\t}\\n\\n\\tfunction name(bytes calldata) public view override returns (string memory) {\\n\\t\\treturn \\\"Test\\\";\\n\\t}\\n\\n\\tfunction symbol(bytes calldata) public view override returns (string memory) {\\n\\t\\treturn \\\"TEST\\\";\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/BentoHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./interfaces/ILendingPair.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\n\\ncontract BentoHelper {\\n    struct PairInfo {\\n        ILendingPair pair;\\n        IOracle oracle;\\n        IBentoBox bentoBox;\\n        address masterContract;\\n        bool masterContractApproved;\\n        IERC20 tokenAsset;\\n        IERC20 tokenCollateral;\\n\\n        uint256 latestExchangeRate;\\n        uint256 lastBlockAccrued;\\n        uint256 interestRate;\\n        uint256 totalCollateralAmount;\\n        uint256 totalAssetAmount;\\n        uint256 totalBorrowAmount;\\n\\n        uint256 totalAssetFraction;\\n        uint256 totalBorrowFraction;\\n\\n        uint256 interestPerBlock;\\n\\n        uint256 feesPendingAmount;\\n\\n        uint256 userCollateralAmount;\\n        uint256 userAssetFraction;\\n        uint256 userAssetAmount;\\n        uint256 userBorrowFraction;\\n        uint256 userBorrowAmount;\\n\\n        uint256 userAssetBalance;\\n        uint256 userCollateralBalance;\\n        uint256 userAssetAllowance;\\n        uint256 userCollateralAllowance;\\n    }\\n\\n    function getPairs(address user, ILendingPair[] calldata pairs) public view returns (PairInfo[] memory info) {\\n        info = new PairInfo[](pairs.length);\\n        for(uint256 i = 0; i < pairs.length; i++) {\\n            ILendingPair pair = pairs[i];\\n            info[i].pair = pair;\\n            info[i].oracle = pair.oracle();\\n            IBentoBox bentoBox = pair.bentoBox();\\n            info[i].bentoBox = bentoBox;\\n            info[i].masterContract = address(pair.masterContract());\\n            info[i].masterContractApproved = bentoBox.masterContractApproved(info[i].masterContract, user);\\n            IERC20 asset = pair.asset();\\n            info[i].tokenAsset = asset;\\n            IERC20 collateral = pair.collateral();\\n            info[i].tokenCollateral = collateral;\\n\\n            (, info[i].latestExchangeRate) = pair.peekExchangeRate();\\n            (info[i].interestPerBlock, info[i].lastBlockAccrued, info[i].feesPendingAmount) = pair.accrueInfo();\\n            info[i].totalCollateralAmount = pair.totalCollateralAmount();\\n            (info[i].totalAssetAmount, info[i].totalAssetFraction ) = pair.totalAsset();\\n            (info[i].totalBorrowAmount, info[i].totalBorrowFraction) = pair.totalBorrow();\\n\\n            info[i].userCollateralAmount = pair.userCollateralAmount(user);\\n            info[i].userAssetFraction = pair.balanceOf(user);\\n            info[i].userAssetAmount = info[i].totalAssetFraction == 0 ? 0 :\\n                 info[i].userAssetFraction * info[i].totalAssetAmount / info[i].totalAssetFraction;\\n            info[i].userBorrowFraction = pair.userBorrowFraction(user);\\n            info[i].userBorrowAmount = info[i].totalBorrowFraction == 0 ? 0 :\\n                info[i].userBorrowFraction * info[i].totalBorrowAmount / info[i].totalBorrowFraction;\\n\\n            info[i].userAssetBalance = info[i].tokenAsset.balanceOf(user);\\n            info[i].userCollateralBalance = info[i].tokenCollateral.balanceOf(user);\\n            info[i].userAssetAllowance = info[i].tokenAsset.allowance(user, address(bentoBox));\\n            info[i].userCollateralAllowance = info[i].tokenCollateral.allowance(user, address(bentoBox));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ERC20Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../ERC20.sol\\\";\\n\\ncontract ERC20Mock is ERC20 {\\n\\tuint256 public totalSupply;\\n\\n\\tconstructor(uint256 _initialAmount) public {\\n\\t\\t// Give the creator all initial tokens\\n\\t\\tbalanceOf[msg.sender] = _initialAmount;\\n\\t\\t// Update total supply\\n\\t\\ttotalSupply = _initialAmount;\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"\": {\r\n        \"__CACHE_BREAKER__\": \"0x00000000d41867734bbee4c6863d9255b2b06ac1\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"WethToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masterContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cloneAddress\",\"type\":\"address\"}],\"name\":\"LogDeploy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masterContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"LogSetMasterContractApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WethToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"},{\"internalType\":\"bool\",\"name\":\"revertOnFail\",\"type\":\"bool\"}],\"name\":\"batch\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"successes\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"masterContractApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"masterContractOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"masterContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setMasterContractApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setMasterContractApprovalFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skimETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skimETHTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skimTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferMultipleFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipDirect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"whitelistMasterContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedMasterContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BentoBox","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}