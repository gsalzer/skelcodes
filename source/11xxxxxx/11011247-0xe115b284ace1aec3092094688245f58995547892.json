{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with buidler v1.4.1 https://buidler.dev\r\n\r\n// File contracts/MetaMultiSigWallet.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// started from https://solidity-by-example.org/0.6/app/multi-sig-wallet/ and cleaned out a bunch of stuff\r\n// grabbed recover stuff from bouncer-proxy: https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\r\n// after building this I found https://github.com/christianlundkvist/simple-multisig/blob/master/contracts/SimpleMultiSig.sol which is amazing and he even has the duplicate guard the same (Scott B schooled me on that!)\r\npragma solidity ^0.6.10;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract MetaMultiSigWallet {\r\n    event Deposit(address indexed sender, uint amount, uint balance);\r\n    event ExecuteTransaction( address indexed owner, address payable to, uint256 value, bytes data, uint256 nonce, bytes32 hash, bytes result);\r\n    event Owner( address indexed owner, bool added);\r\n\r\n    mapping(address => bool) public isOwner;\r\n    uint public signaturesRequired;\r\n    uint public nonce;\r\n    uint public chainId;\r\n\r\n    constructor(address[] memory _owners, uint _signaturesRequired, uint _chainId) public {\r\n        require(_signaturesRequired>0,\"constructor: must be non-zero sigs required\");\r\n        signaturesRequired = _signaturesRequired;\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            address owner = _owners[i];\r\n            require(owner!=address(0), \"constructor: zero address\");\r\n            require(!isOwner[owner], \"constructor: owner not unique\");\r\n            isOwner[owner] = true;\r\n            emit Owner(owner,isOwner[owner]);\r\n        }\r\n        chainId = _chainId;\r\n    }\r\n\r\n    modifier onlySelf() {\r\n        require(msg.sender == address(this), \"Not Self\");\r\n        _;\r\n    }\r\n\r\n    function addSigner(address newSigner, uint256 newSignaturesRequired) public onlySelf {\r\n        require(newSigner!=address(0), \"addSigner: zero address\");\r\n        require(!isOwner[newSigner], \"addSigner: owner not unique\");\r\n        require(newSignaturesRequired>0,\"addSigner: must be non-zero sigs required\");\r\n        isOwner[newSigner] = true;\r\n        signaturesRequired = newSignaturesRequired;\r\n        emit Owner(newSigner,isOwner[newSigner]);\r\n    }\r\n\r\n    function removeSigner(address oldSigner, uint256 newSignaturesRequired) public onlySelf {\r\n        require(isOwner[oldSigner], \"removeSigner: not owner\");\r\n        require(newSignaturesRequired>0,\"removeSigner: must be non-zero sigs required\");\r\n        isOwner[oldSigner] = false;\r\n        signaturesRequired = newSignaturesRequired;\r\n        emit Owner(oldSigner,isOwner[oldSigner]);\r\n    }\r\n\r\n    function updateSignaturesRequired(uint256 newSignaturesRequired) public onlySelf {\r\n        require(newSignaturesRequired>0,\"updateSignaturesRequired: must be non-zero sigs required\");\r\n        signaturesRequired = newSignaturesRequired;\r\n    }\r\n\r\n    function getTransactionHash( uint256 _nonce, address to, uint256 value, bytes memory data ) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(chainId,address(this),_nonce,to,value,data));\r\n    }\r\n\r\n    function executeTransaction( address payable to, uint256 value, bytes memory data, bytes[] memory signatures)\r\n        public\r\n        returns (bytes memory)\r\n    {\r\n        require(isOwner[msg.sender], \"executeTransaction: only owners can execute\");\r\n        bytes32 _hash =  getTransactionHash(nonce, to, value, data);\r\n        nonce++;\r\n        uint256 validSignatures;\r\n        address duplicateGuard;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            address recovered = recover(_hash,signatures[i]);\r\n            require(recovered>duplicateGuard, \"executeTransaction: duplicate or unordered signatures\");\r\n            duplicateGuard = recovered;\r\n            if(isOwner[recovered]){\r\n              validSignatures++;\r\n            }\r\n        }\r\n\r\n        require(validSignatures>=signaturesRequired, \"executeTransaction: not enough valid signatures\");\r\n\r\n        (bool success, bytes memory result) = to.call{value: value}(data);\r\n        require(success, \"executeTransaction: tx failed\");\r\n\r\n        emit ExecuteTransaction(msg.sender, to, value, data, nonce-1, _hash, result);\r\n        return result;\r\n    }\r\n\r\n    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        // Divide the signature in r, s and v variables (spends extra gas, you could split off-chain)\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := byte(0, mload(add(_signature, 96)))\r\n        }\r\n        return ecrecover(keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\r\n        ), v, r, s);\r\n    }\r\n\r\n    receive() payable external {\r\n        emit Deposit(msg.sender, msg.value, address(this).balance);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_signaturesRequired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"ExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"added\",\"type\":\"bool\"}],\"name\":\"Owner\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newSignaturesRequired\",\"type\":\"uint256\"}],\"name\":\"addSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldSigner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newSignaturesRequired\",\"type\":\"uint256\"}],\"name\":\"removeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signaturesRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSignaturesRequired\",\"type\":\"uint256\"}],\"name\":\"updateSignaturesRequired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MetaMultiSigWallet","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d75b0609ed51307e13bae0f9394b5f63a7f8b6a100000000000000000000000034aa3f359a9d614239015126635ce7732c18fdf3","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eaff66b448c480c44a39af97c679ac14b864aba424a262e66b36febbcc828558"}]}