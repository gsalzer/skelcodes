{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/X2ETHMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./libraries/math/SafeMath.sol\\\";\\nimport \\\"./libraries/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/token/IERC20.sol\\\";\\n\\nimport \\\"./interfaces/IX2ETHFactory.sol\\\";\\nimport \\\"./interfaces/IX2PriceFeed.sol\\\";\\nimport \\\"./interfaces/IX2Token.sol\\\";\\nimport \\\"./interfaces/IX2Market.sol\\\";\\nimport \\\"./interfaces/IChi.sol\\\";\\n\\ncontract X2ETHMarket is ReentrancyGuard, IX2Market {\\n    using SafeMath for uint256;\\n\\n    // use a single storage slot\\n    // max uint64 has 19 digits so it can support the INITIAL_REBASE_DIVISOR\\n    // increasing by 10^9 times\\n    uint64 public override previousBullDivisor;\\n    uint64 public override previousBearDivisor;\\n    uint64 public override cachedBullDivisor;\\n    uint64 public override cachedBearDivisor;\\n\\n    // use a single storage slot\\n    // max uint176 can store prices up to 52 digits\\n    uint176 public override lastPrice;\\n    uint80 public lastRound;\\n\\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\\n    // X2Token.balance uses uint128, max uint128 has 38 digits\\n    // with an initial rebase divisor of 10^10\\n    // and 18 decimals for ETH, collateral of up to 10 billion ETH\\n    // can be supported\\n    uint64 public constant INITIAL_REBASE_DIVISOR = 10**10;\\n    uint256 public constant MAX_DIVISOR = uint64(-1);\\n    int256 public constant MAX_PRICE = uint176(-1);\\n\\n    uint256 public constant MAX_FUNDING_POINTS = 100; // 0.1%\\n    uint256 public constant FUNDING_POINTS_DIVISOR = 100000;\\n    uint256 public constant MIN_FUNDING_INTERVAL = 30 minutes;\\n\\n    address public override bullToken;\\n    address public override bearToken;\\n    address public priceFeed;\\n    uint256 public multiplierBasisPoints;\\n    uint256 public maxProfitBasisPoints;\\n    uint256 public feeReserve;\\n\\n    address public factory;\\n    IChi public chi;\\n\\n    uint256 public fundingPoints;\\n    uint256 public fundingInterval;\\n    uint256 public lastFundingTime;\\n\\n    bool public isInitialized;\\n\\n    event DistributeFees(address feeReceiver, uint256 amount);\\n    event DistributeInterest(address feeReceiver, uint256 amount);\\n    event Rebase(uint256 price, uint64 bullDivisor, uint64 bearDivisor);\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == factory, \\\"X2ETHMarket: forbidden\\\");\\n        _;\\n    }\\n\\n    modifier discountCHI {\\n        uint256 gasStart = gasleft();\\n        _;\\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *\\n                           msg.data.length;\\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\\n    }\\n\\n    function initialize(\\n        address _factory,\\n        address _priceFeed,\\n        uint256 _multiplierBasisPoints,\\n        uint256 _maxProfitBasisPoints\\n    ) public {\\n        require(!isInitialized, \\\"X2ETHMarket: already initialized\\\");\\n        require(_maxProfitBasisPoints <= BASIS_POINTS_DIVISOR, \\\"X2ETHMarket: maxProfitBasisPoints limit exceeded\\\");\\n        isInitialized = true;\\n\\n        factory = _factory;\\n        priceFeed = _priceFeed;\\n        multiplierBasisPoints = _multiplierBasisPoints;\\n        maxProfitBasisPoints = _maxProfitBasisPoints;\\n\\n        lastPrice = uint176(latestPrice());\\n        require(lastPrice != 0, \\\"X2ETHMarket: unsupported price feed\\\");\\n    }\\n\\n    function setFunding(uint256 _fundingPoints, uint256 _fundingInterval) public override onlyFactory {\\n        require(_fundingPoints <= MAX_FUNDING_POINTS, \\\"X2ETHMarket: fundingPoints exceeds limit\\\");\\n        require(_fundingInterval >= MIN_FUNDING_INTERVAL, \\\"X2ETHMarket: fundingInterval below limit\\\");\\n\\n        fundingPoints = _fundingPoints;\\n        fundingInterval = _fundingInterval;\\n    }\\n\\n    function setBullToken(address _bullToken) public onlyFactory {\\n        require(bullToken == address(0), \\\"X2ETHMarket: bullToken already set\\\");\\n        bullToken = _bullToken;\\n        cachedBullDivisor = INITIAL_REBASE_DIVISOR;\\n        previousBullDivisor = INITIAL_REBASE_DIVISOR;\\n    }\\n\\n    function setBearToken(address _bearToken) public onlyFactory {\\n        require(bearToken == address(0), \\\"X2ETHMarket: bearToken already set\\\");\\n        bearToken = _bearToken;\\n        cachedBearDivisor = INITIAL_REBASE_DIVISOR;\\n        previousBearDivisor = INITIAL_REBASE_DIVISOR;\\n    }\\n\\n    function setChi(IChi _chi) public onlyFactory {\\n        chi = _chi;\\n    }\\n\\n    function buy(address _token, address _receiver) public payable nonReentrant returns (uint256) {\\n        return _buy(_token, _receiver);\\n    }\\n\\n    function buyUsingChi(address _token, address _receiver) public payable nonReentrant discountCHI returns (uint256) {\\n        return _buy(_token, _receiver);\\n    }\\n\\n    function sell(address _token, uint256 _amount, address _receiver) public nonReentrant returns (uint256) {\\n        return _sell(_token, _amount, _receiver, true);\\n    }\\n\\n    function sellUsingChi(address _token, uint256 _amount, address _receiver) public nonReentrant discountCHI returns (uint256) {\\n        return _sell(_token, _amount, _receiver, true);\\n    }\\n\\n    function sellAll(address _token, address _receiver) public nonReentrant returns (uint256) {\\n        uint256 amount = IERC20(_token).balanceOf(msg.sender);\\n        return _sell(_token, amount, _receiver, true);\\n    }\\n\\n    function sellAllUsingChi(address _token, address _receiver) public nonReentrant discountCHI returns (uint256) {\\n        uint256 amount = IERC20(_token).balanceOf(msg.sender);\\n        return _sell(_token, amount, _receiver, true);\\n    }\\n\\n    // since an X2Token's distributor can be set by the factory's gov,\\n    // the market should allow an option to sell the token without invoking\\n    // the distributor\\n    // this ensures that tokens can always be sold even if the distributor\\n    // is set to an address that intentionally fails when `distribute` is called\\n    function sellWithoutDistribution(address _token, uint256 _amount, address _receiver) public nonReentrant returns (uint256) {\\n        return _sell(_token, _amount, _receiver, false);\\n    }\\n\\n    function rebase() public returns (bool) {\\n        uint256 _lastPrice = uint256(lastPrice);\\n        uint256 nextPrice = latestPrice();\\n        uint80 _latestRound = latestRound();\\n        uint256 _lastRound = lastRound;\\n        if (_latestRound == _lastRound) { return false; }\\n\\n        (uint256 _cachedBullDivisor, uint256 _cachedBearDivisor) = getDivisors(_lastPrice, nextPrice);\\n        _updateLastFundingTime();\\n\\n        // the latest round is just one after the last recorded round\\n        // so update the previous divisors to the cached divisors\\n        // and update the cached divisors to the latest divisors\\n        if (_latestRound == _lastRound + 1) {\\n            lastPrice = uint176(nextPrice);\\n            lastRound = _latestRound;\\n            previousBullDivisor = cachedBullDivisor;\\n            previousBearDivisor = cachedBearDivisor;\\n            cachedBullDivisor = uint64(_cachedBullDivisor);\\n            cachedBearDivisor = uint64(_cachedBearDivisor);\\n\\n            emit Rebase(nextPrice, uint64(_cachedBullDivisor), uint64(_cachedBearDivisor));\\n            return true;\\n        }\\n\\n        // if the previous price cannot be retrieved then\\n        // update the previous divisors to the cached divisors\\n        // and update the cached divisors to the latest divisors\\n        (bool ok, uint256 previousPrice) = getRoundPrice(_latestRound - 1);\\n        if (!ok) {\\n            lastPrice = uint176(nextPrice);\\n            lastRound = _latestRound;\\n            previousBullDivisor = cachedBullDivisor;\\n            previousBearDivisor = cachedBearDivisor;\\n            cachedBullDivisor = uint64(_cachedBullDivisor);\\n            cachedBearDivisor = uint64(_cachedBearDivisor);\\n            emit Rebase(nextPrice, uint64(_cachedBullDivisor), uint64(_cachedBearDivisor));\\n            return false;\\n        }\\n\\n        (uint256 _previousBullDivisor, uint256 _previousBearDivisor) = getDivisors(_lastPrice, previousPrice);\\n\\n        lastPrice = uint176(nextPrice);\\n        lastRound = _latestRound;\\n        previousBullDivisor = uint64(_previousBullDivisor);\\n        previousBearDivisor = uint64(_previousBearDivisor);\\n        cachedBullDivisor = uint64(_cachedBullDivisor);\\n        cachedBearDivisor = uint64(_cachedBearDivisor);\\n        emit Rebase(nextPrice, uint64(_cachedBullDivisor), uint64(_cachedBearDivisor));\\n        return true;\\n    }\\n\\n    function distributeFees() public nonReentrant returns (uint256) {\\n        address feeReceiver = IX2ETHFactory(factory).feeReceiver();\\n        require(feeReceiver != address(0), \\\"X2Market: empty feeReceiver\\\");\\n\\n        uint256 fees = feeReserve;\\n        feeReserve = 0;\\n\\n        (bool success,) = feeReceiver.call{value: fees}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        emit DistributeFees(feeReceiver, fees);\\n\\n        return fees;\\n    }\\n\\n    function distributeInterest() public nonReentrant returns (uint256) {\\n        address feeReceiver = IX2ETHFactory(factory).feeReceiver();\\n        require(feeReceiver != address(0), \\\"X2Market: empty feeReceiver\\\");\\n\\n        uint256 interest = interestReserve();\\n\\n        (bool success,) = feeReceiver.call{value: interest}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        emit DistributeInterest(feeReceiver, interest);\\n\\n        return interest;\\n    }\\n\\n    function interestReserve() public view returns (uint256) {\\n        uint256 bullRefSupply = IX2Token(bullToken)._totalSupply();\\n        uint256 bearRefSupply = IX2Token(bearToken)._totalSupply();\\n\\n        // the actual underlying supplies\\n        uint256 totalBulls = bullRefSupply.div(cachedBullDivisor);\\n        uint256 totalBears = bearRefSupply.div(cachedBearDivisor);\\n\\n        uint256 balance = address(this).balance;\\n        return balance.sub(totalBulls).sub(totalBears).sub(feeReserve);\\n    }\\n\\n    function getDivisor(address _token) public override view returns (uint256) {\\n        uint80 _lastRound = lastRound;\\n        uint80 _latestRound = latestRound();\\n        bool isBull = _token == bullToken;\\n\\n        // if the latest round is the same as the last recorded round\\n        // then select the largest divisor from the previous and cached divisors\\n        if (_latestRound == _lastRound) {\\n            return isBull ? _max(previousBullDivisor, cachedBullDivisor) : _max(previousBearDivisor, cachedBearDivisor);\\n        }\\n\\n        uint256 _lastPrice = uint256(lastPrice);\\n        uint256 nextPrice = latestPrice();\\n        (uint256 nextBullDivisor, uint256 nextBearDivisor) = getDivisors(_lastPrice, nextPrice);\\n\\n        // if the latest round is just after the last recorded round\\n        // then select the largest divisor from the cached divisor and the\\n        // divisor for the next price\\n        if (_latestRound == _lastRound + 1) {\\n            return isBull ? _max(cachedBullDivisor, nextBullDivisor) : _max(cachedBearDivisor, nextBearDivisor);\\n        }\\n\\n        (bool ok, uint256 previousPrice) = getRoundPrice(_latestRound - 1);\\n        // if the price just before the lastest round cannot be retrieved\\n        // then fallback to selecting the largest divisor from the cached divisor\\n        // and the divisor for the next price\\n        if (!ok) {\\n            return isBull ? _max(cachedBullDivisor, nextBullDivisor) : _max(cachedBearDivisor, nextBearDivisor);\\n        }\\n\\n        (uint256 _previousBullDivisor, uint256 _previousBearDivisor) = getDivisors(_lastPrice, previousPrice);\\n        return isBull ? _max(_previousBullDivisor, nextBullDivisor) : _max(_previousBearDivisor, nextBearDivisor);\\n    }\\n\\n    function getRoundPrice(uint80 round) public view returns (bool, uint256) {\\n        address _priceFeed = priceFeed;\\n        (, int256 price, , ,) = IX2PriceFeed(_priceFeed).getRoundData(round);\\n        if (price <= 0 || price > MAX_PRICE) {\\n            return (false, 0);\\n        }\\n\\n        return (true, uint256(price));\\n    }\\n\\n    function latestPrice() public override view returns (uint256) {\\n        int256 answer = IX2PriceFeed(priceFeed).latestAnswer();\\n        // avoid negative, zero or overflow values being returned\\n        if (answer <= 0 || answer > MAX_PRICE) {\\n            return uint256(lastPrice);\\n        }\\n        return uint256(answer);\\n    }\\n\\n    function latestRound() public view returns (uint80) {\\n        return IX2PriceFeed(priceFeed).latestRound();\\n    }\\n\\n    function getDivisors(uint256 _lastPrice, uint256 _nextPrice) public override view returns (uint256, uint256) {\\n        uint256 bullRefSupply = IX2Token(bullToken)._totalSupply();\\n        uint256 bearRefSupply = IX2Token(bearToken)._totalSupply();\\n\\n        // the actual underlying supplies\\n        uint256 totalBulls = bullRefSupply.div(cachedBullDivisor);\\n        uint256 totalBears = bearRefSupply.div(cachedBearDivisor);\\n\\n        // scope variables to avoid stack too deep errors\\n        {\\n        // refSupply is the smaller of the two supplies\\n        uint256 refSupply = totalBulls < totalBears ? totalBulls : totalBears;\\n        uint256 delta = _nextPrice > _lastPrice ? _nextPrice.sub(_lastPrice) : _lastPrice.sub(_nextPrice);\\n        // profit is [(smaller supply) * (change in price) / (last price)] * multiplierBasisPoints\\n        uint256 profit = refSupply.mul(delta).div(_lastPrice).mul(multiplierBasisPoints).div(BASIS_POINTS_DIVISOR);\\n\\n        // cap the profit to the (max profit percentage) of the smaller supply\\n        uint256 maxProfit = refSupply.mul(maxProfitBasisPoints).div(BASIS_POINTS_DIVISOR);\\n        if (profit > maxProfit) { profit = maxProfit; }\\n\\n        totalBulls = _nextPrice > _lastPrice ? totalBulls.add(profit) : totalBulls.sub(profit);\\n        totalBears = _nextPrice > _lastPrice ? totalBears.sub(profit) : totalBears.add(profit);\\n        }\\n\\n        if (fundingPoints > 0 && fundingInterval > 0) {\\n            uint256 intervals = block.timestamp.sub(lastFundingTime).div(fundingInterval);\\n            if (intervals > 0) {\\n                if (totalBulls > totalBears) {\\n                    totalBulls = totalBulls.sub(totalBulls.mul(intervals).mul(fundingPoints).div(FUNDING_POINTS_DIVISOR));\\n                } else {\\n                    totalBears = totalBears.sub(totalBears.mul(intervals).mul(fundingPoints).div(FUNDING_POINTS_DIVISOR));\\n                }\\n            }\\n        }\\n\\n        return (_getNextDivisor(bullRefSupply, totalBulls, cachedBullDivisor), _getNextDivisor(bearRefSupply, totalBears, cachedBearDivisor));\\n    }\\n\\n    function _updateLastFundingTime() private {\\n        if (fundingPoints > 0 && fundingInterval > 0) {\\n            lastFundingTime = block.timestamp;\\n        }\\n    }\\n\\n    function _max(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function _getNextDivisor(uint256 _refSupply, uint256 _nextSupply, uint256 _fallbackDivisor) private pure returns (uint256) {\\n        if (_nextSupply == 0) {\\n            return INITIAL_REBASE_DIVISOR;\\n        }\\n\\n        // round up the divisor\\n        uint256 divisor = _refSupply.mul(10).div(_nextSupply).add(9).div(10);\\n        // prevent the cachedDivisor from overflowing or being set to 0\\n        if (divisor == 0 || divisor > MAX_DIVISOR) { return _fallbackDivisor; }\\n\\n        return divisor;\\n    }\\n\\n    function _collectFees(uint256 _amount) private returns (uint256) {\\n        uint256 fee = IX2ETHFactory(factory).getFee(address(this), _amount);\\n        if (fee == 0) { return 0; }\\n\\n        feeReserve = feeReserve.add(fee);\\n        return fee;\\n    }\\n\\n    function _buy(address _token, address _receiver) private returns (uint256) {\\n        bool isBull = _token == bullToken;\\n        require(isBull || _token == bearToken, \\\"X2ETHMarket: unsupported token\\\");\\n        uint256 amount = msg.value;\\n        require(amount > 0, \\\"X2ETHMarket: insufficient collateral sent\\\");\\n\\n        rebase();\\n\\n        uint256 fee = _collectFees(amount);\\n        uint256 depositAmount = amount.sub(fee);\\n        IX2Token(_token).mint(_receiver, depositAmount, isBull ? cachedBullDivisor : cachedBearDivisor);\\n\\n        return depositAmount;\\n    }\\n\\n    function _sell(address _token, uint256 _amount, address _receiver, bool distribute) private returns (uint256) {\\n        require(_token == bullToken || _token == bearToken, \\\"X2ETHMarket: unsupported token\\\");\\n        rebase();\\n\\n        IX2Token(_token).burn(msg.sender, _amount, distribute);\\n\\n        uint256 fee = _collectFees(_amount);\\n        uint256 withdrawAmount = _amount.sub(fee);\\n        (bool success,) = _receiver.call{value: withdrawAmount}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        return withdrawAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2ETHFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2ETHFactory {\\n    function feeReceiver() external view returns (address);\\n    function getFee(address market, uint256 amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2PriceFeed {\\n    function latestAnswer() external view returns (int256);\\n    function latestRound() external view returns (uint80);\\n    function getRoundData(uint80 roundId) external view returns (uint80, int256, uint256, uint256, uint80);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2Token {\\n    function distributor() external view returns (address);\\n    function _totalSupply() external view returns (uint256);\\n    function _balanceOf(address account) external view returns (uint256);\\n    function market() external view returns (address);\\n    function getDivisor() external view returns (uint256);\\n    function getReward(address account) external view returns (uint256);\\n    function costOf(address account) external view returns (uint256);\\n    function mint(address account, uint256 amount, uint256 divisor) external;\\n    function burn(address account, uint256 amount, bool distribute) external;\\n    function setDistributor(address _distributor) external;\\n    function setInfo(string memory name, string memory symbol) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2Market {\\n    function bullToken() external view returns (address);\\n    function bearToken() external view returns (address);\\n    function latestPrice() external view returns (uint256);\\n    function lastPrice() external view returns (uint176);\\n    function getDivisor(address token) external view returns (uint256);\\n    function getDivisors(uint256 _lastPrice, uint256 _nextPrice) external view returns (uint256, uint256);\\n    function setFunding(uint256 fundingPoints, uint256 fundingInterval) external;\\n    function previousBullDivisor() external view returns (uint64);\\n    function previousBearDivisor() external view returns (uint64);\\n    function cachedBullDivisor() external view returns (uint64);\\n    function cachedBearDivisor() external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IChi {\\n    function freeFromUpTo(address from, uint256 value) external returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"bullDivisor\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"bearDivisor\",\"type\":\"uint64\"}],\"name\":\"Rebase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASIS_POINTS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUNDING_POINTS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_REBASE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FUNDING_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FUNDING_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bearToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bullToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"buyUsingChi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cachedBearDivisor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cachedBullDivisor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chi\",\"outputs\":[{\"internalType\":\"contract IChi\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"name\":\"getDivisors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"round\",\"type\":\"uint80\"}],\"name\":\"getRoundPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_multiplierBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxProfitBasisPoints\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastFundingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"internalType\":\"uint176\",\"name\":\"\",\"type\":\"uint176\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRound\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProfitBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplierBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousBearDivisor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousBullDivisor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"sellAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"sellAllUsingChi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"sellUsingChi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"sellWithoutDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bearToken\",\"type\":\"address\"}],\"name\":\"setBearToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bullToken\",\"type\":\"address\"}],\"name\":\"setBullToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IChi\",\"name\":\"_chi\",\"type\":\"address\"}],\"name\":\"setChi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fundingPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fundingInterval\",\"type\":\"uint256\"}],\"name\":\"setFunding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"X2ETHMarket","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}