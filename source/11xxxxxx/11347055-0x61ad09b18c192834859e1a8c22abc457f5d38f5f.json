{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/helpers/ERC20Like.sol\r\n\r\n// SPDX-License-Identifier: bsl-1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\ninterface ERC20Like {\r\n    function balanceOf(address) external view returns (uint);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/helpers/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.7.1;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () public {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/SafeMath.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/VaultParameters.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title Auth\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n * @dev Manages USDP's system access\r\n **/\r\ncontract Auth {\r\n\r\n    // address of the the contract with vault parameters\r\n    VaultParameters public vaultParameters;\r\n\r\n    constructor(address _parameters) public {\r\n        vaultParameters = VaultParameters(_parameters);\r\n    }\r\n\r\n    // ensures tx's sender is a manager\r\n    modifier onlyManager() {\r\n        require(vaultParameters.isManager(msg.sender), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // ensures tx's sender is able to modify the Vault\r\n    modifier hasVaultAccess() {\r\n        require(vaultParameters.canModifyVault(msg.sender), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // ensures tx's sender is the Vault\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultParameters.vault(), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title VaultParameters\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n **/\r\ncontract VaultParameters is Auth {\r\n\r\n    // map token to stability fee percentage; 3 decimals\r\n    mapping(address => uint) public stabilityFee;\r\n\r\n    // map token to liquidation fee percentage, 0 decimals\r\n    mapping(address => uint) public liquidationFee;\r\n\r\n    // map token to USDP mint limit\r\n    mapping(address => uint) public tokenDebtLimit;\r\n\r\n    // permissions to modify the Vault\r\n    mapping(address => bool) public canModifyVault;\r\n\r\n    // managers\r\n    mapping(address => bool) public isManager;\r\n\r\n    // enabled oracle types\r\n    mapping(uint => mapping (address => bool)) public isOracleTypeEnabled;\r\n\r\n    // address of the Vault\r\n    address payable public vault;\r\n\r\n    // The foundation address\r\n    address public foundation;\r\n\r\n    /**\r\n     * The address for an Ethereum contract is deterministically computed from the address of its creator (sender)\r\n     * and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then\r\n     * hashed with Keccak-256.\r\n     * Therefore, the Vault address can be pre-computed and passed as an argument before deployment.\r\n    **/\r\n    constructor(address payable _vault, address _foundation) public Auth(address(this)) {\r\n        require(_vault != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(_foundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        isManager[msg.sender] = true;\r\n        vault = _vault;\r\n        foundation = _foundation;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Grants and revokes manager's status of any address\r\n     * @param who The target address\r\n     * @param permit The permission flag\r\n     **/\r\n    function setManager(address who, bool permit) external onlyManager {\r\n        isManager[who] = permit;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the foundation address\r\n     * @param newFoundation The new foundation address\r\n     **/\r\n    function setFoundation(address newFoundation) external onlyManager {\r\n        require(newFoundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        foundation = newFoundation;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets ability to use token as the main collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\r\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\r\n     * @param usdpLimit The USDP token issue limit\r\n     * @param oracles The enables oracle types\r\n     **/\r\n    function setCollateral(\r\n        address asset,\r\n        uint stabilityFeeValue,\r\n        uint liquidationFeeValue,\r\n        uint usdpLimit,\r\n        uint[] calldata oracles\r\n    ) external onlyManager {\r\n        setStabilityFee(asset, stabilityFeeValue);\r\n        setLiquidationFee(asset, liquidationFeeValue);\r\n        setTokenDebtLimit(asset, usdpLimit);\r\n        for (uint i=0; i < oracles.length; i++) {\r\n            setOracleType(oracles[i], asset, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets a permission for an address to modify the Vault\r\n     * @param who The target address\r\n     * @param permit The permission flag\r\n     **/\r\n    function setVaultAccess(address who, bool permit) external onlyManager {\r\n        canModifyVault[who] = permit;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage of the year stability fee for a particular collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The stability fee percentage (3 decimals)\r\n     **/\r\n    function setStabilityFee(address asset, uint newValue) public onlyManager {\r\n        stabilityFee[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage of the liquidation fee for a particular collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The liquidation fee percentage (0 decimals)\r\n     **/\r\n    function setLiquidationFee(address asset, uint newValue) public onlyManager {\r\n        require(newValue <= 100, \"Unit Protocol: VALUE_OUT_OF_RANGE\");\r\n        liquidationFee[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Enables/disables oracle types\r\n     * @param _type The type of the oracle\r\n     * @param asset The address of the main collateral token\r\n     * @param enabled The control flag\r\n     **/\r\n    function setOracleType(uint _type, address asset, bool enabled) public onlyManager {\r\n        isOracleTypeEnabled[_type][asset] = enabled;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets USDP limit for a specific collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param limit The limit number\r\n     **/\r\n    function setTokenDebtLimit(address asset, uint limit) public onlyManager {\r\n        tokenDebtLimit[asset] = limit;\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/TransferHelper.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n// File: contracts/USDP.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title USDP token implementation\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n * @dev ERC20 token\r\n **/\r\ncontract USDP is Auth {\r\n    using SafeMath for uint;\r\n\r\n    // name of the token\r\n    string public constant name = \"USDP Stablecoin\";\r\n\r\n    // symbol of the token\r\n    string public constant symbol = \"USDP\";\r\n\r\n    // version of the token\r\n    string public constant version = \"1\";\r\n\r\n    // number of decimals the token uses\r\n    uint8 public constant decimals = 18;\r\n\r\n    // total token supply\r\n    uint public totalSupply;\r\n\r\n    // balance information map\r\n    mapping(address => uint) public balanceOf;\r\n\r\n    // token allowance mapping\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    /**\r\n     * @dev Trigger on any successful call to approve(address spender, uint amount)\r\n    **/\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /**\r\n     * @dev Trigger when tokens are transferred, including zero value transfers\r\n    **/\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    /**\r\n      * @param _parameters The address of system parameters contract\r\n     **/\r\n    constructor(address _parameters) public Auth(_parameters) {}\r\n\r\n    /**\r\n      * @notice Only Vault can mint USDP\r\n      * @dev Mints 'amount' of tokens to address 'to', and MUST fire the\r\n      * Transfer event\r\n      * @param to The address of the recipient\r\n      * @param amount The amount of token to be minted\r\n     **/\r\n    function mint(address to, uint amount) external onlyVault {\r\n        require(to != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        balanceOf[to] = balanceOf[to].add(amount);\r\n        totalSupply = totalSupply.add(amount);\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /**\r\n      * @notice Only manager can burn tokens from manager's balance\r\n      * @dev Burns 'amount' of tokens, and MUST fire the Transfer event\r\n      * @param amount The amount of token to be burned\r\n     **/\r\n    function burn(uint amount) external onlyManager {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n      * @notice Only Vault can burn tokens from any balance\r\n      * @dev Burns 'amount' of tokens from 'from' address, and MUST fire the Transfer event\r\n      * @param from The address of the balance owner\r\n      * @param amount The amount of token to be burned\r\n     **/\r\n    function burn(address from, uint amount) external onlyVault {\r\n        _burn(from, amount);\r\n    }\r\n\r\n    /**\r\n      * @dev Transfers 'amount' of tokens to address 'to', and MUST fire the Transfer event. The\r\n      * function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n      * @param to The address of the recipient\r\n      * @param amount The amount of token to be transferred\r\n     **/\r\n    function transfer(address to, uint amount) external returns (bool) {\r\n        return transferFrom(msg.sender, to, amount);\r\n    }\r\n\r\n    /**\r\n      * @dev Transfers 'amount' of tokens from address 'from' to address 'to', and MUST fire the\r\n      * Transfer event\r\n      * @param from The address of the sender\r\n      * @param to The address of the recipient\r\n      * @param amount The amount of token to be transferred\r\n     **/\r\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\r\n        require(to != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(balanceOf[from] >= amount, \"Unit Protocol: INSUFFICIENT_BALANCE\");\r\n\r\n        if (from != msg.sender) {\r\n            require(allowance[from][msg.sender] >= amount, \"Unit Protocol: INSUFFICIENT_ALLOWANCE\");\r\n            _approve(from, msg.sender, allowance[from][msg.sender].sub(amount));\r\n        }\r\n        balanceOf[from] = balanceOf[from].sub(amount);\r\n        balanceOf[to] = balanceOf[to].add(amount);\r\n\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev Allows 'spender' to withdraw from your account multiple times, up to the 'amount' amount. If\r\n      * this function is called again it overwrites the current allowance with 'amount'.\r\n      * @param spender The address of the account able to transfer the tokens\r\n      * @param amount The amount of tokens to be approved for transfer\r\n     **/\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint amount) internal virtual {\r\n        require(owner != address(0), \"Unit Protocol: approve from the zero address\");\r\n        require(spender != address(0), \"Unit Protocol: approve to the zero address\");\r\n\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _burn(address from, uint amount) internal virtual {\r\n        balanceOf[from] = balanceOf[from].sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/IWETH.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n// File: contracts/Vault.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Vault\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n * @notice Vault is the core of Unit Protocol USDP Stablecoin system\r\n * @notice Vault stores and manages collateral funds of all positions and counts debts\r\n * @notice Only Vault can manage supply of USDP token\r\n * @notice Vault will not be changed/upgraded after initial deployment for the current stablecoin version\r\n **/\r\ncontract Vault is Auth {\r\n    using SafeMath for uint;\r\n\r\n    // COL token address\r\n    address public immutable col;\r\n\r\n    // WETH token address\r\n    address payable public immutable weth;\r\n\r\n    uint public constant DENOMINATOR_1E5 = 1e5;\r\n\r\n    uint public constant DENOMINATOR_1E2 = 1e2;\r\n\r\n    // USDP token address\r\n    address public immutable usdp;\r\n\r\n    // collaterals whitelist\r\n    mapping(address => mapping(address => uint)) public collaterals;\r\n\r\n    // COL token collaterals\r\n    mapping(address => mapping(address => uint)) public colToken;\r\n\r\n    // user debts\r\n    mapping(address => mapping(address => uint)) public debts;\r\n\r\n    // block number of liquidation trigger\r\n    mapping(address => mapping(address => uint)) public liquidationBlock;\r\n\r\n    // initial price of collateral\r\n    mapping(address => mapping(address => uint)) public liquidationPrice;\r\n\r\n    // debts of tokens\r\n    mapping(address => uint) public tokenDebts;\r\n\r\n    // stability fee pinned to each position\r\n    mapping(address => mapping(address => uint)) public stabilityFee;\r\n\r\n    // liquidation fee pinned to each position, 0 decimals\r\n    mapping(address => mapping(address => uint)) public liquidationFee;\r\n\r\n    // type of using oracle pinned for each position\r\n    mapping(address => mapping(address => uint)) public oracleType;\r\n\r\n    // timestamp of the last update\r\n    mapping(address => mapping(address => uint)) public lastUpdate;\r\n\r\n    modifier notLiquidating(address asset, address user) {\r\n        require(liquidationBlock[asset][user] == 0, \"Unit Protocol: LIQUIDATING_POSITION\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @param _parameters The address of the system parameters\r\n     * @param _col COL token address\r\n     * @param _usdp USDP token address\r\n     **/\r\n    constructor(address _parameters, address _col, address _usdp, address payable _weth) public Auth(_parameters) {\r\n        col = _col;\r\n        usdp = _usdp;\r\n        weth = _weth;\r\n    }\r\n\r\n    // only accept ETH via fallback from the WETH contract\r\n    receive() external payable {\r\n        require(msg.sender == weth, \"Unit Protocol: RESTRICTED\");\r\n    }\r\n\r\n    /**\r\n     * @dev Updates parameters of the position to the current ones\r\n     * @param asset The address of the main collateral token\r\n     * @param user The owner of a position\r\n     **/\r\n    function update(address asset, address user) public hasVaultAccess notLiquidating(asset, user) {\r\n\r\n        // calculate fee using stored stability fee\r\n        uint debtWithFee = getTotalDebt(asset, user);\r\n        tokenDebts[asset] = tokenDebts[asset].sub(debts[asset][user]).add(debtWithFee);\r\n        debts[asset][user] = debtWithFee;\r\n\r\n        stabilityFee[asset][user] = vaultParameters.stabilityFee(asset);\r\n        liquidationFee[asset][user] = vaultParameters.liquidationFee(asset);\r\n        lastUpdate[asset][user] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates new position for user\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param _oracleType The type of an oracle\r\n     **/\r\n    function spawn(address asset, address user, uint _oracleType) external hasVaultAccess notLiquidating(asset, user) {\r\n        oracleType[asset][user] = _oracleType;\r\n        delete liquidationBlock[asset][user];\r\n    }\r\n\r\n    /**\r\n     * @dev Clears unused storage variables\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     **/\r\n    function destroy(address asset, address user) public hasVaultAccess notLiquidating(asset, user) {\r\n        delete stabilityFee[asset][user];\r\n        delete oracleType[asset][user];\r\n        delete lastUpdate[asset][user];\r\n        delete liquidationFee[asset][user];\r\n    }\r\n\r\n    /**\r\n     * @notice Tokens must be pre-approved\r\n     * @dev Adds main collateral to a position\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of tokens to deposit\r\n     **/\r\n    function depositMain(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\r\n        collaterals[asset][user] = collaterals[asset][user].add(amount);\r\n        TransferHelper.safeTransferFrom(asset, user, address(this), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts ETH to WETH and adds main collateral to a position\r\n     * @param user The address of a position's owner\r\n     **/\r\n    function depositEth(address user) external payable notLiquidating(weth, user) {\r\n        IWETH(weth).deposit{value: msg.value}();\r\n        collaterals[weth][user] = collaterals[weth][user].add(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws main collateral from a position\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of tokens to withdraw\r\n     **/\r\n    function withdrawMain(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\r\n        collaterals[asset][user] = collaterals[asset][user].sub(amount);\r\n        TransferHelper.safeTransfer(asset, user, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws WETH collateral from a position converting WETH to ETH\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of ETH to withdraw\r\n     **/\r\n    function withdrawEth(address payable user, uint amount) external hasVaultAccess notLiquidating(weth, user) {\r\n        collaterals[weth][user] = collaterals[weth][user].sub(amount);\r\n        IWETH(weth).withdraw(amount);\r\n        TransferHelper.safeTransferETH(user, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Tokens must be pre-approved\r\n     * @dev Adds COL token to a position\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of tokens to deposit\r\n     **/\r\n    function depositCol(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\r\n        colToken[asset][user] = colToken[asset][user].add(amount);\r\n        TransferHelper.safeTransferFrom(col, user, address(this), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws COL token from a position\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of tokens to withdraw\r\n     **/\r\n    function withdrawCol(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\r\n        colToken[asset][user] = colToken[asset][user].sub(amount);\r\n        TransferHelper.safeTransfer(col, user, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Increases position's debt and mints USDP token\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of USDP to borrow\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        address user,\r\n        uint amount\r\n    )\r\n    external\r\n    hasVaultAccess\r\n    notLiquidating(asset, user)\r\n    returns(uint)\r\n    {\r\n        require(vaultParameters.isOracleTypeEnabled(oracleType[asset][user], asset), \"Unit Protocol: WRONG_ORACLE_TYPE\");\r\n        update(asset, user);\r\n        debts[asset][user] = debts[asset][user].add(amount);\r\n        tokenDebts[asset] = tokenDebts[asset].add(amount);\r\n\r\n        // check USDP limit for token\r\n        require(tokenDebts[asset] <= vaultParameters.tokenDebtLimit(asset), \"Unit Protocol: ASSET_DEBT_LIMIT\");\r\n\r\n        USDP(usdp).mint(user, amount);\r\n\r\n        return debts[asset][user];\r\n    }\r\n\r\n    /**\r\n     * @dev Decreases position's debt and burns USDP token\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The amount of USDP to repay\r\n     * @return updated debt of a position\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        address user,\r\n        uint amount\r\n    )\r\n    external\r\n    hasVaultAccess\r\n    notLiquidating(asset, user)\r\n    returns(uint)\r\n    {\r\n        uint debt = debts[asset][user];\r\n        debts[asset][user] = debt.sub(amount);\r\n        tokenDebts[asset] = tokenDebts[asset].sub(amount);\r\n        USDP(usdp).burn(user, amount);\r\n\r\n        return debts[asset][user];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers fee to foundation\r\n     * @param asset The address of the fee asset\r\n     * @param user The address to transfer funds from\r\n     * @param amount The amount of asset to transfer\r\n     **/\r\n    function chargeFee(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\r\n        if (amount != 0) {\r\n            TransferHelper.safeTransferFrom(asset, user, vaultParameters.foundation(), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deletes position and transfers collateral to liquidation system\r\n     * @param asset The address of the main collateral token\r\n     * @param positionOwner The address of a position's owner\r\n     * @param initialPrice The starting price of collateral in USDP\r\n     **/\r\n    function triggerLiquidation(\r\n        address asset,\r\n        address positionOwner,\r\n        uint initialPrice\r\n    )\r\n    external\r\n    hasVaultAccess\r\n    notLiquidating(asset, positionOwner)\r\n    {\r\n        // reverts if oracle type is disabled\r\n        require(vaultParameters.isOracleTypeEnabled(oracleType[asset][positionOwner], asset), \"Unit Protocol: WRONG_ORACLE_TYPE\");\r\n\r\n        // fix the debt\r\n        debts[asset][positionOwner] = getTotalDebt(asset, positionOwner);\r\n\r\n        liquidationBlock[asset][positionOwner] = block.number;\r\n        liquidationPrice[asset][positionOwner] = initialPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal liquidation process\r\n     * @param asset The address of the main collateral token\r\n     * @param positionOwner The address of a position's owner\r\n     * @param mainAssetToLiquidator The amount of main asset to send to a liquidator\r\n     * @param colToLiquidator The amount of COL to send to a liquidator\r\n     * @param mainAssetToPositionOwner The amount of main asset to send to a position owner\r\n     * @param colToPositionOwner The amount of COL to send to a position owner\r\n     * @param repayment The repayment in USDP\r\n     * @param penalty The liquidation penalty in USDP\r\n     * @param liquidator The address of a liquidator\r\n     **/\r\n    function liquidate(\r\n        address asset,\r\n        address positionOwner,\r\n        uint mainAssetToLiquidator,\r\n        uint colToLiquidator,\r\n        uint mainAssetToPositionOwner,\r\n        uint colToPositionOwner,\r\n        uint repayment,\r\n        uint penalty,\r\n        address liquidator\r\n    )\r\n        external\r\n        hasVaultAccess\r\n    {\r\n        require(liquidationBlock[asset][positionOwner] != 0, \"Unit Protocol: NOT_TRIGGERED_LIQUIDATION\");\r\n\r\n        uint mainAssetInPosition = collaterals[asset][positionOwner];\r\n        uint mainAssetToFoundation = mainAssetInPosition.sub(mainAssetToLiquidator).sub(mainAssetToPositionOwner);\r\n\r\n        uint colInPosition = colToken[asset][positionOwner];\r\n        uint colToFoundation = colInPosition.sub(colToLiquidator).sub(colToPositionOwner);\r\n\r\n        delete liquidationPrice[asset][positionOwner];\r\n        delete liquidationBlock[asset][positionOwner];\r\n        delete debts[asset][positionOwner];\r\n        delete collaterals[asset][positionOwner];\r\n        delete colToken[asset][positionOwner];\r\n\r\n        destroy(asset, positionOwner);\r\n\r\n        // charge liquidation fee and burn USDP\r\n        if (repayment > penalty) {\r\n            if (penalty != 0) {\r\n                TransferHelper.safeTransferFrom(usdp, liquidator, vaultParameters.foundation(), penalty);\r\n            }\r\n            USDP(usdp).burn(liquidator, repayment.sub(penalty));\r\n        } else {\r\n            if (repayment != 0) {\r\n                TransferHelper.safeTransferFrom(usdp, liquidator, vaultParameters.foundation(), repayment);\r\n            }\r\n        }\r\n\r\n        // send the part of collateral to a liquidator\r\n        if (mainAssetToLiquidator != 0) {\r\n            TransferHelper.safeTransfer(asset, liquidator, mainAssetToLiquidator);\r\n        }\r\n\r\n        if (colToLiquidator != 0) {\r\n            TransferHelper.safeTransfer(col, liquidator, colToLiquidator);\r\n        }\r\n\r\n        // send the rest of collateral to a position owner\r\n        if (mainAssetToPositionOwner != 0) {\r\n            TransferHelper.safeTransfer(asset, positionOwner, mainAssetToPositionOwner);\r\n        }\r\n\r\n        if (colToPositionOwner != 0) {\r\n            TransferHelper.safeTransfer(col, positionOwner, colToPositionOwner);\r\n        }\r\n\r\n        if (mainAssetToFoundation != 0) {\r\n            TransferHelper.safeTransfer(asset, vaultParameters.foundation(), mainAssetToFoundation);\r\n        }\r\n\r\n        if (colToFoundation != 0) {\r\n            TransferHelper.safeTransfer(col, vaultParameters.foundation(), colToFoundation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager can call this function\r\n     * @dev Changes broken oracle type to the correct one\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param newOracleType The new type of an oracle\r\n     **/\r\n    function changeOracleType(address asset, address user, uint newOracleType) external onlyManager {\r\n        oracleType[asset][user] = newOracleType;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the total amount of position's debt based on elapsed time\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @return user debt of a position plus accumulated fee\r\n     **/\r\n    function getTotalDebt(address asset, address user) public view returns (uint) {\r\n        uint debt = debts[asset][user];\r\n        if (liquidationBlock[asset][user] != 0) return debt;\r\n        uint fee = calculateFee(asset, user, debt);\r\n        return debt.add(fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of fee based on elapsed time and repayment amount\r\n     * @param asset The address of the main collateral token\r\n     * @param user The address of a position's owner\r\n     * @param amount The repayment amount\r\n     * @return fee amount\r\n     **/\r\n    function calculateFee(address asset, address user, uint amount) public view returns (uint) {\r\n        uint sFeePercent = stabilityFee[asset][user];\r\n        uint timePast = block.timestamp.sub(lastUpdate[asset][user]);\r\n\r\n        return amount.mul(sFeePercent).mul(timePast).div(365 days).div(DENOMINATOR_1E5);\r\n    }\r\n}\r\n\r\n// File: contracts/oracles/KeydonixOracleAbstract.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title KeydonixOracleAbstract\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n **/\r\nabstract contract KeydonixOracleAbstract {\r\n\r\n    uint public constant Q112 = 2 ** 112;\r\n\r\n    struct ProofDataStruct {\r\n        bytes block;\r\n        bytes accountProofNodesRlp;\r\n        bytes reserveAndTimestampProofNodesRlp;\r\n        bytes priceAccumulatorProofNodesRlp;\r\n    }\r\n\r\n    function assetToUsd(\r\n        address asset,\r\n        uint amount,\r\n        ProofDataStruct memory proofData\r\n    ) public virtual view returns (uint);\r\n}\r\n\r\n// File: contracts/vault-managers/VaultManagerParameters.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n/**\r\n * @title VaultManagerParameters\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n **/\r\ncontract VaultManagerParameters is Auth {\r\n\r\n    // determines the minimum percentage of COL token part in collateral, 0 decimals\r\n    mapping(address => uint) public minColPercent;\r\n\r\n    // determines the maximum percentage of COL token part in collateral, 0 decimals\r\n    mapping(address => uint) public maxColPercent;\r\n\r\n    // map token to initial collateralization ratio; 0 decimals\r\n    mapping(address => uint) public initialCollateralRatio;\r\n\r\n    // map token to liquidation ratio; 0 decimals\r\n    mapping(address => uint) public liquidationRatio;\r\n\r\n    // map token to liquidation discount; 3 decimals\r\n    mapping(address => uint) public liquidationDiscount;\r\n\r\n    // map token to devaluation period in blocks\r\n    mapping(address => uint) public devaluationPeriod;\r\n\r\n    constructor(address _vaultParameters) public Auth(_vaultParameters) {}\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets ability to use token as the main collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\r\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\r\n     * @param initialCollateralRatioValue The initial collateralization ratio\r\n     * @param liquidationRatioValue The liquidation ratio\r\n     * @param liquidationDiscountValue The liquidation discount (3 decimals)\r\n     * @param devaluationPeriodValue The devaluation period in blocks\r\n     * @param usdpLimit The USDP token issue limit\r\n     * @param minColP The min percentage of COL value in position (0 decimals)\r\n     * @param maxColP The max percentage of COL value in position (0 decimals)\r\n     **/\r\n    function setCollateral(\r\n        address asset,\r\n        uint stabilityFeeValue,\r\n        uint liquidationFeeValue,\r\n        uint initialCollateralRatioValue,\r\n        uint liquidationRatioValue,\r\n        uint liquidationDiscountValue,\r\n        uint devaluationPeriodValue,\r\n        uint usdpLimit,\r\n        uint[] calldata oracles,\r\n        uint minColP,\r\n        uint maxColP\r\n    ) external onlyManager {\r\n        vaultParameters.setCollateral(asset, stabilityFeeValue, liquidationFeeValue, usdpLimit, oracles);\r\n        setInitialCollateralRatio(asset, initialCollateralRatioValue);\r\n        setLiquidationRatio(asset, liquidationRatioValue);\r\n        setDevaluationPeriod(asset, devaluationPeriodValue);\r\n        setLiquidationDiscount(asset, liquidationDiscountValue);\r\n        setColPartRange(asset, minColP, maxColP);\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the initial collateral ratio\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The collateralization ratio (0 decimals)\r\n     **/\r\n    function setInitialCollateralRatio(address asset, uint newValue) public onlyManager {\r\n        require(newValue != 0 && newValue <= 100, \"Unit Protocol: INCORRECT_COLLATERALIZATION_VALUE\");\r\n        initialCollateralRatio[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the liquidation ratio\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The liquidation ratio (0 decimals)\r\n     **/\r\n    function setLiquidationRatio(address asset, uint newValue) public onlyManager {\r\n        require(newValue != 0 && newValue >= initialCollateralRatio[asset], \"Unit Protocol: INCORRECT_COLLATERALIZATION_VALUE\");\r\n        liquidationRatio[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the liquidation discount\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The liquidation discount (3 decimals)\r\n     **/\r\n    function setLiquidationDiscount(address asset, uint newValue) public onlyManager {\r\n        require(newValue < 1e5, \"Unit Protocol: INCORRECT_DISCOUNT_VALUE\");\r\n        liquidationDiscount[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the devaluation period of collateral after liquidation\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The devaluation period in blocks\r\n     **/\r\n    function setDevaluationPeriod(address asset, uint newValue) public onlyManager {\r\n        require(newValue != 0, \"Unit Protocol: INCORRECT_DEVALUATION_VALUE\");\r\n        devaluationPeriod[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage range of the COL token part for specific collateral token\r\n     * @param asset The address of the main collateral token\r\n     * @param min The min percentage (0 decimals)\r\n     * @param max The max percentage (0 decimals)\r\n     **/\r\n    function setColPartRange(address asset, uint min, uint max) public onlyManager {\r\n        require(max <= 100 && min <= max, \"Unit Protocol: WRONG_RANGE\");\r\n        minColPercent[asset] = min;\r\n        maxColPercent[asset] = max;\r\n    }\r\n}\r\n\r\n// File: contracts/liquidators/LiquidationTriggerSimple.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title LiquidationTriggerSimple\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n * @dev Manages triggering of liquidation process\r\n **/\r\nabstract contract LiquidationTriggerSimple {\r\n    using SafeMath for uint;\r\n\r\n    uint public constant Q112 = 2**112;\r\n    uint public constant DENOMINATOR_1E5 = 1e5;\r\n    uint public constant DENOMINATOR_1E2 = 1e2;\r\n\r\n    // vault manager parameters contract\r\n    VaultManagerParameters public immutable vaultManagerParameters;\r\n\r\n    uint public immutable oracleType;\r\n\r\n    // Vault contract\r\n    Vault public immutable vault;\r\n\r\n    /**\r\n     * @dev Trigger when liquidations are initiated\r\n    **/\r\n    event LiquidationTriggered(address indexed token, address indexed user);\r\n\r\n    /**\r\n     * @param _vaultManagerParameters The address of the contract with vault manager parameters\r\n     * @param _oracleType The id of the oracle type\r\n     **/\r\n    constructor(address _vaultManagerParameters, uint _oracleType) internal {\r\n        vaultManagerParameters = VaultManagerParameters(_vaultManagerParameters);\r\n        vault = Vault(VaultManagerParameters(_vaultManagerParameters).vaultParameters().vault());\r\n        oracleType = _oracleType;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers liquidation of a position\r\n     * @param asset The address of the main collateral token of a position\r\n     * @param user The owner of a position\r\n     **/\r\n    function triggerLiquidation(address asset, address user) external virtual {}\r\n\r\n    /**\r\n     * @dev Determines whether a position is liquidatable\r\n     * @param asset The address of the main collateral token of a position\r\n     * @param user The owner of a position\r\n     * @param mainUsdValue_q112 Q112-encoded USD value of the main collateral\r\n     * @param colUsdValue_q112 Q112-encoded USD value of the COL amount\r\n     * @return boolean value, whether a position is liquidatable\r\n     **/\r\n    function isLiquidatablePosition(\r\n        address asset,\r\n        address user,\r\n        uint mainUsdValue_q112,\r\n        uint colUsdValue_q112\r\n    ) public view returns (bool){\r\n        uint debt = vault.getTotalDebt(asset, user);\r\n\r\n        // position is collateralized if there is no debt\r\n        if (debt == 0) return false;\r\n\r\n        require(vault.oracleType(asset, user) == oracleType, \"Unit Protocol: INCORRECT_ORACLE_TYPE\");\r\n\r\n        return UR(mainUsdValue_q112, colUsdValue_q112, debt) >= LR(asset, mainUsdValue_q112, colUsdValue_q112);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates position's utilization ratio\r\n     * @param mainUsdValue USD value of main collateral\r\n     * @param colUsdValue USD value of COL amount\r\n     * @param debt USDP borrowed\r\n     * @return utilization ratio of a position\r\n     **/\r\n    function UR(uint mainUsdValue, uint colUsdValue, uint debt) public view returns (uint) {\r\n        return debt.mul(100).mul(Q112).div(mainUsdValue.add(colUsdValue));\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates position's liquidation ratio based on collateral proportion\r\n     * @param asset The address of the main collateral token of a position\r\n     * @param mainUsdValue USD value of main collateral in position\r\n     * @param colUsdValue USD value of COL amount in position\r\n     * @return liquidation ratio of a position\r\n     **/\r\n    function LR(address asset, uint mainUsdValue, uint colUsdValue) public view returns(uint) {\r\n        uint lrMain = vaultManagerParameters.liquidationRatio(asset);\r\n        uint lrCol = vaultManagerParameters.liquidationRatio(vault.col());\r\n\r\n        return lrMain.mul(mainUsdValue).add(lrCol.mul(colUsdValue)).div(mainUsdValue.add(colUsdValue));\r\n    }\r\n}\r\n\r\n// File: contracts/oracles/OracleSimple.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title OracleSimple\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n **/\r\nabstract contract OracleSimple {\r\n    // returns Q112-encoded value\r\n    function assetToUsd(address asset, uint amount) public virtual view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title OracleSimplePoolToken\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n **/\r\nabstract contract OracleSimplePoolToken is OracleSimple {\r\n    ChainlinkedOracleSimple public oracleMainAsset;\r\n}\r\n\r\n\r\n/**\r\n * @title ChainlinkedOracleSimple\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n **/\r\nabstract contract ChainlinkedOracleSimple is OracleSimple {\r\n    address public WETH;\r\n    // returns ordinary value\r\n    function ethToUsd(uint ethAmount) public virtual view returns (uint);\r\n    // returns Q112-encoded value\r\n    function assetToEth(address asset, uint amount) public virtual view returns (uint);\r\n}\r\n\r\n// File: contracts/liquidators/LiquidationTriggerKeep3rPoolToken.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title LiquidationTriggerKeep3rPoolToken\r\n * @author Unit Protocol: Artem Zakharov (az@unit.xyz), Alexander Ponomorev (@bcngod)\r\n * @dev Manages liquidation process triggering of main asset-based positions\r\n **/\r\ncontract LiquidationTriggerKeep3rPoolToken is LiquidationTriggerSimple, ReentrancyGuard {\r\n    using SafeMath for uint;\r\n\r\n    // uniswap-based oracle contract\r\n    OracleSimple public immutable keep3rOraclePoolToken;\r\n\r\n    /**\r\n     * @param _vaultManagerParameters The address of the contract with vault manager parameters\r\n     * @param _keep3rOraclePoolToken The address of Keep3r-based Oracle for pool tokens\r\n     **/\r\n    constructor(\r\n        address _vaultManagerParameters,\r\n        address _keep3rOraclePoolToken\r\n    )\r\n    public\r\n    LiquidationTriggerSimple(_vaultManagerParameters, 4)\r\n    {\r\n        keep3rOraclePoolToken = OracleSimple(_keep3rOraclePoolToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers liquidation of a position\r\n     * @param asset The address of the main collateral token of a position\r\n     * @param user The owner of a position\r\n     **/\r\n    function triggerLiquidation(address asset, address user) public override nonReentrant{\r\n        // USD value of the main collateral\r\n        uint mainUsdValue_q112 = keep3rOraclePoolToken.assetToUsd(asset, vault.collaterals(asset, user));\r\n\r\n        // USD value of the COL amount of a position\r\n        uint colUsdValue_q112 = keep3rOraclePoolToken.assetToUsd(vault.col(), vault.colToken(asset, user));\r\n\r\n        // reverts if a position is not liquidatable\r\n        require(isLiquidatablePosition(asset, user, mainUsdValue_q112, colUsdValue_q112), \"Unit Protocol: SAFE_POSITION\");\r\n\r\n        uint liquidationDiscount_q112 = mainUsdValue_q112.add(colUsdValue_q112).mul(\r\n            vaultManagerParameters.liquidationDiscount(asset)\r\n        ).div(DENOMINATOR_1E5);\r\n\r\n        uint initialLiquidationPrice = mainUsdValue_q112.add(colUsdValue_q112).sub(liquidationDiscount_q112).div(Q112);\r\n\r\n        // sends liquidation command to the Vault\r\n        vault.triggerLiquidation(asset, user, initialLiquidationPrice);\r\n\r\n        // fire an liquidation event\r\n        emit LiquidationTriggered(asset, user);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultManagerParameters\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keep3rOraclePoolToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LiquidationTriggered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR_1E2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DENOMINATOR_1E5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mainUsdValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"colUsdValue\",\"type\":\"uint256\"}],\"name\":\"LR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q112\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mainUsdValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"colUsdValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"name\":\"UR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mainUsdValue_q112\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"colUsdValue_q112\",\"type\":\"uint256\"}],\"name\":\"isLiquidatablePosition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keep3rOraclePoolToken\",\"outputs\":[{\"internalType\":\"contract OracleSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"triggerLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultManagerParameters\",\"outputs\":[{\"internalType\":\"contract VaultManagerParameters\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LiquidationTriggerKeep3rPoolToken","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000203153522b9eaef4ae17c6e99851ee7b2f7d312e000000000000000000000000573c7913c07514ed801d55ae3d3a04c26e27d0ba","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://96f4e1e42b217f793b8351487ad0ab8bd406621cc4a87e69dabe8a67e0f8e190"}]}