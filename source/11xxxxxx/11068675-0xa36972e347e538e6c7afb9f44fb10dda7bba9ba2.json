{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"AssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport { Address } from \\u0027./Address.sol\\u0027;\\n\\nimport { IERC20, Structs } from \\u0027./Interfaces.sol\\u0027;\\n\\n\\n/**\\n * @notice Library helper functions for managing a registry of asset descriptors indexed by address and symbol\\n */\\nlibrary AssetRegistry {\\n  struct Storage {\\n    mapping(address =\\u003e Structs.Asset) assetsByAddress;\\n    // Mapping value is array since the same symbol can be re-used for a different address\\n    // (usually as a result of a token swap or upgrade)\\n    mapping(string =\\u003e Structs.Asset[]) assetsBySymbol;\\n  }\\n\\n  function registerToken(\\n    Storage storage self,\\n    IERC20 tokenAddress,\\n    string memory symbol,\\n    uint8 decimals\\n  ) internal {\\n    require(decimals \\u003c= 32, \\u0027Token cannot have more than 32 decimals\\u0027);\\n    require(\\n      tokenAddress != IERC20(0x0) \\u0026\\u0026 Address.isContract(address(tokenAddress)),\\n      \\u0027Invalid token address\\u0027\\n    );\\n    // The string type does not have a length property so cast to bytes to check for empty string\\n    require(bytes(symbol).length \\u003e 0, \\u0027Invalid token symbol\\u0027);\\n    require(\\n      !self.assetsByAddress[address(tokenAddress)].isConfirmed,\\n      \\u0027Token already finalized\\u0027\\n    );\\n\\n    self.assetsByAddress[address(tokenAddress)] = Structs.Asset({\\n      exists: true,\\n      assetAddress: address(tokenAddress),\\n      symbol: symbol,\\n      decimals: decimals,\\n      isConfirmed: false,\\n      confirmedTimestampInMs: 0\\n    });\\n  }\\n\\n  function confirmTokenRegistration(\\n    Storage storage self,\\n    IERC20 tokenAddress,\\n    string memory symbol,\\n    uint8 decimals\\n  ) internal {\\n    Structs.Asset memory asset = self.assetsByAddress[address(tokenAddress)];\\n    require(asset.exists, \\u0027Unknown token\\u0027);\\n    require(!asset.isConfirmed, \\u0027Token already finalized\\u0027);\\n    require(isStringEqual(asset.symbol, symbol), \\u0027Symbols do not match\\u0027);\\n    require(asset.decimals == decimals, \\u0027Decimals do not match\\u0027);\\n\\n    asset.isConfirmed = true;\\n    asset.confirmedTimestampInMs = uint64(block.timestamp * 1000); // Block timestamp is in seconds, store ms\\n    self.assetsByAddress[address(tokenAddress)] = asset;\\n    self.assetsBySymbol[symbol].push(asset);\\n  }\\n\\n  function addTokenSymbol(\\n    Storage storage self,\\n    IERC20 tokenAddress,\\n    string memory symbol\\n  ) internal {\\n    Structs.Asset memory asset = self.assetsByAddress[address(tokenAddress)];\\n    require(\\n      asset.exists \\u0026\\u0026 asset.isConfirmed,\\n      \\u0027Registration of token not finalized\\u0027\\n    );\\n    require(!isStringEqual(symbol, \\u0027ETH\\u0027), \\u0027ETH symbol reserved for Ether\\u0027);\\n\\n    // This will prevent swapping assets for previously existing orders\\n    uint64 msInOneSecond = 1000;\\n    asset.confirmedTimestampInMs = uint64(block.timestamp * msInOneSecond);\\n\\n    self.assetsBySymbol[symbol].push(asset);\\n  }\\n\\n  /**\\n   * @dev Resolves an asset address into corresponding Asset struct\\n   *\\n   * @param assetAddress Ethereum address of asset\\n   */\\n  function loadAssetByAddress(Storage storage self, address assetAddress)\\n    internal\\n    view\\n    returns (Structs.Asset memory)\\n  {\\n    if (assetAddress == address(0x0)) {\\n      return getEthAsset();\\n    }\\n\\n    Structs.Asset memory asset = self.assetsByAddress[assetAddress];\\n    require(\\n      asset.exists \\u0026\\u0026 asset.isConfirmed,\\n      \\u0027No confirmed asset found for address\\u0027\\n    );\\n\\n    return asset;\\n  }\\n\\n  /**\\n   * @dev Resolves a asset symbol into corresponding Asset struct\\n   *\\n   * @param symbol Asset symbol, e.g. \\u0027IDEX\\u0027\\n   * @param timestampInMs Milliseconds since Unix epoch, usually parsed from a UUID v1 order nonce.\\n   * Constrains symbol resolution to the asset most recently confirmed prior to timestampInMs. Reverts\\n   * if no such asset exists\\n   */\\n  function loadAssetBySymbol(\\n    Storage storage self,\\n    string memory symbol,\\n    uint64 timestampInMs\\n  ) internal view returns (Structs.Asset memory) {\\n    if (isStringEqual(\\u0027ETH\\u0027, symbol)) {\\n      return getEthAsset();\\n    }\\n\\n    Structs.Asset memory asset;\\n    if (self.assetsBySymbol[symbol].length \\u003e 0) {\\n      for (uint8 i = 0; i \\u003c self.assetsBySymbol[symbol].length; i++) {\\n        if (\\n          self.assetsBySymbol[symbol][i].confirmedTimestampInMs \\u003c= timestampInMs\\n        ) {\\n          asset = self.assetsBySymbol[symbol][i];\\n        }\\n      }\\n    }\\n    require(\\n      asset.exists \\u0026\\u0026 asset.isConfirmed,\\n      \\u0027No confirmed asset found for symbol\\u0027\\n    );\\n\\n    return asset;\\n  }\\n\\n  /**\\n   * @dev ETH is modeled as an always-confirmed Asset struct for programmatic consistency\\n   */\\n  function getEthAsset() private pure returns (Structs.Asset memory) {\\n    return Structs.Asset(true, address(0x0), \\u0027ETH\\u0027, 18, true, 0);\\n  }\\n\\n  // See https://solidity.readthedocs.io/en/latest/types.html#bytes-and-strings-as-arrays\\n  function isStringEqual(string memory a, string memory b)\\n    private\\n    pure\\n    returns (bool)\\n  {\\n    return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\\n  }\\n}\\n\"},\"AssetTransfers.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  SafeMath as SafeMath256\\n} from \\u0027./SafeMath.sol\\u0027;\\n\\nimport { IERC20 } from \\u0027./Interfaces.sol\\u0027;\\n\\n\\n/**\\n * @notice This library provides helper utilities for transfering assets in and out of contracts.\\n * It further validates ERC-20 compliant balance updates in the case of token assets\\n */\\nlibrary AssetTransfers {\\n  using SafeMath256 for uint256;\\n\\n  /**\\n   * @dev Transfers tokens from a wallet into a contract during deposits. `wallet` must already\\n   * have called `approve` on the token contract for at least `tokenQuantity`. Note this only\\n   * applies to tokens since ETH is sent in the deposit transaction via `msg.value`\\n   */\\n  function transferFrom(\\n    address wallet,\\n    IERC20 tokenAddress,\\n    uint256 quantityInAssetUnits\\n  ) internal {\\n    uint256 balanceBefore = tokenAddress.balanceOf(address(this));\\n\\n    // Because we check for the expected balance change we can safely ignore the return value of transferFrom\\n    tokenAddress.transferFrom(wallet, address(this), quantityInAssetUnits);\\n\\n    uint256 balanceAfter = tokenAddress.balanceOf(address(this));\\n    require(\\n      balanceAfter.sub(balanceBefore) == quantityInAssetUnits,\\n      \\u0027Token contract returned transferFrom success without expected balance change\\u0027\\n    );\\n  }\\n\\n  /**\\n   * @dev Transfers ETH or token assets from a contract to 1) another contract, when `Exchange`\\n   * forwards funds to `Custodian` during deposit or 2) a wallet, when withdrawing\\n   */\\n  function transferTo(\\n    address payable walletOrContract,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) internal {\\n    if (asset == address(0x0)) {\\n      require(\\n        walletOrContract.send(quantityInAssetUnits),\\n        \\u0027ETH transfer failed\\u0027\\n      );\\n    } else {\\n      uint256 balanceBefore = IERC20(asset).balanceOf(walletOrContract);\\n\\n      // Because we check for the expected balance change we can safely ignore the return value of transfer\\n      IERC20(asset).transfer(walletOrContract, quantityInAssetUnits);\\n\\n      uint256 balanceAfter = IERC20(asset).balanceOf(walletOrContract);\\n      require(\\n        balanceAfter.sub(balanceBefore) == quantityInAssetUnits,\\n        \\u0027Token contract returned transfer success without expected balance change\\u0027\\n      );\\n    }\\n  }\\n}\\n\"},\"AssetUnitConversions.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  SafeMath as SafeMath256\\n} from \\u0027./SafeMath.sol\\u0027;\\n\\n\\n/**\\n * @notice Library helpers for converting asset quantities between asset units and pips\\n */\\nlibrary AssetUnitConversions {\\n  using SafeMath256 for uint256;\\n\\n  function pipsToAssetUnits(uint64 quantityInPips, uint8 assetDecimals)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    require(assetDecimals \\u003c= 32, \\u0027Asset cannot have more than 32 decimals\\u0027);\\n\\n    // Exponents cannot be negative, so divide or multiply based on exponent signedness\\n    if (assetDecimals \\u003e 8) {\\n      return uint256(quantityInPips).mul(uint256(10)**(assetDecimals - 8));\\n    }\\n    return uint256(quantityInPips).div(uint256(10)**(8 - assetDecimals));\\n  }\\n\\n  function assetUnitsToPips(uint256 quantityInAssetUnits, uint8 assetDecimals)\\n    internal\\n    pure\\n    returns (uint64)\\n  {\\n    require(assetDecimals \\u003c= 32, \\u0027Asset cannot have more than 32 decimals\\u0027);\\n\\n    uint256 quantityInPips;\\n    // Exponents cannot be negative, so divide or multiply based on exponent signedness\\n    if (assetDecimals \\u003e 8) {\\n      quantityInPips = quantityInAssetUnits.div(\\n        uint256(10)**(assetDecimals - 8)\\n      );\\n    } else {\\n      quantityInPips = quantityInAssetUnits.mul(\\n        uint256(10)**(8 - assetDecimals)\\n      );\\n    }\\n    require(quantityInPips \\u003c 2**64, \\u0027Pip quantity overflows uint64\\u0027);\\n\\n    return uint64(quantityInPips);\\n  }\\n}\\n\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 \\u003c s \\u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\");\\n        }\\n\\n        if (v != 27 \\u0026\\u0026 v != 28) {\\n            revert(\\\"ECDSA: invalid signature \\u0027v\\u0027 value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"},\"Exchange.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport { Address } from \\u0027./Address.sol\\u0027;\\nimport { ECDSA } from \\u0027./ECDSA.sol\\u0027;\\nimport {\\n  SafeMath as SafeMath256\\n} from \\u0027./SafeMath.sol\\u0027;\\n\\nimport { AssetRegistry } from \\u0027./AssetRegistry.sol\\u0027;\\nimport { AssetTransfers } from \\u0027./AssetTransfers.sol\\u0027;\\nimport { AssetUnitConversions } from \\u0027./AssetUnitConversions.sol\\u0027;\\nimport { Owned } from \\u0027./Owned.sol\\u0027;\\nimport { SafeMath64 } from \\u0027./SafeMath64.sol\\u0027;\\nimport { Signatures } from \\u0027./Signatures.sol\\u0027;\\nimport {\\n  Enums,\\n  ICustodian,\\n  IERC20,\\n  IExchange,\\n  Structs\\n} from \\u0027./Interfaces.sol\\u0027;\\nimport { UUID } from \\u0027./UUID.sol\\u0027;\\n\\n\\n/**\\n * @notice The Exchange contract. Implements all deposit, trade, and withdrawal logic and associated balance tracking\\n *\\n * @dev The term `asset` refers collectively to ETH and ERC-20 tokens, the term `token` refers only to the latter\\n * @dev Events with indexed string parameters (Deposited and TradeExecuted) only log the hash values for those\\n * parameters, from which the original raw string values cannot be retrieved. For convenience these events contain\\n * the un-indexed string parameter values in addition to the indexed values\\n */\\ncontract Exchange is IExchange, Owned {\\n  using SafeMath64 for uint64;\\n  using SafeMath256 for uint256;\\n  using AssetRegistry for AssetRegistry.Storage;\\n\\n  // Events //\\n\\n  /**\\n   * @notice Emitted when an admin changes the Chain Propagation Period tunable parameter with `setChainPropagationPeriod`\\n   */\\n  event ChainPropagationPeriodChanged(uint256 previousValue, uint256 newValue);\\n  /**\\n   * @notice Emitted when a user deposits ETH with `depositEther` or a token with `depositAsset` or `depositAssetBySymbol`\\n   */\\n  event Deposited(\\n    uint64 index,\\n    address indexed wallet,\\n    address indexed assetAddress,\\n    string indexed assetSymbolIndex,\\n    string assetSymbol,\\n    uint64 quantityInPips,\\n    uint64 newExchangeBalanceInPips,\\n    uint256 newExchangeBalanceInAssetUnits\\n  );\\n  /**\\n   * @notice Emitted when an admin changes the Dispatch Wallet tunable parameter with `setDispatcher`\\n   */\\n  event DispatcherChanged(address previousValue, address newValue);\\n\\n  /**\\n   * @notice Emitted when an admin changes the Fee Wallet tunable parameter with `setFeeWallet`\\n   */\\n  event FeeWalletChanged(address previousValue, address newValue);\\n\\n  /**\\n   * @notice Emitted when a user invalidates an order nonce with `invalidateOrderNonce`\\n   */\\n  event OrderNonceInvalidated(\\n    address indexed wallet,\\n    uint128 nonce,\\n    uint128 timestampInMs,\\n    uint256 effectiveBlockNumber\\n  );\\n  /**\\n   * @notice Emitted when an admin initiates the token registration process with `registerToken`\\n   */\\n  event TokenRegistered(\\n    IERC20 indexed assetAddress,\\n    string assetSymbol,\\n    uint8 decimals\\n  );\\n  /**\\n   * @notice Emitted when an admin finalizes the token registration process with `confirmAssetRegistration`, after\\n   * which it can be deposited, traded, or withdrawn\\n   */\\n  event TokenRegistrationConfirmed(\\n    IERC20 indexed assetAddress,\\n    string assetSymbol,\\n    uint8 decimals\\n  );\\n  /**\\n   * @notice Emitted when an admin adds a symbol to a previously registered and confirmed token\\n   * via `addTokenSymbol`\\n   */\\n  event TokenSymbolAdded(IERC20 indexed assetAddress, string assetSymbol);\\n  /**\\n   * @notice Emitted when the Dispatcher Wallet submits a trade for execution with `executeTrade`\\n   */\\n  event TradeExecuted(\\n    address buyWallet,\\n    address sellWallet,\\n    string indexed baseAssetSymbolIndex,\\n    string indexed quoteAssetSymbolIndex,\\n    string baseAssetSymbol,\\n    string quoteAssetSymbol,\\n    uint64 baseQuantityInPips,\\n    uint64 quoteQuantityInPips,\\n    uint64 tradePriceInPips,\\n    bytes32 buyOrderHash,\\n    bytes32 sellOrderHash\\n  );\\n  /**\\n   * @notice Emitted when a user invokes the Exit Wallet mechanism with `exitWallet`\\n   */\\n  event WalletExited(address indexed wallet, uint256 effectiveBlockNumber);\\n  /**\\n   * @notice Emitted when a user withdraws an asset balance through the Exit Wallet mechanism with `withdrawExit`\\n   */\\n  event WalletExitWithdrawn(\\n    address indexed wallet,\\n    address indexed assetAddress,\\n    string assetSymbol,\\n    uint64 quantityInPips,\\n    uint64 newExchangeBalanceInPips,\\n    uint256 newExchangeBalanceInAssetUnits\\n  );\\n  /**\\n   * @notice Emitted when a user clears the exited status of a wallet previously exited with `exitWallet`\\n   */\\n  event WalletExitCleared(address indexed wallet);\\n  /**\\n   * @notice Emitted when the Dispatcher Wallet submits a withdrawal with `withdraw`\\n   */\\n  event Withdrawn(\\n    address indexed wallet,\\n    address indexed assetAddress,\\n    string assetSymbol,\\n    uint64 quantityInPips,\\n    uint64 newExchangeBalanceInPips,\\n    uint256 newExchangeBalanceInAssetUnits\\n  );\\n\\n  // Internally used structs //\\n\\n  struct NonceInvalidation {\\n    bool exists;\\n    uint64 timestampInMs;\\n    uint256 effectiveBlockNumber;\\n  }\\n  struct WalletExit {\\n    bool exists;\\n    uint256 effectiveBlockNumber;\\n  }\\n\\n  // Storage //\\n\\n  // Asset registry data\\n  AssetRegistry.Storage _assetRegistry;\\n  // Mapping of order wallet hash =\\u003e isComplete\\n  mapping(bytes32 =\\u003e bool) _completedOrderHashes;\\n  // Mapping of withdrawal wallet hash =\\u003e isComplete\\n  mapping(bytes32 =\\u003e bool) _completedWithdrawalHashes;\\n  address payable _custodian;\\n  uint64 _depositIndex;\\n  // Mapping of wallet =\\u003e asset =\\u003e balance\\n  mapping(address =\\u003e mapping(address =\\u003e uint64)) _balancesInPips;\\n  // Mapping of wallet =\\u003e last invalidated timestampInMs\\n  mapping(address =\\u003e NonceInvalidation) _nonceInvalidations;\\n  // Mapping of order hash =\\u003e filled quantity in pips\\n  mapping(bytes32 =\\u003e uint64) _partiallyFilledOrderQuantitiesInPips;\\n  mapping(address =\\u003e WalletExit) _walletExits;\\n  // Tunable parameters\\n  uint256 _chainPropagationPeriod;\\n  address _dispatcherWallet;\\n  address _feeWallet;\\n\\n  // Constant values //\\n\\n  uint256 constant _maxChainPropagationPeriod = (7 * 24 * 60 * 60) / 15; // 1 week at 15s/block\\n  uint64 constant _maxTradeFeeBasisPoints = 20 * 100; // 20%;\\n  uint64 constant _maxWithdrawalFeeBasisPoints = 20 * 100; // 20%;\\n\\n  /**\\n   * @notice Instantiate a new `Exchange` contract\\n   *\\n   * @dev Sets `_owner` and `_admin` to `msg.sender` */\\n  constructor() public Owned() {}\\n\\n  /**\\n   * @notice Sets the address of the `Custodian` contract\\n   *\\n   * @dev The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after\\n   * which they can only be changed by the `Governance` contract itself. Therefore the `Custodian`\\n   * must be deployed last and its address set here on an existing `Exchange` contract. This value\\n   * is immutable once set and cannot be changed again\\n   *\\n   * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange`\\n   * contract\\u0027s address\\n   */\\n  function setCustodian(address payable newCustodian) external onlyAdmin {\\n    require(_custodian == address(0x0), \\u0027Custodian can only be set once\\u0027);\\n    require(Address.isContract(newCustodian), \\u0027Invalid address\\u0027);\\n\\n    _custodian = newCustodian;\\n  }\\n\\n  /*** Tunable parameters ***/\\n\\n  /**\\n   * @notice Sets a new Chain Propagation Period - the block delay after which order nonce invalidations\\n   * are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`\\n   *\\n   * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must\\n   * be less than `_maxChainPropagationPeriod`\\n   */\\n  function setChainPropagationPeriod(uint256 newChainPropagationPeriod)\\n    external\\n    onlyAdmin\\n  {\\n    require(\\n      newChainPropagationPeriod \\u003c _maxChainPropagationPeriod,\\n      \\u0027Must be less than 1 week\\u0027\\n    );\\n\\n    uint256 oldChainPropagationPeriod = _chainPropagationPeriod;\\n    _chainPropagationPeriod = newChainPropagationPeriod;\\n\\n    emit ChainPropagationPeriodChanged(\\n      oldChainPropagationPeriod,\\n      newChainPropagationPeriod\\n    );\\n  }\\n\\n  /**\\n   * @notice Sets the address of the Fee wallet\\n   *\\n   * @dev Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet\\n   *\\n   * @param newFeeWallet The new Fee wallet. Must be different from the current one\\n   */\\n  function setFeeWallet(address newFeeWallet) external onlyAdmin {\\n    require(newFeeWallet != address(0x0), \\u0027Invalid wallet address\\u0027);\\n    require(\\n      newFeeWallet != _feeWallet,\\n      \\u0027Must be different from current fee wallet\\u0027\\n    );\\n\\n    address oldFeeWallet = _feeWallet;\\n    _feeWallet = newFeeWallet;\\n\\n    emit FeeWalletChanged(oldFeeWallet, newFeeWallet);\\n  }\\n\\n  // Accessors //\\n\\n  /**\\n   * @notice Load a wallet\\u0027s balance by asset address, in asset units\\n   *\\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\\n   * @param assetAddress The asset address to load the wallet\\u0027s balance for\\n   *\\n   * @return The quantity denominated in asset units of asset at `assetAddress` currently\\n   * deposited by `wallet`\\n   */\\n  function loadBalanceInAssetUnitsByAddress(\\n    address wallet,\\n    address assetAddress\\n  ) external view returns (uint256) {\\n    require(wallet != address(0x0), \\u0027Invalid wallet address\\u0027);\\n\\n    Structs.Asset memory asset = _assetRegistry.loadAssetByAddress(\\n      assetAddress\\n    );\\n    return\\n      AssetUnitConversions.pipsToAssetUnits(\\n        _balancesInPips[wallet][assetAddress],\\n        asset.decimals\\n      );\\n  }\\n\\n  /**\\n   * @notice Load a wallet\\u0027s balance by asset address, in asset units\\n   *\\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\\n   * @param assetSymbol The asset symbol to load the wallet\\u0027s balance for\\n   *\\n   * @return The quantity denominated in asset units of asset `assetSymbol` currently deposited\\n   * by `wallet`\\n   */\\n  function loadBalanceInAssetUnitsBySymbol(\\n    address wallet,\\n    string calldata assetSymbol\\n  ) external view returns (uint256) {\\n    require(wallet != address(0x0), \\u0027Invalid wallet address\\u0027);\\n\\n    Structs.Asset memory asset = _assetRegistry.loadAssetBySymbol(\\n      assetSymbol,\\n      getCurrentTimestampInMs()\\n    );\\n    return\\n      AssetUnitConversions.pipsToAssetUnits(\\n        _balancesInPips[wallet][asset.assetAddress],\\n        asset.decimals\\n      );\\n  }\\n\\n  /**\\n   * @notice Load a wallet\\u0027s balance by asset address, in pips\\n   *\\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\\n   * @param assetAddress The asset address to load the wallet\\u0027s balance for\\n   *\\n   * @return The quantity denominated in pips of asset at `assetAddress` currently deposited by `wallet`\\n   */\\n  function loadBalanceInPipsByAddress(address wallet, address assetAddress)\\n    external\\n    view\\n    returns (uint64)\\n  {\\n    require(wallet != address(0x0), \\u0027Invalid wallet address\\u0027);\\n\\n    return _balancesInPips[wallet][assetAddress];\\n  }\\n\\n  /**\\n   * @notice Load a wallet\\u0027s balance by asset symbol, in pips\\n   *\\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\\n   * @param assetSymbol The asset symbol to load the wallet\\u0027s balance for\\n   *\\n   * @return The quantity denominated in pips of asset with `assetSymbol` currently deposited by `wallet`\\n   */\\n  function loadBalanceInPipsBySymbol(\\n    address wallet,\\n    string calldata assetSymbol\\n  ) external view returns (uint64) {\\n    require(wallet != address(0x0), \\u0027Invalid wallet address\\u0027);\\n\\n    address assetAddress = _assetRegistry\\n      .loadAssetBySymbol(assetSymbol, getCurrentTimestampInMs())\\n      .assetAddress;\\n    return _balancesInPips[wallet][assetAddress];\\n  }\\n\\n  /**\\n   * @notice Load the address of the Fee wallet\\n   *\\n   * @return The address of the Fee wallet\\n   */\\n  function loadFeeWallet() external view returns (address) {\\n    return _feeWallet;\\n  }\\n\\n  /**\\n   * @notice Load the quantity filled so far for a partially filled orders\\n\\n   * @dev Invalidating an order nonce will not clear partial fill quantities for earlier orders because\\n   * the gas cost would potentially be unbound\\n   *\\n   * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order\\n   *\\n   * @return For partially filled orders, the amount filled so far in pips. For orders in all other states, 0\\n   */\\n  function loadPartiallyFilledOrderQuantityInPips(bytes32 orderHash)\\n    external\\n    view\\n    returns (uint64)\\n  {\\n    return _partiallyFilledOrderQuantitiesInPips[orderHash];\\n  }\\n\\n  // Depositing //\\n\\n  /**\\n   * @notice Deposit ETH\\n   */\\n  function depositEther() external payable {\\n    deposit(msg.sender, address(0x0), msg.value);\\n  }\\n\\n  /**\\n   * @notice Deposit `IERC20` compliant tokens\\n   *\\n   * @param tokenAddress The token contract address\\n   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on\\n   * the token contract for at least this quantity first\\n   */\\n  function depositTokenByAddress(\\n    IERC20 tokenAddress,\\n    uint256 quantityInAssetUnits\\n  ) external {\\n    require(\\n      address(tokenAddress) != address(0x0),\\n      \\u0027Use depositEther to deposit Ether\\u0027\\n    );\\n    deposit(msg.sender, address(tokenAddress), quantityInAssetUnits);\\n  }\\n\\n  /**\\n   * @notice Deposit `IERC20` compliant tokens\\n   *\\n   * @param assetSymbol The case-sensitive symbol string for the token\\n   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on\\n   * the token contract for at least this quantity first\\n   */\\n  function depositTokenBySymbol(\\n    string calldata assetSymbol,\\n    uint256 quantityInAssetUnits\\n  ) external {\\n    IERC20 tokenAddress = IERC20(\\n      _assetRegistry\\n        .loadAssetBySymbol(assetSymbol, getCurrentTimestampInMs())\\n        .assetAddress\\n    );\\n    require(\\n      address(tokenAddress) != address(0x0),\\n      \\u0027Use depositEther to deposit ETH\\u0027\\n    );\\n\\n    deposit(msg.sender, address(tokenAddress), quantityInAssetUnits);\\n  }\\n\\n  function deposit(\\n    address payable wallet,\\n    address assetAddress,\\n    uint256 quantityInAssetUnits\\n  ) private {\\n    // Calling exitWallet disables deposits immediately on mining, in contrast to withdrawals and\\n    // trades which respect the Chain Propagation Period given by `effectiveBlockNumber` via\\n    // `isWalletExitFinalized`\\n    require(!_walletExits[wallet].exists, \\u0027Wallet exited\\u0027);\\n\\n    Structs.Asset memory asset = _assetRegistry.loadAssetByAddress(\\n      assetAddress\\n    );\\n    uint64 quantityInPips = AssetUnitConversions.assetUnitsToPips(\\n      quantityInAssetUnits,\\n      asset.decimals\\n    );\\n    require(quantityInPips \\u003e 0, \\u0027Quantity is too low\\u0027);\\n\\n    // Convert from pips back into asset units to remove any fractional amount that is too small\\n    // to express in pips. If the asset is ETH, this leftover fractional amount accumulates as dust\\n    // in the `Exchange` contract. If the asset is a token the `Exchange` will call `transferFrom`\\n    // without this fractional amount and there will be no dust\\n    uint256 quantityInAssetUnitsWithoutFractionalPips = AssetUnitConversions\\n      .pipsToAssetUnits(quantityInPips, asset.decimals);\\n\\n    // If the asset is ETH then the funds were already assigned to this contract via msg.value. If\\n    // the asset is a token, additionally call the transferFrom function on the token contract for\\n    // the pre-approved asset quantity\\n    if (assetAddress != address(0x0)) {\\n      AssetTransfers.transferFrom(\\n        wallet,\\n        IERC20(assetAddress),\\n        quantityInAssetUnitsWithoutFractionalPips\\n      );\\n    }\\n    // Forward the funds to the `Custodian`\\n    AssetTransfers.transferTo(\\n      _custodian,\\n      assetAddress,\\n      quantityInAssetUnitsWithoutFractionalPips\\n    );\\n\\n    uint64 newExchangeBalanceInPips = _balancesInPips[wallet][assetAddress].add(\\n      quantityInPips\\n    );\\n    uint256 newExchangeBalanceInAssetUnits = AssetUnitConversions\\n      .pipsToAssetUnits(newExchangeBalanceInPips, asset.decimals);\\n\\n    // Update balance with actual transferred quantity\\n    _balancesInPips[wallet][assetAddress] = newExchangeBalanceInPips;\\n    _depositIndex++;\\n\\n    emit Deposited(\\n      _depositIndex,\\n      wallet,\\n      assetAddress,\\n      asset.symbol,\\n      asset.symbol,\\n      quantityInPips,\\n      newExchangeBalanceInPips,\\n      newExchangeBalanceInAssetUnits\\n    );\\n  }\\n\\n  // Invalidation //\\n\\n  /**\\n   * @notice Invalidate all order nonces with a timestampInMs lower than the one provided\\n   *\\n   * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed,\\n   * `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than\\n   * the one provided\\n   */\\n  function invalidateOrderNonce(uint128 nonce) external {\\n    uint64 timestampInMs = UUID.getTimestampInMsFromUuidV1(nonce);\\n    // Enforce a maximum skew for invalidating nonce timestamps in the future so the user doesn\\u0027t\\n    // lock their wallet from trades indefinitely\\n    require(\\n      timestampInMs \\u003c getOneDayFromNowInMs(),\\n      \\u0027Nonce timestamp too far in future\\u0027\\n    );\\n\\n    if (_nonceInvalidations[msg.sender].exists) {\\n      require(\\n        _nonceInvalidations[msg.sender].timestampInMs \\u003c timestampInMs,\\n        \\u0027Nonce timestamp already invalidated\\u0027\\n      );\\n      require(\\n        _nonceInvalidations[msg.sender].effectiveBlockNumber \\u003c= block.number,\\n        \\u0027Previous invalidation awaiting chain propagation\\u0027\\n      );\\n    }\\n\\n    // Changing the Chain Propagation Period will not affect the effectiveBlockNumber for this invalidation\\n    uint256 effectiveBlockNumber = block.number + _chainPropagationPeriod;\\n    _nonceInvalidations[msg.sender] = NonceInvalidation(\\n      true,\\n      timestampInMs,\\n      effectiveBlockNumber\\n    );\\n\\n    emit OrderNonceInvalidated(\\n      msg.sender,\\n      nonce,\\n      timestampInMs,\\n      effectiveBlockNumber\\n    );\\n  }\\n\\n  // Withdrawing //\\n\\n  /**\\n   * @notice Settles a user withdrawal submitted off-chain. Calls restricted to currently whitelisted Dispatcher wallet\\n   *\\n   * @param withdrawal A `Structs.Withdrawal` struct encoding the parameters of the withdrawal\\n   */\\n  function withdraw(Structs.Withdrawal memory withdrawal)\\n    public\\n    override\\n    onlyDispatcher\\n  {\\n    // Validations\\n    require(!isWalletExitFinalized(withdrawal.walletAddress), \\u0027Wallet exited\\u0027);\\n    require(\\n      getFeeBasisPoints(withdrawal.gasFeeInPips, withdrawal.quantityInPips) \\u003c=\\n        _maxWithdrawalFeeBasisPoints,\\n      \\u0027Excessive withdrawal fee\\u0027\\n    );\\n    bytes32 withdrawalHash = validateWithdrawalSignature(withdrawal);\\n    require(\\n      !_completedWithdrawalHashes[withdrawalHash],\\n      \\u0027Hash already withdrawn\\u0027\\n    );\\n\\n    // If withdrawal is by asset symbol (most common) then resolve to asset address\\n    Structs.Asset memory asset = withdrawal.withdrawalType ==\\n      Enums.WithdrawalType.BySymbol\\n      ? _assetRegistry.loadAssetBySymbol(\\n        withdrawal.assetSymbol,\\n        UUID.getTimestampInMsFromUuidV1(withdrawal.nonce)\\n      )\\n      : _assetRegistry.loadAssetByAddress(withdrawal.assetAddress);\\n\\n    // SafeMath reverts if balance is overdrawn\\n    uint64 netAssetQuantityInPips = withdrawal.quantityInPips.sub(\\n      withdrawal.gasFeeInPips\\n    );\\n    uint256 netAssetQuantityInAssetUnits = AssetUnitConversions\\n      .pipsToAssetUnits(netAssetQuantityInPips, asset.decimals);\\n    uint64 newExchangeBalanceInPips = _balancesInPips[withdrawal\\n      .walletAddress][asset.assetAddress]\\n      .sub(withdrawal.quantityInPips);\\n    uint256 newExchangeBalanceInAssetUnits = AssetUnitConversions\\n      .pipsToAssetUnits(newExchangeBalanceInPips, asset.decimals);\\n\\n    _balancesInPips[withdrawal.walletAddress][asset\\n      .assetAddress] = newExchangeBalanceInPips;\\n    _balancesInPips[_feeWallet][asset\\n      .assetAddress] = _balancesInPips[_feeWallet][asset.assetAddress].add(\\n      withdrawal.gasFeeInPips\\n    );\\n\\n    ICustodian(_custodian).withdraw(\\n      withdrawal.walletAddress,\\n      asset.assetAddress,\\n      netAssetQuantityInAssetUnits\\n    );\\n\\n    _completedWithdrawalHashes[withdrawalHash] = true;\\n\\n    emit Withdrawn(\\n      withdrawal.walletAddress,\\n      asset.assetAddress,\\n      asset.symbol,\\n      withdrawal.quantityInPips,\\n      newExchangeBalanceInPips,\\n      newExchangeBalanceInAssetUnits\\n    );\\n  }\\n\\n  // Wallet exits //\\n\\n  /**\\n   * @notice Flags the sending wallet as exited, immediately disabling deposits upon mining.\\n   * After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet,\\n   * and assets may then be withdrawn one at a time via `withdrawExit`\\n   */\\n  function exitWallet() external {\\n    require(!_walletExits[msg.sender].exists, \\u0027Wallet already exited\\u0027);\\n\\n    _walletExits[msg.sender] = WalletExit(\\n      true,\\n      block.number + _chainPropagationPeriod\\n    );\\n\\n    emit WalletExited(msg.sender, block.number + _chainPropagationPeriod);\\n  }\\n\\n  /**\\n   * @notice Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must\\n   * have already passed since calling `exitWallet` on `assetAddress`\\n   *\\n   * @param assetAddress The address of the asset to withdraw\\n   */\\n  function withdrawExit(address assetAddress) external {\\n    require(isWalletExitFinalized(msg.sender), \\u0027Wallet exit not finalized\\u0027);\\n\\n    Structs.Asset memory asset = _assetRegistry.loadAssetByAddress(\\n      assetAddress\\n    );\\n    uint64 balanceInPips = _balancesInPips[msg.sender][assetAddress];\\n    uint256 balanceInAssetUnits = AssetUnitConversions.pipsToAssetUnits(\\n      balanceInPips,\\n      asset.decimals\\n    );\\n\\n    require(balanceInAssetUnits \\u003e 0, \\u0027No balance for asset\\u0027);\\n    _balancesInPips[msg.sender][assetAddress] = 0;\\n    ICustodian(_custodian).withdraw(\\n      msg.sender,\\n      assetAddress,\\n      balanceInAssetUnits\\n    );\\n\\n    emit WalletExitWithdrawn(\\n      msg.sender,\\n      assetAddress,\\n      asset.symbol,\\n      balanceInPips,\\n      0,\\n      0\\n    );\\n  }\\n\\n  /**\\n   * @notice Clears exited status of sending wallet. Upon mining immediately enables\\n   * deposits, trades, and withdrawals by sending wallet\\n   */\\n  function clearWalletExit() external {\\n    require(_walletExits[msg.sender].exists, \\u0027Wallet not exited\\u0027);\\n\\n    delete _walletExits[msg.sender];\\n\\n    emit WalletExitCleared(msg.sender);\\n  }\\n\\n  function isWalletExitFinalized(address wallet) internal view returns (bool) {\\n    WalletExit storage exit = _walletExits[wallet];\\n    return exit.exists \\u0026\\u0026 exit.effectiveBlockNumber \\u003c= block.number;\\n  }\\n\\n  // Trades //\\n\\n  /**\\n   * @notice Settles a trade between two orders submitted and matched off-chain\\n   *\\n   * @dev As a gas optimization, base and quote symbols are passed in separately and combined to verify\\n   * the wallet hash, since this is cheaper than splitting the market symbol into its two constituent asset symbols\\n   * @dev Stack level too deep if declared external\\n   *\\n   * @param buy A `Structs.Order` struct encoding the parameters of the buy-side order (receiving base, giving quote)\\n   * @param sell A `Structs.Order` struct encoding the parameters of the sell-side order (giving base, receiving quote)\\n   * @param trade A `Structs.Trade` struct encoding the parameters of this trade execution of the counterparty orders\\n   */\\n  function executeTrade(\\n    Structs.Order memory buy,\\n    Structs.Order memory sell,\\n    Structs.Trade memory trade\\n  ) public override onlyDispatcher {\\n    require(\\n      !isWalletExitFinalized(buy.walletAddress),\\n      \\u0027Buy wallet exit finalized\\u0027\\n    );\\n    require(\\n      !isWalletExitFinalized(sell.walletAddress),\\n      \\u0027Sell wallet exit finalized\\u0027\\n    );\\n    require(\\n      buy.walletAddress != sell.walletAddress,\\n      \\u0027Self-trading not allowed\\u0027\\n    );\\n\\n    validateAssetPair(buy, sell, trade);\\n    validateLimitPrices(buy, sell, trade);\\n    validateOrderNonces(buy, sell);\\n    (bytes32 buyHash, bytes32 sellHash) = validateOrderSignatures(\\n      buy,\\n      sell,\\n      trade\\n    );\\n    validateTradeFees(trade);\\n\\n    updateOrderFilledQuantities(buy, buyHash, sell, sellHash, trade);\\n    updateBalancesForTrade(buy, sell, trade);\\n\\n    emit TradeExecuted(\\n      buy.walletAddress,\\n      sell.walletAddress,\\n      trade.baseAssetSymbol,\\n      trade.quoteAssetSymbol,\\n      trade.baseAssetSymbol,\\n      trade.quoteAssetSymbol,\\n      trade.grossBaseQuantityInPips,\\n      trade.grossQuoteQuantityInPips,\\n      trade.priceInPips,\\n      buyHash,\\n      sellHash\\n    );\\n  }\\n\\n  // Updates buyer, seller, and fee wallet balances for both assets in trade pair according to trade parameters\\n  function updateBalancesForTrade(\\n    Structs.Order memory buy,\\n    Structs.Order memory sell,\\n    Structs.Trade memory trade\\n  ) private {\\n    // Seller gives base asset including fees\\n    _balancesInPips[sell.walletAddress][trade\\n      .baseAssetAddress] = _balancesInPips[sell.walletAddress][trade\\n      .baseAssetAddress]\\n      .sub(trade.grossBaseQuantityInPips);\\n    // Buyer receives base asset minus fees\\n    _balancesInPips[buy.walletAddress][trade\\n      .baseAssetAddress] = _balancesInPips[buy.walletAddress][trade\\n      .baseAssetAddress]\\n      .add(trade.netBaseQuantityInPips);\\n\\n    // Buyer gives quote asset including fees\\n    _balancesInPips[buy.walletAddress][trade\\n      .quoteAssetAddress] = _balancesInPips[buy.walletAddress][trade\\n      .quoteAssetAddress]\\n      .sub(trade.grossQuoteQuantityInPips);\\n    // Seller receives quote asset minus fees\\n    _balancesInPips[sell.walletAddress][trade\\n      .quoteAssetAddress] = _balancesInPips[sell.walletAddress][trade\\n      .quoteAssetAddress]\\n      .add(trade.netQuoteQuantityInPips);\\n\\n    // Maker and taker fees to fee wallet\\n    _balancesInPips[_feeWallet][trade\\n      .makerFeeAssetAddress] = _balancesInPips[_feeWallet][trade\\n      .makerFeeAssetAddress]\\n      .add(trade.makerFeeQuantityInPips);\\n    _balancesInPips[_feeWallet][trade\\n      .takerFeeAssetAddress] = _balancesInPips[_feeWallet][trade\\n      .takerFeeAssetAddress]\\n      .add(trade.takerFeeQuantityInPips);\\n  }\\n\\n  function updateOrderFilledQuantities(\\n    Structs.Order memory buyOrder,\\n    bytes32 buyOrderHash,\\n    Structs.Order memory sellOrder,\\n    bytes32 sellOrderHash,\\n    Structs.Trade memory trade\\n  ) private {\\n    updateOrderFilledQuantity(buyOrder, buyOrderHash, trade);\\n    updateOrderFilledQuantity(sellOrder, sellOrderHash, trade);\\n  }\\n\\n  // Update filled quantities tracking for order to prevent over- or double-filling orders\\n  function updateOrderFilledQuantity(\\n    Structs.Order memory order,\\n    bytes32 orderHash,\\n    Structs.Trade memory trade\\n  ) private {\\n    require(!_completedOrderHashes[orderHash], \\u0027Order double filled\\u0027);\\n\\n    // Total quantity of above filled as a result of all trade executions, including this one\\n    uint64 newFilledQuantityInPips;\\n\\n    // Market orders can express quantity in quote terms, and can be partially filled by multiple\\n    // limit maker orders necessitating tracking partially filled amounts in quote terms to\\n    // determine completion\\n    if (order.isQuantityInQuote) {\\n      require(\\n        isMarketOrderType(order.orderType),\\n        \\u0027Order quote quantity only valid for market orders\\u0027\\n      );\\n      newFilledQuantityInPips = trade.grossQuoteQuantityInPips.add(\\n        _partiallyFilledOrderQuantitiesInPips[orderHash]\\n      );\\n    } else {\\n      // All other orders track partially filled quantities in base terms\\n      newFilledQuantityInPips = trade.grossBaseQuantityInPips.add(\\n        _partiallyFilledOrderQuantitiesInPips[orderHash]\\n      );\\n    }\\n\\n    require(\\n      newFilledQuantityInPips \\u003c= order.quantityInPips,\\n      \\u0027Order overfilled\\u0027\\n    );\\n\\n    if (newFilledQuantityInPips \\u003c order.quantityInPips) {\\n      // If the order was partially filled, track the new filled quantity\\n      _partiallyFilledOrderQuantitiesInPips[orderHash] = newFilledQuantityInPips;\\n    } else {\\n      // If the order was completed, delete any partial fill tracking and instead track its completion\\n      // to prevent future double fills\\n      delete _partiallyFilledOrderQuantitiesInPips[orderHash];\\n      _completedOrderHashes[orderHash] = true;\\n    }\\n  }\\n\\n  // Validations //\\n\\n  function validateAssetPair(\\n    Structs.Order memory buy,\\n    Structs.Order memory sell,\\n    Structs.Trade memory trade\\n  ) private view {\\n    require(\\n      trade.baseAssetAddress != trade.quoteAssetAddress,\\n      \\u0027Base and quote assets must be different\\u0027\\n    );\\n\\n    // Buy order market pair\\n    Structs.Asset memory buyBaseAsset = _assetRegistry.loadAssetBySymbol(\\n      trade.baseAssetSymbol,\\n      UUID.getTimestampInMsFromUuidV1(buy.nonce)\\n    );\\n    Structs.Asset memory buyQuoteAsset = _assetRegistry.loadAssetBySymbol(\\n      trade.quoteAssetSymbol,\\n      UUID.getTimestampInMsFromUuidV1(buy.nonce)\\n    );\\n    require(\\n      buyBaseAsset.assetAddress == trade.baseAssetAddress \\u0026\\u0026\\n        buyQuoteAsset.assetAddress == trade.quoteAssetAddress,\\n      \\u0027Buy order market symbol address resolution mismatch\\u0027\\n    );\\n\\n    // Sell order market pair\\n    Structs.Asset memory sellBaseAsset = _assetRegistry.loadAssetBySymbol(\\n      trade.baseAssetSymbol,\\n      UUID.getTimestampInMsFromUuidV1(sell.nonce)\\n    );\\n    Structs.Asset memory sellQuoteAsset = _assetRegistry.loadAssetBySymbol(\\n      trade.quoteAssetSymbol,\\n      UUID.getTimestampInMsFromUuidV1(sell.nonce)\\n    );\\n    require(\\n      sellBaseAsset.assetAddress == trade.baseAssetAddress \\u0026\\u0026\\n        sellQuoteAsset.assetAddress == trade.quoteAssetAddress,\\n      \\u0027Sell order market symbol address resolution mismatch\\u0027\\n    );\\n\\n    // Fee asset validation\\n    require(\\n      trade.makerFeeAssetAddress == trade.baseAssetAddress ||\\n        trade.makerFeeAssetAddress == trade.quoteAssetAddress,\\n      \\u0027Maker fee asset is not in trade pair\\u0027\\n    );\\n    require(\\n      trade.takerFeeAssetAddress == trade.baseAssetAddress ||\\n        trade.takerFeeAssetAddress == trade.quoteAssetAddress,\\n      \\u0027Taker fee asset is not in trade pair\\u0027\\n    );\\n    require(\\n      trade.makerFeeAssetAddress != trade.takerFeeAssetAddress,\\n      \\u0027Maker and taker fee assets must be different\\u0027\\n    );\\n  }\\n\\n  function validateLimitPrices(\\n    Structs.Order memory buy,\\n    Structs.Order memory sell,\\n    Structs.Trade memory trade\\n  ) private pure {\\n    require(\\n      trade.grossBaseQuantityInPips \\u003e 0,\\n      \\u0027Base quantity must be greater than zero\\u0027\\n    );\\n    require(\\n      trade.grossQuoteQuantityInPips \\u003e 0,\\n      \\u0027Quote quantity must be greater than zero\\u0027\\n    );\\n\\n    if (isLimitOrderType(buy.orderType)) {\\n      require(\\n        getImpliedQuoteQuantityInPips(\\n          trade.grossBaseQuantityInPips,\\n          buy.limitPriceInPips\\n        ) \\u003e= trade.grossQuoteQuantityInPips,\\n        \\u0027Buy order limit price exceeded\\u0027\\n      );\\n    }\\n\\n    if (isLimitOrderType(sell.orderType)) {\\n      require(\\n        getImpliedQuoteQuantityInPips(\\n          trade.grossBaseQuantityInPips,\\n          sell.limitPriceInPips\\n        ) \\u003c= trade.grossQuoteQuantityInPips,\\n        \\u0027Sell order limit price exceeded\\u0027\\n      );\\n    }\\n  }\\n\\n  function validateTradeFees(Structs.Trade memory trade) private pure {\\n    uint64 makerTotalQuantityInPips = trade.makerFeeAssetAddress ==\\n      trade.baseAssetAddress\\n      ? trade.grossBaseQuantityInPips\\n      : trade.grossQuoteQuantityInPips;\\n    require(\\n      getFeeBasisPoints(\\n        trade.makerFeeQuantityInPips,\\n        makerTotalQuantityInPips\\n      ) \\u003c= _maxTradeFeeBasisPoints,\\n      \\u0027Excessive maker fee\\u0027\\n    );\\n\\n    uint64 takerTotalQuantityInPips = trade.takerFeeAssetAddress ==\\n      trade.baseAssetAddress\\n      ? trade.grossBaseQuantityInPips\\n      : trade.grossQuoteQuantityInPips;\\n    require(\\n      getFeeBasisPoints(\\n        trade.takerFeeQuantityInPips,\\n        takerTotalQuantityInPips\\n      ) \\u003c= _maxTradeFeeBasisPoints,\\n      \\u0027Excessive taker fee\\u0027\\n    );\\n\\n    require(\\n      trade.netBaseQuantityInPips.add(\\n        trade.makerFeeAssetAddress == trade.baseAssetAddress\\n          ? trade.makerFeeQuantityInPips\\n          : trade.takerFeeQuantityInPips\\n      ) == trade.grossBaseQuantityInPips,\\n      \\u0027Net base plus fee is not equal to gross\\u0027\\n    );\\n    require(\\n      trade.netQuoteQuantityInPips.add(\\n        trade.makerFeeAssetAddress == trade.quoteAssetAddress\\n          ? trade.makerFeeQuantityInPips\\n          : trade.takerFeeQuantityInPips\\n      ) == trade.grossQuoteQuantityInPips,\\n      \\u0027Net quote plus fee is not equal to gross\\u0027\\n    );\\n  }\\n\\n  function validateOrderSignatures(\\n    Structs.Order memory buy,\\n    Structs.Order memory sell,\\n    Structs.Trade memory trade\\n  ) private pure returns (bytes32, bytes32) {\\n    bytes32 buyOrderHash = validateOrderSignature(buy, trade);\\n    bytes32 sellOrderHash = validateOrderSignature(sell, trade);\\n\\n    return (buyOrderHash, sellOrderHash);\\n  }\\n\\n  function validateOrderSignature(\\n    Structs.Order memory order,\\n    Structs.Trade memory trade\\n  ) private pure returns (bytes32) {\\n    bytes32 orderHash = Signatures.getOrderWalletHash(\\n      order,\\n      trade.baseAssetSymbol,\\n      trade.quoteAssetSymbol\\n    );\\n\\n    require(\\n      Signatures.isSignatureValid(\\n        orderHash,\\n        order.walletSignature,\\n        order.walletAddress\\n      ),\\n      order.side == Enums.OrderSide.Buy\\n        ? \\u0027Invalid wallet signature for buy order\\u0027\\n        : \\u0027Invalid wallet signature for sell order\\u0027\\n    );\\n\\n    return orderHash;\\n  }\\n\\n  function validateOrderNonces(\\n    Structs.Order memory buy,\\n    Structs.Order memory sell\\n  ) private view {\\n    require(\\n      UUID.getTimestampInMsFromUuidV1(buy.nonce) \\u003e\\n        getLastInvalidatedTimestamp(buy.walletAddress),\\n      \\u0027Buy order nonce timestamp too low\\u0027\\n    );\\n    require(\\n      UUID.getTimestampInMsFromUuidV1(sell.nonce) \\u003e\\n        getLastInvalidatedTimestamp(sell.walletAddress),\\n      \\u0027Sell order nonce timestamp too low\\u0027\\n    );\\n  }\\n\\n  function validateWithdrawalSignature(Structs.Withdrawal memory withdrawal)\\n    private\\n    pure\\n    returns (bytes32)\\n  {\\n    bytes32 withdrawalHash = Signatures.getWithdrawalWalletHash(withdrawal);\\n\\n    require(\\n      Signatures.isSignatureValid(\\n        withdrawalHash,\\n        withdrawal.walletSignature,\\n        withdrawal.walletAddress\\n      ),\\n      \\u0027Invalid wallet signature\\u0027\\n    );\\n\\n    return withdrawalHash;\\n  }\\n\\n  // Asset registry //\\n\\n  /**\\n   * @notice Initiate registration process for a token asset. Only `IERC20` compliant tokens can be\\n   * added - ETH is hardcoded in the registry\\n   *\\n   * @param tokenAddress The address of the `IERC20` compliant token contract to add\\n   * @param symbol The symbol identifying the token asset\\n   * @param decimals The decimal precision of the token\\n   */\\n  function registerToken(\\n    IERC20 tokenAddress,\\n    string calldata symbol,\\n    uint8 decimals\\n  ) external onlyAdmin {\\n    _assetRegistry.registerToken(tokenAddress, symbol, decimals);\\n    emit TokenRegistered(tokenAddress, symbol, decimals);\\n  }\\n\\n  /**\\n   * @notice Finalize registration process for a token asset. All parameters must exactly match a previous\\n   * call to `registerToken`\\n   *\\n   * @param tokenAddress The address of the `IERC20` compliant token contract to add\\n   * @param symbol The symbol identifying the token asset\\n   * @param decimals The decimal precision of the token\\n   */\\n  function confirmTokenRegistration(\\n    IERC20 tokenAddress,\\n    string calldata symbol,\\n    uint8 decimals\\n  ) external onlyAdmin {\\n    _assetRegistry.confirmTokenRegistration(tokenAddress, symbol, decimals);\\n    emit TokenRegistrationConfirmed(tokenAddress, symbol, decimals);\\n  }\\n\\n  /**\\n   * @notice Add a symbol to a token that has already been registered and confirmed\\n   *\\n   * @param tokenAddress The address of the `IERC20` compliant token contract the symbol will identify\\n   * @param symbol The symbol identifying the token asset\\n   */\\n  function addTokenSymbol(IERC20 tokenAddress, string calldata symbol)\\n    external\\n    onlyAdmin\\n  {\\n    _assetRegistry.addTokenSymbol(tokenAddress, symbol);\\n    emit TokenSymbolAdded(tokenAddress, symbol);\\n  }\\n\\n  /**\\n   * @notice Loads an asset descriptor struct by its symbol and timestamp\\n   *\\n   * @dev Since multiple token addresses can potentially share the same symbol (in case of a token\\n   * swap/contract upgrade) the provided `timestampInMs` is compared against each asset\\u0027s\\n   * `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time\\n   *\\n   * @param assetSymbol The asset\\u0027s symbol\\n   * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol\\n   *\\n   * @return A `Structs.Asset` record describing the asset\\n   */\\n  function loadAssetBySymbol(string calldata assetSymbol, uint64 timestampInMs)\\n    external\\n    view\\n    returns (Structs.Asset memory)\\n  {\\n    return _assetRegistry.loadAssetBySymbol(assetSymbol, timestampInMs);\\n  }\\n\\n  // Dispatcher whitelisting //\\n\\n  /**\\n   * @notice Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions\\n   *\\n   * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one\\n   */\\n  function setDispatcher(address newDispatcherWallet) external onlyAdmin {\\n    require(newDispatcherWallet != address(0x0), \\u0027Invalid wallet address\\u0027);\\n    require(\\n      newDispatcherWallet != _dispatcherWallet,\\n      \\u0027Must be different from current dispatcher\\u0027\\n    );\\n    address oldDispatcherWallet = _dispatcherWallet;\\n    _dispatcherWallet = newDispatcherWallet;\\n\\n    emit DispatcherChanged(oldDispatcherWallet, newDispatcherWallet);\\n  }\\n\\n  /**\\n   * @notice Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the\\n   * `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`\\n   */\\n  function removeDispatcher() external onlyAdmin {\\n    emit DispatcherChanged(_dispatcherWallet, address(0x0));\\n    _dispatcherWallet = address(0x0);\\n  }\\n\\n  modifier onlyDispatcher() {\\n    require(msg.sender == _dispatcherWallet, \\u0027Caller is not dispatcher\\u0027);\\n    _;\\n  }\\n\\n  // Utils //\\n\\n  function isLimitOrderType(Enums.OrderType orderType)\\n    private\\n    pure\\n    returns (bool)\\n  {\\n    return\\n      orderType == Enums.OrderType.Limit ||\\n      orderType == Enums.OrderType.LimitMaker ||\\n      orderType == Enums.OrderType.StopLossLimit ||\\n      orderType == Enums.OrderType.TakeProfitLimit;\\n  }\\n\\n  function isMarketOrderType(Enums.OrderType orderType)\\n    private\\n    pure\\n    returns (bool)\\n  {\\n    return\\n      orderType == Enums.OrderType.Market ||\\n      orderType == Enums.OrderType.StopLoss ||\\n      orderType == Enums.OrderType.TakeProfit;\\n  }\\n\\n  function getCurrentTimestampInMs() private view returns (uint64) {\\n    uint64 msInOneSecond = 1000;\\n\\n    return uint64(block.timestamp) * msInOneSecond;\\n  }\\n\\n  function getFeeBasisPoints(uint64 fee, uint64 total)\\n    private\\n    pure\\n    returns (uint64)\\n  {\\n    uint64 basisPointsInTotal = 100 * 100; // 100 basis points/percent * 100 percent/total\\n    return fee.mul(basisPointsInTotal).div(total);\\n  }\\n\\n  function getImpliedQuoteQuantityInPips(\\n    uint64 baseQuantityInPips,\\n    uint64 limitPriceInPips\\n  ) private pure returns (uint64) {\\n    // To convert a fractional price to integer pips, shift right by the pip precision of 8 decimals\\n    uint256 pipsMultiplier = 10**8;\\n\\n    uint256 impliedQuoteQuantityInPips = uint256(baseQuantityInPips)\\n      .mul(uint256(limitPriceInPips))\\n      .div(pipsMultiplier);\\n    require(\\n      impliedQuoteQuantityInPips \\u003c 2**64,\\n      \\u0027Implied quote pip quantity overflows uint64\\u0027\\n    );\\n\\n    return uint64(impliedQuoteQuantityInPips);\\n  }\\n\\n  function getLastInvalidatedTimestamp(address walletAddress)\\n    private\\n    view\\n    returns (uint64)\\n  {\\n    if (\\n      _nonceInvalidations[walletAddress].exists \\u0026\\u0026\\n      _nonceInvalidations[walletAddress].effectiveBlockNumber \\u003c= block.number\\n    ) {\\n      return _nonceInvalidations[walletAddress].timestampInMs;\\n    }\\n\\n    return 0;\\n  }\\n\\n  function getOneDayFromNowInMs() private view returns (uint64) {\\n    uint64 secondsInOneDay = 24 * 60 * 60; // 24 hours/day * 60 min/hour * 60 seconds/min\\n    uint64 msInOneSecond = 1000;\\n\\n    return (uint64(block.timestamp) + secondsInOneDay) * msInOneSecond;\\n  }\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @notice Enums used in `Order` and `Withdrawal` structs\\n */\\ncontract Enums {\\n  enum OrderSelfTradePrevention {\\n    // Decrement and cancel\\n    dc,\\n    // Cancel oldest\\n    co,\\n    // Cancel newest\\n    cn,\\n    // Cancel both\\n    cb\\n  }\\n  enum OrderSide { Buy, Sell }\\n  enum OrderTimeInForce {\\n    // Good until cancelled\\n    gtc,\\n    // Good until time\\n    gtt,\\n    // Immediate or cancel\\n    ioc,\\n    // Fill or kill\\n    fok\\n  }\\n  enum OrderType {\\n    Market,\\n    Limit,\\n    LimitMaker,\\n    StopLoss,\\n    StopLossLimit,\\n    TakeProfit,\\n    TakeProfitLimit\\n  }\\n  enum WithdrawalType { BySymbol, ByAddress }\\n}\\n\\n\\n/**\\n * @notice Struct definitions\\n */\\ncontract Structs {\\n  /**\\n   * @notice Argument type for `Exchange.executeTrade` and `Signatures.getOrderWalletHash`\\n   */\\n  struct Order {\\n    // Not currently used but reserved for future use. Must be 1\\n    uint8 signatureHashVersion;\\n    // UUIDv1 unique to wallet\\n    uint128 nonce;\\n    // Wallet address that placed order and signed hash\\n    address walletAddress;\\n    // Type of order\\n    Enums.OrderType orderType;\\n    // Order side wallet is on\\n    Enums.OrderSide side;\\n    // Order quantity in base or quote asset terms depending on isQuantityInQuote flag\\n    uint64 quantityInPips;\\n    // Is quantityInPips in quote terms\\n    bool isQuantityInQuote;\\n    // For limit orders, price in decimal pips * 10^8 in quote terms\\n    uint64 limitPriceInPips;\\n    // For stop orders, stop loss or take profit price in decimal pips * 10^8 in quote terms\\n    uint64 stopPriceInPips;\\n    // Optional custom client order ID\\n    string clientOrderId;\\n    // TIF option specified by wallet for order\\n    Enums.OrderTimeInForce timeInForce;\\n    // STP behavior specified by wallet for order\\n    Enums.OrderSelfTradePrevention selfTradePrevention;\\n    // Cancellation time specified by wallet for GTT TIF order\\n    uint64 cancelAfter;\\n    // The ECDSA signature of the order hash as produced by Signatures.getOrderWalletHash\\n    bytes walletSignature;\\n  }\\n\\n  /**\\n   * @notice Return type for `Exchange.loadAssetBySymbol`, and `Exchange.loadAssetByAddress`; also\\n   * used internally by `AssetRegistry`\\n   */\\n  struct Asset {\\n    // Flag to distinguish from empty struct\\n    bool exists;\\n    // The asset\\u0027s address\\n    address assetAddress;\\n    // The asset\\u0027s symbol\\n    string symbol;\\n    // The asset\\u0027s decimal precision\\n    uint8 decimals;\\n    // Flag set when asset registration confirmed. Asset deposits, trades, or withdrawals only allowed if true\\n    bool isConfirmed;\\n    // Timestamp as ms since Unix epoch when isConfirmed was asserted\\n    uint64 confirmedTimestampInMs;\\n  }\\n\\n  /**\\n   * @notice Argument type for `Exchange.executeTrade` specifying execution parameters for matching orders\\n   */\\n  struct Trade {\\n    // Base asset symbol\\n    string baseAssetSymbol;\\n    // Quote asset symbol\\n    string quoteAssetSymbol;\\n    // Base asset address\\n    address baseAssetAddress;\\n    // Quote asset address\\n    address quoteAssetAddress;\\n    // Gross amount including fees of base asset executed\\n    uint64 grossBaseQuantityInPips;\\n    // Gross amount including fees of quote asset executed\\n    uint64 grossQuoteQuantityInPips;\\n    // Net amount of base asset received by buy side wallet after fees\\n    uint64 netBaseQuantityInPips;\\n    // Net amount of quote asset received by sell side wallet after fees\\n    uint64 netQuoteQuantityInPips;\\n    // Asset address for liquidity maker\\u0027s fee\\n    address makerFeeAssetAddress;\\n    // Asset address for liquidity taker\\u0027s fee\\n    address takerFeeAssetAddress;\\n    // Fee paid by liquidity maker\\n    uint64 makerFeeQuantityInPips;\\n    // Fee paid by liquidity taker\\n    uint64 takerFeeQuantityInPips;\\n    // Execution price of trade in decimal pips * 10^8 in quote terms\\n    uint64 priceInPips;\\n    // Which side of the order (buy or sell) the liquidity maker was on\\n    Enums.OrderSide makerSide;\\n  }\\n\\n  /**\\n   * @notice Argument type for `Exchange.withdraw` and `Signatures.getWithdrawalWalletHash`\\n   */\\n  struct Withdrawal {\\n    // Distinguishes between withdrawals by asset symbol or address\\n    Enums.WithdrawalType withdrawalType;\\n    // UUIDv1 unique to wallet\\n    uint128 nonce;\\n    // Address of wallet to which funds will be returned\\n    address payable walletAddress;\\n    // Asset symbol\\n    string assetSymbol;\\n    // Asset address\\n    address assetAddress; // Used when assetSymbol not specified\\n    // Withdrawal quantity\\n    uint64 quantityInPips;\\n    // Gas fee deducted from withdrawn quantity to cover dispatcher tx costs\\n    uint64 gasFeeInPips;\\n    // Not currently used but reserved for future use. Must be true\\n    bool autoDispatchEnabled;\\n    // The ECDSA signature of the withdrawal hash as produced by Signatures.getWithdrawalWalletHash\\n    bytes walletSignature;\\n  }\\n}\\n\\n\\n/**\\n * @notice Interface of the ERC20 standard as defined in the EIP, but with no return values for\\n * transfer and transferFrom. By asserting expected balance changes when calling these two methods\\n * we can safely ignore their return values. This allows support of non-compliant tokens that do not\\n * return a boolean. See https://github.com/ethereum/solidity/issues/4116\\n */\\ninterface IERC20 {\\n  /**\\n   * @notice Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external;\\n\\n  /**\\n   * @notice Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @notice Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n   * allowance.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @notice Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @notice Interface to Custodian contract. Used by Exchange and Governance contracts for internal\\n * delegate calls\\n */\\ninterface ICustodian {\\n  /**\\n   * @notice ETH can only be sent by the Exchange\\n   */\\n  receive() external payable;\\n\\n  /**\\n   * @notice Withdraw any asset and amount to a target wallet\\n   *\\n   * @dev No balance checking performed\\n   *\\n   * @param wallet The wallet to which assets will be returned\\n   * @param asset The address of the asset to withdraw (ETH or ERC-20 contract)\\n   * @param quantityInAssetUnits The quantity in asset units to withdraw\\n   */\\n  function withdraw(\\n    address payable wallet,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Exchange contract\\n   *\\n   * @return The address of the currently whitelisted Exchange contract\\n   */\\n  function loadExchange() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Exchange contract address\\n   *\\n   * @param newExchange The address of the new whitelisted Exchange contract\\n   */\\n  function setExchange(address newExchange) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Governance contract\\n   *\\n   * @return The address of the currently whitelisted Governance contract\\n   */\\n  function loadGovernance() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Governance contract address\\n   *\\n   * @param newGovernance The address of the new whitelisted Governance contract\\n   */\\n  function setGovernance(address newGovernance) external;\\n}\\n\\n\\n/**\\n * @notice Interface to Exchange contract. Provided only to document struct usage\\n */\\ninterface IExchange {\\n  /**\\n   * @notice Settles a trade between two orders submitted and matched off-chain\\n   *\\n   * @param buy A `Structs.Order` struct encoding the parameters of the buy-side order (receiving base, giving quote)\\n   * @param sell A `Structs.Order` struct encoding the parameters of the sell-side order (giving base, receiving quote)\\n   * @param trade A `Structs.Trade` struct encoding the parameters of this trade execution of the counterparty orders\\n   */\\n  function executeTrade(\\n    Structs.Order calldata buy,\\n    Structs.Order calldata sell,\\n    Structs.Trade calldata trade\\n  ) external;\\n\\n  /**\\n   * @notice Settles a user withdrawal submitted off-chain. Calls restricted to currently whitelisted Dispatcher wallet\\n   *\\n   * @param withdrawal A `Structs.Withdrawal` struct encoding the parameters of the withdrawal\\n   */\\n  function withdraw(Structs.Withdrawal calldata withdrawal) external;\\n}\\n\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\n\\n\\n/**\\n * @notice Mixin that provide separate owner and admin roles for RBAC\\n */\\nabstract contract Owned {\\n  address immutable _owner;\\n  address _admin;\\n\\n  modifier onlyOwner {\\n    require(msg.sender == _owner, \\u0027Caller must be owner\\u0027);\\n    _;\\n  }\\n  modifier onlyAdmin {\\n    require(msg.sender == _admin, \\u0027Caller must be admin\\u0027);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Sets both the owner and admin roles to the contract creator\\n   */\\n  constructor() public {\\n    _owner = msg.sender;\\n    _admin = msg.sender;\\n  }\\n\\n  /**\\n   * @notice Sets a new whitelisted admin wallet\\n   *\\n   * @param newAdmin The new whitelisted admin wallet. Must be different from the current one\\n   */\\n  function setAdmin(address newAdmin) external onlyOwner {\\n    require(newAdmin != address(0x0), \\u0027Invalid wallet address\\u0027);\\n    require(newAdmin != _admin, \\u0027Must be different from current admin\\u0027);\\n\\n    _admin = newAdmin;\\n  }\\n\\n  /**\\n   * @notice Clears the currently whitelisted admin wallet, effectively disabling any functions requiring\\n   * the admin role\\n   */\\n  function removeAdmin() external onlyOwner {\\n    _admin = address(0x0);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"SafeMath64.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\n\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath64 {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\\n    uint64 c = a + b;\\n    require(c \\u003e= a, \\u0027SafeMath: addition overflow\\u0027);\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\\n    return sub(a, b, \\u0027SafeMath: subtraction overflow\\u0027);\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   *\\n   * _Available since v2.4.0._\\n   */\\n  function sub(\\n    uint64 a,\\n    uint64 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint64) {\\n    require(b \\u003c= a, errorMessage);\\n    uint64 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint64 c = a * b;\\n    require(c / a == b, \\u0027SafeMath: multiplication overflow\\u0027);\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\\n    return div(a, b, \\u0027SafeMath: division by zero\\u0027);\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   *\\n   * _Available since v2.4.0._\\n   */\\n  function div(\\n    uint64 a,\\n    uint64 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint64) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b \\u003e 0, errorMessage);\\n    uint64 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n}\\n\"},\"Signatures.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport { ECDSA } from \\u0027./ECDSA.sol\\u0027;\\n\\nimport { Enums, Structs } from \\u0027./Interfaces.sol\\u0027;\\n\\n\\n/**\\n * Library helpers for building hashes and verifying wallet signatures on `Order` and `Withdrawal` structs\\n */\\nlibrary Signatures {\\n  function isSignatureValid(\\n    bytes32 hash,\\n    bytes memory signature,\\n    address signer\\n  ) internal pure returns (bool) {\\n    return\\n      ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), signature) == signer;\\n  }\\n\\n  function getOrderWalletHash(\\n    Structs.Order memory order,\\n    string memory baseSymbol,\\n    string memory quoteSymbol\\n  ) internal pure returns (bytes32) {\\n    require(\\n      order.signatureHashVersion == 1,\\n      \\u0027Signature hash version must be 1\\u0027\\n    );\\n    return\\n      keccak256(\\n        // Placing all the fields in a single `abi.encodePacked` call causes a `stack too deep` error\\n        abi.encodePacked(\\n          abi.encodePacked(\\n            order.signatureHashVersion,\\n            order.nonce,\\n            order.walletAddress,\\n            getMarketSymbol(baseSymbol, quoteSymbol),\\n            uint8(order.orderType),\\n            uint8(order.side),\\n            // Ledger qtys and prices are in pip, but order was signed by wallet owner with decimal values\\n            pipToDecimal(order.quantityInPips)\\n          ),\\n          abi.encodePacked(\\n            order.isQuantityInQuote,\\n            order.limitPriceInPips \\u003e 0\\n              ? pipToDecimal(order.limitPriceInPips)\\n              : \\u0027\\u0027,\\n            order.stopPriceInPips \\u003e 0\\n              ? pipToDecimal(order.stopPriceInPips)\\n              : \\u0027\\u0027,\\n            order.clientOrderId,\\n            uint8(order.timeInForce),\\n            uint8(order.selfTradePrevention),\\n            order.cancelAfter\\n          )\\n        )\\n      );\\n  }\\n\\n  function getWithdrawalWalletHash(Structs.Withdrawal memory withdrawal)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return\\n      keccak256(\\n        abi.encodePacked(\\n          withdrawal.nonce,\\n          withdrawal.walletAddress,\\n          // Ternary branches must resolve to the same type, so wrap in idempotent encodePacked\\n          withdrawal.withdrawalType == Enums.WithdrawalType.BySymbol\\n            ? abi.encodePacked(withdrawal.assetSymbol)\\n            : abi.encodePacked(withdrawal.assetAddress),\\n          pipToDecimal(withdrawal.quantityInPips),\\n          withdrawal.autoDispatchEnabled\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @dev Combines base and quote asset symbols into the market symbol originally signed by the\\n   * wallet. For example if base is \\u0027IDEX\\u0027 and quote is \\u0027ETH\\u0027, the resulting market symbol is\\n   * \\u0027IDEX-ETH\\u0027. This approach is used rather than passing in the market symbol and splitting it\\n   * since the latter incurs a higher gas cost\\n   */\\n  function getMarketSymbol(string memory baseSymbol, string memory quoteSymbol)\\n    private\\n    pure\\n    returns (string memory)\\n  {\\n    bytes memory baseSymbolBytes = bytes(baseSymbol);\\n    bytes memory hyphenBytes = bytes(\\u0027-\\u0027);\\n    bytes memory quoteSymbolBytes = bytes(quoteSymbol);\\n\\n    bytes memory marketSymbolBytes = bytes(\\n      new string(\\n        baseSymbolBytes.length + quoteSymbolBytes.length + hyphenBytes.length\\n      )\\n    );\\n\\n    uint256 i;\\n    uint256 j;\\n\\n    for (i = 0; i \\u003c baseSymbolBytes.length; i++) {\\n      marketSymbolBytes[j++] = baseSymbolBytes[i];\\n    }\\n\\n    // Hyphen is one byte\\n    marketSymbolBytes[j++] = hyphenBytes[0];\\n\\n    for (i = 0; i \\u003c quoteSymbolBytes.length; i++) {\\n      marketSymbolBytes[j++] = quoteSymbolBytes[i];\\n    }\\n\\n    return string(marketSymbolBytes);\\n  }\\n\\n  /**\\n   * @dev Converts an integer pip quantity back into the fixed-precision decimal pip string\\n   * originally signed by the wallet. For example, 1234567890 becomes \\u002712.34567890\\u0027\\n   */\\n  function pipToDecimal(uint256 pips) private pure returns (string memory) {\\n    // Inspired by https://github.com/provable-things/ethereum-api/blob/831f4123816f7a3e57ebea171a3cdcf3b528e475/oraclizeAPI_0.5.sol#L1045-L1062\\n    uint256 copy = pips;\\n    uint256 length;\\n    while (copy != 0) {\\n      length++;\\n      copy /= 10;\\n    }\\n    if (length \\u003c 9) {\\n      length = 9; // a zero before the decimal point plus 8 decimals\\n    }\\n    length++; // for the decimal point\\n\\n    bytes memory decimal = new bytes(length);\\n    for (uint256 i = length; i \\u003e 0; i--) {\\n      if (length - i == 8) {\\n        decimal[i - 1] = bytes1(uint8(46)); // period\\n      } else {\\n        decimal[i - 1] = bytes1(uint8(48 + (pips % 10)));\\n        pips /= 10;\\n      }\\n    }\\n    return string(decimal);\\n  }\\n}\\n\"},\"UUID.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.8;\\n\\nimport { SafeMath64 } from \\u0027./SafeMath64.sol\\u0027;\\n\\n\\n/**\\n * Library helper for extracting timestamp component of Version 1 UUIDs\\n */\\nlibrary UUID {\\n  using SafeMath64 for uint64;\\n\\n  /**\\n   * Extracts the timestamp component of a Version 1 UUID. Used to make time-based assertions\\n   * against a wallet-privided nonce\\n   */\\n  function getTimestampInMsFromUuidV1(uint128 uuid)\\n    internal\\n    pure\\n    returns (uint64 msSinceUnixEpoch)\\n  {\\n    // https://tools.ietf.org/html/rfc4122#section-4.1.2\\n    uint128 version = (uuid \\u003e\\u003e 76) \\u0026 0x0000000000000000000000000000000F;\\n    require(version == 1, \\u0027Must be v1 UUID\\u0027);\\n\\n    // Time components are in reverse order so shift+mask each to reassemble\\n    uint128 timeHigh = (uuid \\u003e\\u003e 16) \\u0026 0x00000000000000000FFF000000000000;\\n    uint128 timeMid = (uuid \\u003e\\u003e 48) \\u0026 0x00000000000000000000FFFF00000000;\\n    uint128 timeLow = (uuid \\u003e\\u003e 96) \\u0026 0x000000000000000000000000FFFFFFFF;\\n    uint128 nsSinceGregorianEpoch = (timeHigh | timeMid | timeLow);\\n    // Gregorian offset given in seconds by https://www.wolframalpha.com/input/?i=convert+1582-10-15+UTC+to+unix+time\\n    msSinceUnixEpoch = uint64(nsSinceGregorianEpoch / 10000).sub(\\n      12219292800000\\n    );\\n\\n    return msSinceUnixEpoch;\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ChainPropagationPeriodChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"assetSymbolIndex\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"quantityInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newExchangeBalanceInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExchangeBalanceInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"DispatcherChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"FeeWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"timestampInMs\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveBlockNumber\",\"type\":\"uint256\"}],\"name\":\"OrderNonceInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"TokenRegistrationConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"}],\"name\":\"TokenSymbolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sellWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"baseAssetSymbolIndex\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"quoteAssetSymbolIndex\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseAssetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"quoteAssetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"baseQuantityInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"quoteQuantityInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"tradePriceInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"buyOrderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sellOrderHash\",\"type\":\"bytes32\"}],\"name\":\"TradeExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"WalletExitCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"quantityInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newExchangeBalanceInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExchangeBalanceInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"WalletExitWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveBlockNumber\",\"type\":\"uint256\"}],\"name\":\"WalletExited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"quantityInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newExchangeBalanceInPips\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExchangeBalanceInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"addTokenSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearWalletExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"confirmTokenRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantityInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"depositTokenByAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"quantityInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"depositTokenBySymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"signatureHashVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"enum Enums.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum Enums.OrderSide\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"quantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isQuantityInQuote\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"limitPriceInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"stopPriceInPips\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"clientOrderId\",\"type\":\"string\"},{\"internalType\":\"enum Enums.OrderTimeInForce\",\"name\":\"timeInForce\",\"type\":\"uint8\"},{\"internalType\":\"enum Enums.OrderSelfTradePrevention\",\"name\":\"selfTradePrevention\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"cancelAfter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"walletSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct Structs.Order\",\"name\":\"buy\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"signatureHashVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"enum Enums.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"enum Enums.OrderSide\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"quantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isQuantityInQuote\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"limitPriceInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"stopPriceInPips\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"clientOrderId\",\"type\":\"string\"},{\"internalType\":\"enum Enums.OrderTimeInForce\",\"name\":\"timeInForce\",\"type\":\"uint8\"},{\"internalType\":\"enum Enums.OrderSelfTradePrevention\",\"name\":\"selfTradePrevention\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"cancelAfter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"walletSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct Structs.Order\",\"name\":\"sell\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"baseAssetSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"quoteAssetSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"baseAssetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"grossBaseQuantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"grossQuoteQuantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"netBaseQuantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"netQuoteQuantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"makerFeeAssetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerFeeAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"makerFeeQuantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"takerFeeQuantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"priceInPips\",\"type\":\"uint64\"},{\"internalType\":\"enum Enums.OrderSide\",\"name\":\"makerSide\",\"type\":\"uint8\"}],\"internalType\":\"struct Structs.Trade\",\"name\":\"trade\",\"type\":\"tuple\"}],\"name\":\"executeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"}],\"name\":\"invalidateOrderNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"timestampInMs\",\"type\":\"uint64\"}],\"name\":\"loadAssetBySymbol\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isConfirmed\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"confirmedTimestampInMs\",\"type\":\"uint64\"}],\"internalType\":\"struct Structs.Asset\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"loadBalanceInAssetUnitsByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"}],\"name\":\"loadBalanceInAssetUnitsBySymbol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"loadBalanceInPipsByAddress\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"}],\"name\":\"loadBalanceInPipsBySymbol\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadFeeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"loadPartiallyFilledOrderQuantityInPips\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"registerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDispatcher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newChainPropagationPeriod\",\"type\":\"uint256\"}],\"name\":\"setChainPropagationPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newCustodian\",\"type\":\"address\"}],\"name\":\"setCustodian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDispatcherWallet\",\"type\":\"address\"}],\"name\":\"setDispatcher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeWallet\",\"type\":\"address\"}],\"name\":\"setFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum Enums.WithdrawalType\",\"name\":\"withdrawalType\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"},{\"internalType\":\"address payable\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"assetSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"quantityInPips\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"gasFeeInPips\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"autoDispatchEnabled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"walletSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct Structs.Withdrawal\",\"name\":\"withdrawal\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"withdrawExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Exchange","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"49","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5dd7ac35c5f7c6f5ec79f4ba79633e7c75138d994328bbe33fa2efc0d21be22d"}]}