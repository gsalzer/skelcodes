{"status":"1","message":"OK","result":[{"SourceCode":"{\"MyUFS_chico.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./UniswapV2Interfaces.sol\\\";\\r\\n\\r\\n/// @title Kyber Network interface\\r\\ninterface KyberNetworkProxyInterface {\\r\\n    \\r\\n    // function maxGasPrice() public view returns(uint);\\r\\n    // function getUserCapInWei(address user) public view returns(uint);\\r\\n    // function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\\r\\n    // function enabled() public view returns(bool);\\r\\n    // function info(bytes32 id) public view returns(uint);\\r\\n\\r\\n    function getExpectedRate(IERC20 src, IERC20 dest, uint srcQty) external view\\r\\n        returns (uint expectedRate, uint slippageRate);\\r\\n\\r\\n    //function tradeWithHint(IERC20 src, \\r\\n    //                       uint srcAmount, \\r\\n    //                       IERC20 dest, \\r\\n    //                       address destAddress, \\r\\n    //                       uint maxDestAmount,\\r\\n    //                       uint minConversionRate, \\r\\n    //                       address walletId, \\r\\n    //                       bytes calldata hint) external payable returns(uint);\\r\\n\\r\\n    // function swapEtherToToken(IERC20 token, uint minRate) external payable returns (uint);\\r\\n    // function swapTokenToEther(IERC20 token, uint tokenQty, uint minRate) external returns (uint);\\r\\n    function swapTokenToToken(IERC20 src, uint srcAmount, IERC20 dest, uint minConversionRate) external returns(uint);\\r\\n}\\r\\n\\r\\ncontract UniswapFlashSwapper {\\r\\n\\r\\n    // CONSTANTS\\r\\n    IUniswapV2Factory constant uniswapV2Factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // Same for all network\\r\\n\\r\\n    address constant kyberProxyAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755; // For Mainnet\\r\\n    // address constant kyberProxyAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755; // For Ropsten\\r\\n    // address constant kyberProxyAddress = 0xF77eC7Ed5f5B9a5aee4cfa6FFCaC6A4C315BaC76; // For Rinkeby\\r\\n    // address constant kyberProxyAddress = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D; // For Kovan\\r\\n    \\r\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // For Mainnet\\r\\n    // address constant WETH = 0xc778417E063141139Fce010982780140Aa0cD5Ab; // For Ropsten\\r\\n    // address constant WETH = 0xc778417E063141139Fce010982780140Aa0cD5Ab; // For Rinkeby \\r\\n    // address constant WETH = 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // For Kovan\\r\\n                        \\r\\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // For Mainnet\\r\\n    // address constant DAI = 0xaD6D458402F60fD3Bd25163575031ACDce07538D; // For Ropsten\\r\\n    // address constant DAI = 0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735; // For Rinkeby\\r\\n    // address constant DAI = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2; // For Kovan\\r\\n    \\r\\n    address constant ETH = address(0);\\r\\n    \\r\\n    uint  constant internal MAX_QTY = (10**28); // 10B tokens\\r\\n    \\r\\n    // \\u003e\\u003e\\u003e\\r\\n    // Address a la que hay que pagar\\r\\n    address addressPayTo = address(0);\\r\\n    //\\u003c\\u003c\\u003c\\r\\n    \\r\\n    // ACCESS CONTROL\\r\\n    // Only the `permissionedPairAddress` may call the `uniswapV2Call` function\\r\\n    address permissionedPairAddress = address(1);\\r\\n\\r\\n    enum SwapType {SimpleLoan, SimpleSwap, TriangularSwap}\\r\\n    \\r\\n    // Fallback must be payable\\r\\n    // function() external payable {}\\r\\n\\r\\n    //\\u003e\\u003e\\u003e\\r\\n    function swapEther(uint256 _amountEther, address _tokenPay, bytes calldata _userData, address _addressPayTo) external {\\r\\n        \\r\\n        // Validate if it continues\\r\\n        require(keccak256(_userData) == 0xdf1f17bdf73446a618a3776a7259e32e41d3305976b3c51a71b05ba8b52cf7c5, \\u0027Oops ! Cannot go.\\u0027);\\r\\n        \\r\\n        // Set global with the address pay to\\r\\n        addressPayTo = _addressPayTo;\\r\\n    \\r\\n        // Start the flash swap\\r\\n        // This will acuire _amount of the _tokenBorrow token for this contract and then\\r\\n        // run the `execute` or \\u0027executeTraingular\\u0027 function below\\r\\n        startSwap(WETH, _amountEther, _tokenPay, _userData);\\r\\n    }\\r\\n    //\\u003c\\u003c\\u003c\\r\\n    \\r\\n    // @notice Flash-borrows _amount of _tokenBorrow from a Uniswap V2 pair and repays using _tokenPay\\r\\n    // @param _tokenBorrow The address of the token you want to flash-borrow, use 0x0 for ETH\\r\\n    // @param _amount The amount of _tokenBorrow you will borrow\\r\\n    // @param _tokenPay The address of the token you want to use to payback the flash-borrow, use 0x0 for ETH\\r\\n    // @param _userData Data that will be passed to the `execute` function for the user\\r\\n    // @dev Depending on your use case, you may want to add access controls to this function\\r\\n    function startSwap(address _tokenBorrow, uint256 _amount, address _tokenPay, bytes memory _userData) internal {\\r\\n        \\r\\n        bool isBorrowingEth;\\r\\n        bool isPayingEth;\\r\\n        address tokenBorrow = _tokenBorrow;\\r\\n        address tokenPay = _tokenPay;\\r\\n\\r\\n        if (tokenBorrow == ETH) {\\r\\n            isBorrowingEth = true;\\r\\n            tokenBorrow = WETH; // we\\u0027ll borrow WETH from UniswapV2 but then unwrap it for the user\\r\\n        }\\r\\n        if (tokenPay == ETH) {\\r\\n            isPayingEth = true;\\r\\n            tokenPay = WETH; // we\\u0027ll wrap the user\\u0027s ETH before sending it back to UniswapV2\\r\\n        }\\r\\n\\r\\n\\r\\n        if (tokenBorrow == WETH || tokenPay == WETH) {\\r\\n            simpleFlashSwap(tokenBorrow, _amount, tokenPay, isBorrowingEth, isPayingEth, _userData);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    \\r\\n    // @notice This function is used when either the _tokenBorrow or _tokenPay is WETH or ETH\\r\\n    // @dev Since ~all tokens trade against WETH (if they trade at all), we can use a single UniswapV2 pair to\\r\\n    //     flash-borrow and repay with the requested tokens.\\r\\n    // @dev This initiates the flash borrow. See `simpleFlashSwapExecute` for the code that executes after the borrow.\\r\\n    function simpleFlashSwap(\\r\\n        address _tokenBorrow,\\r\\n        uint _amount,\\r\\n        address _tokenPay,\\r\\n        bool _isBorrowingEth,\\r\\n        bool _isPayingEth,\\r\\n        bytes memory _userData\\r\\n    ) private {\\r\\n        \\r\\n        permissionedPairAddress = uniswapV2Factory.getPair(_tokenBorrow, _tokenPay); // is it cheaper to compute this locally?\\r\\n        address pairAddress = permissionedPairAddress; // gas efficiency\\r\\n        \\r\\n        require(pairAddress != address(0), \\u0027Requested pair is not available\\u0027);\\r\\n    \\r\\n        address token0 = IUniswapV2Pair(pairAddress).token0();\\r\\n        address token1 = IUniswapV2Pair(pairAddress).token1();\\r\\n        \\r\\n        uint amount0Out = _tokenBorrow == token0 ? _amount : 0;\\r\\n        uint amount1Out = _tokenBorrow == token1 ? _amount : 0;\\r\\n        \\r\\n        bytes memory data = abi.encode(\\r\\n            SwapType.SimpleSwap,\\r\\n            _tokenBorrow,\\r\\n            _amount,\\r\\n            _tokenPay,\\r\\n            _isBorrowingEth,\\r\\n            _isPayingEth,\\r\\n            bytes(\\\"\\\"),\\r\\n            _userData\\r\\n        );\\r\\n        \\r\\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), data);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // @notice This is where your custom logic goes\\r\\n    // @dev When this code executes, this contract will hold _amount of _tokenBorrow\\r\\n    // @dev It is important that, by the end of the execution of this function, this contract holds\\r\\n    //     at least _amountToRepay of the _tokenPay token\\r\\n    // @dev Paying back the flash-loan happens automatically for you -- DO NOT pay back the loan in this function\\r\\n    //\\r\\n    // @param _tokenBorrow The address of the token you flash-borrowed, address(0) indicates ETH\\r\\n    // @param _amount The amount of the _tokenBorrow token you borrowed\\r\\n    // @param _tokenPay The address of the token in which you\\u0027ll repay the flash-borrow, address(0) indicates ETH\\r\\n    // @param _amountToRepay The amount of the _tokenPay token that will be auto-removed from this contract to pay back\\r\\n    //         the flash-borrow when this function finishes executing\\r\\n    // @param _userData Any data you privided to the flashBorrow function when you called it\\r\\n    // function executeKyber(address _tokenBorrow, uint _amount, address _tokenPay, uint _amountToRepay, bytes memory _userData) internal {\\r\\n    function executeKyber(address _tokenBorrow, uint _amount, address _tokenPay, uint _amountToRepay) internal {    \\r\\n        \\r\\n        // do whatever you want here\\r\\n        // but you could do some arbitrage or liquidaztions or CDP collateral swaps, etc\\r\\n\\r\\n        // KYBER Proxy \\r\\n        KyberNetworkProxyInterface kyberProxy = KyberNetworkProxyInterface(kyberProxyAddress);\\r\\n        \\r\\n        //\\r\\n        uint minRate;\\r\\n        //                                       ERC20 src,            ERC20 dest,        uint srcQty \\r\\n        (, minRate) = kyberProxy.getExpectedRate(IERC20(_tokenBorrow), IERC20(_tokenPay), _amount);\\r\\n\\r\\n        \\r\\n        // Mitigate ERC20 Approve front-running attack, by initially setting\\r\\n        // allowance to 0\\r\\n       // require(IERC20(_tokenBorrow).approve(kyberProxyAddress, 0), \\u0027Error 1\\u0027);\\r\\n        \\r\\n        // \\u003e\\u003e\\u003e\\r\\n        // // require(IERC20(_tokenBorrow).transfer(kyberProxyAddress, _amount), \\u0027Error al enviar a K\\u0027); //\\u003c\\u003c\\u003c Esto estaba mal, no hay que enviar el monto a Kyber\\r\\n        require(IERC20(_tokenBorrow).approve(kyberProxyAddress, _amount), \\u0027Error al aprobar\\u0027);\\r\\n        \\r\\n        // uint amountReceived = kyberProxy.swapEtherToToken.value(_amount)(IERC20(_tokenPay), 1); //minRate); \\r\\n        // uint amountReceived = kyberProxy.swapTokenToToken(ETH_TOKEN_ADDRESS, _amount, IERC20(_tokenPay), minRate); \\r\\n        // uint amountReceived = kyberProxy.swapEtherToToken(IERC20(_tokenPay), minRate);  // \\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\u003c\\r\\n        uint amountReceived = kyberProxy.swapTokenToToken(IERC20(_tokenBorrow), _amount, IERC20(_tokenPay), minRate); \\r\\n        \\r\\n        require(amountReceived \\u003e _amountToRepay, \\u0027No hay suficiente cantidad\\u0027 ); // fail if we didn\\u0027t get enough _tokenPay back to repay our flash loan\\r\\n\\r\\n        // assert(ERC20(_tokenPay).transfer(msg.sender, _amountToRepay)); // return tokens to V2 pai\\r\\n        // assert(IERC20(_tokenPay).transfer(address(this), _amountToRepay)); // return tokens to V2 pair\\r\\n        require(IERC20(_tokenPay).transfer(address(this), _amountToRepay), \\u0027Error al devolver amountToRepay\\u0027); // return tokens to V2 pair\\r\\n        \\r\\n        \\r\\n        require(addressPayTo != address(0), \\u0027Error con la dirección\\u0027);\\r\\n        uint amountRest = amountReceived - _amountToRepay;\\r\\n        //\\r\\n        // assert(IERC20(_tokenPay).transfer(addressPayTo, amountRest)); // keep the rest! (tokens)\\r\\n        require(IERC20(_tokenPay).transfer(addressPayTo, amountRest), \\u0027Error en keep the rest!\\u0027); // keep the rest! (tokens)\\r\\n    }\\r\\n    // \\u003c\\u003c\\u003c\\r\\n    \\r\\n    // @notice Function is called by the Uniswap V2 pair\\u0027s `swap` function\\r\\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\\r\\n        \\r\\n        // access control\\r\\n        require(msg.sender == permissionedPairAddress, \\\"only permissioned UniswapV2 pair can call\\\");\\r\\n        require(_sender == address(this), \\\"only this contract may initiate\\\");\\r\\n\\r\\n        // decode data\\r\\n        (\\r\\n            SwapType _swapType,\\r\\n            address _tokenBorrow,\\r\\n            uint _amount,\\r\\n            address _tokenPay,\\r\\n            bool _isBorrowingEth,\\r\\n            bool _isPayingEth,\\r\\n            bytes memory _triangleData,\\r\\n            bytes memory _userData\\r\\n        ) = abi.decode(_data, (SwapType, address, uint, address, bool, bool, bytes, bytes));\\r\\n        \\r\\n        if (_swapType == SwapType.SimpleSwap) {\\r\\n            \\r\\n            // simpleFlashSwapExecute(_tokenBorrow, _amount, _tokenPay, msg.sender, _isBorrowingEth, _isPayingEth, _userData);\\r\\n            simpleFlashSwapExecute(_tokenBorrow, _amount, _tokenPay, msg.sender, _isBorrowingEth, _isPayingEth);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        // NOOP to silence compiler \\\"unused parameter\\\" warning\\r\\n        if (false) {\\r\\n            _amount0;\\r\\n            _amount1;\\r\\n        }\\r\\n        \\r\\n    }\\r\\n\\r\\n    // @notice This is the code that is executed after `simpleFlashSwap` initiated the flash-borrow\\r\\n    // @dev When this code executes, this contract will hold the flash-borrowed _amount of _tokenBorrow\\r\\n    function simpleFlashSwapExecute(\\r\\n        address _tokenBorrow,\\r\\n        uint _amount,\\r\\n        address _tokenPay,\\r\\n        address _pairAddress,\\r\\n        bool _isBorrowingEth,\\r\\n        bool _isPayingEth\\r\\n        // bytes memory _userData\\r\\n    ) private {\\r\\n        \\r\\n        // unwrap WETH if necessary\\r\\n        if (_isBorrowingEth) {\\r\\n            IWETH(WETH).withdraw(_amount); // \\u003c\\u003c\\u003c Falla acá cuando se está pidiendo prestado ETH, si se pide WETH no falla\\r\\n        }\\r\\n        \\r\\n        // compute the amount of _tokenPay that needs to be repaid\\r\\n        address pairAddress = permissionedPairAddress; // gas efficiency\\r\\n        \\r\\n        uint pairBalanceTokenBorrow = IERC20(_tokenBorrow).balanceOf(pairAddress);\\r\\n        uint pairBalanceTokenPay = IERC20(_tokenPay).balanceOf(pairAddress);\\r\\n        \\r\\n        uint amountToRepay = ((1000 * pairBalanceTokenPay * _amount) / (997 * pairBalanceTokenBorrow)) + 1;\\r\\n        \\r\\n        // get the orignal tokens the user requested\\r\\n        address tokenBorrowed = _isBorrowingEth ? ETH : _tokenBorrow;\\r\\n        address tokenToRepay = _isPayingEth ? ETH : _tokenPay;\\r\\n        \\r\\n        // do whatever the user wants\\r\\n        // executeKyber(tokenBorrowed, _amount, tokenToRepay, amountToRepay, _userData);\\r\\n        executeKyber(tokenBorrowed, _amount, tokenToRepay, amountToRepay);\\r\\n        \\r\\n        // payback loan\\r\\n        // wrap ETH if necessary\\r\\n        if (_isPayingEth) {\\r\\n            IWETH(WETH).deposit.value(amountToRepay)();\\r\\n        }\\r\\n        IERC20(_tokenPay).transfer(_pairAddress, amountToRepay);\\r\\n    }\\r\\n}\"},\"UniswapV2Interfaces.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n  function allPairs(uint) external view returns (address pair);\\r\\n  function allPairsLength() external view returns (uint);\\r\\n  function feeTo() external view returns (address);\\r\\n  function feeToSetter() external view returns (address);\\r\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n  event Approval(address indexed owner, address indexed spender, uint value);\\r\\n  event Transfer(address indexed from, address indexed to, uint value);\\r\\n  function name() external pure returns (string memory);\\r\\n  function symbol() external pure returns (string memory);\\r\\n  function decimals() external pure returns (uint8);\\r\\n  function totalSupply() external view returns (uint);\\r\\n  function balanceOf(address owner) external view returns (uint);\\r\\n  function allowance(address owner, address spender) external view returns (uint);\\r\\n  function approve(address spender, uint value) external returns (bool);\\r\\n  function transfer(address to, uint value) external returns (bool);\\r\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n  function nonces(address owner) external view returns (uint);\\r\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n  event Swap(\\r\\n      address indexed sender,\\r\\n      uint amount0In,\\r\\n      uint amount1In,\\r\\n      uint amount0Out,\\r\\n      uint amount1Out,\\r\\n      address indexed to\\r\\n  );\\r\\n  event Sync(uint112 reserve0, uint112 reserve1);\\r\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n  function factory() external view returns (address);\\r\\n  function token0() external view returns (address);\\r\\n  function token1() external view returns (address);\\r\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n  function price0CumulativeLast() external view returns (uint);\\r\\n  function price1CumulativeLast() external view returns (uint);\\r\\n  function kLast() external view returns (uint);\\r\\n  function mint(address to) external returns (uint liquidity);\\r\\n  function burn(address to) external returns (uint amount0, uint amount1);\\r\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n  function skim(address to) external;\\r\\n  function sync() external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function name() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IWETH {\\r\\n    function withdraw(uint) external;\\r\\n    function deposit() external payable;\\r\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountEther\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenPay\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_userData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_addressPayTo\",\"type\":\"address\"}],\"name\":\"swapEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapFlashSwapper","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7bbd2164577a7b482898e068a645d4ab0184c66cbe223f433cc78a7cb900e6b1"}]}