{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.4;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nstruct PoolParams {\r\n    string poolTokenSymbol;\r\n    string poolTokenName;\r\n    address[] constituentTokens;\r\n    uint256[] tokenBalances;\r\n    uint256[] tokenWeights;\r\n    uint256 swapFee;\r\n}\r\n\r\nstruct Rights {\r\n    bool canPauseSwapping;\r\n    bool canChangeSwapFee;\r\n    bool canChangeWeights;\r\n    bool canAddRemoveTokens;\r\n    bool canWhitelistLPs;\r\n    bool canChangeCap;\r\n}\r\n\r\nlibrary BalancerConstants {\r\n    uint256 public constant BONE = 10**18;\r\n}\r\n\r\ninterface IConfigurableRightsPool is IERC20 {\r\n    function whitelistLiquidityProvider(address provider) external;\r\n\r\n    function setController(address newOwner) external;\r\n    function getController() external returns (address);\r\n\r\n    function createPool(\r\n        uint256 initialSupply,\r\n        uint256 minimumWeightChangeBlockPeriodParam,\r\n        uint256 addTokenTimeLockInBlocksParam\r\n    ) external;\r\n\r\n    function updateWeightsGradually(\r\n        uint256[] calldata newWeights,\r\n        uint256 startBlock,\r\n        uint256 endBlock\r\n    ) external;\r\n\r\n    function bPool() external view returns (address);\r\n    function pokeWeights() external;\r\n    function setPublicSwap(bool) external;\r\n}\r\n\r\ninterface ICRPFactory {\r\n    function newCrp(\r\n        address factoryAddress,\r\n        PoolParams calldata poolParams,\r\n        Rights calldata rights\r\n    ) external returns (IConfigurableRightsPool);\r\n}\r\n\r\ninterface IERC20Decimal is IERC20 {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract RadicleLbp {\r\n    IERC20Decimal public immutable radToken;\r\n    IERC20Decimal public immutable usdcToken;\r\n    Sale public immutable sale;\r\n\r\n    uint256 public constant RAD_BALANCE = 3750000e18; // 3.75 million RAD\r\n    uint256 public constant USDC_BALANCE = 3500000e6; // 3.5 million USDC\r\n    uint256 public constant RAD_WEIGHT = 37;\r\n    uint256 public constant USDC_WEIGHT = 3;\r\n    uint256 public constant SWAP_FEE = 5e15; // 0.5%\r\n\r\n    constructor(\r\n        address bFactory,\r\n        address crpFactory,\r\n        IERC20Decimal _radToken,\r\n        IERC20Decimal _usdcToken,\r\n        address lp\r\n    ) {\r\n        ICRPFactory factory = ICRPFactory(crpFactory);\r\n\r\n        // RAD starting balance and weight.\r\n        uint256 radTokenWeight = RAD_WEIGHT * BalancerConstants.BONE;\r\n\r\n        // USDC starting balance and weight.\r\n        uint256 usdcTokenWeight = USDC_WEIGHT * BalancerConstants.BONE;\r\n\r\n        // Permissions on the pool.\r\n        Rights memory rights;\r\n        rights.canPauseSwapping = true;\r\n        rights.canChangeSwapFee = false;\r\n        rights.canChangeWeights = true;\r\n        rights.canAddRemoveTokens = false;\r\n        rights.canWhitelistLPs = true;\r\n        rights.canChangeCap = false;\r\n\r\n        // Pool parameters.\r\n        PoolParams memory params;\r\n        params.poolTokenSymbol = \"RADP\";\r\n        params.poolTokenName = \"RAD Pool Token\";\r\n\r\n        params.constituentTokens = new address[](2);\r\n        params.tokenBalances = new uint256[](2);\r\n        params.tokenWeights = new uint256[](2);\r\n\r\n        params.constituentTokens[0] = address(_radToken);\r\n        params.tokenBalances[0] = RAD_BALANCE;\r\n        params.tokenWeights[0] = radTokenWeight;\r\n\r\n        params.constituentTokens[1] = address(_usdcToken);\r\n        params.tokenBalances[1] = USDC_BALANCE;\r\n        params.tokenWeights[1] = usdcTokenWeight;\r\n        params.swapFee = SWAP_FEE;\r\n\r\n        IConfigurableRightsPool _crpPool = factory.newCrp(bFactory, params, rights);\r\n\r\n        // Create the sale contract and transfer ownership of the CRP to the sale contract.\r\n        Sale _sale = new Sale(_crpPool, _radToken, _usdcToken, RAD_BALANCE, USDC_BALANCE, lp);\r\n        _crpPool.setController(address(_sale));\r\n\r\n        sale = _sale;\r\n        radToken = _radToken;\r\n        usdcToken = _usdcToken;\r\n    }\r\n}\r\n\r\ncontract Sale {\r\n    IConfigurableRightsPool public immutable crpPool;\r\n\r\n    uint256 public immutable radTokenBalance;\r\n    uint256 public immutable usdcTokenBalance;\r\n\r\n    IERC20 public immutable radToken;\r\n    IERC20 public immutable usdcToken;\r\n\r\n    uint256 public constant RAD_END_WEIGHT = 20;\r\n    uint256 public constant USDC_END_WEIGHT = 20;\r\n\r\n    address lp;\r\n\r\n    constructor(\r\n        IConfigurableRightsPool _crpPool,\r\n        IERC20 _radToken,\r\n        IERC20 _usdcToken,\r\n        uint256 _radTokenBalance,\r\n        uint256 _usdcTokenBalance,\r\n        address _lp\r\n    ) {\r\n        crpPool = _crpPool;\r\n        radToken = _radToken;\r\n        usdcToken = _usdcToken;\r\n        radTokenBalance = _radTokenBalance;\r\n        usdcTokenBalance = _usdcTokenBalance;\r\n        lp = _lp;\r\n    }\r\n\r\n    /// Begin the sale. Transfers balances from the sender into the\r\n    /// Balancer pool, and transfers the pool tokens to the sender.\r\n    function begin(\r\n        uint256 minimumWeightChangeBlockPeriod,\r\n        uint256 weightChangeStartDelay,\r\n        address controller\r\n    ) public {\r\n        require(\r\n            msg.sender == lp,\r\n            \"Sale::begin: only the LP can call this function\"\r\n        );\r\n        require(\r\n            controller != address(0),\r\n            \"Sale::begin: the controller must be set\"\r\n        );\r\n        require(\r\n            radToken.transferFrom(msg.sender, address(this), radTokenBalance),\r\n            \"Sale::begin: transfer of RAD must succeed\"\r\n        );\r\n        require(\r\n            usdcToken.transferFrom(msg.sender, address(this), usdcTokenBalance),\r\n            \"Sale::begin: transfer of USDC must succeed\"\r\n        );\r\n        require(\r\n            crpPool.getController() == address(this),\r\n            \"Sale::begin: sale must be controller\"\r\n        );\r\n\r\n        radToken.approve(address(crpPool), radTokenBalance);\r\n        usdcToken.approve(address(crpPool), usdcTokenBalance);\r\n\r\n        // How many pool tokens to mint.\r\n        uint256 poolTokens = 100 * BalancerConstants.BONE;\r\n\r\n        crpPool.createPool(\r\n          poolTokens,\r\n          minimumWeightChangeBlockPeriod,\r\n          0\r\n        );\r\n\r\n        require(\r\n            crpPool.totalSupply() == poolTokens,\r\n            \"Sale::begin: pool tokens must match total supply\"\r\n        );\r\n\r\n        uint256[] memory endWeights = new uint256[](2);\r\n        endWeights[0] = RAD_END_WEIGHT * BalancerConstants.BONE;\r\n        endWeights[1] = USDC_END_WEIGHT * BalancerConstants.BONE;\r\n\r\n        // Start and end of the weight/price curve.\r\n        uint256 startBlock = block.number + weightChangeStartDelay;\r\n        uint256 endBlock = startBlock + minimumWeightChangeBlockPeriod;\r\n\r\n        // Kick-off the price curve.\r\n        crpPool.updateWeightsGradually(endWeights, startBlock, endBlock);\r\n        // Transfer ownership of the pool tokens to the sender.\r\n        crpPool.transfer(msg.sender, poolTokens);\r\n        // Set the pool controller, who can pause the sale.\r\n        crpPool.setController(controller);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crpFactory\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Decimal\",\"name\":\"_radToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Decimal\",\"name\":\"_usdcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"RAD_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAD_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"radToken\",\"outputs\":[{\"internalType\":\"contract IERC20Decimal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"internalType\":\"contract Sale\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcToken\",\"outputs\":[{\"internalType\":\"contract IERC20Decimal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RadicleLbp","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009424b1412450d0f8fc2255faf6046b98213b76bd000000000000000000000000ed52d8e202401645edad1c0aa21e872498ce47d000000000000000000000000031c8eacbffdd875c74b94b077895bd78cf1e64a3000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000008da8f82d2bbdd896822de723f55d6edf416130ba","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://49bfb1dfe6eb0e818b1aa5337ee12c3d4cf3cd5942176d8c096719a29d5aaff8"}]}