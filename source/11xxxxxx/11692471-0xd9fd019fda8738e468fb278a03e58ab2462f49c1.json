{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply + amount;\r\n        _balances[account] = _balances[account] + amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account] - amount;\r\n        _totalSupply = _totalSupply - amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\nabstract contract ERC20Capped is ERC20 {\r\n    uint256 private _cap;\r\n\r\n    constructor(uint256 cap_) {\r\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\r\n        _cap = cap_;\r\n    }\r\n\r\n    function cap() public view returns (uint256) {\r\n        return _cap;\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n\r\n        if (from == address(0)) {\r\n            // When minting tokens\r\n            require(\r\n                totalSupply() + amount <= _cap,\r\n                \"ERC20Capped: cap exceeded\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ncontract FourPool is ERC20Capped {\r\n    ERC20 private _token;\r\n\r\n    uint32 t_count;\r\n    uint32 constant ref_fee_pct = 1;\r\n    address payable _team;\r\n    uint256 constant trade_fee_pct = 1;\r\n    uint256 constant trade_fee_pct_divider = 2;\r\n    uint256 constant base_price = 0.00001 ether;\r\n    uint256 constant _factor = (10**12);\r\n\r\n    event OnPool(\r\n        uint32 t_count,\r\n        uint32 a,\r\n        uint32 b,\r\n        uint32 c,\r\n        uint32 d,\r\n        uint32 reward,\r\n        Pool pool\r\n    );\r\n\r\n    event OnUser(\r\n        address indexed addr,\r\n        uint32 staked,\r\n        uint32 pool_amount,\r\n        uint32 t_count,\r\n        uint32 t_count_max,\r\n        Pool join_pool,\r\n        address referred_by\r\n    );\r\n\r\n    event OnReferral(address indexed addr, uint32 fee);\r\n\r\n    event OnTrade(\r\n        uint32 t_count,\r\n        uint32 buy,\r\n        uint32 sell,\r\n        uint32 buy_liq,\r\n        uint256 sell_liq\r\n    );\r\n\r\n    enum Pool {None, A, B, C, D}\r\n\r\n    struct User {\r\n        uint32 staked;\r\n        uint32 pool_amount;\r\n        uint32 t_count;\r\n        uint32 t_count_max;\r\n        Pool join_pool;\r\n        address referred_by;\r\n    }\r\n\r\n    mapping(Pool => uint32) pool_amount;\r\n    mapping(address => User) users;\r\n\r\n    constructor(address payable team_)\r\n        ERC20(\"4pool\", \"4PL\")\r\n        ERC20Capped(500 * (10**6))\r\n    {\r\n        _setupDecimals(0);\r\n        _initialise_pools(1);\r\n        _team = team_;\r\n        _token = ERC20(address(this));\r\n\r\n        emit OnTrade(\r\n            0,\r\n            0,\r\n            0,\r\n            uint32(cap() - totalSupply()),\r\n            address(this).balance\r\n        );\r\n    }\r\n\r\n    function _initialise_pools(uint32 _base) internal {\r\n        pool_amount[Pool.A] = _base;\r\n        pool_amount[Pool.B] = _base;\r\n        pool_amount[Pool.C] = _base;\r\n        pool_amount[Pool.D] = _base;\r\n    }\r\n\r\n    modifier handle_slippage(Pool _pool, uint32 _slippage_amount) {\r\n        require(pool_amount[_pool] <= _slippage_amount, \"low_slippage\");\r\n        _;\r\n    }\r\n\r\n    function trade_calc_fee(uint256 value) internal pure returns (uint256) {\r\n        return ((value * trade_fee_pct) / 100) / trade_fee_pct_divider;\r\n    }\r\n\r\n    function reward_calc_fee(uint32 mint_amount)\r\n        internal\r\n        pure\r\n        returns (uint32, uint32)\r\n    {\r\n        uint32 fee = ((mint_amount * ref_fee_pct) / 100);\r\n        if (mint_amount <= 1 || fee < 1) {\r\n            return (mint_amount, 0);\r\n        } else {\r\n            return (mint_amount - fee, fee);\r\n        }\r\n    }\r\n\r\n    function buy() external payable {\r\n        uint256 fee = trade_calc_fee(msg.value);\r\n        _team.transfer(fee);\r\n        _mint(msg.sender, msg.value / base_price);\r\n        emit OnTrade(\r\n            (t_count += 1),\r\n            uint32(msg.value / base_price),\r\n            0,\r\n            uint32(cap() - totalSupply()),\r\n            address(this).balance\r\n        );\r\n    }\r\n\r\n    function sell(uint32 _amount) external {\r\n        require(balanceOf(msg.sender) >= _amount, \"invalid_balance\");\r\n        uint256 value = _amount * base_price;\r\n        uint256 fee = trade_calc_fee(value);\r\n\r\n        _team.transfer(fee);\r\n\r\n        _burn(msg.sender, _amount);\r\n        payable(msg.sender).transfer(value - fee);\r\n\r\n        emit OnTrade(\r\n            (t_count += 1),\r\n            0,\r\n            _amount,\r\n            uint32(cap() - totalSupply()),\r\n            address(this).balance\r\n        );\r\n    }\r\n\r\n    function reinvest(uint32 _slippage_amount)\r\n        external\r\n        handle_slippage(users[msg.sender].join_pool, _slippage_amount)\r\n    {\r\n        uint32 mint_amount = get_mint_amount();\r\n        require(mint_amount > 0, \"no_reward\");\r\n\r\n        (uint32 reward, uint32 fee) = reward_calc_fee(mint_amount);\r\n\r\n        Pool pool = users[msg.sender].join_pool;\r\n        // Adjust pool amounts\r\n        pool_amount[pool] += reward;\r\n\r\n        // Update user\r\n        users[msg.sender].staked += reward;\r\n        users[msg.sender].t_count = t_count + 1;\r\n        users[msg.sender].t_count_max = r_t_max(users[msg.sender].staked);\r\n        users[msg.sender].pool_amount += reward;\r\n\r\n        if (fee > 0) {\r\n            _mint(users[msg.sender].referred_by, fee);\r\n            emit OnReferral(users[msg.sender].referred_by, fee);\r\n        }\r\n\r\n        emit_pool_events(pool, reward);\r\n    }\r\n\r\n    function add(uint32 _amount, uint32 _slippage_amount)\r\n        external\r\n        handle_slippage(users[msg.sender].join_pool, _slippage_amount)\r\n    {\r\n        require(_amount > 0, \"sending_zero\");\r\n        require(balanceOf(msg.sender) >= _amount, \"invalid_balance\");\r\n        Pool pool = users[msg.sender].join_pool;\r\n        require(pool != Pool.None, \"not_in_pool\");\r\n\r\n        uint32 mint_amount = get_mint_amount();\r\n        (uint32 reward, uint32 fee) = reward_calc_fee(mint_amount);\r\n\r\n        // Adjust pool amounts\r\n        pool_amount[pool] += _amount + reward;\r\n\r\n        // Update user\r\n        users[msg.sender].staked += _amount + reward;\r\n        users[msg.sender].t_count = t_count + 1;\r\n        users[msg.sender].t_count_max = r_t_max(users[msg.sender].staked);\r\n        users[msg.sender].pool_amount += _amount + reward;\r\n\r\n        if (fee > 0) {\r\n            _mint(users[msg.sender].referred_by, fee);\r\n            emit OnReferral(users[msg.sender].referred_by, fee);\r\n        }\r\n\r\n        _burn(msg.sender, _amount);\r\n\r\n        emit_pool_events(pool, reward);\r\n    }\r\n\r\n    function swap(Pool _pool, uint32 _slippage_amount)\r\n        external\r\n        handle_slippage(_pool, _slippage_amount)\r\n    {\r\n        require(users[msg.sender].join_pool != Pool.None, \"not_in_pool\");\r\n        require(_pool != users[msg.sender].join_pool, \"same_pool\");\r\n\r\n        uint32 amount = users[msg.sender].staked;\r\n        uint32 mint_amount = get_mint_amount();\r\n        (uint32 reward, uint32 fee) = reward_calc_fee(mint_amount);\r\n\r\n        // Adjust pool amounts\r\n        pool_amount[_pool] += amount;\r\n        pool_amount[users[msg.sender].join_pool] -= amount;\r\n\r\n        // Update user\r\n        users[msg.sender].t_count = t_count + 1;\r\n        users[msg.sender].t_count_max = r_t_max(users[msg.sender].staked);\r\n        users[msg.sender].join_pool = _pool;\r\n        users[msg.sender].pool_amount = pool_amount[_pool];\r\n\r\n        if (reward > 0) {\r\n            _mint(msg.sender, reward);\r\n        }\r\n\r\n        if (fee > 0) {\r\n            _mint(users[msg.sender].referred_by, fee);\r\n            emit OnReferral(users[msg.sender].referred_by, fee);\r\n        }\r\n\r\n        emit_pool_events(_pool, reward);\r\n    }\r\n\r\n    function join(\r\n        uint32 _amount,\r\n        Pool _pool,\r\n        address _referredBy,\r\n        uint32 _slippage_amount\r\n    ) external handle_slippage(_pool, _slippage_amount) {\r\n        require(_pool != Pool.None, \"not_in_pool\");\r\n        require(users[msg.sender].join_pool == Pool.None, \"already_in_pool\");\r\n        require(_amount > 0, \"sending_zero\");\r\n        require(balanceOf(msg.sender) >= _amount, \"invalid_balance\");\r\n        require(_referredBy != address(0), \"invalid_ref\");\r\n        require(_referredBy != msg.sender, \"self_ref\");\r\n\r\n        // Adjust _pool amounts\r\n        pool_amount[_pool] += _amount;\r\n\r\n        // Update user\r\n        users[msg.sender].join_pool = _pool;\r\n        users[msg.sender].staked = _amount;\r\n        users[msg.sender].t_count = t_count + 1;\r\n        users[msg.sender].t_count_max = r_t_max(_amount);\r\n        users[msg.sender].pool_amount = pool_amount[_pool];\r\n        users[msg.sender].referred_by = _referredBy;\r\n\r\n        _burn(msg.sender, _amount);\r\n\r\n        emit_pool_events(_pool, 0);\r\n    }\r\n\r\n    function leave(uint32 _slippage_amount)\r\n        external\r\n        handle_slippage(users[msg.sender].join_pool, _slippage_amount)\r\n    {\r\n        Pool pool = users[msg.sender].join_pool;\r\n        require(pool != Pool.None, \"not_in_pool\");\r\n        uint32 amount = users[msg.sender].staked;\r\n\r\n        uint32 mint_amount = get_mint_amount();\r\n        (uint32 reward, uint32 fee) = reward_calc_fee(mint_amount);\r\n\r\n        // Adjust pool amounts\r\n        pool_amount[pool] -= amount;\r\n\r\n        // Update user\r\n        delete users[msg.sender].join_pool;\r\n        delete users[msg.sender].staked;\r\n        delete users[msg.sender].t_count;\r\n        delete users[msg.sender].t_count_max;\r\n        delete users[msg.sender].pool_amount;\r\n\r\n        _mint(msg.sender, amount + reward);\r\n\r\n        if (fee > 0) {\r\n            _mint(users[msg.sender].referred_by, fee);\r\n            emit OnReferral(users[msg.sender].referred_by, fee);\r\n        }\r\n\r\n        emit_pool_events(pool, reward);\r\n    }\r\n\r\n    function emit_pool_events(Pool pool, uint32 reward) internal {\r\n        emit OnPool(\r\n            (t_count += 1),\r\n            pool_amount[Pool.A],\r\n            pool_amount[Pool.B],\r\n            pool_amount[Pool.C],\r\n            pool_amount[Pool.D],\r\n            reward,\r\n            pool\r\n        );\r\n\r\n        emit OnUser(\r\n            msg.sender,\r\n            users[msg.sender].staked,\r\n            users[msg.sender].pool_amount,\r\n            users[msg.sender].t_count,\r\n            users[msg.sender].t_count_max,\r\n            users[msg.sender].join_pool,\r\n            users[msg.sender].referred_by\r\n        );\r\n    }\r\n\r\n    function get_mint_amount() internal view returns (uint32 total) {\r\n        if (users[msg.sender].join_pool == Pool.None) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 pool_total =\r\n            pool_amount[Pool.A] +\r\n                pool_amount[Pool.B] +\r\n                pool_amount[Pool.C] +\r\n                pool_amount[Pool.D];\r\n\r\n        uint256 tcount =\r\n            r_t_count(\r\n                users[msg.sender].t_count_max,\r\n                users[msg.sender].t_count,\r\n                t_count\r\n            );\r\n\r\n        uint256 pool =\r\n            r_pool(\r\n                users[msg.sender].pool_amount,\r\n                pool_amount[users[msg.sender].join_pool],\r\n                pool_total\r\n            );\r\n\r\n        uint256 amount = r_amount(users[msg.sender].staked, cap());\r\n\r\n        uint256 rate_total = r_total(pool, tcount, amount);\r\n\r\n        total = r_mint(rate_total, cap() - totalSupply());\r\n    }\r\n\r\n    function r_mint(uint256 _total, uint256 _remaining)\r\n        public\r\n        pure\r\n        returns (uint32 r)\r\n    {\r\n        r = uint32((_remaining * _total) / (_factor));\r\n    }\r\n\r\n    function r_amount(uint256 _amount, uint256 _max)\r\n        public\r\n        pure\r\n        returns (uint256 r)\r\n    {\r\n        _amount *= _factor;\r\n        r = _amount / _max;\r\n    }\r\n\r\n    function r_pool(\r\n        uint256 _enter_amount,\r\n        uint256 _exit_amount,\r\n        uint256 _max\r\n    ) public pure returns (uint256 r) {\r\n        _exit_amount *= _factor;\r\n        _enter_amount *= _factor;\r\n        if (_exit_amount < _enter_amount) {\r\n            return 0;\r\n        }\r\n        return (_exit_amount - _enter_amount) / (_max);\r\n    }\r\n\r\n    function r_total(\r\n        uint256 _pool,\r\n        uint256 _tcount,\r\n        uint256 _amount\r\n    ) public pure returns (uint256 r) {\r\n        r = (_pool * _tcount * _amount) / (_factor * _factor);\r\n    }\r\n\r\n    function r_t_count(\r\n        uint256 _max_tcount,\r\n        uint256 _enter_count,\r\n        uint256 _leave_count\r\n    ) public pure returns (uint256) {\r\n        _leave_count *= _factor;\r\n        _enter_count *= _factor;\r\n        uint256 _rate = (_leave_count - _enter_count) / (_max_tcount);\r\n        if (_rate > _factor) {\r\n            return _factor * 2;\r\n        }\r\n        return _rate * 2;\r\n    }\r\n\r\n    function r_t_max(uint256 _amount) public pure returns (uint32) {\r\n        return uint32(sqrt(_amount));\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    function ui() external view returns (uint256[12] memory acc) {\r\n        acc[0] = t_count;\r\n        acc[1] = pool_amount[Pool.A];\r\n        acc[2] = pool_amount[Pool.B];\r\n        acc[3] = pool_amount[Pool.C];\r\n        acc[4] = pool_amount[Pool.D];\r\n        acc[5] = cap() - totalSupply();\r\n        acc[6] = address(this).balance;\r\n        acc[7] = users[msg.sender].staked;\r\n        acc[8] = users[msg.sender].pool_amount;\r\n        acc[9] = users[msg.sender].t_count;\r\n        acc[10] = users[msg.sender].t_count_max;\r\n        acc[11] = uint256(users[msg.sender].join_pool);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"team_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"t_count\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"a\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"b\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"c\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"d\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"reward\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"enum FourPool.Pool\",\"name\":\"pool\",\"type\":\"uint8\"}],\"name\":\"OnPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fee\",\"type\":\"uint32\"}],\"name\":\"OnReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"t_count\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"buy\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"sell\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"buy_liq\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell_liq\",\"type\":\"uint256\"}],\"name\":\"OnTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"staked\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"pool_amount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"t_count\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"t_count_max\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"enum FourPool.Pool\",\"name\":\"join_pool\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referred_by\",\"type\":\"address\"}],\"name\":\"OnUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_amount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_slippage_amount\",\"type\":\"uint32\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_amount\",\"type\":\"uint32\"},{\"internalType\":\"enum FourPool.Pool\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_slippage_amount\",\"type\":\"uint32\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_slippage_amount\",\"type\":\"uint32\"}],\"name\":\"leave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"r_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_remaining\",\"type\":\"uint256\"}],\"name\":\"r_mint\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"r\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_enter_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exit_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"r_pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max_tcount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_enter_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_leave_count\",\"type\":\"uint256\"}],\"name\":\"r_t_count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"r_t_max\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tcount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"r_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_slippage_amount\",\"type\":\"uint32\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_amount\",\"type\":\"uint32\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FourPool.Pool\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_slippage_amount\",\"type\":\"uint32\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ui\",\"outputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"acc\",\"type\":\"uint256[12]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FourPool","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000088328ecb7510f281699318ef3e6a8e375f865850","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fc06a013dde8b9a79e4541901783a40a8783b1bf221312cfc8903ba49d800375"}]}