{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DigitalaxAccessControls.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\n/**\\n * @notice Access Controls contract for the Digitalax Platform\\n * @author BlockRocket.tech\\n */\\ncontract DigitalaxAccessControls is AccessControl {\\n    /// @notice Role definitions\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\\\"SMART_CONTRACT_ROLE\\\");\\n\\n    /// @notice Events for adding and removing various roles\\n    event AdminRoleGranted(\\n        address indexed beneficiary,\\n        address indexed caller\\n    );\\n\\n    event AdminRoleRemoved(\\n        address indexed beneficiary,\\n        address indexed caller\\n    );\\n\\n    event MinterRoleGranted(\\n        address indexed beneficiary,\\n        address indexed caller\\n    );\\n\\n    event MinterRoleRemoved(\\n        address indexed beneficiary,\\n        address indexed caller\\n    );\\n\\n    event SmartContractRoleGranted(\\n        address indexed beneficiary,\\n        address indexed caller\\n    );\\n\\n    event SmartContractRoleRemoved(\\n        address indexed beneficiary,\\n        address indexed caller\\n    );\\n\\n    /**\\n     * @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses\\n     */\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    /////////////\\n    // Lookups //\\n    /////////////\\n\\n    /**\\n     * @notice Used to check whether an address has the admin role\\n     * @param _address EOA or contract being checked\\n     * @return bool True if the account has the role or false if it does not\\n     */\\n    function hasAdminRole(address _address) external view returns (bool) {\\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\\n    }\\n\\n    /**\\n     * @notice Used to check whether an address has the minter role\\n     * @param _address EOA or contract being checked\\n     * @return bool True if the account has the role or false if it does not\\n     */\\n    function hasMinterRole(address _address) external view returns (bool) {\\n        return hasRole(MINTER_ROLE, _address);\\n    }\\n\\n    /**\\n     * @notice Used to check whether an address has the smart contract role\\n     * @param _address EOA or contract being checked\\n     * @return bool True if the account has the role or false if it does not\\n     */\\n    function hasSmartContractRole(address _address) external view returns (bool) {\\n        return hasRole(SMART_CONTRACT_ROLE, _address);\\n    }\\n\\n    ///////////////\\n    // Modifiers //\\n    ///////////////\\n\\n    /**\\n     * @notice Grants the admin role to an address\\n     * @dev The sender must have the admin role\\n     * @param _address EOA or contract receiving the new role\\n     */\\n    function addAdminRole(address _address) external {\\n        grantRole(DEFAULT_ADMIN_ROLE, _address);\\n        emit AdminRoleGranted(_address, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Removes the admin role from an address\\n     * @dev The sender must have the admin role\\n     * @param _address EOA or contract affected\\n     */\\n    function removeAdminRole(address _address) external {\\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\\n        emit AdminRoleRemoved(_address, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Grants the minter role to an address\\n     * @dev The sender must have the admin role\\n     * @param _address EOA or contract receiving the new role\\n     */\\n    function addMinterRole(address _address) external {\\n        grantRole(MINTER_ROLE, _address);\\n        emit MinterRoleGranted(_address, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Removes the minter role from an address\\n     * @dev The sender must have the admin role\\n     * @param _address EOA or contract affected\\n     */\\n    function removeMinterRole(address _address) external {\\n        revokeRole(MINTER_ROLE, _address);\\n        emit MinterRoleRemoved(_address, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Grants the smart contract role to an address\\n     * @dev The sender must have the admin role\\n     * @param _address EOA or contract receiving the new role\\n     */\\n    function addSmartContractRole(address _address) external {\\n        grantRole(SMART_CONTRACT_ROLE, _address);\\n        emit SmartContractRoleGranted(_address, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Removes the smart contract role from an address\\n     * @dev The sender must have the admin role\\n     * @param _address EOA or contract affected\\n     */\\n    function removeSmartContractRole(address _address) external {\\n        revokeRole(SMART_CONTRACT_ROLE, _address);\\n        emit SmartContractRoleRemoved(_address, _msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DigitalaxAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./DigitalaxAccessControls.sol\\\";\\nimport \\\"./garment/IDigitalaxGarmentNFT.sol\\\";\\n\\n/**\\n * @notice Primary sale auction contract for Digitalax NFTs\\n */\\ncontract DigitalaxAuction is Context, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using Address for address payable;\\n\\n    /// @notice Event emitted only on construction. To be used by indexers\\n    event DigitalaxAuctionContractDeployed();\\n\\n    event PauseToggled(\\n        bool isPaused\\n    );\\n\\n    event AuctionCreated(\\n        uint256 indexed garmentTokenId\\n    );\\n\\n    event UpdateAuctionEndTime(\\n        uint256 indexed garmentTokenId,\\n        uint256 endTime\\n    );\\n\\n    event UpdateAuctionStartTime(\\n        uint256 indexed garmentTokenId,\\n        uint256 startTime\\n    );\\n\\n    event UpdateAuctionReservePrice(\\n        uint256 indexed garmentTokenId,\\n        uint256 reservePrice\\n    );\\n\\n    event UpdateAccessControls(\\n        address indexed accessControls\\n    );\\n\\n    event UpdatePlatformFee(\\n        uint256 platformFee\\n    );\\n\\n    event UpdatePlatformFeeRecipient(\\n        address payable platformFeeRecipient\\n    );\\n\\n    event UpdateMinBidIncrement(\\n        uint256 minBidIncrement\\n    );\\n\\n    event UpdateBidWithdrawalLockTime(\\n        uint256 bidWithdrawalLockTime\\n    );\\n\\n    event BidPlaced(\\n        uint256 indexed garmentTokenId,\\n        address indexed bidder,\\n        uint256 bid\\n    );\\n\\n    event BidWithdrawn(\\n        uint256 indexed garmentTokenId,\\n        address indexed bidder,\\n        uint256 bid\\n    );\\n\\n    event BidRefunded(\\n        address indexed bidder,\\n        uint256 bid\\n    );\\n\\n    event AuctionResulted(\\n        uint256 indexed garmentTokenId,\\n        address indexed winner,\\n        uint256 winningBid\\n    );\\n\\n    event AuctionCancelled(\\n        uint256 indexed garmentTokenId\\n    );\\n\\n    /// @notice Parameters of an auction\\n    struct Auction {\\n        uint256 reservePrice;\\n        uint256 startTime;\\n        uint256 endTime;\\n        bool resulted;\\n    }\\n\\n    /// @notice Information about the sender that placed a bit on an auction\\n    struct HighestBid {\\n        address payable bidder;\\n        uint256 bid;\\n        uint256 lastBidTime;\\n    }\\n\\n    /// @notice Garment ERC721 Token ID -> Auction Parameters\\n    mapping(uint256 => Auction) public auctions;\\n\\n    /// @notice Garment ERC721 Token ID -> highest bidder info (if a bid has been received)\\n    mapping(uint256 => HighestBid) public highestBids;\\n\\n    /// @notice Garment ERC721 NFT - the only NFT that can be auctioned in this contract\\n    IDigitalaxGarmentNFT public garmentNft;\\n\\n    // @notice responsible for enforcing admin access\\n    DigitalaxAccessControls public accessControls;\\n\\n    /// @notice globally and across all auctions, the amount by which a bid has to increase\\n    uint256 public minBidIncrement = 0.1 ether;\\n\\n    /// @notice global bid withdrawal lock time\\n    uint256 public bidWithdrawalLockTime = 20 minutes;\\n\\n    /// @notice global platform fee, assumed to always be to 1 decimal place i.e. 120 = 12.0%\\n    uint256 public platformFee = 120;\\n\\n    /// @notice where to send platform fee funds to\\n    address payable public platformFeeRecipient;\\n\\n    /// @notice for switching off auction creations, bids and withdrawals\\n    bool public isPaused;\\n\\n    modifier whenNotPaused() {\\n        require(!isPaused, \\\"Function is currently paused\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        DigitalaxAccessControls _accessControls,\\n        IDigitalaxGarmentNFT _garmentNft,\\n        address payable _platformFeeRecipient\\n    ) public {\\n        require(address(_accessControls) != address(0), \\\"DigitalaxAuction: Invalid Access Controls\\\");\\n        require(address(_garmentNft) != address(0), \\\"DigitalaxAuction: Invalid NFT\\\");\\n        require(_platformFeeRecipient != address(0), \\\"DigitalaxAuction: Invalid Platform Fee Recipient\\\");\\n\\n        accessControls = _accessControls;\\n        garmentNft = _garmentNft;\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        emit DigitalaxAuctionContractDeployed();\\n    }\\n\\n    /**\\n     @notice Creates a new auction for a given garment\\n     @dev Only the owner of a garment can create an auction and must have approved the contract\\n     @dev In addition to owning the garment, the sender also has to have the MINTER role.\\n     @dev End time for the auction must be in the future.\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     @param _reservePrice Garment cannot be sold for less than this or minBidIncrement, whichever is higher\\n     @param _startTimestamp Unix epoch in seconds for the auction start time\\n     @param _endTimestamp Unix epoch in seconds for the auction end time.\\n     */\\n    function createAuction(\\n        uint256 _garmentTokenId,\\n        uint256 _reservePrice,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp\\n    ) external whenNotPaused {\\n        // Ensure caller has privileges\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxAuction.createAuction: Sender must have the minter role\\\"\\n        );\\n\\n        // Check owner of the token is the creator and approved\\n        require(\\n            garmentNft.ownerOf(_garmentTokenId) == _msgSender() && garmentNft.isApproved(_garmentTokenId, address(this)),\\n            \\\"DigitalaxAuction.createAuction: Not owner and or contract not approved\\\"\\n        );\\n\\n        _createAuction(\\n            _garmentTokenId,\\n            _reservePrice,\\n            _startTimestamp,\\n            _endTimestamp\\n        );\\n    }\\n\\n    /**\\n     @notice Admin or smart contract can list approved Garments\\n     @dev Sender must have admin or smart contract role\\n     @dev Owner must have approved this contract for the garment or all garments they own\\n     @dev End time for the auction must be in the future.\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     @param _reservePrice Garment cannot be sold for less than this or minBidIncrement, whichever is higher\\n     @param _startTimestamp Unix epoch in seconds for the auction start time\\n     @param _endTimestamp Unix epoch in seconds for the auction end time.\\n     */\\n    function createAuctionOnBehalfOfOwner(\\n        uint256 _garmentTokenId,\\n        uint256 _reservePrice,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp\\n    ) external {\\n        // Ensure caller has privileges\\n        require(\\n            accessControls.hasAdminRole(_msgSender()) || accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxAuction.createAuctionOnBehalfOfOwner: Sender must have admin or smart contract role\\\"\\n        );\\n\\n        require(\\n            garmentNft.isApproved(_garmentTokenId, address(this)),\\n            \\\"DigitalaxAuction.createAuctionOnBehalfOfOwner: Cannot create an auction if you do not have approval\\\"\\n        );\\n\\n        _createAuction(\\n            _garmentTokenId,\\n            _reservePrice,\\n            _startTimestamp,\\n            _endTimestamp\\n        );\\n    }\\n\\n    /**\\n     @notice Places a new bid, out bidding the existing bidder if found and criteria is reached\\n     @dev Only callable when the auction is open\\n     @dev Bids from smart contracts are prohibited to prevent griefing with always reverting receiver\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     */\\n    function placeBid(uint256 _garmentTokenId) external payable nonReentrant whenNotPaused {\\n        require(_msgSender().isContract() == false, \\\"DigitalaxAuction.placeBid: No contracts permitted\\\");\\n\\n        // Check the auction to see if this is a valid bid\\n        Auction storage auction = auctions[_garmentTokenId];\\n\\n        // Ensure auction is in flight\\n        require(\\n            _getNow() >= auction.startTime && _getNow() <= auction.endTime,\\n            \\\"DigitalaxAuction.placeBid: Bidding outside of the auction window\\\"\\n        );\\n\\n        uint256 bidAmount = msg.value;\\n\\n        // Ensure bid adheres to outbid increment and threshold\\n        HighestBid storage highestBid = highestBids[_garmentTokenId];\\n        uint256 minBidRequired = highestBid.bid.add(minBidIncrement);\\n        require(bidAmount >= minBidRequired, \\\"DigitalaxAuction.placeBid: Failed to outbid highest bidder\\\");\\n\\n        // Refund existing top bidder if found\\n        if (highestBid.bidder != address(0)) {\\n            _refundHighestBidder(highestBid.bidder, highestBid.bid);\\n        }\\n\\n        // assign top bidder and bid time\\n        highestBid.bidder = _msgSender();\\n        highestBid.bid = bidAmount;\\n        highestBid.lastBidTime = _getNow();\\n\\n        emit BidPlaced(_garmentTokenId, _msgSender(), bidAmount);\\n    }\\n\\n    /**\\n     @notice Given a sender who has the highest bid on a garment, allows them to withdraw their bid\\n     @dev Only callable by the existing top bidder\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     */\\n    function withdrawBid(uint256 _garmentTokenId) external nonReentrant whenNotPaused {\\n        HighestBid storage highestBid = highestBids[_garmentTokenId];\\n\\n        // Ensure highest bidder is the caller\\n        require(highestBid.bidder == _msgSender(), \\\"DigitalaxAuction.withdrawBid: You are not the highest bidder\\\");\\n\\n        // Check withdrawal after delay time\\n        require(\\n            _getNow() >= highestBid.lastBidTime.add(bidWithdrawalLockTime),\\n            \\\"DigitalaxAuction.withdrawBid: Cannot withdraw until lock time has passed\\\"\\n        );\\n\\n        require(_getNow() < auctions[_garmentTokenId].endTime, \\\"DigitalaxAuction.withdrawBid: Past auction end\\\");\\n\\n        uint256 previousBid = highestBid.bid;\\n\\n        // Clean up the existing top bid\\n        delete highestBids[_garmentTokenId];\\n\\n        // Refund the top bidder\\n        _refundHighestBidder(_msgSender(), previousBid);\\n\\n        emit BidWithdrawn(_garmentTokenId, _msgSender(), previousBid);\\n    }\\n\\n    //////////\\n    // Admin /\\n    //////////\\n\\n    /**\\n     @notice Results a finished auction\\n     @dev Only admin or smart contract\\n     @dev Auction can only be resulted if there has been a bidder and reserve met.\\n     @dev If there have been no bids, the auction needs to be cancelled instead using `cancelAuction()`\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     */\\n    function resultAuction(uint256 _garmentTokenId) external nonReentrant {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()) || accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxAuction.resultAuction: Sender must be admin or smart contract\\\"\\n        );\\n\\n        // Check the auction to see if it can be resulted\\n        Auction storage auction = auctions[_garmentTokenId];\\n\\n        // Check the auction real\\n        require(auction.endTime > 0, \\\"DigitalaxAuction.resultAuction: Auction does not exist\\\");\\n\\n        // Check the auction has ended\\n        require(_getNow() > auction.endTime, \\\"DigitalaxAuction.resultAuction: The auction has not ended\\\");\\n\\n        // Ensure auction not already resulted\\n        require(!auction.resulted, \\\"DigitalaxAuction.resultAuction: auction already resulted\\\");\\n\\n        // Ensure this contract is approved to move the token\\n        require(garmentNft.isApproved(_garmentTokenId, address(this)), \\\"DigitalaxAuction.resultAuction: auction not approved\\\");\\n\\n        // Get info on who the highest bidder is\\n        HighestBid storage highestBid = highestBids[_garmentTokenId];\\n        address winner = highestBid.bidder;\\n        uint256 winningBid = highestBid.bid;\\n\\n        // Ensure auction not already resulted\\n        require(winningBid >= auction.reservePrice, \\\"DigitalaxAuction.resultAuction: reserve not reached\\\");\\n\\n        // Ensure there is a winner\\n        require(winner != address(0), \\\"DigitalaxAuction.resultAuction: no open bids\\\");\\n\\n        // Result the auction\\n        auctions[_garmentTokenId].resulted = true;\\n\\n        // Clean up the highest bid\\n        delete highestBids[_garmentTokenId];\\n\\n        // Record the primary sale price for the garment\\n        garmentNft.setPrimarySalePrice(_garmentTokenId, winningBid);\\n\\n        if (winningBid > auction.reservePrice) {\\n            // Work out total above the reserve\\n            uint256 aboveReservePrice = winningBid.sub(auction.reservePrice);\\n\\n            // Work out platform fee from above reserve amount\\n            uint256 platformFeeAboveReserve = aboveReservePrice.mul(platformFee).div(1000);\\n\\n            // Send platform fee\\n            (bool platformTransferSuccess,) = platformFeeRecipient.call{value : platformFeeAboveReserve}(\\\"\\\");\\n            require(platformTransferSuccess, \\\"DigitalaxAuction.resultAuction: Failed to send platform fee\\\");\\n\\n            // Send remaining to designer\\n            (bool designerTransferSuccess,) = garmentNft.garmentDesigners(_garmentTokenId).call{value : winningBid.sub(platformFeeAboveReserve)}(\\\"\\\");\\n            require(designerTransferSuccess, \\\"DigitalaxAuction.resultAuction: Failed to send the designer their royalties\\\");\\n        } else {\\n            // Send all to the designer\\n            (bool designerTransferSuccess,) = garmentNft.garmentDesigners(_garmentTokenId).call{value : winningBid}(\\\"\\\");\\n            require(designerTransferSuccess, \\\"DigitalaxAuction.resultAuction: Failed to send the designer their royalties\\\");\\n        }\\n\\n        // Transfer the token to the winner\\n        garmentNft.safeTransferFrom(garmentNft.ownerOf(_garmentTokenId), winner, _garmentTokenId);\\n\\n        emit AuctionResulted(_garmentTokenId, winner, winningBid);\\n    }\\n\\n    /**\\n     @notice Cancels and inflight and un-resulted auctions, returning the funds to the top bidder if found\\n     @dev Only admin\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     */\\n    function cancelAuction(uint256 _garmentTokenId) external nonReentrant {\\n        // Admin only resulting function\\n        require(\\n            accessControls.hasAdminRole(_msgSender()) || accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxAuction.cancelAuction: Sender must be admin or smart contract\\\"\\n        );\\n\\n        // Check valid and not resulted\\n        Auction storage auction = auctions[_garmentTokenId];\\n\\n        // Check auction is real\\n        require(auction.endTime > 0, \\\"DigitalaxAuction.cancelAuction: Auction does not exist\\\");\\n\\n        // Check auction not already resulted\\n        require(!auction.resulted, \\\"DigitalaxAuction.cancelAuction: auction already resulted\\\");\\n\\n        // refund existing top bidder if found\\n        HighestBid storage highestBid = highestBids[_garmentTokenId];\\n        if (highestBid.bidder != address(0)) {\\n            _refundHighestBidder(highestBid.bidder, highestBid.bid);\\n\\n            // Clear up highest bid\\n            delete highestBids[_garmentTokenId];\\n        }\\n\\n        // Remove auction and top bidder\\n        delete auctions[_garmentTokenId];\\n\\n        emit AuctionCancelled(_garmentTokenId);\\n    }\\n\\n    /**\\n     @notice Toggling the pause flag\\n     @dev Only admin\\n     */\\n    function toggleIsPaused() external {\\n        require(accessControls.hasAdminRole(_msgSender()), \\\"DigitalaxAuction.toggleIsPaused: Sender must be admin\\\");\\n        isPaused = !isPaused;\\n        emit PauseToggled(isPaused);\\n    }\\n\\n    /**\\n     @notice Update the amount by which bids have to increase, across all auctions\\n     @dev Only admin\\n     @param _minBidIncrement New bid step in WEI\\n     */\\n    function updateMinBidIncrement(uint256 _minBidIncrement) external {\\n        require(accessControls.hasAdminRole(_msgSender()), \\\"DigitalaxAuction.updateMinBidIncrement: Sender must be admin\\\");\\n        minBidIncrement = _minBidIncrement;\\n        emit UpdateMinBidIncrement(_minBidIncrement);\\n    }\\n\\n    /**\\n     @notice Update the global bid withdrawal lockout time\\n     @dev Only admin\\n     @param _bidWithdrawalLockTime New bid withdrawal lock time\\n     */\\n    function updateBidWithdrawalLockTime(uint256 _bidWithdrawalLockTime) external {\\n        require(accessControls.hasAdminRole(_msgSender()), \\\"DigitalaxAuction.updateBidWithdrawalLockTime: Sender must be admin\\\");\\n        bidWithdrawalLockTime = _bidWithdrawalLockTime;\\n        emit UpdateBidWithdrawalLockTime(_bidWithdrawalLockTime);\\n    }\\n\\n    /**\\n     @notice Update the current reserve price for an auction\\n     @dev Only admin\\n     @dev Auction must exist\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     @param _reservePrice New Ether reserve price (WEI value)\\n     */\\n    function updateAuctionReservePrice(uint256 _garmentTokenId, uint256 _reservePrice) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxAuction.updateAuctionReservePrice: Sender must be admin\\\"\\n        );\\n\\n        require(\\n            auctions[_garmentTokenId].endTime > 0,\\n            \\\"DigitalaxAuction.updateAuctionReservePrice: No Auction exists\\\"\\n        );\\n\\n        auctions[_garmentTokenId].reservePrice = _reservePrice;\\n        emit UpdateAuctionReservePrice(_garmentTokenId, _reservePrice);\\n    }\\n\\n    /**\\n     @notice Update the current start time for an auction\\n     @dev Only admin\\n     @dev Auction must exist\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     @param _startTime New start time (unix epoch in seconds)\\n     */\\n    function updateAuctionStartTime(uint256 _garmentTokenId, uint256 _startTime) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxAuction.updateAuctionStartTime: Sender must be admin\\\"\\n        );\\n\\n        require(\\n            auctions[_garmentTokenId].endTime > 0,\\n            \\\"DigitalaxAuction.updateAuctionStartTime: No Auction exists\\\"\\n        );\\n\\n        auctions[_garmentTokenId].startTime = _startTime;\\n        emit UpdateAuctionStartTime(_garmentTokenId, _startTime);\\n    }\\n\\n    /**\\n     @notice Update the current end time for an auction\\n     @dev Only admin\\n     @dev Auction must exist\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     @param _endTimestamp New end time (unix epoch in seconds)\\n     */\\n    function updateAuctionEndTime(uint256 _garmentTokenId, uint256 _endTimestamp) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxAuction.updateAuctionEndTime: Sender must be admin\\\"\\n        );\\n        require(\\n            auctions[_garmentTokenId].endTime > 0,\\n            \\\"DigitalaxAuction.updateAuctionEndTime: No Auction exists\\\"\\n        );\\n        require(\\n            auctions[_garmentTokenId].startTime < _endTimestamp,\\n            \\\"DigitalaxAuction.updateAuctionEndTime: End time must be greater than start\\\"\\n        );\\n        require(\\n            _endTimestamp > _getNow(),\\n            \\\"DigitalaxAuction.updateAuctionEndTime: End time passed. Nobody can bid\\\"\\n        );\\n\\n        auctions[_garmentTokenId].endTime = _endTimestamp;\\n        emit UpdateAuctionEndTime(_garmentTokenId, _endTimestamp);\\n    }\\n\\n    /**\\n     @notice Method for updating the access controls contract used by the NFT\\n     @dev Only admin\\n     @param _accessControls Address of the new access controls contract (Cannot be zero address)\\n     */\\n    function updateAccessControls(DigitalaxAccessControls _accessControls) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxAuction.updateAccessControls: Sender must be admin\\\"\\n        );\\n\\n        require(address(_accessControls) != address(0), \\\"DigitalaxAuction.updateAccessControls: Zero Address\\\");\\n\\n        accessControls = _accessControls;\\n        emit UpdateAccessControls(address(_accessControls));\\n    }\\n\\n    /**\\n     @notice Method for updating platform fee\\n     @dev Only admin\\n     @param _platformFee uint256 the platform fee to set\\n     */\\n    function updatePlatformFee(uint256 _platformFee) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxAuction.updatePlatformFee: Sender must be admin\\\"\\n        );\\n\\n        platformFee = _platformFee;\\n        emit UpdatePlatformFee(_platformFee);\\n    }\\n\\n    /**\\n     @notice Method for updating platform fee address\\n     @dev Only admin\\n     @param _platformFeeRecipient payable address the address to sends the funds to\\n     */\\n    function updatePlatformFeeRecipient(address payable _platformFeeRecipient) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxAuction.updatePlatformFeeRecipient: Sender must be admin\\\"\\n        );\\n\\n        require(_platformFeeRecipient != address(0), \\\"DigitalaxAuction.updatePlatformFeeRecipient: Zero address\\\");\\n\\n        platformFeeRecipient = _platformFeeRecipient;\\n        emit UpdatePlatformFeeRecipient(_platformFeeRecipient);\\n    }\\n\\n    ///////////////\\n    // Accessors //\\n    ///////////////\\n\\n    /**\\n     @notice Method for getting all info about the auction\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     */\\n    function getAuction(uint256 _garmentTokenId)\\n    external\\n    view\\n    returns (uint256 _reservePrice, uint256 _startTime, uint256 _endTime, bool _resulted) {\\n        Auction storage auction = auctions[_garmentTokenId];\\n        return (\\n        auction.reservePrice,\\n        auction.startTime,\\n        auction.endTime,\\n        auction.resulted\\n        );\\n    }\\n\\n    /**\\n     @notice Method for getting all info about the highest bidder\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     */\\n    function getHighestBidder(uint256 _garmentTokenId) external view returns (\\n        address payable _bidder,\\n        uint256 _bid,\\n        uint256 _lastBidTime\\n    ) {\\n        HighestBid storage highestBid = highestBids[_garmentTokenId];\\n        return (\\n            highestBid.bidder,\\n            highestBid.bid,\\n            highestBid.lastBidTime\\n        );\\n    }\\n\\n    /////////////////////////\\n    // Internal and Private /\\n    /////////////////////////\\n\\n    function _getNow() internal virtual view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     @notice Private method doing the heavy lifting of creating an auction\\n     @param _garmentTokenId Token ID of the garment being auctioned\\n     @param _reservePrice Garment cannot be sold for less than this or minBidIncrement, whichever is higher\\n     @param _startTimestamp Unix epoch in seconds for the auction start time\\n     @param _endTimestamp Unix epoch in seconds for the auction end time.\\n     */\\n    function _createAuction(\\n        uint256 _garmentTokenId,\\n        uint256 _reservePrice,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp\\n    ) private {\\n        // Ensure a token cannot be re-listed if previously successfully sold\\n        require(auctions[_garmentTokenId].endTime == 0, \\\"DigitalaxAuction.createAuction: Cannot relist\\\");\\n\\n        // Check end time not before start time and that end is in the future\\n        require(_endTimestamp > _startTimestamp, \\\"DigitalaxAuction.createAuction: End time must be greater than start\\\");\\n        require(_endTimestamp > _getNow(), \\\"DigitalaxAuction.createAuction: End time passed. Nobody can bid.\\\");\\n\\n        // Setup the auction\\n        auctions[_garmentTokenId] = Auction({\\n        reservePrice : _reservePrice,\\n        startTime : _startTimestamp,\\n        endTime : _endTimestamp,\\n        resulted : false\\n        });\\n\\n        emit AuctionCreated(_garmentTokenId);\\n    }\\n\\n    /**\\n     @notice Used for sending back escrowed funds from a previous bid\\n     @param _currentHighestBidder Address of the last highest bidder\\n     @param _currentHighestBid Ether amount in WEI that the bidder sent when placing their bid\\n     */\\n    function _refundHighestBidder(address payable _currentHighestBidder, uint256 _currentHighestBid) private {\\n        // refund previous best (if bid exists)\\n        (bool successRefund,) = _currentHighestBidder.call{value : _currentHighestBid}(\\\"\\\");\\n        require(successRefund, \\\"DigitalaxAuction._refundHighestBidder: failed to refund previous bidder\\\");\\n        emit BidRefunded(_currentHighestBidder, _currentHighestBid);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/garment/IDigitalaxGarmentNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IDigitalaxGarmentNFT is IERC721 {\\n    function isApproved(uint256 _tokenId, address _operator) external view returns (bool);\\n    function setPrimarySalePrice(uint256 _tokenId, uint256 _salePrice) external;\\n    function garmentDesigners(uint256 _tokenId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/DigitalaxGenesisNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./ERC721/ERC721WithSameTokenURIForAllTokens.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./DigitalaxAccessControls.sol\\\";\\n\\n/**\\n * @title Digitalax Genesis NFT\\n * @dev To facilitate the genesis sale for the Digitialax platform\\n */\\ncontract DigitalaxGenesisNFT is ERC721WithSameTokenURIForAllTokens(\\\"DigitalaxGenesis\\\", \\\"DXG\\\") {\\n    using SafeMath for uint256;\\n\\n    // @notice event emitted upon construction of this contract, used to bootstrap external indexers\\n    event DigitalaxGenesisNFTContractDeployed();\\n\\n    // @notice event emitted when a contributor buys a Genesis NFT\\n    event GenesisPurchased(\\n        address indexed buyer,\\n        uint256 indexed tokenId,\\n        uint256 contribution\\n    );\\n\\n    // @notice event emitted when a admin mints a Genesis NFT\\n    event AdminGenesisMinted(\\n        address indexed beneficiary,\\n        address indexed admin,\\n        uint256 indexed tokenId\\n    );\\n\\n    // @notice event emitted when a contributors amount is increased\\n    event ContributionIncreased(\\n        address indexed buyer,\\n        uint256 contribution\\n    );\\n\\n    // @notice event emitted when end date is changed\\n    event GenesisEndUpdated(\\n        uint256 genesisEndTimestamp,\\n        address indexed admin\\n    );\\n\\n    // @notice event emitted when DigitalaxAccessControls is updated\\n    event AccessControlsUpdated(\\n        address indexed newAdress\\n    );\\n\\n    // @notice responsible for enforcing admin access\\n    DigitalaxAccessControls public accessControls;\\n\\n    // @notice all funds will be sent to this address pon purchase of a Genesis NFT\\n    address payable public fundsMultisig;\\n\\n    // @notice start date for them the Genesis sale is open to the public, before this data no purchases can be made\\n    uint256 public genesisStartTimestamp;\\n\\n    // @notice end date for them the Genesis sale is closed, no more purchased can be made after this point\\n    uint256 public genesisEndTimestamp;\\n\\n    // @notice set after end time has been changed once, prevents further changes to end timestamp\\n    bool public genesisEndTimestampLocked;\\n\\n    // @notice the minimum amount a buyer can contribute in a single go\\n    uint256 public constant minimumContributionAmount = 0.1 ether;\\n\\n    // @notice the maximum accumulative amount a user can contribute to the genesis sale\\n    uint256 public constant maximumContributionAmount = 2 ether;\\n\\n    // @notice accumulative => contribution total\\n    mapping(address => uint256) public contribution;\\n\\n    // @notice global accumulative contribution amount\\n    uint256 public totalContributions;\\n\\n    // @notice max number of paid contributions to the genesis sale\\n    uint256 public constant maxGenesisContributionTokens = 460;\\n\\n    uint256 public totalAdminMints;\\n\\n    constructor(\\n        DigitalaxAccessControls _accessControls,\\n        address payable _fundsMultisig,\\n        uint256 _genesisStartTimestamp,\\n        uint256 _genesisEndTimestamp,\\n        string memory _tokenURI\\n    ) public {\\n        accessControls = _accessControls;\\n        fundsMultisig = _fundsMultisig;\\n        genesisStartTimestamp = _genesisStartTimestamp;\\n        genesisEndTimestamp = _genesisEndTimestamp;\\n        tokenURI_ = _tokenURI;\\n        emit DigitalaxGenesisNFTContractDeployed();\\n    }\\n\\n    /**\\n     * @dev Proxy method for facilitating a single point of entry to either buy or contribute additional value to the Genesis sale\\n     * @dev Cannot contribute less than minimumContributionAmount\\n     * @dev Cannot contribute accumulative more than than maximumContributionAmount\\n     */\\n    function buyOrIncreaseContribution() external payable {\\n        if (contribution[_msgSender()] == 0) {\\n            buy();\\n        } else {\\n            increaseContribution();\\n        }\\n    }\\n\\n    /**\\n     * @dev Facilitating the initial purchase of a Genesis NFT\\n     * @dev Cannot contribute less than minimumContributionAmount\\n     * @dev Cannot contribute accumulative more than than maximumContributionAmount\\n     * @dev Reverts if already owns an genesis token\\n     * @dev Buyer receives a NFT on success\\n     * @dev All funds move to fundsMultisig\\n     */\\n    function buy() public payable {\\n        require(contribution[_msgSender()] == 0, \\\"DigitalaxGenesisNFT.buy: You already own a genesis NFT\\\");\\n        require(\\n            _getNow() >= genesisStartTimestamp && _getNow() <= genesisEndTimestamp,\\n            \\\"DigitalaxGenesisNFT.buy: No genesis are available outside of the genesis window\\\"\\n        );\\n\\n        uint256 _contributionAmount = msg.value;\\n        require(\\n            _contributionAmount >= minimumContributionAmount,\\n            \\\"DigitalaxGenesisNFT.buy: Contribution does not meet minimum requirement\\\"\\n        );\\n\\n        require(\\n            _contributionAmount <= maximumContributionAmount,\\n            \\\"DigitalaxGenesisNFT.buy: You cannot exceed the maximum contribution amount\\\"\\n        );\\n\\n        require(remainingGenesisTokens() > 0, \\\"DigitalaxGenesisNFT.buy: Total number of genesis token holders reached\\\");\\n\\n        contribution[_msgSender()] = _contributionAmount;\\n        totalContributions = totalContributions.add(_contributionAmount);\\n\\n        (bool fundsTransferSuccess,) = fundsMultisig.call{value : _contributionAmount}(\\\"\\\");\\n        require(fundsTransferSuccess, \\\"DigitalaxGenesisNFT.buy: Unable to send contribution to funds multisig\\\");\\n\\n        uint256 tokenId = totalSupply().add(1);\\n        _safeMint(_msgSender(), tokenId);\\n\\n        emit GenesisPurchased(_msgSender(), tokenId, _contributionAmount);\\n    }\\n\\n    /**\\n     * @dev Facilitates an owner to increase there contribution\\n     * @dev Cannot contribute less than minimumContributionAmount\\n     * @dev Cannot contribute accumulative more than than maximumContributionAmount\\n     * @dev Reverts if caller does not already owns an genesis token\\n     * @dev All funds move to fundsMultisig\\n     */\\n    function increaseContribution() public payable {\\n        require(\\n            _getNow() >= genesisStartTimestamp && _getNow() <= genesisEndTimestamp,\\n            \\\"DigitalaxGenesisNFT.increaseContribution: No increases are possible outside of the genesis window\\\"\\n        );\\n\\n        require(\\n            contribution[_msgSender()] > 0,\\n            \\\"DigitalaxGenesisNFT.increaseContribution: You do not own a genesis NFT\\\"\\n        );\\n\\n        uint256 _amountToIncrease = msg.value;\\n        contribution[_msgSender()] = contribution[_msgSender()].add(_amountToIncrease);\\n\\n        require(\\n            contribution[_msgSender()] <= maximumContributionAmount,\\n            \\\"DigitalaxGenesisNFT.increaseContribution: You cannot exceed the maximum contribution amount\\\"\\n        );\\n\\n        totalContributions = totalContributions.add(_amountToIncrease);\\n\\n        (bool fundsTransferSuccess,) = fundsMultisig.call{value : _amountToIncrease}(\\\"\\\");\\n        require(\\n            fundsTransferSuccess,\\n            \\\"DigitalaxGenesisNFT.increaseContribution: Unable to send contribution to funds multisig\\\"\\n        );\\n\\n        emit ContributionIncreased(_msgSender(), _amountToIncrease);\\n    }\\n\\n    // Admin\\n\\n    /**\\n     * @dev Allows a whitelisted admin to mint a token and issue it to a beneficiary\\n     * @dev One token per holder\\n     * @dev All holders contribution as set o zero on creation\\n     */\\n    function adminBuy(address _beneficiary) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxGenesisNFT.adminBuy: Sender must be admin\\\"\\n        );\\n        require(_beneficiary != address(0), \\\"DigitalaxGenesisNFT.adminBuy: Beneficiary cannot be ZERO\\\");\\n        require(balanceOf(_beneficiary) == 0, \\\"DigitalaxGenesisNFT.adminBuy: Beneficiary already owns a genesis NFT\\\");\\n\\n        uint256 tokenId = totalSupply().add(1);\\n        _safeMint(_beneficiary, tokenId);\\n\\n        // Increase admin mint counts\\n        totalAdminMints = totalAdminMints.add(1);\\n\\n        emit AdminGenesisMinted(_beneficiary, _msgSender(), tokenId);\\n    }\\n\\n    /**\\n     * @dev Allows a whitelisted admin to update the end date of the genesis\\n     */\\n    function updateGenesisEnd(uint256 _end) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxGenesisNFT.updateGenesisEnd: Sender must be admin\\\"\\n        );\\n        // If already passed, dont allow opening again\\n        require(genesisEndTimestamp > _getNow(), \\\"DigitalaxGenesisNFT.updateGenesisEnd: End time already passed\\\");\\n\\n        // Only allow setting this once\\n        require(!genesisEndTimestampLocked, \\\"DigitalaxGenesisNFT.updateGenesisEnd: End time locked\\\");\\n\\n        genesisEndTimestamp = _end;\\n\\n        // Lock future end time modifications\\n        genesisEndTimestampLocked = true;\\n\\n        emit GenesisEndUpdated(genesisEndTimestamp, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Allows a whitelisted admin to update the start date of the genesis\\n     */\\n    function updateAccessControls(DigitalaxAccessControls _accessControls) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxGenesisNFT.updateAccessControls: Sender must be admin\\\"\\n        );\\n        require(address(_accessControls) != address(0), \\\"DigitalaxGenesisNFT.updateAccessControls: Zero Address\\\");\\n        accessControls = _accessControls;\\n\\n        emit AccessControlsUpdated(address(_accessControls));\\n    }\\n\\n    /**\\n    * @dev Returns total remaining number of tokens available in the Genesis sale\\n    */\\n    function remainingGenesisTokens() public view returns (uint256) {\\n        return _getMaxGenesisContributionTokens() - (totalSupply() - totalAdminMints);\\n    }\\n\\n    // Internal\\n\\n    function _getNow() internal virtual view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function _getMaxGenesisContributionTokens() internal virtual view returns (uint256) {\\n        return maxGenesisContributionTokens;\\n    }\\n\\n    /**\\n     * @dev Before token transfer hook to enforce that no token can be moved to another address until the genesis sale has ended\\n     */\\n    function _beforeTokenTransfer(address from, address, uint256) internal override {\\n        if (from != address(0) && _getNow() <= genesisEndTimestamp) {\\n            revert(\\\"DigitalaxGenesisNFT._beforeTokenTransfer: Transfers are currently locked at this time\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721/ERC721WithSameTokenURIForAllTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableMap.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n * @dev This is a modified OZ ERC721 base contract with one change where all tokens have the same token URI\\n */\\ncontract ERC721WithSameTokenURIForAllTokens is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Single token URI for all tokens\\n    string public tokenURI_;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        return tokenURI_;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n    private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n                IERC721Receiver(to).onERC721Received.selector,\\n                _msgSender(),\\n                from,\\n                tokenId,\\n                _data\\n            ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\\n    external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        return _get(map, key, \\\"EnumerableMap: nonexistent key\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// Contract based from the following:\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/aaa5ef81cf75454d1c337dc3de03d12480849ad1/contracts/token/ERC1155/ERC1155.sol\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n *\\n * @notice Modifications to uri logic made by BlockRocket.tech\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Token ID to its URI\\n    mapping (uint256 => string) internal tokenUris;\\n\\n    // Token ID to its total supply\\n    mapping(uint256 => uint256) public tokenTotalSupply;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    constructor () public {\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     */\\n    function uri(uint256 tokenId) external view override returns (string memory) {\\n        return tokenUris[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n    public\\n    view\\n    override\\n    returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            require(accounts[i] != address(0), \\\"ERC1155: batch balance query for the zero address\\\");\\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n    external\\n    virtual\\n    override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n    external\\n    virtual\\n    override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for a given token ID\\n     */\\n    function _setURI(uint256 tokenId, string memory newuri) internal virtual {\\n        tokenUris[tokenId] = newuri;\\n        emit URI(newuri, tokenId);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        tokenTotalSupply[id] = tokenTotalSupply[id].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            _balances[id][to] = amount.add(_balances[id][to]);\\n            tokenTotalSupply[id] = tokenTotalSupply[id].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        tokenTotalSupply[id] = tokenTotalSupply[id].sub(amount);\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            _balances[id][account] = _balances[id][account].sub(\\n                amount,\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n\\n            tokenTotalSupply[id] = tokenTotalSupply[id].sub(amount);\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n    internal virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n    private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n    private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/ERC1155/ERC1155Burnable.sol\": {\r\n      \"content\": \"//imported from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/aaa5ef81cf75454d1c337dc3de03d12480849ad1/contracts/token/ERC1155/ERC1155Burnable.sol\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\\n * own tokens and those that they have been approved to use.\\n *\\n * _Available since v3.1._\\n */\\nabstract contract ERC1155Burnable is ERC1155 {\\n    function burn(address account, uint256 id, uint256 amount) public virtual {\\n        require(\\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        _burn(account, id, amount);\\n    }\\n\\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public virtual {\\n        require(\\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        _burnBatch(account, ids, amounts);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC998/IERC998ERC1155TopDown.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n// Based on: https://github.com/rocksideio/ERC998-ERC1155-TopDown/blob/695963195606304374015c49d166ab2fbeb42ea9/contracts/IERC998ERC1155TopDown.sol\\ninterface IERC998ERC1155TopDown is IERC1155Receiver {\\n\\n    event ReceivedChild(address indexed from, uint256 indexed toTokenId, address indexed childContract, uint256 childTokenId, uint256 amount);\\n    event TransferBatchChild(uint256 indexed fromTokenId, address indexed to, address indexed childContract, uint256[] childTokenIds, uint256[] amounts);\\n\\n    function childContractsFor(uint256 tokenId) external view returns (address[] memory childContracts);\\n    function childIdsForOn(uint256 tokenId, address childContract) external view returns (uint256[] memory childIds);\\n    function childBalance(uint256 tokenId, address childContract, uint256 childTokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/garment/DigitalaxGarmentFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./DigitalaxGarmentNFT.sol\\\";\\nimport \\\"./DigitalaxMaterials.sol\\\";\\nimport \\\"../DigitalaxAccessControls.sol\\\";\\n\\n/**\\n * @title Digitalax Garment Factory\\n * @dev To facilitate the creation of child and parents NFTs\\n * @dev This contract needs to be given the smart contract role in order to be given access to mint tokens\\n */\\ncontract DigitalaxGarmentFactory is Context, ReentrancyGuard {\\n\\n    // @notice event emitted on garment creation\\n    event GarmentCreated(\\n        uint256 indexed garmentTokenId\\n    );\\n\\n    // @notice the parent ERC721 garment token\\n    DigitalaxGarmentNFT public garmentToken;\\n\\n    // @notice the child ERC1155 strand tokens\\n    DigitalaxMaterials public materials;\\n\\n    // @notice access controls\\n    DigitalaxAccessControls public accessControls;\\n\\n    constructor(\\n        DigitalaxGarmentNFT _garmentToken,\\n        DigitalaxMaterials _materials,\\n        DigitalaxAccessControls _accessControls\\n    ) public {\\n        garmentToken = _garmentToken;\\n        materials = _materials;\\n        accessControls = _accessControls;\\n    }\\n\\n    /**\\n     @notice Creates a single child ERC1155 token\\n     @dev Only callable with minter role\\n     @return childTokenId the generated child Token ID\\n     */\\n    function createNewChild(string calldata _uri) external returns (uint256 childTokenId) {\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentFactory.createNewChild: Sender must be minter\\\"\\n        );\\n        return materials.createChild(_uri);\\n    }\\n\\n    /**\\n     @notice Creates a batch of child ERC1155 tokens\\n     @dev Only callable with minter role\\n     @return childTokenIds the generated child Token IDs\\n     */\\n    function createNewChildren(string[] calldata _uris) external returns (uint256[] memory childTokenIds) {\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentFactory.createNewChildren: Sender must be minter\\\"\\n        );\\n        return materials.batchCreateChildren(_uris);\\n    }\\n\\n    /**\\n     @notice Creates a batch of child ERC1155 tokens with balances, assigning them to the beneficiary\\n     @dev Only callable with minter role\\n     */\\n    function createNewChildrenWithBalances(\\n        string[] calldata _childTokenUris,\\n        uint256[] calldata _childTokenAmounts,\\n        address _beneficiary\\n    ) external nonReentrant {\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentFactory.createNewChildrenWithBalances: Sender must be minter\\\"\\n        );\\n\\n        // Create new children\\n        uint256[] memory childTokenIds = materials.batchCreateChildren(_childTokenUris);\\n\\n        // Mint balances of children\\n        materials.batchMintChildren(childTokenIds, _childTokenAmounts, _beneficiary, abi.encodePacked(\\\"\\\"));\\n    }\\n\\n    /**\\n     @notice Creates a batch of child ERC1155 tokens with balances, assigning them to a newly minted garment\\n     @dev Only callable with minter role\\n     */\\n    function createNewChildrenWithBalanceAndGarment(\\n        string calldata _garmentTokenUri,\\n        address _designer,\\n        string[] calldata _childTokenUris,\\n        uint256[] calldata _childTokenAmounts,\\n        address _beneficiary\\n    ) external nonReentrant {\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentFactory.createNewChildrenWithBalanceAndGarment: Sender must be minter\\\"\\n        );\\n\\n        // Generate parent 721 token\\n        uint256 garmentTokenId = garmentToken.mint(_beneficiary, _garmentTokenUri, _designer);\\n\\n        // Create new children\\n        uint256[] memory childTokenIds = materials.batchCreateChildren(_childTokenUris);\\n\\n        // Mint balances of children\\n        materials.batchMintChildren(childTokenIds, _childTokenAmounts, address(garmentToken), abi.encodePacked(garmentTokenId));\\n    }\\n\\n    /**\\n     @notice Creates a single ERC721 parent token, along with a batch of assigned child ERC1155 tokens\\n     @dev Only callable with minter role\\n     */\\n    function mintParentWithChildren(\\n        string calldata garmentTokenUri,\\n        address designer,\\n        uint256[] calldata childTokenIds,\\n        uint256[] calldata childTokenAmounts,\\n        address beneficiary\\n    ) external nonReentrant {\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentFactory.mintParentWithChildren: Sender must be minter\\\"\\n        );\\n        // Generate parent 721 token\\n        uint256 garmentTokenId = garmentToken.mint(beneficiary, garmentTokenUri, designer);\\n\\n        // Batch mint child tokens and assign to generated 721 token ID\\n        materials.batchMintChildren(childTokenIds, childTokenAmounts, address(garmentToken), abi.encodePacked(garmentTokenId));\\n\\n        // Emit completion event\\n        emit GarmentCreated(garmentTokenId);\\n    }\\n\\n    /**\\n     @notice Creates a single ERC721 parent token without any linked child tokens\\n     @dev Only callable with minter role\\n     */\\n    function mintParentWithoutChildren(\\n        string calldata garmentTokenUri,\\n        address designer,\\n        address beneficiary\\n    ) external nonReentrant {\\n        require(\\n            accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentFactory.mintParentWithoutChildren: Sender must be minter\\\"\\n        );\\n\\n        // Generate parent 721 token\\n        uint256 garmentTokenId = garmentToken.mint(beneficiary, garmentTokenUri, designer);\\n\\n        // Emit completion event\\n        emit GarmentCreated(garmentTokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/garment/DigitalaxGarmentNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"../ERC1155/ERC1155.sol\\\";\\nimport \\\"../DigitalaxAccessControls.sol\\\";\\nimport \\\"../ERC998/IERC998ERC1155TopDown.sol\\\";\\n\\n/**\\n * @title Digitalax Garment NFT a.k.a. parent NFTs\\n * @dev Issues ERC-721 tokens as well as being able to hold child 1155 tokens\\n */\\ncontract DigitalaxGarmentNFT is ERC721(\\\"DigitalaxNFT\\\", \\\"DTX\\\"), ERC1155Receiver, IERC998ERC1155TopDown {\\n\\n    // @notice event emitted upon construction of this contract, used to bootstrap external indexers\\n    event DigitalaxGarmentNFTContractDeployed();\\n\\n    // @notice event emitted when token URI is updated\\n    event DigitalaxGarmentTokenUriUpdate(\\n        uint256 indexed _tokenId,\\n        string _tokenUri\\n    );\\n\\n    // @notice event emitted when a tokens primary sale occurs\\n    event TokenPrimarySalePriceSet(\\n        uint256 indexed _tokenId,\\n        uint256 _salePrice\\n    );\\n\\n    /// @dev Required to govern who can call certain functions\\n    DigitalaxAccessControls public accessControls;\\n\\n    /// @dev Child ERC1155 contract address\\n    ERC1155 public childContract;\\n\\n    /// @dev current max tokenId\\n    uint256 public tokenIdPointer;\\n\\n    /// @dev TokenID -> Designer address\\n    mapping(uint256 => address) public garmentDesigners;\\n\\n    /// @dev TokenID -> Primary Ether Sale Price in Wei\\n    mapping(uint256 => uint256) public primarySalePrice;\\n\\n    /// @dev ERC721 Token ID -> ERC1155 ID -> Balance\\n    mapping(uint256 => mapping(uint256 => uint256)) private balances;\\n\\n    /// @dev ERC1155 ID -> ERC721 Token IDs that have a balance\\n    mapping(uint256 => EnumerableSet.UintSet) private childToParentMapping;\\n\\n    /// @dev ERC721 Token ID -> ERC1155 child IDs owned by the token ID\\n    mapping(uint256 => EnumerableSet.UintSet) private parentToChildMapping;\\n\\n    /// @dev max children NFTs a single 721 can hold\\n    uint256 public maxChildrenPerToken = 10;\\n\\n    /**\\n     @param _accessControls Address of the Digitalax access control contract\\n     @param _childContract ERC1155 the Digitalax child NFT contract\\n     */\\n    constructor(DigitalaxAccessControls _accessControls, ERC1155 _childContract) public {\\n        accessControls = _accessControls;\\n        childContract = _childContract;\\n        emit DigitalaxGarmentNFTContractDeployed();\\n    }\\n\\n    /**\\n     @notice Mints a DigitalaxGarmentNFT AND when minting to a contract checks if the beneficiary is a 721 compatible\\n     @dev Only senders with either the minter or smart contract role can invoke this method\\n     @param _beneficiary Recipient of the NFT\\n     @param _tokenUri URI for the token being minted\\n     @param _designer Garment designer - will be required for issuing royalties from secondary sales\\n     @return uint256 The token ID of the token that was minted\\n     */\\n    function mint(address _beneficiary, string calldata _tokenUri, address _designer) external returns (uint256) {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()) || accessControls.hasMinterRole(_msgSender()),\\n            \\\"DigitalaxGarmentNFT.mint: Sender must have the minter or contract role\\\"\\n        );\\n\\n        // Valid args\\n        _assertMintingParamsValid(_tokenUri, _designer);\\n\\n        tokenIdPointer = tokenIdPointer.add(1);\\n        uint256 tokenId = tokenIdPointer;\\n\\n        // Mint token and set token URI\\n        _safeMint(_beneficiary, tokenId);\\n        _setTokenURI(tokenId, _tokenUri);\\n\\n        // Associate garment designer\\n        garmentDesigners[tokenId] = _designer;\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     @notice Burns a DigitalaxGarmentNFT, releasing any composed 1155 tokens held by the token itseld\\n     @dev Only the owner or an approved sender can call this method\\n     @param _tokenId the token ID to burn\\n     */\\n    function burn(uint256 _tokenId) external {\\n        address operator = _msgSender();\\n        require(\\n            ownerOf(_tokenId) == operator || isApproved(_tokenId, operator),\\n            \\\"DigitalaxGarmentNFT.burn: Only garment owner or approved\\\"\\n        );\\n\\n        // If there are any children tokens then send them as part of the burn\\n        if (parentToChildMapping[_tokenId].length() > 0) {\\n            // Transfer children to the burner\\n            _extractAndTransferChildrenFromParent(_tokenId, _msgSender());\\n        }\\n\\n        // Destroy token mappings\\n        _burn(_tokenId);\\n\\n        // Clean up designer mapping\\n        delete garmentDesigners[_tokenId];\\n        delete primarySalePrice[_tokenId];\\n    }\\n\\n    /**\\n     @notice Single ERC1155 receiver callback hook, used to enforce children token binding to a given parent token\\n     */\\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes memory _data)\\n    virtual\\n    external\\n    override\\n    returns (bytes4) {\\n        require(_data.length == 32, \\\"ERC998: data must contain the unique uint256 tokenId to transfer the child token to\\\");\\n\\n        uint256 _receiverTokenId = _extractIncomingTokenId();\\n        _validateReceiverParams(_receiverTokenId, _operator, _from);\\n\\n        _receiveChild(_receiverTokenId, _msgSender(), _id, _amount);\\n\\n        emit ReceivedChild(_from, _receiverTokenId, _msgSender(), _id, _amount);\\n\\n        // Check total tokens do not exceed maximum\\n        require(\\n            parentToChildMapping[_receiverTokenId].length() <= maxChildrenPerToken,\\n            \\\"Cannot exceed max child token allocation\\\"\\n        );\\n\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    /**\\n     @notice Batch ERC1155 receiver callback hook, used to enforce child token bindings to a given parent token ID\\n     */\\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes memory _data)\\n    virtual\\n    external\\n    override\\n    returns (bytes4) {\\n        require(_data.length == 32, \\\"ERC998: data must contain the unique uint256 tokenId to transfer the child token to\\\");\\n\\n        uint256 _receiverTokenId = _extractIncomingTokenId();\\n        _validateReceiverParams(_receiverTokenId, _operator, _from);\\n\\n        // Note: be mindful of GAS limits\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            _receiveChild(_receiverTokenId, _msgSender(), _ids[i], _values[i]);\\n            emit ReceivedChild(_from, _receiverTokenId, _msgSender(), _ids[i], _values[i]);\\n        }\\n\\n        // Check total tokens do not exceed maximum\\n        require(\\n            parentToChildMapping[_receiverTokenId].length() <= maxChildrenPerToken,\\n            \\\"Cannot exceed max child token allocation\\\"\\n        );\\n\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    function _extractIncomingTokenId() internal pure returns (uint256) {\\n        // Extract out the embedded token ID from the sender\\n        uint256 _receiverTokenId;\\n        uint256 _index = msg.data.length - 32;\\n        assembly {_receiverTokenId := calldataload(_index)}\\n        return _receiverTokenId;\\n    }\\n\\n    function _validateReceiverParams(uint256 _receiverTokenId, address _operator, address _from) internal view {\\n        require(_exists(_receiverTokenId), \\\"Token does not exist\\\");\\n\\n        // We only accept children from the Digitalax child contract\\n        require(_msgSender() == address(childContract), \\\"Invalid child token contract\\\");\\n\\n        // check the sender is the owner of the token or its just been birthed to this token\\n        if (_from != address(0)) {\\n            require(\\n                ownerOf(_receiverTokenId) == _from,\\n                \\\"Cannot add children to tokens you dont own\\\"\\n            );\\n\\n            // Check the operator is also the owner, preventing an approved address adding tokens on the holders behalf\\n            require(_operator == _from, \\\"Operator is not owner\\\");\\n        }\\n    }\\n\\n    //////////\\n    // Admin /\\n    //////////\\n\\n    /**\\n     @notice Updates the token URI of a given token\\n     @dev Only admin or smart contract\\n     @param _tokenId The ID of the token being updated\\n     @param _tokenUri The new URI\\n     */\\n    function setTokenURI(uint256 _tokenId, string calldata _tokenUri) external {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()) || accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxGarmentNFT.setTokenURI: Sender must be an authorised contract or admin\\\"\\n        );\\n        _setTokenURI(_tokenId, _tokenUri);\\n        emit DigitalaxGarmentTokenUriUpdate(_tokenId, _tokenUri);\\n    }\\n\\n    /**\\n     @notice Records the Ether price that a given token was sold for (in WEI)\\n     @dev Only admin or a smart contract can call this method\\n     @param _tokenId The ID of the token being updated\\n     @param _salePrice The primary Ether sale price in WEI\\n     */\\n    function setPrimarySalePrice(uint256 _tokenId, uint256 _salePrice) external {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()) || accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxGarmentNFT.setPrimarySalePrice: Sender must be an authorised contract or admin\\\"\\n        );\\n        require(_exists(_tokenId), \\\"DigitalaxGarmentNFT.setPrimarySalePrice: Token does not exist\\\");\\n        require(_salePrice > 0, \\\"DigitalaxGarmentNFT.setPrimarySalePrice: Invalid sale price\\\");\\n\\n        // Only set it once\\n        if (primarySalePrice[_tokenId] == 0) {\\n            primarySalePrice[_tokenId] = _salePrice;\\n            emit TokenPrimarySalePriceSet(_tokenId, _salePrice);\\n        }\\n    }\\n\\n    /**\\n     @notice Method for updating the access controls contract used by the NFT\\n     @dev Only admin\\n     @param _accessControls Address of the new access controls contract\\n     */\\n    function updateAccessControls(DigitalaxAccessControls _accessControls) external {\\n        require(accessControls.hasAdminRole(_msgSender()), \\\"DigitalaxGarmentNFT.updateAccessControls: Sender must be admin\\\");\\n        accessControls = _accessControls;\\n    }\\n\\n    /**\\n     @notice Method for updating max children a token can hold\\n     @dev Only admin\\n     @param _maxChildrenPerToken uint256 the max children a token can hold\\n     */\\n    function updateMaxChildrenPerToken(uint256 _maxChildrenPerToken) external {\\n        require(accessControls.hasAdminRole(_msgSender()), \\\"DigitalaxGarmentNFT.updateMaxChildrenPerToken: Sender must be admin\\\");\\n        maxChildrenPerToken = _maxChildrenPerToken;\\n    }\\n\\n    /////////////////\\n    // View Methods /\\n    /////////////////\\n\\n    /**\\n     @notice View method for checking whether a token has been minted\\n     @param _tokenId ID of the token being checked\\n     */\\n    function exists(uint256 _tokenId) external view returns (bool) {\\n        return _exists(_tokenId);\\n    }\\n\\n    /**\\n     @dev Get the child token balances held by the contract, assumes caller knows the correct child contract\\n     */\\n    function childBalance(uint256 _tokenId, address _childContract, uint256 _childTokenId)\\n    public\\n    view\\n    override\\n    returns (uint256) {\\n        return _childContract == address(childContract) ? balances[_tokenId][_childTokenId] : 0;\\n    }\\n\\n    /**\\n     @dev Get list of supported child contracts, always a list of 0 or 1 in our case\\n     */\\n    function childContractsFor(uint256 _tokenId) override external view returns (address[] memory) {\\n        if (!_exists(_tokenId)) {\\n            return new address[](0);\\n        }\\n\\n        address[] memory childContracts = new address[](1);\\n        childContracts[0] = address(childContract);\\n        return childContracts;\\n    }\\n\\n    /**\\n     @dev Gets mapped IDs for child tokens\\n     */\\n    function childIdsForOn(uint256 _tokenId, address _childContract) override public view returns (uint256[] memory) {\\n        if (!_exists(_tokenId) || _childContract != address(childContract)) {\\n            return new uint256[](0);\\n        }\\n\\n        uint256[] memory childTokenIds = new uint256[](parentToChildMapping[_tokenId].length());\\n\\n        for (uint256 i = 0; i < parentToChildMapping[_tokenId].length(); i++) {\\n            childTokenIds[i] = parentToChildMapping[_tokenId].at(i);\\n        }\\n\\n        return childTokenIds;\\n    }\\n\\n    /**\\n     @dev Get total number of children mapped to the token\\n     */\\n    function totalChildrenMapped(uint256 _tokenId) external view returns (uint256) {\\n        return parentToChildMapping[_tokenId].length();\\n    }\\n\\n    /**\\n     * @dev checks the given token ID is approved either for all or the single token ID\\n     */\\n    function isApproved(uint256 _tokenId, address _operator) public view returns (bool) {\\n        return isApprovedForAll(ownerOf(_tokenId), _operator) || getApproved(_tokenId) == _operator;\\n    }\\n\\n    /////////////////////////\\n    // Internal and Private /\\n    /////////////////////////\\n\\n    function _extractAndTransferChildrenFromParent(uint256 _fromTokenId, address _to) internal {\\n        uint256[] memory _childTokenIds = childIdsForOn(_fromTokenId, address(childContract));\\n        uint256[] memory _amounts = new uint256[](_childTokenIds.length);\\n\\n        for (uint256 i = 0; i < _childTokenIds.length; ++i) {\\n            uint256 _childTokenId = _childTokenIds[i];\\n            uint256 amount = childBalance(_fromTokenId, address(childContract), _childTokenId);\\n\\n            _amounts[i] = amount;\\n\\n            _removeChild(_fromTokenId, address(childContract), _childTokenId, amount);\\n        }\\n\\n        childContract.safeBatchTransferFrom(address(this), _to, _childTokenIds, _amounts, abi.encodePacked(\\\"\\\"));\\n\\n        emit TransferBatchChild(_fromTokenId, _to, address(childContract), _childTokenIds, _amounts);\\n    }\\n\\n    function _receiveChild(uint256 _tokenId, address, uint256 _childTokenId, uint256 _amount) private {\\n        if (balances[_tokenId][_childTokenId] == 0) {\\n           parentToChildMapping[_tokenId].add(_childTokenId);\\n        }\\n        balances[_tokenId][_childTokenId] = balances[_tokenId][_childTokenId].add(_amount);\\n    }\\n\\n    function _removeChild(uint256 _tokenId, address, uint256 _childTokenId, uint256 _amount) private {\\n        require(_amount != 0 || balances[_tokenId][_childTokenId] >= _amount, \\\"ERC998: insufficient child balance for transfer\\\");\\n        balances[_tokenId][_childTokenId] = balances[_tokenId][_childTokenId].sub(_amount);\\n        if (balances[_tokenId][_childTokenId] == 0) {\\n            childToParentMapping[_childTokenId].remove(_tokenId);\\n            parentToChildMapping[_tokenId].remove(_childTokenId);\\n        }\\n    }\\n\\n    /**\\n     @notice Checks that the URI is not empty and the designer is a real address\\n     @param _tokenUri URI supplied on minting\\n     @param _designer Address supplied on minting\\n     */\\n    function _assertMintingParamsValid(string calldata _tokenUri, address _designer) pure internal {\\n        require(bytes(_tokenUri).length > 0, \\\"DigitalaxGarmentNFT._assertMintingParamsValid: Token URI is empty\\\");\\n        require(_designer != address(0), \\\"DigitalaxGarmentNFT._assertMintingParamsValid: Designer is zero address\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(_baseURI).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    constructor() public {\\n        _registerInterface(\\n            ERC1155Receiver(0).onERC1155Received.selector ^\\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/garment/DigitalaxMaterials.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC1155/ERC1155Burnable.sol\\\";\\nimport \\\"../DigitalaxAccessControls.sol\\\";\\n\\n/**\\n * @title Digitalax Materials NFT a.k.a. child NFTs\\n * @dev Issues ERC-1155 tokens which can be held by the parent ERC-721 contract\\n */\\ncontract DigitalaxMaterials is ERC1155Burnable {\\n\\n    // @notice event emitted on contract creation\\n    event DigitalaxMaterialsDeployed();\\n\\n    // @notice a single child has been created\\n    event ChildCreated(\\n        uint256 indexed childId\\n    );\\n\\n    // @notice a batch of children have been created\\n    event ChildrenCreated(\\n        uint256[] childIds\\n    );\\n\\n    string public name;\\n    string public symbol;\\n\\n    // @notice current token ID pointer\\n    uint256 public tokenIdPointer;\\n\\n    // @notice enforcing access controls\\n    DigitalaxAccessControls public accessControls;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        DigitalaxAccessControls _accessControls\\n    ) public {\\n        name = _name;\\n        symbol = _symbol;\\n        accessControls = _accessControls;\\n        emit DigitalaxMaterialsDeployed();\\n    }\\n\\n    ///////////////////////////\\n    // Creating new children //\\n    ///////////////////////////\\n\\n    /**\\n     @notice Creates a single child ERC1155 token\\n     @dev Only callable with smart contact role\\n     @return id the generated child Token ID\\n     */\\n    function createChild(string calldata _uri) external returns (uint256 id) {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxMaterials.createChild: Sender must be smart contract\\\"\\n        );\\n\\n        require(bytes(_uri).length > 0, \\\"DigitalaxMaterials.createChild: URI is a blank string\\\");\\n\\n        tokenIdPointer = tokenIdPointer.add(1);\\n\\n        id = tokenIdPointer;\\n        _setURI(id, _uri);\\n\\n        emit ChildCreated(id);\\n    }\\n\\n    /**\\n     @notice Creates a batch of child ERC1155 tokens\\n     @dev Only callable with smart contact role\\n     @return tokenIds the generated child Token IDs\\n     */\\n    function batchCreateChildren(string[] calldata _uris) external returns (uint256[] memory tokenIds) {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxMaterials.batchCreateChildren: Sender must be smart contract\\\"\\n        );\\n\\n        require(_uris.length > 0, \\\"DigitalaxMaterials.batchCreateChildren: No data supplied in array\\\");\\n\\n        uint256 urisLength = _uris.length;\\n        tokenIds = new uint256[](urisLength);\\n        for (uint256 i = 0; i < urisLength; i++) {\\n            string memory uri = _uris[i];\\n            require(bytes(uri).length > 0, \\\"DigitalaxMaterials.batchCreateChildren: URI is a blank string\\\");\\n            tokenIdPointer = tokenIdPointer.add(1);\\n\\n            _setURI(tokenIdPointer, uri);\\n            tokenIds[i] = tokenIdPointer;\\n        }\\n\\n        // Batched event for GAS savings\\n        emit ChildrenCreated(tokenIds);\\n    }\\n\\n    //////////////////////////////////\\n    // Minting of existing children //\\n    //////////////////////////////////\\n\\n    /**\\n      @notice Mints a single child ERC1155 tokens, increasing its supply by the _amount specified. msg.data along with the\\n      parent contract as the recipient can be used to map the created children to a given parent token\\n      @dev Only callable with smart contact role\\n     */\\n    function mintChild(uint256 _childTokenId, uint256 _amount, address _beneficiary, bytes calldata _data) external {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxMaterials.mintChild: Sender must be smart contract\\\"\\n        );\\n\\n        require(bytes(tokenUris[_childTokenId]).length > 0, \\\"DigitalaxMaterials.mintChild: Strand does not exist\\\");\\n        require(_amount > 0, \\\"DigitalaxMaterials.mintChild: No amount specified\\\");\\n\\n        _mint(_beneficiary, _childTokenId, _amount, _data);\\n    }\\n\\n    /**\\n      @notice Mints a batch of child ERC1155 tokens, increasing its supply by the _amounts specified. msg.data along with the\\n      parent contract as the recipient can be used to map the created children to a given parent token\\n      @dev Only callable with smart contact role\\n     */\\n    function batchMintChildren(\\n        uint256[] calldata _childTokenIds,\\n        uint256[] calldata _amounts,\\n        address _beneficiary,\\n        bytes calldata _data\\n    ) external {\\n        require(\\n            accessControls.hasSmartContractRole(_msgSender()),\\n            \\\"DigitalaxMaterials.batchMintChildren: Sender must be smart contract\\\"\\n        );\\n\\n        require(_childTokenIds.length == _amounts.length, \\\"DigitalaxMaterials.batchMintChildren: Array lengths are invalid\\\");\\n        require(_childTokenIds.length > 0, \\\"DigitalaxMaterials.batchMintChildren: No data supplied in arrays\\\");\\n\\n        // Check the strands exist and no zero amounts\\n        for (uint256 i = 0; i < _childTokenIds.length; i++) {\\n            uint256 strandId = _childTokenIds[i];\\n            require(bytes(tokenUris[strandId]).length > 0, \\\"DigitalaxMaterials.batchMintChildren: Strand does not exist\\\");\\n\\n            uint256 amount = _amounts[i];\\n            require(amount > 0, \\\"DigitalaxMaterials.batchMintChildren: Invalid amount\\\");\\n        }\\n\\n        _mintBatch(_beneficiary, _childTokenIds, _amounts, _data);\\n    }\\n\\n    function updateAccessControls(DigitalaxAccessControls _accessControls) external {\\n        require(\\n            accessControls.hasAdminRole(_msgSender()),\\n            \\\"DigitalaxMaterials.updateAccessControls: Sender must be admin\\\"\\n        );\\n\\n        require(\\n            address(_accessControls) != address(0),\\n            \\\"DigitalaxMaterials.updateAccessControls: New access controls cannot be ZERO address\\\"\\n        );\\n\\n        accessControls = _accessControls;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/AlwaysRevertingEthReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ncontract AlwaysRevertingEthReceiver {\\n    receive() external payable {\\n        revert(\\\"No thanks\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/BiddingContractMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../DigitalaxAuction.sol\\\";\\n\\ncontract BiddingContractMock {\\n    DigitalaxAuction public auctionContract;\\n\\n    constructor(DigitalaxAuction _auctionContract) public {\\n        auctionContract = _auctionContract;\\n    }\\n\\n    function bid(uint256 _garmentTokenId) external payable {\\n        auctionContract.placeBid{value: msg.value}(_garmentTokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/DigitalaxAuctionMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../DigitalaxAuction.sol\\\";\\n\\ncontract DigitalaxAuctionMock is DigitalaxAuction {\\n    uint256 public nowOverride;\\n\\n    constructor(\\n        DigitalaxAccessControls _accessControls,\\n        IDigitalaxGarmentNFT _garmentNft,\\n        address payable _platformReserveAddress\\n    )\\n    DigitalaxAuction(_accessControls, _garmentNft, _platformReserveAddress)\\n    public {}\\n\\n    function setNowOverride(uint256 _now) external {\\n        nowOverride = _now;\\n    }\\n\\n    function _getNow() internal override view returns (uint256) {\\n        return nowOverride;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/DigitalaxGenesisNFTMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../DigitalaxGenesisNFT.sol\\\";\\n\\ncontract DigitalaxGenesisNFTMock is DigitalaxGenesisNFT {\\n    uint256 public nowOverride;\\n    uint256 public maxGenesisContributionTokensOverride;\\n\\n    constructor(\\n        DigitalaxAccessControls _accessControls,\\n        address payable _fundsMultisig,\\n        uint256 _genesisStart,\\n        uint256 _genesisEnd,\\n        string memory _tokenURI\\n    )\\n    DigitalaxGenesisNFT(_accessControls, _fundsMultisig, _genesisStart, _genesisEnd, _tokenURI)\\n    public {}\\n\\n    function addContribution(uint256 _contributionAmount) external {\\n        contribution[_msgSender()] = _contributionAmount;\\n        totalContributions = totalContributions.add(_contributionAmount);\\n    }\\n\\n    function setNowOverride(uint256 _now) external {\\n        nowOverride = _now;\\n    }\\n\\n    function setMaxGenesisContributionTokensOverride(uint256 _maxGenesisContributionTokensOverride) external {\\n        maxGenesisContributionTokensOverride = _maxGenesisContributionTokensOverride;\\n    }\\n\\n    function _getNow() internal override view returns (uint256) {\\n        return nowOverride;\\n    }\\n\\n    function _getMaxGenesisContributionTokens() internal override view returns (uint256) {\\n        return maxGenesisContributionTokensOverride;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/ERC1155Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../ERC1155/ERC1155.sol\\\";\\n\\ncontract ERC1155Mock is ERC1155 {\\n\\n    function mint(uint256 id, uint256 amount) external {\\n        _mint(msg.sender, id, amount, \\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/ERC1155ReceiverMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport \\\"./ERC165Mock.sol\\\";\\n\\ncontract ERC1155ReceiverMock is IERC1155Receiver, ERC165Mock {\\n    bytes4 private _recRetval;\\n    bool private _recReverts;\\n    bytes4 private _batRetval;\\n    bool private _batReverts;\\n\\n    event Received(address operator, address from, uint256 id, uint256 value, bytes data, uint256 gas);\\n    event BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data, uint256 gas);\\n\\n    constructor (\\n        bytes4 recRetval,\\n        bool recReverts,\\n        bytes4 batRetval,\\n        bool batReverts\\n    )\\n    public\\n    {\\n        _recRetval = recRetval;\\n        _recReverts = recReverts;\\n        _batRetval = batRetval;\\n        _batReverts = batReverts;\\n    }\\n\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n    external\\n    override\\n    returns(bytes4)\\n    {\\n        require(!_recReverts, \\\"ERC1155ReceiverMock: reverting on receive\\\");\\n        emit Received(operator, from, id, value, data, gasleft());\\n        return _recRetval;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n    external\\n    override\\n    returns(bytes4)\\n    {\\n        require(!_batReverts, \\\"ERC1155ReceiverMock: reverting on batch receive\\\");\\n        emit BatchReceived(operator, from, ids, values, data, gasleft());\\n        return _batRetval;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/ERC165Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\n\\ncontract ERC165Mock is ERC165 {\\n    function registerInterface(bytes4 interfaceId) public {\\n        _registerInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/ERC721ReceiverMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\ncontract ERC721ReceiverMock is IERC721Receiver {\\n    bytes4 private _retval;\\n    bool private _reverts;\\n\\n    event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\\n\\n    constructor (bytes4 retval, bool reverts) public {\\n        _retval = retval;\\n        _reverts = reverts;\\n    }\\n\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public override returns (bytes4)\\n    {\\n        require(!_reverts, \\\"ERC721ReceiverMock: reverting\\\");\\n        emit Received(operator, from, tokenId, data, gasleft());\\n        return _retval;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockERC20 is ERC20 {\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 supply\\n    ) public ERC20(name, symbol) {\\n        _mint(msg.sender, supply);\\n    }\\n\\n    function mint(address _to, uint256 _amount) public {\\n        _mint(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../garment/DigitalaxMaterials.sol\\\";\\n\\ncontract MockVault {\\n    DigitalaxMaterials public materials;\\n    IERC20 public supportedERC20Asset;\\n    uint256 public supportedERC20AssetSyntheticStrandId;\\n\\n    // using init rather than constructor as we need to know the contract address in the test to give it smart contract role\\n    function init(DigitalaxMaterials _materials, IERC20 _supportedERC20Asset, string memory _supportedAssetSyntheticStrandUri) external {\\n        materials = _materials;\\n\\n        // If this contract supported many assets, this would be in a 'whitelist' method of sorts (maybe without the createChild and instead with a strandId)\\n        supportedERC20Asset = _supportedERC20Asset;\\n        supportedERC20AssetSyntheticStrandId = materials.createChild(_supportedAssetSyntheticStrandUri);\\n    }\\n\\n    function mintAssetBackedSyntheticMaterial(uint256 _depositAmount) external {\\n        // Danger: Transfer does not guarantee this contract will receive all tokens depending on the token implementation\\n        supportedERC20Asset.transferFrom(msg.sender, address(this), _depositAmount);\\n\\n        //mint balance of strand to sender\\n        materials.mintChild(\\n            supportedERC20AssetSyntheticStrandId,\\n            _depositAmount,\\n            msg.sender,\\n            abi.encodePacked(\\\"\\\")\\n        );\\n    }\\n\\n    function mintAssetBackedSyntheticMaterialToGarment(address _garmentAddress, uint256 _garmentId, uint256 _depositAmount) external {\\n        //TODO: this should really check owner of garment ID is msg.sender otherwise you could add to someone elses garment\\n\\n        // Danger: Transfer does not guarantee this contract will receive all tokens depending on the token implementation\\n        supportedERC20Asset.transferFrom(msg.sender, address(this), _depositAmount);\\n\\n        //mint balance of strand to sender\\n        materials.mintChild(\\n            supportedERC20AssetSyntheticStrandId,\\n            _depositAmount,\\n            _garmentAddress,\\n            abi.encodePacked(_garmentId)\\n        );\\n    }\\n\\n    function claimUnderlyingAssetFromMaterial(uint256 _strandId, uint256 _claimAmount) external {\\n        //\\n        materials.burn(msg.sender, _strandId, _claimAmount);\\n        supportedERC20Asset.transfer(msg.sender, _claimAmount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract DigitalaxGarmentNFT\",\"name\":\"_garmentToken\",\"type\":\"address\"},{\"internalType\":\"contract DigitalaxMaterials\",\"name\":\"_materials\",\"type\":\"address\"},{\"internalType\":\"contract DigitalaxAccessControls\",\"name\":\"_accessControls\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"garmentTokenId\",\"type\":\"uint256\"}],\"name\":\"GarmentCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accessControls\",\"outputs\":[{\"internalType\":\"contract DigitalaxAccessControls\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"createNewChild\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"childTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_uris\",\"type\":\"string[]\"}],\"name\":\"createNewChildren\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"childTokenIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_garmentTokenUri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_designer\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"_childTokenUris\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_childTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"createNewChildrenWithBalanceAndGarment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_childTokenUris\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_childTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"createNewChildrenWithBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"garmentToken\",\"outputs\":[{\"internalType\":\"contract DigitalaxGarmentNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"materials\",\"outputs\":[{\"internalType\":\"contract DigitalaxMaterials\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"garmentTokenUri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"designer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"childTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"childTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"mintParentWithChildren\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"garmentTokenUri\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"designer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"mintParentWithoutChildren\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DigitalaxGarmentFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000b509f4b044f713a91bb50535914f7ad160532fe000000000000000000000000e6822e8b4d91b85f9ca00cca79bf92bab14bc221000000000000000000000000165eec91620b7bb96d02890d8a3f8cb79a29195c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://12882f7c6f6ee1592f37d20a285ea737a504fcb31c36a102fa91f01770a6e6b9"}]}