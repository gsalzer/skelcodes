{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/Interfaces/PriceCalculatorInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\ninterface PriceCalculatorInterface {\r\n    function calculatePrice(\r\n        uint256 buyAmount,\r\n        uint256 buyAmountLimit,\r\n        uint256 sellAmount,\r\n        uint256 sellAmountLimit,\r\n        uint256 baseTokenPool,\r\n        uint256 settlementTokenPool\r\n    ) external view returns (uint256[5] memory);\r\n}\r\n\r\n// File: contracts/Libraries/Enums.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\nenum Token {TOKEN0, TOKEN1}\r\n\r\n// FLEX_0_1 => Swap TOKEN0 to TOKEN1, slippage is tolerate to 5%\r\n// FLEX_1_0 => Swap TOKEN1 to TOKEN0, slippage is tolerate to 5%\r\n// STRICT_0_1 => Swap TOKEN0 to TOKEN1, slippage is limited in 0.1%\r\n// STRICT_1_0 => Swap TOKEN1 to TOKEN0, slippage is limited in 0.1%\r\nenum OrderType {FLEX_0_1, FLEX_1_0, STRICT_0_1, STRICT_1_0}\r\n\r\nlibrary TokenLibrary {\r\n    function another(Token self) internal pure returns (Token) {\r\n        if (self == Token.TOKEN0) {\r\n            return Token.TOKEN1;\r\n        } else {\r\n            return Token.TOKEN0;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary OrderTypeLibrary {\r\n    function inToken(OrderType self) internal pure returns (Token) {\r\n        if (self == OrderType.FLEX_0_1 || self == OrderType.STRICT_0_1) {\r\n            return Token.TOKEN0;\r\n        } else {\r\n            return Token.TOKEN1;\r\n        }\r\n    }\r\n\r\n    function isFlex(OrderType self) internal pure returns (bool) {\r\n        return self == OrderType.FLEX_0_1 || self == OrderType.FLEX_1_0;\r\n    }\r\n\r\n    function isStrict(OrderType self) internal pure returns (bool) {\r\n        return !isFlex(self);\r\n    }\r\n\r\n    function next(OrderType self) internal pure returns (OrderType) {\r\n        return OrderType((uint256(self) + 1) % 4);\r\n    }\r\n\r\n    function isBuy(OrderType self) internal pure returns (bool) {\r\n        return (self == OrderType.FLEX_0_1 || self == OrderType.STRICT_0_1);\r\n    }\r\n}\r\n\r\n// File: contracts/Libraries/RateMath.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\nlibrary RateMath {\r\n    using SafeMath for uint256;\r\n    uint256 public constant RATE_POINT_MULTIPLIER = 1000000000000000000; // 10^18\r\n\r\n    function getRate(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a.mul(RATE_POINT_MULTIPLIER).div(b);\r\n    }\r\n\r\n    function divByRate(uint256 self, uint256 rate)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return self.mul(RATE_POINT_MULTIPLIER).div(rate);\r\n    }\r\n\r\n    function mulByRate(uint256 self, uint256 rate)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return self.mul(rate).div(RATE_POINT_MULTIPLIER);\r\n    }\r\n}\r\n\r\n// File: contracts/Libraries/ExecutionStatus.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\nstruct BoxExecutionStatus {\r\n    OrderType partiallyRefundOrderType;\r\n    uint64 partiallyRefundRate; // refundAmount/inAmount\r\n    uint128 rate; // Token0/Token1\r\n    uint32 boxNumber;\r\n    bool onGoing;\r\n}\r\n\r\nstruct BookExecutionStatus {\r\n    OrderType executingOrderType;\r\n    uint256 nextIndex;\r\n}\r\n\r\nlibrary BoxExecutionStatusLibrary {\r\n    using OrderTypeLibrary for OrderType;\r\n\r\n    function refundRate(BoxExecutionStatus memory self, OrderType orderType)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // inToken is different from refundOrderType\r\n        if (self.partiallyRefundOrderType.inToken() != orderType.inToken()) {\r\n            return 0;\r\n        }\r\n\r\n        // inToken is the same as refundOrderType\r\n        // refund all of strict order and some of flex order\r\n        if (self.partiallyRefundOrderType.isFlex()) {\r\n            // orderType is flex\r\n            if (orderType.isFlex()) {\r\n                return self.partiallyRefundRate;\r\n            }\r\n            // orderType is strict\r\n            return RateMath.RATE_POINT_MULTIPLIER;\r\n        }\r\n\r\n        // refund some of strict order\r\n        if (orderType.isStrict()) {\r\n            return self.partiallyRefundRate;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: contracts/Libraries/OrderBox.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\n\r\nstruct OrderBox {\r\n    mapping(OrderType => OrderBook) orderBooks;\r\n    uint128 spreadRate;\r\n    uint128 expireAt;\r\n}\r\n\r\nstruct OrderBook {\r\n    mapping(address => uint256) inAmounts;\r\n    address[] recipients;\r\n    uint256 totalInAmount;\r\n}\r\n\r\nlibrary OrderBoxLibrary {\r\n    using RateMath for uint256;\r\n    using SafeMath for uint256;\r\n    using TokenLibrary for Token;\r\n\r\n    function newOrderBox(uint128 spreadRate, uint128 expireAt)\r\n        internal\r\n        pure\r\n        returns (OrderBox memory)\r\n    {\r\n        return OrderBox({spreadRate: spreadRate, expireAt: expireAt});\r\n    }\r\n\r\n    function addOrder(\r\n        OrderBox storage self,\r\n        OrderType orderType,\r\n        uint256 inAmount,\r\n        address recipient\r\n    ) internal {\r\n        OrderBook storage orderBook = self.orderBooks[orderType];\r\n        if (orderBook.inAmounts[recipient] == 0) {\r\n            orderBook.recipients.push(recipient);\r\n        }\r\n        orderBook.inAmounts[recipient] = orderBook.inAmounts[recipient].add(\r\n            inAmount\r\n        );\r\n        orderBook.totalInAmount = orderBook.totalInAmount.add(inAmount);\r\n    }\r\n}\r\n\r\nlibrary OrderBookLibrary {\r\n    function numOfOrder(OrderBook memory self) internal pure returns (uint256) {\r\n        return self.recipients.length;\r\n    }\r\n}\r\n\r\n// File: contracts/BoxExchange/BoxExchange.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\nabstract contract BoxExchange is ERC20 {\r\n    using BoxExecutionStatusLibrary for BoxExecutionStatus;\r\n    using OrderBoxLibrary for OrderBox;\r\n    using OrderBookLibrary for OrderBook;\r\n    using OrderTypeLibrary for OrderType;\r\n    using TokenLibrary for Token;\r\n    using RateMath for uint256;\r\n    using SafeMath for uint256;\r\n    using SafeCast for uint256;\r\n\r\n    uint256 internal constant MARKET_FEE_RATE = 200000000000000000; // market fee taker takes 20% of spread\r\n\r\n    address internal immutable factory;\r\n\r\n    address internal immutable marketFeeTaker; // Address that receives market fee (i.e. Lien Token)\r\n    uint128 public marketFeePool0; // Total market fee in TOKEN0\r\n    uint128 public marketFeePool1; // Total market fee in TOKEN1\r\n\r\n    uint128 internal reserve0; // Total Liquidity of TOKEN0\r\n    uint128 internal reserve1; // Total Liquidity of TOKEN1\r\n    OrderBox[] internal orderBoxes; // Array of OrderBox\r\n    PriceCalculatorInterface internal immutable priceCalc; // Price Calculator\r\n    BoxExecutionStatus internal boxExecutionStatus; // Struct that has information about execution of current executing OrderBox\r\n    BookExecutionStatus internal bookExecutionStatus; // Struct that has information about execution of current executing OrderBook\r\n\r\n    event AcceptOrders(\r\n        address indexed recipient,\r\n        bool indexed isBuy, // if true, this order is exchange from TOKEN0 to TOKEN1\r\n        uint32 indexed boxNumber,\r\n        bool isLimit, // if true, this order is STRICT order\r\n        uint256 tokenIn\r\n    );\r\n\r\n    event MoveLiquidity(\r\n        address indexed liquidityProvider,\r\n        bool indexed isAdd, // if true, this order is addtion of liquidity\r\n        uint256 movedToken0Amount,\r\n        uint256 movedToken1Amount,\r\n        uint256 sharesMoved // Amount of share that is minted or burned\r\n    );\r\n\r\n    event Execution(\r\n        bool indexed isBuy, // if true, this order is exchange from TOKEN0 to TOKEN1\r\n        uint32 indexed boxNumber,\r\n        address indexed recipient,\r\n        uint256 orderAmount, // Amount of token that is transferred when this order is added\r\n        uint256 refundAmount, // In the same token as orderAmount\r\n        uint256 outAmount // In the other token than orderAmount\r\n    );\r\n\r\n    event UpdateReserve(uint128 reserve0, uint128 reserve1, uint256 totalShare);\r\n\r\n    event PayMarketFee(uint256 amount0, uint256 amount1);\r\n\r\n    event ExecutionSummary(\r\n        uint32 indexed boxNumber,\r\n        uint8 partiallyRefundOrderType,\r\n        uint256 rate,\r\n        uint256 partiallyRefundRate,\r\n        uint256 totalInAmountFLEX_0_1,\r\n        uint256 totalInAmountFLEX_1_0,\r\n        uint256 totalInAmountSTRICT_0_1,\r\n        uint256 totalInAmountSTRICT_1_0\r\n    );\r\n\r\n    modifier isAmountSafe(uint256 amount) {\r\n        require(amount != 0, \"Amount should be bigger than 0\");\r\n        _;\r\n    }\r\n\r\n    modifier isInTime(uint256 timeout) {\r\n        require(timeout > _currentOpenBoxId(), \"Time out\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        PriceCalculatorInterface _priceCalc,\r\n        address _marketFeeTaker,\r\n        string memory _name\r\n    ) public ERC20(_name, \"share\") {\r\n        factory = msg.sender;\r\n        priceCalc = _priceCalc;\r\n        marketFeeTaker = _marketFeeTaker;\r\n        _setupDecimals(8); // Decimal of share token is the same as iDOL, LBT, and Lien Token\r\n    }\r\n\r\n    /**\r\n     * @notice Shows how many boxes and orders exist before the specific order\r\n     * @dev If this order does not exist, return (false, 0, 0)\r\n     * @dev If this order is already executed, return (true, 0, 0)\r\n     * @param recipient Recipient of this order\r\n     * @param boxNumber Box ID where the order exists\r\n     * @param isExecuted If true, the order is already executed\r\n     * @param boxCount Counter of boxes before this order. If current executing box number is the same as boxNumber, return 1 (i.e. indexing starts from 1)\r\n     * @param orderCount Counter of orders before this order. If this order is on n-th top of the queue, return n (i.e. indexing starts from 1)\r\n     **/\r\n    function whenToExecute(\r\n        address recipient,\r\n        uint256 boxNumber,\r\n        bool isBuy,\r\n        bool isLimit\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool isExecuted,\r\n            uint256 boxCount,\r\n            uint256 orderCount\r\n        )\r\n    {\r\n        return\r\n            _whenToExecute(recipient, _getOrderType(isBuy, isLimit), boxNumber);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns summary of current exchange status\r\n     * @param boxNumber Current open box ID\r\n     * @param _reserve0 Current reserve of TOKEN0\r\n     * @param _reserve1 Current reserve of TOKEN1\r\n     * @param totalShare Total Supply of share token\r\n     * @param latestSpreadRate Spread Rate in latest OrderBox\r\n     * @param token0PerShareE18 Amount of TOKEN0 per 1 share token and has 18 decimal\r\n     * @param token1PerShareE18 Amount of TOKEN1 per 1 share token and has 18 decimal\r\n     **/\r\n    function getExchangeData()\r\n        external\r\n        virtual\r\n        view\r\n        returns (\r\n            uint256 boxNumber,\r\n            uint256 _reserve0,\r\n            uint256 _reserve1,\r\n            uint256 totalShare,\r\n            uint256 latestSpreadRate,\r\n            uint256 token0PerShareE18,\r\n            uint256 token1PerShareE18\r\n        )\r\n    {\r\n        boxNumber = _currentOpenBoxId();\r\n        (_reserve0, _reserve1) = _getReserves();\r\n        latestSpreadRate = orderBoxes[boxNumber].spreadRate;\r\n        totalShare = totalSupply();\r\n        token0PerShareE18 = RateMath.getRate(_reserve0, totalShare);\r\n        token1PerShareE18 = RateMath.getRate(_reserve1, totalShare);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets summary of Current box information (Total order amount of each OrderTypes)\r\n     * @param executionStatusNumber Status of execution of this box\r\n     * @param boxNumber ID of target box.\r\n     **/\r\n    function getBoxSummary(uint256 boxNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 executionStatusNumber,\r\n            uint256 flexToken0InAmount,\r\n            uint256 strictToken0InAmount,\r\n            uint256 flexToken1InAmount,\r\n            uint256 strictToken1InAmount\r\n        )\r\n    {\r\n        // `executionStatusNumber`\r\n        // 0 => This box has not been executed\r\n        // 1 => This box is currently executing. (Reserves and market fee pools have already been updated)\r\n        // 2 => This box has already been executed\r\n        uint256 nextExecutingBoxId = boxExecutionStatus.boxNumber;\r\n        flexToken0InAmount = orderBoxes[boxNumber].orderBooks[OrderType\r\n            .FLEX_0_1]\r\n            .totalInAmount;\r\n        strictToken0InAmount = orderBoxes[boxNumber].orderBooks[OrderType\r\n            .STRICT_0_1]\r\n            .totalInAmount;\r\n        flexToken1InAmount = orderBoxes[boxNumber].orderBooks[OrderType\r\n            .FLEX_1_0]\r\n            .totalInAmount;\r\n        strictToken1InAmount = orderBoxes[boxNumber].orderBooks[OrderType\r\n            .STRICT_1_0]\r\n            .totalInAmount;\r\n        if (boxNumber < nextExecutingBoxId) {\r\n            executionStatusNumber = 2;\r\n        } else if (\r\n            boxNumber == nextExecutingBoxId && boxExecutionStatus.onGoing\r\n        ) {\r\n            executionStatusNumber = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets amount of order in current open box\r\n     * @param account Target Address\r\n     * @param orderType OrderType of target order\r\n     * @return Amount of target order\r\n     **/\r\n    function getOrderAmount(address account, OrderType orderType)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            orderBoxes[_currentOpenBoxId()].orderBooks[orderType]\r\n                .inAmounts[account];\r\n    }\r\n\r\n    // abstract functions\r\n    function _feeRate() internal virtual returns (uint128);\r\n\r\n    function _receiveTokens(\r\n        Token token,\r\n        address from,\r\n        uint256 amount\r\n    ) internal virtual;\r\n\r\n    function _sendTokens(\r\n        Token token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual;\r\n\r\n    function _payForOrderExecution(\r\n        Token token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual;\r\n\r\n    function _payMarketFee(\r\n        address _marketFeeTaker,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal virtual;\r\n\r\n    function _isCurrentOpenBoxExpired() internal virtual view returns (bool) {}\r\n\r\n    /**\r\n     * @notice User can determine the amount of share token to mint.\r\n     * @dev This function can be executed only by factory\r\n     * @param amount0 The amount of TOKEN0 to invest\r\n     * @param amount1 The amount of TOKEN1 to invest\r\n     * @param initialShare The amount of share token to mint. This defines approximate value of share token.\r\n     **/\r\n    function _init(\r\n        uint128 amount0,\r\n        uint128 amount1,\r\n        uint256 initialShare\r\n    ) internal virtual {\r\n        require(totalSupply() == 0, \"Already initialized\");\r\n        require(msg.sender == factory);\r\n        _updateReserve(amount0, amount1);\r\n        _mint(msg.sender, initialShare);\r\n        _receiveTokens(Token.TOKEN0, msg.sender, amount0);\r\n        _receiveTokens(Token.TOKEN1, msg.sender, amount1);\r\n        _openNewBox();\r\n    }\r\n\r\n    /**\r\n     * @dev Amount of share to mint is determined by `amount`\r\n     * @param tokenType Type of token which the amount of share the LP get is calculated based on `amount`\r\n     * @param amount The amount of token type of `tokenType`\r\n     **/\r\n    function _addLiquidity(\r\n        uint256 _reserve0,\r\n        uint256 _reserve1,\r\n        uint256 amount,\r\n        uint256 minShare,\r\n        Token tokenType\r\n    ) internal virtual {\r\n        (uint256 amount0, uint256 amount1, uint256 share) = _calculateAmounts(\r\n            amount,\r\n            _reserve0,\r\n            _reserve1,\r\n            tokenType\r\n        );\r\n        require(share >= minShare, \"You can't receive enough shares\");\r\n        _receiveTokens(Token.TOKEN0, msg.sender, amount0);\r\n        _receiveTokens(Token.TOKEN1, msg.sender, amount1);\r\n        _updateReserve(\r\n            _reserve0.add(amount0).toUint128(),\r\n            _reserve1.add(amount1).toUint128()\r\n        );\r\n        _mint(msg.sender, share);\r\n        emit MoveLiquidity(msg.sender, true, amount0, amount1, share);\r\n    }\r\n\r\n    /**\r\n     * @dev Amount of TOKEN0 and TOKEN1 is determined by amount of share to be burned\r\n     * @param minAmount0 Minimum amount of TOKEN0 to return. If returned TOKEN0 is less than this value, revert transaction\r\n     * @param minAmount1 Minimum amount of TOKEN1 to return. If returned TOKEN1 is less than this value, revert transaction\r\n     * @param share Amount of share token to be burned\r\n     **/\r\n    function _removeLiquidity(\r\n        uint256 minAmount0,\r\n        uint256 minAmount1,\r\n        uint256 share\r\n    ) internal virtual {\r\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves(); // gas savings\r\n        uint256 _totalSupply = totalSupply();\r\n        uint256 amount0 = _reserve0.mul(share).div(_totalSupply);\r\n        uint256 amount1 = _reserve1.mul(share).div(_totalSupply);\r\n        require(\r\n            amount0 >= minAmount0 && amount1 >= minAmount1,\r\n            \"You can't receive enough tokens\"\r\n        );\r\n        _updateReserve(\r\n            _reserve0.sub(amount0).toUint128(),\r\n            _reserve1.sub(amount1).toUint128()\r\n        );\r\n        _burn(msg.sender, share);\r\n        _sendTokens(Token.TOKEN0, msg.sender, amount0);\r\n        _sendTokens(Token.TOKEN1, msg.sender, amount1);\r\n        emit MoveLiquidity(msg.sender, false, amount0, amount1, share);\r\n    }\r\n\r\n    /**\r\n     * @dev If there is some OrderBox to be executed, try execute 5 orders\r\n     * @dev If currentBox has expired, open new box\r\n     * @param orderType Type of order\r\n     * @param inAmount Amount of token to be exchanged\r\n     * @param recipient Recipient of swapped token. If this value is address(0), msg.sender is the recipient\r\n     **/\r\n    function _addOrder(\r\n        OrderType orderType,\r\n        uint256 inAmount,\r\n        address recipient\r\n    ) internal virtual {\r\n        _rotateBox();\r\n        uint256 _currentOpenBoxId = _currentOpenBoxId();\r\n        _executeOrders(5, _currentOpenBoxId);\r\n        if (recipient == address(0)) {\r\n            recipient = msg.sender;\r\n        }\r\n        _receiveTokens(orderType.inToken(), msg.sender, inAmount);\r\n        orderBoxes[_currentOpenBoxId].addOrder(orderType, inAmount, recipient);\r\n        emit AcceptOrders(\r\n            recipient,\r\n            orderType.isBuy(),\r\n            uint32(_currentOpenBoxId),\r\n            orderType.isStrict(),\r\n            inAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers executeOrders()\r\n     * @param maxOrderNum Number of orders to execute (if no order is left, stop execution)\r\n     **/\r\n    function _triggerExecuteOrders(uint8 maxOrderNum) internal virtual {\r\n        _executeOrders(maxOrderNum, _currentOpenBoxId());\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers PayMarketFee() and update marketFeePool to 0\r\n     **/\r\n    function _triggerPayMarketFee() internal virtual {\r\n        (\r\n            uint256 _marketFeePool0,\r\n            uint256 _marketFeePool1\r\n        ) = _getMarketFeePools();\r\n        _updateMarketFeePool(0, 0);\r\n\r\n        emit PayMarketFee(_marketFeePool0, _marketFeePool1);\r\n        _payMarketFee(marketFeeTaker, _marketFeePool0, _marketFeePool1);\r\n    }\r\n\r\n    // When open new box, creates new OrderBox with spreadRate and block number of expiretion, then pushes it to orderBoxes\r\n    function _openNewBox() internal virtual {\r\n        orderBoxes.push(\r\n            OrderBoxLibrary.newOrderBox(\r\n                _feeRate(),\r\n                (block.number + 2).toUint32()\r\n            )\r\n        );\r\n    }\r\n\r\n    function _rotateBox() private {\r\n        // if current open box has expired\r\n        if (_isCurrentOpenBoxExpired()) {\r\n            _openNewBox();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param maxOrderNum Number of orders to execute (if no order is left, stoppes execution)\r\n     * @param _currentOpenBoxId Current box ID (_currentOpenBoxID() is already run in _addOrder() or _triggerExecuteOrders()\r\n     **/\r\n    function _executeOrders(uint256 maxOrderNum, uint256 _currentOpenBoxId)\r\n        private\r\n    {\r\n        BoxExecutionStatus memory _boxExecutionStatus = boxExecutionStatus;\r\n        BookExecutionStatus memory _bookExecutionStatus = bookExecutionStatus;\r\n        // if _boxExecutionStatus.boxNumber is current open and not expired box, won't execute.\r\n        // if _boxExecutionStatus.boxNumber is more than currentOpenBoxId, the newest box is already executed.\r\n        if (\r\n            _boxExecutionStatus.boxNumber >= _currentOpenBoxId &&\r\n            (!_isCurrentOpenBoxExpired() ||\r\n                _boxExecutionStatus.boxNumber > _currentOpenBoxId)\r\n        ) {\r\n            return;\r\n        }\r\n        if (!_boxExecutionStatus.onGoing) {\r\n            // get rates and start new box execution\r\n            // before start new box execution, updates reserves.\r\n            {\r\n                (\r\n                    OrderType partiallyRefundOrderType,\r\n                    uint256 partiallyRefundRate,\r\n                    uint256 rate\r\n                ) = _getExecutionRatesAndUpdateReserve(\r\n                    _boxExecutionStatus.boxNumber\r\n                );\r\n                _boxExecutionStatus\r\n                    .partiallyRefundOrderType = partiallyRefundOrderType;\r\n                _boxExecutionStatus.partiallyRefundRate = partiallyRefundRate\r\n                    .toUint64();\r\n                _boxExecutionStatus.rate = rate.toUint128();\r\n                _boxExecutionStatus.onGoing = true;\r\n                _bookExecutionStatus.executingOrderType = OrderType(0);\r\n                _bookExecutionStatus.nextIndex = 0;\r\n            }\r\n        }\r\n        // execute orders in one book\r\n        // reducing maxOrderNum to avoid stack to deep\r\n        while (maxOrderNum != 0) {\r\n            OrderBook storage executionBook = orderBoxes[_boxExecutionStatus\r\n                .boxNumber]\r\n                .orderBooks[_bookExecutionStatus.executingOrderType];\r\n            (\r\n                bool isBookFinished,\r\n                uint256 nextIndex,\r\n                uint256 executedOrderNum\r\n            ) = _executeOrdersInBook(\r\n                executionBook,\r\n                _bookExecutionStatus.executingOrderType.inToken(),\r\n                _bookExecutionStatus.nextIndex,\r\n                _boxExecutionStatus.refundRate(\r\n                    _bookExecutionStatus.executingOrderType\r\n                ),\r\n                _boxExecutionStatus.rate,\r\n                orderBoxes[_boxExecutionStatus.boxNumber].spreadRate,\r\n                maxOrderNum\r\n            );\r\n            if (isBookFinished) {\r\n                bool isBoxFinished = _isBoxFinished(\r\n                    orderBoxes[_boxExecutionStatus.boxNumber],\r\n                    _bookExecutionStatus.executingOrderType\r\n                );\r\n                delete orderBoxes[_boxExecutionStatus.boxNumber]\r\n                    .orderBooks[_bookExecutionStatus.executingOrderType];\r\n\r\n                // update book execution status and box execution status\r\n                if (isBoxFinished) {\r\n                    _boxExecutionStatus.boxNumber += 1;\r\n                    _boxExecutionStatus.onGoing = false;\r\n                    boxExecutionStatus = _boxExecutionStatus;\r\n\r\n                    return; // no need to update bookExecutionStatus;\r\n                }\r\n                _bookExecutionStatus.executingOrderType = _bookExecutionStatus\r\n                    .executingOrderType\r\n                    .next();\r\n            }\r\n            _bookExecutionStatus.nextIndex = nextIndex.toUint32();\r\n            maxOrderNum -= executedOrderNum;\r\n        }\r\n        boxExecutionStatus = _boxExecutionStatus;\r\n        bookExecutionStatus = _bookExecutionStatus;\r\n    }\r\n\r\n    /**\r\n     * @notice Executes each OrderBook\r\n     * @param orderBook Target OrderBook\r\n     * @param rate Rate of swap\r\n     * @param refundRate Refund rate in this OrderType\r\n     * @param maxOrderNum Max number of orders to execute in this book\r\n     * @return If execution is finished, return true\r\n     * @return Next index to execute. If execution is finished, return 0\r\n     * @return Number of orders executed\r\n     **/\r\n    function _executeOrdersInBook(\r\n        OrderBook storage orderBook,\r\n        Token inToken,\r\n        uint256 initialIndex,\r\n        uint256 refundRate,\r\n        uint256 rate,\r\n        uint256 spreadRate,\r\n        uint256 maxOrderNum\r\n    )\r\n        private\r\n        returns (\r\n            bool,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 index;\r\n        uint256 numOfOrder = orderBook.numOfOrder();\r\n        for (\r\n            index = initialIndex;\r\n            index - initialIndex < maxOrderNum;\r\n            index++\r\n        ) {\r\n            if (index >= numOfOrder) {\r\n                return (true, 0, index - initialIndex);\r\n            }\r\n            address recipient = orderBook.recipients[index];\r\n            _executeOrder(\r\n                inToken,\r\n                recipient,\r\n                orderBook.inAmounts[recipient],\r\n                refundRate,\r\n                rate,\r\n                spreadRate\r\n            );\r\n        }\r\n        if (index >= numOfOrder) {\r\n            return (true, 0, index - initialIndex);\r\n        }\r\n        return (false, index, index - initialIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Executes each order\r\n     * @param inToken type of token\r\n     * @param recipient Recipient of Token\r\n     * @param inAmount Amount of token\r\n     * @param refundRate Refund rate in this OrderType\r\n     * @param rate Rate of swap\r\n     * @param spreadRate Spread rate in this box\r\n     **/\r\n    function _executeOrder(\r\n        Token inToken,\r\n        address recipient,\r\n        uint256 inAmount,\r\n        uint256 refundRate,\r\n        uint256 rate,\r\n        uint256 spreadRate\r\n    ) internal {\r\n        Token outToken = inToken.another();\r\n        // refundAmount = inAmount * refundRate\r\n        uint256 refundAmount = inAmount.mulByRate(refundRate);\r\n        // executingInAmountWithoutSpread = (inAmount - refundAmount) / (1+spreadRate)\r\n        uint256 executingInAmountWithoutSpread = inAmount\r\n            .sub(refundAmount)\r\n            .divByRate(RateMath.RATE_POINT_MULTIPLIER.add(spreadRate));\r\n        // spread = executingInAmountWithoutSpread * spreadRate\r\n        // = (inAmount - refundAmount ) * ( 1 - 1 /( 1 + spreadRate))\r\n        uint256 outAmount = _otherAmountBasedOnRate(\r\n            inToken,\r\n            executingInAmountWithoutSpread,\r\n            rate\r\n        );\r\n        _payForOrderExecution(inToken, recipient, refundAmount);\r\n        _payForOrderExecution(outToken, recipient, outAmount);\r\n        emit Execution(\r\n            (inToken == Token.TOKEN0),\r\n            uint32(_currentOpenBoxId()),\r\n            recipient,\r\n            inAmount,\r\n            refundAmount,\r\n            outAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates reserves and market fee pools\r\n     * @param spreadRate Spread rate in the box\r\n     * @param executingAmount0WithoutSpread Executed amount of TOKEN0 in this box\r\n     * @param executingAmount1WithoutSpread Executed amount of TOKEN1 in this box\r\n     * @param rate Rate of swap\r\n     **/\r\n    function _updateReservesAndMarketFeePoolByExecution(\r\n        uint256 spreadRate,\r\n        uint256 executingAmount0WithoutSpread,\r\n        uint256 executingAmount1WithoutSpread,\r\n        uint256 rate\r\n    ) internal virtual {\r\n        uint256 newReserve0;\r\n        uint256 newReserve1;\r\n        uint256 newMarketFeePool0;\r\n        uint256 newMarketFeePool1;\r\n        {\r\n            (\r\n                uint256 differenceOfReserve,\r\n                uint256 differenceOfMarketFee\r\n            ) = _calculateNewReserveAndMarketFeePool(\r\n                spreadRate,\r\n                executingAmount0WithoutSpread,\r\n                executingAmount1WithoutSpread,\r\n                rate,\r\n                Token.TOKEN0\r\n            );\r\n            newReserve0 = reserve0 + differenceOfReserve;\r\n            newMarketFeePool0 = marketFeePool0 + differenceOfMarketFee;\r\n        }\r\n        {\r\n            (\r\n                uint256 differenceOfReserve,\r\n                uint256 differenceOfMarketFee\r\n            ) = _calculateNewReserveAndMarketFeePool(\r\n                spreadRate,\r\n                executingAmount1WithoutSpread,\r\n                executingAmount0WithoutSpread,\r\n                rate,\r\n                Token.TOKEN1\r\n            );\r\n            newReserve1 = reserve1 + differenceOfReserve;\r\n            newMarketFeePool1 = marketFeePool1 + differenceOfMarketFee;\r\n        }\r\n        _updateReserve(newReserve0.toUint128(), newReserve1.toUint128());\r\n        _updateMarketFeePool(\r\n            newMarketFeePool0.toUint128(),\r\n            newMarketFeePool1.toUint128()\r\n        );\r\n    }\r\n\r\n    function _whenToExecute(\r\n        address recipient,\r\n        uint256 orderTypeCount,\r\n        uint256 boxNumber\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            bool isExecuted,\r\n            uint256 boxCount,\r\n            uint256 orderCount\r\n        )\r\n    {\r\n        if (boxNumber > _currentOpenBoxId()) {\r\n            return (false, 0, 0);\r\n        }\r\n        OrderBox storage yourOrderBox = orderBoxes[boxNumber];\r\n        address[] memory recipients = yourOrderBox.orderBooks[OrderType(\r\n            orderTypeCount\r\n        )]\r\n            .recipients;\r\n        uint256 nextExecutingBoxId = boxExecutionStatus.boxNumber;\r\n        uint256 nextIndex = bookExecutionStatus.nextIndex;\r\n        uint256 nextType = uint256(bookExecutionStatus.executingOrderType);\r\n        bool onGoing = boxExecutionStatus.onGoing;\r\n        bool isExist;\r\n        uint256 place;\r\n        for (uint256 j = 0; j != recipients.length; j++) {\r\n            if (recipients[j] == recipient) {\r\n                isExist = true;\r\n                place = j;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If current box number exceeds boxNumber, the target box has already been executed\r\n        // If current box number is equal to boxNumber, and OrderType or index exceeds that of the target order, the target box has already been executed\r\n        if (\r\n            (boxNumber < nextExecutingBoxId) ||\r\n            ((onGoing && (boxNumber == nextExecutingBoxId)) &&\r\n                ((orderTypeCount < nextType) ||\r\n                    ((orderTypeCount == nextType) && (place < nextIndex))))\r\n        ) {\r\n            return (true, 0, 0);\r\n        }\r\n\r\n        if (!isExist) {\r\n            return (false, 0, 0);\r\n        }\r\n\r\n        // Total number of orders before the target OrderType\r\n        uint256 counts;\r\n        if (boxNumber == nextExecutingBoxId && onGoing) {\r\n            for (uint256 i = nextType; i < orderTypeCount; i++) {\r\n                counts += yourOrderBox.orderBooks[OrderType(i)].numOfOrder();\r\n            }\r\n            boxCount = 1;\r\n            orderCount = counts.add(place).sub(nextIndex) + 1;\r\n        } else {\r\n            for (uint256 i = 0; i != orderTypeCount; i++) {\r\n                counts += yourOrderBox.orderBooks[OrderType(i)].numOfOrder();\r\n            }\r\n            boxCount = boxNumber.sub(nextExecutingBoxId) + 1;\r\n            orderCount = counts.add(place) + 1;\r\n        }\r\n    }\r\n\r\n    function _getReserves()\r\n        internal\r\n        view\r\n        returns (uint256 _reserve0, uint256 _reserve1)\r\n    {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n    }\r\n\r\n    function _getMarketFeePools()\r\n        internal\r\n        view\r\n        returns (uint256 _marketFeePool0, uint256 _marketFeePool1)\r\n    {\r\n        _marketFeePool0 = marketFeePool0;\r\n        _marketFeePool1 = marketFeePool1;\r\n    }\r\n\r\n    function _updateReserve(uint128 newReserve0, uint128 newReserve1) internal {\r\n        reserve0 = newReserve0;\r\n        reserve1 = newReserve1;\r\n        emit UpdateReserve(newReserve0, newReserve1, totalSupply());\r\n    }\r\n\r\n    function _calculatePriceWrapper(\r\n        uint256 flexToken0InWithoutSpread,\r\n        uint256 strictToken0InWithoutSpread,\r\n        uint256 flexToken1InWithoutSpread,\r\n        uint256 strictToken1InWithoutSpread,\r\n        uint256 _reserve0,\r\n        uint256 _reserve1\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 rate,\r\n            uint256 refundStatus,\r\n            uint256 partiallyRefundRate,\r\n            uint256 executingAmount0,\r\n            uint256 executingAmount1\r\n        )\r\n    {\r\n        uint256[5] memory data = priceCalc.calculatePrice(\r\n            flexToken0InWithoutSpread,\r\n            strictToken0InWithoutSpread,\r\n            flexToken1InWithoutSpread,\r\n            strictToken1InWithoutSpread,\r\n            _reserve0,\r\n            _reserve1\r\n        );\r\n        return (data[0], data[1], data[2], data[3], data[4]);\r\n    }\r\n\r\n    /**\r\n     * @param rate0Per1 Token0 / Token1 * RATE_POINT_MULTIPLIER\r\n     */\r\n    function _otherAmountBasedOnRate(\r\n        Token token,\r\n        uint256 amount,\r\n        uint256 rate0Per1\r\n    ) internal pure returns (uint256) {\r\n        if (token == Token.TOKEN0) {\r\n            return amount.mulByRate(rate0Per1);\r\n        } else {\r\n            return amount.divByRate(rate0Per1);\r\n        }\r\n    }\r\n\r\n    function _currentOpenBoxId() internal view returns (uint256) {\r\n        return orderBoxes.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets OrderType in uint\r\n     **/\r\n    function _getOrderType(bool isBuy, bool isLimit)\r\n        internal\r\n        pure\r\n        returns (uint256 orderTypeCount)\r\n    {\r\n        if (isBuy && isLimit) {\r\n            orderTypeCount = 2;\r\n        } else if (!isBuy) {\r\n            if (isLimit) {\r\n                orderTypeCount = 3;\r\n            } else {\r\n                orderTypeCount = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateMarketFeePool(\r\n        uint128 newMarketFeePool0,\r\n        uint128 newMarketFeePool1\r\n    ) private {\r\n        marketFeePool0 = newMarketFeePool0;\r\n        marketFeePool1 = newMarketFeePool1;\r\n    }\r\n\r\n    function _calculateAmounts(\r\n        uint256 amount,\r\n        uint256 _reserve0,\r\n        uint256 _reserve1,\r\n        Token tokenType\r\n    )\r\n        private\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        if (tokenType == Token.TOKEN0) {\r\n            return (\r\n                amount,\r\n                amount.mul(_reserve1).div(_reserve0),\r\n                amount.mul(totalSupply()).div(_reserve0)\r\n            );\r\n        } else {\r\n            return (\r\n                amount.mul(_reserve0).div(_reserve1),\r\n                amount,\r\n                amount.mul(totalSupply()).div(_reserve1)\r\n            );\r\n        }\r\n    }\r\n\r\n    function _priceCalculateRates(\r\n        OrderBox storage orderBox,\r\n        uint256 totalInAmountFLEX_0_1,\r\n        uint256 totalInAmountFLEX_1_0,\r\n        uint256 totalInAmountSTRICT_0_1,\r\n        uint256 totalInAmountSTRICT_1_0\r\n    )\r\n        private\r\n        view\r\n        returns (\r\n            uint256 rate,\r\n            uint256 refundStatus,\r\n            uint256 partiallyRefundRate,\r\n            uint256 executingAmount0,\r\n            uint256 executingAmount1\r\n        )\r\n    {\r\n        uint256 withoutSpreadRate = RateMath.RATE_POINT_MULTIPLIER +\r\n            orderBox.spreadRate;\r\n        return\r\n            _calculatePriceWrapper(\r\n                totalInAmountFLEX_0_1.divByRate(withoutSpreadRate),\r\n                totalInAmountSTRICT_0_1.divByRate(withoutSpreadRate),\r\n                totalInAmountFLEX_1_0.divByRate(withoutSpreadRate),\r\n                totalInAmountSTRICT_1_0.divByRate(withoutSpreadRate),\r\n                reserve0,\r\n                reserve1\r\n            );\r\n    }\r\n\r\n    function _getExecutionRatesAndUpdateReserve(uint32 boxNumber)\r\n        private\r\n        returns (\r\n            OrderType partiallyRefundOrderType,\r\n            uint256 partiallyRefundRate,\r\n            uint256 rate\r\n        )\r\n    {\r\n        OrderBox storage orderBox = orderBoxes[boxNumber];\r\n        // `refundStatus`\r\n        // 0 => no_refund\r\n        // 1 => refund some of strictToken0\r\n        // 2 => refund all strictToken0 and some of flexToken0\r\n        // 3 => refund some of strictToken1\r\n        // 4 => refund all strictToken1 and some of flexToken1\r\n        uint256 refundStatus;\r\n        uint256 executingAmount0WithoutSpread;\r\n        uint256 executingAmount1WithoutSpread;\r\n        uint256 totalInAmountFLEX_0_1 = orderBox.orderBooks[OrderType.FLEX_0_1]\r\n            .totalInAmount;\r\n        uint256 totalInAmountFLEX_1_0 = orderBox.orderBooks[OrderType.FLEX_1_0]\r\n            .totalInAmount;\r\n        uint256 totalInAmountSTRICT_0_1 = orderBox.orderBooks[OrderType\r\n            .STRICT_0_1]\r\n            .totalInAmount;\r\n        uint256 totalInAmountSTRICT_1_0 = orderBox.orderBooks[OrderType\r\n            .STRICT_1_0]\r\n            .totalInAmount;\r\n        (\r\n            rate,\r\n            refundStatus,\r\n            partiallyRefundRate,\r\n            executingAmount0WithoutSpread,\r\n            executingAmount1WithoutSpread\r\n        ) = _priceCalculateRates(\r\n            orderBox,\r\n            totalInAmountFLEX_0_1,\r\n            totalInAmountFLEX_1_0,\r\n            totalInAmountSTRICT_0_1,\r\n            totalInAmountSTRICT_1_0\r\n        );\r\n\r\n        {\r\n            if (refundStatus == 0) {\r\n                partiallyRefundOrderType = OrderType.STRICT_0_1;\r\n                //refundRate = 0;\r\n            } else if (refundStatus == 1) {\r\n                partiallyRefundOrderType = OrderType.STRICT_0_1;\r\n            } else if (refundStatus == 2) {\r\n                partiallyRefundOrderType = OrderType.FLEX_0_1;\r\n            } else if (refundStatus == 3) {\r\n                partiallyRefundOrderType = OrderType.STRICT_1_0;\r\n            } else if (refundStatus == 4) {\r\n                partiallyRefundOrderType = OrderType.FLEX_1_0;\r\n            }\r\n        }\r\n        emit ExecutionSummary(\r\n            boxNumber,\r\n            uint8(partiallyRefundOrderType),\r\n            rate,\r\n            partiallyRefundRate,\r\n            totalInAmountFLEX_0_1,\r\n            totalInAmountFLEX_1_0,\r\n            totalInAmountSTRICT_0_1,\r\n            totalInAmountSTRICT_1_0\r\n        );\r\n        _updateReservesAndMarketFeePoolByExecution(\r\n            orderBox.spreadRate,\r\n            executingAmount0WithoutSpread,\r\n            executingAmount1WithoutSpread,\r\n            rate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Detects if this OrderBox is finished\r\n     * @param orders Target OrderBox\r\n     * @param lastFinishedOrderType Latest OrderType which is executed\r\n     **/\r\n    function _isBoxFinished(\r\n        OrderBox storage orders,\r\n        OrderType lastFinishedOrderType\r\n    ) private view returns (bool) {\r\n        // If orderType is STRICT_1_0, no book is left\r\n        if (lastFinishedOrderType == OrderType.STRICT_1_0) {\r\n            return true;\r\n        }\r\n        for (uint256 i = uint256(lastFinishedOrderType.next()); i != 4; i++) {\r\n            OrderBook memory book = orders.orderBooks[OrderType(i)];\r\n            // If OrderBook has some order return false\r\n            if (book.numOfOrder() != 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _calculateNewReserveAndMarketFeePool(\r\n        uint256 spreadRate,\r\n        uint256 executingAmountWithoutSpread,\r\n        uint256 anotherExecutingAmountWithoutSpread,\r\n        uint256 rate,\r\n        Token tokenType\r\n    ) internal returns (uint256, uint256) {\r\n        uint256 totalSpread = executingAmountWithoutSpread.mulByRate(\r\n            spreadRate\r\n        );\r\n        uint256 marketFee = totalSpread.mulByRate(MARKET_FEE_RATE);\r\n        uint256 newReserve = executingAmountWithoutSpread +\r\n            (totalSpread - marketFee) -\r\n            _otherAmountBasedOnRate(\r\n                tokenType.another(),\r\n                anotherExecutingAmountWithoutSpread,\r\n                rate\r\n            );\r\n        return (newReserve, marketFee);\r\n    }\r\n\r\n    function _getTokenType(bool isBuy, bool isStrict)\r\n        internal\r\n        pure\r\n        returns (OrderType)\r\n    {\r\n        if (isBuy) {\r\n            if (isStrict) {\r\n                return OrderType.STRICT_0_1;\r\n            } else {\r\n                return OrderType.FLEX_0_1;\r\n            }\r\n        } else {\r\n            if (isStrict) {\r\n                return OrderType.STRICT_1_0;\r\n            } else {\r\n                return OrderType.FLEX_1_0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Interfaces/ERC20Interface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\ninterface ERC20Interface is IERC20 {\r\n    function name() external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Interfaces/OracleInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\ninterface OracleInterface {\r\n    function latestPrice() external returns (uint256);\r\n\r\n    function getVolatility() external returns (uint256);\r\n\r\n    function latestId() external returns (uint256);\r\n}\r\n\r\n// File: contracts/Interfaces/SpreadCalculatorInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\ninterface SpreadCalculatorInterface {\r\n    function calculateCurrentSpread(\r\n        uint256 _maturity,\r\n        uint256 _strikePrice,\r\n        OracleInterface oracle\r\n    ) external returns (uint128);\r\n\r\n    function calculateSpreadByAssetVolatility(OracleInterface oracle)\r\n        external\r\n        returns (uint128);\r\n}\r\n\r\n// File: contracts/BoxExchange/TokenBoxExchange/TokenBoxExchange.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract TokenBoxExchange is BoxExchange {\r\n  using SafeERC20 for ERC20Interface;\r\n\r\n  ERC20Interface public immutable idol; // token0\r\n  ERC20Interface public immutable token;\r\n  SpreadCalculatorInterface internal immutable spreadCalc;\r\n  OracleInterface internal immutable oracle;\r\n\r\n  event SpreadRate(uint128 indexed boxNumber, uint128 spreadRate);\r\n\r\n  /**\r\n   * @param _idol iDOL contract\r\n   * @param _token ERC20 contract\r\n   * @param _priceCalc Price Calculator contract\r\n   * @param _marketFeeTaker Address of market fee taker (i.e. Lien Token)\r\n   * @param _spreadCalc Spread Calculator contract\r\n   * @param _oracle Oracle contract\r\n   * @param _name Name of share token\r\n   **/\r\n  constructor(\r\n    ERC20Interface _idol,\r\n    ERC20Interface _token,\r\n    PriceCalculatorInterface _priceCalc,\r\n    address _marketFeeTaker,\r\n    SpreadCalculatorInterface _spreadCalc,\r\n    OracleInterface _oracle,\r\n    string memory _name\r\n  ) public BoxExchange(_priceCalc, _marketFeeTaker, _name) {\r\n    idol = _idol;\r\n    token = _token;\r\n    spreadCalc = _spreadCalc;\r\n    oracle = _oracle;\r\n  }\r\n\r\n  /**\r\n   * @param IDOLAmount Amount of initial liquidity of iDOL to be provided\r\n   * @param settlementTokenAmount Amount of initial liquidity of the other token to be provided\r\n   * @param initialShare Initial amount of share token\r\n   **/\r\n  function initializeExchange(\r\n    uint256 IDOLAmount,\r\n    uint256 settlementTokenAmount,\r\n    uint256 initialShare\r\n  ) external {\r\n    _init(uint128(IDOLAmount), uint128(settlementTokenAmount), initialShare);\r\n  }\r\n\r\n  /**\r\n   * @param timeout Revert if nextBoxNumber exceeds `timeout`\r\n   * @param recipient Recipient of swapped token. If `recipient` == address(0), recipient is msg.sender\r\n   * @param IDOLAmount Amount of token that should be approved before executing this function\r\n   * @param isLimit Whether the order restricts a large slippage\r\n   * @dev if isLimit is true and reserve0/reserve1 * 1.001 >  `rate`, the order will be executed, otherwise token will be refunded\r\n   * @dev if isLimit is false and reserve0/reserve1 * 1.05 > `rate`, the order will be executed, otherwise token will be refunded\r\n   **/\r\n  function orderBaseToSettlement(\r\n    uint256 timeout,\r\n    address recipient,\r\n    uint256 IDOLAmount,\r\n    bool isLimit\r\n  ) external isAmountSafe(IDOLAmount) isInTime(timeout) {\r\n    OrderType orderType = _getTokenType(true, isLimit);\r\n    _addOrder(orderType, IDOLAmount, recipient);\r\n  }\r\n\r\n  /**\r\n   * @param timeout Revert if nextBoxNumber exceeds `timeout`\r\n   * @param recipient Recipient of swapped token. If `recipient` == address(0), recipient is msg.sender\r\n   * @param settlementTokenAmount Amount of token that should be approved before executing this function\r\n   * @param isLimit Whether the order restricts a large slippage\r\n   * @dev if isLimit is true and reserve0/reserve1 * 0.999 > `rate`, the order will be executed, otherwise token will be refunded\r\n   * @dev if isLimit is false and reserve0/reserve1 * 0.95 > `rate`, the order will be executed, otherwise token will be refunded\r\n   **/\r\n  function orderSettlementToBase(\r\n    uint256 timeout,\r\n    address recipient,\r\n    uint256 settlementTokenAmount,\r\n    bool isLimit\r\n  ) external isAmountSafe(settlementTokenAmount) isInTime(timeout) {\r\n    OrderType orderType = _getTokenType(false, isLimit);\r\n    _addOrder(orderType, settlementTokenAmount, recipient);\r\n  }\r\n\r\n  /**\r\n   * @notice LP provides liquidity and receives share token\r\n   * @param timeout Revert if nextBoxNumber exceeds `timeout`\r\n   * @param IDOLAmount Amount of iDOL to be provided. The amount of the other token required is calculated based on this amount\r\n   * @param minShares Minimum amount of share token LP will receive. If amount of share token is less than `minShares`, revert the transaction\r\n   **/\r\n  function addLiquidity(\r\n    uint256 timeout,\r\n    uint256 IDOLAmount,\r\n    uint256 settlementTokenAmount,\r\n    uint256 minShares\r\n  )\r\n    external\r\n    isAmountSafe(IDOLAmount)\r\n    isAmountSafe(settlementTokenAmount)\r\n    isInTime(timeout)\r\n  {\r\n    require(timeout > _currentOpenBoxId(), \"Time out\");\r\n    (uint256 _reserve0, uint256 _reserve1) = _getReserves(); // gas savings\r\n    uint256 settlementAmountInBase = settlementTokenAmount.mul(_reserve0).div(\r\n      _reserve1\r\n    );\r\n    if (IDOLAmount <= settlementAmountInBase) {\r\n      _addLiquidity(_reserve0, _reserve1, IDOLAmount, minShares, Token.TOKEN0);\r\n    } else {\r\n      _addLiquidity(\r\n        _reserve0,\r\n        _reserve1,\r\n        settlementTokenAmount,\r\n        minShares,\r\n        Token.TOKEN1\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice LP burns share token and receives iDOL and the other token\r\n   * @param timeout Revert if nextBoxNumber exceeds `timeout`\r\n   * @param minBaseTokens Minimum amount of iDOL LP will receive. If amount of iDOL is less than `minBaseTokens`, revert the transaction\r\n   * @param minSettlementTokens Minimum amount of the other token LP will get. If amount is less than `minSettlementTokens`, revert the transaction\r\n   * @param sharesBurned Amount of share token to be burned\r\n   **/\r\n  function removeLiquidity(\r\n    uint256 timeout,\r\n    uint256 minBaseTokens,\r\n    uint256 minSettlementTokens,\r\n    uint256 sharesBurned\r\n  ) external isInTime(timeout) {\r\n    require(timeout > _currentOpenBoxId(), \"Time out\");\r\n    _removeLiquidity(minBaseTokens, minSettlementTokens, sharesBurned);\r\n  }\r\n\r\n  /**\r\n   * @notice Executes orders that are unexecuted\r\n   * @param maxOrderNum Max number of orders to be executed\r\n   **/\r\n  function executeUnexecutedBox(uint8 maxOrderNum) external {\r\n    _triggerExecuteOrders(maxOrderNum);\r\n  }\r\n\r\n  /**\r\n   * @notice Sends market fee to Lien Token\r\n   **/\r\n  function sendMarketFeeToLien() external {\r\n    _triggerPayMarketFee();\r\n  }\r\n\r\n  // definition of abstract functions\r\n\r\n  function _receiveTokens(\r\n    Token tokenType,\r\n    address from,\r\n    uint256 amount\r\n  ) internal override {\r\n    _IERC20(tokenType).safeTransferFrom(from, address(this), amount);\r\n  }\r\n\r\n  function _sendTokens(\r\n    Token tokenType,\r\n    address to,\r\n    uint256 amount\r\n  ) internal override {\r\n    if (amount > 0) {\r\n      _IERC20(tokenType).safeTransfer(to, amount);\r\n    }\r\n  }\r\n\r\n  function _payForOrderExecution(\r\n    Token tokenType,\r\n    address to,\r\n    uint256 amount\r\n  ) internal override {\r\n    if (amount > 0) {\r\n      _IERC20(tokenType).safeTransfer(to, amount);\r\n    }\r\n  }\r\n\r\n  function _isCurrentOpenBoxExpired() internal override view returns (bool) {\r\n    return block.number >= orderBoxes[_currentOpenBoxId()].expireAt;\r\n  }\r\n\r\n  function _openNewBox() internal override(BoxExchange) {\r\n    super._openNewBox();\r\n    uint256 _boxNumber = _currentOpenBoxId();\r\n    emit SpreadRate(_boxNumber.toUint128(), orderBoxes[_boxNumber].spreadRate);\r\n  }\r\n\r\n  function _IERC20(Token tokenType) internal view returns (ERC20Interface) {\r\n    if (tokenType == Token.TOKEN0) {\r\n      return idol;\r\n    }\r\n    return token;\r\n  }\r\n}\r\n\r\n// File: contracts/BoxExchange/TokenBoxExchange/IDOLvsERC20/ERC20BoxExchange.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\ncontract ERC20BoxExchange is TokenBoxExchange {\r\n    /**\r\n     * @param _idol iDOL contract\r\n     * @param _token ERC20 contract\r\n     * @param _priceCalc Price Calculator contract\r\n     * @param _marketFeeTaker Address of market fee taker (i.e. Lien Token)\r\n     * @param _spreadCalc Spread Calculator contract\r\n     * @param _oracle Oracle contract\r\n     * @param _name Name of share token\r\n     **/\r\n    constructor(\r\n        ERC20Interface _idol,\r\n        ERC20Interface _token,\r\n        PriceCalculatorInterface _priceCalc,\r\n        address _marketFeeTaker,\r\n        SpreadCalculatorInterface _spreadCalc,\r\n        OracleInterface _oracle,\r\n        string memory _name\r\n    )\r\n        public\r\n        TokenBoxExchange(\r\n            _idol,\r\n            _token,\r\n            _priceCalc,\r\n            _marketFeeTaker,\r\n            _spreadCalc,\r\n            _oracle,\r\n            _name\r\n        )\r\n    {}\r\n\r\n    // definition of abstract functions\r\n    function _feeRate() internal override returns (uint128) {\r\n        return spreadCalc.calculateSpreadByAssetVolatility(oracle);\r\n    }\r\n\r\n    function _payMarketFee(\r\n        address _marketFeeTaker,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal override {\r\n        if (amount0 != 0) {\r\n            idol.safeTransfer(_marketFeeTaker, amount0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Updates reserves and market fee pools\r\n     * @param spreadRate Spread rate in the box\r\n     * @param executingAmount0WithoutSpread Executed amount of TOKEN0 in this box\r\n     * @param executingAmount1WithoutSpread Executed amount of TOKEN1 in this box\r\n     * @param rate Rate of swap\r\n     **/\r\n    function _updateReservesAndMarketFeePoolByExecution(\r\n        uint256 spreadRate,\r\n        uint256 executingAmount0WithoutSpread,\r\n        uint256 executingAmount1WithoutSpread,\r\n        uint256 rate\r\n    ) internal virtual override {\r\n        uint256 newReserve0;\r\n        uint256 newReserve1;\r\n        uint256 newMarketFeePool0;\r\n        uint256 marketFee1;\r\n        {\r\n            (\r\n                uint256 differenceOfReserve,\r\n                uint256 differenceOfMarketFee\r\n            ) = _calculateNewReserveAndMarketFeePool(\r\n                spreadRate,\r\n                executingAmount0WithoutSpread,\r\n                executingAmount1WithoutSpread,\r\n                rate,\r\n                Token.TOKEN0\r\n            );\r\n            newReserve0 = reserve0 + differenceOfReserve;\r\n            newMarketFeePool0 = marketFeePool0 + differenceOfMarketFee;\r\n        }\r\n        {\r\n            (newReserve1, marketFee1) = _calculateNewReserveAndMarketFeePool(\r\n                spreadRate,\r\n                executingAmount1WithoutSpread,\r\n                executingAmount0WithoutSpread,\r\n                rate,\r\n                Token.TOKEN1\r\n            );\r\n            newReserve1 = newReserve1 + reserve1;\r\n        }\r\n\r\n        {\r\n            uint256 convertedSpread1to0 = marketFee1\r\n                .mulByRate(newReserve0.divByRate(newReserve1.add(marketFee1)))\r\n                .divByRate(RateMath.RATE_POINT_MULTIPLIER);\r\n            newReserve1 = newReserve1 + marketFee1;\r\n            newReserve0 = newReserve0 - convertedSpread1to0;\r\n            newMarketFeePool0 = newMarketFeePool0 + convertedSpread1to0;\r\n        }\r\n        _updateReserve(newReserve0.toUint128(), newReserve1.toUint128());\r\n        _updateMarketFeePool(newMarketFeePool0.toUint128());\r\n    }\r\n\r\n    /**\r\n     * updates only pool0\r\n     */\r\n    function _updateMarketFeePool(uint256 newMarketFeePool0) internal {\r\n        marketFeePool0 = newMarketFeePool0.toUint128();\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Arrays.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to array types.\r\n */\r\nlibrary Arrays {\r\n   /**\r\n     * @dev Searches a sorted `array` and returns the first index that contains\r\n     * a value greater or equal to `element`. If no such index exists (i.e. all\r\n     * values in the array are strictly less than `element`), the array length is\r\n     * returned. Time complexity O(log n).\r\n     *\r\n     * `array` is expected to be sorted in ascending order, and to contain no\r\n     * repeated elements.\r\n     */\r\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\n        if (array.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 low = 0;\r\n        uint256 high = array.length;\r\n\r\n        while (low < high) {\r\n            uint256 mid = Math.average(low, high);\r\n\r\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\r\n            // because Math.average rounds down (it does integer division with truncation).\r\n            if (array[mid] > element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\r\n        if (low > 0 && array[low - 1] == element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\r\n * total supply at the time are recorded for later access.\r\n *\r\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\r\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\r\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\r\n * used to create an efficient ERC20 forking mechanism.\r\n *\r\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\r\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\r\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\r\n * and the account address.\r\n *\r\n * ==== Gas Costs\r\n *\r\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\r\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\r\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\r\n *\r\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\r\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\r\n * transfers will have normal cost until the next snapshot, and so on.\r\n */\r\nabstract contract ERC20Snapshot is ERC20 {\r\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\r\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\r\n\r\n    using SafeMath for uint256;\r\n    using Arrays for uint256[];\r\n    using Counters for Counters.Counter;\r\n\r\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\r\n    // Snapshot struct, but that would impede usage of functions that work on an array.\r\n    struct Snapshots {\r\n        uint256[] ids;\r\n        uint256[] values;\r\n    }\r\n\r\n    mapping (address => Snapshots) private _accountBalanceSnapshots;\r\n    Snapshots private _totalSupplySnapshots;\r\n\r\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\r\n    Counters.Counter private _currentSnapshotId;\r\n\r\n    /**\r\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\r\n     */\r\n    event Snapshot(uint256 id);\r\n\r\n    /**\r\n     * @dev Creates a new snapshot and returns its snapshot id.\r\n     *\r\n     * Emits a {Snapshot} event that contains the same id.\r\n     *\r\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\r\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\r\n     * you must consider that it can potentially be used by attackers in two ways.\r\n     *\r\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\r\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\r\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\r\n     * section above.\r\n     *\r\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\r\n     * ====\r\n     */\r\n    function _snapshot() internal virtual returns (uint256) {\r\n        _currentSnapshotId.increment();\r\n\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        emit Snapshot(currentId);\r\n        return currentId;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\r\n     */\r\n    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\r\n\r\n        return snapshotted ? value : balanceOf(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\r\n     */\r\n    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\r\n\r\n        return snapshotted ? value : totalSupply();\r\n    }\r\n\r\n    // _transfer, _mint and _burn are the only functions where the balances are modified, so it is there that the\r\n    // snapshots are updated. Note that the update happens _before_ the balance change, with the pre-modified value.\r\n    // The same is true for the total supply and _mint and _burn.\r\n    function _transfer(address from, address to, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(from);\r\n        _updateAccountSnapshot(to);\r\n\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._mint(account, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal virtual override {\r\n        _updateAccountSnapshot(account);\r\n        _updateTotalSupplySnapshot();\r\n\r\n        super._burn(account, value);\r\n    }\r\n\r\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\r\n        private view returns (bool, uint256)\r\n    {\r\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(snapshotId <= _currentSnapshotId.current(), \"ERC20Snapshot: nonexistent id\");\r\n\r\n        // When a valid snapshot is queried, there are three possibilities:\r\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\r\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\r\n        //  to this id is the current one.\r\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\r\n        //  requested id, and its value is the one to return.\r\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\r\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\r\n        //  larger than the requested one.\r\n        //\r\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\r\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\r\n        // exactly this.\r\n\r\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\r\n\r\n        if (index == snapshots.ids.length) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, snapshots.values[index]);\r\n        }\r\n    }\r\n\r\n    function _updateAccountSnapshot(address account) private {\r\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\r\n    }\r\n\r\n    function _updateTotalSupplySnapshot() private {\r\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\r\n    }\r\n\r\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\r\n        uint256 currentId = _currentSnapshotId.current();\r\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\r\n            snapshots.ids.push(currentId);\r\n            snapshots.values.push(currentValue);\r\n        }\r\n    }\r\n\r\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\r\n        if (ids.length == 0) {\r\n            return 0;\r\n        } else {\r\n            return ids[ids.length - 1];\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Interfaces/LienTokenInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\ninterface LienTokenInterface is IERC20 {\r\n    function currentTerm() external view returns (uint256);\r\n\r\n    function expiration() external view returns (uint256);\r\n\r\n    function receiveDividend(address token, address recipient) external;\r\n\r\n    function dividendAt(\r\n        address token,\r\n        address account,\r\n        uint256 term\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/BoxExchange/TokenBoxExchange/IDOLvsERC20/IDOLvsLien/ERC20Redistribution.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract ERC20Redistribution is ERC20Snapshot {\r\n    using SafeERC20 for ERC20Interface;\r\n\r\n    struct Dividend {\r\n        mapping(ERC20Interface => uint256) tokens;\r\n        uint256 eth;\r\n    }\r\n\r\n    LienTokenInterface public lien;\r\n    mapping(uint256 => uint256) private snapshotsOfTermEnd;\r\n    mapping(uint256 => Dividend) private totalDividendsAt;\r\n    mapping(address => mapping(ERC20Interface => uint256))\r\n        private lastReceivedTermsOfTokens;\r\n    mapping(address => uint256) private lastReceivedTermsOfEth;\r\n\r\n    event ReceiveDividendETH(address indexed recipient, uint256 amount);\r\n    event ReceiveDividendToken(\r\n        address indexed recipient,\r\n        address indexed tokenAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    modifier termValidation(uint256 _term) {\r\n        require(_term > 0, \"0 is invalid value as term\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    constructor(LienTokenInterface _lien) public {\r\n        lien = _lien;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ERC20 token dividend to Liquidity Provider\r\n     * @notice Before transfer dividend, this exchange withdraws dividend in this ERC20 token from Lien Token\r\n     * @param token Target ERC20 token to be received\r\n     */\r\n    function receiveDividendToken(ERC20Interface token) public {\r\n        uint256 _currentTerm = currentTerm();\r\n        if (_currentTerm == 1) {\r\n            return;\r\n        }\r\n        _moveDividendTokenFromLIEN(token, _currentTerm);\r\n        uint256 lastReceivedTerm = lastReceivedTermsOfTokens[msg.sender][token];\r\n        lastReceivedTermsOfTokens[msg.sender][token] = _currentTerm - 1;\r\n        uint256 dividend;\r\n        for (uint256 term = lastReceivedTerm + 1; term < _currentTerm; term++) {\r\n            dividend += dividendTokenAt(msg.sender, token, term);\r\n        }\r\n        emit ReceiveDividendToken(msg.sender, address(token), dividend);\r\n        token.safeTransfer(msg.sender, dividend);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ETH dividend to Liquidity Provider\r\n     * @notice Before transfer dividend, this exchange withdraws dividend in ETH from Lien Token\r\n     */\r\n    function receiveDividendEth() public {\r\n        uint256 _currentTerm = currentTerm();\r\n        if (_currentTerm == 1) {\r\n            return;\r\n        }\r\n        _moveDividendEthFromLIEN(_currentTerm);\r\n        uint256 lastReceivedTerm = lastReceivedTermsOfEth[msg.sender];\r\n        lastReceivedTermsOfEth[msg.sender] = _currentTerm - 1;\r\n        uint256 dividend;\r\n        for (uint256 term = lastReceivedTerm + 1; term < _currentTerm; term++) {\r\n            dividend += dividendEthAt(msg.sender, term);\r\n        }\r\n        emit ReceiveDividendETH(msg.sender, dividend);\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = msg.sender.call{value: dividend}(\"\");\r\n        require(success, \"ETH transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets current term in Lien Token\r\n     **/\r\n    function currentTerm() public view returns (uint256) {\r\n        return lien.currentTerm();\r\n    }\r\n\r\n    /**\r\n     * @notice Gets amount of ERC20 token dividend LP can get in the `term`\r\n     * @param account Target account\r\n     * @param token Target ERC20 token\r\n     * @param term Target term\r\n     **/\r\n    function dividendTokenAt(\r\n        address account,\r\n        ERC20Interface token,\r\n        uint256 term\r\n    ) public view returns (uint256) {\r\n        uint256 balanceAtTermEnd = balanceOfAtTermEnd(account, term);\r\n        uint256 totalSupplyAtTermEnd = totalSupplyAtTermEnd(term);\r\n        uint256 totalDividend = totalDividendTokenAt(token, term);\r\n        return totalDividend.mul(balanceAtTermEnd).div(totalSupplyAtTermEnd);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets Amount of ETH dividend LP can get in the `term`\r\n     * @param account Target account\r\n     * @param term Target term\r\n     **/\r\n    function dividendEthAt(address account, uint256 term)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 balanceAtTermEnd = balanceOfAtTermEnd(account, term);\r\n        uint256 totalSupplyAtTermEnd = totalSupplyAtTermEnd(term);\r\n        uint256 totalDividend = totalDividendEthAt(term);\r\n        return totalDividend.mul(balanceAtTermEnd).div(totalSupplyAtTermEnd);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets total amount of ERC20 token dividend this exchange received in the `term`\r\n     * @param token Target ERC20 token\r\n     * @param term Target term\r\n     **/\r\n    function totalDividendTokenAt(ERC20Interface token, uint256 term)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalDividendsAt[term].tokens[token];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets total amount of ETH dividend this exchange received in the `term`\r\n     * @param term Target term\r\n     **/\r\n    function totalDividendEthAt(uint256 term) public view returns (uint256) {\r\n        return totalDividendsAt[term].eth;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the balance of `account` at the end of the term `term`\r\n     * @param account Target account\r\n     * @param term Target term\r\n     */\r\n    function balanceOfAtTermEnd(address account, uint256 term)\r\n        public\r\n        view\r\n        termValidation(term)\r\n        returns (uint256)\r\n    {\r\n        uint256 _currentTerm = currentTerm();\r\n        for (uint256 i = term; i < _currentTerm; i++) {\r\n            if (_isSnapshottedOnTermEnd(i)) {\r\n                return balanceOfAt(account, snapshotsOfTermEnd[i]);\r\n            }\r\n        }\r\n        return balanceOf(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the total supply at the end of the term `term`\r\n     * @param term Target term\r\n     */\r\n    function totalSupplyAtTermEnd(uint256 term)\r\n        public\r\n        view\r\n        termValidation(term)\r\n        returns (uint256)\r\n    {\r\n        uint256 _currentTerm = currentTerm();\r\n        for (uint256 i = term; i < _currentTerm; i++) {\r\n            if (_isSnapshottedOnTermEnd(i)) {\r\n                return totalSupplyAt(snapshotsOfTermEnd[i]);\r\n            }\r\n        }\r\n        return totalSupply();\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual override {\r\n        _snapshotOnTermEnd();\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal virtual override {\r\n        _snapshotOnTermEnd();\r\n        super._mint(account, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal virtual override {\r\n        _snapshotOnTermEnd();\r\n        super._burn(account, value);\r\n    }\r\n\r\n    function _snapshotOnTermEnd() private {\r\n        uint256 _currentTerm = currentTerm();\r\n        if (_currentTerm > 1 && !_isSnapshottedOnTermEnd(_currentTerm - 1)) {\r\n            snapshotsOfTermEnd[_currentTerm - 1] = _snapshot();\r\n        }\r\n    }\r\n\r\n    function _isSnapshottedOnTermEnd(uint256 term) private view returns (bool) {\r\n        return snapshotsOfTermEnd[term] != 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws dividends in ETH and iDOL from Lien Token\r\n     * @dev At first, this function registers amount of dividends from Lien Token, and thereafter withdraws it\r\n     **/\r\n    function _moveDividendTokenFromLIEN(\r\n        ERC20Interface token,\r\n        uint256 _currentTerm\r\n    ) private {\r\n        uint256 expiration = lien.expiration();\r\n        uint256 start;\r\n        uint256 totalNewDividend;\r\n        if (_currentTerm > expiration) {\r\n            start = _currentTerm - expiration;\r\n        } else {\r\n            start = 1;\r\n        }\r\n        //get and register dividend amount in the exchange from Lien Token contract\r\n        for (uint256 i = _currentTerm - 1; i >= start; i--) {\r\n            if (totalDividendsAt[i].tokens[token] != 0) {\r\n                break;\r\n            }\r\n            uint256 dividend = lien.dividendAt(\r\n                address(token),\r\n                address(this),\r\n                i\r\n            );\r\n            totalDividendsAt[i].tokens[token] = dividend;\r\n            totalNewDividend += dividend;\r\n        }\r\n        if (totalNewDividend == 0) {\r\n            return;\r\n        }\r\n        lien.receiveDividend(address(token), address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws dividends in ETH and iDOL from lienToken\r\n     * @dev At first, this function registers amount of dividend from Lien Token, and thereafter withdraws it\r\n     **/\r\n    function _moveDividendEthFromLIEN(uint256 _currentTerm) private {\r\n        uint256 expiration = lien.expiration();\r\n        uint256 start;\r\n        uint256 totalNewDividend;\r\n        if (_currentTerm > expiration) {\r\n            start = _currentTerm - expiration;\r\n        } else {\r\n            start = 1;\r\n        }\r\n        //get and register dividend amount in the exchange from Lien Token contract\r\n        for (uint256 i = _currentTerm - 1; i >= start; i--) {\r\n            if (totalDividendsAt[i].eth != 0) {\r\n                break;\r\n            }\r\n            uint256 dividend = lien.dividendAt(address(0), address(this), i);\r\n            totalDividendsAt[i].eth = dividend;\r\n            totalNewDividend += dividend;\r\n        }\r\n        if (totalNewDividend == 0) {\r\n            return;\r\n        }\r\n        lien.receiveDividend(address(0), address(this));\r\n    }\r\n}\r\n\r\n// File: contracts/BoxExchange/TokenBoxExchange/IDOLvsERC20/IDOLvsLien/LienBoxExchange.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\ncontract LienBoxExchange is ERC20BoxExchange, ERC20Redistribution {\r\n  /**\r\n   * @param _idol iDOL contract\r\n   * @param _priceCalc Price Calculator contract\r\n   * @param _lien Lien Token contract\r\n   * @param _spreadCalc Spread Calculator contract\r\n   * @param _name Name of share token\r\n   **/\r\n  constructor(\r\n    ERC20Interface _idol,\r\n    PriceCalculatorInterface _priceCalc,\r\n    LienTokenInterface _lien,\r\n    SpreadCalculatorInterface _spreadCalc,\r\n    string memory _name\r\n  )\r\n    public\r\n    ERC20Redistribution(_lien)\r\n    ERC20BoxExchange(\r\n      _idol,\r\n      ERC20Interface(address(_lien)),\r\n      _priceCalc,\r\n      address(_lien),\r\n      _spreadCalc,\r\n      OracleInterface(address(0)),\r\n      _name\r\n    )\r\n  {}\r\n\r\n  // overriding ERC20 functions\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal override(ERC20, ERC20Redistribution) {\r\n    ERC20Redistribution._transfer(from, to, value);\r\n  }\r\n\r\n  function _burn(address account, uint256 value)\r\n    internal\r\n    override(ERC20, ERC20Redistribution)\r\n  {\r\n    ERC20Redistribution._burn(account, value);\r\n  }\r\n\r\n  function _mint(address account, uint256 value)\r\n    internal\r\n    override(ERC20, ERC20Redistribution)\r\n  {\r\n    ERC20Redistribution._mint(account, value);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"_idol\",\"type\":\"address\"},{\"internalType\":\"contract PriceCalculatorInterface\",\"name\":\"_priceCalc\",\"type\":\"address\"},{\"internalType\":\"contract LienTokenInterface\",\"name\":\"_lien\",\"type\":\"address\"},{\"internalType\":\"contract SpreadCalculatorInterface\",\"name\":\"_spreadCalc\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"boxNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLimit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIn\",\"type\":\"uint256\"}],\"name\":\"AcceptOrders\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"boxNumber\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"boxNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"partiallyRefundOrderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"partiallyRefundRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInAmountFLEX_0_1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInAmountFLEX_1_0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInAmountSTRICT_0_1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInAmountSTRICT_1_0\",\"type\":\"uint256\"}],\"name\":\"ExecutionSummary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"movedToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"movedToken1Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesMoved\",\"type\":\"uint256\"}],\"name\":\"MoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"PayMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceiveDividendETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceiveDividendToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Snapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"boxNumber\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"spreadRate\",\"type\":\"uint128\"}],\"name\":\"SpreadRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"reserve0\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"reserve1\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShare\",\"type\":\"uint256\"}],\"name\":\"UpdateReserve\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IDOLAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settlementTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"balanceOfAtTermEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTerm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"dividendEthAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"dividendTokenAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maxOrderNum\",\"type\":\"uint8\"}],\"name\":\"executeUnexecutedBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boxNumber\",\"type\":\"uint256\"}],\"name\":\"getBoxSummary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"executionStatusNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flexToken0InAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strictToken0InAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flexToken1InAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strictToken1InAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangeData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"boxNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestSpreadRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0PerShareE18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1PerShareE18\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"}],\"name\":\"getOrderAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idol\",\"outputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"IDOLAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settlementTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialShare\",\"type\":\"uint256\"}],\"name\":\"initializeExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lien\",\"outputs\":[{\"internalType\":\"contract LienTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketFeePool0\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketFeePool1\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"IDOLAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLimit\",\"type\":\"bool\"}],\"name\":\"orderBaseToSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"settlementTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLimit\",\"type\":\"bool\"}],\"name\":\"orderSettlementToBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveDividendEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"receiveDividendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSettlementTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesBurned\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendMarketFeeToLien\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"totalDividendEthAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"totalDividendTokenAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAtTermEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isLimit\",\"type\":\"bool\"}],\"name\":\"whenToExecute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"boxCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LienBoxExchange","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000003627b04ee69a7d27eb73844e0244ec75f7087dac000000000000000000000000ab37e1358b639fd877f015027bb62d3ddaa7557e000000000000000000000000c05cb1999ab97a9ae5337fbdc4cb0e1458bc5cbf00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000f53484152452d555344432d4c49454e0000000000000000000000000000000000","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b4e4cb47cf233bd3a865673df19693c9a4238f8e503067d2f6c5183d69494e97"}]}