{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\nlibrary WadRayMath {\n  using SafeMath for uint256;\n\n  uint256 internal constant _WAD = 1e18;\n  uint256 internal constant _HALF_WAD = _WAD / 2;\n\n  uint256 internal constant _RAY = 1e27;\n  uint256 internal constant _HALF_RAY = _RAY / 2;\n\n  uint256 internal constant _WAD_RAY_RATIO = 1e9;\n\n  function ray() internal pure returns (uint256) {\n    return _RAY;\n  }\n\n  function wad() internal pure returns (uint256) {\n    return _WAD;\n  }\n\n  function halfRay() internal pure returns (uint256) {\n    return _HALF_RAY;\n  }\n\n  function halfWad() internal pure returns (uint256) {\n    return _HALF_WAD;\n  }\n\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return _HALF_WAD.add(a.mul(b)).div(_WAD);\n  }\n\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(_WAD)).div(b);\n  }\n\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return _HALF_RAY.add(a.mul(b)).div(_RAY);\n  }\n\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(_RAY)).div(b);\n  }\n\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = _WAD_RAY_RATIO / 2;\n\n    return halfRatio.add(a).div(_WAD_RAY_RATIO);\n  }\n\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    return a.mul(_WAD_RAY_RATIO);\n  }\n\n  /**\n   * @dev calculates x^n, in ray. The code uses the ModExp precompile\n   * @param x base\n   * @param n exponent\n   * @return z = x^n, in ray\n   */\n  function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : _RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = rayMul(x, x);\n\n      if (n % 2 != 0) {\n        z = rayMul(z, x);\n      }\n    }\n  }\n}\n\n// \ninterface IAccessController {\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function MANAGER_ROLE() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n}\n\n// \ninterface IConfigProvider {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 liquidationRatio;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n    uint256 liquidationBonus;\n    uint256 liquidationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 liquidationRatio,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee,\n    uint256 liquidationBonus,\n    uint256 liquidationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _liquidationRatio,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee,\n    uint256 _liquidationBonus,\n    uint256 _liquidationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;\n\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;\n\n  function setMinVotingPeriod(uint256 _minVotingPeriod) external;\n\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;\n\n  function setVotingQuorum(uint256 _votingQuorum) external;\n\n  function setProposalThreshold(uint256 _proposalThreshold) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function minVotingPeriod() external view returns (uint256);\n\n  function maxVotingPeriod() external view returns (uint256);\n\n  function votingQuorum() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationFee(address _collateralType) external view returns (uint256);\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \ninterface ISTABLEX is IERC20 {\n  function mint(address account, uint256 amount) external;\n\n  function burn(address account, uint256 amount) external;\n\n  function a() external view returns (IAddressProvider);\n}\n\n// \ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n// \ninterface IPriceFeed {\n  event OracleUpdated(address indexed asset, address oracle, address sender);\n  event EurOracleUpdated(address oracle, address sender);\n\n  function setAssetOracle(address _asset, address _oracle) external;\n\n  function setEurOracle(address _oracle) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\n\n  function eurOracle() external view returns (AggregatorV3Interface);\n\n  function getAssetPrice(address _asset) external view returns (uint256);\n\n  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);\n\n  function convertTo(address _asset, uint256 _amount) external view returns (uint256);\n}\n\n// \ninterface IRatesManager {\n  function a() external view returns (IAddressProvider);\n\n  //current annualized borrow rate\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate baseDebt at time T0\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //calculate a new cumulative rate\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) external view returns (uint256);\n}\n\n// \ninterface ILiquidationManager {\n  function a() external view returns (IAddressProvider);\n\n  function calculateHealthFactor(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\n    external\n    view\n    returns (uint256 discountedAmount);\n\n  function isHealthy(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (bool);\n}\n\n// \ninterface IVaultsDataProvider {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n\n  // Read\n  function a() external view returns (IAddressProvider);\n\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface IFeeDistributor {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n}\n\n// \ninterface IAddressProvider {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProvider _config) external;\n\n  function setVaultsCore(IVaultsCore _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProvider);\n\n  function core() external view returns (IVaultsCore);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManager);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n\n// \ninterface IConfigProviderV1 {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setLiquidationBonus(uint256 _bonus) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function liquidationBonus() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface ILiquidationManagerV1 {\n  function a() external view returns (IAddressProviderV1);\n\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\n\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (bool);\n}\n\n// \ninterface IVaultsCoreV1 {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawAll(uint256 _vaultId) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  //Refresh\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  //upgrade\n  function upgrade(address _newVaultsCore) external;\n\n  //Read only\n\n  function a() external view returns (IAddressProviderV1);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface IWETH {\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n}\n\n// \ninterface IGovernorAlpha {\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n\n        // Creator of the proposal\n        address proposer;\n\n        // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n\n        // the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n\n        // The ordered list of function signatures to be called\n        string[] signatures;\n\n        // The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp\n        uint256 startTime;\n\n        // The timestamp at which voting ends: votes must be cast prior to this timestamp\n        uint endTime;\n\n        // Current number of votes in favor of this proposal\n        uint256 forVotes;\n\n        // Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        // Flag marking whether the proposal has been executed\n        bool executed;\n\n        // Receipts of ballots for the entire set of voters\n        mapping (address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n\n        // Whether or not the voter supports the proposal\n        bool support;\n\n        // The number of votes the voter had, which were cast\n        uint votes;\n    }\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint256 id, address proposer, address[] targets, uint256[] values, string[] signatures, bytes[] calldatas, uint startTime, uint endTime, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    function propose(address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description, uint256 endTime) external returns (uint);\n\n    function queue(uint256 proposalId) external;\n\n    function execute(uint256 proposalId) external payable;\n\n    function cancel(uint256 proposalId) external;\n\n    function castVote(uint256 proposalId, bool support) external;\n\n    function getActions(uint256 proposalId) external view returns (address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas);\n\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n\n    function state(uint proposalId) external view returns (ProposalState);\n\n    function quorumVotes() external view returns (uint256);\n\n    function proposalThreshold() external view returns (uint256);\n}\n\n// \ninterface ITimelock {\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  function acceptAdmin() external;\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n}\n\n// \ninterface IVotingEscrow {\n  enum LockAction { CREATE_LOCK, INCREASE_LOCK_AMOUNT, INCREASE_LOCK_TIME }\n\n  struct LockedBalance {\n    uint256 amount;\n    uint256 end;\n  }\n\n  /** Shared Events */\n  event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\n  event Withdraw(address indexed provider, uint256 value, uint256 ts);\n  event Expired();\n\n  function createLock(uint256 _value, uint256 _unlockTime) external;\n\n  function increaseLockAmount(uint256 _value) external;\n\n  function increaseLockLength(uint256 _unlockTime) external;\n\n  function withdraw() external;\n\n  function expireContract() external;\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256);\n\n  function balanceOfAt(address _owner, uint256 _blockTime) external view returns (uint256);\n\n  function stakingToken() external view returns (IERC20);\n}\n\n// \ninterface IMIMO is IERC20 {\n\n  function burn(address account, uint256 amount) external;\n  \n  function mint(address account, uint256 amount) external;\n\n}\n\n// \ninterface ISupplyMiner {\n\n  function baseDebtChanged(address user, uint256 newBaseDebt) external;\n}\n\n// \ninterface IDebtNotifier {\n\n  function debtChanged(uint256 _vaultId) external;\n\n  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) external;\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n\tfunction collateralSupplyMinerMapping(address collateral) external view returns (ISupplyMiner);\n}\n\n// \ninterface IGovernanceAddressProvider {\n  function setParallelAddressProvider(IAddressProvider _parallel) external;\n\n  function setMIMO(IMIMO _mimo) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;\n\n  function setTimelock(ITimelock _timelock) external;\n\n  function setVotingEscrow(IVotingEscrow _votingEscrow) external;\n\n  function controller() external view returns (IAccessController);\n\n  function parallel() external view returns (IAddressProvider);\n\n  function mimo() external view returns (IMIMO);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function governorAlpha() external view returns (IGovernorAlpha);\n\n  function timelock() external view returns (ITimelock);\n\n  function votingEscrow() external view returns (IVotingEscrow);\n}\n\n// \ninterface IVaultsCore {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function depositETH() external payable;\n\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;\n\n  function depositETHByVaultId(uint256 _vaultId) external payable;\n\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) external;\n\n  function depositETHAndBorrow(uint256 _borrowAmount) external payable;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawETH(uint256 _vaultId, uint256 _amount) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;\n\n  function upgrade(address payable _newVaultsCore) external;\n\n  function acceptUpgrade(address payable _oldVaultsCore) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function WETH() external view returns (IWETH);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function state() external view returns (IVaultsCoreState);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface IAddressProviderV1 {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProviderV1 _config) external;\n\n  function setVaultsCore(IVaultsCoreV1 _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProviderV1);\n\n  function core() external view returns (IVaultsCoreV1);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManagerV1);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n\n// \ninterface IVaultsCoreState {\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  function syncState(IVaultsCoreState _stateAddress) external;\n\n  function syncStateFromV1(IVaultsCoreV1 _core) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n\n  function synced() external view returns (bool);\n}\n\n// \ncontract ConfigProvider is IConfigProvider {\n  IAddressProvider public override a;\n\n  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1\n  mapping(address => uint256) public override collateralIds;\n\n  uint256 public override numCollateralConfigs;\n  /// @notice The minimum duration of voting on a proposal, in seconds\n  uint256 public override minVotingPeriod = 3 days;\n  /// @notice The max duration of voting on a proposal, in seconds\n  uint256 public override maxVotingPeriod = 2 weeks;\n  /// @notice The percentage of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\n  uint256 public override votingQuorum = 1e16; // 1%\n  /// @notice The percentage of votes required in order for a voter to become a proposer\n  uint256 public override proposalThreshold = 2e14; // 0.02%\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n\n    a = _addresses;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /**\n    Creates or overwrites an existing config for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the debt ceiling for the collateral type\n    @param _liquidationRatio the minimum ratio to maintain to avoid liquidation\n    @param _minCollateralRatio the minimum ratio to maintain to borrow new money or withdraw collateral\n    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.\n    @param _originationFee an optional origination fee for newly created debt. Can be 0.\n    @param _liquidationBonus the liquidation bonus to be paid to liquidators.\n    @param _liquidationFee an optional fee for liquidation debt. Can be 0.\n  */\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _liquidationRatio,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee,\n    uint256 _liquidationBonus,\n    uint256 _liquidationFee\n  ) public override onlyManager {\n    require(address(_collateralType) != address(0));\n    require(_minCollateralRatio >= _liquidationRatio);\n    if (collateralIds[_collateralType] == 0) {\n      // Initialize new collateral\n      a.core().state().initializeRates(_collateralType);\n      CollateralConfig memory config = CollateralConfig({\n        collateralType: _collateralType,\n        debtLimit: _debtLimit,\n        liquidationRatio: _liquidationRatio,\n        minCollateralRatio: _minCollateralRatio,\n        borrowRate: _borrowRate,\n        originationFee: _originationFee,\n        liquidationBonus: _liquidationBonus,\n        liquidationFee: _liquidationFee\n      });\n\n      numCollateralConfigs++;\n      _collateralConfigs[numCollateralConfigs] = config;\n      collateralIds[_collateralType] = numCollateralConfigs;\n    } else {\n      // Update collateral config\n      a.core().state().refreshCollateral(_collateralType);\n      uint256 id = collateralIds[_collateralType];\n\n      _collateralConfigs[id].collateralType = _collateralType;\n      _collateralConfigs[id].debtLimit = _debtLimit;\n      _collateralConfigs[id].liquidationRatio = _liquidationRatio;\n      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;\n      _collateralConfigs[id].borrowRate = _borrowRate;\n      _collateralConfigs[id].originationFee = _originationFee;\n      _collateralConfigs[id].liquidationBonus = _liquidationBonus;\n      _collateralConfigs[id].liquidationFee = _liquidationFee;\n    }\n    emit CollateralUpdated(\n      _collateralType,\n      _debtLimit,\n      _liquidationRatio,\n      _minCollateralRatio,\n      _borrowRate,\n      _originationFee,\n      _liquidationBonus,\n      _liquidationFee\n    );\n  }\n\n  function _emitUpdateEvent(address _collateralType) internal {\n    emit CollateralUpdated(\n      _collateralType,\n      _collateralConfigs[collateralIds[_collateralType]].debtLimit,\n      _collateralConfigs[collateralIds[_collateralType]].liquidationRatio,\n      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,\n      _collateralConfigs[collateralIds[_collateralType]].borrowRate,\n      _collateralConfigs[collateralIds[_collateralType]].originationFee,\n      _collateralConfigs[collateralIds[_collateralType]].liquidationBonus,\n      _collateralConfigs[collateralIds[_collateralType]].liquidationFee\n    );\n  }\n\n  /**\n    Remove the config for a collateral type\n    @param _collateralType address of the collateral type\n  */\n  function removeCollateral(address _collateralType) public override onlyManager {\n    uint256 id = collateralIds[_collateralType];\n    require(id != 0, \"collateral does not exist\");\n\n    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward\n    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry\n    delete _collateralConfigs[numCollateralConfigs]; // delete last entry\n    delete collateralIds[_collateralType];\n\n    numCollateralConfigs--;\n\n    emit CollateralRemoved(_collateralType);\n  }\n\n  /**\n    Sets the debt limit for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the new debt limit\n  */\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the minimum liquidation ratio for a collateral type\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\n    @param _collateralType address of the collateral type\n    @param _liquidationRatio the new minimum collateralization ratio\n  */\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio)\n    public\n    override\n    onlyManager\n  {\n    require(_liquidationRatio <= _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio);\n    _collateralConfigs[collateralIds[_collateralType]].liquidationRatio = _liquidationRatio;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the minimum ratio for a collateral type for new borrowing or collateral withdrawal\n    @param _collateralType address of the collateral type\n    @param _minCollateralRatio the new minimum open ratio\n  */\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)\n    public\n    override\n    onlyManager\n  {\n    require(_minCollateralRatio >= _collateralConfigs[collateralIds[_collateralType]].liquidationRatio);\n    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n    @param _borrowRate the new borrowing rate for a 1 sec interval\n  */\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {\n    a.core().state().refreshCollateral(_collateralType);\n    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _originationFee new origination fee in WAD\n  */\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the liquidation bonus for a collateral type\n    @dev the liquidation bonus is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _liquidationBonus the liquidation bonus to be paid to liquidators.\n  */\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus)\n    public\n    override\n    onlyManager\n  {\n    _collateralConfigs[collateralIds[_collateralType]].liquidationBonus = _liquidationBonus;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the liquidation fee for a collateral type\n    @dev this rate is applied as a fee for liquidation and is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _liquidationFee new liquidation fee in WAD\n  */\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) public override onlyManager {\n    require(_liquidationFee < 1e18); // fee < 100%\n    _collateralConfigs[collateralIds[_collateralType]].liquidationFee = _liquidationFee;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Set the min voting period for a gov proposal.\n    @param _minVotingPeriod the min voting period for a gov proposal\n  */\n  function setMinVotingPeriod(uint256 _minVotingPeriod) public override onlyManager {\n    minVotingPeriod = _minVotingPeriod;\n  }\n\n  /**\n    Set the max voting period for a gov proposal.\n    @param _maxVotingPeriod the max voting period for a gov proposal\n  */\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) public override onlyManager {\n    maxVotingPeriod = _maxVotingPeriod;\n  }\n\n  /**\n    Set the voting quora for a gov proposal.\n    @param _votingQuorum the voting quora for a gov proposal\n  */\n  function setVotingQuorum(uint256 _votingQuorum) public override onlyManager {\n    require(_votingQuorum < 1e18);\n    votingQuorum = _votingQuorum;\n  }\n\n  /**\n    Set the proposal threshold for a gov proposal.\n    @param _proposalThreshold the proposal threshold for a gov proposal\n  */\n  function setProposalThreshold(uint256 _proposalThreshold) public override onlyManager {\n    require(_proposalThreshold < 1e18);\n    proposalThreshold = _proposalThreshold;\n  }\n\n  /**\n    Get the debt limit for a collateral type\n    @dev this is a platform wide limit for new debt issuance against a specific collateral type\n    @param _collateralType address of the collateral type\n  */\n  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;\n  }\n\n  /**\n    Get the liquidation ratio that needs to be maintained for a collateral type to avoid liquidation.\n    @param _collateralType address of the collateral type\n  */\n  function collateralLiquidationRatio(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationRatio;\n  }\n\n  /**\n    Get the minimum collateralization ratio for a collateral type for new borrowing or collateral withdrawal.\n    @param _collateralType address of the collateral type\n  */\n  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;\n  }\n\n  /**\n    Get the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n  */\n  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;\n  }\n\n  /**\n    Get the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].originationFee;\n  }\n\n  /**\n    Get the liquidation bonus for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralLiquidationBonus(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationBonus;\n  }\n\n  /**\n    Get the liquidation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralLiquidationFee(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationFee;\n  }\n\n  /**\n    Retreives the entire config for a specific config id.\n    @param _id the ID of the conifg to be returned\n  */\n  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {\n    require(_id <= numCollateralConfigs, \"Invalid config id\");\n    return _collateralConfigs[_id];\n  }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"_addresses\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"CollateralRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minCollateralRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationFee\",\"type\":\"uint256\"}],\"name\":\"CollateralUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"a\",\"outputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"collateralConfigs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationFee\",\"type\":\"uint256\"}],\"internalType\":\"struct IConfigProvider.CollateralConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralDebtLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collateralIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralLiquidationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralLiquidationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralLiquidationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralMinCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralOriginationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxVotingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minVotingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numCollateralConfigs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"removeCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRate\",\"type\":\"uint256\"}],\"name\":\"setCollateralBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minCollateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationFee\",\"type\":\"uint256\"}],\"name\":\"setCollateralConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtLimit\",\"type\":\"uint256\"}],\"name\":\"setCollateralDebtLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationBonus\",\"type\":\"uint256\"}],\"name\":\"setCollateralLiquidationBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationFee\",\"type\":\"uint256\"}],\"name\":\"setCollateralLiquidationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationRatio\",\"type\":\"uint256\"}],\"name\":\"setCollateralLiquidationRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minCollateralRatio\",\"type\":\"uint256\"}],\"name\":\"setCollateralMinCollateralRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_originationFee\",\"type\":\"uint256\"}],\"name\":\"setCollateralOriginationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"setMaxVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"setMinVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalThreshold\",\"type\":\"uint256\"}],\"name\":\"setProposalThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_votingQuorum\",\"type\":\"uint256\"}],\"name\":\"setVotingQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConfigProvider","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006fae125de41c03fa7d917ccfa17ba54ef4feb014","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}