{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/common/Validating.sol\n\npragma solidity 0.5.12;\n\n\ninterface Validating {\n  modifier notZero(uint number) { require(number > 0, \"invalid 0 value\"); _; }\n  modifier notEmpty(string memory text) { require(bytes(text).length > 0, \"invalid empty string\"); _; }\n  modifier validAddress(address value) { require(value != address(0x0), \"invalid address\"); _; }\n}\n\n// File: contracts/common/HasOwners.sol\n\npragma solidity 0.5.12;\n\n\n\n/// @notice providing an ownership access control mechanism\ncontract HasOwners is Validating {\n\n  address[] public owners;\n  mapping(address => bool) public isOwner;\n\n  event OwnerAdded(address indexed owner);\n  event OwnerRemoved(address indexed owner);\n\n  /// @notice initializing the owners list (with at least one owner)\n  constructor(address[] memory owners_) public {\n    for (uint i = 0; i < owners_.length; i++) addOwner_(owners_[i]);\n  }\n\n  /// @notice requires the sender to be one of the contract owners\n  modifier onlyOwner { require(isOwner[msg.sender], \"invalid sender; must be owner\"); _; }\n\n  /// @notice list all accounts with an owner access\n  function getOwners() public view returns (address[] memory) { return owners; }\n\n  /// @notice authorize an `account` with owner access\n  function addOwner(address owner) external onlyOwner { addOwner_(owner); }\n\n  function addOwner_(address owner) private validAddress(owner) {\n    if (!isOwner[owner]) {\n      isOwner[owner] = true;\n      owners.push(owner);\n      emit OwnerAdded(owner);\n    }\n  }\n\n  /// @notice revoke an `account` owner access (while ensuring at least one owner remains)\n  function removeOwner(address owner) external onlyOwner {\n    require(isOwner[owner], 'only owners can be removed');\n    require(owners.length > 1, 'can not remove last owner');\n    isOwner[owner] = false;\n    for (uint i = 0; i < owners.length; i++) {\n      if (owners[i] == owner) {\n        owners[i] = owners[owners.length - 1];\n        owners.pop();\n        emit OwnerRemoved(owner);\n        break;\n      }\n    }\n  }\n\n}\n\n// File: contracts/common/Versioned.sol\n\npragma solidity 0.5.12;\n\n\ncontract Versioned {\n\n  string public version;\n\n  constructor(string memory version_) public { version = version_; }\n\n}\n\n// File: contracts/external/SafeMath.sol\n\npragma solidity 0.5.12;\n\n\n/**\n * @title Math provides arithmetic functions for uint type pairs.\n * You can safely `plus`, `minus`, `times`, and `divide` uint numbers without fear of integer overflow.\n * You can also find the `min` and `max` of two numbers.\n */\nlibrary SafeMath {\n\n  function min(uint x, uint y) internal pure returns (uint) { return x <= y ? x : y; }\n  function max(uint x, uint y) internal pure returns (uint) { return x >= y ? x : y; }\n\n\n  /** @dev adds two numbers, reverts on overflow */\n  function plus(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x, \"bad addition\"); }\n\n  /** @dev subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend) */\n  function minus(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x, \"bad subtraction\"); }\n\n\n  /** @dev multiplies two numbers, reverts on overflow */\n  function times(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x, \"bad multiplication\"); }\n\n  /** @dev divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero */\n  function mod(uint x, uint y) internal pure returns (uint z) {\n    require(y != 0, \"bad modulo; using 0 as divisor\");\n    z = x % y;\n  }\n\n  /** @dev Integer division of two numbers truncating the quotient, reverts on division by zero */\n  function div(uint a, uint b) internal pure returns (uint c) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n  }\n\n}\n\n// File: contracts/gluon/AppLogic.sol\n\npragma solidity 0.5.12;\n\n\n/**\n  * @notice representing an app's in-and-out transfers of assets\n  * @dev an account/asset based app should implement its own bookkeeping\n  */\ninterface AppLogic {\n\n  /// @notice when an app proposal has been activated, Gluon will call this method on the previously active app version\n  /// @dev each app must implement, providing a future upgrade path, and call retire_() at the very end.\n  /// this is the chance for the previously active app version to migrate to the new version\n  /// i.e.: migrating data, deprecate prior behavior, releasing resources, etc.\n  function upgrade() external;\n\n  /// @dev once an asset has been deposited into the app's safe within Gluon, the app is given the chance to do\n  /// it's own per account/asset bookkeeping\n  ///\n  /// @param account any Ethereum address\n  /// @param asset any ERC20 token or ETH (represented by address 0x0)\n  /// @param quantity quantity of asset\n  function credit(address account, address asset, uint quantity) external;\n\n  /// @dev before an asset can be withdrawn from the app's safe within Gluon, the quantity and asset to withdraw must be\n  /// derived from `parameters`. if the app is account/asset based, it should take this opportunity to:\n  /// - also derive the owning account from `parameters`\n  /// - prove that the owning account indeed has the derived quantity of the derived asset\n  /// - do it's own per account/asset bookkeeping\n  /// notice that the derived account is not necessarily the same as the provided account; a classic usage example is\n  /// an account transfers assets across app (in which case the provided account would be the target app)\n  ///\n  /// @param account any Ethereum address to which `quantity` of `asset` would be transferred to\n  /// @param parameters a bytes-marshalled record containing all data needed for the app-specific logic\n  /// @return asset any ERC20 token or ETH (represented by address 0x0)\n  /// @return quantity quantity of asset\n  function debit(address account, bytes calldata parameters) external returns (address asset, uint quantity);\n}\n\n// File: contracts/gluon/GluonView.sol\n\npragma solidity 0.5.12;\n\n\ninterface GluonView {\n  function app(uint32 id) external view returns (address current, address proposal, uint activationBlock);\n  function current(uint32 id) external view returns (address);\n  function history(uint32 id) external view returns (address[] memory);\n  function getBalance(uint32 id, address asset) external view returns (uint);\n  function isAnyLogic(uint32 id, address logic) external view returns (bool);\n  function isAppOwner(uint32 id, address appOwner) external view returns (bool);\n  function proposals(address logic) external view returns (bool);\n  function totalAppsCount() external view returns(uint32);\n}\n\n// File: contracts/gluon/GluonWallet.sol\n\npragma solidity 0.5.12;\n\n\ninterface GluonWallet {\n  function depositEther(uint32 id) external payable;\n  function depositToken(uint32 id, address token, uint quantity) external;\n  function withdraw(uint32 id, bytes calldata parameters) external;\n  function transfer(uint32 from, uint32 to, bytes calldata parameters) external;\n}\n\n// File: contracts/gluon/LegacyTokensExtension.sol\n\npragma solidity 0.5.12;\n\n\n\n\n\n\n\n\n/**\n  * @title the Gluon-Plasma Extension contract for supporting deposit and withdraw for legacy tokens\n  * - depositing an token into an app\n  * - withdrawing an token from an app\n  * - transferring an token across apps\n  */\ncontract LegacyTokensExtension is Versioned, GluonWallet, HasOwners {\n    using SafeMath for uint;\n\n    address[] public tokens;\n    mapping(address => bool) public isTokenAllowed;\n\n    mapping(uint32 => mapping(address => uint)) public balances;\n    mapping(address => uint) public tokenBalances;\n\n    GluonView public gluon;\n\n    event TokenAdded(address indexed token);\n    event TokenRemoved(address indexed token);\n\n    constructor(address _gluon, address[] memory tokens_, address[] memory owners, string memory version) Versioned(version) HasOwners(owners) public {\n        gluon = GluonView(_gluon);\n        for (uint i = 0; i < tokens_.length; i++) addToken_(tokens_[i]);\n    }\n\n    modifier provisioned(uint32 appId) {\n        require(gluon.history(appId).length > 0, \"App is not yet provisioned\");\n        _;\n    }\n\n    /**************************************************** GluonWallet ****************************************************/\n\n    /// @notice deposit ETH token on behalf of the sender into an app's safe\n    ///\n    /// @param appId index of the target app\n    function depositEther(uint32 appId) external payable provisioned(appId) {\n        require(false, \"prohibited operation; must use Gluon to deposit Ether\");\n    }\n\n    /// @notice deposit ERC20 token token (represented by address 0x0) on behalf of the sender into an app's safe\n    /// @dev an account must call token.approve(logic, quantity) beforehand\n    ///\n    /// @param appId index of the target app\n    /// @param token address of ERC20 token contract\n    /// @param quantity how much of token\n    function depositToken(uint32 appId, address token, uint quantity) external provisioned(appId) {\n        require(isTokenAllowed[token], \"use gluon contract\");\n        transferTokensToGluonSecurely(appId, LegacyToken(token), quantity);\n        AppLogic(current(appId)).credit(msg.sender, token, quantity);\n    }\n\n    function transferTokensToGluonSecurely(uint32 appId, LegacyToken token, uint quantity) private {\n        uint balanceBefore = token.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), quantity);\n        uint balanceAfter = token.balanceOf(address(this));\n        require(balanceAfter.minus(balanceBefore) == quantity, \"bad LegacyToken; transferFrom erroneously reported of successful transfer\");\n        balances[appId][address(token)] = balances[appId][address(token)].plus(quantity);\n        tokenBalances[address(token)] = tokenBalances[address(token)].plus(quantity);\n    }\n\n    /// @notice withdraw a quantity of token from an app's safe\n    /// @dev quantity & token should be derived by the app\n    ///\n    /// @param appId index of the target app\n    /// @param parameters a bytes-marshalled record containing at the very least quantity & token\n    function withdraw(uint32 appId, bytes calldata parameters) external provisioned(appId) {\n        (address token, uint quantity) = AppLogic(current(appId)).debit(msg.sender, parameters);\n        require(isTokenAllowed[token], \"use gluon contract\");\n        if (quantity > 0) {\n            require(balances[appId][token] >= quantity, \"not enough funds to transfer\");\n            balances[appId][token] = balances[appId][token].minus(quantity);\n            tokenBalances[token] = tokenBalances[token].minus(quantity);\n            transferTokensToAccountSecurely(LegacyToken(token), quantity, msg.sender);\n        }\n    }\n\n    function transferTokensToAccountSecurely(LegacyToken token, uint quantity, address to) private {\n        uint balanceBefore = token.balanceOf(to);\n        token.transfer(to, quantity);\n        uint balanceAfter = token.balanceOf(to);\n        require(balanceAfter.minus(balanceBefore) == quantity, \"transfer failed\");\n    }\n\n    /// @notice withdraw a quantity of token from a source app's safe and transfer it (within Gluon) to a target app's safe\n    /// @dev quantity & token should be derived by the source app\n    ///\n    /// @param from index of the source app\n    /// @param to index of the target app\n    /// @param parameters a bytes-marshalled record containing at the very least quantity & token\n    function transfer(uint32 from, uint32 to, bytes calldata parameters) external provisioned(from) provisioned(to) {\n        (address token, uint quantity) = AppLogic(current(from)).debit(msg.sender, parameters);\n        require(isTokenAllowed[token], \"use gluon contract\");\n        if (quantity > 0) {\n            if (from != to) {\n                require(balances[from][token] >= quantity, \"not enough balance in logic to transfer\");\n                balances[from][token] = balances[from][token].minus(quantity);\n                balances[to][token] = balances[to][token].plus(quantity);\n            }\n            AppLogic(current(to)).credit(msg.sender, token, quantity);\n        }\n    }\n\n    /**************************************************** GluonView  ****************************************************/\n\n    function current(uint32 appId) public view returns (address) {return gluon.current(appId);}\n\n    /// @notice what is the current balance of `token` in the `appId` app's safe?\n    function getBalance(uint32 appId, address token) external view returns (uint) {return balances[appId][token];}\n\n    /**************************************************** allowed tokens  ****************************************************/\n    /// @notice add a token\n    function addToken(address token) external onlyOwner {addToken_(token);}\n\n    function addToken_(address token) private validAddress(token) {\n        if (!isTokenAllowed[token]) {\n            isTokenAllowed[token] = true;\n            tokens.push(token);\n            emit TokenAdded(token);\n        }\n    }\n\n    /// @notice remove a token\n    function removeToken(address token) external onlyOwner {\n        require(isTokenAllowed[token], \"token does not exists\");\n        require(tokenBalances[token] == 0, \"token is in use\");\n        isTokenAllowed[token] = false;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (tokens[i] == token) {\n                tokens[i] = tokens[tokens.length - 1];\n                tokens.pop();\n                emit TokenRemoved(token);\n                break;\n            }\n        }\n    }\n\n    function getTokens() public view returns (address[] memory){return tokens;}\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract LegacyToken {\n    uint public _totalSupply;\n    function totalSupply() public view returns (uint);\n    function balanceOf(address who) public view returns (uint);\n    function transfer(address to, uint value) public;\n    event Transfer(address indexed from, address indexed to, uint value);\n    function allowance(address owner, address spender) public view returns (uint);\n    function transferFrom(address from, address to, uint value) public;\n    function approve(address spender, uint value) public;\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gluon\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"}],\"name\":\"current\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"}],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gluon\",\"outputs\":[{\"internalType\":\"contract GluonView\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTokenAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"from\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"to\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LegacyTokensExtension","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000075ace7a086ea0fb1a79e43cc6331ad053d8c67cb000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000000000030000000000000000000000004d2130d9d20428dc249a1e938a0bcea4b5b9ac1a000000000000000000000000ac01f01f51f0bdd012c1838bd5cef330e6c7ffca0000000000000000000000005ccaaae7bea14e8e04fb0fc7ed16df49d5678eb80000000000000000000000000000000000000000000000000000000000000005322e302e32000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}