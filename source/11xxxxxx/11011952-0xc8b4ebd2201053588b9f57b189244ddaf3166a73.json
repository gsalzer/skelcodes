{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/helpers/Owned.sol\r\n\r\npragma solidity >=0.4.0 <0.6.0;\r\n\r\ncontract Owned {\r\n  address payable public owner;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner, \"Sender not owner\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address payable newOwner) public onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Gems/Staking.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\ninterface IStakingErc20 {\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n  // This only applies to Cargo Credits \r\n  function increaseBalance(address user, uint balance) external;\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n}\r\n\r\ninterface IStakingCargoData {\r\n  function verifySigAndUuid(bytes32 hash, bytes calldata signature, bytes32 uuid) external;\r\n  function verifyContract(address contractAddress) external returns (bool);\r\n}\r\n\r\ninterface IStakingErc721 {\r\n  function ownerOf(uint256 tokenId) external view returns (address);\r\n  function supportsInterface(bytes4 interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\ncontract CargoGemsStaking is Owned {\r\n  using SafeMath for uint256;\r\n\r\n  event TotalStakeUpdated(uint totalStakedAmount);\r\n  event TokenStakeUpdated(\r\n    address indexed tokenContract, \r\n    uint256 indexed tokenId, \r\n    uint256 stakedAmount, \r\n    bool genesis\r\n  );\r\n  event Claim(\r\n    address indexed claimant, \r\n    address indexed tokenContractAddress, \r\n    uint256 indexed tokenId, \r\n    uint256 gemsReward, \r\n    uint256 creditsReward\r\n  );\r\n\r\n  IStakingCargoData cargoData;\r\n  IStakingErc20 cargoGems;\r\n  IStakingErc20 cargoCredits;\r\n\r\n  struct Stake {\r\n    uint amount;\r\n    uint lastBlockClaimed;\r\n    uint genesisBlock;\r\n    bool exists;\r\n  }\r\n\r\n  uint256 public totalStaked = 0;\r\n  mapping(string => bool) config;\r\n\r\n  // Token Contract Address => Token ID => Staked Amount\r\n  mapping(address => mapping(uint256 => Stake)) tokenStakes;\r\n  mapping(address => bool) public whiteList;\r\n  mapping(address => bool) public blackList;\r\n\r\n  constructor(address cargoDataAddress, address cargoGemsAddress, address cargoCreditsAddress) public {\r\n    cargoData = IStakingCargoData(cargoDataAddress);\r\n    cargoGems = IStakingErc20(cargoGemsAddress);\r\n    cargoCredits = IStakingErc20(cargoCreditsAddress);\r\n    config[\"enabled\"] = true;\r\n    config[\"onlyCargoContracts\"] = true;\r\n  }\r\n\r\n  modifier onlyEnabled() {\r\n    require(config[\"enabled\"] == true, \"Staking: Not enabled\"); \r\n    _;\r\n  }\r\n\r\n  modifier onlyExists(address contractAddress, uint tokenId) {\r\n    require(tokenStakes[contractAddress][tokenId].exists, \"Staking: Token ID at address not staked\");\r\n    _;\r\n  }\r\n\r\n  function updateBlacklist(address contractAddress, bool val) external onlyOwner {\r\n    blackList[contractAddress] = val;\r\n  }\r\n\r\n  function updateWhitelist(address contractAddress, bool val) external onlyOwner {\r\n    whiteList[contractAddress] = val;\r\n  }\r\n\r\n  function updateConfig(string calldata key, bool value) external onlyOwner {\r\n    config[key] = value;\r\n  }\r\n\r\n  function getStakedAmount(address contractAddress, uint tokenId) onlyExists(contractAddress, tokenId) external view returns (uint) {\r\n    return tokenStakes[contractAddress][tokenId].amount;\r\n  }\r\n\r\n  function getLastBlockClaimed(address contractAddress, uint tokenId) onlyExists(contractAddress, tokenId) external view returns (uint) {\r\n    return tokenStakes[contractAddress][tokenId].lastBlockClaimed;\r\n  }\r\n\r\n  function getStakeGenesis(address contractAddress, uint tokenId) onlyExists(contractAddress, tokenId) external view returns (uint) {\r\n    return tokenStakes[contractAddress][tokenId].genesisBlock;\r\n  }\r\n\r\n  /** @notice Function to claim rewards. Rewards are calculated off-chain by using on-chain data */\r\n  function claim(\r\n    address tokenContractAddress, \r\n    uint tokenId, \r\n    uint gemsReward,\r\n    uint creditsReward,\r\n    uint blockNumber,\r\n    uint amountToWithdraw,\r\n    bytes32 uuid,\r\n    bytes calldata signature\r\n  ) external onlyEnabled {\r\n    cargoData.verifySigAndUuid(keccak256(\r\n      abi.encodePacked(\r\n        \"CLAIM\",\r\n        tokenContractAddress,\r\n        tokenId,\r\n        gemsReward,\r\n        creditsReward,\r\n        amountToWithdraw,\r\n        blockNumber,\r\n        uuid\r\n      )\r\n    ), signature, uuid);\r\n\r\n    IStakingErc721 erc721 = IStakingErc721(tokenContractAddress);\r\n    require(erc721.ownerOf(tokenId) == msg.sender, \"Staking: Sender not owner\");\r\n    require(tokenStakes[tokenContractAddress][tokenId].lastBlockClaimed < blockNumber, \"Staking: block number invalid\");\r\n\r\n    tokenStakes[tokenContractAddress][tokenId].amount = tokenStakes[tokenContractAddress][tokenId].amount.add(gemsReward);\r\n    totalStaked = totalStaked.add(gemsReward);\r\n\r\n    if(amountToWithdraw > 0) {\r\n      require(amountToWithdraw <= tokenStakes[tokenContractAddress][tokenId].amount, \"Staking: Withdrawl amount must be lte staked amount\");\r\n\r\n      // transfer rewards to sender\r\n      cargoGems.transfer(msg.sender, amountToWithdraw);\r\n      \r\n      // Decrease staked amount\r\n      tokenStakes[tokenContractAddress][tokenId].amount = tokenStakes[tokenContractAddress][tokenId].amount.sub(amountToWithdraw);\r\n      totalStaked = totalStaked.sub(amountToWithdraw);\r\n    }\r\n\r\n    // Regardless of whether its a withdrawl the user will still be rewarded credits.\r\n    cargoCredits.increaseBalance(msg.sender, creditsReward);\r\n\r\n    // Save block number \r\n    tokenStakes[tokenContractAddress][tokenId].lastBlockClaimed = block.number;\r\n\r\n    emit Claim(msg.sender, tokenContractAddress, tokenId, gemsReward, creditsReward);\r\n    emit TotalStakeUpdated(totalStaked);\r\n    emit TokenStakeUpdated(\r\n      tokenContractAddress, \r\n      tokenId, \r\n      tokenStakes[tokenContractAddress][tokenId].amount, \r\n      !tokenStakes[tokenContractAddress][tokenId].exists\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice function to stake \r\n    @param tokenContractAddress Address of ERC721 contract\r\n    @param tokenId ID of token\r\n    @param amountToStake Amount of Cargo gems, must account for decimals when sending this\r\n   */\r\n  function stake(address tokenContractAddress, uint tokenId, uint amountToStake) external onlyEnabled {\r\n    require(amountToStake > 0, \"Staking: Amount must be gt 0\");\r\n    if(config[\"onlyCargoContracts\"]) {\r\n      require(cargoData.verifyContract(tokenContractAddress), \"Staking: Must be a cargo contract\");\r\n    }\r\n    IStakingErc721 erc721 = IStakingErc721(tokenContractAddress);\r\n    require(\r\n      (erc721.supportsInterface(0x80ac58cd) || whiteList[tokenContractAddress]) \r\n      && !blackList[tokenContractAddress], \r\n      \"Staking: 721 not supported\"\r\n    );\r\n    require(erc721.ownerOf(tokenId) == msg.sender, \"Staking: Sender not owner\");\r\n    // User must approve this contract to transfer the given amount\r\n    cargoGems.transferFrom(msg.sender, address(this), amountToStake);\r\n\r\n    // Increase token's staked amount\r\n    tokenStakes[tokenContractAddress][tokenId].amount = tokenStakes[tokenContractAddress][tokenId].amount.add(amountToStake);\r\n\r\n    // Increase the total staked amount\r\n    totalStaked = totalStaked.add(amountToStake);\r\n\r\n    emit TotalStakeUpdated(totalStaked);\r\n    emit TokenStakeUpdated(\r\n      tokenContractAddress, \r\n      tokenId, \r\n      tokenStakes[tokenContractAddress][tokenId].amount, \r\n      !tokenStakes[tokenContractAddress][tokenId].exists\r\n    );\r\n\r\n    if(!tokenStakes[tokenContractAddress][tokenId].exists) {\r\n      tokenStakes[tokenContractAddress][tokenId].genesisBlock = block.number;\r\n      tokenStakes[tokenContractAddress][tokenId].exists = true;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"amountToStake\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStakeGenesis\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStakedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"updateBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"gemsReward\",\"type\":\"uint256\"},{\"name\":\"creditsReward\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"name\":\"uuid\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"updateConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastBlockClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"cargoDataAddress\",\"type\":\"address\"},{\"name\":\"cargoGemsAddress\",\"type\":\"address\"},{\"name\":\"cargoCreditsAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"TotalStakeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genesis\",\"type\":\"bool\"}],\"name\":\"TokenStakeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gemsReward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creditsReward\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"}]","ContractName":"CargoGemsStaking","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"1300","ConstructorArguments":"00000000000000000000000075cc87648945714e32cdca19b7a68b81f2f7cdb300000000000000000000000030b1efb052205e6ca3c4888c3c50c5b339cc0602000000000000000000000000714a91578624d76a209e9aa4af9a1f55d78f9190","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6ca453d9bdb0848dc8fba50bbf04cebd8566b8fe98ba1415f2e85299801bd422"}]}