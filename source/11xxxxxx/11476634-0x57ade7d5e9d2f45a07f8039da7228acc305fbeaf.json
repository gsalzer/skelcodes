{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/AddressBook.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: UNLICENSED\\n */\\npragma solidity 0.6.10;\\n\\nimport {Ownable} from \\\"./packages/oz/Ownable.sol\\\";\\nimport {OwnedUpgradeabilityProxy} from \\\"./packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @author Opyn Team\\n * @title AddressBook Module\\n */\\ncontract AddressBook is Ownable {\\n    /// @dev Otoken implementation key\\n    bytes32 private constant OTOKEN_IMPL = keccak256(\\\"OTOKEN_IMPL\\\");\\n    /// @dev OtokenFactory key\\n    bytes32 private constant OTOKEN_FACTORY = keccak256(\\\"OTOKEN_FACTORY\\\");\\n    /// @dev Whitelist key\\n    bytes32 private constant WHITELIST = keccak256(\\\"WHITELIST\\\");\\n    /// @dev Controller key\\n    bytes32 private constant CONTROLLER = keccak256(\\\"CONTROLLER\\\");\\n    /// @dev MarginPool key\\n    bytes32 private constant MARGIN_POOL = keccak256(\\\"MARGIN_POOL\\\");\\n    /// @dev MarginCalculator key\\n    bytes32 private constant MARGIN_CALCULATOR = keccak256(\\\"MARGIN_CALCULATOR\\\");\\n    /// @dev LiquidationManager key\\n    bytes32 private constant LIQUIDATION_MANAGER = keccak256(\\\"LIQUIDATION_MANAGER\\\");\\n    /// @dev Oracle key\\n    bytes32 private constant ORACLE = keccak256(\\\"ORACLE\\\");\\n\\n    /// @dev mapping between key and address\\n    mapping(bytes32 => address) private addresses;\\n\\n    /// @notice emits an event when a new proxy is created\\n    event ProxyCreated(bytes32 indexed id, address indexed proxy);\\n    /// @notice emits an event when a new address is added\\n    event AddressAdded(bytes32 indexed id, address indexed add);\\n\\n    /**\\n     * @notice return Otoken implementation address\\n     * @return Otoken implementation address\\n     */\\n    function getOtokenImpl() external view returns (address) {\\n        return getAddress(OTOKEN_IMPL);\\n    }\\n\\n    /**\\n     * @notice return oTokenFactory address\\n     * @return OtokenFactory address\\n     */\\n    function getOtokenFactory() external view returns (address) {\\n        return getAddress(OTOKEN_FACTORY);\\n    }\\n\\n    /**\\n     * @notice return Whitelist address\\n     * @return Whitelist address\\n     */\\n    function getWhitelist() external view returns (address) {\\n        return getAddress(WHITELIST);\\n    }\\n\\n    /**\\n     * @notice return Controller address\\n     * @return Controller address\\n     */\\n    function getController() external view returns (address) {\\n        return getAddress(CONTROLLER);\\n    }\\n\\n    /**\\n     * @notice return MarginPool address\\n     * @return MarginPool address\\n     */\\n    function getMarginPool() external view returns (address) {\\n        return getAddress(MARGIN_POOL);\\n    }\\n\\n    /**\\n     * @notice return MarginCalculator address\\n     * @return MarginCalculator address\\n     */\\n    function getMarginCalculator() external view returns (address) {\\n        return getAddress(MARGIN_CALCULATOR);\\n    }\\n\\n    /**\\n     * @notice return LiquidationManager address\\n     * @return LiquidationManager address\\n     */\\n    function getLiquidationManager() external view returns (address) {\\n        return getAddress(LIQUIDATION_MANAGER);\\n    }\\n\\n    /**\\n     * @notice return Oracle address\\n     * @return Oracle address\\n     */\\n    function getOracle() external view returns (address) {\\n        return getAddress(ORACLE);\\n    }\\n\\n    /**\\n     * @notice set Otoken implementation address\\n     * @dev can only be called by the addressbook owner\\n     * @param _otokenImpl Otoken implementation address\\n     */\\n    function setOtokenImpl(address _otokenImpl) external onlyOwner {\\n        setAddress(OTOKEN_IMPL, _otokenImpl);\\n    }\\n\\n    /**\\n     * @notice set OtokenFactory address\\n     * @dev can only be called by the addressbook owner\\n     * @param _otokenFactory OtokenFactory address\\n     */\\n    function setOtokenFactory(address _otokenFactory) external onlyOwner {\\n        setAddress(OTOKEN_FACTORY, _otokenFactory);\\n    }\\n\\n    /**\\n     * @notice set Whitelist address\\n     * @dev can only be called by the addressbook owner\\n     * @param _whitelist Whitelist address\\n     */\\n    function setWhitelist(address _whitelist) external onlyOwner {\\n        setAddress(WHITELIST, _whitelist);\\n    }\\n\\n    /**\\n     * @notice set Controller address\\n     * @dev can only be called by the addressbook owner\\n     * @param _controller Controller address\\n     */\\n    function setController(address _controller) external onlyOwner {\\n        updateImpl(CONTROLLER, _controller);\\n    }\\n\\n    /**\\n     * @notice set MarginPool address\\n     * @dev can only be called by the addressbook owner\\n     * @param _marginPool MarginPool address\\n     */\\n    function setMarginPool(address _marginPool) external onlyOwner {\\n        setAddress(MARGIN_POOL, _marginPool);\\n    }\\n\\n    /**\\n     * @notice set MarginCalculator address\\n     * @dev can only be called by the addressbook owner\\n     * @param _marginCalculator MarginCalculator address\\n     */\\n    function setMarginCalculator(address _marginCalculator) external onlyOwner {\\n        setAddress(MARGIN_CALCULATOR, _marginCalculator);\\n    }\\n\\n    /**\\n     * @notice set LiquidationManager address\\n     * @dev can only be called by the addressbook owner\\n     * @param _liquidationManager LiquidationManager address\\n     */\\n    function setLiquidationManager(address _liquidationManager) external onlyOwner {\\n        setAddress(LIQUIDATION_MANAGER, _liquidationManager);\\n    }\\n\\n    /**\\n     * @notice set Oracle address\\n     * @dev can only be called by the addressbook owner\\n     * @param _oracle Oracle address\\n     */\\n    function setOracle(address _oracle) external onlyOwner {\\n        setAddress(ORACLE, _oracle);\\n    }\\n\\n    /**\\n     * @notice return an address for specific key\\n     * @param _key key address\\n     * @return address\\n     */\\n    function getAddress(bytes32 _key) public view returns (address) {\\n        return addresses[_key];\\n    }\\n\\n    /**\\n     * @notice set a specific address for a specific key\\n     * @dev can only be called by the addressbook owner\\n     * @param _key key\\n     * @param _address address\\n     */\\n    function setAddress(bytes32 _key, address _address) public onlyOwner {\\n        addresses[_key] = _address;\\n\\n        emit AddressAdded(_key, _address);\\n    }\\n\\n    /**\\n     * @dev function to update the implementation of a specific component of the protocol\\n     * @param _id id of the contract to be updated\\n     * @param _newAddress address of the new implementation\\n     **/\\n    function updateImpl(bytes32 _id, address _newAddress) public onlyOwner {\\n        address payable proxyAddress = address(uint160(getAddress(_id)));\\n\\n        if (proxyAddress == address(0)) {\\n            bytes memory params = abi.encodeWithSignature(\\\"initialize(address,address)\\\", address(this), owner());\\n            OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy();\\n            setAddress(_id, address(proxy));\\n            emit ProxyCreated(_id, address(proxy));\\n            proxy.upgradeToAndCall(_newAddress, params);\\n        } else {\\n            OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(proxyAddress);\\n            proxy.upgradeTo(_newAddress);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.10;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal virtual view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal virtual view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.10;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.10;\\n\\nimport \\\"./UpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title OwnedUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\\n */\\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\\n    /**\\n     * @dev Event to show ownership has been transferred\\n     * @param previousOwner representing the address of the previous owner\\n     * @param newOwner representing the address of the new owner\\n     */\\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\\n\\n    /// @dev Storage position of the owner of the contract\\n    bytes32 private constant proxyOwnerPosition = keccak256(\\\"org.zeppelinos.proxy.owner\\\");\\n\\n    /**\\n     * @dev the constructor sets the original owner of the contract to the sender account.\\n     */\\n    constructor() public {\\n        setUpgradeabilityOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyProxyOwner() {\\n        require(msg.sender == proxyOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Tells the address of the owner\\n     * @return owner the address of the owner\\n     */\\n    function proxyOwner() public view returns (address owner) {\\n        bytes32 position = proxyOwnerPosition;\\n        assembly {\\n            owner := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the address of the owner\\n     * @param _newProxyOwner address of new proxy owner\\n     */\\n    function setUpgradeabilityOwner(address _newProxyOwner) internal {\\n        bytes32 position = proxyOwnerPosition;\\n        assembly {\\n            sstore(position, _newProxyOwner)\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\\n        require(_newOwner != address(0));\\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\\n        setUpgradeabilityOwner(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Allows the proxy owner to upgrade the current version of the proxy.\\n     * @param _implementation representing the address of the new implementation to be set.\\n     */\\n    function upgradeTo(address _implementation) public onlyProxyOwner {\\n        _upgradeTo(_implementation);\\n    }\\n\\n    /**\\n     * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\\n     * to initialize whatever is needed through a low level call.\\n     * @param _implementation representing the address of the new implementation to be set.\\n     * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\\n     * signature of the implementation to be called with the needed payload\\n     */\\n    function upgradeToAndCall(address _implementation, bytes calldata _data) public payable onlyProxyOwner {\\n        upgradeTo(_implementation);\\n        (bool success, ) = address(this).call{value: msg.value}(_data);\\n        require(success);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/upgradeability/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.10;\\n\\n/**\\n * @title Proxy\\n * @dev Gives the possibility to delegate any call to a foreign implementation.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Tells the address of the implementation where every call will be delegated.\\n     * @return address of the implementation to which it will be delegated\\n     */\\n    function implementation() public virtual view returns (address);\\n\\n    /**\\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\\n     * This function will return whatever the implementation call returns\\n     */\\n    fallback() external payable {\\n        address _impl = implementation();\\n        require(_impl != address(0));\\n\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/upgradeability/UpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.10;\\n\\nimport \\\"./Proxy.sol\\\";\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n    /**\\n     * @dev This event will be emitted every time the implementation gets upgraded\\n     * @param implementation representing the address of the upgraded implementation\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /// @dev Storage position of the address of the current implementation\\n    bytes32 private constant implementationPosition = keccak256(\\\"org.zeppelinos.proxy.implementation\\\");\\n\\n    /**\\n     * @dev Tells the address of the current implementation\\n     * @return impl address of the current implementation\\n     */\\n    function implementation() public override view returns (address impl) {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            impl := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the address of the current implementation\\n     * @param _newImplementation address representing the new implementation to be set\\n     */\\n    function setImplementation(address _newImplementation) internal {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            sstore(position, _newImplementation)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the implementation address\\n     * @param _newImplementation representing the address of the new implementation to be set\\n     */\\n    function _upgradeTo(address _newImplementation) internal {\\n        address currentImplementation = implementation();\\n        require(currentImplementation != _newImplementation);\\n        setImplementation(_newImplementation);\\n        emit Upgraded(_newImplementation);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"AddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidationManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarginCalculator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarginPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOtokenFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOtokenImpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidationManager\",\"type\":\"address\"}],\"name\":\"setLiquidationManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marginCalculator\",\"type\":\"address\"}],\"name\":\"setMarginCalculator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marginPool\",\"type\":\"address\"}],\"name\":\"setMarginPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otokenFactory\",\"type\":\"address\"}],\"name\":\"setOtokenFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otokenImpl\",\"type\":\"address\"}],\"name\":\"setOtokenImpl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateImpl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AddressBook","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}