{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title Liquidity Mining Redeemer\r\n * @dev This Contract will redeem the Liquidity Mining Positions of the DFOs DFOhub, EthArt and UniFi.\r\n * Addresses who held tokens in one of there contracts will receive back the result of their Positions, including the reward until now, plus some gifts by the DFOhub DFO.\r\n * Anyome can redeem all their tokens in a unique operation.\r\n * For Gas Consumption purposes only in the initialization phase, this Contract will have an initializer who syncs the contract data after the deployment.\r\n * In fact, the initializer has the only power to insert the positions to redeem and nothing more.\r\n * When all the positions will be filled, the completeInitialization method will be called and the redeem can be available.\r\n */\r\ncontract LiquidityMiningRedeemer {\r\n\r\n    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\r\n    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    address private WETH_ADDRESS = IUniswapV2Router(UNISWAP_V2_ROUTER).WETH();\r\n\r\n    address private _initializer;\r\n\r\n    address private _doubleProxy;\r\n\r\n    address[] private _tokens;\r\n\r\n    mapping(address => bool) private _redeemed;\r\n\r\n    mapping(address => mapping(address => uint256)) private _positions;\r\n\r\n    event Redeemed(address indexed sender, address indexed positionOwner);\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param doubleProxy - The link with the DFO which this Contract depends on\r\n     * @param tokens - The list of all ERC-20 tokens involved in the Liquidity Mining Contracts\r\n     */\r\n    constructor(address doubleProxy, address[] memory tokens) {\r\n        _initializer = msg.sender;\r\n        _doubleProxy = doubleProxy;\r\n        _tokens = tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev This method is callable by the initializer only and it helps to do a step-by-step initialization to avoid out-of-gas transaction due to large amount of information.\r\n     * It loads all the addresses having opened positions in the Liquidity Mining Contracts and the amount they will receive to redeem.\r\n     */\r\n    function fillData(address[] memory positionOwners, uint256[] memory token0Amounts, uint256[] memory token1Amounts, uint256[] memory token2Amounts, uint256[] memory token3Amounts, uint256[] memory token4Amounts, uint256[] memory token5Amounts) public {\r\n        require(msg.sender == _initializer, \"Unauthorized Action\");\r\n        assert(positionOwners.length == token0Amounts.length && token0Amounts.length == token1Amounts.length && token1Amounts.length == token2Amounts.length && token2Amounts.length == token3Amounts.length && token3Amounts.length == token4Amounts.length && token4Amounts.length == token5Amounts.length);\r\n        for(uint256 i = 0; i < positionOwners.length; i++) {\r\n            if(_tokens.length > 0) {\r\n                _positions[positionOwners[i]][_tokens[0]] = token0Amounts[i];\r\n            }\r\n            if(_tokens.length > 1) {\r\n                _positions[positionOwners[i]][_tokens[1]] = token1Amounts[i];\r\n            }\r\n            if(_tokens.length > 2) {\r\n                _positions[positionOwners[i]][_tokens[2]] = token2Amounts[i];\r\n            }\r\n            if(_tokens.length > 3) {\r\n                _positions[positionOwners[i]][_tokens[3]] = token3Amounts[i];\r\n            }\r\n            if(_tokens.length > 4) {\r\n                _positions[positionOwners[i]][_tokens[4]] = token4Amounts[i];\r\n            }\r\n            if(_tokens.length > 5) {\r\n                _positions[positionOwners[i]][_tokens[5]] = token5Amounts[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev After the end of the contract inizialiation, initializer will be set to address(0) and cannot be edited any more.\r\n     */\r\n    function completeInitialization() public {\r\n        require(msg.sender == _initializer, \"Unauthorized Action\");\r\n        _initializer = address(0);\r\n    }\r\n\r\n    /**\r\n     * @return The address of the Contract initializer\r\n     */\r\n    function initializer() public view returns (address) {\r\n        return _initializer;\r\n    }\r\n\r\n    /**\r\n     * @dev Method callable only by voting a Proposal in the linked DFO.\r\n     * For emergency purposes only (e.g. in case of Smart Contract bug)\r\n     * @param additionalTokens all the eventual additional tokens hel by the Contract. Can be empty\r\n     */\r\n    function emergencyFlush(address[] memory additionalTokens) public {\r\n        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\r\n        require(IMVDFunctionalitiesManager(proxy.getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), \"Unauthorized Action!\");\r\n        address walletAddress = proxy.getMVDWalletAddress();\r\n        address tokenAddress = proxy.getToken();\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 balanceOf = token.balanceOf(address(this));\r\n        if(balanceOf > 0) {\r\n            token.transfer(walletAddress, balanceOf);\r\n        }\r\n        balanceOf = 0;\r\n        for(uint256 i = 0; i < _tokens.length; i++) {\r\n            token = IERC20(_tokens[i]);\r\n            balanceOf = token.balanceOf(address(this));\r\n            if(balanceOf > 0) {\r\n                token.transfer(walletAddress, balanceOf);\r\n            }\r\n            balanceOf = 0;\r\n        }\r\n        balanceOf = 0;\r\n        for(uint256 i = 0; i < additionalTokens.length; i++) {\r\n            token = IERC20(additionalTokens[i]);\r\n            balanceOf = token.balanceOf(address(this));\r\n            if(balanceOf > 0) {\r\n                token.transfer(walletAddress, balanceOf);\r\n            }\r\n            balanceOf = 0;\r\n        }\r\n        balanceOf = address(this).balance;\r\n        if(balanceOf > 0) {\r\n            payable(walletAddress).transfer(balanceOf);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the Double Proxy Address of the linked DFO\r\n     */\r\n    function doubleProxy() public view returns(address) {\r\n        return _doubleProxy;\r\n    }\r\n\r\n    /**\r\n     * @return the address of all the tokens involved in the Liquidity Mining Contracts\r\n     */\r\n    function tokens() public view returns(address[] memory) {\r\n        return _tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Method callable only by voting a Proposal in the linked DFO.\r\n     * Sets the new Double Proxy address, in case it is needed.\r\n     */\r\n    function setDoubleProxy(address newDoubleProxy) public {\r\n        require(IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), \"Unauthorized Action!\");\r\n        _doubleProxy = newDoubleProxy;\r\n    }\r\n\r\n    /**\r\n     * @param positionOwner the Address of the owner you want to know info\r\n     * @return amounts The amount of tokens this address will receive (each position of the array corresponds to the one of the array returned by the votingTokens() call)\r\n     */\r\n    function position(address positionOwner) public view returns (uint256[] memory amounts){\r\n        amounts = new uint256[](_tokens.length);\r\n        for(uint256 i = 0; i < _tokens.length; i++) {\r\n            amounts[i] = _positions[positionOwner][_tokens[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param positionOwner the Address of the owner you want to know info\r\n     * @return true if this address already redeemed its position. False otherwhise\r\n     */\r\n    function redeemed(address positionOwner) public view returns(bool) {\r\n        return _redeemed[positionOwner];\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    /**\r\n     * @dev The redeem function will give back the position amounts to the msg.sender.\r\n     * It can be called just one time per address.\r\n     * Redeem will be available after the finalization of the Smart Contract\r\n     */\r\n    function redeem() public {\r\n        require(_initializer == address(0), \"Redeem still not initialized\");\r\n        address positionOwner = msg.sender;\r\n        require(!_redeemed[positionOwner], \"This position owner already redeemed its position\");\r\n        _redeemed[positionOwner] = true;\r\n        for(uint256 i = 0; i < _tokens.length; i++) {\r\n            uint256 amount = _positions[positionOwner][_tokens[i]];\r\n            if(amount == 0) {\r\n                continue;\r\n            }\r\n            if(_tokens[i] == WETH_ADDRESS) {\r\n                payable(positionOwner).transfer(amount);\r\n                continue;\r\n            }\r\n            IERC20(_tokens[i]).transfer(positionOwner, amount);\r\n        }\r\n        emit Redeemed(msg.sender, positionOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts the Uniswap V2 LP Tokens sent by the Liquidity Mining Contracts to the corresponding tokens to provide liquidity for the redeemers\r\n     * @param token0 Uniswap V2 LP Token 0\r\n     * @param token1 Uniswap V2 LP Token 1\r\n     * @param amountMin0 Parameter useful to call the UniswapV2Router\r\n     * @param amountMin1 Parameter useful to call the UniswapV2Router\r\n     */\r\n    function convertUniswapV2TokenPool(address token0, address token1, uint256 amountMin0, uint256  amountMin1) public returns (uint256 amountA, uint256 amountB) {\r\n        IERC20 pair = IERC20(IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(token0, token1));\r\n        uint256 liquidity = pair.balanceOf(address(this));\r\n        IUniswapV2Router router = IUniswapV2Router(UNISWAP_V2_ROUTER);\r\n        pair.approve(UNISWAP_V2_ROUTER, liquidity);\r\n        if(token0 == WETH_ADDRESS || token1 == WETH_ADDRESS) {\r\n            return router.removeLiquidityETH(token0 == WETH_ADDRESS ? token1 : token0, liquidity, amountMin0, amountMin1, address(this), block.timestamp + 1000);\r\n        }\r\n        return router.removeLiquidity(token0, token1, liquidity, amountMin0, amountMin1, address(this), block.timestamp + 1000);\r\n    }\r\n}\r\n\r\ninterface IMVDProxy {\r\n    function getToken() external view returns(address);\r\n    function getStateHolderAddress() external view returns(address);\r\n    function getMVDWalletAddress() external view returns(address);\r\n    function getMVDFunctionalitiesManagerAddress() external view returns(address);\r\n    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\r\n}\r\n\r\ninterface IStateHolder {\r\n    function setUint256(string calldata name, uint256 value) external returns(uint256);\r\n    function getUint256(string calldata name) external view returns(uint256);\r\n    function getBool(string calldata varName) external view returns (bool);\r\n    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\r\n}\r\n\r\ninterface IMVDFunctionalitiesManager {\r\n    function isAuthorizedFunctionality(address functionality) external view returns(bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n}\r\n\r\ninterface IDoubleProxy {\r\n    function proxy() external view returns(address);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doubleProxy\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"completeInitialization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMin0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMin1\",\"type\":\"uint256\"}],\"name\":\"convertUniswapV2TokenPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doubleProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"additionalTokens\",\"type\":\"address[]\"}],\"name\":\"emergencyFlush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"positionOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token0Amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token1Amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token2Amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token3Amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token4Amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token5Amounts\",\"type\":\"uint256[]\"}],\"name\":\"fillData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"name\":\"position\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"name\":\"redeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDoubleProxy\",\"type\":\"address\"}],\"name\":\"setDoubleProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LiquidityMiningRedeemer","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fa7bd9fee90745189b99b95aff42ce681c58cb49000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000050000000000000000000000007b123f53421b1bf8533339bfbdc7c98aa94163db000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000034612903db071e888a4dadcaa416d3ee263a87b90000000000000000000000009e78b8274e1d6a76a0dbbf90418894df27cbceb5000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://35b8bf7ff3a7f483e2b056c59d293f377dc9b569866b91473388575dc3248fcb"}]}