{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NestStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"./lib/SafeMath.sol\\\";\\nimport \\\"./lib/AddressPayable.sol\\\";\\n\\nimport \\\"./iface/INestPool.sol\\\";\\nimport \\\"./iface/INestStaking.sol\\\";\\n\\nimport \\\"./lib/SafeERC20.sol\\\";\\nimport \\\"./lib/ReentrancyGuard.sol\\\";\\nimport './lib/TransferHelper.sol';\\n\\n/// @title NestStaking\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\n\\ncontract NestStaking is INestStaking, ReentrancyGuard {\\n\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE ============== */\\n\\n    /// @dev  The flag of staking global state\\n    uint8 public flag;      // = 0: uninitialized\\n                            // = 1: active\\n                            // = 2: no staking\\n                            // = 3: paused \\n\\n    uint248 private _reserved1;\\n\\n    uint8 constant STAKING_FLAG_UNINITIALIZED    = 0;\\n    uint8 constant STAKING_FLAG_ACTIVE           = 1;\\n    uint8 constant STAKING_FLAG_NO_STAKING       = 2;\\n    uint8 constant STAKING_FLAG_PAUSED           = 3;\\n\\n    /// @dev The balance of savings w.r.t a ntoken(or nest-token)\\n    ///     _pending_saving_Amount: ntoken => saving amount\\n    //mapping(address => uint256) private _pending_saving_amount;\\n\\n    /// @dev The per-ntoken-reward (ETH) w.r.t a ntoken(or nest-token)\\n    ///     _reward_per_ntoken_stored: ntoken => amount\\n    mapping(address => uint256) private _reward_per_ntoken_stored;\\n\\n    // _reward_per_ntoken_claimed: (ntoken, acount, amount) => amount\\n    mapping(address => mapping(address => uint256)) _reward_per_ntoken_claimed;\\n\\n    // ntoken => last reward \\n    mapping(address => uint256) public lastRewardsTotal;\\n\\n    // _ntoken_total: ntoken => amount\\n    mapping(address => uint256) _ntoken_staked_total;\\n\\n    // _staked_balances: (ntoken, account) => amount\\n    mapping(address => mapping(address => uint256)) private _staked_balances;\\n\\n    // rewardsTotal: (ntoken) => amount\\n    mapping(address => uint256) public rewardsTotal;\\n    \\n    // _rewards_balances: (ntoken, account) => amount\\n    mapping(address => mapping(address => uint256)) public rewardBalances;\\n\\n    /* ========== PARAMETERS ============== */\\n    \\n    /// @dev The percentage of dividends \\n    uint8 private _dividend_share; // = 100 as default;\\n\\n    uint8 constant STAKING_DIVIDEND_SHARE_PRECENTAGE = 100;\\n\\n    uint248 private _reserved2;\\n\\n    /* ========== ADDRESSES ============== */\\n\\n    address private C_NestToken;\\n    address private C_NestPool;\\n\\n    address private governance;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    receive() external payable {}\\n\\n    // NOTE: to support open-zeppelin/upgrades, leave it blank\\n    constructor() public { }\\n\\n    /// @dev It is called by the proxy (open-zeppelin/upgrades), only ONCE!\\n    function initialize(address NestPool) external \\n    {\\n        require(flag == STAKING_FLAG_UNINITIALIZED, \\\"Nest:Stak:!flag\\\");\\n        governance = msg.sender;\\n        _dividend_share = STAKING_DIVIDEND_SHARE_PRECENTAGE;\\n        flag = STAKING_FLAG_ACTIVE;\\n        C_NestPool = NestPool;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyGovOrBy(address _contract) \\n    {\\n        require(msg.sender == governance || msg.sender == _contract, \\\"Nest:Stak:!sender\\\");\\n        _;\\n    }\\n\\n    modifier whenActive() \\n    {\\n        require(flag == STAKING_FLAG_ACTIVE, \\\"Nest:Stak:!flag\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernance() \\n    {\\n        require(msg.sender == governance, \\\"Nest:Stak:!gov\\\");\\n        _;\\n    }\\n\\n    mapping(uint256 => mapping(address => bool)) private _status;\\n\\n    modifier onlyOneBlock() {\\n        require(\\n            !_status[block.number][tx.origin],\\n            'Nest:Stak:!block'\\n        );\\n        require(\\n            !_status[block.number][msg.sender],\\n            'Nest:Stak:!block'\\n        );\\n\\n        _;\\n\\n        _status[block.number][tx.origin] = true;\\n        _status[block.number][msg.sender] = true;\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\\n    {\\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\\n    }\\n\\n    /// @dev To ensure that all of governance-addresses be consist with each other\\n    function loadGovernance() override external \\n    { \\n        governance = INestPool(C_NestPool).governance();\\n    }\\n\\n    /// @dev Stop service for emergency\\n    function pause() override external onlyGovernance\\n    {\\n        require(flag == STAKING_FLAG_ACTIVE, \\\"Nest:Stak:!flag\\\");\\n        flag = STAKING_FLAG_PAUSED;\\n        emit FlagSet(address(msg.sender), uint256(STAKING_FLAG_PAUSED));\\n    }\\n\\n    /// @dev Resume service \\n    function resume() override external onlyGovernance\\n    {\\n        require(flag == STAKING_FLAG_PAUSED, \\\"Nest:Stak:!flag\\\");\\n        flag = STAKING_FLAG_ACTIVE;\\n        emit FlagSet(address(msg.sender), uint256(STAKING_FLAG_ACTIVE));\\n    }\\n\\n    /*\\n    // exist bug\\n    function withdrawSavingByGov(address ntoken, address to, uint256 amount) \\n        external \\n        nonReentrant \\n        onlyGovernance \\n    {\\n        require(flag == STAKING_FLAG_PAUSED, \\\"Nest:Stak:!flag\\\");\\n\\n        _pending_saving_amount[ntoken] = _pending_saving_amount[ntoken].sub(amount);\\n\\n        // must refresh WETH balance record after updating WETH balance\\n        // or lastRewardsTotal could be less than the newest WETH balance in the next update\\n        uint256 _newTotal = rewardsTotal[ntoken].sub(amount);\\n        lastRewardsTotal[ntoken] = _newTotal;\\n        rewardsTotal[ntoken] = _newTotal;\\n        emit SavingWithdrawn(ntoken, to, amount);\\n        TransferHelper.safeTransferETH(to, amount);      \\n    }\\n   \\n    function setParams(uint8 dividendShareRate) override external onlyGovernance\\n    {\\n        if (dividendShareRate > 0 && dividendShareRate <= 100) {\\n            _dividend_share = dividendShareRate;\\n        }\\n    }\\n    */\\n    /* ========== VIEWS ========== */\\n    /*\\n    function totalSaving(address ntoken)\\n        external view returns (uint256) \\n    {\\n       return  _pending_saving_amount[ntoken];\\n    }\\n    */\\n    function totalRewards(address ntoken)\\n        external view returns (uint256) \\n    {\\n       return  rewardsTotal[ntoken];\\n    }\\n\\n    function totalStaked(address ntoken) \\n        external override view returns (uint256) \\n    {\\n        return _ntoken_staked_total[ntoken];\\n    }\\n\\n    function stakedBalanceOf(address ntoken, address account) \\n        external override view returns (uint256) \\n    {\\n        return _staked_balances[ntoken][account];\\n    }\\n\\n    // CM: <tokenShare> = <OldTokenShare> + (<NewTokenShare> * _dividend_share% / <tokenAmount>) \\n    function rewardPerToken(address ntoken) \\n        public \\n        view \\n        returns (uint256) \\n    {\\n        uint256 _total = _ntoken_staked_total[ntoken];\\n        if (_total == 0) {\\n            // use the old rewardPerTokenStored\\n            // if not, the new accrued amount will never be distributed to anyone\\n            return _reward_per_ntoken_stored[ntoken];\\n        }\\n        uint256 _rewardPerToken = _reward_per_ntoken_stored[ntoken].add(\\n                accrued(ntoken).mul(1e18).mul(_dividend_share).div(_total).div(100)\\n            );\\n        return _rewardPerToken;\\n    }\\n\\n    // CM: <NewTokenShare> = <rewardToken blnc> - <last blnc>\\n    function accrued(address ntoken) \\n        public \\n        view \\n        returns (uint256) \\n    {\\n        // eth increment of eth since last update\\n        uint256 _newest = rewardsTotal[ntoken];\\n        // lastest must be larger than lastUpdate\\n        return _newest.sub(lastRewardsTotal[ntoken]); \\n    }\\n\\n    // CM: <user share> = [<tokenAmonut> * (<tokenShare> - <tokenShareCollected>) / 1e18] + <reward>\\n    function earned(address ntoken, address account) \\n        public \\n        view \\n        returns (uint256) \\n    {\\n        return _staked_balances[ntoken][account].mul(\\n                        rewardPerToken(ntoken).sub(_reward_per_ntoken_claimed[ntoken][account])\\n                    ).div(1e18).add(rewardBalances[ntoken][account]);\\n    }\\n    /*  // it is extra\\n    // calculate\\n    function _rewardPerTokenAndAccrued(address ntoken) \\n        internal\\n        view \\n        returns (uint256, uint256) \\n    {\\n        uint256 _total = _ntoken_staked_total[ntoken];\\n        if (_total == 0) {\\n            // use the old rewardPerTokenStored, and accrued should be zero here\\n            // if not the new accrued amount will never be distributed to anyone\\n            return (_reward_per_ntoken_stored[ntoken], 0);\\n        }\\n        uint256 _accrued = accrued(ntoken);\\n        uint256 _rewardPerToken = _reward_per_ntoken_stored[ntoken].add(\\n                _accrued.mul(1e18).mul(_dividend_share).div(_total).div(100) \\n            ); // 80% of accrued to NEST holders as dividend\\n        return (_rewardPerToken, _accrued);\\n    }\\n    */\\n    /* ========== STAK/UNSTAK/CLAIM ========== */\\n\\n    modifier updateReward(address ntoken, address account) \\n    {\\n        uint256 _total = _ntoken_staked_total[ntoken];\\n        uint256 _accrued = rewardsTotal[ntoken].sub(lastRewardsTotal[ntoken]);\\n        uint256 _rewardPerToken;      \\n\\n        if (_total == 0) {\\n            // use the old rewardPerTokenStored, and accrued should be zero here\\n            // if not the new accrued amount will never be distributed to anyone\\n            _rewardPerToken = _reward_per_ntoken_stored[ntoken];\\n        } else {\\n            // 80% of accrued to NEST holders as dividend\\n            _rewardPerToken = _reward_per_ntoken_stored[ntoken].add(\\n                _accrued.mul(1e18).mul(_dividend_share).div(_total).div(100) \\n            );\\n            // update _reward_per_ntoken_stored\\n            _reward_per_ntoken_stored[ntoken] = _rewardPerToken;\\n            lastRewardsTotal[ntoken] = rewardsTotal[ntoken];\\n            //uint256 _newSaving = _accrued.sub(_accrued.mul(_dividend_share).div(100)); // left 20%\\n            //_pending_saving_amount[ntoken] = _pending_saving_amount[ntoken].add(_newSaving);\\n        }\\n\\n        uint256 _newEarned = _staked_balances[ntoken][account].mul(\\n                _rewardPerToken.sub(_reward_per_ntoken_claimed[ntoken][account])\\n            ).div(1e18);\\n\\n        if (account != address(0)) { // Q: redundant\\n            rewardBalances[ntoken][account] = rewardBalances[ntoken][account].add(_newEarned);\\n            _reward_per_ntoken_claimed[ntoken][account] = _reward_per_ntoken_stored[ntoken];\\n        }\\n        _;\\n    }\\n\\n    /// @notice Stake NTokens to get the dividends\\n    function stake(address ntoken, uint256 amount)\\n        external \\n        override \\n        nonReentrant \\n        onlyOneBlock\\n        whenActive\\n        updateReward(ntoken, msg.sender) \\n    {\\n        require(amount > 0, \\\"Nest:Stak:!amount\\\");\\n        _ntoken_staked_total[ntoken] = _ntoken_staked_total[ntoken].add(amount);\\n        _staked_balances[ntoken][msg.sender] = _staked_balances[ntoken][msg.sender].add(amount);\\n        //TransferHelper.safeTransferFrom(ntoken, msg.sender, address(this), amount);\\n        emit NTokenStaked(ntoken, msg.sender, amount);\\n        TransferHelper.safeTransferFrom(ntoken, msg.sender, address(this), amount);\\n\\n    }\\n\\n    /// @notice Stake NTokens to get the dividends\\n    function stakeFromNestPool(address ntoken, uint256 amount) \\n        external \\n        override \\n        nonReentrant \\n        onlyOneBlock\\n        whenActive\\n        updateReward(ntoken, msg.sender) \\n    {\\n        require(amount > 0, \\\"Nest:Stak:!amount\\\");\\n        _ntoken_staked_total[ntoken] = _ntoken_staked_total[ntoken].add(amount);\\n        _staked_balances[ntoken][msg.sender] = _staked_balances[ntoken][msg.sender].add(amount);\\n        INestPool(C_NestPool).withdrawNTokenAndTransfer(msg.sender, ntoken, amount, address(this));\\n        emit NTokenStaked(ntoken, msg.sender, amount);\\n    }\\n\\n    /// @notice Unstake NTokens\\n    function unstake(address ntoken, uint256 amount) \\n        public \\n        override \\n        nonReentrant \\n        onlyOneBlock\\n        whenActive\\n        updateReward(ntoken, msg.sender)\\n    {\\n        require(amount > 0, \\\"Nest:Stak:!amount\\\");\\n        _ntoken_staked_total[ntoken] = _ntoken_staked_total[ntoken].sub(amount);\\n        _staked_balances[ntoken][msg.sender] = _staked_balances[ntoken][msg.sender].sub(amount);\\n        //TransferHelper.safeTransfer(ntoken, msg.sender, amount);\\n        emit NTokenUnstaked(ntoken, msg.sender, amount);\\n        TransferHelper.safeTransfer(ntoken, msg.sender, amount);\\n\\n    }\\n\\n    /// @notice Claim rewards\\n    function claim(address ntoken) \\n        public \\n        override \\n        nonReentrant \\n        whenActive\\n        updateReward(ntoken, msg.sender) \\n        returns (uint256)\\n    {\\n        uint256 _reward = rewardBalances[ntoken][msg.sender];\\n        if (_reward > 0) {\\n            rewardBalances[ntoken][msg.sender] = 0;\\n            // WETH balance decreased after this\\n            //TransferHelper.safeTransferETH(msg.sender, _reward);\\n            // must refresh WETH balance record after updating WETH balance\\n            // or lastRewardsTotal could be less than the newest WETH balance in the next update\\n            uint256 _newTotal = rewardsTotal[ntoken].sub(_reward);\\n            lastRewardsTotal[ntoken] = _newTotal;\\n            rewardsTotal[ntoken] = _newTotal;         \\n           \\n            emit RewardClaimed(ntoken, msg.sender, _reward);\\n\\n             TransferHelper.safeTransferETH(msg.sender, _reward);\\n        }\\n        return _reward;\\n    }\\n\\n    /* ========== INTER-CALLS ========== */\\n\\n    function addETHReward(address ntoken) \\n        override \\n        external \\n        payable \\n    {\\n        // NOTE: no need to update reward here\\n        // support for sending ETH for rewards\\n        rewardsTotal[ntoken] = rewardsTotal[ntoken].add(msg.value); \\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y > 0, \\\"ds-math-div-zero\\\");\\n        z = x / y;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/AddressPayable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nlibrary address_make_payable {\\n   function make_payable(address x) internal pure returns (address payable) {\\n      return address(uint160(x));\\n   }\\n}\"\r\n    },\r\n    \"contracts/iface/INestPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\ninterface INestPool {\\n\\n    // function getNTokenFromToken(address token) view external returns (address);\\n    // function setNTokenToToken(address token, address ntoken) external; \\n\\n    function addNest(address miner, uint256 amount) external;\\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\\n\\n    function depositEth(address miner) external payable;\\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\\n\\n    function freezeEth(address miner, uint256 ethAmount) external; \\n    function unfreezeEth(address miner, uint256 ethAmount) external;\\n\\n    function freezeNest(address miner, uint256 nestAmount) external;\\n    function unfreezeNest(address miner, uint256 nestAmount) external;\\n\\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n\\n    function getNTokenFromToken(address token) external view returns (address); \\n    function setNTokenToToken(address token, address ntoken) external; \\n\\n    function withdrawEth(address miner, uint256 ethAmount) external;\\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function withdrawNest(address miner, uint256 amount) external;\\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\\n\\n\\n    function balanceOfNestInPool(address miner) external view returns (uint256);\\n    function balanceOfEthInPool(address miner) external view returns (uint256);\\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\\n\\n    function addrOfNestToken() external view returns (address);\\n    function addrOfNestMining() external view returns (address);\\n    function addrOfNTokenController() external view returns (address);\\n    function addrOfNNRewardPool() external view returns (address);\\n    function addrOfNNToken() external view returns (address);\\n    function addrOfNestStaking() external view returns (address);\\n    function addrOfNestQuery() external view returns (address);\\n    function addrOfNestDAO() external view returns (address);\\n\\n    function addressOfBurnedNest() external view returns (address);\\n\\n    function setGovernance(address _gov) external; \\n    function governance() external view returns(address);\\n    function initNestLedger(uint256 amount) external;\\n    function drainNest(address to, uint256 amount, address gov) external;\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\ninterface INestStaking {\\n    // Views\\n\\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @return The total amount of XTokens deposited in this staking pool\\n    function totalStaked(address ntoken) external view returns (uint256);\\n\\n    /// @dev How many stakingToken (XToken) deposited by the target account\\n    /// @param  ntoken The address of NToken\\n    /// @param  account The target account\\n    /// @return The total amount of XToken deposited in this staking pool\\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\\n\\n\\n    // Mutative\\n    /// @dev Stake/Deposit into the reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function stake(address ntoken, uint256 amount) external;\\n\\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\\n\\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function unstake(address ntoken, uint256 amount) external;\\n\\n    /// @dev Claim the reward the user earned\\n    /// @param ntoken The address of NToken\\n    /// @return The amount of ethers as rewards\\n    function claim(address ntoken) external returns (uint256);\\n\\n    /// @dev Add ETH reward to the staking pool\\n    /// @param ntoken The address of NToken\\n    function addETHReward(address ntoken) external payable;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    function pause() external;\\n\\n    function resume() external;\\n\\n    //function setParams(uint8 dividendShareRate) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Events\\n    event RewardAdded(address ntoken, address sender, uint256 reward);\\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\\n\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/// @dev The non-empty constructor is conflict with upgrades-openzeppelin. \\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n\\n    // NOTE: _NOT_ENTERED is set to ZERO such that it needn't constructor\\n    uint256 private constant _NOT_ENTERED = 0;\\n    uint256 private constant _ENTERED = 1;\\n\\n    uint256 private _status;\\n\\n    // constructor () internal {\\n    //     _status = _NOT_ENTERED;\\n    // }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{value:amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"FlagSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NTokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NTokenUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SavingWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"accrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"addETHReward\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"NestPool\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRewardsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFromNestPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NestStaking","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}