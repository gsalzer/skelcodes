{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n *\\r\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\\r\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\r\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\r\\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the address of the owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(),\\\"Not Owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return true if `msg.sender` is the owner of the contract.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to relinquish control of the contract.\\r\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\r\\n     * It will not be possible to call the functions with the `onlyOwner`\\r\\n     * modifier anymore.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0),\\\"Zero address not allowed\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  /**\\r\\n   * @dev Returns the addition of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `+` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Addition cannot overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n   * overflow (when the result is negative).\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `-` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Subtraction cannot overflow.\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n   * overflow.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `*` operator.\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - Multiplication cannot overflow.\\r\\n   */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n   * division by zero. The result is rounded towards zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b \\u003e 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n   * Reverts with custom message when dividing by zero.\\r\\n   *\\r\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n   * invalid opcode to revert (consuming all remaining gas).\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - The divisor cannot be zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"},\"SwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\n//import \\\"./SafeMath.sol\\\";\\r\\n//import \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SwapPair.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IValidator {\\r\\n    // returns: user balance, native (foreign for us) encoded balance, foreign (native for us) encoded balance\\r\\n    function checkBalances(address pair, address foreignSwapPair, address user) external returns(uint256);\\r\\n    // returns: user balance\\r\\n    function checkBalance(address pair, address foreignSwapPair, address user) external returns(uint256);\\r\\n    // returns: oracle fee\\r\\n    function getOracleFee(uint256 req) external returns(uint256);  //req: 1 - cancel, 2 - claim, returns: value\\r\\n}\\r\\n\\r\\ninterface ISmart {\\r\\n    function requestCompensation(address user, uint256 feeAmount) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IAuction {\\r\\n    function contributeFromSmartSwap(address payable _whom) external payable returns (bool);\\r\\n}\\r\\n\\r\\ncontract SwapFactory is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 1 - BNB, 2 - ETH, 3 - BTC\\r\\n    uint256 constant INVESTMENT_FLAG = 2**224;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e address payable)) public getPair;\\r\\n    mapping(address =\\u003e address) public foreignPair;\\r\\n    address[] public allPairs;\\r\\n    address public foreignFactory;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public cancelAmount;    // pair =\\u003e user =\\u003e cancelAmount\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public swapAmount;    // pair =\\u003e user =\\u003e swapAmount\\r\\n\\r\\n    mapping(address =\\u003e bool) public isExchange;         // is Exchange address\\r\\n    mapping(address =\\u003e bool) public isExcludedSender;   // address excluded from receiving SMART token as fee compensation\\r\\n\\r\\n    \\r\\n    uint256 public fee;\\r\\n    address payable public validator;\\r\\n    address public system;  // system address mey change fee amount\\r\\n    address public auction; // auction address\\r\\n    address public contractSmart;  // the contract address to request Smart token in exchange of fee\\r\\n    address public feeReceiver; // address which receive the fee (by default is validator)\\r\\n    \\r\\n\\r\\n    address public newFactory;            // new factory address to upgrade\\r\\n    event PairCreated(address indexed tokenA, address indexed tokenB, address pair, uint);\\r\\n    event SwapRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountA, bool isInvestment);\\r\\n    event CancelRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountA, bool isInvestment);\\r\\n    event CancelApprove(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountA, bool isInvestment);\\r\\n    event ClaimRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountB, bool isInvestment);\\r\\n    event ClaimApprove(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountB, uint256 amountA, bool isInvestment);\\r\\n    event ExchangeInvestETH(address indexed exchange, address indexed whom, uint256 value);\\r\\n    \\r\\n    /**\\r\\n    * @dev Throws if called by any account other than the system.\\r\\n    */\\r\\n    modifier onlySystem() {\\r\\n        require(msg.sender == system || isOwner(), \\\"Caller is not the system\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor (address _system) public {\\r\\n        system = _system;\\r\\n        newFactory = address(this);\\r\\n    }\\r\\n    \\r\\n    //invest into auction\\r\\n    function investAuction(address payable _whom) external payable returns (bool)\\r\\n    {\\r\\n        require(foreignPair[msg.sender] != address(0), \\\"Investing allowed from pair only\\\");\\r\\n        IAuction(auction).contributeFromSmartSwap{value: msg.value}(_whom);\\r\\n    }\\r\\n    \\r\\n    function setFee(uint256 _fee) external onlySystem returns(bool) {\\r\\n        fee = _fee;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setSystem(address _system) external onlyOwner returns(bool) {\\r\\n        system = _system;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setValidator(address payable _validator) external onlyOwner returns(bool) {\\r\\n        validator = _validator;\\r\\n        if(feeReceiver == address(0)) feeReceiver = _validator;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setForeignFactory(address _addr) external onlyOwner returns(bool) {\\r\\n        foreignFactory = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\\r\\n        feeReceiver = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setMSSContract(address _addr) external onlyOwner returns(bool) {\\r\\n        contractSmart = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setNewFactory(address _addr) external onlyOwner returns(bool) {\\r\\n        newFactory = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAuction(address _addr) external onlyOwner returns(bool) {\\r\\n        auction = _addr;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // for ETH side only\\r\\n    function changeExchangeAddress(address _which,bool _bool) external onlyOwner returns(bool){\\r\\n        isExchange[_which] = _bool;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function changeExcludedAddress(address _which,bool _bool) external onlyOwner returns(bool){\\r\\n        isExcludedSender[_which] = _bool;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function createPair(address tokenA, uint8 decimalsA, address tokenB, uint8 decimalsB) public onlyOwner returns (address payable pair) {\\r\\n        require(getPair[tokenA][tokenB] == address(0), \\u0027PAIR_EXISTS\\u0027); // single check is sufficient\\r\\n        bytes memory bytecode = type(SwapPair).creationCode;\\r\\n        bytes32 salt = keccak256(abi.encodePacked(tokenA, tokenB));\\r\\n        assembly {\\r\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\r\\n        }\\r\\n        foreignPair[pair] = getForeignPair(tokenB, tokenA);\\r\\n        SwapPair(pair).initialize(foreignPair[pair], tokenA, decimalsA, tokenB, decimalsB);\\r\\n        getPair[tokenA][tokenB] = pair;\\r\\n\\r\\n        allPairs.push(pair);\\r\\n        emit PairCreated(tokenA, tokenB, pair, allPairs.length);\\r\\n    }\\r\\n\\r\\n    function getForeignPair(address tokenA, address tokenB) internal view returns(address pair) {\\r\\n        pair = address(uint(keccak256(abi.encodePacked(\\r\\n                hex\\u0027ff\\u0027,\\r\\n                foreignFactory,\\r\\n                keccak256(abi.encodePacked(tokenA, tokenB)),\\r\\n                hex\\u002705a14d15386c927ac1a2b1e515003107665e36f549246b88b3d136d36426eded\\u0027 // init code hash\\r\\n            ))));\\r\\n    }\\r\\n\\r\\n    // set already existed pairs in case of contract upgrade\\r\\n    function setPairs(address[] memory tokenA, address[] memory tokenB, address payable[] memory pair) external onlyOwner returns(bool) {\\r\\n        uint256 len = tokenA.length;\\r\\n        while (len \\u003e 0) {\\r\\n            len--;\\r\\n            getPair[tokenA[len]][tokenB[len]] = pair[len];\\r\\n            foreignPair[pair[len]] = SwapPair(pair[len]).foreignSwapPair();\\r\\n            allPairs.push(pair[len]);\\r\\n            emit PairCreated(tokenA[len], tokenB[len], pair[len], allPairs.length);            \\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairAddressFor(address tokenA, address tokenB) external view returns (address pair, bytes32 bytecodeHash) {\\r\\n        bytes memory bytecode = type(SwapPair).creationCode;\\r\\n        bytecodeHash = keccak256(bytecode);\\r\\n        pair = address(uint(keccak256(abi.encodePacked(\\r\\n                hex\\u0027ff\\u0027,\\r\\n                address(this),\\r\\n                keccak256(abi.encodePacked(tokenA, tokenB)),\\r\\n                bytecodeHash    // hex\\u002705a14d15386c927ac1a2b1e515003107665e36f549246b88b3d136d36426eded\\u0027 // init code hash\\r\\n            ))));\\r\\n    }\\r\\n\\r\\n    // ================== on Ethereum network only =========================================================================\\r\\n\\r\\n    //user should approve tokens transfer before calling this function.\\r\\n    function swapInvestment(address tokenA, uint256 amount) external payable returns (bool) {\\r\\n        address tokenB = address(1);    // BNB (foreign coin)\\r\\n        return _swap(tokenA, tokenB, msg.sender, amount, true);\\r\\n    }\\r\\n\\r\\n    function cancelInvestment(address tokenA, uint256 amount) external payable returns (bool) {\\r\\n        address tokenB = address(1);    // BNB (foreign coin)\\r\\n        return _cancel(tokenA, tokenB, msg.sender, amount, true);\\r\\n    }\\r\\n\\r\\n\\r\\n    // function for invest ETH from from exchange on user behalf\\r\\n    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\\r\\n        require(isExchange[msg.sender], \\\"Not an Exchange address\\\");\\r\\n        address tokenA = address(2);    // ETH (native coin)\\r\\n        address tokenB = address(1);    // BNB (foreign coin)\\r\\n        uint256 amount = msg.value - fee;\\r\\n        emit ExchangeInvestETH(msg.sender, _whom, msg.value);\\r\\n        return _swap(tokenA, tokenB, _whom, amount, true);\\r\\n    }\\r\\n    // ================= end Ethereum part =================================================================================\\r\\n\\r\\n    // ====================== on BSC side only =============================================================================\\r\\n\\r\\n    // tokenB - foreign token address or address(1) for ETH\\r\\n    // amountB - amount of foreign tokens or ETH\\r\\n    function claimInvestmentBehalf(address tokenB, address user, uint256 amountB) external onlySystem returns (bool) {\\r\\n        address tokenA = address(1);    // BNB (native coin)\\r\\n        return _claimTokenBehalf(tokenA, tokenB, user, amountB, true);\\r\\n    }\\r\\n    // ====================== end BSC part =================================================================================\\r\\n\\r\\n    \\r\\n    //user should approve tokens transfer before calling this function.\\r\\n    function swap(address tokenA, address tokenB, uint256 amount) external payable returns (bool) {\\r\\n        return _swap(tokenA, tokenB, msg.sender, amount, false);\\r\\n    }\\r\\n\\r\\n    function cancel(address tokenA, address tokenB, uint256 amount) external payable returns (bool) {\\r\\n        return _cancel(tokenA, tokenB, msg.sender, amount, false);\\r\\n    }\\r\\n    function claimTokenBehalf(address tokenA, address tokenB, address user, uint256 amountB) external onlySystem returns (bool) {\\r\\n        return _claimTokenBehalf(tokenA, tokenB, user, amountB, false);\\r\\n    }\\r\\n\\r\\n    // transfer fee to receiver and request MASS token as compensation.\\r\\n    function transferFee(uint256 feeAmount, address user) internal {\\r\\n        TransferHelper.safeTransferETH(feeReceiver, feeAmount);\\r\\n        if(contractSmart != address(0) \\u0026\\u0026 !isExcludedSender[msg.sender]) {\\r\\n            ISmart(contractSmart).requestCompensation(user, feeAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //user should approve tokens transfer before calling this function.\\r\\n    function _swap(address tokenA, address tokenB, address user, uint256 amount, bool isInvestment) internal returns (bool) {\\r\\n        uint256 feeAmount = msg.value;\\r\\n        if (tokenA \\u003c NATIVE_COINS) feeAmount = feeAmount.sub(amount,\\\"Insuficiant value\\\");   // if native coin, then feeAmount = msg.value - swap amount\\r\\n        require(feeAmount \\u003e= fee,\\\"Insufficient fee\\\");\\r\\n        require(amount != 0, \\\"Zero amount\\\");\\r\\n        address payable pair = getPair[tokenA][tokenB];\\r\\n        require(pair != address(0), \\u0027PAIR_NOT_EXISTS\\u0027);\\r\\n        \\r\\n        // transfer fee to validator. May be changed to request tokens for compensation\\r\\n        transferFee(feeAmount, user);\\r\\n\\r\\n        if (tokenA \\u003c NATIVE_COINS)\\r\\n            TransferHelper.safeTransferETH(pair, amount);\\r\\n        else \\r\\n            TransferHelper.safeTransferFrom(tokenA, user, pair, amount);\\r\\n        SwapPair(pair).deposit(user, amount, isInvestment);\\r\\n        emit SwapRequest(tokenA, tokenB, user, amount, isInvestment);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _cancel(address tokenA, address tokenB, address user, uint256 amount, bool isInvestment) internal returns (bool) {\\r\\n        require(msg.value \\u003e= IValidator(validator).getOracleFee(1), \\\"Insufficient fee\\\");    // check oracle fee for Cancel request\\r\\n        require(amount != 0, \\\"Zero amount\\\");\\r\\n        address payable pair = getPair[tokenA][tokenB];\\r\\n        require(pair != address(0), \\u0027PAIR_NOT_EXISTS\\u0027);\\r\\n        if (cancelAmount[pair][user] == 0) {  // new cancel request\\r\\n            cancelAmount[pair][user] = amount;\\r\\n            SwapPair(pair).cancel(user, amount, isInvestment);\\r\\n        }\\r\\n        else { // repeat cancel request in case oracle issues.\\r\\n            amount = cancelAmount[pair][user];\\r\\n        }\\r\\n\\r\\n        // transfer fee to validator. May be changed to request tokens for compensation\\r\\n        transferFee(msg.value, user);\\r\\n\\r\\n        if (isInvestment)\\r\\n            IValidator(validator).checkBalance(pair, foreignPair[pair], _investAddress(user));    // on Ethereum network only\\r\\n        else\\r\\n            IValidator(validator).checkBalance(pair, foreignPair[pair], _swapAddress(user));\\r\\n        emit CancelRequest(tokenA, tokenB, user, amount, isInvestment);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // amountB - amount of foreign token to swap\\r\\n    function _claimTokenBehalf(address tokenA, address tokenB, address user, uint256 amountB, bool isInvestment) internal returns (bool) {\\r\\n        address payable pair = getPair[tokenA][tokenB];\\r\\n        require(pair != address(0), \\u0027PAIR_NOT_EXISTS\\u0027);\\r\\n        require(amountB != 0, \\\"Zero amount\\\");\\r\\n        if (swapAmount[pair][user] == 0) {  // new claim request\\r\\n            swapAmount[pair][user] = amountB;\\r\\n            SwapPair(pair).claim(user, amountB, isInvestment);\\r\\n        }\\r\\n        else { // repeat claim request in case oracle issues.\\r\\n            amountB = swapAmount[pair][user];\\r\\n        }\\r\\n        if (isInvestment)\\r\\n            IValidator(validator).checkBalances(pair, foreignPair[pair], _investAddress(user));    // on BSC network only\\r\\n        else\\r\\n            IValidator(validator).checkBalances(pair, foreignPair[pair], user);\\r\\n        emit ClaimRequest(tokenA, tokenB, user, amountB, isInvestment);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // On both side (BEP and ERC) we accumulate user\\u0027s deposits (balance).\\r\\n    // If balance on one side it greater then on other, the difference means user deposit.\\r\\n    function balanceCallback(address payable pair, address user, uint256 balanceForeign) external returns(bool) {\\r\\n        require (validator == msg.sender, \\\"Not validator\\\");\\r\\n        (uint256 balance, bool isInvestment) = _getBalance(SwapPair(pair).balanceOf(user));\\r\\n        if (isInvestment) user = _swapAddress(user);    // real user address = investAddress + 1\\r\\n        uint256 amount = cancelAmount[pair][user];\\r\\n        require (amount != 0, \\\"No active cancel request\\\");\\r\\n        cancelAmount[pair][user] = 0;\\r\\n        address tokenA;\\r\\n        address tokenB;\\r\\n        bool isApproved = (balanceForeign \\u003c= balance);\\r\\n        (tokenA, tokenB) = SwapPair(pair).cancelApprove(user, amount, isApproved, isInvestment);\\r\\n        if(!isApproved) amount = 0;\\r\\n\\r\\n        emit CancelApprove(tokenA, tokenB, user, amount, isInvestment);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function balancesCallback(\\r\\n            address payable pair,\\r\\n            address user,\\r\\n            uint256 balanceForeign,\\r\\n            uint256 nativeEncoded,\\r\\n            uint256 foreignSpent,\\r\\n            uint256 rate    // rate = foreignPrice.mul(NOMINATOR) / nativePrice;   // current rate\\r\\n        ) external returns(bool) {\\r\\n        require (validator == msg.sender, \\\"Not validator\\\");\\r\\n        (uint256 balance, bool isInvestment) = _getBalance(balanceForeign);\\r\\n        address userSwap;\\r\\n        if (isInvestment) {\\r\\n            userSwap = user;    // investAddress\\r\\n            user = _swapAddress(user);    // real user address = investAddress + 1\\r\\n        }\\r\\n        else {\\r\\n            userSwap = _swapAddress(user);\\r\\n        }\\r\\n\\r\\n        uint256 amountB = swapAmount[pair][user];\\r\\n        require (amountB != 0, \\\"No active swap request\\\");\\r\\n        swapAmount[pair][user] = 0;\\r\\n        address tokenA;\\r\\n        address tokenB;\\r\\n        uint256 nativeAmount;\\r\\n        uint256 rest;\\r\\n        if (balance \\u003e= SwapPair(pair).balanceOf(userSwap)) { // is approve claim\\r\\n            (tokenA, tokenB, nativeAmount, rest) = SwapPair(pair).claimApprove(user, amountB, nativeEncoded, foreignSpent, rate, true, isInvestment);\\r\\n            amountB = amountB.sub(rest);\\r\\n        }\\r\\n        else {\\r\\n            (tokenA, tokenB, nativeAmount, rest) = SwapPair(pair).claimApprove(user, amountB, nativeEncoded, foreignSpent, rate, false, isInvestment);\\r\\n            amountB = 0;\\r\\n        }\\r\\n\\r\\n        emit ClaimApprove(tokenA, tokenB, user, amountB, nativeAmount, isInvestment);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // swapAddress = user address + 1.\\r\\n    // balanceOf contain two types of balance:\\r\\n    // 1. balanceOf[user] - balance of tokens on native chain\\r\\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\\r\\n    function _swapAddress(address user) internal pure returns(address swapAddress) {\\r\\n        swapAddress = address(uint160(user)+1);\\r\\n    }\\r\\n    // 3. balanceOf[user-1] - investment to auction total balance.\\r\\n    function _investAddress(address user) internal pure returns(address investAddress) {\\r\\n        investAddress = address(uint160(user)-1);\\r\\n    }\\r\\n    // return balance and investment flag\\r\\n    function _getBalance(uint256 balanceWithFlag) internal pure returns(uint256 balance, bool isInvestment) {\\r\\n        if(INVESTMENT_FLAG \\u0026 balanceWithFlag != 0) {\\r\\n            balance = uint192(balanceWithFlag);\\r\\n            isInvestment = true;\\r\\n        }\\r\\n        else {\\r\\n            balance = balanceWithFlag;\\r\\n            isInvestment = false;\\r\\n        }\\r\\n    }\\r\\n}\"},\"SwapPair.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\n\\r\\n// TODO: balance + 1, to avoid Zero balance\\r\\n\\r\\ninterface ISwapFactory {\\r\\n    function newFactory() external view returns(address);\\r\\n    function auction() external view returns(address);\\r\\n    function validator() external view returns(address);\\r\\n    function investAuction(address payable _whom) external payable returns (bool);\\r\\n}\\r\\n\\r\\ncontract SwapPair {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //uint256 constant chain = 97;  // ETH mainnet = 1, Ropsten = 2, BSC_TESTNET = 97, BSC_MAINNET = 56\\r\\n    uint256 constant MAX_AMOUNT = 2**192;\\r\\n    uint256 constant INVESTMENT_FLAG = 2**224;\\r\\n    uint256 constant NOMINATOR = 10**18;\\r\\n    uint256 constant PRICE_NOMINATOR = 10**9;     // rate nominator\\r\\n    address constant NATIVE = address(-1);  // address which holds native token ballance that was spent\\r\\n    address constant FOREIGN = address(-2); // address which holds foreign token encoded ballance that was spent\\r\\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 0 - BNB, 1 - ETH, 2 - BTC\\r\\n\\r\\n    address public token;               // token address\\r\\n    address public tokenForeign;        // Foreign token address\\r\\n    address public foreignSwapPair;     // foreign SwapPair contract address (on other blockchain)\\r\\n    address public factory;             // factory address\\r\\n    uint256 public decimalsNative;\\r\\n    uint256 public decimalsForeign;\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    // balanceOf contain two types of balance:\\r\\n    // 1. balanceOf[user] - balance of tokens on native chain\\r\\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\\r\\n    // 3. balanceOf[user-1] - swapped balance of foreign tokens for investment. I.e. on BSC chain it contain amount of ETH that was swapped.\\r\\n    mapping (address =\\u003e uint256) public balanceOf;\\r\\n    //mapping (address =\\u003e uint256) public cancelAmount;\\r\\n    //mapping (address =\\u003e uint256) public swapAmount;\\r\\n\\r\\n    event CancelRequest(address indexed user, address token, uint256 amount);\\r\\n    event CancelApprove(address indexed user, address token, uint256 amount);\\r\\n    event ClaimRequest(address indexed user, address foreignToken, uint256 foreignAmount);\\r\\n    event ClaimApprove(address indexed user, address foreignToken, uint256 foreignAmount, address token, uint256 amount);\\r\\n\\r\\n    modifier onlyFactory() {\\r\\n        require(msg.sender == factory, \\\"Caller is not the factory\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        factory = msg.sender;\\r\\n    }\\r\\n\\r\\n    function initialize(address _foreignPair, address tokenA, uint8 decimalsA, address tokenB, uint8 decimalsB) public onlyFactory {\\r\\n        foreignSwapPair = _foreignPair;\\r\\n        token = tokenA;\\r\\n        tokenForeign = tokenB;\\r\\n        decimalsNative = 10**uint256(decimalsA);\\r\\n        decimalsForeign = 10**uint256(decimalsB);\\r\\n    }\\r\\n\\r\\n    function update() public returns(bool) {\\r\\n        factory = ISwapFactory(factory).newFactory();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getTokens() external view returns(address tokenA, address tokenB) {\\r\\n        tokenA = token;\\r\\n        tokenB = tokenForeign;\\r\\n    }\\r\\n    \\r\\n    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \\r\\n    // into uint256 where high 64 bits is rate and low 192 bit is amount\\r\\n    // rate = foreign token price / native token price\\r\\n    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\\r\\n        require(amount \\u003c MAX_AMOUNT, \\\"Amount overflow\\\");\\r\\n        require(rate \\u003c 2**64, \\\"Rate overflow\\\");\\r\\n        encodedBalance = rate * MAX_AMOUNT + amount;\\r\\n    }\\r\\n\\r\\n    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\\r\\n    // rate = foreign token price / native token price\\r\\n    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\\r\\n        rate = encodedBalance / MAX_AMOUNT;\\r\\n        amount = uint192(encodedBalance);\\r\\n    }\\r\\n\\r\\n    // swapAddress = user address + 1.\\r\\n    // balanceOf contain two types of balance:\\r\\n    // 1. balanceOf[user] - balance of tokens on native chain\\r\\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\\r\\n    function _swapAddress(address user) internal pure returns(address swapAddress) {\\r\\n        swapAddress = address(uint160(user)+1);\\r\\n    }\\r\\n    // 3. balanceOf[user-1] - investment to auction total balance.\\r\\n    function _investAddress(address user) internal pure returns(address investAddress) {\\r\\n        investAddress = address(uint160(user)-1);\\r\\n    }\\r\\n\\r\\n    // call appropriate transfer function\\r\\n    function _transfer(address to, uint value) internal {\\r\\n        if (token \\u003c NATIVE_COINS) \\r\\n            TransferHelper.safeTransferETH(to, value);\\r\\n        else\\r\\n            TransferHelper.safeTransfer(token, to, value);\\r\\n    }\\r\\n\\r\\n    // user\\u0027s deposit to the pool, waiting for swap\\r\\n    function deposit(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\\r\\n        if (isInvestment) {\\r\\n            address investAddress = _investAddress(user);   // on Ethereum side only\\r\\n            balanceOf[investAddress] = (balanceOf[investAddress].add(amount)) | INVESTMENT_FLAG;\\r\\n        }\\r\\n        else {\\r\\n            balanceOf[user] = balanceOf[user].add(amount);\\r\\n        }\\r\\n        totalSupply = totalSupply.add(amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // cancel swap order request\\r\\n    function cancel(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\\r\\n        if (isInvestment) {\\r\\n            address investAddress = _investAddress(user);   // on Ethereum side only\\r\\n            uint256 balance = uint192(balanceOf[investAddress]);\\r\\n            balance = balance.sub(amount,\\\"Not enough tokens on the balance\\\");\\r\\n            balanceOf[investAddress] = balance | INVESTMENT_FLAG;\\r\\n        }\\r\\n        else {\\r\\n            balanceOf[user] = balanceOf[user].sub(amount,\\\"Not enough tokens on the balance\\\");\\r\\n        }\\r\\n        totalSupply = totalSupply.sub(amount,\\\"Not enough Total Supply\\\");\\r\\n        return true;\\r\\n    }\\r\\n    // approve cancel swap order and withdraw token from pool or discard cancel request\\r\\n    // if isInvestment then user = investAddress (user - 1)\\r\\n    function cancelApprove(address user, uint256 amount, bool approve, bool isInvestment) external onlyFactory returns(address, address) {\\r\\n        if (approve) {    //approve cancel\\r\\n            _transfer(user, amount);\\r\\n        }\\r\\n        else {  // discard cancel request.\\r\\n            if (isInvestment)\\r\\n                user = _investAddress(user);   // on Ethereum side only\\r\\n            balanceOf[user] = balanceOf[user].add(amount);\\r\\n            totalSupply = totalSupply.add(amount);\\r\\n        }\\r\\n        return (token, tokenForeign);\\r\\n    }\\r\\n\\r\\n    // request to claim token after swap\\r\\n    function claim(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\\r\\n        address userBalance;\\r\\n        if (isInvestment)\\r\\n            userBalance = _investAddress(user); // on BSC side only\\r\\n        else\\r\\n            userBalance = _swapAddress(user);\\r\\n        balanceOf[userBalance] = balanceOf[userBalance].add(amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // approve / discard claim request\\r\\n    function claimApprove(\\r\\n            address user,\\r\\n            uint256 amount, // foreign token amount to swap\\r\\n            uint256 nativeEncoded,\\r\\n            uint256 foreignSpent,\\r\\n            uint256 rate,\\r\\n            bool approve,\\r\\n            bool isInvestment\\r\\n        ) external onlyFactory returns(address, address, uint256 nativeAmount, uint256 rest) {\\r\\n        address userSwap;\\r\\n        if (isInvestment) {   //claim investment only on BSC side\\r\\n            userSwap = _investAddress(user);    // invest address (real user address - 1)\\r\\n        }\\r\\n        else {\\r\\n            userSwap = _swapAddress(user);  // swap address = real user address + 1\\r\\n        }\\r\\n\\r\\n        if(approve) { // approve claim\\r\\n            (nativeAmount, rest) = calculateAmount(amount,nativeEncoded,foreignSpent,rate);\\r\\n            if (rest != 0) {\\r\\n                balanceOf[userSwap] = balanceOf[userSwap].sub(rest);    // not all amount swapped\\r\\n            }\\r\\n            totalSupply = totalSupply.sub(nativeAmount,\\\"Not enough Total Supply\\\");\\r\\n            if (isInvestment)\\r\\n                ISwapFactory(factory).investAuction{value: nativeAmount}(payable(user));\\r\\n            else\\r\\n                _transfer(user, nativeAmount);\\r\\n        }\\r\\n        else {  // discard claim\\r\\n            balanceOf[userSwap] = balanceOf[userSwap].sub(amount);\\r\\n        }\\r\\n        return (token, tokenForeign, nativeAmount, rest);\\r\\n    }\\r\\n\\r\\n    function calculateAmount(\\r\\n        uint256 foreignAmount,\\r\\n        uint256 nativeEncoded,\\r\\n        uint256 foreignSpent,\\r\\n        uint256 rate    // Foreign token price / Native token price = (Native amount / Foreign amount)\\r\\n    ) internal returns(uint256 nativeAmount, uint256 rest) {\\r\\n        uint256 nativeDecimals = decimalsNative;\\r\\n        uint256 foreignDecimals = decimalsForeign;\\r\\n        \\r\\n        // step 1. Check is it enough unspent native tokens\\r\\n        {\\r\\n            (uint256 rate1, uint256 amount1) = _decode(nativeEncoded);  // rate1 = Native token price / Foreign token price\\r\\n            rate1 = rate1*NOMINATOR*foreignDecimals/nativeDecimals;\\r\\n            amount1 = amount1.sub(balanceOf[NATIVE], \\\"NativeSpent balance higher then remote\\\");\\r\\n            // rate1, amount1 - rate and amount ready to spend native tokens\\r\\n            if (amount1 != 0) {\\r\\n                uint256 requireAmount = foreignAmount.mul(PRICE_NOMINATOR*NOMINATOR).div(rate1);\\r\\n                if (requireAmount \\u003c= amount1) {\\r\\n                    nativeAmount = requireAmount;\\r\\n                    foreignAmount = 0;\\r\\n                }\\r\\n                else {\\r\\n                    nativeAmount = amount1;\\r\\n                    foreignAmount = (requireAmount - amount1).mul(rate1) / (PRICE_NOMINATOR*NOMINATOR);\\r\\n                }\\r\\n                balanceOf[NATIVE] = balanceOf[NATIVE].add(nativeAmount);\\r\\n            }\\r\\n        }\\r\\n        require(totalSupply \\u003e= nativeAmount,\\\"ERR: Not enough Total Supply\\\");\\r\\n        // step 2. recalculate rate for swapped tokens\\r\\n        if (foreignAmount != 0) {\\r\\n            uint256 rate2 = rate.mul(NOMINATOR).mul(nativeDecimals).div(foreignDecimals);\\r\\n            uint256 requireAmount = foreignAmount.mul(rate2) / (PRICE_NOMINATOR*NOMINATOR);\\r\\n            if (totalSupply \\u003c nativeAmount.add(requireAmount)) {\\r\\n                requireAmount = totalSupply.sub(nativeAmount);\\r\\n                rest = foreignAmount.sub(requireAmount.mul(PRICE_NOMINATOR*NOMINATOR).div(rate2));\\r\\n                foreignAmount = foreignAmount.sub(rest);\\r\\n            }\\r\\n            nativeAmount = nativeAmount.add(requireAmount);\\r\\n            uint256 amount;\\r\\n            (rate2, amount) = _decode(balanceOf[FOREIGN]);\\r\\n            rate2 = rate2.mul(NOMINATOR).mul(nativeDecimals).div(foreignDecimals);\\r\\n            uint256 amount2 = amount.sub(foreignSpent, \\\"ForeignSpent balance higher then local\\\");\\r\\n            // rate2, amount2 - rate and amount swapped foreign tokens\\r\\n\\r\\n            if (amount2 != 0) { // recalculate avarage rate (native amount / foreign amount)\\r\\n                rate =  ((amount2.mul(rate2)/(PRICE_NOMINATOR*NOMINATOR)).add(requireAmount)).mul(PRICE_NOMINATOR*foreignDecimals).div((amount2.add(foreignAmount)).mul(nativeDecimals));\\r\\n            }\\r\\n            balanceOf[FOREIGN] = _encode(rate, amount.add(foreignAmount));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        require(msg.sender == factory, \\\"Not a factory\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"CancelApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"CancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"ClaimApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"ClaimRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ExchangeInvestETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"SwapRequest\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balanceForeign\",\"type\":\"uint256\"}],\"name\":\"balanceCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balanceForeign\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeEncoded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreignSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"balancesCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cancelAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelInvestment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changeExchangeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changeExcludedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"claimInvestmentBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"claimTokenBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSmart\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"contributeWithEtherBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimalsA\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimalsB\",\"type\":\"uint8\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreignFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foreignPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"investAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"pairAddressFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setForeignFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMSSContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setNewFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenA\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenB\",\"type\":\"address[]\"},{\"internalType\":\"address payable[]\",\"name\":\"pair\",\"type\":\"address[]\"}],\"name\":\"setPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"}],\"name\":\"setSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapInvestment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"system\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SwapFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000AcAa64D0797cD95cDfcC1De55ed9e570DcbEE84c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3571df6aa462a0fc9474291110f15a85a277c5fa6552b3a903757136e0307ec3"}]}