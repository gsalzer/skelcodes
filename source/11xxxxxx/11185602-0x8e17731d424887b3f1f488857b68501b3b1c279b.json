{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetConverterHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./ACOAssetHelper.sol\\u0027;\\r\\nimport \\u0027./IACOAssetConverterHelper.sol\\u0027;\\r\\nimport \\u0027./IUniswapV2Router02.sol\\u0027;\\r\\nimport \\u0027./AggregatorV3Interface.sol\\u0027;\\r\\nimport \\u0027./IWETH.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOAssetConverterHelper\\r\\n * @dev A contract to swap assets on Uniswap with a Chainlink oracle protection.\\r\\n */\\r\\ncontract ACOAssetConverterHelper is Ownable, IACOAssetConverterHelper {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n    \\t\\r\\n    /**\\r\\n     * @dev The percentage precision. (100000 = 100%)\\r\\n     */\\r\\n    uint256 public constant PERCENTAGE_PRECISION = 100000;\\r\\n    \\r\\n    /**\\r\\n     * @dev Struct to store the pair data.\\r\\n     */\\r\\n    struct PairData {\\r\\n        /**\\r\\n         * @dev True if the pair was initialized.\\r\\n         */\\r\\n        bool initialized;\\r\\n        \\r\\n        /**\\r\\n         * @dev Address of the Oracle aggregator.\\r\\n         */\\r\\n        address aggregator;\\r\\n        \\r\\n        /**\\r\\n         * @dev Oracle aggregator precision. (8 decimals = 100000000)\\r\\n         */\\r\\n        uint256 aggregatorPrecision;\\r\\n        \\r\\n        /**\\r\\n         * @dev The tolerance percentage for the price on the Oracle.\\r\\n         */\\r\\n        uint256 tolerancePercentage;\\r\\n        \\r\\n        /**\\r\\n         * @dev Addresses of Uniswap middle route for a swap.\\r\\n         */\\r\\n        address[] uniswapMiddleRoute;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Emitted when the Oracle aggregator data has been changed.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param previousAggregator Address of the previous Oracle aggregator.\\r\\n     * @param newAggregator Address of the new Oracle aggregator.\\r\\n     */\\r\\n    event SetAggregator(address indexed baseAsset, address indexed quoteAsset, address previousAggregator, address newAggregator);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the addresses of Uniswap middle route for a swap has been changed.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param previousUniswapMiddleRoute Previous addresses of Uniswap middle route for a swap.\\r\\n     * @param newUniswapMiddleRoute New addresses of Uniswap middle route for a swap.\\r\\n     */\\r\\n    event SetUniswapMiddleRoute(address indexed baseAsset, address indexed quoteAsset, address[] previousUniswapMiddleRoute, address[] newUniswapMiddleRoute);\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Emitted when the tolerance percentage for the pair price on the Oracle has been changed.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param oldTolerancePercentage Value of the previous tolerance percentage for the price on the Oracle.\\r\\n     * @param newTolerancePercentage Value of the new tolerance percentage for the price on the Oracle.\\r\\n     */\\r\\n\\tevent SetPairTolerancePercentage(address indexed baseAsset, address indexed quoteAsset, uint256 oldTolerancePercentage, uint256 newTolerancePercentage);\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Address of the Uniswap V2 router.\\r\\n\\t */\\r\\n    IUniswapV2Router02 public immutable uniswapRouter;\\r\\n    \\r\\n    /**\\r\\n\\t * @dev Address of the WETH.\\r\\n\\t */\\r\\n    address public immutable WETH;\\r\\n\\r\\n\\t/**\\r\\n     * @dev The Oracle aggregators data. (baseAsset =\\u003e quoteAsset =\\u003e PairData)\\r\\n     */\\r\\n    mapping(address =\\u003e mapping(address =\\u003e PairData)) internal pairs; \\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The asset precision. (6 decimals = 1000000)\\r\\n     */\\r\\n    mapping(address =\\u003e uint256) public assetPrecision;\\r\\n    \\r\\n    constructor(address _uniswapRouter) public {\\r\\n\\t\\tsuper.init();\\r\\n\\t\\t\\r\\n\\t\\tuniswapRouter = IUniswapV2Router02(_uniswapRouter);\\r\\n\\t\\tWETH = IUniswapV2Router02(_uniswapRouter).WETH();\\r\\n    }\\r\\n    \\r\\n    receive() external payable {\\r\\n        require(msg.sender != tx.origin, \\\"ACOAssetConverterHelper:: Only contracts can send ether\\\");\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the tolerance percentage for the pair price on the Oracle.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage for the price on the Oracle.\\r\\n     */\\r\\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) onlyOwner public override {\\r\\n        require(tolerancePercentage \\u003c= PERCENTAGE_PRECISION, \\\"ACOAssetConverterHelper:: Invalid tolerance percentage\\\");\\r\\n        (bool reversed, PairData storage data) = _getPair(baseAsset, quoteAsset, false);\\r\\n        if (data.initialized) {\\r\\n\\t\\t\\tif (reversed) {\\r\\n\\t\\t\\t\\temit SetPairTolerancePercentage(quoteAsset, baseAsset, data.tolerancePercentage, tolerancePercentage);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\temit SetPairTolerancePercentage(baseAsset, quoteAsset, data.tolerancePercentage, tolerancePercentage);\\r\\n\\t\\t\\t}\\r\\n            data.tolerancePercentage = tolerancePercentage;\\r\\n        } else {\\r\\n\\t\\t\\temit SetPairTolerancePercentage(baseAsset, quoteAsset, 0, tolerancePercentage);\\r\\n            _createPair(baseAsset, quoteAsset, address(0), 0, tolerancePercentage, new address[](0));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the the Oracle aggregator data.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @param aggregator Address of the Oracle aggregator.\\r\\n     */\\r\\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) onlyOwner public override {\\r\\n        require(aggregator.isContract(), \\\"ACOAssetConverterHelper:: Invalid aggregator\\\");\\r\\n        uint256 aggregatorPrecision = (10 ** uint256(AggregatorV3Interface(aggregator).decimals()));\\r\\n        (bool reversed, PairData storage data) = _getPair(baseAsset, quoteAsset, false);\\r\\n        if (data.initialized) {\\r\\n\\t\\t\\tif (reversed) {\\r\\n\\t\\t\\t\\temit SetAggregator(quoteAsset, baseAsset, data.aggregator, aggregator);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\temit SetAggregator(baseAsset, quoteAsset, data.aggregator, aggregator);\\r\\n\\t\\t\\t}\\r\\n            data.aggregator = aggregator;\\r\\n            data.aggregatorPrecision = aggregatorPrecision;\\r\\n        } else {\\r\\n\\t\\t\\temit SetAggregator(baseAsset, quoteAsset, address(0), aggregator);\\r\\n            _createPair(baseAsset, quoteAsset, aggregator, aggregatorPrecision, 0, new address[](0));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the addresses of Uniswap middle route for a swap.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n     */\\r\\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] memory uniswapMiddleRoute) onlyOwner public override {\\r\\n        _validateUniswapMiddleRoute(baseAsset, quoteAsset, uniswapMiddleRoute);\\r\\n        (bool reversed, PairData storage data) = _getPair(baseAsset, quoteAsset, false);\\r\\n        if (data.initialized) {\\r\\n            if (reversed) {\\r\\n                address[] memory route = new address[](uniswapMiddleRoute.length);\\r\\n                uint256 index = 0;\\r\\n                for (uint256 i = uniswapMiddleRoute.length; i \\u003e 0; --i) {\\r\\n                    route[index] = uniswapMiddleRoute[i-1];\\r\\n                    ++index;\\r\\n                }\\r\\n\\t\\t\\t\\temit SetUniswapMiddleRoute(quoteAsset, baseAsset, data.uniswapMiddleRoute, route);\\r\\n                delete data.uniswapMiddleRoute;\\r\\n                data.uniswapMiddleRoute = route;\\r\\n            } else {\\r\\n\\t\\t\\t\\temit SetUniswapMiddleRoute(baseAsset, quoteAsset, data.uniswapMiddleRoute, uniswapMiddleRoute);\\r\\n                delete data.uniswapMiddleRoute;\\r\\n                data.uniswapMiddleRoute = uniswapMiddleRoute;\\r\\n            }\\r\\n        } else {\\r\\n\\t\\t\\temit SetUniswapMiddleRoute(baseAsset, quoteAsset, new address[](0), uniswapMiddleRoute);\\r\\n            _createPair(baseAsset, quoteAsset, address(0), 0, 0, uniswapMiddleRoute);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to withdraw a stuck asset on the contract.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param destination Address of the destination.\\r\\n     */\\r\\n    function withdrawStuckAsset(address asset, address destination) onlyOwner public override {\\r\\n        uint256 amount = ACOAssetHelper._getAssetBalanceOf(asset, address(this));\\r\\n        if (amount \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(asset, destination, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to check if the contract has an aggregator.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @return True if an aggregator is set.\\r\\n     */\\r\\n    function hasAggregator(address baseAsset, address quoteAsset) public override view returns(bool) {\\r\\n        (,PairData storage data) = _getPair(baseAsset, quoteAsset, false);\\r\\n        return (data.aggregator != address(0));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the pair data\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @return Aggregator, aggregator precision, tolerance percentage, Uniswap middle route length.\\r\\n     */\\r\\n    function getPairData(address baseAsset, address quoteAsset) public override view returns(address, uint256, uint256, uint256) {\\r\\n        (,PairData storage data) = _getPair(baseAsset, quoteAsset, false);\\r\\n        return (data.aggregator, data.aggregatorPrecision, data.tolerancePercentage, data.uniswapMiddleRoute.length);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get an Uniswap middle route token by array index.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param index Th array index.\\r\\n\\t * @return The Uniswap middle route token.\\r\\n     */\\r\\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) public override view returns(address) {\\r\\n        (bool reversed, PairData memory data) = _getPair(baseAsset, quoteAsset, false);\\r\\n        if (reversed) {\\r\\n            if (index \\u003e= data.uniswapMiddleRoute.length) {\\r\\n                return address(0);\\r\\n            } else {\\r\\n                return data.uniswapMiddleRoute[(data.uniswapMiddleRoute.length - index - 1)];    \\r\\n            }\\r\\n        } else {\\r\\n            return data.uniswapMiddleRoute[index];\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get the price on the Oracle aggregator.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @return The price with the quote asset precision.\\r\\n     */\\r\\n    function getPrice(address baseAsset, address quoteAsset) public override view returns(uint256) {\\r\\n        (uint256 price,) = _getAggregatorPriceAndTolerance(baseAsset, quoteAsset);  \\r\\n        return price;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get a price with tolerance.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param isMinimumPrice True if is the minimum price, otherwise is the maximum price.\\r\\n\\t * @return The price with a tolerance percentage and on quote asset precision.\\r\\n     */\\r\\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) public override view returns(uint256) {\\r\\n        (uint256 price, uint256 tolerancePercentage) = _getAggregatorPriceAndTolerance(baseAsset, quoteAsset);\\r\\n        return _getPriceWithTolerance(price, tolerancePercentage, isMinimumPrice);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the expected amount to be sold to swap for an exact amount to be purchased.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToBuy Amount to be purchased.\\r\\n\\t * @return The expected amount to be sold.\\r\\n     */\\r\\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) public override view returns(uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, true);\\r\\n        return _getMaxAmountToSoldToSwapExactAmountIn(assetToSold, assetToBuy, amountToBuy, data.tolerancePercentage, reversed, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the expected amount to be sold to swap for an exact amount to be purchased and specifying a tolerance percentage on Oracle.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToBuy Amount to be purchased.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage. (100% = 100000)\\r\\n\\t * @return The expected amount to be sold.\\r\\n     */\\r\\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) public override view returns(uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, true);\\r\\n        return _getMaxAmountToSoldToSwapExactAmountIn(assetToSold, assetToBuy, amountToBuy, tolerancePercentage, reversed, data);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap assets with the exact amount of asset to be sold.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToSold Amount to be sold.\\r\\n\\t * @return The amount of the asset purchased.\\r\\n     */\\r\\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) public payable override returns(uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, true);\\r\\n        return _swapExactAmountOut(assetToSold, assetToBuy, amountToSold, data.tolerancePercentage, reversed, data);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap assets with the exact amount of asset to be sold and specifying a tolerance percentage on Oracle.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToSold Amount to be sold.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage. (100% = 100000)\\r\\n\\t * @return The amount of the asset purchased.\\r\\n     */\\r\\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) public payable override returns(uint256) {\\r\\n        require(tolerancePercentage \\u003c= PERCENTAGE_PRECISION, \\\"ACOAssetConverterHelper:: Invalid tolerance percentage\\\");\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, true);\\r\\n        return _swapExactAmountOut(assetToSold, assetToBuy, amountToSold, tolerancePercentage, reversed, data);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap assets with the exact amount of asset to be sold.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToSold Amount to be sold.\\r\\n     * @param minAmountToReceive The minimum amount to receive.\\r\\n\\t * @return The amount of the asset purchased.\\r\\n     */\\r\\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) public payable override returns(uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, false);\\r\\n        _setAsset(assetToSold);\\r\\n        return _swapExactAmountOutWithMinAmountToReceive(assetToSold, assetToBuy, amountToSold, minAmountToReceive, reversed, data.uniswapMiddleRoute);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap assets with the exact amount of asset to be purchased.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToBuy Amount to be purchased.\\r\\n\\t * @return The amount of the asset sold.\\r\\n     */\\r\\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) public payable override returns(uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, true);\\r\\n        return _swapExactAmountIn(assetToSold, assetToBuy, amountToBuy, data.tolerancePercentage, reversed, data);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap assets with the exact amount of asset to be purchased and specifying a tolerance percentage on Oracle.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToBuy Amount to be purchased.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage. (100% = 100000)\\r\\n\\t * @return The amount of the asset sold.\\r\\n     */\\r\\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) public payable override returns(uint256) {\\r\\n        require(tolerancePercentage \\u003c= PERCENTAGE_PRECISION, \\\"ACOAssetConverterHelper:: Invalid tolerance percentage\\\");\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, true);\\r\\n        return _swapExactAmountIn(assetToSold, assetToBuy, amountToBuy, tolerancePercentage, reversed, data);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap assets with the exact amount of asset to be purchased.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToBuy Amount to be purchased.\\r\\n     * @param maxAmountToSold The maximum amount to be sold.\\r\\n\\t * @return The amount of the asset sold.\\r\\n     */\\r\\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) public payable override returns(uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(assetToSold, assetToBuy, false);\\r\\n        _setAsset(assetToSold);\\r\\n        return _swapExactAmountInWithMaxAmountToSold(assetToSold, assetToBuy, amountToBuy, maxAmountToSold, reversed, data.uniswapMiddleRoute);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets with the exact amount of asset to be purchased.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amount Amount to be purchased.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage. (100% = 100000)\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param data The pair data.\\r\\n\\t * @return The amount of the asset sold.\\r\\n     */\\r\\n    function _swapExactAmountIn(\\r\\n        address assetToSold, \\r\\n        address assetToBuy, \\r\\n        uint256 amount, \\r\\n        uint256 tolerancePercentage,\\r\\n        bool reversed,\\r\\n        PairData storage data\\r\\n    ) internal returns(uint256) {\\r\\n        uint256 maxAmountToSold = _getMaxAmountToSoldToSwapExactAmountIn(\\r\\n            assetToSold,\\r\\n            assetToBuy,\\r\\n            amount,\\r\\n            tolerancePercentage,\\r\\n            reversed,\\r\\n            data\\r\\n        );\\r\\n        return _swapExactAmountInWithMaxAmountToSold(assetToSold, assetToBuy, amount, maxAmountToSold, reversed, data.uniswapMiddleRoute);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get the max amount to be sold.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amount Amount to be purchased.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage. (100% = 100000)\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param data The pair data.\\r\\n\\t * @return The max amount to be sold.\\r\\n     */\\r\\n    function _getMaxAmountToSoldToSwapExactAmountIn(\\r\\n        address assetToSold, \\r\\n        address assetToBuy, \\r\\n        uint256 amount, \\r\\n        uint256 tolerancePercentage,\\r\\n        bool reversed,\\r\\n        PairData storage data\\r\\n    ) internal view returns(uint256) {\\r\\n        uint256 price = _getPriceWithTolerance(_getAggregatorPriceValue(assetToBuy, reversed, data), tolerancePercentage, true);\\r\\n        return amount.mul(assetPrecision[assetToSold]).div(price);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets with the exact amount of asset to be purchased.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToBuy Amount to be purchased.\\r\\n     * @param maxAmountToSold The maximum amount to be sold.\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n\\t * @return The amount of the asset sold.\\r\\n     */\\r\\n    function _swapExactAmountInWithMaxAmountToSold(\\r\\n        address assetToSold, \\r\\n        address assetToBuy, \\r\\n        uint256 amountToBuy, \\r\\n        uint256 maxAmountToSold,\\r\\n        bool reversed,\\r\\n        address[] storage uniswapMiddleRoute\\r\\n    ) internal returns(uint256) {\\r\\n        uint256 previousAmount = ACOAssetHelper._getAssetBalanceOf(assetToSold, address(this));\\r\\n        \\r\\n        if (ACOAssetHelper._isEther(assetToSold)) {\\r\\n            previousAmount = previousAmount.sub(msg.value);\\r\\n            require(msg.value \\u003e= maxAmountToSold, \\\"ACOAssetConverterHelper:: Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOAssetConverterHelper:: Ether is not expected\\\");\\r\\n            ACOAssetHelper._callTransferFromERC20(assetToSold, msg.sender, address(this), maxAmountToSold);\\r\\n        }\\r\\n\\r\\n        _swapAssetsExactAmountIn(assetToSold, assetToBuy, amountToBuy, maxAmountToSold, reversed, uniswapMiddleRoute);\\r\\n        \\r\\n        uint256 afterAmount = ACOAssetHelper._getAssetBalanceOf(assetToSold, address(this));\\r\\n        uint256 remaining = afterAmount.sub(previousAmount);\\r\\n        if (remaining \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(assetToSold, msg.sender, remaining);\\r\\n        }\\r\\n        ACOAssetHelper._transferAsset(assetToBuy, msg.sender, amountToBuy);\\r\\n        return maxAmountToSold.sub(remaining);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets with the exact amount of asset to be sold.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amount Amount to be sold.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage. (100% = 100000)\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param data The pair data.\\r\\n\\t * @return The amount of the asset purchased.\\r\\n     */\\r\\n    function _swapExactAmountOut(\\r\\n        address assetToSold, \\r\\n        address assetToBuy, \\r\\n        uint256 amount, \\r\\n        uint256 tolerancePercentage,\\r\\n        bool reversed,\\r\\n        PairData storage data\\r\\n    ) internal returns(uint256) {\\r\\n        uint256 price = _getPriceWithTolerance(_getAggregatorPriceValue(assetToBuy, reversed, data), tolerancePercentage, true);\\r\\n        uint256 minAmountToReceive = price.mul(amount).div(assetPrecision[assetToSold]);\\r\\n        \\r\\n        return _swapExactAmountOutWithMinAmountToReceive(assetToSold, assetToBuy, amount, minAmountToReceive, reversed, data.uniswapMiddleRoute);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets with the exact amount of asset to be sold.\\r\\n     * @param assetToSold Address of the asset to be sold.\\r\\n     * @param assetToBuy Address of the asset to be purchased.\\r\\n     * @param amountToSold Amount to be sold.\\r\\n     * @param minAmountToReceive The minimum amount to receive.\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n\\t * @return The amount of the asset purchased.\\r\\n     */\\r\\n    function _swapExactAmountOutWithMinAmountToReceive(\\r\\n        address assetToSold, \\r\\n        address assetToBuy, \\r\\n        uint256 amountToSold, \\r\\n        uint256 minAmountToReceive,\\r\\n        bool reversed,\\r\\n        address[] storage uniswapMiddleRoute\\r\\n    ) internal returns(uint256) {\\r\\n        ACOAssetHelper._receiveAsset(assetToSold, amountToSold);\\r\\n        \\r\\n        uint256 previousAmount = ACOAssetHelper._getAssetBalanceOf(assetToBuy, address(this));\\r\\n        \\r\\n        _swapAssetsExactAmountOut(assetToSold, assetToBuy, amountToSold, minAmountToReceive, reversed, uniswapMiddleRoute);\\r\\n        \\r\\n        uint256 afterAmount = ACOAssetHelper._getAssetBalanceOf(assetToBuy, address(this));\\r\\n        uint256 purchased = afterAmount.sub(previousAmount);\\r\\n        ACOAssetHelper._transferAsset(assetToBuy, msg.sender, purchased);\\r\\n        return purchased;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to validate the addresses on the Uniswap middle route.\\r\\n     * @param asset0 Address of a pair asset.\\r\\n     * @param asset1 Address of another pair asset.\\r\\n\\t * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n     */\\r\\n    function _validateUniswapMiddleRoute(address asset0, address asset1, address[] memory uniswapMiddleRoute) internal pure {\\r\\n        for (uint256 i = 0; i \\u003c uniswapMiddleRoute.length; ++i) {\\r\\n            address asset = uniswapMiddleRoute[i];\\r\\n            require(asset0 != asset \\u0026\\u0026 asset1 != asset, \\\"ACOAssetConverterHelper:: Invalid middle route\\\");\\r\\n            for (uint256 j = i+1; j \\u003c uniswapMiddleRoute.length; ++j) {\\r\\n                require(asset != uniswapMiddleRoute[j], \\\"ACOAssetConverterHelper:: Invalid middle route\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get a price with tolerance.\\r\\n     * @param price Oracle price value.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage.\\r\\n     * @param isMinimumPrice True if is the minimum price, otherwise is the maximum price.\\r\\n\\t * @return The price with a tolerance percentage.\\r\\n     */\\r\\n    function _getPriceWithTolerance(uint256 price, uint256 tolerancePercentage, bool isMinimumPrice) internal pure returns(uint256) {\\r\\n        if (isMinimumPrice) {\\r\\n            return price.mul(PERCENTAGE_PRECISION.sub(tolerancePercentage)).div(PERCENTAGE_PRECISION);\\r\\n        } else {\\r\\n            return price.mul(PERCENTAGE_PRECISION.add(tolerancePercentage)).div(PERCENTAGE_PRECISION);    \\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get the pair data.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param validateAggregatorExistence True if an exception should be thrown and the pair aggregator does not exist.\\r\\n\\t * @return If the assets are reversed and the pair data.\\r\\n     */\\r\\n    function _getPair(address baseAsset, address quoteAsset, bool validateAggregatorExistence) internal view returns(bool, PairData storage) {\\r\\n        PairData storage data = pairs[baseAsset][quoteAsset];\\r\\n        if (data.initialized) {\\r\\n\\t\\t\\trequire(!validateAggregatorExistence || data.aggregator != address(0), \\\"ACOAssetConverterHelper:: No aggregator\\\");\\r\\n            return (false, data);\\r\\n        } else {\\r\\n\\t\\t\\tPairData storage data2 = pairs[quoteAsset][baseAsset];\\r\\n\\t\\t\\trequire(!validateAggregatorExistence || data2.aggregator != address(0), \\\"ACOAssetConverterHelper:: No aggregator\\\");\\r\\n\\t\\t\\treturn (data2.initialized, data2);\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the price on the Oracle aggregator.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @return The price with the quote asset precision and the oracle tolerance percentage.\\r\\n     */\\r\\n    function _getAggregatorPriceAndTolerance(address baseAsset, address quoteAsset) internal view returns(uint256, uint256) {\\r\\n        (bool reversed, PairData storage data) = _getPair(baseAsset, quoteAsset, true);\\r\\n        uint256 price = _getAggregatorPriceValue(quoteAsset, reversed, data);\\r\\n        return (price, data.tolerancePercentage);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the price value on the Oracle aggregator.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n     * @param reversed Assets are reversed on the aggregator.\\r\\n     * @param data Pair data.\\r\\n\\t * @return The price with the quote asset precision.\\r\\n     */\\r\\n    function _getAggregatorPriceValue(address quoteAsset, bool reversed, PairData storage data) internal view returns(uint256) {\\r\\n        (,int256 answer,,,) = AggregatorV3Interface(data.aggregator).latestRoundData();\\r\\n        \\r\\n        uint256 _aggregatorPrecision = data.aggregatorPrecision;\\r\\n        uint256 _assetPrecision = assetPrecision[quoteAsset];\\r\\n        \\r\\n        if (reversed) {\\r\\n            return _aggregatorPrecision.mul(_assetPrecision).div(uint256(answer));\\r\\n        } else if (_aggregatorPrecision \\u003e _assetPrecision) {\\r\\n            return uint256(answer).div(_aggregatorPrecision.div(_assetPrecision));\\r\\n        } else {\\r\\n            return uint256(answer).mul(_assetPrecision).div(_aggregatorPrecision);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to create a pair data.\\r\\n     * @param baseAsset Address of the base asset.\\r\\n     * @param quoteAsset Address of the quote asset.\\r\\n\\t * @param aggregator Address of the Oracle aggregator.\\r\\n\\t * @param aggregatorPrecision Value of the aggregator precision.\\r\\n     * @param tolerancePercentage Value of the tolerance percentage.\\r\\n     * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n     */\\r\\n\\tfunction _createPair(\\r\\n\\t    address baseAsset,\\r\\n\\t    address quoteAsset,\\r\\n\\t    address aggregator, \\r\\n\\t    uint256 aggregatorPrecision,\\r\\n\\t    uint256 tolerancePercentage, \\r\\n\\t    address[] memory uniswapMiddleRoute\\r\\n    ) internal {\\r\\n        require(baseAsset != quoteAsset, \\\"ACOAssetConverterHelper:: Invalid assets\\\");\\r\\n        require(ACOAssetHelper._isEther(baseAsset) || baseAsset.isContract(), \\\"ACOAssetConverterHelper:: Invalid base asset\\\");\\r\\n        require(ACOAssetHelper._isEther(quoteAsset) || quoteAsset.isContract(), \\\"ACOAssetConverterHelper:: Invalid quote asset\\\");\\r\\n        \\r\\n        _setAsset(baseAsset);\\r\\n        _setAsset(quoteAsset);\\r\\n        \\r\\n        pairs[baseAsset][quoteAsset] = PairData(true, aggregator, aggregatorPrecision, tolerancePercentage, uniswapMiddleRoute);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set the asset precision and authorize the Uniswap V2 router. (6 decimals = 1000000)\\r\\n     * @param asset Address of the asset.\\r\\n     */\\r\\n    function _setAsset(address asset) internal {\\r\\n        if (assetPrecision[asset] == 0) {\\r\\n            uint256 decimals = ACOAssetHelper._getAssetDecimals(asset);\\r\\n            assetPrecision[asset] = (10 ** decimals);\\r\\n            if (!ACOAssetHelper._isEther(asset)) {\\r\\n                ACOAssetHelper._callApproveERC20(asset, address(uniswapRouter), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get Uniswap V2 router path.\\r\\n     * @param assetOut Address of the asset to be sold.\\r\\n\\t * @param assetIn Address of the asset to be purchased.\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n     * @return The Uniswap V2 router path.\\r\\n     */\\r\\n\\tfunction _getUniswapRouterPath(address assetOut, address assetIn, bool reversed, address[] storage uniswapMiddleRoute) internal view returns(address[] memory) {\\r\\n        address[] memory path = new address[](2 + uniswapMiddleRoute.length);\\r\\n        address end;\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n            path[0] = WETH;\\r\\n            end = assetIn;\\r\\n        } else if (ACOAssetHelper._isEther(assetIn)) {\\r\\n            path[0] = assetOut;\\r\\n            end = WETH;\\r\\n        } else {\\r\\n            path[0] = assetOut;\\r\\n            end = assetIn;\\r\\n        }\\r\\n        uint256 index = 1;\\r\\n        uint256 i = (uniswapMiddleRoute.length \\u003e 0 \\u0026\\u0026 reversed ? (uniswapMiddleRoute.length - 1) : 0);\\r\\n        while (i \\u003c uniswapMiddleRoute.length \\u0026\\u0026 i \\u003e= 0) {\\r\\n            path[index] = uniswapMiddleRoute[i];\\r\\n            if (reversed) {\\r\\n                --i;\\r\\n            } else {\\r\\n                ++i;\\r\\n            }\\r\\n            ++index;\\r\\n        }\\r\\n        path[index] = end;\\r\\n        return path;\\r\\n\\t}\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Internal function to swap assets on the Uniswap V2 with an exact amount of an asset to be sold.\\r\\n     * @param assetOut Address of the asset to be sold.\\r\\n\\t * @param assetIn Address of the asset to be purchased.\\r\\n     * @param amountOut The exact amount to be sold.\\r\\n     * @param minAmountIn Minimum amount to be received.\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n     */\\r\\n    function _swapAssetsExactAmountOut(\\r\\n        address assetOut, \\r\\n        address assetIn, \\r\\n        uint256 amountOut, \\r\\n        uint256 minAmountIn,\\r\\n        bool reversed,\\r\\n        address[] storage uniswapMiddleRoute\\r\\n    ) internal {\\r\\n        address[] memory path = _getUniswapRouterPath(assetOut, assetIn, reversed, uniswapMiddleRoute);\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n            uniswapRouter.swapExactETHForTokens{value: amountOut}(minAmountIn, path, address(this), block.timestamp);\\r\\n        } else if (ACOAssetHelper._isEther(assetIn)) {\\r\\n            uniswapRouter.swapExactTokensForETH(amountOut, minAmountIn, path, address(this), block.timestamp);\\r\\n        } else {\\r\\n            uniswapRouter.swapExactTokensForTokens(amountOut, minAmountIn, path, address(this), block.timestamp);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets on the Uniswap V2 with an exact amount of an asset to be purchased.\\r\\n     * @param assetOut Address of the asset to be sold.\\r\\n\\t * @param assetIn Address of the asset to be purchased.\\r\\n     * @param amountIn The exact amount to be purchased.\\r\\n     * @param maxAmountOut Maximum amount to be paid.\\r\\n     * @param reversed If the pairs are reversed.\\r\\n     * @param uniswapMiddleRoute Addresses of Uniswap middle route for a swap.\\r\\n     */\\r\\n    function _swapAssetsExactAmountIn(\\r\\n        address assetOut, \\r\\n        address assetIn, \\r\\n        uint256 amountIn, \\r\\n        uint256 maxAmountOut, \\r\\n        bool reversed,\\r\\n        address[] storage uniswapMiddleRoute\\r\\n    ) internal {\\r\\n        address[] memory path = _getUniswapRouterPath(assetOut, assetIn, reversed, uniswapMiddleRoute);\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n            uniswapRouter.swapETHForExactTokens{value: maxAmountOut}(amountIn, path, address(this), block.timestamp);\\r\\n        } else if (ACOAssetHelper._isEther(assetIn)) {\\r\\n            uniswapRouter.swapTokensForExactETH(amountIn, maxAmountOut, path, address(this), block.timestamp);\\r\\n        } else {\\r\\n            uniswapRouter.swapTokensForExactTokens(amountIn, maxAmountOut, path, address(this), block.timestamp);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callApproveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferFromERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetDecimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetName\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetAllowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\u0027ACOAssetHelper::_transferAsset\\u0027);\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"ACOAssetHelper:: Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOAssetHelper:: Ether is not expected\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"AggregatorV3Interface.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\\r\\n\"},\"IACOAssetConverterHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOAssetConverterHelper {\\r\\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\\r\\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\\r\\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\\r\\n    function withdrawStuckAsset(address asset, address destination) external;\\r\\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\\r\\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\\r\\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\\r\\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\\r\\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\\r\\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\\r\\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\\r\\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity 0.6.6;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"IWETH.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Adapted from OpenZeppelin\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function init() internal {\\r\\n        require(_owner == address(0), \\\"Ownable: Contract initialized\\\");\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAggregator\",\"type\":\"address\"}],\"name\":\"SetAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTolerancePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTolerancePercentage\",\"type\":\"uint256\"}],\"name\":\"SetPairTolerancePercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"previousUniswapMiddleRoute\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newUniswapMiddleRoute\",\"type\":\"address[]\"}],\"name\":\"SetUniswapMiddleRoute\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PERCENTAGE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetPrecision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToBuy\",\"type\":\"uint256\"}],\"name\":\"getExpectedAmountOutToSwapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePercentage\",\"type\":\"uint256\"}],\"name\":\"getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"getPairData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isMinimumPrice\",\"type\":\"bool\"}],\"name\":\"getPriceWithTolerance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUniswapMiddleRouteByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"}],\"name\":\"hasAggregator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"setAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePercentage\",\"type\":\"uint256\"}],\"name\":\"setPairTolerancePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAsset\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"uniswapMiddleRoute\",\"type\":\"address[]\"}],\"name\":\"setUniswapMiddleRoute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToBuy\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountToSold\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountInWithMaxAmountToSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePercentage\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountInWithSpecificTolerance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToSold\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountToReceive\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOutWithMinAmountToReceive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToSold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToBuy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePercentage\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOutWithSpecificTolerance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawStuckAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOAssetConverterHelper","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e2610df84053738597e75cdbe37b329108aa2fdebff4d329238896fee9f4be68"}]}