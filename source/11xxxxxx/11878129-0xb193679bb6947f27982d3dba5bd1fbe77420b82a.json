{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n// These definitions are taken from across multiple dydx contracts, and are\r\n// limited to just the bare minimum necessary to make flash loans work.\r\nlibrary Types {\r\n    enum AssetDenomination { Wei, Par }\r\n    enum AssetReference { Delta, Target }\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Account {\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\r\n    }\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n\r\ninterface ISoloMargin {\r\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\r\n}\r\n\r\n// The interface for a contract to be callable after receiving a flash loan\r\ninterface ICallee {\r\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external;\r\n}\r\n\r\n// Standard ERC-20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Additional methods available for WETH\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\ncontract FlashBotsMultiCall02 is ICallee {\r\n    \r\n    struct ArbitrageData {\r\n        uint256 wethAmountToFirstMarket;\r\n        uint256 ethAmountToCoinbase;\r\n        address[] targets;\r\n        bytes[] payloads;\r\n    }\r\n\r\n    // The WETH token contract, since we're assuming we want a loan in WETH\r\n    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    \r\n    // The dydx Solo Margin contract\r\n    ISoloMargin private constant soloMargin = ISoloMargin(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\r\n\r\n    address private immutable owner;\r\n    address private executor;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyExecutor() {\r\n        require(msg.sender == executor);\r\n        _;\r\n    }\r\n\r\n    constructor(address _executor) public payable {\r\n        owner = msg.sender;\r\n        executor = _executor;\r\n        if (msg.value > 0) {\r\n            WETH.deposit{value: msg.value}();\r\n        }\r\n        // Give infinite approval to dydx to withdraw WETH on contract deployment,\r\n        // so we don't have to approve the loan repayment amount (+2 wei) on each call.\r\n        // The approval is used by the dydx contract to pay the loan back to itself.\r\n        WETH.approve(address(soloMargin), uint(-1));\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    function withdrawAmount(address payable receiver, uint256 amount) public onlyOwner {\r\n        require(amount <= address(this).balance);\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n    function withdrawTokenAmount(address receiver, uint256 amount, IERC20 token) public onlyOwner {\r\n        require(amount <= token.balanceOf(address(this)));\r\n        token.transfer(receiver, amount);\r\n    }\r\n\r\n    function setExecutor(address _executor) public onlyOwner {\r\n        executor = _executor;\r\n    }\r\n\r\n    // This is the function we call\r\n    function flashLoan(\r\n        uint256 _wethAmountToFirstMarket,\r\n        uint256 _ethAmountToCoinbase,\r\n        address[] memory _targets,\r\n        bytes[] memory _payloads\r\n    ) external onlyExecutor {\r\n        /*\r\n        The flash loan functionality in dydx is predicated by their \"operate\" function,\r\n        which takes a list of operations to execute, and defers validating the state of\r\n        things until it's done executing them.\r\n        \r\n        We thus create three operations, a Withdraw (which loans us the funds), a Call\r\n        (which invokes the callFunction method on this contract), and a Deposit (which\r\n        repays the loan, plus the 2 wei fee), and pass them all to \"operate\".\r\n        \r\n        Note that the Deposit operation will invoke the transferFrom to pay the loan \r\n        (or whatever amount it was initialised with) back to itself, there is no need\r\n        to pay it back explicitly.\r\n        \r\n        The loan must be given as an ERC-20 token, so WETH is used instead of ETH. Other\r\n        currencies (DAI, USDC) are also available, their index can be looked up by\r\n        calling getMarketTokenAddress on the solo margin contract, and set as the \r\n        primaryMarketId in the Withdraw and Deposit definitions.\r\n        */\r\n\r\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n        \r\n        // 1. Withdraw\r\n        operations[0] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Withdraw,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: _wethAmountToFirstMarket // Amount to borrow\r\n            }),\r\n            primaryMarketId: 0, // WETH\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n\r\n        // 2. Call\r\n        operations[1] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Call,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: 0\r\n            }),\r\n            primaryMarketId: 0,\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: abi.encode(\r\n                ArbitrageData({\r\n                    wethAmountToFirstMarket: _wethAmountToFirstMarket,\r\n                    ethAmountToCoinbase: _ethAmountToCoinbase,\r\n                    targets: _targets,\r\n                    payloads: _payloads\r\n                })\r\n            )\r\n        });\r\n\r\n        // 3. Deposit\r\n        operations[2] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Deposit,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: true,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: _wethAmountToFirstMarket + 2 // Repayment amount with 2 wei fee\r\n            }),\r\n            primaryMarketId: 0, // WETH\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n\r\n        Account.Info[] memory accountInfos = new Account.Info[](1);\r\n        accountInfos[0] = Account.Info({owner: address(this), number: 1});\r\n\r\n        soloMargin.operate(accountInfos, operations);\r\n    }\r\n\r\n    // This is the function called by dydx after giving us the loan\r\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external override {\r\n        require(msg.sender == address(soloMargin), 'SIMP AT alakazam9102@protonmail.com');\r\n        // Decode the passed variables from the data object\r\n        ArbitrageData memory arbData = abi.decode(data, (ArbitrageData));\r\n        \r\n        // Arbitrage logic\r\n        arbitrage(arbData.wethAmountToFirstMarket, arbData.ethAmountToCoinbase, arbData.targets, arbData.payloads);\r\n\r\n        // It can be useful for debugging to have a verbose error message when\r\n        // the loan can't be paid, since dydx doesn't provide one\r\n        require(WETH.balanceOf(address(this)) > arbData.wethAmountToFirstMarket + 2, \"RUGGED IN PROD\");\r\n        // Leave just enough WETH to pay back the loan, and convert the rest to ETH\r\n        // WETH.withdraw(WETH.balanceOf(address(this)) - loanAmount - 2);\r\n        // Send any profit in ETH to the account that invoked this transaction\r\n        // actualSender.transfer(address(this).balance);\r\n    }\r\n\r\n    function uniswapWeth(\r\n        uint256 _wethAmountToFirstMarket,\r\n        uint256 _ethAmountToCoinbase,\r\n        address[] memory _targets,\r\n        bytes[] memory _payloads\r\n    ) external onlyExecutor payable {\r\n        arbitrage(_wethAmountToFirstMarket, _ethAmountToCoinbase, _targets, _payloads);\r\n    }\r\n\r\n    function arbitrage(uint256 _wethAmountToFirstMarket, uint256 _ethAmountToCoinbase, address[] memory _targets, bytes[] memory _payloads) private {\r\n        require (_targets.length == _payloads.length);\r\n        uint256 _wethBalanceBefore = WETH.balanceOf(address(this));\r\n        require(_wethBalanceBefore >= _wethAmountToFirstMarket);\r\n\r\n        WETH.transfer(_targets[0], _wethAmountToFirstMarket);\r\n        for (uint256 i = 0; i < _targets.length; i++) {\r\n            (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\r\n            require(_success); _response;\r\n        }\r\n\r\n        uint256 _wethBalanceAfter = WETH.balanceOf(address(this));\r\n        require(_wethBalanceAfter > _wethBalanceBefore + _ethAmountToCoinbase);\r\n        if (_ethAmountToCoinbase == 0) return;\r\n\r\n        uint256 _ethBalance = address(this).balance;\r\n        if (_ethBalance < _ethAmountToCoinbase) {\r\n            WETH.withdraw(_ethAmountToCoinbase - _ethBalance);\r\n        }\r\n        block.coinbase.transfer(_ethAmountToCoinbase);\r\n    }\r\n\r\n    function call(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner payable returns (bytes memory) {\r\n        require(_to != address(0));\r\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\r\n        require(_success);\r\n        return _result;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Account.Info\",\"name\":\"accountInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wethAmountToFirstMarket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmountToCoinbase\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_payloads\",\"type\":\"bytes[]\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"setExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wethAmountToFirstMarket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmountToCoinbase\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_payloads\",\"type\":\"bytes[]\"}],\"name\":\"uniswapWeth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"FlashBotsMultiCall02","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000038d358caed6807b533db4c11d74a748a35e64dfb","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://89a68f6382e319e2f94ce2cb1be626fc087bdcd4321ba1aabd0caba1ded6b05c"}]}