{"status":"1","message":"OK","result":[{"SourceCode":"{\"AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Source: https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\r\\npragma solidity \\u003e=0.6.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\\r\\n\"},\"Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.7.6;\\r\\n\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\n\\r\\nlibrary Helpers {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @param number number to get percentage of\\r\\n     * @param percent percentage (8 decimals)\\r\\n     * @return The percentage of the number\\r\\n     */\\r\\n    function percentageOf(uint256 number, uint256 percent) internal pure returns (uint256) {\\r\\n        return number.mul(percent).div(100000000);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param keccak keccak256 hash to use\\r\\n     * @return The referral code\\r\\n     */\\r\\n    function keccak256ToReferralCode(bytes32 keccak) internal pure returns (bytes3) {\\r\\n        bytes3 code;\\r\\n        for (uint8 i = 0; i \\u003c 3; ++i) {\\r\\n            code |= bytes3(keccak[i]) \\u003e\\u003e (i * 8);\\r\\n        }\\r\\n        return code;\\r\\n    }\\r\\n\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Wallet.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.7.6;\\r\\n\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./Helpers.sol\\u0027;\\r\\n\\r\\nstruct Buyer {\\r\\n    uint256 eth; // Amount of sent ETH\\r\\n    uint256 zapp; // Amount of bought ZAPP\\r\\n}\\r\\n\\r\\nstruct EarlyAdopter {\\r\\n    uint256 zapp; // Early adopter purchase amount\\r\\n}\\r\\n\\r\\nstruct Referrer {\\r\\n    bytes3 code; // Referral code\\r\\n    uint256 time; // Time of code generation\\r\\n    Referee[] referrals; // List of referrals\\r\\n}\\r\\n\\r\\nstruct Referee {\\r\\n    uint256 zapp; // Purchase amount\\r\\n}\\r\\n\\r\\nstruct Hunter {\\r\\n    bool verified; // Verified by Zappermint (after Token Sale)\\r\\n    uint256 bonus; // Bounty bonus (after Token Sale)\\r\\n}\\r\\n\\r\\nstruct Wallet {\\r\\n    address payable addr; // Address of the wallet\\r\\n\\r\\n    Buyer buyer; // Buyer data\\r\\n    bool isBuyer; // Whether this wallet is a buyer\\r\\n    \\r\\n    EarlyAdopter earlyAdopter; // Early adopter data\\r\\n    bool isEarlyAdopter; // Whether this wallet is an early adopter\\r\\n    \\r\\n    Referrer referrer; // Referrer data\\r\\n    bool isReferrer; // Whether this wallet is a referrer\\r\\n    \\r\\n    Referee referee; // Referee data\\r\\n    bool isReferee; // Whether this wallet is a referee\\r\\n    \\r\\n    Hunter hunter; // Hunter data\\r\\n    bool isHunter; // Whether this wallet is a hunter\\r\\n    \\r\\n    bool claimed; // Whether ZAPP has been claimed\\r\\n}\\r\\n\\r\\n/**\\r\\n * Functionality for the Wallet struct\\r\\n */\\r\\nlibrary WalletInterface {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @param self the wallet\\r\\n     * @param referrerMin the minimum amount of ZAPP that has to be bought to be a referrer (for hunters)\\r\\n     * @param checkVerified whether to check if the hunter is verified (set to false to show progress during token sale)\\r\\n     * @return The amount of ZAPP bits that have been bought with the referrer\\u0027s code (18 decimals)\\r\\n     */\\r\\n    function calculateReferredAmount(Wallet storage self, uint256 referrerMin, bool checkVerified) internal view returns (uint256) {\\r\\n        // 0 if not a referrer\\r\\n        if (!self.isReferrer) return 0;\\r\\n\\r\\n        // 0 if unverified hunter without enough bought ZAPP\\r\\n        if (checkVerified \\u0026\\u0026 self.isHunter \\u0026\\u0026 !self.hunter.verified \\u0026\\u0026 self.buyer.zapp \\u003c referrerMin) return 0;\\r\\n\\r\\n        // Calculate the sum of all referrals\\r\\n        uint256 amount = 0;\\r\\n        for (uint256 i = 0; i \\u003c self.referrer.referrals.length; ++i) {\\r\\n            amount = amount.add(self.referrer.referrals[i].zapp);\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param self the wallet\\r\\n     * @param bonus the bonus percentage (8 decimals)\\r\\n     * @return The amount of ZAPP bits the early adopter will get as bonus (18 decimals)\\r\\n     */\\r\\n    function getEarlyAdopterBonus(Wallet storage self, uint256 bonus) internal view returns (uint256) {\\r\\n        if (!self.isEarlyAdopter) return 0;\\r\\n        return Helpers.percentageOf(self.earlyAdopter.zapp, bonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param self the wallet\\r\\n     * @param bonus the bonus percentage (8 decimals)\\r\\n     * @param referrerMin the minimum amount of ZAPP a referrer must have bought to be eligible (18 decimals)\\r\\n     * @param checkVerified whether to check if the hunter is verified\\r\\n     * @return The amount of ZAPP bits the referrer will get as bonus (18 decimals)\\r\\n     */\\r\\n    function getReferrerBonus(Wallet storage self, uint256 bonus, uint256 referrerMin, bool checkVerified) internal view returns (uint256) {\\r\\n        if (!self.isReferrer) return 0;\\r\\n        return Helpers.percentageOf(calculateReferredAmount(self, referrerMin, checkVerified), bonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param self the wallet\\r\\n     * @param bonus the bonus percentage (8 decimals)\\r\\n     * @return The amount of ZAPP bits the referee will get as bonus (18 decimals)\\r\\n     */\\r\\n    function getRefereeBonus(Wallet storage self, uint256 bonus) internal view returns (uint256) {\\r\\n        if (!self.isReferee) return 0;\\r\\n        return Helpers.percentageOf(self.referee.zapp, bonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param self the wallet\\r\\n     * @param checkVerified whether to check if the hunter is verified\\r\\n     * @return The amount of ZAPP bits the hunter will get as bonus (18 decimals)\\r\\n     */\\r\\n    function getHunterBonus(Wallet storage self, bool checkVerified) internal view returns (uint256) {\\r\\n        if (!self.isHunter) return 0;\\r\\n        if (checkVerified \\u0026\\u0026 !self.hunter.verified) return 0;\\r\\n        return self.hunter.bonus;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param self the wallet\\r\\n     * @return The amount of ZAPP bits the buyer has bought (18 decimals)\\r\\n     */\\r\\n    function getBuyerZAPP(Wallet storage self) internal view returns (uint256) {\\r\\n        if (!self.isBuyer) return 0;\\r\\n        return self.buyer.zapp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Makes a purchase for the wallet\\r\\n     * @param self the wallet\\r\\n     * @param eth amount of sent ETH (18 decimals)\\r\\n     * @param zapp amount of bought ZAPP (18 decimals)\\r\\n     */\\r\\n    function purchase(Wallet storage self, uint256 eth, uint256 zapp) internal {\\r\\n        // Become buyer\\r\\n        self.isBuyer = true;\\r\\n        // Add ETH to buyer data\\r\\n        self.buyer.eth = self.buyer.eth.add(eth);\\r\\n        // Add ZAPP to buyer data\\r\\n        self.buyer.zapp = self.buyer.zapp.add(zapp);\\r\\n    } \\r\\n\\r\\n    /**\\r\\n     * Adds early adoption bonus\\r\\n     * @param self the wallet\\r\\n     * @param zapp amount of bought ZAPP (18 decimals)\\r\\n     * NOTE Doesn\\u0027t check for early adoption end time\\r\\n     */\\r\\n    function earlyAdoption(Wallet storage self, uint256 zapp) internal {\\r\\n        // Become early adopter\\r\\n        self.isEarlyAdopter = true;\\r\\n        // Add ZAPP to early adopter data\\r\\n        self.earlyAdopter.zapp = self.earlyAdopter.zapp.add(zapp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Adds referral bonuses\\r\\n     * @param self the wallet\\r\\n     * @param zapp amount of bought ZAPP (18 decimals)\\r\\n     * @param referrer referrer wallet\\r\\n     * NOTE Doesn\\u0027t check for minimum purchase amount\\r\\n     */\\r\\n    function referral(Wallet storage self, uint256 zapp, Wallet storage referrer) internal {\\r\\n        // Become referee\\r\\n        self.isReferee = true;\\r\\n        // Add ZAPP to referee data\\r\\n        self.referee.zapp = self.referee.zapp.add(zapp);\\r\\n        // Add referral to referrer\\r\\n        referrer.referrer.referrals.push(Referee(zapp));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Register as hunter\\r\\n     * @param self the wallet\\r\\n     */\\r\\n    function register(Wallet storage self, uint256 reward, mapping(bytes3 =\\u003e address) storage codes) internal {\\r\\n        // Become hunter\\r\\n        self.isHunter = true;\\r\\n        // Set initial bonus to the register reward\\r\\n        self.hunter.bonus = reward;\\r\\n        // Become referrer\\r\\n        self.isReferrer = true;\\r\\n        // Generate referral code\\r\\n        generateReferralCode(self, codes);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Verify hunter and add his rewards\\r\\n     * @param self the wallet\\r\\n     * @param bonus hunted bounties\\r\\n     * NOTE Also becomes a hunter, even if unregistered\\r\\n     */\\r\\n    function verify(Wallet storage self, uint256 bonus) internal {\\r\\n        // Become hunter\\r\\n        self.isHunter = true;\\r\\n        // Set data\\r\\n        self.hunter.verified = true;\\r\\n        self.hunter.bonus = self.hunter.bonus.add(bonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Generates a new code to assign to the referrer\\r\\n     * @param self the wallet\\r\\n     * @param codes the code map to check for duplicates\\r\\n     * @return Unique referral code\\r\\n     */\\r\\n    function generateReferralCode(Wallet storage self, mapping(bytes3 =\\u003e address) storage codes) internal returns (bytes3) {\\r\\n        // Only on referrers\\r\\n        if (!self.isReferrer) return bytes3(0);\\r\\n\\r\\n        // Only generate once\\r\\n        if (self.referrer.code != bytes3(0)) return self.referrer.code;\\r\\n\\r\\n        bytes memory enc = abi.encodePacked(self.addr);\\r\\n        bytes3 code = bytes3(0);\\r\\n        while (true) {\\r\\n            bytes32 keccak = keccak256(enc);\\r\\n            code = Helpers.keccak256ToReferralCode(keccak);\\r\\n            if (code != bytes3(0) \\u0026\\u0026 codes[code] == address(0)) break;\\r\\n            // If the code already exists, we hash the hash to generate a new code\\r\\n            enc = abi.encodePacked(keccak);\\r\\n        }\\r\\n\\r\\n        // Save the code for the referrer and in the code map to avoid duplicates\\r\\n        self.referrer.code = code;\\r\\n        self.referrer.time = block.timestamp;\\r\\n        codes[code] = self.addr;\\r\\n        return code;\\r\\n    }\\r\\n\\r\\n}\"},\"ZappermintTokenSale.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.7.6;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./AggregatorV3Interface.sol\\u0027;\\r\\nimport \\u0027./Wallet.sol\\u0027;\\r\\n\\r\\n// Crowdsale contract for ZAPP. Functionalities:\\r\\n// - Timed: opens Jan 14, 2021, 6:00:00PM UTC (1610647200) and closes Feb 14, 2021, 6:00:00PM UTC (1613325600)\\r\\n// - Capped: soft cap of 6M ZAPP, hard cap of 120M ZAPP\\r\\n// - Refundable: ETH can be refunded if soft cap hasn\\u0027t been reached\\r\\n// - Post Delivery: ZAPP can be claimed after Token Sale end, if soft cap has been reached\\r\\n// - Early Adopter: Bonus ZAPP for a set duration\\r\\n// - Referral System: Bonus ZAPP when buying with referral link\\r\\ncontract ZappermintTokenSale {\\r\\n    using SafeMath for uint256; // Avoid overflow issues\\r\\n    using WalletInterface for Wallet; // Wallet functionality\\r\\n\\r\\n// ----\\r\\n// Variables\\r\\n// ----\\r\\n\\r\\n    // Token Sale configuration\\r\\n    uint256 private _openingTime; // Start of Token Sale\\r\\n    uint256 private _closingTime; // End of Token Sale\\r\\n    uint256 private _claimTime; // Claim opening time\\r\\n    uint256 private _softCap; // Minimum amount of ZAPP to sell (18 decimals)\\r\\n    uint256 private _hardCap; // Maximum amount of ZAPP to sell (18 decimals)\\r\\n    uint256 private _ethPrice; // Fallback ETH/USD price in case ChainLink breaks (8 decimals)\\r\\n    uint256 private _zappPrice; // ZAPP/USD price (8 decimals)\\r\\n    address private _zappContract; // Zappermint Token Contract\\r\\n    address private _owner; // Owner of the contract\\r\\n    \\r\\n    // Wallets\\r\\n    mapping(address =\\u003e Wallet) private _wallets; // Addresses that have interacted with the Token Sale\\r\\n    address[] _walletKeys; // Address list, for iterating over `_wallets`\\r\\n\\r\\n    // Early Adopters\\r\\n    uint256 private _earlyAdoptionEndTime; // End of early adoption bonus\\r\\n    uint256 private _earlyAdoptionBonus; // Percentage of purchase to receive as bonus (8 decimals)\\r\\n\\r\\n    // Referrals\\r\\n    uint256 private _referrerMin; // Referrer minimum ZAPP bits (18 decimals)\\r\\n    uint256 private _refereeMin; // Referee minimum ZAPP bits (18 decimals)\\r\\n    uint256 private _referralBonus; // Percentage of purchase to receive as bonus (8 decimals)\\r\\n    uint256[5] private _rankRewards; // Referrer rank reward list\\r\\n    mapping(bytes3 =\\u003e address) private _codes; // Referral codes\\r\\n    \\r\\n    // Bounty Hunters\\r\\n    address[] _registeredHunters; // Registered hunter list\\r\\n    uint256 private _maxHunters; // Maximum amount of registered bounty hunters\\r\\n    uint256 private _registerBonus; // Bonus for registering as bounty hunter\\r\\n\\r\\n    // Token Sale progress\\r\\n    uint256 private _soldZAPP; // Amount of ZAPP sold (18 decimals)\\r\\n    bool private _ended; // Whether the Token Sale has ended\\r\\n\\r\\n    // Third party\\r\\n    AggregatorV3Interface private _priceFeed; // ChainLink ETH/USD Price Feed\\r\\n\\r\\n// ----\\r\\n// Modifiers\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run while the Token Sale is open\\r\\n     */\\r\\n    modifier whileOpen {\\r\\n        require(isOpen(), \\\"Token Sale not open\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run while the Token Sale is not closed\\r\\n     * NOTE The difference with whileOpen is that this returns true also before Token Sale opens\\r\\n     */\\r\\n    modifier whileNotClosed {\\r\\n        require(!isClosed(), \\\"Token Sale closed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run while the claims are open\\r\\n     */\\r\\n    modifier whileClaimable {\\r\\n        require(isClaimable(), \\\"ZAPP can\\u0027t be claimed yet\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run after the Token Sale has ended\\r\\n     */\\r\\n    modifier afterEnd {\\r\\n        require(_ended, \\\"Token Sale not ended\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run before the Token Sale has ended\\r\\n     */\\r\\n    modifier beforeEnd {\\r\\n        require(!_ended, \\\"Token Sale ended\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run when the Token Sale has reached the soft cap\\r\\n     */\\r\\n    modifier aboveSoftCap {\\r\\n        require(isSoftCapReached(), \\\"Token Sale hasn\\u0027t reached soft cap\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to run when the Token Sale hasn\\u0027t reached the soft cap\\r\\n     */\\r\\n    modifier belowSoftCap {\\r\\n        require(!isSoftCapReached(), \\\"Token Sale reached soft cap\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to be run by the Zappermint Token Contract\\r\\n     */\\r\\n    modifier onlyZAPPContract {\\r\\n        require(msg.sender == _zappContract, \\\"Only the Zappermint Token Contract can do this\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Only allow function with this modifier to be run by the owner\\r\\n     */\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == _owner, \\\"Only the owner can do this\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n// ----\\r\\n// Constructor\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * Solves the Stack too deep error for the constructor\\r\\n     * @param openingTime start time of the Token Sale (epoch)\\r\\n     * @param closingTime end time of the Token Sale (epoch)\\r\\n     * @param claimTime claim opening time (epoch)\\r\\n     * @param softCap minimum amount of ZAPP to sell (18 decimals)\\r\\n     * @param hardCap maximum amount of ZAPP to sell (18 decimals)\\r\\n     * @param ethPrice price of 1 ETH in USD (8 decimals) to use in case ChainLink breaks\\r\\n     * @param zappPrice price of 1 ZAPP in USD (8 decimals)\\r\\n     * @param referrerMin minimum amount of ZAPP referrer must have purchased before getting a referral link (18 decimals)\\r\\n     * @param refereeMin minimum amount of ZAPP referee must purchase to get referral bonus (18 decimals)\\r\\n     * @param referralBonus percentage of purchase to receive as bonus (8 decimals)\\r\\n     * @param rankRewards referrer rank reward list\\r\\n     * @param earlyAdoptionEndTime end of early adoption bonus\\r\\n     * @param earlyAdoptionBonus percentage of purchase to receive as bonus (8 decimals)\\r\\n     * @param maxHunters maximum amount of bounty hunters\\r\\n     * @param registerBonus bonus for registering as bounty hunter\\r\\n     * @param aggregator address of ChainLink Aggregator price feed\\r\\n     */\\r\\n    struct ContractArguments {\\r\\n        uint256 openingTime;\\r\\n        uint256 closingTime; \\r\\n        uint256 claimTime;\\r\\n        uint256 softCap;\\r\\n        uint256 hardCap;\\r\\n        uint256 ethPrice;\\r\\n        uint256 zappPrice;\\r\\n        uint256 referrerMin;\\r\\n        uint256 refereeMin;\\r\\n        uint256 referralBonus;\\r\\n        uint256[5] rankRewards;\\r\\n        uint256 earlyAdoptionEndTime;\\r\\n        uint256 earlyAdoptionBonus;\\r\\n        uint256 maxHunters;\\r\\n        uint256 registerBonus;\\r\\n        address aggregator;\\r\\n    }\\r\\n\\r\\n    constructor(ContractArguments memory args) {\\r\\n        require(args.openingTime \\u003e= block.timestamp, \\\"Opening time is before current time\\\");\\r\\n        require(args.closingTime \\u003e args.openingTime, \\\"Opening time is not before closing time\\\");\\r\\n        require(args.claimTime \\u003e= args.closingTime, \\\"Claiming time is not after closing time\\\");\\r\\n        require(args.softCap \\u003c args.hardCap, \\\"Hard cap is below soft cap\\\");\\r\\n\\r\\n        _openingTime = args.openingTime;\\r\\n        _closingTime = args.closingTime;\\r\\n        _claimTime = args.claimTime;\\r\\n        _softCap = args.softCap;\\r\\n        _hardCap = args.hardCap;\\r\\n        _ethPrice = args.ethPrice;\\r\\n        _zappPrice = args.zappPrice;\\r\\n        _referrerMin = args.referrerMin;\\r\\n        _refereeMin = args.refereeMin;\\r\\n        _referralBonus = args.referralBonus;\\r\\n        _rankRewards = args.rankRewards;\\r\\n        _earlyAdoptionEndTime = args.earlyAdoptionEndTime;\\r\\n        _earlyAdoptionBonus = args.earlyAdoptionBonus;\\r\\n        _maxHunters = args.maxHunters;\\r\\n        _registerBonus = args.registerBonus;\\r\\n        _priceFeed = AggregatorV3Interface(args.aggregator);\\r\\n\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n// ----\\r\\n// Getters\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * @return Token Sale opening time\\r\\n     */\\r\\n    function getOpeningTime() public view returns (uint256) {\\r\\n        return _openingTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether Token Sale is open\\r\\n     */\\r\\n    function isOpen() public view returns (bool) {\\r\\n        return block.timestamp \\u003e= _openingTime \\u0026\\u0026 block.timestamp \\u003c= _closingTime \\u0026\\u0026 !_ended;\\r\\n    }    \\r\\n\\r\\n    /**\\r\\n     * @return Token Sale closing time\\r\\n     */\\r\\n    function getClosingTime() public view returns (uint256) {\\r\\n        return _closingTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether Token Sale is closed\\r\\n     */\\r\\n    function isClosed() public view returns (bool) {\\r\\n        return block.timestamp \\u003e _closingTime || _ended;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether the Token Sale has been ended by the owner\\r\\n     */\\r\\n    function isEnded() public view returns (bool) {\\r\\n        return _ended;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Early adoption end time\\r\\n     */\\r\\n    function getEarlyAdoptionEndTime() public view returns (uint256) {\\r\\n        return _earlyAdoptionEndTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether the early adoption is active\\r\\n     */\\r\\n    function isEarlyAdoptionActive() public view returns (bool) {\\r\\n        return block.timestamp \\u003c= _earlyAdoptionEndTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Percentage of purchase to receive as bonus during early adoption (8 decimals)\\r\\n     */\\r\\n    function getEarlyAdoptionBonus() public view returns (uint256) {\\r\\n        return _earlyAdoptionBonus;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The claim opening time\\r\\n     */\\r\\n    function getClaimTime() public view returns (uint256) {\\r\\n        return _claimTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether the ZAPP can be claimed\\r\\n     */\\r\\n    function isClaimable() public view returns (bool) {\\r\\n        return block.timestamp \\u003e= _claimTime \\u0026\\u0026 _ended \\u0026\\u0026 _zappContract != address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The minimum amount of ZAPP to sell (18 decimals)\\r\\n     */\\r\\n    function getSoftCap() public view returns (uint256) {\\r\\n        return _softCap;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether the soft cap has been reached\\r\\n     */\\r\\n    function isSoftCapReached() public view returns (bool) {\\r\\n        return _soldZAPP \\u003e= _softCap;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The maximum amount of ZAPP to sell (18 decimals)\\r\\n     */\\r\\n    function getHardCap() public view returns (uint256) {\\r\\n        return _hardCap;\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @return Whether the hard cap has been reached\\r\\n     */\\r\\n    function isHardCapReached() public view returns (bool) {\\r\\n        return _soldZAPP \\u003e= _hardCap;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The total amount of ZAPP sold so far (18 decimals)\\r\\n     */\\r\\n    function getSoldZAPP() public view returns (uint256) {\\r\\n        return _soldZAPP;    \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The current number of ZAPP a buyer gets per 1 ETH\\r\\n     * NOTE Based on ETH/USD pair. 1 ZAPP = 0.05 USD\\r\\n     */\\r\\n    function getRate() public view returns (uint256) {\\r\\n        return getLatestPrice().div(_zappPrice); // 8 decimals\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The price of 1 ETH in USD. Attempts using ChainLink Aggregator, falls back to `_ethPrice` if broken.\\r\\n     * NOTE 8 decimals\\r\\n     */\\r\\n    function getLatestPrice() public view returns (uint256) {\\r\\n        // Try/catch only works on external function calls. `this.f()` uses a message call instead of a direct jump, \\r\\n        //   which is considered external.\\r\\n        //   https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls\\r\\n        // Note when ChainLink is broken, this will log an internal `revert` error, but the code will complete successfully\\r\\n        try this.getChainlinkPrice() returns (uint256 price) {\\r\\n            return price;\\r\\n        }\\r\\n        catch {\\r\\n            return _ethPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The price of 1 ETH in USD (from ChainLink Aggregator) \\r\\n     * NOTE 8 decimals\\r\\n     */\\r\\n    function getChainlinkPrice() public view returns (uint256) {\\r\\n        // Get the ETH/USD price from ChainLink\\u0027s Aggregator\\r\\n        (,int256 p,,,) = _priceFeed.latestRoundData();\\r\\n        \\r\\n        // This price is a signed int, so make sure it\\u0027s higher than 0\\r\\n        require(p \\u003e 0, \\\"Price feed invalid\\\");\\r\\n\\r\\n        // We can now safely cast it to unsigned int and use SafeMath on it\\r\\n        uint256 price = uint256(p);\\r\\n\\r\\n        // Verify the number of decimals. We work with 8 decimals for USD prices, \\r\\n        //   but ChainLink can choose to change this at any point outside of our control.\\r\\n        // We ensure that the price has 8 decimals with the math below.\\r\\n        // Note that the exponent must be positive, so we use div instead of mul in case\\r\\n        //   the number of decimals is smaller than 8.\\r\\n        uint8 decimals = _priceFeed.decimals();\\r\\n        if (decimals == 8) return price;\\r\\n        else if (decimals \\u003c 8) return price.div(10**(8 - decimals));\\r\\n        else return price.mul(10**(decimals - 8));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Minimum amount of ZAPP a referrer must have bought to get a referral link (18 decimals)\\r\\n     */\\r\\n    function getReferrerMin() public view returns (uint256) {\\r\\n        return _referrerMin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Minimum amount of ZAPP a referee must buy to get referral bonus (18 decimals)\\r\\n     */\\r\\n    function getRefereeMin() public view returns (uint256) {\\r\\n        return _refereeMin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Percentage of purchase to receive as bonus (8 decimals)\\r\\n     */\\r\\n    function getReferralBonus() public view returns (uint256) {\\r\\n        return _referralBonus;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The referral code for this address\\r\\n     */\\r\\n    function getReferralCode() public view returns (bytes3) {\\r\\n        return _wallets[msg.sender].referrer.code;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param code referral code\\r\\n     * @return Whether the referral code is valid\\r\\n     */\\r\\n    function isReferralCodeValid(bytes3 code) public view returns (bool) {\\r\\n        return _codes[code] != address(0) \\u0026\\u0026 _codes[code] != msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The referral rank reward list\\r\\n     */\\r\\n    function getRankRewards() public view returns (uint256[5] memory) {\\r\\n        return _rankRewards;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The amount of registered Bounty Hunters\\r\\n     */\\r\\n    function getRegisteredHunters() public view returns (uint256) {\\r\\n        return _registeredHunters.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The maximum number of Bounty Hunters that can register\\r\\n     */\\r\\n    function getMaxHunters() public view returns (uint256) {\\r\\n        return _maxHunters;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The bonus for registering as Bounty Hunter\\r\\n     */\\r\\n    function getRegisterBonus() public view returns (uint256) {\\r\\n        return _registerBonus;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether Bounty Hunters can still register\\r\\n     */\\r\\n    function canRegister() public view returns (bool) {\\r\\n        return getRegisteredHunters() \\u003c getMaxHunters();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to check\\r\\n     * @return Whether the address is a Bounty Hunter\\r\\n     */\\r\\n    function isHunter(address addr) public view returns (bool) {\\r\\n        return _wallets[addr].isHunter;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to check\\r\\n     * @return Whether the address is a registered Bounty Hunter \\r\\n     */\\r\\n    function isHunterRegistered(address addr) public view returns (bool) {\\r\\n        for (uint256 i = 0; i \\u003c _registeredHunters.length; ++i) {\\r\\n            if (_registeredHunters[i] == addr) return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Whether the Bounty Hunter is verified by Zappermint\\r\\n     */\\r\\n    function isHunterVerified(address addr) public view returns (bool) {\\r\\n        return _wallets[addr].hunter.verified;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get ETH of\\r\\n     * @return The amount of wei this address has spent (18 decimals)\\r\\n     */\\r\\n    function getBuyerETH(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return _wallets[addr].buyer.eth;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get ZAPP of\\r\\n     * @return The amount of ZAPP bits this address has bought (18 decimals)\\r\\n     */\\r\\n    function getBuyerZAPP(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return _wallets[addr].buyer.zapp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get bonus of\\r\\n     * @return The amount of ZAPP bits this address will get as early adopter bonus (18 decimals)\\r\\n     */\\r\\n    function getEarlyAdopterBonus(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return _wallets[addr].getEarlyAdopterBonus(_earlyAdoptionBonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get bonus of\\r\\n     * @return The amount of ZAPP bits this address will get as referrer bonus (18 decimals)\\r\\n     */\\r\\n    function getReferrerBonus(address addr) public  view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return _wallets[addr].getReferrerBonus(_referralBonus, _referrerMin, isClaimable());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get bonus of\\r\\n     * @return The amount of ZAPP bits this address will receive as bonus for his purchase(s) (18 decimals)\\r\\n     */\\r\\n    function getRefereeBonus(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return _wallets[addr].getRefereeBonus(_referralBonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get bonus of\\r\\n     * @return The amount of ZAPP bits this address will receive as bonus for his bounty campaign (18 decimals)\\r\\n     */\\r\\n    function getHunterBonus(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return _wallets[addr].getHunterBonus(isClaimable());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get reward of\\r\\n     * @return The amount of ZAPP bits this address will be rewarded with for referrer rank (18 decimals)\\r\\n     */\\r\\n    function getReferrerRankReward(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        uint256 rank = getReferrerRank(addr);\\r\\n        if (rank == 0) return 0;\\r\\n        --rank;\\r\\n        if (rank \\u003c _rankRewards.length) return _rankRewards[rank];\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get reward of\\r\\n     * @return The total amount of ZAPP bits this address will get as bonus (18 decimals)\\r\\n     * NOTE Hunter and referrer rank rewards only added when claimable\\r\\n     */\\r\\n    function getWalletTotalBonus(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        uint256 total = getEarlyAdopterBonus(addr)\\r\\n            .add(getReferrerBonus(addr))\\r\\n            .add(getRefereeBonus(addr));\\r\\n        \\r\\n        bool verified = isHunterVerified(addr);\\r\\n        bool claimable = isClaimable();\\r\\n        \\r\\n        // Add hunter bonus when verified\\r\\n        if (verified) {\\r\\n            total = total.add(getHunterBonus(addr));\\r\\n        } \\r\\n        // Also add hunter bonus when not claimable yet\\r\\n        else if (!claimable) {\\r\\n            total = total.add(getHunterBonus(addr));\\r\\n        }\\r\\n\\r\\n        // Add rank reward when claimable\\r\\n        if (claimable) {\\r\\n            total = total.add(getReferrerRankReward(addr));\\r\\n        } \\r\\n        \\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get ZAPP of\\r\\n     * @return The total amount of ZAPP bits this address can claim (18 decimals)\\r\\n     */\\r\\n    function getWalletTotalZAPP(address addr) public view returns (uint256) {\\r\\n        if (hasWalletClaimed(addr)) return 0;\\r\\n        return getBuyerZAPP(addr)\\r\\n            .add(getWalletTotalBonus(addr));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get claimed state of\\r\\n     * @return Whether this address has claimed their ZAPP\\r\\n     */\\r\\n    function hasWalletClaimed(address addr) public view returns (bool) {\\r\\n        return _wallets[addr].claimed;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param addr address to get referrals of\\r\\n     * @return The list of successful referrals of the referrer\\r\\n     */\\r\\n    function getReferrals(address addr) public view returns (uint256[] memory) {\\r\\n        uint256 length = _wallets[addr].referrer.referrals.length;\\r\\n        uint256[] memory referrals = new uint256[](length);\\r\\n        for (uint256 i = 0; i \\u003c length; ++i) {\\r\\n            referrals[i] = _wallets[addr].referrer.referrals[i].zapp;\\r\\n        }\\r\\n        return referrals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get the ranking position of the referrer\\r\\n     * @param addr referrer address\\r\\n     * @return The one-based rank of the referrer. 0 if not a referrer\\r\\n     */\\r\\n    function getReferrerRank(address addr) public view returns (uint256) {\\r\\n        // Non-referrers don\\u0027t have a rank\\r\\n        if (!_wallets[addr].isReferrer) return 0;\\r\\n        // Must have at least one referral\\r\\n        if (_wallets[addr].referrer.referrals.length == 0) return 0;\\r\\n\\r\\n        // Start at rank 1\\r\\n        uint256 rank = 1;\\r\\n        uint256 amount1 = _wallets[addr].calculateReferredAmount(_referrerMin, isClaimable());\\r\\n        if (amount1 == 0) return 0;\\r\\n\\r\\n        // Find every referrer with a higher referral sum\\r\\n        for (uint256 key = 0; key \\u003c _walletKeys.length; ++key) {\\r\\n            // Skip self\\r\\n            if (addr == _walletKeys[key]) continue;\\r\\n\\r\\n            // Skip non-referrers\\r\\n            if (!_wallets[_walletKeys[key]].isReferrer) continue;\\r\\n            \\r\\n            uint256 amount2 = _wallets[_walletKeys[key]].calculateReferredAmount(_referrerMin, isClaimable());\\r\\n            if (amount2 == 0) continue;\\r\\n            \\r\\n            // Increase the rank if another referrer has a higher sum\\r\\n            if (amount2 \\u003e amount1) ++rank;\\r\\n            // Increase the rank if another referrer has same amount but earlier time\\r\\n            else if (amount2 == amount1 \\u0026\\u0026 _wallets[_walletKeys[key]].referrer.time \\u003c _wallets[addr].referrer.time) ++rank;\\r\\n        }\\r\\n        return rank;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get the top 5 referrers\\r\\n     * @return The array of referred amounts of the top 5 referrers\\r\\n     * NOTE This can vary depending on the isClaimable state\\r\\n     */\\r\\n    function getTopReferrers() public view returns (uint256[5] memory) {\\r\\n        uint256[5] memory top = [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)];\\r\\n        for (uint256 key = 0; key \\u003c _walletKeys.length; ++key) {\\r\\n            uint256 amount = _wallets[_walletKeys[key]].calculateReferredAmount(_referrerMin, isClaimable());\\r\\n            for (uint256 t = 0; t \\u003c top.length; ++t) {\\r\\n                if (amount \\u003e top[t]) {\\r\\n                    for (uint256 i = 4; i \\u003e t; --i) {\\r\\n                        top[i] = top[i - 1];\\r\\n                    }\\r\\n                    top[t] = amount;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return top;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Total amount of ZAPP that has been bought during Early Adoption\\r\\n     */\\r\\n    function getTotalEarlyAdoptionZAPP() public view returns (uint256) {\\r\\n        uint256 total;\\r\\n        for (uint256 i = 0; i \\u003c _walletKeys.length; ++i) {\\r\\n            total = total.add(_wallets[_walletKeys[i]].earlyAdopter.zapp);\\r\\n        }\\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Total amount of ZAPP that has been bought without referral code\\r\\n     */\\r\\n    function getTotalWithoutCodeZAPP() public view returns (uint256) {\\r\\n        uint256 total;\\r\\n        for (uint256 i = 0; i \\u003c _walletKeys.length; ++i) {\\r\\n            total = total.add(_wallets[_walletKeys[i]].buyer.zapp)\\r\\n                         .sub(_wallets[_walletKeys[i]].referee.zapp);\\r\\n        }\\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Total amount of ZAPP that has been bought with referral code\\r\\n     */\\r\\n    function getTotalReferredZAPP() public view returns (uint256) {\\r\\n        uint256 total;\\r\\n        for (uint256 i = 0; i \\u003c _walletKeys.length; ++i) {\\r\\n            total = total.add(_wallets[_walletKeys[i]].referee.zapp);\\r\\n        }\\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Total amount of ZAPP that has been bought with Bounty Hunter referral code\\r\\n     */\\r\\n    function getTotalHunterReferredZAPP() public view returns (uint256) {\\r\\n        uint256 total;\\r\\n        for (uint256 i = 0; i \\u003c _registeredHunters.length; ++i) {\\r\\n            total = total.add(_wallets[_registeredHunters[i]].calculateReferredAmount(_referrerMin, false));\\r\\n        } \\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The Zappermint Token Contract address\\r\\n     */\\r\\n    function getZAPPContract() public view returns (address) {\\r\\n        return _zappContract;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The owner of the Token Sale Contract\\r\\n     */\\r\\n    function getOwner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n// ----\\r\\n// Currency helpers\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * Calculate amount of ZAPP for a given amount of wei\\r\\n     * @param weiAmount amount of wei (18 decimals)\\r\\n     * @return ZAPP\\r\\n     */\\r\\n    function calculateZAPPAmount(uint256 weiAmount) public view returns (uint256) {\\r\\n        return weiAmount.mul(getRate());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate amount of ETH for a given amount of ZAPP bits\\r\\n     * @param zappAmount amount of ZAPP bits (18 decimals)\\r\\n     * @return Wei\\r\\n     */\\r\\n    function calculateETHAmount(uint256 zappAmount) public view returns (uint256) {\\r\\n        return zappAmount.div(getRate());\\r\\n    }\\r\\n\\r\\n// ----\\r\\n// Setters\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * Changes the ETH price in case ChainLink breaks\\r\\n     * @param price price of 1 ETH in USD (8 decimals)\\r\\n     */\\r\\n    function setETHPrice(uint256 price) public beforeEnd onlyOwner {\\r\\n        _ethPrice = price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Changes the max amount of Bounty Hunters that can register\\r\\n     * @param max new max amount\\r\\n     */\\r\\n    function setMaxHunters(uint256 max) public beforeEnd onlyOwner {\\r\\n        _maxHunters = max;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Closes the Token Sale manually\\r\\n     */\\r\\n    function endTokenSale() public onlyOwner {\\r\\n        _ended = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sets the address of the Zappermint Token Contract\\r\\n     * @param zappContract address of the Zappermint Token Contract\\r\\n     */\\r\\n    function setZAPPContract(address zappContract) public onlyOwner {\\r\\n        _zappContract = zappContract;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfers ownership\\r\\n     * @param newOwner address of the new owner\\r\\n     */\\r\\n    function changeOwner(address newOwner) public onlyOwner {\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n\\r\\n// ----\\r\\n// Transaction functions\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * Fallback function shouldn\\u0027t do anything, as it won\\u0027t have any ETH to buy ZAPP with\\r\\n     */\\r\\n    fallback () external whileOpen {\\r\\n        revert(\\\"Fallback function called\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Receive function to buy ZAPP\\r\\n     */\\r\\n    receive() external payable whileOpen {\\r\\n        buyZAPP();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Buy ZAPP without referral code\\r\\n     */\\r\\n    function buyZAPP() public payable whileOpen {\\r\\n        uint256 zapp = _buyZAPP(msg.sender, msg.value);\\r\\n        _assignBonuses(msg.sender, zapp, bytes3(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Buy ZAPP with referral code\\r\\n     * @param code used referral code\\r\\n     */\\r\\n    function buyZAPPWithCode(bytes3 code) public payable whileOpen {\\r\\n        uint256 zapp = _buyZAPP(msg.sender, msg.value);\\r\\n        _assignBonuses(msg.sender, zapp, code);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Register as Bounty Hunter\\r\\n     * NOTE This generates a code for the address, disregarding the bought zapp amount\\r\\n     */\\r\\n    function registerHunter() public whileNotClosed {\\r\\n        require(!isHunterRegistered(msg.sender), \\\"Already a Bounty Hunter\\\");\\r\\n        require(canRegister(), \\\"Maximum amount of Bounty Hunters has been reached\\\");\\r\\n        \\r\\n        // Register without purchase\\r\\n        if (_wallets[msg.sender].addr == address(0)) {\\r\\n            _wallets[msg.sender].addr = msg.sender;\\r\\n            _walletKeys.push(msg.sender);\\r\\n        }\\r\\n        \\r\\n        _wallets[msg.sender].register(_registerBonus, _codes);\\r\\n        _registeredHunters.push(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Verifies Bounty Hunters and adds their collected bounty rewards\\r\\n     * @param hunters list of Bounty Hunters\\r\\n     * @param bonuses list of bounty rewards (18 decimals)\\r\\n     * NOTE Lists need to be of same length\\r\\n     */\\r\\n    function verifyHunters(address[] memory hunters, uint256[] memory bonuses) public afterEnd aboveSoftCap onlyOwner {\\r\\n        require(hunters.length == bonuses.length, \\\"Data length mismatch\\\");\\r\\n        for (uint256 i = 0; i \\u003c hunters.length; ++i) {\\r\\n            // Verify without purchase\\r\\n            if (_wallets[hunters[i]].addr == address(0)) {\\r\\n                _wallets[hunters[i]].addr = payable(hunters[i]);\\r\\n                _walletKeys.push(msg.sender);\\r\\n            }\\r\\n            _wallets[hunters[i]].verify(bonuses[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfers the contract\\u0027s wei to a wallet, after Token Sale ended and has reached the soft cap\\r\\n     * @param wallet address to send wei to\\r\\n     */\\r\\n    function claimETH(address payable wallet) public afterEnd aboveSoftCap onlyOwner {\\r\\n        wallet.transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Lets a wallet claim their ZAPP through the Zappermint Token Contract, after claim opening time \\r\\n     *   and if token sale has reached the soft cap\\r\\n     * @return Amount of bought ZAPP and amount of bonus ZAPP\\r\\n     * NOTE The payout implementation of this can be found in the Zappermint Token Contract\\r\\n     */\\r\\n    function claimZAPP() public afterEnd aboveSoftCap whileClaimable onlyZAPPContract returns (uint256, uint256) {\\r\\n        address beneficiary = tx.origin; // Use tx, as msg points to the Zappermint Token Contract\\r\\n\\r\\n        require(!hasWalletClaimed(beneficiary), \\\"Already claimed\\\");\\r\\n        uint256 zapp = getBuyerZAPP(beneficiary);\\r\\n        uint256 bonus = getWalletTotalBonus(beneficiary);\\r\\n\\r\\n        // Adjust claimed state\\r\\n        _wallets[beneficiary].claimed = true;\\r\\n\\r\\n        // Return amount of ZAPP and bonus of the wallet\\r\\n        // NOTE Returned separately so the Token Contract can send the ZAPP from the correct pools\\r\\n        return (zapp, bonus);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Lets the buyer claim their ETH, after Token Sale ended and hasn\\u0027t reached the soft cap\\r\\n     */\\r\\n    function claimRefund() public afterEnd belowSoftCap {\\r\\n        address beneficiary = msg.sender;\\r\\n\\r\\n        require(_wallets[beneficiary].isBuyer, \\\"Not a buyer\\\");\\r\\n        require(!_wallets[beneficiary].claimed, \\\"Already claimed\\\");\\r\\n\\r\\n        // Get buyer variables before changing state (otherwise will return 0!)\\r\\n        uint256 zapp = getBuyerZAPP(beneficiary);\\r\\n        uint256 eth = getBuyerETH(beneficiary);\\r\\n\\r\\n        // Adjust claimed state\\r\\n        _wallets[beneficiary].claimed = true;\\r\\n\\r\\n        // Adjust Token Sale state\\r\\n        _soldZAPP = _soldZAPP.sub(zapp);\\r\\n\\r\\n        // Refund the ETH of the buyer\\r\\n        _wallets[beneficiary].addr.transfer(eth);\\r\\n    }\\r\\n\\r\\n// ----\\r\\n// Internal functions\\r\\n// ----\\r\\n\\r\\n    /**\\r\\n     * Calculate amount of ZAPP for a given amount of wei\\r\\n     * @param weiAmount amount of wei\\r\\n     * @param rate ZAPP/ETH rate\\r\\n     * @return ZAPP bits (18 decimals)\\r\\n     * NOTE Internally used as optimization by avoiding multiple Chainlink calls\\r\\n     */\\r\\n    function _calculateZAPPAmount(uint256 weiAmount, uint256 rate) internal pure returns (uint256) {\\r\\n        return weiAmount.mul(rate);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate amount of ETH for a given amount of ZAPP bits\\r\\n     * @param zappAmount amount of ZAPP bits (18 decimals)\\r\\n     * @param rate ZAPP/ETH rate\\r\\n     * @return wei\\r\\n     * NOTE Internally used as optimization by avoiding multiple Chainlink calls\\r\\n     */\\r\\n    function _calculateETHAmount(uint256 zappAmount, uint256 rate) internal pure returns (uint256) {\\r\\n        return zappAmount.div(rate);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Buys ZAPP\\r\\n     * @param beneficiary address of buyer\\r\\n     * @param eth amount of ETH sent\\r\\n     * @return Amount of ZAPP bought\\r\\n     */\\r\\n    function _buyZAPP(address beneficiary, uint256 eth) internal returns (uint256) {\\r\\n        // Verify amount of ETH\\r\\n        require(eth \\u003e 0, \\\"Not enough ETH\\\");\\r\\n\\r\\n        // First purchase\\r\\n        if (_wallets[beneficiary].addr == address(0)) {\\r\\n            _wallets[beneficiary].addr = payable(beneficiary);\\r\\n            _walletKeys.push(beneficiary);\\r\\n        }\\r\\n\\r\\n        // Make sure the rate is consistent in this purchase\\r\\n        uint256 rate = getRate();\\r\\n\\r\\n        // Calculate the amount of ZAPP to receive and add it to the total sold\\r\\n        uint256 zapp = _calculateZAPPAmount(eth, rate); \\r\\n        _soldZAPP = _soldZAPP.add(zapp);\\r\\n\\r\\n        // Verify that this purchase isn\\u0027t surpassing the hard cap, otherwise refund exceeding amount \\r\\n        int256 exceeding = int256(_soldZAPP - _hardCap);\\r\\n        uint256 exceedingZAPP = 0;\\r\\n        uint256 exceedingETH = 0;\\r\\n        if (exceeding \\u003e 0) {\\r\\n            // Adjust sold amount and close Token Sale\\r\\n            _soldZAPP = _hardCap;\\r\\n            _ended = true;\\r\\n\\r\\n            // Adjust amount of bought ZAPP and paid ETH\\r\\n            exceedingZAPP = uint256(exceeding);\\r\\n            exceedingETH = _calculateETHAmount(exceedingZAPP, rate);\\r\\n            zapp = zapp.sub(exceedingZAPP);\\r\\n            eth = eth.sub(exceedingETH);\\r\\n        }\\r\\n\\r\\n        // Adjust the buyer\\r\\n        _wallets[beneficiary].purchase(eth, zapp);\\r\\n\\r\\n        // Purchase adds total bought ZAPP to more than referrer minimum\\r\\n        if (!_wallets[beneficiary].isReferrer \\u0026\\u0026 _wallets[beneficiary].buyer.zapp \\u003e= _referrerMin) {\\r\\n            _wallets[beneficiary].isReferrer = true;\\r\\n            _wallets[beneficiary].generateReferralCode(_codes);\\r\\n        }\\r\\n\\r\\n        // Refund the exceeding ETH\\r\\n        // NOTE Checks-Effects-Interactions pattern\\r\\n        if (exceeding \\u003e 0) _wallets[beneficiary].addr.transfer(exceedingETH);\\r\\n\\r\\n        return zapp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Assigns all active bonuses for a purchase\\r\\n     * @param beneficiary address of the buyer\\r\\n     * @param zapp amount of ZAPP bits purchased (18 decimals)\\r\\n     * @param code used referral code (set to 0 if no code used)\\r\\n     */\\r\\n    function _assignBonuses(address beneficiary, uint256 zapp, bytes3 code) internal {\\r\\n        // Referral bonus if code is valid and purchased enough ZAPP\\r\\n        if (isReferralCodeValid(code)) {\\r\\n            if (zapp \\u003e= _refereeMin) {\\r\\n                _wallets[beneficiary].referral(zapp, _wallets[_codes[code]]);\\r\\n            }\\r\\n        }\\r\\n        // Early adopter bonus if code invalid and early adoption active\\r\\n        else {\\r\\n            if (isEarlyAdoptionActive()) {\\r\\n                _wallets[beneficiary].earlyAdoption(zapp);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zappPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refereeMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"rankRewards\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256\",\"name\":\"earlyAdoptionEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earlyAdoptionBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxHunters\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registerBonus\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"internalType\":\"struct ZappermintTokenSale.ContractArguments\",\"name\":\"args\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"buyZAPP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes3\",\"name\":\"code\",\"type\":\"bytes3\"}],\"name\":\"buyZAPPWithCode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zappAmount\",\"type\":\"uint256\"}],\"name\":\"calculateETHAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"calculateZAPPAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canRegister\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"claimETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTokenSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBuyerETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBuyerZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClosingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getEarlyAdopterBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarlyAdoptionBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarlyAdoptionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getHunterBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxHunters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpeningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRankRewards\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getRefereeBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRefereeMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferralBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferralCode\",\"outputs\":[{\"internalType\":\"bytes3\",\"name\":\"\",\"type\":\"bytes3\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReferrals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReferrerBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferrerMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReferrerRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReferrerRankReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisterBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredHunters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSoftCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSoldZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTopReferrers\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalEarlyAdoptionZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalHunterReferredZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalReferredZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWithoutCodeZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWalletTotalBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWalletTotalZAPP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getZAPPContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasWalletClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClaimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEarlyAdoptionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isHardCapReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isHunter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isHunterRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isHunterVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes3\",\"name\":\"code\",\"type\":\"bytes3\"}],\"name\":\"isReferralCodeValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSoftCapReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerHunter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setETHPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMaxHunters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zappContract\",\"type\":\"address\"}],\"name\":\"setZAPPContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"hunters\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bonuses\",\"type\":\"uint256[]\"}],\"name\":\"verifyHunters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ZappermintTokenSale","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000060008664000000000000000000000000000000000000000000000000000000006029652000000000000000000000000000000000000000000000000000000000604e4f2000000000000000000000000000000000000000000004f68ca6d8cd91c60000000000000000000000000000000000000000000000006342fd08f00f6378000000000000000000000000000000000000000000000000000000000000199c82cc0000000000000000000000000000000000000000000000000000000000004c4b4000000000000000000000000000000000000000000000006c6b935b8bbd400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004c4b4000000000000000000000000000000000000000000000043c33c193756480000000000000000000000000000000000000000000000000028a857425466f8000000000000000000000000000000000000000000000000001b1ae4d6e2ef500000000000000000000000000000000000000000000000000014542ba12a337c000000000000000000000000000000000000000000000000000d8d726b7177a8000000000000000000000000000000000000000000000000000000000000060047ae400000000000000000000000000000000000000000000000000000000004c4b400000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000015af1d78b58c4000000000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419","EVMVersion":"istanbul","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1d0858d59e56a19d64cdefe33f91d753a660559bc824bf788ea632eaa549637a"}]}