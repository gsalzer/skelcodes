{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.0;\r\npragma abicoder v2;\r\n\r\n\r\ninterface MassetStructs {\r\n    struct BassetPersonal {\r\n        // Address of the bAsset\r\n        address addr;\r\n        // Address of the bAsset\r\n        address integrator;\r\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n        bool hasTxFee; // takes a byte in storage\r\n        // Status of the bAsset\r\n        BassetStatus status;\r\n    }\r\n\r\n    struct BassetData {\r\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n        uint128 ratio;\r\n        // Amount of the Basset that is held in Collateral\r\n        uint128 vaultBalance;\r\n    }\r\n\r\n    // Status of the Basset - has it broken its peg?\r\n    enum BassetStatus {\r\n        Default,\r\n        Normal,\r\n        BrokenBelowPeg,\r\n        BrokenAbovePeg,\r\n        Blacklisted,\r\n        Liquidating,\r\n        Liquidated,\r\n        Failed\r\n    }\r\n\r\n    struct BasketState {\r\n        bool undergoingRecol;\r\n        bool failed;\r\n    }\r\n\r\n    struct InvariantConfig {\r\n        uint256 a;\r\n        WeightLimits limits;\r\n    }\r\n\r\n    struct WeightLimits {\r\n        uint128 min;\r\n        uint128 max;\r\n    }\r\n\r\n    struct AmpData {\r\n        uint64 initialA;\r\n        uint64 targetA;\r\n        uint64 rampStartTime;\r\n        uint64 rampEndTime;\r\n    }\r\n}\r\n\r\nabstract contract IInvariantValidator is MassetStructs {\r\n    // Mint\r\n    function computeMint(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _rawInput,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    function computeMintMulti(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawInputs,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    // Swap\r\n    function computeSwap(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint8 _o,\r\n        uint256 _rawInput,\r\n        uint256 _feeRate,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256, uint256);\r\n\r\n    // Redeem\r\n    function computeRedeem(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _mAssetQuantity,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    function computeRedeemExact(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawOutputs,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n}\r\n\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC205 is Context, IERC20 {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] -= amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()] - amount);\r\n    }\r\n}\r\n\r\nabstract contract InitializableERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(\r\n        string memory nameArg,\r\n        string memory symbolArg,\r\n        uint8 decimalsArg\r\n    ) internal {\r\n        _name = nameArg;\r\n        _symbol = symbolArg;\r\n        _decimals = decimalsArg;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\nabstract contract InitializableToken is ERC205, InitializableERC20Detailed {\r\n    /**\r\n     * @dev Initialization function for implementing contract\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(string memory _nameArg, string memory _symbolArg) internal {\r\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\r\n    }\r\n}\r\n\r\ncontract ModuleKeys {\r\n    // Governance\r\n    // ===========\r\n    // keccak256(\"Governance\");\r\n    bytes32 internal constant KEY_GOVERNANCE =\r\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\r\n    //keccak256(\"Staking\");\r\n    bytes32 internal constant KEY_STAKING =\r\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\r\n    //keccak256(\"ProxyAdmin\");\r\n    bytes32 internal constant KEY_PROXY_ADMIN =\r\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\r\n\r\n    // mStable\r\n    // =======\r\n    // keccak256(\"OracleHub\");\r\n    bytes32 internal constant KEY_ORACLE_HUB =\r\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\r\n    // keccak256(\"Manager\");\r\n    bytes32 internal constant KEY_MANAGER =\r\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\r\n    //keccak256(\"Recollateraliser\");\r\n    bytes32 internal constant KEY_RECOLLATERALISER =\r\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\r\n    //keccak256(\"MetaToken\");\r\n    bytes32 internal constant KEY_META_TOKEN =\r\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\r\n    // keccak256(\"SavingsManager\");\r\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\r\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\r\n    // keccak256(\"Liquidator\");\r\n    bytes32 internal constant KEY_LIQUIDATOR =\r\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\r\n}\r\n\r\ninterface INexus {\r\n    function governor() external view returns (address);\r\n\r\n    function getModule(bytes32 key) external view returns (address);\r\n\r\n    function proposeModule(bytes32 _key, address _addr) external;\r\n\r\n    function cancelProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModules(bytes32[] calldata _keys) external;\r\n\r\n    function requestLockModule(bytes32 _key) external;\r\n\r\n    function cancelLockModule(bytes32 _key) external;\r\n\r\n    function lockModule(bytes32 _key) external;\r\n}\r\n\r\nabstract contract ImmutableModule is ModuleKeys {\r\n    INexus public immutable nexus;\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contracts\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) {\r\n        require(_nexus != address(0), \"Nexus address is zero\");\r\n        nexus = INexus(_nexus);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        _onlyGovernor();\r\n        _;\r\n    }\r\n\r\n    function _onlyGovernor() internal view {\r\n        require(msg.sender == _governor(), \"Only governor can execute\");\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governance.\r\n     *      Governance is either Governor address or Governance address.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == _governor() || msg.sender == _governance(),\r\n            \"Only governance can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the ProxyAdmin.\r\n     */\r\n    modifier onlyProxyAdmin() {\r\n        require(msg.sender == _proxyAdmin(), \"Only ProxyAdmin can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == _manager(), \"Only manager can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governor address from the Nexus\r\n     * @return Address of Governor Contract\r\n     */\r\n    function _governor() internal view returns (address) {\r\n        return nexus.governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governance Module address from the Nexus\r\n     * @return Address of the Governance (Phase 2)\r\n     */\r\n    function _governance() internal view returns (address) {\r\n        return nexus.getModule(KEY_GOVERNANCE);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Staking Module address from the Nexus\r\n     * @return Address of the Staking Module contract\r\n     */\r\n    function _staking() internal view returns (address) {\r\n        return nexus.getModule(KEY_STAKING);\r\n    }\r\n\r\n    /**\r\n     * @dev Return ProxyAdmin Module address from the Nexus\r\n     * @return Address of the ProxyAdmin Module contract\r\n     */\r\n    function _proxyAdmin() internal view returns (address) {\r\n        return nexus.getModule(KEY_PROXY_ADMIN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return MetaToken Module address from the Nexus\r\n     * @return Address of the MetaToken Module contract\r\n     */\r\n    function _metaToken() internal view returns (address) {\r\n        return nexus.getModule(KEY_META_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return OracleHub Module address from the Nexus\r\n     * @return Address of the OracleHub Module contract\r\n     */\r\n    function _oracleHub() internal view returns (address) {\r\n        return nexus.getModule(KEY_ORACLE_HUB);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Manager Module address from the Nexus\r\n     * @return Address of the Manager Module contract\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return nexus.getModule(KEY_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return SavingsManager Module address from the Nexus\r\n     * @return Address of the SavingsManager Module contract\r\n     */\r\n    function _savingsManager() internal view returns (address) {\r\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Recollateraliser Module address from the Nexus\r\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\r\n     */\r\n    function _recollateraliser() internal view returns (address) {\r\n        return nexus.getModule(KEY_RECOLLATERALISER);\r\n    }\r\n}\r\n\r\ncontract InitializableReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    function _initializeReentrancyGuard() internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\nabstract contract IMasset is MassetStructs {\r\n    // Mint\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    // Swaps\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 swapOutput);\r\n\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view virtual returns (uint256 swapOutput);\r\n\r\n    // Redemption\r\n    function redeem(\r\n        address _output,\r\n        uint256 _mAssetQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 outputQuantity);\r\n\r\n    function redeemMasset(\r\n        uint256 _mAssetQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external virtual returns (uint256[] memory outputQuantities);\r\n\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mAssetRedeemed);\r\n\r\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 bAssetOutput);\r\n\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view virtual returns (uint256 mAssetAmount);\r\n\r\n    // Views\r\n    function getBasket() external view virtual returns (bool, bool);\r\n\r\n    function getBasset(address _token)\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal memory personal, BassetData memory data);\r\n\r\n    function getBassets()\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\r\n\r\n    function bAssetIndexes(address) external view virtual returns (uint8);\r\n\r\n    // SavingsManager\r\n    function collectInterest() external virtual returns (uint256 swapFeesGained, uint256 newSupply);\r\n\r\n    function collectPlatformInterest()\r\n        external\r\n        virtual\r\n        returns (uint256 mintAmount, uint256 newSupply);\r\n\r\n    // Admin\r\n    function setCacheSize(uint256 _cacheSize) external virtual;\r\n\r\n    function upgradeForgeValidator(address _newForgeValidator) external virtual;\r\n\r\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external virtual;\r\n\r\n    function setTransferFeesFlag(address _bAsset, bool _flag) external virtual;\r\n\r\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external virtual;\r\n}\r\n\r\nabstract contract Deprecated_BasketManager is MassetStructs {}\r\n\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e38 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x * ratio;\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled + RATIO_SCALE - 1;\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil / RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        // return 1e22 / 1e12 = 1e10\r\n        return (x * RATIO_SCALE) / ratio;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\ninterface IPlatformIntegration {\r\n    /**\r\n     * @dev Deposit the given bAsset to Lending platform\r\n     * @param _bAsset bAsset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool isTokenFeeCharged\r\n    ) external returns (uint256 quantityDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        uint256 _totalAmount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from the cache\r\n     */\r\n    function withdrawRaw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given bAsset\r\n     */\r\n    function checkBalance(address _bAsset) external returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the pToken\r\n     */\r\n    function bAssetToPToken(address _bAsset) external returns (address pToken);\r\n}\r\n\r\ninterface IBasicToken {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MassetHelpers {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function transferReturnBalance(\r\n        address _sender,\r\n        address _recipient,\r\n        address _bAsset,\r\n        uint256 _qty\r\n    ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\r\n        uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\r\n        IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\r\n        recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\r\n        receivedQty = recipientBalance - balBefore;\r\n    }\r\n\r\n    function safeInfiniteApprove(address _asset, address _spender) internal {\r\n        IERC20(_asset).safeApprove(_spender, 0);\r\n        IERC20(_asset).safeApprove(_spender, 2**256 - 1);\r\n    }\r\n}\r\n\r\nlibrary Manager {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\r\n    event TransferFeeEnabled(address indexed bAsset, bool enabled);\r\n    event BassetAdded(address indexed bAsset, address integrator);\r\n    event BassetStatusChanged(address indexed bAsset, MassetStructs.BassetStatus status);\r\n    event BasketStatusChanged();\r\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    uint256 private constant MIN_RAMP_TIME = 1 days;\r\n    uint256 private constant MAX_A = 1e6;\r\n\r\n    /**\r\n     * @notice Adds a bAsset to the given personal, data and mapping, provided it is valid\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssetData       Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _maxBassets       Max size of the basket\r\n     * @param _bAsset           Address of the ERC20 token to add to the Basket\r\n     * @param _integration      Address of the Platform Integration\r\n     * @param _mm               Base 1e8 var to determine measurement ratio\r\n     * @param _hasTxFee         Are transfer fees charged on this bAsset (e.g. USDT)\r\n     */\r\n    function addBasset(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        MassetStructs.BassetData[] storage _bAssetData,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        uint8 _maxBassets,\r\n        address _bAsset,\r\n        address _integration,\r\n        uint256 _mm,\r\n        bool _hasTxFee\r\n    ) external {\r\n        require(_bAsset != address(0), \"bAsset address must be valid\");\r\n        uint8 bAssetCount = uint8(_bAssetPersonal.length);\r\n        require(bAssetCount < _maxBassets, \"Max bAssets in Basket\");\r\n\r\n        uint8 idx = _bAssetIndexes[_bAsset];\r\n        require(\r\n            bAssetCount == 0 || _bAssetPersonal[idx].addr != _bAsset,\r\n            \"bAsset already exists in Basket\"\r\n        );\r\n\r\n        // Should fail if bAsset is not added to integration\r\n        // Programmatic enforcement of bAsset validity should service through decentralised feed\r\n        if (_integration != address(0)) {\r\n            IPlatformIntegration(_integration).checkBalance(_bAsset);\r\n        }\r\n\r\n        uint256 bAssetDecimals = IBasicToken(_bAsset).decimals();\r\n        require(\r\n            bAssetDecimals >= 4 && bAssetDecimals <= 18,\r\n            \"Token must have sufficient decimal places\"\r\n        );\r\n\r\n        uint256 delta = uint256(18) - bAssetDecimals;\r\n        uint256 ratio = _mm * (10**delta);\r\n\r\n        _bAssetIndexes[_bAsset] = bAssetCount;\r\n\r\n        _bAssetPersonal.push(\r\n            MassetStructs.BassetPersonal({\r\n                addr: _bAsset,\r\n                integrator: _integration,\r\n                hasTxFee: _hasTxFee,\r\n                status: MassetStructs.BassetStatus.Normal\r\n            })\r\n        );\r\n        _bAssetData.push(\r\n            MassetStructs.BassetData({ ratio: SafeCast.toUint128(ratio), vaultBalance: 0 })\r\n        );\r\n\r\n        emit BassetAdded(_bAsset, _integration);\r\n    }\r\n\r\n    /**\r\n     * @dev Collects the interest generated from the Basket, minting a relative\r\n     *      amount of mAsset and sending it over to the SavingsManager.\r\n     * @param _bAssetPersonal   Basset personal storage array\r\n     * @param _bAssetData       Basset data storage array\r\n     * @param _forgeValidator   Link to the current InvariantValidator\r\n     * @return mintAmount       Lending market interest collected\r\n     * @return rawGains         Raw increases in vault Balance\r\n     */\r\n    function collectPlatformInterest(\r\n        MassetStructs.BassetPersonal[] memory _bAssetPersonal,\r\n        MassetStructs.BassetData[] storage _bAssetData,\r\n        IInvariantValidator _forgeValidator,\r\n        MassetStructs.InvariantConfig memory _config\r\n    ) external returns (uint256 mintAmount, uint256[] memory rawGains) {\r\n        // Get basket details\r\n        MassetStructs.BassetData[] memory bAssetData_ = _bAssetData;\r\n        uint256 count = bAssetData_.length;\r\n        uint8[] memory indices = new uint8[](count);\r\n        rawGains = new uint256[](count);\r\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\r\n        for (uint256 i = 0; i < count; i++) {\r\n            indices[i] = uint8(i);\r\n            MassetStructs.BassetPersonal memory bPersonal = _bAssetPersonal[i];\r\n            MassetStructs.BassetData memory bData = bAssetData_[i];\r\n            // If there is no integration, then nothing can have accrued\r\n            if (bPersonal.integrator == address(0)) continue;\r\n            uint256 lending =\r\n                IPlatformIntegration(bPersonal.integrator).checkBalance(bPersonal.addr);\r\n            uint256 cache = 0;\r\n            if (!bPersonal.hasTxFee) {\r\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\r\n            }\r\n            uint256 balance = lending + cache;\r\n            uint256 oldVaultBalance = bData.vaultBalance;\r\n            if (\r\n                balance > oldVaultBalance && bPersonal.status == MassetStructs.BassetStatus.Normal\r\n            ) {\r\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\r\n                uint256 interestDelta = balance - oldVaultBalance;\r\n                rawGains[i] = interestDelta;\r\n            } else {\r\n                rawGains[i] = 0;\r\n            }\r\n        }\r\n        mintAmount = _forgeValidator.computeMintMulti(bAssetData_, indices, rawGains, _config);\r\n    }\r\n\r\n    /**\r\n     * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _bAsset   bAsset address\r\n     * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\r\n     */\r\n    function setTransferFeesFlag(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _bAsset,\r\n        bool _flag\r\n    ) external {\r\n        uint256 index = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\r\n        _bAssetPersonal[index].hasTxFee = _flag;\r\n\r\n        if (_flag) {\r\n            // if token has tx fees, it can no longer operate with a cache\r\n            address integration = _bAssetPersonal[index].integrator;\r\n            if (integration != address(0)) {\r\n                uint256 bal = IERC20(_bAsset).balanceOf(integration);\r\n                if (bal > 0) {\r\n                    IPlatformIntegration(integration).deposit(_bAsset, bal, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        emit TransferFeeEnabled(_bAsset, _flag);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all collateral from one lending market to another - used initially\r\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\r\n     *      tx fee enabled assets. Supports going from no integration to integration, but\r\n     *      not the other way around.\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _bAssets          Array of basket assets to migrate\r\n     * @param _newIntegration   Address of the new platform integration\r\n     */\r\n    function migrateBassets(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address[] calldata _bAssets,\r\n        address _newIntegration\r\n    ) external {\r\n        uint256 len = _bAssets.length;\r\n        require(len > 0, \"Must migrate some bAssets\");\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // 1. Check that the bAsset is in the basket\r\n            address bAsset = _bAssets[i];\r\n            uint256 index = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, bAsset);\r\n            require(!_bAssetPersonal[index].hasTxFee, \"A bAsset has a transfer fee\");\r\n\r\n            // 2. Withdraw everything from the old platform integration\r\n            address oldAddress = _bAssetPersonal[index].integrator;\r\n            require(oldAddress != _newIntegration, \"Must transfer to new integrator\");\r\n            (uint256 cache, uint256 lendingBal) = (0, 0);\r\n            if (oldAddress == address(0)) {\r\n                cache = IERC20(bAsset).balanceOf(address(this));\r\n            } else {\r\n                IPlatformIntegration oldIntegration = IPlatformIntegration(oldAddress);\r\n                cache = IERC20(bAsset).balanceOf(address(oldIntegration));\r\n                // 2.1. Withdraw from the lending market\r\n                lendingBal = oldIntegration.checkBalance(bAsset);\r\n                if (lendingBal > 0) {\r\n                    oldIntegration.withdraw(address(this), bAsset, lendingBal, false);\r\n                }\r\n                // 2.2. Withdraw from the cache, if any\r\n                if (cache > 0) {\r\n                    oldIntegration.withdrawRaw(address(this), bAsset, cache);\r\n                }\r\n            }\r\n            uint256 sum = lendingBal + cache;\r\n\r\n            // 3. Update the integration address for this bAsset\r\n            _bAssetPersonal[index].integrator = _newIntegration;\r\n\r\n            // 4. Deposit everything into the new\r\n            //    This should fail if we did not receive the full amount from the platform withdrawal\r\n            // 4.1. Deposit all bAsset\r\n            IERC20(bAsset).safeTransfer(_newIntegration, sum);\r\n            IPlatformIntegration newIntegration = IPlatformIntegration(_newIntegration);\r\n            if (lendingBal > 0) {\r\n                newIntegration.deposit(bAsset, lendingBal, false);\r\n            }\r\n            // 4.2. Check balances\r\n            uint256 newLendingBal = newIntegration.checkBalance(bAsset);\r\n            uint256 newCache = IERC20(bAsset).balanceOf(address(newIntegration));\r\n            uint256 upperMargin = 10001e14;\r\n            uint256 lowerMargin = 9999e14;\r\n\r\n            require(\r\n                newLendingBal >= lendingBal.mulTruncate(lowerMargin) &&\r\n                    newLendingBal <= lendingBal.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n            require(\r\n                newCache >= cache.mulTruncate(lowerMargin) &&\r\n                    newCache <= cache.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n        }\r\n\r\n        emit BassetsMigrated(_bAssets, _newIntegration);\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\r\n     * @param _basket          Struct containing core basket info\r\n     * @param _bAssetPersonal  Basset data storage array\r\n     * @param _bAsset          Address of the ERC20 token to isolate\r\n     * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\r\n     *                         or above (f)\r\n     */\r\n    function handlePegLoss(\r\n        MassetStructs.BasketState storage _basket,\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _bAsset,\r\n        bool _belowPeg\r\n    ) external {\r\n        require(!_basket.failed, \"Basket must be alive\");\r\n\r\n        uint256 i = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\r\n\r\n        MassetStructs.BassetStatus newStatus =\r\n            _belowPeg\r\n                ? MassetStructs.BassetStatus.BrokenBelowPeg\r\n                : MassetStructs.BassetStatus.BrokenAbovePeg;\r\n        _bAssetPersonal[i].status = newStatus;\r\n\r\n        _basket.undergoingRecol = true;\r\n\r\n        emit BassetStatusChanged(_bAsset, newStatus);\r\n    }\r\n\r\n    /**\r\n     * @dev Negates the isolation of a given bAsset\r\n     * @param _basket          Struct containing core basket info\r\n     * @param _bAssetPersonal  Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _bAsset Address of the bAsset\r\n     */\r\n    function negateIsolation(\r\n        MassetStructs.BasketState storage _basket,\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _bAsset\r\n    ) external {\r\n        uint256 i = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\r\n\r\n        _bAssetPersonal[i].status = MassetStructs.BassetStatus.Normal;\r\n\r\n        bool undergoingRecol = false;\r\n        for (uint256 j = 0; j < _bAssetPersonal.length; j++) {\r\n            if (_bAssetPersonal[j].status != MassetStructs.BassetStatus.Normal) {\r\n                undergoingRecol = true;\r\n                break;\r\n            }\r\n        }\r\n        _basket.undergoingRecol = undergoingRecol;\r\n\r\n        emit BassetStatusChanged(_bAsset, MassetStructs.BassetStatus.Normal);\r\n    }\r\n\r\n    /**\r\n     * @dev Starts changing of the amplification var A\r\n     * @param _targetA      Target A value\r\n     * @param _rampEndTime  Time at which A will arrive at _targetA\r\n     */\r\n    function startRampA(\r\n        MassetStructs.AmpData storage _ampData,\r\n        uint256 _targetA,\r\n        uint256 _rampEndTime,\r\n        uint256 _currentA,\r\n        uint256 _precision\r\n    ) external {\r\n        require(\r\n            block.timestamp >= (_ampData.rampStartTime + MIN_RAMP_TIME),\r\n            \"Sufficient period of previous ramp has not elapsed\"\r\n        );\r\n        require(_rampEndTime >= (block.timestamp + MIN_RAMP_TIME), \"Ramp time too short\");\r\n        require(_targetA > 0 && _targetA < MAX_A, \"A target out of bounds\");\r\n\r\n        uint256 preciseTargetA = _targetA * _precision;\r\n\r\n        if (preciseTargetA > _currentA) {\r\n            require(preciseTargetA <= _currentA * 10, \"A target increase too big\");\r\n        } else {\r\n            require(preciseTargetA >= _currentA / 10, \"A target decrease too big\");\r\n        }\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(preciseTargetA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(_rampEndTime);\r\n\r\n        emit StartRampA(_currentA, preciseTargetA, block.timestamp, _rampEndTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the changing of the amplification var A, setting\r\n     * it to whatever the current value is.\r\n     */\r\n    function stopRampA(MassetStructs.AmpData storage _ampData, uint256 _currentA) external {\r\n        require(block.timestamp < _ampData.rampEndTime, \"Amplification not changing\");\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(_currentA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(block.timestamp);\r\n\r\n        emit StopRampA(_currentA, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets a bAsset index from storage\r\n     * @param _asset      Address of the asset\r\n     * @return idx        Index of the asset\r\n     */\r\n    function _getAssetIndex(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _asset\r\n    ) internal view returns (uint8 idx) {\r\n        idx = _bAssetIndexes[_asset];\r\n        require(_bAssetPersonal[idx].addr == _asset, \"Invalid asset input\");\r\n    }\r\n\r\n    /***************************************\r\n                    FORGING\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Deposits a given asset to the system. If there is sufficient room for the asset\r\n     * in the cache, then just transfer, otherwise reset the cache to the desired mid level by\r\n     * depositing the delta in the platform\r\n     */\r\n    function depositTokens(\r\n        MassetStructs.BassetPersonal memory _bAsset,\r\n        uint256 _bAssetRatio,\r\n        uint256 _quantity,\r\n        uint256 _maxCache\r\n    ) external returns (uint256 quantityDeposited) {\r\n        // 0. If integration is 0, short circuit\r\n        if (_bAsset.integrator == address(0)) {\r\n            (uint256 received, ) =\r\n                MassetHelpers.transferReturnBalance(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _bAsset.addr,\r\n                    _quantity\r\n                );\r\n            return received;\r\n        }\r\n\r\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\r\n        uint256 cacheBal;\r\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\r\n            msg.sender,\r\n            _bAsset.integrator,\r\n            _bAsset.addr,\r\n            _quantity\r\n        );\r\n\r\n        // 2 - Deposit X if necessary\r\n        // 2.1 - Deposit if xfer fees\r\n        if (_bAsset.hasTxFee) {\r\n            uint256 deposited =\r\n                IPlatformIntegration(_bAsset.integrator).deposit(\r\n                    _bAsset.addr,\r\n                    quantityDeposited,\r\n                    true\r\n                );\r\n\r\n            return StableMath.min(deposited, quantityDeposited);\r\n        }\r\n        // 2.2 - Else Deposit X if Cache > %\r\n        // This check is in place to ensure that any token with a txFee is rejected\r\n        require(quantityDeposited == _quantity, \"Asset not fully transferred\");\r\n\r\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\r\n\r\n        if (cacheBal > relativeMaxCache) {\r\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\r\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws a given asset from its platformIntegration. If there is sufficient liquidity\r\n     * in the cache, then withdraw from there, otherwise withdraw from the lending market and reset the\r\n     * cache to the mid level.\r\n     */\r\n    function withdrawTokens(\r\n        uint256 _quantity,\r\n        MassetStructs.BassetPersonal memory _personal,\r\n        MassetStructs.BassetData memory _data,\r\n        address _recipient,\r\n        uint256 _maxCache\r\n    ) external {\r\n        if (_quantity == 0) return;\r\n\r\n        // 1.0 If there is no integrator, send from here\r\n        if (_personal.integrator == address(0)) {\r\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\r\n        }\r\n        // 1.1 If txFee then short circuit - there is no cache\r\n        else if (_personal.hasTxFee) {\r\n            IPlatformIntegration(_personal.integrator).withdraw(\r\n                _recipient,\r\n                _personal.addr,\r\n                _quantity,\r\n                _quantity,\r\n                true\r\n            );\r\n        }\r\n        // 1.2. Else, withdraw from either cache or main vault\r\n        else {\r\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\r\n            // 2.1 - If balance b in cache, simply withdraw\r\n            if (cacheBal >= _quantity) {\r\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity\r\n                );\r\n            }\r\n            // 2.2 - Else reset the cache to X, or as far as possible\r\n            //       - Withdraw X+b from platform\r\n            //       - Send b to user\r\n            else {\r\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\r\n                uint256 totalWithdrawal =\r\n                    StableMath.min(\r\n                        relativeMidCache + _quantity - cacheBal,\r\n                        _data.vaultBalance - SafeCast.toUint128(cacheBal)\r\n                    );\r\n\r\n                IPlatformIntegration(_personal.integrator).withdraw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity,\r\n                    totalWithdrawal,\r\n                    false\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// External\r\n// Internal\r\n// Libs\r\n/**\r\n * @title   Masset\r\n * @author  mStable\r\n * @notice  An incentivised constant sum market maker with hard limits at max region. This supports\r\n *          low slippage swaps and applies penalties towards min and max regions. AMM produces a\r\n *          stablecoin (mAsset) and redirects lending market interest and swap fees to the savings\r\n *          contract, producing a second yield bearing asset.\r\n * @dev     VERSION: 3.0\r\n *          DATE:    2021-01-22\r\n */\r\ncontract Masset is\r\n    IMasset,\r\n    Initializable,\r\n    InitializableToken,\r\n    ImmutableModule,\r\n    InitializableReentrancyGuard\r\n{\r\n    using StableMath for uint256;\r\n\r\n    // Forging Events\r\n    event Minted(\r\n        address indexed minter,\r\n        address recipient,\r\n        uint256 mAssetQuantity,\r\n        address input,\r\n        uint256 inputQuantity\r\n    );\r\n    event MintedMulti(\r\n        address indexed minter,\r\n        address recipient,\r\n        uint256 mAssetQuantity,\r\n        address[] inputs,\r\n        uint256[] inputQuantities\r\n    );\r\n    event Swapped(\r\n        address indexed swapper,\r\n        address input,\r\n        address output,\r\n        uint256 outputAmount,\r\n        uint256 scaledFee,\r\n        address recipient\r\n    );\r\n    event Redeemed(\r\n        address indexed redeemer,\r\n        address recipient,\r\n        uint256 mAssetQuantity,\r\n        address output,\r\n        uint256 outputQuantity,\r\n        uint256 scaledFee\r\n    );\r\n    event RedeemedMulti(\r\n        address indexed redeemer,\r\n        address recipient,\r\n        uint256 mAssetQuantity,\r\n        address[] outputs,\r\n        uint256[] outputQuantity,\r\n        uint256 scaledFee\r\n    );\r\n\r\n    // State Events\r\n    event CacheSizeChanged(uint256 cacheSize);\r\n    event FeesChanged(uint256 swapFee, uint256 redemptionFee);\r\n    event WeightLimitsChanged(uint128 min, uint128 max);\r\n    event ForgeValidatorChanged(address forgeValidator);\r\n\r\n    // Release 1.0 VARS\r\n    IInvariantValidator public forgeValidator;\r\n    bool private forgeValidatorLocked;\r\n    // Deprecated - maintain for storage layout in mUSD\r\n    Deprecated_BasketManager private deprecated_basketManager;\r\n\r\n    // Basic redemption fee information\r\n    uint256 public swapFee;\r\n    uint256 private MAX_FEE;\r\n\r\n    // Release 1.1 VARS\r\n    uint256 public redemptionFee;\r\n\r\n    // Release 2.0 VARS\r\n    uint256 public cacheSize;\r\n    uint256 public surplus;\r\n\r\n    // Release 3.0 VARS\r\n    // Struct holding Basket details\r\n    BassetPersonal[] public bAssetPersonal;\r\n    BassetData[] public bAssetData;\r\n    mapping(address => uint8) public override bAssetIndexes;\r\n    uint8 public maxBassets;\r\n    BasketState public basket;\r\n    // Amplification Data\r\n    uint256 private constant A_PRECISION = 100;\r\n    AmpData public ampData;\r\n    WeightLimits public weightLimits;\r\n\r\n    /**\r\n     * @dev Constructor to set immutable bytecode\r\n     * @param _nexus   Nexus address\r\n     */\r\n    constructor(address _nexus) ImmutableModule(_nexus) {}\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contract.\r\n     *      This function should be called via Proxy just after contract deployment.\r\n     *      To avoid variable shadowing appended `Arg` after arguments name.\r\n     * @param _nameArg          Name of the mAsset\r\n     * @param _symbolArg        Symbol of the mAsset\r\n     * @param _forgeValidator   Address of the AMM implementation\r\n     * @param _bAssets          Array of Basset data\r\n     */\r\n    function initialize(\r\n        string calldata _nameArg,\r\n        string calldata _symbolArg,\r\n        address _forgeValidator,\r\n        BassetPersonal[] calldata _bAssets,\r\n        InvariantConfig memory _config\r\n    ) public initializer {\r\n        InitializableToken._initialize(_nameArg, _symbolArg);\r\n\r\n        _initializeReentrancyGuard();\r\n\r\n        forgeValidator = IInvariantValidator(_forgeValidator);\r\n\r\n        maxBassets = 10;\r\n\r\n        uint256 len = _bAssets.length;\r\n        require(len > 0, \"No bAssets\");\r\n        for (uint256 i = 0; i < len; i++) {\r\n            Manager.addBasset(\r\n                bAssetPersonal,\r\n                bAssetData,\r\n                bAssetIndexes,\r\n                maxBassets,\r\n                _bAssets[i].addr,\r\n                _bAssets[i].integrator,\r\n                1e8,\r\n                _bAssets[i].hasTxFee\r\n            );\r\n        }\r\n\r\n        uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\r\n        ampData = AmpData(startA, startA, 0, 0);\r\n        weightLimits = _config.limits;\r\n\r\n        MAX_FEE = 2e16;\r\n        swapFee = 6e14;\r\n        redemptionFee = 3e14;\r\n        cacheSize = 1e17;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Savings Manager contract\r\n     */\r\n    modifier onlySavingsManager() {\r\n        _isSavingsManager();\r\n        _;\r\n    }\r\n\r\n    // Internal fn for modifier to reduce deployment size\r\n    function _isSavingsManager() internal view {\r\n        require(_savingsManager() == msg.sender, \"Must be savings manager\");\r\n    }\r\n\r\n    /**\r\n     * @dev Requires the overall basket composition to be healthy\r\n     */\r\n    modifier whenHealthy() {\r\n        _isHealthy();\r\n        _;\r\n    }\r\n\r\n    // Internal fn for modifier to reduce deployment size\r\n    function _isHealthy() internal view {\r\n        BasketState memory basket_ = basket;\r\n        require(!basket_.undergoingRecol && !basket_.failed, \"Unhealthy\");\r\n    }\r\n\r\n    /**\r\n     * @dev Requires the basket not to be undergoing recollateralisation\r\n     */\r\n    modifier whenNoRecol() {\r\n        _noRecol();\r\n        _;\r\n    }\r\n\r\n    // Internal fn for modifier to reduce deployment size\r\n    function _noRecol() internal view {\r\n        BasketState memory basket_ = basket;\r\n        require(!basket_.undergoingRecol, \"In recol\");\r\n    }\r\n\r\n    /***************************************\r\n                MINTING (PUBLIC)\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Mint a single bAsset, at a 1:1 ratio with the bAsset. This contract\r\n     *      must have approval to spend the senders bAsset\r\n     * @param _input             Address of the bAsset to deposit for the minted mAsset.\r\n     * @param _inputQuantity     Quantity in bAsset units\r\n     * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\r\n     * @param _recipient         Receipient of the newly minted mAsset tokens\r\n     * @return mintOutput        Quantity of newly minted mAssets for the deposited bAsset.\r\n     */\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\r\n        mintOutput = _mintTo(_input, _inputQuantity, _minOutputQuantity, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint with multiple bAssets, at a 1:1 ratio to mAsset. This contract\r\n     *      must have approval to spend the senders bAssets\r\n     * @param _inputs            Non-duplicate address array of bASset addresses to deposit for the minted mAsset tokens.\r\n     * @param _inputQuantities   Quantity of each bAsset to deposit for the minted mAsset.\r\n     *                           Order of array should mirror the above bAsset addresses.\r\n     * @param _minOutputQuantity Minimum mAsset quanity to be minted. This protects against slippage.\r\n     * @param _recipient         Address to receive the newly minted mAsset tokens\r\n     * @return mintOutput    Quantity of newly minted mAssets for the deposited bAssets.\r\n     */\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenHealthy returns (uint256 mintOutput) {\r\n        mintOutput = _mintMulti(_inputs, _inputQuantities, _minOutputQuantity, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the projected output of a given mint\r\n     * @param _input             Address of the bAsset to deposit for the minted mAsset\r\n     * @param _inputQuantity     Quantity in bAsset units\r\n     * @return mintOutput        Estimated mint output in mAsset terms\r\n     */\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 mintOutput)\r\n    {\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        (uint8 idx, ) = _getAsset(_input);\r\n\r\n        mintOutput = forgeValidator.computeMint(bAssetData, idx, _inputQuantity, _getConfig());\r\n    }\r\n\r\n    /**\r\n     * @dev Get the projected output of a given mint\r\n     * @param _inputs            Non-duplicate address array of addresses to bAssets to deposit for the minted mAsset tokens.\r\n     * @param _inputQuantities  Quantity of each bAsset to deposit for the minted mAsset.\r\n     * @return mintOutput        Estimated mint output in mAsset terms\r\n     */\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 mintOutput)\r\n    {\r\n        uint256 len = _inputQuantities.length;\r\n        require(len > 0 && len == _inputs.length, \"Input array mismatch\");\r\n        (uint8[] memory indexes, ) = _getBassets(_inputs);\r\n        return forgeValidator.computeMintMulti(bAssetData, indexes, _inputQuantities, _getConfig());\r\n    }\r\n\r\n    /***************************************\r\n              MINTING (INTERNAL)\r\n    ****************************************/\r\n\r\n    /** @dev Mint Single */\r\n    function _mintTo(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minMassetQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 mAssetMinted) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n        BassetData[] memory allBassets = bAssetData;\r\n        (uint8 bAssetIndex, BassetPersonal memory personal) = _getAsset(_input);\r\n        Cache memory cache = _getCacheDetails();\r\n        // Transfer collateral to the platform integration address and call deposit\r\n        uint256 quantityDeposited =\r\n            Manager.depositTokens(\r\n                personal,\r\n                allBassets[bAssetIndex].ratio,\r\n                _inputQuantity,\r\n                cache.maxCache\r\n            );\r\n        // Validation should be after token transfer, as bAssetQty is unknown before\r\n        mAssetMinted = forgeValidator.computeMint(\r\n            allBassets,\r\n            bAssetIndex,\r\n            quantityDeposited,\r\n            _getConfig()\r\n        );\r\n        require(mAssetMinted >= _minMassetQuantity, \"Mint quantity < min qty\");\r\n        // Log the Vault increase - can only be done when basket is healthy\r\n        bAssetData[bAssetIndex].vaultBalance =\r\n            allBassets[bAssetIndex].vaultBalance +\r\n            SafeCast.toUint128(quantityDeposited);\r\n        // Mint the Masset\r\n        _mint(_recipient, mAssetMinted);\r\n        emit Minted(msg.sender, _recipient, mAssetMinted, _input, quantityDeposited);\r\n    }\r\n\r\n    /** @dev Mint Multi */\r\n    function _mintMulti(\r\n        address[] memory _inputs,\r\n        uint256[] memory _inputQuantities,\r\n        uint256 _minMassetQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 mAssetMinted) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        uint256 len = _inputQuantities.length;\r\n        require(len > 0 && len == _inputs.length, \"Input array mismatch\");\r\n        // Load bAssets from storage into memory\r\n        (uint8[] memory indexes, BassetPersonal[] memory personals) = _getBassets(_inputs);\r\n        BassetData[] memory allBassets = bAssetData;\r\n        Cache memory cache = _getCacheDetails();\r\n        uint256[] memory quantitiesDeposited = new uint256[](len);\r\n        // Transfer the Bassets to the integrator, update storage and calc MassetQ\r\n        for (uint256 i = 0; i < len; i++) {\r\n            uint256 bAssetQuantity = _inputQuantities[i];\r\n            if (bAssetQuantity > 0) {\r\n                uint8 idx = indexes[i];\r\n                BassetData memory data = allBassets[idx];\r\n                BassetPersonal memory personal = personals[i];\r\n                uint256 quantityDeposited =\r\n                    Manager.depositTokens(personal, data.ratio, bAssetQuantity, cache.maxCache);\r\n                quantitiesDeposited[i] = quantityDeposited;\r\n                bAssetData[idx].vaultBalance =\r\n                    data.vaultBalance +\r\n                    SafeCast.toUint128(quantityDeposited);\r\n            }\r\n        }\r\n        // Validate the proposed mint, after token transfer\r\n        mAssetMinted = forgeValidator.computeMintMulti(\r\n            allBassets,\r\n            indexes,\r\n            quantitiesDeposited,\r\n            _getConfig()\r\n        );\r\n        require(mAssetMinted >= _minMassetQuantity, \"Mint quantity < min qty\");\r\n        require(mAssetMinted > 0, \"Zero mAsset quantity\");\r\n\r\n        // Mint the Masset\r\n        _mint(_recipient, mAssetMinted);\r\n        emit MintedMulti(msg.sender, _recipient, mAssetMinted, _inputs, _inputQuantities);\r\n    }\r\n\r\n    /***************************************\r\n                SWAP (PUBLIC)\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Swaps one bAsset for another bAsset using the bAsset addresses.\r\n     * bAsset <> bAsset swaps will incur a small fee (swapFee()).\r\n     * @param _input             Address of bAsset to deposit\r\n     * @param _output            Address of bAsset to receive\r\n     * @param _inputQuantity     Units of input bAsset to swap\r\n     * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\r\n     * @param _recipient         Address to transfer output asset to\r\n     * @return swapOutput        Quantity of output asset returned from swap\r\n     */\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenHealthy returns (uint256 swapOutput) {\r\n        swapOutput = _swap(_input, _output, _inputQuantity, _minOutputQuantity, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines both if a trade is valid, and the expected fee or output.\r\n     * Swap is valid if it does not result in the input asset exceeding its maximum weight.\r\n     * @param _input             Address of bAsset to deposit\r\n     * @param _output            Address of bAsset to receive\r\n     * @param _inputQuantity     Units of input bAsset to swap\r\n     * @return swapOutput        Quantity of output asset returned from swap\r\n     */\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view override returns (uint256 swapOutput) {\r\n        require(_input != _output, \"Invalid pair\");\r\n        require(_inputQuantity > 0, \"Invalid swap quantity\");\r\n\r\n        // 1. Load the bAssets from storage into memory\r\n        BassetData[] memory allBassets = bAssetData;\r\n        (uint8 inputIdx, ) = _getAsset(_input);\r\n        (uint8 outputIdx, ) = _getAsset(_output);\r\n\r\n        // 2. If a bAsset swap, calculate the validity, output and fee\r\n        (swapOutput, ) = forgeValidator.computeSwap(\r\n            allBassets,\r\n            inputIdx,\r\n            outputIdx,\r\n            _inputQuantity,\r\n            swapFee,\r\n            _getConfig()\r\n        );\r\n    }\r\n\r\n    /***************************************\r\n              SWAP (INTERNAL)\r\n    ****************************************/\r\n\r\n    /** @dev Swap single */\r\n    function _swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 swapOutput) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_input != _output, \"Invalid pair\");\r\n        require(_inputQuantity > 0, \"Invalid swap quantity\");\r\n\r\n        // 1. Load the bAssets from storage into memory\r\n        BassetData[] memory allBassets = bAssetData;\r\n        (uint8 inputIdx, BassetPersonal memory inputPersonal) = _getAsset(_input);\r\n        (uint8 outputIdx, BassetPersonal memory outputPersonal) = _getAsset(_output);\r\n        // 2. Load cache\r\n        Cache memory cache = _getCacheDetails();\r\n        // 3. Deposit the input tokens\r\n        uint256 quantityDeposited =\r\n            Manager.depositTokens(\r\n                inputPersonal,\r\n                allBassets[inputIdx].ratio,\r\n                _inputQuantity,\r\n                cache.maxCache\r\n            );\r\n        // 3.1. Update the input balance\r\n        bAssetData[inputIdx].vaultBalance =\r\n            allBassets[inputIdx].vaultBalance +\r\n            SafeCast.toUint128(quantityDeposited);\r\n\r\n        // 3. Validate the swap\r\n        uint256 scaledFee;\r\n        (swapOutput, scaledFee) = forgeValidator.computeSwap(\r\n            allBassets,\r\n            inputIdx,\r\n            outputIdx,\r\n            quantityDeposited,\r\n            swapFee,\r\n            _getConfig()\r\n        );\r\n        require(swapOutput >= _minOutputQuantity, \"Output qty < minimum qty\");\r\n        require(swapOutput > 0, \"Zero output quantity\");\r\n        //4. Settle the swap\r\n        //4.1. Decrease output bal\r\n        Manager.withdrawTokens(\r\n            swapOutput,\r\n            outputPersonal,\r\n            allBassets[outputIdx],\r\n            _recipient,\r\n            cache.maxCache\r\n        );\r\n        bAssetData[outputIdx].vaultBalance =\r\n            allBassets[outputIdx].vaultBalance -\r\n            SafeCast.toUint128(swapOutput);\r\n        // Save new surplus to storage\r\n        surplus = cache.surplus + scaledFee;\r\n        emit Swapped(\r\n            msg.sender,\r\n            inputPersonal.addr,\r\n            outputPersonal.addr,\r\n            swapOutput,\r\n            scaledFee,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    /***************************************\r\n                REDEMPTION (PUBLIC)\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Redeems a specified quantity of mAsset in return for a bAsset specified by bAsset address.\r\n     * The bAsset is sent to the specified recipient.\r\n     * The bAsset quantity is relative to current vault balance levels and desired mAsset quantity.\r\n     * The quantity of mAsset is burnt as payment.\r\n     * A minimum quantity of bAsset is specified to protect against price slippage between the mAsset and bAsset.\r\n     * @param _output            Address of the bAsset to receive\r\n     * @param _mAssetQuantity    Quantity of mAsset to redeem\r\n     * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt mAssets. This protects against slippage.\r\n     * @param _recipient         Address to transfer the withdrawn bAssets to.\r\n     * @return outputQuantity    Quanity of bAsset units received for the burnt mAssets\r\n     */\r\n    function redeem(\r\n        address _output,\r\n        uint256 _mAssetQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenNoRecol returns (uint256 outputQuantity) {\r\n        outputQuantity = _redeem(_output, _mAssetQuantity, _minOutputQuantity, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\r\n     * balance levels and desired mAsset quantity. Burns the mAsset as payment.\r\n     * @param _mAssetQuantity       Quantity of mAsset to redeem\r\n     * @param _minOutputQuantities  Min units of output to receive\r\n     * @param _recipient            Address to credit the withdrawn bAssets\r\n     */\r\n    function redeemMasset(\r\n        uint256 _mAssetQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external override nonReentrant whenNoRecol returns (uint256[] memory outputQuantities) {\r\n        outputQuantities = _redeemMasset(_mAssetQuantity, _minOutputQuantities, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\r\n     *      relative Masset quantity from the sender. Sender also incurs a small fee on the outgoing asset.\r\n     * @param _outputs           Addresses of the bAssets to receive\r\n     * @param _outputQuantities  Units of the bAssets to redeem\r\n     * @param _maxMassetQuantity Maximum mAsset quantity to burn for the received bAssets. This protects against slippage.\r\n     * @param _recipient         Address to receive the withdrawn bAssets\r\n     * @return mAssetQuantity    Quantity of mAsset units burned plus the swap fee to pay for the redeemed bAssets\r\n     */\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) external override nonReentrant whenNoRecol returns (uint256 mAssetQuantity) {\r\n        mAssetQuantity = _redeemExactBassets(\r\n            _outputs,\r\n            _outputQuantities,\r\n            _maxMassetQuantity,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the estimated output from a given redeem\r\n     * @param _output            Address of the bAsset to receive\r\n     * @param _mAssetQuantity    Quantity of mAsset to redeem\r\n     * @return bAssetOutput      Estimated quantity of bAsset units received for the burnt mAssets\r\n     */\r\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 bAssetOutput)\r\n    {\r\n        require(_mAssetQuantity > 0, \"Qty==0\");\r\n\r\n        (uint8 idx, ) = _getAsset(_output);\r\n\r\n        uint256 scaledFee = _mAssetQuantity.mulTruncate(swapFee);\r\n        bAssetOutput = forgeValidator.computeRedeem(\r\n            bAssetData,\r\n            idx,\r\n            _mAssetQuantity - scaledFee,\r\n            _getConfig()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the estimated output from a given redeem\r\n     * @param _outputs           Addresses of the bAsset to receive\r\n     * @param _outputQuantities  Quantities of bAsset to redeem\r\n     * @return mAssetQuantity    Estimated quantity of mAsset units needed to burn to receive output\r\n     */\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view override returns (uint256 mAssetQuantity) {\r\n        uint256 len = _outputQuantities.length;\r\n        require(len > 0 && len == _outputs.length, \"Invalid array input\");\r\n\r\n        (uint8[] memory indexes, ) = _getBassets(_outputs);\r\n\r\n        // calculate the value of mAssets need to cover the value of bAssets being redeemed\r\n        uint256 mAssetRedeemed =\r\n            forgeValidator.computeRedeemExact(bAssetData, indexes, _outputQuantities, _getConfig());\r\n        mAssetQuantity = mAssetRedeemed.divPrecisely(1e18 - swapFee) + 1;\r\n    }\r\n\r\n    /***************************************\r\n                REDEMPTION (INTERNAL)\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Redeem mAsset for a single bAsset\r\n     */\r\n    function _redeem(\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 bAssetQuantity) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        // Load the bAsset data from storage into memory\r\n        BassetData[] memory allBassets = bAssetData;\r\n        (uint8 bAssetIndex, BassetPersonal memory personal) = _getAsset(_output);\r\n        // Calculate redemption quantities\r\n        uint256 scaledFee = _inputQuantity.mulTruncate(swapFee);\r\n        bAssetQuantity = forgeValidator.computeRedeem(\r\n            allBassets,\r\n            bAssetIndex,\r\n            _inputQuantity - scaledFee,\r\n            _getConfig()\r\n        );\r\n        require(bAssetQuantity >= _minOutputQuantity, \"bAsset qty < min qty\");\r\n        require(bAssetQuantity > 0, \"Output == 0\");\r\n        // Apply fees, burn mAsset and return bAsset to recipient\r\n        // 1.0. Burn the full amount of Masset\r\n        _burn(msg.sender, _inputQuantity);\r\n        surplus += scaledFee;\r\n        Cache memory cache = _getCacheDetails();\r\n        // 2.0. Transfer the Bassets to the recipient\r\n        Manager.withdrawTokens(\r\n            bAssetQuantity,\r\n            personal,\r\n            allBassets[bAssetIndex],\r\n            _recipient,\r\n            cache.maxCache\r\n        );\r\n        // 3.0. Set vault balance\r\n        bAssetData[bAssetIndex].vaultBalance =\r\n            allBassets[bAssetIndex].vaultBalance -\r\n            SafeCast.toUint128(bAssetQuantity);\r\n\r\n        emit Redeemed(\r\n            msg.sender,\r\n            _recipient,\r\n            _inputQuantity,\r\n            personal.addr,\r\n            bAssetQuantity,\r\n            scaledFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem mAsset for proportional amount of bAssets\r\n     */\r\n    function _redeemMasset(\r\n        uint256 _inputQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) internal returns (uint256[] memory outputQuantities) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        require(_inputQuantity > 0, \"Qty==0\");\r\n\r\n        // Calculate mAsset redemption quantities\r\n        uint256 scaledFee = _inputQuantity.mulTruncate(redemptionFee);\r\n        uint256 mAssetRedemptionAmount = _inputQuantity - scaledFee;\r\n\r\n        // Burn mAsset quantity\r\n        _burn(msg.sender, _inputQuantity);\r\n        surplus += scaledFee;\r\n\r\n        // Calc cache and total mAsset circulating\r\n        Cache memory cache = _getCacheDetails();\r\n        // Total mAsset = (totalSupply + _inputQuantity - scaledFee) + surplus\r\n        uint256 totalMasset = cache.vaultBalanceSum + mAssetRedemptionAmount;\r\n\r\n        // Load the bAsset data from storage into memory\r\n        BassetData[] memory allBassets = bAssetData;\r\n\r\n        uint256 len = allBassets.length;\r\n        address[] memory outputs = new address[](len);\r\n        outputQuantities = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // Get amount out, proportionate to redemption quantity\r\n            // Use `cache.sum` here as the total mAsset supply is actually totalSupply + surplus\r\n            uint256 amountOut = (allBassets[i].vaultBalance * mAssetRedemptionAmount) / totalMasset;\r\n            require(amountOut > 1, \"Output == 0\");\r\n            amountOut -= 1;\r\n            require(amountOut >= _minOutputQuantities[i], \"bAsset qty < min qty\");\r\n            // Set output in array\r\n            (outputQuantities[i], outputs[i]) = (amountOut, bAssetPersonal[i].addr);\r\n            // Transfer the bAsset to the recipient\r\n            Manager.withdrawTokens(\r\n                amountOut,\r\n                bAssetPersonal[i],\r\n                allBassets[i],\r\n                _recipient,\r\n                cache.maxCache\r\n            );\r\n            // reduce vaultBalance\r\n            bAssetData[i].vaultBalance = allBassets[i].vaultBalance - SafeCast.toUint128(amountOut);\r\n        }\r\n\r\n        emit RedeemedMulti(\r\n            msg.sender,\r\n            _recipient,\r\n            _inputQuantity,\r\n            outputs,\r\n            outputQuantities,\r\n            scaledFee\r\n        );\r\n    }\r\n\r\n    /** @dev Redeem mAsset for one or more bAssets */\r\n    function _redeemExactBassets(\r\n        address[] memory _outputs,\r\n        uint256[] memory _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 mAssetQuantity) {\r\n        require(_recipient != address(0), \"Invalid recipient\");\r\n        uint256 len = _outputQuantities.length;\r\n        require(len > 0 && len == _outputs.length, \"Invalid array input\");\r\n        require(_maxMassetQuantity > 0, \"Qty==0\");\r\n\r\n        (uint8[] memory indexes, BassetPersonal[] memory personal) = _getBassets(_outputs);\r\n        // Load bAsset data from storage to memory\r\n        BassetData[] memory allBassets = bAssetData;\r\n        // Validate redemption\r\n        uint256 mAssetRequired =\r\n            forgeValidator.computeRedeemExact(allBassets, indexes, _outputQuantities, _getConfig());\r\n        mAssetQuantity = mAssetRequired.divPrecisely(1e18 - swapFee);\r\n        uint256 fee = mAssetQuantity - mAssetRequired;\r\n        require(mAssetQuantity > 0, \"Must redeem some mAssets\");\r\n        mAssetQuantity += 1;\r\n        require(mAssetQuantity <= _maxMassetQuantity, \"Redeem mAsset qty > max quantity\");\r\n        // Apply fees, burn mAsset and return bAsset to recipient\r\n        // 1.0. Burn the full amount of Masset\r\n        _burn(msg.sender, mAssetQuantity);\r\n        surplus += fee;\r\n        Cache memory cache = _getCacheDetails();\r\n        // 2.0. Transfer the Bassets to the recipient and count fees\r\n        for (uint256 i = 0; i < len; i++) {\r\n            uint8 idx = indexes[i];\r\n            Manager.withdrawTokens(\r\n                _outputQuantities[i],\r\n                personal[i],\r\n                allBassets[idx],\r\n                _recipient,\r\n                cache.maxCache\r\n            );\r\n            bAssetData[idx].vaultBalance =\r\n                allBassets[idx].vaultBalance -\r\n                SafeCast.toUint128(_outputQuantities[i]);\r\n        }\r\n        emit RedeemedMulti(\r\n            msg.sender,\r\n            _recipient,\r\n            mAssetQuantity,\r\n            _outputs,\r\n            _outputQuantities,\r\n            fee\r\n        );\r\n    }\r\n\r\n    /***************************************\r\n                    GETTERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Get basket details for `Masset_MassetStructs.Basket`\r\n     * @return b   Basket struct\r\n     */\r\n    function getBasket() external view override returns (bool, bool) {\r\n        return (basket.undergoingRecol, basket.failed);\r\n    }\r\n\r\n    /**\r\n     * @dev Get data for a all bAssets in basket\r\n     * @return personal  Struct[] with full bAsset data\r\n     * @return data      Number of bAssets in the Basket\r\n     */\r\n    function getBassets()\r\n        external\r\n        view\r\n        override\r\n        returns (BassetPersonal[] memory personal, BassetData[] memory data)\r\n    {\r\n        return (bAssetPersonal, bAssetData);\r\n    }\r\n\r\n    /**\r\n     * @dev Get data for a specific bAsset, if it exists\r\n     * @param _bAsset   Address of bAsset\r\n     * @return personal  Struct with full bAsset data\r\n     * @return data  Struct with full bAsset data\r\n     */\r\n    function getBasset(address _bAsset)\r\n        external\r\n        view\r\n        override\r\n        returns (BassetPersonal memory personal, BassetData memory data)\r\n    {\r\n        uint8 idx = bAssetIndexes[_bAsset];\r\n        personal = bAssetPersonal[idx];\r\n        require(personal.addr == _bAsset, \"Invalid asset\");\r\n        data = bAssetData[idx];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all config needed for general InvariantValidator calls\r\n     */\r\n    function getConfig() external view returns (InvariantConfig memory config) {\r\n        return _getConfig();\r\n    }\r\n\r\n    /***************************************\r\n                GETTERS - INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * vaultBalanceSum = totalSupply + 'surplus'\r\n     * maxCache = vaultBalanceSum * (cacheSize / 1e18)\r\n     * surplus is simply surplus, to reduce SLOADs\r\n     */\r\n    struct Cache {\r\n        uint256 vaultBalanceSum;\r\n        uint256 maxCache;\r\n        uint256 surplus;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the supply and cache details for the mAsset, taking into account the surplus\r\n     * @return Cache containing (tracked) sum of vault balances, ideal cache size and surplus\r\n     */\r\n    function _getCacheDetails() internal view returns (Cache memory) {\r\n        // read surplus from storage into memory\r\n        uint256 _surplus = surplus;\r\n        uint256 sum = totalSupply() + _surplus;\r\n        return Cache(sum, sum.mulTruncate(cacheSize), _surplus);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets a bAsset from storage\r\n     * @param _asset        Address of the asset\r\n     * @return idx        Index of the asset\r\n     * @return personal   Personal details for the asset\r\n     */\r\n    function _getAsset(address _asset)\r\n        internal\r\n        view\r\n        returns (uint8 idx, BassetPersonal memory personal)\r\n    {\r\n        idx = bAssetIndexes[_asset];\r\n        personal = bAssetPersonal[idx];\r\n        require(personal.addr == _asset, \"Invalid asset\");\r\n    }\r\n\r\n    /**\r\n     * @dev Gets a an array of bAssets from storage and protects against duplicates\r\n     * @param _bAssets    Addresses of the assets\r\n     * @return indexes    Indexes of the assets\r\n     * @return personal   Personal details for the assets\r\n     */\r\n    function _getBassets(address[] memory _bAssets)\r\n        internal\r\n        view\r\n        returns (uint8[] memory indexes, BassetPersonal[] memory personal)\r\n    {\r\n        uint256 len = _bAssets.length;\r\n\r\n        indexes = new uint8[](len);\r\n        personal = new BassetPersonal[](len);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            (indexes[i], personal[i]) = _getAsset(_bAssets[i]);\r\n\r\n            for (uint256 j = i + 1; j < len; j++) {\r\n                require(_bAssets[i] != _bAssets[j], \"Duplicate asset\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all config needed for general InvariantValidator calls\r\n     */\r\n    function _getConfig() internal view returns (InvariantConfig memory) {\r\n        return InvariantConfig(_getA(), weightLimits);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets current amplification var A\r\n     */\r\n    function _getA() internal view returns (uint256) {\r\n        AmpData memory ampData_ = ampData;\r\n\r\n        uint64 endA = ampData_.targetA;\r\n        uint64 endTime = ampData_.rampEndTime;\r\n\r\n        // If still changing, work out based on current timestmap\r\n        if (block.timestamp < endTime) {\r\n            uint64 startA = ampData_.initialA;\r\n            uint64 startTime = ampData_.rampStartTime;\r\n\r\n            (uint256 elapsed, uint256 total) = (block.timestamp - startTime, endTime - startTime);\r\n\r\n            if (endA > startA) {\r\n                return startA + (((endA - startA) * elapsed) / total);\r\n            } else {\r\n                return startA - (((startA - endA) * elapsed) / total);\r\n            }\r\n        }\r\n        // Else return final value\r\n        else {\r\n            return endA;\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    YIELD\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Converts recently accrued swap and redeem fees into mAsset\r\n     * @return mintAmount   mAsset units generated from swap and redeem fees\r\n     * @return newSupply    mAsset total supply after mint\r\n     */\r\n    function collectInterest()\r\n        external\r\n        override\r\n        onlySavingsManager\r\n        returns (uint256 mintAmount, uint256 newSupply)\r\n    {\r\n        // Set the surplus variable to 1 to optimise for SSTORE costs.\r\n        // If setting to 0 here, it would save 5k per savings deposit, but cost 20k for the\r\n        // first surplus call (a SWAP or REDEEM).\r\n        uint256 surplusFees = surplus;\r\n        if (surplusFees > 1) {\r\n            mintAmount = surplusFees - 1;\r\n            surplus = 1;\r\n\r\n            // mint new mAsset to savings manager\r\n            _mint(msg.sender, mintAmount);\r\n            emit MintedMulti(\r\n                address(this),\r\n                msg.sender,\r\n                mintAmount,\r\n                new address[](0),\r\n                new uint256[](0)\r\n            );\r\n        }\r\n        newSupply = totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Collects the interest generated from the Basket, minting a relative\r\n     *      amount of mAsset and sends it over to the SavingsManager.\r\n     * @return mintAmount   mAsset units generated from interest collected from lending markets\r\n     * @return newSupply    mAsset total supply after mint\r\n     */\r\n    function collectPlatformInterest()\r\n        external\r\n        override\r\n        onlySavingsManager\r\n        whenHealthy\r\n        nonReentrant\r\n        returns (uint256 mintAmount, uint256 newSupply)\r\n    {\r\n        uint256[] memory gains;\r\n        (mintAmount, gains) = Manager.collectPlatformInterest(\r\n            bAssetPersonal,\r\n            bAssetData,\r\n            forgeValidator,\r\n            _getConfig()\r\n        );\r\n\r\n        require(mintAmount > 0, \"Must collect something\");\r\n\r\n        _mint(msg.sender, mintAmount);\r\n        emit MintedMulti(address(this), msg.sender, mintAmount, new address[](0), gains);\r\n\r\n        newSupply = totalSupply();\r\n    }\r\n\r\n    /***************************************\r\n                    STATE\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Sets the MAX cache size for each bAsset. The cache will actually revolve around\r\n     *      _cacheSize * totalSupply / 2 under normal circumstances.\r\n     * @param _cacheSize Maximum percent of total mAsset supply to hold for each bAsset\r\n     */\r\n    function setCacheSize(uint256 _cacheSize) external override onlyGovernor {\r\n        require(_cacheSize <= 2e17, \"Must be <= 20%\");\r\n\r\n        cacheSize = _cacheSize;\r\n\r\n        emit CacheSizeChanged(_cacheSize);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the version of ForgeValidator protocol. Governor can do this\r\n     *      only while ForgeValidator is unlocked.\r\n     * @param _newForgeValidator Address of the new ForgeValidator\r\n     */\r\n    function upgradeForgeValidator(address _newForgeValidator) external override onlyGovernor {\r\n        require(!forgeValidatorLocked, \"ForgeVal locked\");\r\n        require(_newForgeValidator != address(0), \"Null address\");\r\n\r\n        forgeValidator = IInvariantValidator(_newForgeValidator);\r\n\r\n        emit ForgeValidatorChanged(_newForgeValidator);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the ecosystem fee for sewapping bAssets or redeeming specific bAssets\r\n     * @param _swapFee Fee calculated in (%/100 * 1e18)\r\n     */\r\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external override onlyGovernor {\r\n        require(_swapFee <= MAX_FEE, \"Swap rate oob\");\r\n        require(_redemptionFee <= MAX_FEE, \"Redemption rate oob\");\r\n\r\n        swapFee = _swapFee;\r\n        redemptionFee = _redemptionFee;\r\n\r\n        emit FeesChanged(_swapFee, _redemptionFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the maximum weight for a given bAsset\r\n     * @param _min Weight where 100% = 1e18\r\n     * @param _max Weight where 100% = 1e18\r\n     */\r\n    function setWeightLimits(uint128 _min, uint128 _max) external onlyGovernor {\r\n        require(_min <= 1e18 / (bAssetData.length * 2), \"Min weight oob\");\r\n        require(_max >= 1e18 / (bAssetData.length - 1), \"Max weight oob\");\r\n\r\n        weightLimits = WeightLimits(_min, _max);\r\n\r\n        emit WeightLimitsChanged(_min, _max);\r\n    }\r\n\r\n    /**\r\n     * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\r\n     * @param _bAsset   bAsset address\r\n     * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\r\n     */\r\n    function setTransferFeesFlag(address _bAsset, bool _flag) external override onlyGovernor {\r\n        Manager.setTransferFeesFlag(bAssetPersonal, bAssetIndexes, _bAsset, _flag);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all collateral from one lending market to another - used initially\r\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\r\n     *      tx fee enabled assets. Supports going from no integration to integration, but\r\n     *      not the other way around.\r\n     * @param _bAssets Array of basket assets to migrate\r\n     * @param _newIntegration Address of the new platform integration\r\n     */\r\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration)\r\n        external\r\n        override\r\n        onlyGovernor\r\n    {\r\n        Manager.migrateBassets(bAssetPersonal, bAssetIndexes, _bAssets, _newIntegration);\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\r\n     * @param _bAsset          Address of the ERC20 token to isolate\r\n     * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\r\n     *                         or above (f)\r\n     */\r\n    function handlePegLoss(address _bAsset, bool _belowPeg) external onlyGovernor {\r\n        Manager.handlePegLoss(basket, bAssetPersonal, bAssetIndexes, _bAsset, _belowPeg);\r\n    }\r\n\r\n    /**\r\n     * @dev Negates the isolation of a given bAsset\r\n     * @param _bAsset Address of the bAsset\r\n     */\r\n    function negateIsolation(address _bAsset) external onlyGovernor {\r\n        Manager.negateIsolation(basket, bAssetPersonal, bAssetIndexes, _bAsset);\r\n    }\r\n\r\n    /**\r\n     * @dev Starts changing of the amplification var A\r\n     * @param _targetA      Target A value\r\n     * @param _rampEndTime  Time at which A will arrive at _targetA\r\n     */\r\n    function startRampA(uint256 _targetA, uint256 _rampEndTime) external onlyGovernor {\r\n        Manager.startRampA(ampData, _targetA, _rampEndTime, _getA(), A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the changing of the amplification var A, setting\r\n     * it to whatever the current value is.\r\n     */\r\n    function stopRampA() external onlyGovernor {\r\n        Manager.stopRampA(ampData, _getA());\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nexus\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cacheSize\",\"type\":\"uint256\"}],\"name\":\"CacheSizeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"}],\"name\":\"FeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"forgeValidator\",\"type\":\"address\"}],\"name\":\"ForgeValidatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputQuantity\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"inputs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"inputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"MintedMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"outputs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"outputQuantity\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"}],\"name\":\"RedeemedMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"name\":\"WeightLimitsChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ampData\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"initialA\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetA\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rampStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rampEndTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bAssetData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bAssetIndexes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bAssetPersonal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"undergoingRecol\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"failed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cacheSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectPlatformInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forgeValidator\",\"outputs\":[{\"internalType\":\"contract IInvariantValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBasket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bAsset\",\"type\":\"address\"}],\"name\":\"getBasset\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MassetStructs.BassetPersonal\",\"name\":\"personal\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBassets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MassetStructs.BassetPersonal[]\",\"name\":\"personal\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.BassetData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"getMintMultiOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"}],\"name\":\"getMintOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_outputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"getRedeemExactBassetsOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mAssetQuantity\",\"type\":\"uint256\"}],\"name\":\"getRedeemOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bAssetOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"}],\"name\":\"getSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_belowPeg\",\"type\":\"bool\"}],\"name\":\"handlePegLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nameArg\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbolArg\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_forgeValidator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MassetStructs.BassetPersonal[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct MassetStructs.WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct MassetStructs.InvariantConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBassets\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bAssets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_newIntegration\",\"type\":\"address\"}],\"name\":\"migrateBassets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mintMulti\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bAsset\",\"type\":\"address\"}],\"name\":\"negateIsolation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mAssetQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_outputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxMassetQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemExactBassets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mAssetQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_minOutputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemMasset\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"outputQuantities\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cacheSize\",\"type\":\"uint256\"}],\"name\":\"setCacheSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_redemptionFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setTransferFeesFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_max\",\"type\":\"uint128\"}],\"name\":\"setWeightLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rampEndTime\",\"type\":\"uint256\"}],\"name\":\"startRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surplus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newForgeValidator\",\"type\":\"address\"}],\"name\":\"upgradeForgeValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weightLimits\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Masset","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000afce80b19a8ce13dec0739a1aab7a028d6845eb3","EVMVersion":"Default","Library":"Manager:1e91f826fa8aa4fa4d3f595898af3a64dd188848","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dae72f5ff69570886e954e80393ebc0b72fed276185edb02ee12829454e8422a"}]}