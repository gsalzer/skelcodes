{"status":"1","message":"OK","result":[{"SourceCode":"/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\npragma solidity 0.5.15;\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\n\r\n/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\ninterface IShardGovernor {\r\n\tfunction claimInitialShotgun(\r\n\t\taddress payable initialClaimantAddress,\r\n\t\tuint initialClaimantBalance\r\n\t) external payable returns (bool);\r\n\r\n\tfunction transferShards(\r\n\t\taddress recipient,\r\n\t\tuint amount\r\n\t) external;\r\n\r\n\tfunction enactShotgun() external;\r\n\tfunction offererAddress() external view returns (address);\r\n\tfunction checkLock() external view returns (bool);\r\n\tfunction checkShotgunState() external view returns (bool);\r\n\tfunction getNftRegistryAddress() external view returns (address);\r\n\tfunction getNftTokenIds() external view returns (uint256[] memory);\r\n\tfunction getOwner() external view returns (address);\r\n}\r\n/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\n\r\n\r\ninterface IShardRegistry {\r\n\tfunction mint(address, uint256) external returns (bool);\r\n\tfunction pause() external;\r\n\tfunction unpause() external;\r\n\tfunction burn(uint256) external;\r\n\tfunction transfer(address, uint256) external returns (bool);\r\n\tfunction cap() external view returns (uint256);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction totalSupply() external view returns (uint256);\r\n}\r\n\r\n/**\r\n\t* @title Contract managing Shotgun Clause lifecycle\r\n\t* @author Joel Hubert (Metalith.io)\r\n\t* @dev OpenZeppelin contracts are not ready for 0.6.0 yet, using 0.5.16.\r\n\t* @dev This contract is deployed once a Shotgun is initiated by calling the Registry.\r\n\t*/\r\n\r\ncontract ShotgunClause {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tIShardGovernor private _shardGovernor;\r\n\tIShardRegistry private _shardRegistry;\r\n\r\n\tenum ClaimWinner { None, Claimant, Counterclaimant }\r\n\tClaimWinner private _claimWinner = ClaimWinner.None;\r\n\r\n\tuint private _deadlineTimestamp;\r\n\tuint private _initialOfferInWei;\r\n\tuint private _pricePerShardInWei;\r\n\taddress payable private _initialClaimantAddress;\r\n\tuint private _initialClaimantBalance;\r\n\tbool private _shotgunEnacted = false;\r\n\tuint private _counterWeiContributed;\r\n\taddress[] private _counterclaimants;\r\n\tmapping(address => uint) private _counterclaimContribs;\r\n\r\n\tevent Countercommit(address indexed committer, uint indexed weiAmount);\r\n\tevent EtherCollected(address indexed collector, uint indexed weiAmount);\r\n\r\n\tconstructor(\r\n\t\taddress payable initialClaimantAddress,\r\n\t\tuint initialClaimantBalance,\r\n\t\taddress shardRegistryAddress\r\n\t) public payable {\r\n\t\t_shardGovernor = IShardGovernor(msg.sender);\r\n\t\t_shardRegistry = IShardRegistry(shardRegistryAddress);\r\n\t\t_deadlineTimestamp = now.add(1 * 14 days);\r\n\t\t_initialClaimantAddress = initialClaimantAddress;\r\n\t\t_initialClaimantBalance = initialClaimantBalance;\r\n\t\t_initialOfferInWei = msg.value;\r\n\t\t_pricePerShardInWei = (_initialOfferInWei.mul(10**18)).div(_shardRegistry.cap().sub(_initialClaimantBalance));\r\n\t\t_claimWinner = ClaimWinner.Claimant;\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Contribute Ether to the counterclaim for this Shotgun.\r\n\t\t* @dev Automatically enacts Shotgun once enough Ether is raised and\r\n\t\treturns initial claimant's Ether offer.\r\n\t\t*/\r\n\tfunction counterCommitEther() external payable {\r\n\t\trequire(\r\n\t\t\t_shardRegistry.balanceOf(msg.sender) > 0,\r\n\t\t\t\"[counterCommitEther] Account does not own Shards\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\tmsg.value > 0,\r\n\t\t\t\"[counterCommitEther] Ether is required\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t_initialClaimantAddress != address(0),\r\n\t\t\t\"[counterCommitEther] Initial claimant does not exist\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\tmsg.sender != _initialClaimantAddress,\r\n\t\t\t\"[counterCommitEther] Initial claimant cannot countercommit\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t!_shotgunEnacted,\r\n\t\t\t\"[counterCommitEther] Shotgun already enacted\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\tnow < _deadlineTimestamp,\r\n\t\t\t\"[counterCommitEther] Deadline has expired\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\tmsg.value + _counterWeiContributed <= getRequiredWeiForCounterclaim(),\r\n\t\t\t\"[counterCommitEther] Ether exceeds goal\"\r\n\t\t);\r\n\t\tif (_counterclaimContribs[msg.sender] == 0) {\r\n\t\t\t_counterclaimants.push(msg.sender);\r\n\t\t}\r\n\t\t_counterclaimContribs[msg.sender] = _counterclaimContribs[msg.sender].add(msg.value);\r\n\t\t_counterWeiContributed = _counterWeiContributed.add(msg.value);\r\n\t\temit Countercommit(msg.sender, msg.value);\r\n\t\tif (_counterWeiContributed == getRequiredWeiForCounterclaim()) {\r\n\t\t\t_claimWinner = ClaimWinner.Counterclaimant;\r\n\t\t\tenactShotgun();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Collect ether from completed Shotgun.\r\n\t\t* @dev Called by Shard Registry after burning caller's Shards.\r\n\t\t* @dev For counterclaimants, returns both the proportional worth of their\r\n\t\tShards in Ether AND any counterclaim contributions they have made.\r\n\t\t* @dev alternative: OpenZeppelin PaymentSplitter\r\n\t\t*/\r\n\tfunction collectEtherProceeds(uint balance, address payable caller) external {\r\n\t\trequire(\r\n\t\t\tmsg.sender == address(_shardRegistry),\r\n\t\t\t\"[collectEtherProceeds] Caller not authorized\"\r\n\t\t);\r\n\t\tif (_claimWinner == ClaimWinner.Claimant && caller != _initialClaimantAddress) {\r\n\t\t\tuint weiProceeds = (_pricePerShardInWei.mul(balance)).div(10**18);\r\n\t\t\tweiProceeds = weiProceeds.add(_counterclaimContribs[caller]);\r\n\t\t\t_counterclaimContribs[caller] = 0;\r\n\t\t\t(bool success, ) = address(caller).call.value(weiProceeds)(\"\");\r\n\t\t\trequire(success, \"[collectEtherProceeds] Transfer failed.\");\r\n\t\t\temit EtherCollected(caller, weiProceeds);\r\n\t\t} else if (_claimWinner == ClaimWinner.Counterclaimant && caller == _initialClaimantAddress) {\r\n\t\t\tuint amount = (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10**18);\r\n\t\t\tamount = amount.add(_initialOfferInWei);\r\n\t\t\t_initialClaimantBalance = 0;\r\n\t\t\t(bool success, ) = address(caller).call.value(amount)(\"\");\r\n\t\t\trequire(success, \"[collectEtherProceeds] Transfer failed.\");\r\n\t\t\temit EtherCollected(caller, amount);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Use by successful counterclaimants to collect Shards from initial claimant.\r\n\t\t*/\r\n\tfunction collectShardProceeds() external {\r\n\t\trequire(\r\n\t\t\t_shotgunEnacted && _claimWinner == ClaimWinner.Counterclaimant,\r\n\t\t\t\"[collectShardProceeds] Shotgun has not been enacted or invalid winner\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t_counterclaimContribs[msg.sender] != 0,\r\n\t\t\t\"[collectShardProceeds] Account has not participated in counterclaim\"\r\n\t\t);\r\n\t\tuint proportionContributed = (_counterclaimContribs[msg.sender].mul(10**18)).div(_counterWeiContributed);\r\n\t\t_counterclaimContribs[msg.sender] = 0;\r\n\t\tuint shardsToReceive = (proportionContributed.mul(_initialClaimantBalance)).div(10**18);\r\n\t\t_shardGovernor.transferShards(msg.sender, shardsToReceive);\r\n\t}\r\n\r\n\tfunction deadlineTimestamp() external view returns (uint256) {\r\n\t\treturn _deadlineTimestamp;\r\n\t}\r\n\r\n\tfunction shotgunEnacted() external view returns (bool) {\r\n\t\treturn _shotgunEnacted;\r\n\t}\r\n\r\n\tfunction initialClaimantAddress() external view returns (address) {\r\n\t\treturn _initialClaimantAddress;\r\n\t}\r\n\r\n\tfunction initialClaimantBalance() external view returns (uint) {\r\n\t\treturn _initialClaimantBalance;\r\n\t}\r\n\r\n\tfunction initialOfferInWei() external view returns (uint256) {\r\n\t\treturn _initialOfferInWei;\r\n\t}\r\n\r\n\tfunction pricePerShardInWei() external view returns (uint256) {\r\n\t\treturn _pricePerShardInWei;\r\n\t}\r\n\r\n\tfunction claimWinner() external view returns (ClaimWinner) {\r\n\t\treturn _claimWinner;\r\n\t}\r\n\r\n\tfunction counterclaimants() external view returns (address[] memory) {\r\n\t\treturn _counterclaimants;\r\n\t}\r\n\r\n\tfunction getCounterclaimantContribution(address counterclaimant) external view returns (uint) {\r\n\t\treturn _counterclaimContribs[counterclaimant];\r\n\t}\r\n\r\n\tfunction counterWeiContributed() external view returns (uint) {\r\n\t\treturn _counterWeiContributed;\r\n\t}\r\n\r\n\tfunction getContractBalance() external view returns (uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n\tfunction shardGovernor() external view returns (address) {\r\n\t\treturn address(_shardGovernor);\r\n\t}\r\n\r\n\tfunction getRequiredWeiForCounterclaim() public view returns (uint) {\r\n\t\treturn (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10**18);\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Initiate Shotgun enactment.\r\n\t\t* @dev Automatically called if enough Ether is raised by counterclaimants,\r\n\t\tor manually called if deadline expires without successful counterclaim.\r\n\t\t*/\r\n\tfunction enactShotgun() public {\r\n\t\trequire(\r\n\t\t\t!_shotgunEnacted,\r\n\t\t\t\"[enactShotgun] Shotgun already enacted\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t_claimWinner == ClaimWinner.Counterclaimant ||\r\n\t\t\t(_claimWinner == ClaimWinner.Claimant && now > _deadlineTimestamp),\r\n\t\t\t\"[enactShotgun] Conditions not met to enact Shotgun Clause\"\r\n\t\t);\r\n\t\t_shotgunEnacted = true;\r\n\t\t_shardGovernor.enactShotgun();\r\n\t}\r\n}\r\n/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\n\r\n\r\ninterface IShardOffering {\r\n\tfunction claimShards(address) external;\r\n\tfunction wrapUpOffering() external;\r\n\tfunction hasClaimedShards(address) external view returns (bool);\r\n\tfunction offeringCompleted() external view returns (bool);\r\n\tfunction offeringDeadline() external view returns (uint);\r\n\tfunction getSubEther(address) external view returns (uint);\r\n\tfunction getSubShards(address) external view returns (uint);\r\n\tfunction offererShardAmount() external view returns (uint);\r\n\tfunction totalShardsClaimed() external view returns (uint);\r\n\tfunction liqProviderCutInShards() external view returns (uint);\r\n\tfunction artistCutInShards() external view returns (uint);\r\n}\r\n/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\n\r\n\r\n\r\ninterface IFactory {\r\n\r\n\tfunction newSet(\r\n\t\tuint liqProviderCutInShards,\r\n\t\tuint artistCutInShards,\r\n\t\tuint pricePerShardInWei,\r\n\t\tuint shardAmountOffered,\r\n\t\tuint offeringDeadline,\r\n\t\tuint256 cap,\r\n\t\tstring calldata name,\r\n\t\tstring calldata symbol,\r\n\t\tbool shotgunDisabled\r\n\t) external returns (IShardRegistry, IShardOffering);\r\n}\r\n/* solhint-disable no-mix-tabs-and-spaces */\r\n/* solhint-disable indent */\r\n\r\n\r\ninterface IUniswapExchange {\r\n\tfunction removeLiquidity(\r\n\t\tuint256 uniTokenAmount,\r\n\t\tuint256 minEth,\r\n\t\tuint256 minTokens,\r\n\t\tuint256 deadline\r\n\t) external returns(\r\n\t\tuint256, uint256\r\n\t);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) external returns (bool);\r\n}\r\n\r\n/**\r\n\t* @title Contract managing Shard lifecycle (NFT custody + Shard issuance and redemption)\r\n\t* @author Joel Hubert (Metalith.io)\r\n\t* @dev OpenZeppelin contracts are not ready for 0.6.0 yet, using 0.5.15.\r\n\t* @dev This contract owns the Registry, Offering and any Shotgun contracts,\r\n\t* making it the gateway for core state changes.\r\n\t*/\r\n\r\ncontract ShardGovernor is IERC721Receiver {\r\n\r\n  using SafeMath for uint256;\r\n\r\n\t// Equals `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\tIShardRegistry private _shardRegistry;\r\n\tIShardOffering private _shardOffering;\r\n\tShotgunClause private _currentShotgunClause;\r\n\taddress payable private _offererAddress;\r\n\taddress[] private _nftRegistryAddresses;\r\n\taddress payable private _niftexWalletAddress;\r\n\taddress payable private _artistWalletAddress;\r\n\tuint256[] private _tokenIds;\r\n\r\n\tenum ClaimWinner { None, Claimant, Counterclaimant }\r\n\taddress[] private _shotgunAddressArray;\r\n\tmapping(address => uint) private _shotgunMapping;\r\n\tuint private _shotgunCounter;\r\n\r\n\tevent NewShotgun(address indexed shotgun);\r\n\tevent ShardsClaimed(address indexed claimant, uint indexed shardAmount);\r\n\tevent NftRedeemed(address indexed redeemer);\r\n\tevent ShotgunEnacted(address indexed enactor);\r\n\tevent ShardsCollected(address indexed collector, uint indexed shardAmount, address indexed shotgun);\r\n\r\n\t/**\r\n\t\t* @dev Checks whether offerer indeed owns the relevant NFT.\r\n\t\t* @dev Offering deadline starts ticking on deployment, but offerer needs to transfer\r\n\t\t* NFT to this contract before anyone can contribute.\r\n\t\t*/\r\n  constructor(\r\n  \taddress[] memory nftRegistryAddresses,\r\n  \taddress payable offererAddress,\r\n  \tuint256[] memory tokenIds,\r\n  \taddress payable niftexWalletAddress,\r\n  \taddress payable artistWalletAddress\r\n\t) public {\r\n\t\tfor (uint x = 0; x < tokenIds.length; x++) {\r\n\t\t\trequire(\r\n\t\t\t\tIERC721(nftRegistryAddresses[x]).ownerOf(tokenIds[x]) == offererAddress,\r\n\t\t\t\t\"Offerer is not owner of tokenId\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t_nftRegistryAddresses = nftRegistryAddresses;\r\n\t\t_niftexWalletAddress = niftexWalletAddress;\r\n\t\t_artistWalletAddress = artistWalletAddress;\r\n\t\t_tokenIds = tokenIds;\r\n\t\t_offererAddress = offererAddress;\r\n\t}\r\n\r\n\t/**\r\n\t\t* @dev Used to receive ether from the pullLiquidity function.\r\n\t\t*/\r\n\tfunction() external payable { }\r\n\r\n\tfunction deploySubcontracts(\r\n\t\tuint liqProviderCutInShards,\r\n\t\tuint artistCutInShards,\r\n\t\tuint pricePerShardInWei,\r\n\t\tuint shardAmountOffered,\r\n\t\tuint offeringDeadline,\r\n\t\tuint256 cap,\r\n\t\tstring calldata name,\r\n\t\tstring calldata symbol,\r\n\t\tbool shotgunDisabled,\r\n\t\taddress factoryAddress\r\n\t) external {\r\n\t\trequire(\r\n\t\t\tmsg.sender == _niftexWalletAddress,\r\n\t\t\t\"[deploySubcontracts] Unauthorized call\"\r\n\t\t);\r\n\r\n\t\trequire(\r\n\t\t\taddress(_shardRegistry) == address(0) && address(_shardOffering) == address(0),\r\n\t\t\t\"[deploySubcontracts] Contract(s) exist\"\r\n\t\t);\r\n\r\n\t\tIFactory factory = IFactory(factoryAddress);\r\n\t\t(_shardRegistry, _shardOffering) = factory.newSet(\r\n\t\t\tliqProviderCutInShards,\r\n\t\t\tartistCutInShards,\r\n\t\t\tpricePerShardInWei,\r\n\t\t\tshardAmountOffered,\r\n\t\t\tofferingDeadline,\r\n\t\t\tcap,\r\n\t\t\tname,\r\n\t\t\tsymbol,\r\n\t\t\tshotgunDisabled\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Issues Shards upon completion of Offering.\r\n\t\t* @dev Cap should equal totalSupply when all Shards have been claimed.\r\n\t\t* @dev The Offerer may close an undersubscribed Offering once the deadline has\r\n\t\t* passed and claim the remaining Shards.\r\n\t\t*/\r\n\tfunction checkOfferingAndIssue() external {\r\n\t\trequire(\r\n\t\t\t_shardRegistry.totalSupply() != _shardRegistry.cap(),\r\n\t\t\t\"[checkOfferingAndIssue] Shards have already been issued\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t!_shardOffering.hasClaimedShards(msg.sender),\r\n\t\t\t\"[checkOfferingAndIssue] You have already claimed your Shards\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t_shardOffering.offeringCompleted() ||\r\n\t\t\t(now > _shardOffering.offeringDeadline() && !_shardOffering.offeringCompleted()),\r\n\t\t\t\"Offering not completed or deadline not expired\"\r\n\t\t);\r\n\t\tif (_shardOffering.offeringCompleted()) {\r\n\t\t\tif (_shardOffering.getSubEther(msg.sender) != 0) {\r\n\t\t\t\t_shardOffering.claimShards(msg.sender);\r\n\t\t\t\tuint subShards = _shardOffering.getSubShards(msg.sender);\r\n\t\t\t\tbool success = _shardRegistry.mint(msg.sender, subShards);\r\n\t\t\t\trequire(success, \"[checkOfferingAndIssue] Mint failed\");\r\n\t\t\t\temit ShardsClaimed(msg.sender, subShards);\r\n\t\t\t} else if (msg.sender == _offererAddress) {\r\n\t\t\t\t_shardOffering.claimShards(msg.sender);\r\n\t\t\t\tuint offShards = _shardOffering.offererShardAmount();\r\n\t\t\t\tbool success = _shardRegistry.mint(msg.sender, offShards);\r\n\t\t\t\trequire(success, \"[checkOfferingAndIssue] Mint failed\");\r\n\t\t\t\temit ShardsClaimed(msg.sender, offShards);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t_shardOffering.wrapUpOffering();\r\n\t\t\tuint remainingShards = _shardRegistry.cap().sub(_shardOffering.totalShardsClaimed());\r\n\t\t\tremainingShards = remainingShards\r\n\t\t\t\t.sub(_shardOffering.liqProviderCutInShards())\r\n\t\t\t\t.sub(_shardOffering.artistCutInShards());\r\n\t\t\tbool success = _shardRegistry.mint(_offererAddress, remainingShards);\r\n\t\t\trequire(success, \"[checkOfferingAndIssue] Mint failed\");\r\n\t\t\temit ShardsClaimed(msg.sender, remainingShards);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Used by NIFTEX to claim predetermined amount of shards in offering in order\r\n\t\t* to bootstrap liquidity on Uniswap-type exchange.\r\n\t\t*/\r\n\t/* function claimLiqProviderShards() external {\r\n\t\trequire(\r\n\t\t\tmsg.sender == _niftexWalletAddress,\r\n\t\t\t\"[claimLiqProviderShards] Unauthorized caller\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t!_shardOffering.hasClaimedShards(msg.sender),\r\n\t\t\t\"[claimLiqProviderShards] You have already claimed your Shards\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t_shardOffering.offeringCompleted(),\r\n\t\t\t\"[claimLiqProviderShards] Offering not completed\"\r\n\t\t);\r\n\t\t_shardOffering.claimShards(_niftexWalletAddress);\r\n\t\tuint cut = _shardOffering.liqProviderCutInShards();\r\n\t\tbool success = _shardRegistry.mint(_niftexWalletAddress, cut);\r\n\t\trequire(success, \"[claimLiqProviderShards] Mint failed\");\r\n\t\temit ShardsClaimed(msg.sender, cut);\r\n\t} */\r\n\r\n\tfunction mintReservedShards(address _beneficiary) external {\r\n\t\tbool niftex;\r\n\t\tif (_beneficiary == _niftexWalletAddress) niftex = true;\r\n\t\trequire(\r\n\t\t\tniftex ||\r\n\t\t\t_beneficiary == _artistWalletAddress,\r\n\t\t\t\"[mintReservedShards] Unauthorized beneficiary\"\r\n\t\t);\r\n\t\trequire(\r\n\t\t\t!_shardOffering.hasClaimedShards(_beneficiary),\r\n\t\t\t\"[mintReservedShards] Shards already claimed\"\r\n\t\t);\r\n\t\t_shardOffering.claimShards(_beneficiary);\r\n\t\tuint cut;\r\n\t\tif (niftex) {\r\n\t\t\tcut = _shardOffering.liqProviderCutInShards();\r\n\t\t} else {\r\n\t\t\tcut = _shardOffering.artistCutInShards();\r\n\t\t}\r\n\t\tbool success = _shardRegistry.mint(_beneficiary, cut);\r\n\t\trequire(success, \"[mintReservedShards] Mint failed\");\r\n\t\temit ShardsClaimed(_beneficiary, cut);\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice In the unlikely case that one account accumulates all Shards,\r\n\t\t* they can be redeemed directly for the underlying NFT.\r\n\t\t*/\r\n\tfunction redeem() external {\r\n\t\trequire(\r\n\t\t\t_shardRegistry.balanceOf(msg.sender) == _shardRegistry.cap(),\r\n\t\t\t\"[redeem] Account does not own total amount of Shards outstanding\"\r\n\t\t);\r\n\t\t// Disable contracts to improve compatibility with certain NFT projects\r\n\t\trequire(\r\n\t\t\tmsg.sender == tx.origin,\r\n\t\t\t\"[redeem] Caller must be wallet\"\r\n\t\t);\r\n\t\tfor (uint x = 0; x < _tokenIds.length; x++) {\r\n\t\t\tIERC721(_nftRegistryAddresses[x]).safeTransferFrom(address(this), msg.sender, _tokenIds[x]);\r\n\t\t}\r\n\t\temit NftRedeemed(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Creates a new Shotgun claim.\r\n\t\t* @dev This Function is called from the Shard Registry because the claimant's\r\n\t\t* Shards must be frozen until the Shotgun is resolved: if they lose the claim,\r\n\t\t* their Shards are automatically distributed to the counterclaimants.\r\n\t\t* @dev The Registry is paused while an active Shotgun claim exists to\r\n\t\t* let the process work in an orderly manner.\r\n\t\t* @param initialClaimantAddress wallet address of the person who initiated Shotgun.\r\n\t\t* @param initialClaimantBalance Shard balance of the person who initiated Shotgun.\r\n\t\t*/\r\n\tfunction claimInitialShotgun(\r\n\t\taddress payable initialClaimantAddress,\r\n\t\tuint initialClaimantBalance\r\n\t) external payable returns (bool) {\r\n\t\trequire(\r\n\t\t\tmsg.sender == address(_shardRegistry),\r\n\t\t\t\"[claimInitialShotgun] Caller not authorized\"\r\n\t\t);\r\n\t\t_currentShotgunClause = (new ShotgunClause).value(msg.value)(\r\n\t\t\tinitialClaimantAddress,\r\n\t\t\tinitialClaimantBalance,\r\n\t\t\taddress(_shardRegistry)\r\n\t\t);\r\n\t\temit NewShotgun(address(_currentShotgunClause));\r\n\t\t_shardRegistry.pause();\r\n\t\t_shotgunAddressArray.push(address(_currentShotgunClause));\r\n\t\t_shotgunCounter++;\r\n\t\t_shotgunMapping[address(_currentShotgunClause)] = _shotgunCounter;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Effects the results of a (un)successful Shotgun claim.\r\n\t\t* @dev This Function can only be called by a Shotgun contract in two scenarios:\r\n\t\t* - Counterclaimants raise enough ether to buy claimant out\r\n\t\t* - Shotgun deadline passes without successful counter-raise, claimant wins\r\n\t\t*/\r\n\tfunction enactShotgun() external {\r\n\t\trequire(\r\n\t\t\t_shotgunMapping[msg.sender] != 0,\r\n\t\t\t\"[enactShotgun] Invalid Shotgun Clause\"\r\n\t\t);\r\n\t\tShotgunClause _shotgunClause = ShotgunClause(msg.sender);\r\n\t\taddress initialClaimantAddress = _shotgunClause.initialClaimantAddress();\r\n\t\tif (uint(_shotgunClause.claimWinner()) == uint(ClaimWinner.Claimant)) {\r\n\t\t\t_shardRegistry.burn(_shardRegistry.balanceOf(initialClaimantAddress));\r\n\t\t\tfor (uint x = 0; x < _tokenIds.length; x++) {\r\n\t\t\t\tIERC721(_nftRegistryAddresses[x]).safeTransferFrom(address(this), initialClaimantAddress, _tokenIds[x]);\r\n\t\t\t}\r\n\t\t\t_shardRegistry.unpause();\r\n\t\t\temit ShotgunEnacted(address(_shotgunClause));\r\n\t\t} else if (uint(_shotgunClause.claimWinner()) == uint(ClaimWinner.Counterclaimant)) {\r\n\t\t\t_shardRegistry.unpause();\r\n\t\t\temit ShotgunEnacted(address(_shotgunClause));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Transfer Shards to counterclaimants after unsuccessful Shotgun claim.\r\n\t\t* @dev This contract custodies the claimant's Shards when they claim Shotgun -\r\n\t\t* if they lose the claim these Shards must be transferred to counterclaimants.\r\n\t\t* This process is initiated by the relevant Shotgun contract.\r\n\t\t* @param recipient wallet address of the person receiving the Shards.\r\n\t\t* @param amount the amount of Shards to receive.\r\n\t\t*/\r\n\tfunction transferShards(address recipient, uint amount) external {\r\n\t\trequire(\r\n\t\t\t_shotgunMapping[msg.sender] != 0,\r\n\t\t\t\"[transferShards] Unauthorized caller\"\r\n\t\t);\r\n\t\tbool success = _shardRegistry.transfer(recipient, amount);\r\n\t\trequire(success, \"[transferShards] Transfer failed\");\r\n\t\temit ShardsCollected(recipient, amount, msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Allows liquidity providers to pull funds during shotgun.\r\n\t\t* @dev Requires Unitokens to be sent to the contract so the contract can\r\n\t\t* remove liquidity.\r\n\t\t* @param exchangeAddress address of the Uniswap pool.\r\n\t\t* @param liqProvAddress address of the liquidity provider.\r\n\t\t* @param uniTokenAmount liquidity tokens to redeem.\r\n\t\t* @param minEth minimum ether to withdraw.\r\n\t\t* @param minTokens minimum tokens to withdraw.\r\n\t\t* @param deadline deadline for the withdrawal.\r\n\t\t*/\r\n\tfunction pullLiquidity(\r\n\t\taddress exchangeAddress,\r\n\t\taddress liqProvAddress,\r\n\t\tuint256 uniTokenAmount,\r\n\t\tuint256 minEth,\r\n\t\tuint256 minTokens,\r\n\t\tuint256 deadline\r\n\t) public {\r\n\t\trequire(msg.sender == _niftexWalletAddress, \"[pullLiquidity] Unauthorized call\");\r\n\t\tIUniswapExchange uniExchange = IUniswapExchange(exchangeAddress);\r\n\t\tuniExchange.transferFrom(liqProvAddress, address(this), uniTokenAmount);\r\n\t\t_shardRegistry.unpause();\r\n\t\t(uint ethAmount, uint tokenAmount) = uniExchange.removeLiquidity(uniTokenAmount, minEth, minTokens, deadline);\r\n\t\t(bool ethSuccess, ) = liqProvAddress.call.value(ethAmount)(\"\");\r\n\t\trequire(ethSuccess, \"[pullLiquidity] ETH transfer failed.\");\r\n\t\tbool tokenSuccess = _shardRegistry.transfer(liqProvAddress, tokenAmount);\r\n\t\trequire(tokenSuccess, \"[pullLiquidity] Token transfer failed\");\r\n\t\t_shardRegistry.pause();\r\n\t}\r\n\r\n\t/**\r\n\t\t* @dev Utility function to check if a Shotgun is in progress.\r\n\t\t*/\r\n\tfunction checkShotgunState() external view returns (bool) {\r\n\t\tif (_shotgunCounter == 0) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tShotgunClause _shotgunClause = ShotgunClause(_shotgunAddressArray[_shotgunCounter - 1]);\r\n\t\t\tif (_shotgunClause.shotgunEnacted()) {\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction currentShotgunClause() external view returns (address) {\r\n\t\treturn address(_currentShotgunClause);\r\n\t}\r\n\r\n\tfunction shardRegistryAddress() external view returns (address) {\r\n\t\treturn address(_shardRegistry);\r\n\t}\r\n\r\n\tfunction shardOfferingAddress() external view returns (address) {\r\n\t\treturn address(_shardOffering);\r\n\t}\r\n\r\n\tfunction getContractBalance() external view returns (uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n\tfunction offererAddress() external view returns (address payable) {\r\n\t\treturn _offererAddress;\r\n\t}\r\n\r\n\tfunction shotgunCounter() external view returns (uint) {\r\n\t\treturn _shotgunCounter;\r\n\t}\r\n\r\n\tfunction shotgunAddressArray() external view returns (address[] memory) {\r\n\t\treturn _shotgunAddressArray;\r\n\t}\r\n\r\n\tfunction getNftRegistryAddresses() external view returns (address[] memory) {\r\n\t\treturn _nftRegistryAddresses;\r\n\t}\r\n\r\n\tfunction getNftTokenIds() external view returns (uint256[] memory) {\r\n\t\treturn _tokenIds;\r\n\t}\r\n\r\n\tfunction getOwner() external view returns (address) {\r\n\t\treturn _niftexWalletAddress;\r\n\t}\r\n\r\n\t/**\r\n\t\t* @dev Utility function to check whether this contract owns the Sharded NFT.\r\n\t\t*/\r\n\tfunction checkLock() external view returns (bool) {\r\n\t\tif (address(_shardOffering) == address(0) || address(_shardRegistry) == address(0)) return false;\r\n\r\n\t\tfor (uint x = 0; x < _tokenIds.length; x++) {\r\n\t\t\taddress owner = IERC721(_nftRegistryAddresses[x]).ownerOf(_tokenIds[x]);\r\n\t\t\tif (owner != address(this)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t\t* @notice Handle the receipt of an NFT.\r\n\t\t* @dev The ERC721 smart contract calls this function on the recipient\r\n\t\t* after a `safetransfer`. This function MAY throw to revert and reject the\r\n\t\t* transfer. Return of other than the magic value MUST result in the\r\n\t\t* transaction being reverted.\r\n\t\t* Note: the contract address is always the message sender.\r\n\t\t* @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n\t\t*/\r\n\tfunction onERC721Received(address, address, uint256, bytes memory) public returns(bytes4) {\r\n\t\treturn _ERC721_RECEIVED;\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nftRegistryAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"offererAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address payable\",\"name\":\"niftexWalletAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"artistWalletAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"shotgun\",\"type\":\"address\"}],\"name\":\"NewShotgun\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"NftRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shardAmount\",\"type\":\"uint256\"}],\"name\":\"ShardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shardAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"shotgun\",\"type\":\"address\"}],\"name\":\"ShardsCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"enactor\",\"type\":\"address\"}],\"name\":\"ShotgunEnacted\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkOfferingAndIssue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkShotgunState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"initialClaimantAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialClaimantBalance\",\"type\":\"uint256\"}],\"name\":\"claimInitialShotgun\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentShotgunClause\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liqProviderCutInShards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artistCutInShards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePerShardInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shardAmountOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offeringDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"shotgunDisabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"factoryAddress\",\"type\":\"address\"}],\"name\":\"deploySubcontracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enactShotgun\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNftRegistryAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNftTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"mintReservedShards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"offererAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liqProvAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uniTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"pullLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shardOfferingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shardRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shotgunAddressArray\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shotgunCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferShards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ShardGovernor","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000a690b298f84d12414f5c8db7de1ece5a460587700000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000a31f5bd5cc1e975a3791015237951f9d6073c42e0000000000000000000000003ddb542f4bbc36c99e1ae02d99ecdbbb48831c8d00000000000000000000000000000000000000000000000000000000000000010000000000000000000000006c7b6cc55d4098400ac787c8793205d3e86c37c900000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000046","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f496d1e5246837fd26a940a39bcaf4ac1bb61063b8ee65a381a382c235f0a982"}]}