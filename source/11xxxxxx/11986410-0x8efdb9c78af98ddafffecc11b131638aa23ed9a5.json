{"status":"1","message":"OK","result":[{"SourceCode":"{\"Crowdsale.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n//import \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\n//import \\\"../token/ERC20/SafeERC20.sol\\\";\\n\\n\\n/**\\n * @title Crowdsale\\n * @dev Crowdsale is a base contract for managing a token crowdsale,\\n * allowing investors to purchase tokens with ether. This contract implements\\n * such functionality in its most fundamental form and can be extended to provide additional\\n * functionality and/or custom behavior.\\n * The external interface represents the basic interface for purchasing tokens, and conform\\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\\n * the methods to add functionality. Consider using \\u0027super\\u0027 where appropriate to concatenate\\n * behavior.\\n */\\ncontract Crowdsale {\\n  using SafeMath for uint256;\\n  //using SafeERC20 for ERC20;\\n\\n  // Address where funds are collected\\n  address public wallet;\\n\\n  // Plants by ammount wei\\n  uint256 public rate;\\n\\n  // Amount of wei raised\\n  uint256 public weiRaised;\\n\\n  /**\\n   * Event for plants purchase logging\\n   * @param purchaser who paid for the plants\\n   * @param beneficiary who got the plants\\n   * @param value weis paid for purchase\\n   * @param amount amount of plants purchased\\n   */\\n  event PlantPurchase(\\n    address indexed purchaser,\\n    address indexed beneficiary,\\n    uint256 value,\\n    uint256 amount\\n  );\\n\\n  /**\\n   * @param _rate Number of plants units a buyer gets per wei\\n   * @param _wallet Address where collected funds will be forwarded to\\n   */\\n  constructor(uint256 _rate, address _wallet) public {\\n    require(_rate \\u003e 0);\\n    require(_wallet != address(0));\\n\\n    rate = _rate;\\n    wallet = _wallet;\\n  }\\n\\n  // -----------------------------------------\\n  // Crowdsale external interface\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev fallback function ***DO NOT OVERRIDE***\\n   */\\n  function () external payable {\\n    buyPlants(msg.sender);\\n  }\\n\\n  /**\\n   * @dev low level plants purchase ***DO NOT OVERRIDE***\\n   * @param _beneficiary Address performing the plant purchase\\n   */\\n  function buyPlants(address _beneficiary) public payable {\\n\\n    uint256 weiAmount = msg.value;\\n    // Validar antes de\\n    _preValidatePurchase(_beneficiary, weiAmount);\\n   \\n    // calculate plants amount to be created\\n    uint256 plants = _getPlantAmount(weiAmount);\\n    // update state\\n    weiRaised = weiRaised.add(weiAmount);\\n\\n    //_processPurchase(_beneficiary, plants);\\n\\n    emit PlantPurchase(\\n      msg.sender,\\n      _beneficiary,\\n      weiAmount,\\n      plants\\n    );\\n\\n    _updatePurchasingState(_beneficiary, weiAmount);\\n    _forwardFunds();\\n    _postValidatePurchase(_beneficiary, weiAmount);\\n  }\\n\\n  // -----------------------------------------\\n  // Internal interface (extensible)\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\\n   * Example from CappedCrowdsale.sol\\u0027s _preValidatePurchase method: \\n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\\n   *   require(weiRaised.add(_weiAmount) \\u003c= cap);\\n   * @param _beneficiary Address performing the plants purchase\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _preValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    require(_beneficiary != address(0));\\n    require(_weiAmount != 0);\\n  }\\n\\n  /**\\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\\n   * @param _beneficiary Address performing the plants purchase\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _postValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\\n   * @param _beneficiary Address receiving the plants\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _updatePurchasingState(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Override to extend the way in which ether is converted to plants.\\n   * @param _weiAmount Value in wei to be converted into plants\\n   * @return Number of plants that can be purchased with the specified _weiAmount\\n   */\\n  function _getPlantAmount(uint256 _weiAmount)\\n    internal view returns (uint256)\\n  {\\n    return _weiAmount.mul(rate);\\n  }\\n\\n  /**\\n   * @dev Determines how ETH is stored/forwarded on purchases.\\n   */\\n  function _forwardFunds() internal {\\n    wallet.transfer(msg.value);\\n  }\\n}\\n\"},\"EgroweedManasrCrowdsale.sol\":{\"content\":\"pragma solidity 0.4.24;\\r\\n//import \\\"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/token/ERC20/PausableToken.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/token/ERC20/TokenTimelock.sol\\\";\\r\\nimport \\\"Crowdsale.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/crowdsale/validation/WhitelistedCrowdsale.sol\\\";\\r\\n//import \\\"openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol\\\";\\r\\n\\r\\ncontract EgroweedManasrCrowdsale is Crowdsale {\\r\\n\\r\\n  // Min and max cap user invest\\r\\n  uint256 public investorMinCap =    100000000000000000;\\r\\n  uint256 public investorHardCap = 70000000000000000000;\\r\\n\\r\\n  mapping(address =\\u003e uint256) public contributions;\\r\\n\\r\\n  constructor(uint256 _rate, address _wallet)\\r\\n    Crowdsale(_rate, _wallet)\\r\\n    public\\r\\n  {\\r\\n    \\r\\n  }\\r\\n\\r\\n  // obtener la contribucion de un e-grower en el crowdfunding\\r\\n  function getUserContribution(address _beneficiary)public view returns (uint256){\\r\\n    return contributions[_beneficiary];\\r\\n  }\\r\\n \\r\\n  // Obtener fondos\\r\\n  function _forwardFunds() internal {\\r\\n    super._forwardFunds();\\r\\n  }\\r\\n  \\r\\n  // Validar los datos del e-grower, cantidad enviada y capacidad de invertir (min 0.1, maximo 700)\\r\\n  function _preValidatePurchase(address _beneficiary,uint256 _weiAmount)internal{\\r\\n    require(_beneficiary != address(0));\\r\\n    require(_weiAmount != 0);\\r\\n    // Obtener contribucion\\r\\n    uint256 _existingContribution = contributions[_beneficiary];\\r\\n    uint256 _newContribution = _existingContribution.add(_weiAmount); // sumar lo enviado\\r\\n    //Validar los limites\\r\\n    require(_newContribution \\u003e= investorMinCap \\u0026\\u0026 _newContribution \\u003c= investorHardCap);\\r\\n    //Nueva contribucion\\r\\n    contributions[_beneficiary] = _newContribution;\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    c = _a * _b;\\n    assert(c / _a == _b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n    return _a / _b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    assert(_b \\u003c= _a);\\n    return _a - _b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    c = _a + _b;\\n    assert(c \\u003e= _a);\\n    return c;\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorMinCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getUserContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyPlants\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlantPurchase\",\"type\":\"event\"}]","ContractName":"EgroweedManasrCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000063e4d8ae4c075e038c92783dee3743c8a5cc27bf","EVMVersion":"Default","Library":"","LicenseType":"OSL-3.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://44e5ab7e2bd75444a59f2603acede09e9d3dc343f4ed0a9ddf09479671e88d14"}]}