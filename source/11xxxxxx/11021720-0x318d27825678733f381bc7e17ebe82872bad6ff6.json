{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge\r\n*\r\n* Implementation of an example of a diamond.\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct FacetAddressAndPosition {\r\n        address facetAddress;\r\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n    }\r\n\r\n    struct FacetFunctionSelectors {\r\n        bytes4[] functionSelectors;\r\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n    }\r\n\r\n    struct DiamondStorage {\r\n        // maps function selector to the facet address and\r\n        // the position of the selector in the facetFunctionSelectors.selectors array\r\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n        // maps facet addresses to function selectors\r\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n        // facet addresses\r\n        address[] facetAddresses;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n        _;\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'FacetCut[] memory _diamondCut' instead of\r\n    // 'FacetCut[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            addReplaceRemoveFacetSelectors(\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        // add or replace functions\r\n        if (_newFacetAddress != address(0)) {\r\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_newFacetAddress].facetAddressPosition;\r\n            // add new facet address if it does not exist\r\n            if (facetAddressPosition == 0 && ds.facetFunctionSelectors[_newFacetAddress].functionSelectors.length == 0) {\r\n                enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: New facet has no code\");\r\n                facetAddressPosition = ds.facetAddresses.length;\r\n                ds.facetAddresses.push(_newFacetAddress);\r\n                ds.facetFunctionSelectors[_newFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\r\n            }\r\n            // add or replace selectors\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n                // add\r\n                if (_action == IDiamondCut.FacetCutAction.Add) {\r\n                    require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                    addSelector(_newFacetAddress, selector);\r\n                } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n                    // replace\r\n                    require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                    removeSelector(oldFacetAddress, selector);\r\n                    addSelector(_newFacetAddress, selector);\r\n                } else {\r\n                    revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n                }\r\n            }\r\n        } else {\r\n            require(_action == IDiamondCut.FacetCutAction.Remove, \"LibDiamondCut: action not set to FacetCutAction.Remove\");\r\n            // remove selectors\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                removeSelector(ds.selectorToFacetAndPosition[selector].facetAddress, selector);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addSelector(address _newFacet, bytes4 _selector) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 selectorPosition = ds.facetFunctionSelectors[_newFacet].functionSelectors.length;\r\n        ds.facetFunctionSelectors[_newFacet].functionSelectors.push(_selector);\r\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _newFacet;\r\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = uint16(selectorPosition);\r\n    }\r\n\r\n    function removeSelector(address _oldFacetAddress, bytes4 _selector) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // if function does not exist then do nothing and return\r\n        require(_oldFacetAddress != address(0), \"LibDiamondCut: Can't remove or replace function that doesn't exist\");\r\n        require(_oldFacetAddress != address(this), \"LibDiamondCut: Can't remove or replace immutable function\");\r\n        // replace selector with last selector, then delete last selector\r\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\r\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_oldFacetAddress].functionSelectors.length - 1;\r\n        // if not the same then replace _selector with lastSelector\r\n        if (selectorPosition != lastSelectorPosition) {\r\n            bytes4 lastSelector = ds.facetFunctionSelectors[_oldFacetAddress].functionSelectors[lastSelectorPosition];\r\n            ds.facetFunctionSelectors[_oldFacetAddress].functionSelectors[selectorPosition] = lastSelector;\r\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\r\n        }\r\n        // delete the last selector\r\n        ds.facetFunctionSelectors[_oldFacetAddress].functionSelectors.pop();\r\n        delete ds.selectorToFacetAndPosition[_selector];\r\n\r\n        // if no more selectors for facet address then delete the facet address\r\n        if (lastSelectorPosition == 0) {\r\n            // replace facet address with last facet address and delete last facet address\r\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\r\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_oldFacetAddress].facetAddressPosition;\r\n            if (facetAddressPosition != lastFacetAddressPosition) {\r\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\r\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\r\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\r\n            }\r\n            ds.facetAddresses.pop();\r\n            delete ds.facetFunctionSelectors[_oldFacetAddress];\r\n        }\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ncontract Diamond {\r\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, address _owner) payable {\r\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\r\n        LibDiamond.setContractOwner(_owner);\r\n\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n                        \r\n          // adding ERC165 data\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\ncontract DiamondFactory {\r\n  event DiamondCreated(address tokenAddress);\r\n\r\n  function deployNewDiamond(\r\n    address _owner,\r\n    IDiamondCut.FacetCut[] memory diamondCut\r\n  ) public returns (address) {\r\n    Diamond d = new Diamond(diamondCut, _owner);\r\n    emit DiamondCreated(address(d));\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Diamond","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000004cf5f3ecd6303f6a04480f75ac394d4bb3816f83000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000003e000000000000000000000000000000000000000000000000000000000000005a00000000000000000000000001f1c29a6691fbe1768b2b289655ec6ae9192a2510000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000011f931c1c00000000000000000000000000000000000000000000000000000000000000000000000000000000dc4deec075ddbc668d1f802e6d7139a866632e2c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000057a0ed62700000000000000000000000000000000000000000000000000000000adfca15e0000000000000000000000000000000000000000000000000000000052ef6b2c00000000000000000000000000000000000000000000000000000000cdffacc60000000000000000000000000000000000000000000000000000000001ffc9a70000000000000000000000000000000000000000000000000000000000000000000000000000000067cae12e325ac91e1a76e14a5f4b79bcd58b2419000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000002f2fde38b000000000000000000000000000000000000000000000000000000008da5cb5b000000000000000000000000000000000000000000000000000000000000000000000000000000005f41fc259627dbf27623ae89e8f813bc80e6e82b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000130c9473c000000000000000000000000000000000000000000000000000000000000000000000000000000007213257925641ec46774a98b0b19e2574b2a220300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000a8a35c5630000000000000000000000000000000000000000000000000000000006fdde030000000000000000000000000000000000000000000000000000000095d89b4100000000000000000000000000000000000000000000000000000000313ce56700000000000000000000000000000000000000000000000000000000095ea7b300000000000000000000000000000000000000000000000000000000a9059cbb0000000000000000000000000000000000000000000000000000000023b872dd00000000000000000000000000000000000000000000000000000000dd62ed3e0000000000000000000000000000000000000000000000000000000070a082310000000000000000000000000000000000000000000000000000000018160ddd00000000000000000000000000000000000000000000000000000000000000000000000000000000b9c91b2740a4aacaac91d49d0bb9cb526deaa1e600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000960b5bb3f0000000000000000000000000000000000000000000000000000000034e7a19f00000000000000000000000000000000000000000000000000000000be1d24ad000000000000000000000000000000000000000000000000000000007e5852d900000000000000000000000000000000000000000000000000000000d3e1574700000000000000000000000000000000000000000000000000000000c7352ede00000000000000000000000000000000000000000000000000000000763265de00000000000000000000000000000000000000000000000000000000e3d670d700000000000000000000000000000000000000000000000000000000aa6ca80800000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"1","Implementation":"0x5f41fc259627dbf27623ae89e8f813bc80e6e82b","SwarmSource":"ipfs://4b92f54a2868f69a5d9929624c57077f9526790c0a7b7229356b0124a19eba8c"}]}