{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/PrintLimiter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20Impl.sol\\\";\\nimport \\\"./LockRequestable.sol\\\";\\n\\n/** @title  A contact to govern hybrid control over increases to the token supply.\\n  *\\n  * @notice  A contract that acts as a custodian of the active token\\n  * implementation, and an intermediary between it and the ‘true’ custodian.\\n  * It preserves the functionality of direct custodianship as well as granting\\n  * limited control of token supply increases to an additional key.\\n  *\\n  * @dev  This contract is a layer of indirection between an instance of\\n  * ERC20Impl and a custodian. The functionality of the custodianship over\\n  * the token implementation is preserved (printing and custodian changes),\\n  * but this contract adds the ability for an additional key\\n  * (the 'limited printer') to increase the token supply up to a ceiling,\\n  * and this supply ceiling can only be raised by the custodian.\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\ncontract PrintLimiter is LockRequestable {\\n\\n    // TYPES\\n    /// @dev The struct type for pending ceiling raises.\\n    struct PendingCeilingRaise {\\n        uint256 raiseBy;\\n    }\\n\\n    // MEMBERS\\n    /// @dev  The reference to the active token implementation.\\n    ERC20Impl immutable public erc20Impl;\\n\\n    /// @dev  The address of the account or contract that acts as the custodian.\\n    address immutable public custodian;\\n\\n    /** @dev  The sole authorized caller of limited printing.\\n      * This account is also authorized to lower the supply ceiling.\\n      */\\n    address immutable public limitedPrinter;\\n\\n    /** @dev  The maximum that the token supply can be increased to\\n      * through use of the limited printing feature.\\n      * The difference between the current total supply and the supply\\n      * ceiling is what is available to the 'limited printer' account.\\n      * The value of the ceiling can only be increased by the custodian.\\n      */\\n    uint256 public totalSupplyCeiling;\\n\\n    /// @dev  The map of lock ids to pending ceiling raises.\\n    mapping (bytes32 => PendingCeilingRaise) public pendingRaiseMap;\\n\\n    // CONSTRUCTOR\\n    constructor(\\n        address _erc20Impl,\\n        address _custodian,\\n        address _limitedPrinter,\\n        uint256 _initialCeiling\\n    )\\n    {\\n        erc20Impl = ERC20Impl(_erc20Impl);\\n        custodian = _custodian;\\n        limitedPrinter = _limitedPrinter;\\n        totalSupplyCeiling = _initialCeiling;\\n    }\\n\\n    // MODIFIERS\\n    modifier onlyCustodian {\\n        require(msg.sender == custodian, \\\"unauthorized\\\");\\n        _;\\n    }\\n    modifier onlyLimitedPrinter {\\n        require(msg.sender == limitedPrinter, \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    /** @notice  Increases the token supply, with the newly created tokens\\n      * being added to the balance of the specified account.\\n      *\\n      * @dev  The function checks that the value to print does not\\n      * exceed the supply ceiling when added to the current total supply.\\n      * NOTE: printing to the zero address is disallowed.\\n      *\\n      * @param  _receiver  The receiving address of the print.\\n      * @param  _value  The number of tokens to add to the total supply and the\\n      * balance of the receiving address.\\n      */\\n    function limitedPrint(address _receiver, uint256 _value, bytes32 _merkleRoot) external onlyLimitedPrinter {\\n        uint256 totalSupply = erc20Impl.totalSupply();\\n        uint256 newTotalSupply = totalSupply + _value;\\n\\n        require(newTotalSupply >= totalSupply, \\\"overflow\\\");\\n        require(newTotalSupply <= totalSupplyCeiling, \\\"ceiling exceeded\\\");\\n        erc20Impl.executePrint(_receiver, _value, _merkleRoot);\\n    }\\n\\n    /** @notice  Requests an increase to the supply ceiling.\\n      *\\n      * @dev  Returns a unique lock id associated with the request.\\n      * Anyone can call this function, but confirming the request is authorized\\n      * by the custodian.\\n      *\\n      * @param  _raiseBy  The amount by which to raise the ceiling.\\n      *\\n      * @return  lockId  A unique identifier for this request.\\n      */\\n    function requestCeilingRaise(uint256 _raiseBy) external returns (bytes32 lockId) {\\n        require(_raiseBy != 0, \\\"zero\\\");\\n\\n        (bytes32 preLockId, uint256 lockRequestIdx) = generatePreLockId();\\n        lockId = keccak256(\\n            abi.encodePacked(\\n                preLockId,\\n                this.requestCeilingRaise.selector,\\n                _raiseBy\\n            )\\n        );\\n\\n        pendingRaiseMap[lockId] = PendingCeilingRaise({\\n            raiseBy: _raiseBy\\n        });\\n\\n        emit CeilingRaiseLocked(lockId, _raiseBy, lockRequestIdx);\\n    }\\n\\n    /** @notice  Confirms a pending increase in the token supply.\\n      *\\n      * @dev  When called by the custodian with a lock id associated with a\\n      * pending ceiling increase, the amount requested is added to the\\n      * current supply ceiling.\\n      * NOTE: this function will not execute any raise that would overflow the\\n      * supply ceiling, but it will not revert either.\\n      *\\n      * @param  _lockId  The identifier of a pending ceiling raise request.\\n      */\\n    function confirmCeilingRaise(bytes32 _lockId) external onlyCustodian {\\n        PendingCeilingRaise storage pendingRaise = pendingRaiseMap[_lockId];\\n\\n        // copy locals of references to struct members\\n        uint256 raiseBy = pendingRaise.raiseBy;\\n        // accounts for a gibberish _lockId\\n        require(raiseBy != 0, \\\"no such lockId\\\");\\n\\n        delete pendingRaiseMap[_lockId];\\n\\n        uint256 newCeiling = totalSupplyCeiling + raiseBy;\\n        // overflow check\\n        if (newCeiling >= totalSupplyCeiling) {\\n            totalSupplyCeiling = newCeiling;\\n\\n            emit CeilingRaiseConfirmed(_lockId, raiseBy, newCeiling);\\n        }\\n    }\\n\\n    /** @notice  Lowers the supply ceiling, further constraining the bound of\\n      * what can be printed by the limited printer.\\n      *\\n      * @dev  The limited printer is the sole authorized caller of this function,\\n      * so it is the only account that can elect to lower its limit to increase\\n      * the token supply.\\n      *\\n      * @param  _lowerBy  The amount by which to lower the supply ceiling.\\n      */\\n    function lowerCeiling(uint256 _lowerBy) external onlyLimitedPrinter {\\n        uint256 newCeiling = totalSupplyCeiling - _lowerBy;\\n        // overflow check\\n        require(newCeiling <= totalSupplyCeiling, \\\"overflow\\\");\\n        totalSupplyCeiling = newCeiling;\\n\\n        emit CeilingLowered(_lowerBy, newCeiling);\\n    }\\n\\n    /** @notice  Pass-through control of print confirmation, allowing this\\n      * contract's custodian to act as the custodian of the associated\\n      * active token implementation.\\n      *\\n      * @dev  This contract is the direct custodian of the active token\\n      * implementation, but this function allows this contract's custodian\\n      * to act as though it were the direct custodian of the active\\n      * token implementation. Therefore the custodian retains control of\\n      * unlimited printing.\\n      *\\n      * @param  _lockId  The identifier of a pending print request in\\n      * the associated active token implementation.\\n      */\\n    function confirmPrintProxy(bytes32 _lockId) external onlyCustodian {\\n        erc20Impl.confirmPrint(_lockId);\\n    }\\n\\n    /** @notice  Pass-through control of custodian change confirmation,\\n      * allowing this contract's custodian to act as the custodian of\\n      * the associated active token implementation.\\n      *\\n      * @dev  This contract is the direct custodian of the active token\\n      * implementation, but this function allows this contract's custodian\\n      * to act as though it were the direct custodian of the active\\n      * token implementation. Therefore the custodian retains control of\\n      * custodian changes.\\n      *\\n      * @param  _lockId  The identifier of a pending custodian change request\\n      * in the associated active token implementation.\\n      */\\n    function confirmCustodianChangeProxy(bytes32 _lockId) external onlyCustodian {\\n        erc20Impl.confirmCustodianChange(_lockId);\\n    }\\n\\n    // EVENTS\\n    /// @dev  Emitted by successful `requestCeilingRaise` calls.\\n    event CeilingRaiseLocked(bytes32 _lockId, uint256 _raiseBy, uint256 _lockRequestIdx);\\n    /// @dev  Emitted by successful `confirmCeilingRaise` calls.\\n    event CeilingRaiseConfirmed(bytes32 _lockId, uint256 _raiseBy, uint256 _newCeiling);\\n\\n    /// @dev  Emitted by successful `lowerCeiling` calls.\\n    event CeilingLowered(uint256 _lowerBy, uint256 _newCeiling);\\n}\\n\"\r\n    },\r\n    \"./contracts/ERC20Impl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CustodianUpgradeable.sol\\\";\\nimport \\\"./ERC20Proxy.sol\\\";\\nimport \\\"./ERC20Store.sol\\\";\\n\\n/** @title  ERC20 compliant token intermediary contract holding core logic.\\n  *\\n  * @notice  This contract serves as an intermediary between the exposed ERC20\\n  * interface in ERC20Proxy and the store of balances in ERC20Store. This\\n  * contract contains core logic that the proxy can delegate to\\n  * and that the store is called by.\\n  *\\n  * @dev  This contract contains the core logic to implement the\\n  * ERC20 specification as well as several extensions.\\n  * 1. Changes to the token supply.\\n  * 2. Batched transfers.\\n  * 3. Relative changes to spending approvals.\\n  * 4. Delegated transfer control ('sweeping').\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\ncontract ERC20Impl is CustodianUpgradeable {\\n\\n    // TYPES\\n    /// @dev  The struct type for pending increases to the token supply (print).\\n    struct PendingPrint {\\n        address receiver;\\n        uint256 value;\\n        bytes32 merkleRoot;\\n    }\\n\\n    // MEMBERS\\n    /// @dev  The reference to the proxy.\\n    ERC20Proxy immutable public erc20Proxy;\\n\\n    /// @dev  The reference to the store.\\n    ERC20Store immutable public erc20Store;\\n\\n    address immutable public implOwner;\\n\\n    /// @dev  The map of lock ids to pending token increases.\\n    mapping (bytes32 => PendingPrint) public pendingPrintMap;\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    bytes32 private immutable _PERMIT_TYPEHASH;\\n\\n\\n    // CONSTRUCTOR\\n    constructor(\\n          address _erc20Proxy,\\n          address _erc20Store,\\n          address _custodian,\\n          address _implOwner\\n    )\\n        CustodianUpgradeable(_custodian)\\n    {\\n        erc20Proxy = ERC20Proxy(_erc20Proxy);\\n        erc20Store = ERC20Store(_erc20Store);\\n        implOwner = _implOwner;\\n\\n        bytes32 hashedName = keccak256(bytes(ERC20Proxy(_erc20Proxy).name()));\\n        bytes32 hashedVersion = keccak256(bytes(\\\"1\\\"));\\n        bytes32 typeHash = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"); \\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = _getChainId();\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion, _erc20Proxy);\\n        _TYPE_HASH = typeHash;\\n\\n        _PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    }\\n\\n    // MODIFIERS\\n    modifier onlyProxy {\\n        require(msg.sender == address(erc20Proxy), \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyImplOwner {\\n        require(msg.sender == implOwner, \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    function _approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        require(_spender != address(0), \\\"zero address\\\"); // disallow unspendable approvals\\n        erc20Store.setAllowance(_owner, _spender, _amount);\\n        erc20Proxy.emitApproval(_owner, _spender, _amount);\\n    }\\n\\n    /** @notice  Core logic of the ERC20 `approve` function.\\n      *\\n      * @dev  This function can only be called by the referenced proxy,\\n      * which has an `approve` function.\\n      * Every argument passed to that function as well as the original\\n      * `msg.sender` gets passed to this function.\\n      * NOTE: approvals for the zero address (unspendable) are disallowed.\\n      *\\n      * @param  _sender  The address initiating the approval in proxy.\\n      */\\n    function approveWithSender(\\n        address _sender,\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        onlyProxy\\n        returns (bool success)\\n    {\\n        _approve(_sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** @notice  Core logic of the `increaseApproval` function.\\n      *\\n      * @dev  This function can only be called by the referenced proxy,\\n      * which has an `increaseApproval` function.\\n      * Every argument passed to that function as well as the original\\n      * `msg.sender` gets passed to this function.\\n      * NOTE: approvals for the zero address (unspendable) are disallowed.\\n      *\\n      * @param  _sender  The address initiating the approval.\\n      */\\n    function increaseApprovalWithSender(\\n        address _sender,\\n        address _spender,\\n        uint256 _addedValue\\n    )\\n        external\\n        onlyProxy\\n        returns (bool success)\\n    {\\n        require(_spender != address(0), \\\"zero address\\\"); // disallow unspendable approvals\\n        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\\n        uint256 newAllowance = currentAllowance + _addedValue;\\n\\n        require(newAllowance >= currentAllowance, \\\"overflow\\\");\\n\\n        erc20Store.setAllowance(_sender, _spender, newAllowance);\\n        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\\n        return true;\\n    }\\n\\n    /** @notice  Core logic of the `decreaseApproval` function.\\n      *\\n      * @dev  This function can only be called by the referenced proxy,\\n      * which has a `decreaseApproval` function.\\n      * Every argument passed to that function as well as the original\\n      * `msg.sender` gets passed to this function.\\n      * NOTE: approvals for the zero address (unspendable) are disallowed.\\n      *\\n      * @param  _sender  The address initiating the approval.\\n      */\\n    function decreaseApprovalWithSender(\\n        address _sender,\\n        address _spender,\\n        uint256 _subtractedValue\\n    )\\n        external\\n        onlyProxy\\n        returns (bool success)\\n    {\\n        require(_spender != address(0), \\\"zero address\\\"); // disallow unspendable approvals\\n        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\\n        uint256 newAllowance = currentAllowance - _subtractedValue;\\n\\n        require(newAllowance <= currentAllowance, \\\"overflow\\\");\\n\\n        erc20Store.setAllowance(_sender, _spender, newAllowance);\\n        erc20Proxy.emitApproval(_sender, _spender, newAllowance);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(owner != address(0x0), \\\"zero address\\\");\\n        require(block.timestamp <= deadline, \\\"expired\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                erc20Store.getNonceAndIncrement(owner),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                _domainSeparatorV4(),\\n                structHash\\n            )\\n        );\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer == owner, \\\"invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n    function nonces(address owner) external view returns (uint256) {\\n      return erc20Store.nonces(owner);\\n    }\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\\n      return _domainSeparatorV4();\\n    }\\n\\n    /** @notice  Requests an increase in the token supply, with the newly created\\n      * tokens to be added to the balance of the specified account.\\n      *\\n      * @dev  Returns a unique lock id associated with the request.\\n      * Anyone can call this function, but confirming the request is authorized\\n      * by the custodian.\\n      * NOTE: printing to the zero address is disallowed.\\n      *\\n      * @param  _receiver  The receiving address of the print, if confirmed.\\n      * @param  _value  The number of tokens to add to the total supply and the\\n      * balance of the receiving address, if confirmed.\\n      *\\n      * @return  lockId  A unique identifier for this request.\\n      */\\n    function requestPrint(address _receiver, uint256 _value, bytes32 _merkleRoot) external returns (bytes32 lockId) {\\n        require(_receiver != address(0), \\\"zero address\\\");\\n\\n        (bytes32 preLockId, uint256 lockRequestIdx) = generatePreLockId();\\n        lockId = keccak256(\\n            abi.encodePacked(\\n                preLockId,\\n                this.requestPrint.selector,\\n                _receiver,\\n                _value,\\n                _merkleRoot\\n            )\\n        );\\n\\n        pendingPrintMap[lockId] = PendingPrint({\\n            receiver: _receiver,\\n            value: _value,\\n            merkleRoot: _merkleRoot\\n        });\\n\\n        emit PrintingLocked(lockId, _receiver, _value, lockRequestIdx);\\n    }\\n\\n    function _executePrint(address _receiver, uint256 _value, bytes32 _merkleRoot) private {\\n        uint256 supply = erc20Store.totalSupply();\\n        uint256 newSupply = supply + _value;\\n        if (newSupply >= supply) {\\n          erc20Store.setTotalSupplyAndAddBalance(newSupply, _receiver, _value);\\n\\n          erc20Proxy.emitTransfer(address(0), _receiver, _value);\\n          emit AuditPrint(_merkleRoot);\\n        }\\n    }\\n\\n    function executePrint(address _receiver, uint256 _value, bytes32 _merkleRoot) external onlyCustodian {\\n        _executePrint(_receiver, _value, _merkleRoot);\\n    }\\n\\n    /** @notice  Confirms a pending increase in the token supply.\\n      *\\n      * @dev  When called by the custodian with a lock id associated with a\\n      * pending increase, the amount requested to be printed in the print request\\n      * is printed to the receiving address specified in that same request.\\n      * NOTE: this function will not execute any print that would overflow the\\n      * total supply, but it will not revert either.\\n      *\\n      * @param  _lockId  The identifier of a pending print request.\\n      */\\n    function confirmPrint(bytes32 _lockId) external onlyCustodian {\\n        PendingPrint storage print = pendingPrintMap[_lockId];\\n\\n        // reject ‘null’ results from the map lookup\\n        // this can only be the case if an unknown `_lockId` is received\\n        address receiver = print.receiver;\\n        require (receiver != address(0), \\\"no such lockId\\\");\\n        uint256 value = print.value;\\n        bytes32 merkleRoot = print.merkleRoot;\\n\\n        delete pendingPrintMap[_lockId];\\n\\n        emit PrintingConfirmed(_lockId, receiver, value);\\n        _executePrint(receiver, value, merkleRoot);\\n    }\\n\\n    /** @notice  Burns the specified value from the sender's balance.\\n      *\\n      * @dev  Sender's balanced is subtracted by the amount they wish to burn.\\n      *\\n      * @param  _value  The amount to burn.\\n      *\\n      * @return  success  true if the burn succeeded.\\n      */\\n    function burn(uint256 _value, bytes32 _merkleRoot) external returns (bool success) {\\n        uint256 balanceOfSender = erc20Store.balances(msg.sender);\\n        require(_value <= balanceOfSender, \\\"insufficient balance\\\");\\n\\n        erc20Store.setBalanceAndDecreaseTotalSupply(\\n            msg.sender,\\n            balanceOfSender - _value,\\n            _value\\n        );\\n\\n        erc20Proxy.emitTransfer(msg.sender, address(0), _value);\\n        emit AuditBurn(_merkleRoot);\\n\\n        return true;\\n    }\\n\\n    /** @notice  A function for a sender to issue multiple transfers to multiple\\n      * different addresses at once. This function is implemented for gas\\n      * considerations when someone wishes to transfer, as one transaction is\\n      * cheaper than issuing several distinct individual `transfer` transactions.\\n      *\\n      * @dev  By specifying a set of destination addresses and values, the\\n      * sender can issue one transaction to transfer multiple amounts to\\n      * distinct addresses, rather than issuing each as a separate\\n      * transaction. The `_tos` and `_values` arrays must be equal length, and\\n      * an index in one array corresponds to the same index in the other array\\n      * (e.g. `_tos[0]` will receive `_values[0]`, `_tos[1]` will receive\\n      * `_values[1]`, and so on.)\\n      * NOTE: transfers to the zero address are disallowed.\\n      *\\n      * @param  _tos  The destination addresses to receive the transfers.\\n      * @param  _values  The values for each destination address.\\n      * @return  success  If transfers succeeded.\\n      */\\n    function batchTransfer(address[] calldata _tos, uint256[] calldata _values) external returns (bool success) {\\n        require(_tos.length == _values.length, \\\"inconsistent length\\\");\\n\\n        uint256 numTransfers = _tos.length;\\n        uint256 senderBalance = erc20Store.balances(msg.sender);\\n\\n        for (uint256 i = 0; i < numTransfers; i++) {\\n          address to = _tos[i];\\n          require(to != address(0), \\\"zero address\\\");\\n          uint256 v = _values[i];\\n          require(senderBalance >= v, \\\"insufficient balance\\\");\\n\\n          if (msg.sender != to) {\\n            senderBalance -= v;\\n            erc20Store.addBalance(to, v);\\n          }\\n          erc20Proxy.emitTransfer(msg.sender, to, v);\\n        }\\n\\n        erc20Store.setBalance(msg.sender, senderBalance);\\n\\n        return true;\\n    }\\n\\n    /** @notice  Core logic of the ERC20 `transferFrom` function.\\n      *\\n      * @dev  This function can only be called by the referenced proxy,\\n      * which has a `transferFrom` function.\\n      * Every argument passed to that function as well as the original\\n      * `msg.sender` gets passed to this function.\\n      * NOTE: transfers to the zero address are disallowed.\\n      *\\n      * @param  _sender  The address initiating the transfer in proxy.\\n      */\\n    function transferFromWithSender(\\n        address _sender,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        onlyProxy\\n        returns (bool success)\\n    {\\n        require(_to != address(0), \\\"zero address\\\"); // ensure burn is the cannonical transfer to 0x0\\n\\n        (uint256 balanceOfFrom, uint256 senderAllowance) = erc20Store.balanceAndAllowed(_from, _sender);\\n        require(_value <= balanceOfFrom, \\\"insufficient balance\\\");\\n        require(_value <= senderAllowance, \\\"insufficient allowance\\\");\\n\\n        erc20Store.setBalanceAndAllowanceAndAddBalance(\\n            _from, balanceOfFrom - _value,\\n            _sender, senderAllowance - _value,\\n            _to, _value\\n        );\\n\\n        erc20Proxy.emitTransfer(_from, _to, _value);\\n\\n        return true;\\n    }\\n\\n    /** @notice  Core logic of the ERC20 `transfer` function.\\n      *\\n      * @dev  This function can only be called by the referenced proxy,\\n      * which has a `transfer` function.\\n      * Every argument passed to that function as well as the original\\n      * `msg.sender` gets passed to this function.\\n      * NOTE: transfers to the zero address are disallowed.\\n      *\\n      * @param  _sender  The address initiating the transfer in proxy.\\n      */\\n    function transferWithSender(\\n        address _sender,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        onlyProxy\\n        returns (bool success)\\n    {\\n        require(_to != address(0), \\\"zero address\\\"); // ensure burn is the cannonical transfer to 0x0\\n\\n        uint256 balanceOfSender = erc20Store.balances(_sender);\\n        require(_value <= balanceOfSender, \\\"insufficient balance\\\");\\n\\n        erc20Store.setBalanceAndAddBalance(\\n            _sender, balanceOfSender - _value,\\n            _to, _value\\n        );\\n\\n        erc20Proxy.emitTransfer(_sender, _to, _value);\\n\\n        return true;\\n    }\\n\\n    // METHODS (ERC20 sub interface impl.)\\n    /// @notice  Core logic of the ERC20 `totalSupply` function.\\n    function totalSupply() external view returns (uint256) {\\n        return erc20Store.totalSupply();\\n    }\\n\\n    /// @notice  Core logic of the ERC20 `balanceOf` function.\\n    function balanceOf(address _owner) external view returns (uint256 balance) {\\n        return erc20Store.balances(_owner);\\n    }\\n\\n    /// @notice  Core logic of the ERC20 `allowance` function.\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\\n        return erc20Store.allowed(_owner, _spender);\\n    }\\n\\n    function executeCallInProxy(\\n        address contractAddress,\\n        bytes calldata callData\\n    ) external onlyImplOwner {\\n        erc20Proxy.executeCallWithData(contractAddress, callData);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() private view returns (bytes32) {\\n        if (_getChainId() == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, address(erc20Proxy));\\n        }\\n    }\\n\\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version, address verifyingContract) private view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                typeHash,\\n                name,\\n                version,\\n                _getChainId(),\\n                verifyingContract\\n            )\\n        );\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        // SEE:\\n        //   - https://github.com/ethereum/solidity/issues/8854#issuecomment-629436203\\n        //   - https://github.com/ethereum/solidity/issues/10090\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n\\n    // EVENTS\\n    /// @dev  Emitted by successful `requestPrint` calls.\\n    event PrintingLocked(bytes32 _lockId, address _receiver, uint256 _value, uint256 _lockRequestIdx);\\n    /// @dev Emitted by successful `confirmPrint` calls.\\n    event PrintingConfirmed(bytes32 _lockId, address _receiver, uint256 _value);\\n\\n    event AuditBurn(bytes32 merkleRoot);\\n    event AuditPrint(bytes32 merkleRoot);\\n}\\n\"\r\n    },\r\n    \"./contracts/CustodianUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./LockRequestable.sol\\\";\\n\\n/** @title  A contract to inherit upgradeable custodianship.\\n  *\\n  * @notice  A contract that provides re-usable code for upgradeable\\n  * custodianship. That custodian may be an account or another contract.\\n  *\\n  * @dev  This contract is intended to be inherited by any contract\\n  * requiring a custodian to control some aspect of its functionality.\\n  * This contract provides the mechanism for that custodianship to be\\n  * passed from one custodian to the next.\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\nabstract contract CustodianUpgradeable is LockRequestable {\\n\\n    // TYPES\\n    /// @dev  The struct type for pending custodian changes.\\n    struct CustodianChangeRequest {\\n        address proposedNew;\\n    }\\n\\n    // MEMBERS\\n    /// @dev  The address of the account or contract that acts as the custodian.\\n    address public custodian;\\n\\n    /// @dev  The map of lock ids to pending custodian changes.\\n    mapping (bytes32 => CustodianChangeRequest) public custodianChangeReqs;\\n\\n    // CONSTRUCTOR\\n    constructor(\\n        address _custodian\\n    )\\n      LockRequestable()\\n    {\\n        custodian = _custodian;\\n    }\\n\\n    // MODIFIERS\\n    modifier onlyCustodian {\\n        require(msg.sender == custodian, \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n    // (UPGRADE)\\n\\n    /** @notice  Requests a change of the custodian associated with this contract.\\n      *\\n      * @dev  Returns a unique lock id associated with the request.\\n      * Anyone can call this function, but confirming the request is authorized\\n      * by the custodian.\\n      *\\n      * @param  _proposedCustodian  The address of the new custodian.\\n      * @return  lockId  A unique identifier for this request.\\n      */\\n    function requestCustodianChange(address _proposedCustodian) external returns (bytes32 lockId) {\\n        require(_proposedCustodian != address(0), \\\"zero address\\\");\\n\\n        (bytes32 preLockId, uint256 lockRequestIdx) = generatePreLockId();\\n        lockId = keccak256(\\n            abi.encodePacked(\\n                preLockId,\\n                this.requestCustodianChange.selector,\\n                _proposedCustodian\\n            )\\n        );\\n\\n        custodianChangeReqs[lockId] = CustodianChangeRequest({\\n            proposedNew: _proposedCustodian\\n        });\\n\\n        emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian, lockRequestIdx);\\n    }\\n\\n    /** @notice  Confirms a pending change of the custodian associated with this contract.\\n      *\\n      * @dev  When called by the current custodian with a lock id associated with a\\n      * pending custodian change, the `address custodian` member will be updated with the\\n      * requested address.\\n      *\\n      * @param  _lockId  The identifier of a pending change request.\\n      */\\n    function confirmCustodianChange(bytes32 _lockId) external onlyCustodian {\\n        custodian = getCustodianChangeReq(_lockId);\\n\\n        delete custodianChangeReqs[_lockId];\\n\\n        emit CustodianChangeConfirmed(_lockId, custodian);\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n    function getCustodianChangeReq(bytes32 _lockId) private view returns (address _proposedNew) {\\n        CustodianChangeRequest storage changeRequest = custodianChangeReqs[_lockId];\\n\\n        // reject ‘null’ results from the map lookup\\n        // this can only be the case if an unknown `_lockId` is received\\n        require(changeRequest.proposedNew != address(0), \\\"no such lockId\\\");\\n\\n        return changeRequest.proposedNew;\\n    }\\n\\n    /// @dev  Emitted by successful `requestCustodianChange` calls.\\n    event CustodianChangeRequested(\\n        bytes32 _lockId,\\n        address _msgSender,\\n        address _proposedCustodian,\\n        uint256 _lockRequestIdx\\n    );\\n\\n    /// @dev Emitted by successful `confirmCustodianChange` calls.\\n    event CustodianChangeConfirmed(bytes32 _lockId, address _newCustodian);\\n}\\n\"\r\n    },\r\n    \"./contracts/LockRequestable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\n/** @title  A contract for generating unique identifiers\\n  *\\n  * @notice  A contract that provides a identifier generation scheme,\\n  * guaranteeing uniqueness across all contracts that inherit from it,\\n  * as well as unpredictability of future identifiers.\\n  *\\n  * @dev  This contract is intended to be inherited by any contract that\\n  * implements the callback software pattern for cooperative custodianship.\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\nabstract contract LockRequestable {\\n\\n    // MEMBERS\\n    /// @notice  the count of all invocations of `generatePreLockId`.\\n    uint256 public lockRequestCount;\\n\\n    // CONSTRUCTOR\\n    constructor() {\\n        lockRequestCount = 0;\\n    }\\n\\n    // FUNCTIONS\\n    /** @notice  Returns a fresh unique identifier.\\n      *\\n      * @dev the generation scheme uses three components.\\n      * First, the blockhash of the previous block.\\n      * Second, the deployed address.\\n      * Third, the next value of the counter.\\n      * This ensure that identifiers are unique across all contracts\\n      * following this scheme, and that future identifiers are\\n      * unpredictable.\\n      *\\n      * @return preLockId a 32-byte unique identifier.\\n      * @return lockRequestIdx index of lock request\\n\\n      */\\n    function generatePreLockId() internal returns (bytes32 preLockId, uint256 lockRequestIdx) {\\n        lockRequestIdx = ++lockRequestCount;\\n        preLockId = keccak256(\\n          abi.encodePacked(\\n            blockhash(block.number - 1),\\n            address(this),\\n            lockRequestIdx\\n          )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/ERC20Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./EIP2612Interface.sol\\\";\\nimport \\\"./ERC20Interface.sol\\\";\\nimport \\\"./ERC20ImplUpgradeable.sol\\\";\\n\\n/** @title  Public interface to ERC20 compliant token.\\n  *\\n  * @notice  This contract is a permanent entry point to an ERC20 compliant\\n  * system of contracts.\\n  *\\n  * @dev  This contract contains no business logic and instead\\n  * delegates to an instance of ERC20Impl. This contract also has no storage\\n  * that constitutes the operational state of the token. This contract is\\n  * upgradeable in the sense that the `custodian` can update the\\n  * `erc20Impl` address, thus redirecting the delegation of business logic.\\n  * The `custodian` is also authorized to pass custodianship.\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\ncontract ERC20Proxy is ERC20Interface, ERC20ImplUpgradeable, EIP2612Interface {\\n\\n    // MEMBERS\\n    /// @notice  Returns the name of the token.\\n    string public name; // TODO: use `constant` for mainnet\\n\\n    /// @notice  Returns the symbol of the token.\\n    string public symbol; // TODO: use `constant` for mainnet\\n\\n    /// @notice  Returns the number of decimals the token uses.\\n    uint8 immutable public decimals; // TODO: use `constant` (18) for mainnet\\n\\n    // CONSTRUCTOR\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        address _custodian\\n    )\\n        ERC20ImplUpgradeable(_custodian)\\n    {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n    // (ERC20Interface)\\n    /** @notice  Returns the total token supply.\\n      *\\n      * @return  the total token supply.\\n      */\\n    function totalSupply() external override view returns (uint256) {\\n        return erc20Impl.totalSupply();\\n    }\\n\\n    /** @notice  Returns the account balance of another account with address\\n      * `_owner`.\\n      *\\n      * @return  balance  the balance of account with address `_owner`.\\n      */\\n    function balanceOf(address _owner) external override view returns (uint256 balance) {\\n        return erc20Impl.balanceOf(_owner);\\n    }\\n\\n    /** @dev Internal use only.\\n      */\\n    function emitTransfer(address _from, address _to, uint256 _value) external onlyImpl {\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /** @notice  Transfers `_value` amount of tokens to address `_to`.\\n      *\\n      * @dev Will fire the `Transfer` event. Will revert if the `_from`\\n      * account balance does not have enough tokens to spend.\\n      *\\n      * @return  success  true if transfer completes.\\n      */\\n    function transfer(address _to, uint256 _value) external override returns (bool success) {\\n        return erc20Impl.transferWithSender(msg.sender, _to, _value);\\n    }\\n\\n    /** @notice  Transfers `_value` amount of tokens from address `_from`\\n      * to address `_to`.\\n      *\\n      * @dev  Will fire the `Transfer` event. Will revert unless the `_from`\\n      * account has deliberately authorized the sender of the message\\n      * via some mechanism.\\n      *\\n      * @return  success  true if transfer completes.\\n      */\\n    function transferFrom(address _from, address _to, uint256 _value) external override returns (bool success) {\\n        return erc20Impl.transferFromWithSender(msg.sender, _from, _to, _value);\\n    }\\n\\n    /** @dev Internal use only.\\n      */\\n    function emitApproval(address _owner, address _spender, uint256 _value) external onlyImpl {\\n        emit Approval(_owner, _spender, _value);\\n    }\\n\\n    /** @notice  Allows `_spender` to withdraw from your account multiple times,\\n      * up to the `_value` amount. If this function is called again it\\n      * overwrites the current allowance with _value.\\n      *\\n      * @dev  Will fire the `Approval` event.\\n      *\\n      * @return  success  true if approval completes.\\n      */\\n    function approve(address _spender, uint256 _value) external override returns (bool success) {\\n        return erc20Impl.approveWithSender(msg.sender, _spender, _value);\\n    }\\n\\n    /** @notice Increases the amount `_spender` is allowed to withdraw from\\n      * your account.\\n      * This function is implemented to avoid the race condition in standard\\n      * ERC20 contracts surrounding the `approve` method.\\n      *\\n      * @dev  Will fire the `Approval` event. This function should be used instead of\\n      * `approve`.\\n      *\\n      * @return  success  true if approval completes.\\n      */\\n    function increaseApproval(address _spender, uint256 _addedValue) external returns (bool success) {\\n        return erc20Impl.increaseApprovalWithSender(msg.sender, _spender, _addedValue);\\n    }\\n\\n    /** @notice  Decreases the amount `_spender` is allowed to withdraw from\\n      * your account. This function is implemented to avoid the race\\n      * condition in standard ERC20 contracts surrounding the `approve` method.\\n      *\\n      * @dev  Will fire the `Approval` event. This function should be used\\n      * instead of `approve`.\\n      *\\n      * @return  success  true if approval completes.\\n      */\\n    function decreaseApproval(address _spender, uint256 _subtractedValue) external returns (bool success) {\\n        return erc20Impl.decreaseApprovalWithSender(msg.sender, _spender, _subtractedValue);\\n    }\\n\\n    /** @notice  Returns how much `_spender` is currently allowed to spend from\\n      * `_owner`'s balance.\\n      *\\n      * @return  remaining  the remaining allowance.\\n      */\\n    function allowance(address _owner, address _spender) external override view returns (uint256 remaining) {\\n        return erc20Impl.allowance(_owner, _spender);\\n    }\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\\n      erc20Impl.permit(owner, spender, value, deadline, v, r, s);\\n    }\\n    function nonces(address owner) external override view returns (uint256) {\\n      return erc20Impl.nonces(owner);\\n    }\\n    function DOMAIN_SEPARATOR() external override view returns (bytes32) {\\n      return erc20Impl.DOMAIN_SEPARATOR();\\n    }\\n\\n    function executeCallWithData(address contractAddress, bytes calldata callData) external {\\n        address implAddr = address(erc20Impl);\\n        require(msg.sender == implAddr, \\\"unauthorized\\\");\\n        require(contractAddress != implAddr, \\\"disallowed\\\");\\n\\n        (bool success, bytes memory returnData) = contractAddress.call(callData);\\n        if (success) {\\n            emit CallWithDataSuccess(contractAddress, callData, returnData);\\n        } else {\\n            emit CallWithDataFailure(contractAddress, callData, returnData);\\n        }\\n    }\\n\\n    event CallWithDataSuccess(address contractAddress, bytes callData, bytes returnData);\\n    event CallWithDataFailure(address contractAddress, bytes callData, bytes returnData);\\n}\\n\"\r\n    },\r\n    \"./contracts/EIP2612Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Adapted from\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ceb7324657ed4e73df6cb6f853c60c8d3fb3a0e9/contracts/drafts/IERC20Permit.sol\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface EIP2612Interface {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"./contracts/ERC20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\ninterface ERC20Interface {\\n  // METHODS\\n\\n  // NOTE:\\n  //   public getter functions are not currently recognised as an\\n  //   implementation of the matching abstract function by the compiler.\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#name\\n  // function name() public view returns (string);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#symbol\\n  // function symbol() public view returns (string);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#totalsupply\\n  // function decimals() public view returns (uint8);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#totalsupply\\n  function totalSupply() external view returns (uint256);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#balanceof\\n  function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer\\n  function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transferfrom\\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\\n  function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#allowance\\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n  // EVENTS\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approval\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\"\r\n    },\r\n    \"./contracts/ERC20ImplUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CustodianUpgradeable.sol\\\";\\nimport \\\"./ERC20Impl.sol\\\";\\n\\n/** @title  A contract to inherit upgradeable token implementations.\\n  *\\n  * @notice  A contract that provides re-usable code for upgradeable\\n  * token implementations. It itself inherits from `CustodianUpgradable`\\n  * as the upgrade process is controlled by the custodian.\\n  *\\n  * @dev  This contract is intended to be inherited by any contract\\n  * requiring a reference to the active token implementation, either\\n  * to delegate calls to it, or authorize calls from it. This contract\\n  * provides the mechanism for that implementation to be be replaced,\\n  * which constitutes an implementation upgrade.\\n  *\\n  * @author Gemini Trust Company, LLC\\n  */\\nabstract contract ERC20ImplUpgradeable is CustodianUpgradeable {\\n\\n    // TYPES\\n    /// @dev  The struct type for pending implementation changes.\\n    struct ImplChangeRequest {\\n        address proposedNew;\\n    }\\n\\n    // MEMBERS\\n    // @dev  The reference to the active token implementation.\\n    ERC20Impl public erc20Impl;\\n\\n    /// @dev  The map of lock ids to pending implementation changes.\\n    mapping (bytes32 => ImplChangeRequest) public implChangeReqs;\\n\\n    // CONSTRUCTOR\\n    constructor(address _custodian) CustodianUpgradeable(_custodian) {\\n        erc20Impl = ERC20Impl(0x0);\\n    }\\n\\n    // MODIFIERS\\n    modifier onlyImpl {\\n        require(msg.sender == address(erc20Impl), \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n    // (UPGRADE)\\n    /** @notice  Requests a change of the active implementation associated\\n      * with this contract.\\n      *\\n      * @dev  Returns a unique lock id associated with the request.\\n      * Anyone can call this function, but confirming the request is authorized\\n      * by the custodian.\\n      *\\n      * @param  _proposedImpl  The address of the new active implementation.\\n      * @return  lockId  A unique identifier for this request.\\n      */\\n    function requestImplChange(address _proposedImpl) external returns (bytes32 lockId) {\\n        require(_proposedImpl != address(0), \\\"zero address\\\");\\n\\n        (bytes32 preLockId, uint256 lockRequestIdx) = generatePreLockId();\\n        lockId = keccak256(\\n            abi.encodePacked(\\n                preLockId,\\n                this.requestImplChange.selector,\\n                _proposedImpl\\n            )\\n        );\\n\\n        implChangeReqs[lockId] = ImplChangeRequest({\\n            proposedNew: _proposedImpl\\n        });\\n\\n        emit ImplChangeRequested(lockId, msg.sender, _proposedImpl, lockRequestIdx);\\n    }\\n\\n    /** @notice  Confirms a pending change of the active implementation\\n      * associated with this contract.\\n      *\\n      * @dev  When called by the custodian with a lock id associated with a\\n      * pending change, the `ERC20Impl erc20Impl` member will be updated\\n      * with the requested address.\\n      *\\n      * @param  _lockId  The identifier of a pending change request.\\n      */\\n    function confirmImplChange(bytes32 _lockId) external onlyCustodian {\\n        erc20Impl = getImplChangeReq(_lockId);\\n\\n        delete implChangeReqs[_lockId];\\n\\n        emit ImplChangeConfirmed(_lockId, address(erc20Impl));\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n    function getImplChangeReq(bytes32 _lockId) private view returns (ERC20Impl _proposedNew) {\\n        ImplChangeRequest storage changeRequest = implChangeReqs[_lockId];\\n\\n        // reject ‘null’ results from the map lookup\\n        // this can only be the case if an unknown `_lockId` is received\\n        require(changeRequest.proposedNew != address(0), \\\"no such lockId\\\");\\n\\n        return ERC20Impl(changeRequest.proposedNew);\\n    }\\n\\n    /// @dev  Emitted by successful `requestImplChange` calls.\\n    event ImplChangeRequested(\\n        bytes32 _lockId,\\n        address _msgSender,\\n        address _proposedImpl,\\n        uint256 _lockRequestIdx\\n    );\\n\\n    /// @dev Emitted by successful `confirmImplChange` calls.\\n    event ImplChangeConfirmed(bytes32 _lockId, address _newImpl);\\n}\\n\"\r\n    },\r\n    \"./contracts/ERC20Store.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20ImplUpgradeable.sol\\\";\\n\\n/** @title  ERC20 compliant token balance store.\\n  *\\n  * @notice  This contract serves as the store of balances, allowances, and\\n  * supply for the ERC20 compliant token. No business logic exists here.\\n  *\\n  * @dev  This contract contains no business logic and instead\\n  * is the final destination for any change in balances, allowances, or token\\n  * supply. This contract is upgradeable in the sense that its custodian can\\n  * update the `erc20Impl` address, thus redirecting the source of logic that\\n  * determines how the balances will be updated.\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\ncontract ERC20Store is ERC20ImplUpgradeable {\\n\\n    // MEMBERS\\n    /// @dev  The total token supply.\\n    uint256 public totalSupply;\\n\\n    /// @dev  The mapping of balances.\\n    mapping (address => uint256) public balances;\\n\\n    /// @dev  The mapping of allowances.\\n    mapping (address => mapping (address => uint256)) public allowed;\\n\\n    mapping (address => uint256) public nonces;\\n\\n    // CONSTRUCTOR\\n    constructor(address _custodian) ERC20ImplUpgradeable(_custodian) {\\n        totalSupply = 0;\\n    }\\n\\n\\n    // PUBLIC FUNCTIONS\\n    // (ERC20 Ledger)\\n\\n    /** @notice  Sets how much `_owner` allows `_spender` to transfer on behalf\\n      * of `_owner`.\\n      *\\n      * @dev  Intended for use by token implementation functions\\n      * that update spending allowances. The only authorized caller\\n      * is the active implementation.\\n      *\\n      * @param  _owner  The account that will allow an on-behalf-of spend.\\n      * @param  _spender  The account that will spend on behalf of the owner.\\n      * @param  _value  The limit of what can be spent.\\n      */\\n    function setAllowance(\\n        address _owner,\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        onlyImpl\\n    {\\n        allowed[_owner][_spender] = _value;\\n    }\\n\\n    /** @notice  Sets the balance of `_owner` to `_newBalance`.\\n      *\\n      * @dev  Intended for use by token implementation functions\\n      * that update balances. The only authorized caller\\n      * is the active implementation.\\n      *\\n      * @param  _owner  The account that will hold a new balance.\\n      * @param  _newBalance  The balance to set.\\n      */\\n    function setBalance(\\n        address _owner,\\n        uint256 _newBalance\\n    )\\n        external\\n        onlyImpl\\n    {\\n        balances[_owner] = _newBalance;\\n    }\\n\\n    /** @notice Adds `_balanceIncrease` to `_owner`'s balance.\\n      *\\n      * @dev  Intended for use by token implementation functions\\n      * that update balances. The only authorized caller\\n      * is the active implementation.\\n      * WARNING: the caller is responsible for preventing overflow.\\n      *\\n      * @param  _owner  The account that will hold a new balance.\\n      * @param  _balanceIncrease  The balance to add.\\n      */\\n    function addBalance(\\n        address _owner,\\n        uint256 _balanceIncrease\\n    )\\n        external\\n        onlyImpl\\n    {\\n        balances[_owner] = balances[_owner] + _balanceIncrease;\\n    }\\n\\n    function setTotalSupplyAndAddBalance(\\n        uint256 _newTotalSupply,\\n        address _owner,\\n        uint256 _balanceIncrease\\n    )\\n        external\\n        onlyImpl\\n    {\\n        totalSupply = _newTotalSupply;\\n        balances[_owner] = balances[_owner] + _balanceIncrease;\\n    }\\n\\n    function setBalanceAndDecreaseTotalSupply(\\n        address _owner,\\n        uint256 _newBalance,\\n        uint256 _supplyDecrease\\n    )\\n        external\\n        onlyImpl\\n    {\\n        balances[_owner] = _newBalance;\\n        totalSupply = totalSupply - _supplyDecrease;\\n    }\\n\\n    function setBalanceAndAddBalance(\\n        address _ownerToSet,\\n        uint256 _newBalance,\\n        address _ownerToAdd,\\n        uint256 _balanceIncrease\\n    )\\n        external\\n        onlyImpl\\n    {\\n        balances[_ownerToSet] = _newBalance;\\n        balances[_ownerToAdd] = balances[_ownerToAdd] + _balanceIncrease;\\n    }\\n\\n    function setBalanceAndAllowanceAndAddBalance(\\n        address _ownerToSet,\\n        uint256 _newBalance,\\n        address _spenderToSet,\\n        uint256 _newAllowance,\\n        address _ownerToAdd,\\n        uint256 _balanceIncrease\\n    )\\n        external\\n        onlyImpl\\n    {\\n        balances[_ownerToSet] = _newBalance;\\n        allowed[_ownerToSet][_spenderToSet] = _newAllowance;\\n        balances[_ownerToAdd] = balances[_ownerToAdd] + _balanceIncrease;\\n    }\\n\\n    function balanceAndAllowed(\\n        address _owner,\\n        address _spender\\n    )\\n        external\\n        view\\n        returns (uint256 ownerBalance, uint256 spenderAllowance)\\n    {\\n        ownerBalance = balances[_owner];\\n        spenderAllowance = allowed[_owner][_spender];\\n    }\\n\\n    function getNonceAndIncrement(\\n        address _owner\\n    )\\n        external\\n        onlyImpl\\n        returns (uint256 current)\\n    {\\n        current = nonces[_owner];\\n        nonces[_owner] = current + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/Initializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20Proxy.sol\\\";\\nimport \\\"./ERC20Impl.sol\\\";\\nimport \\\"./ERC20Store.sol\\\";\\n\\ncontract Initializer {\\n\\n  function initialize(\\n      ERC20Store _store,\\n      ERC20Proxy _proxy,\\n      ERC20Impl _impl,\\n      address _implChangeCustodian,\\n      address _printCustodian) external {\\n\\n    // set impl as active implementation for store and proxy\\n    _store.confirmImplChange(_store.requestImplChange(address(_impl)));\\n    _proxy.confirmImplChange(_proxy.requestImplChange(address(_impl)));\\n\\n    // pass custodianship of store and proxy to impl change custodian\\n    _store.confirmCustodianChange(_store.requestCustodianChange(_implChangeCustodian));\\n    _proxy.confirmCustodianChange(_proxy.requestCustodianChange(_implChangeCustodian));\\n\\n    // pass custodianship of impl to print custodian\\n    _impl.confirmCustodianChange(_impl.requestCustodianChange(_printCustodian));\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"./contracts/ERC20ImplPaused.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2020 Gemini Trust Company LLC. All Rights Reserved\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC20Store.sol\\\";\\n\\n/** @title  ERC20 compliant token intermediary contract holding core logic.\\n  *\\n  * @notice  This contract serves as an intermediary between the exposed ERC20\\n  * interface in ERC20Proxy and the store of balances in ERC20Store. This\\n  * contract contains core logic that the proxy can delegate to\\n  * and that the store is called by.\\n  *\\n  * @dev  This version of ERC20Impl is intended to revert all ERC20 functions\\n  * that are state mutating; only view functions remain operational. Upgrading\\n  * to this contract places the system into a read-only paused state.\\n  *\\n  * @author  Gemini Trust Company, LLC\\n  */\\ncontract ERC20ImplPaused {\\n\\n    // MEMBERS\\n\\n    /// @dev  The reference to the store.\\n    ERC20Store immutable public erc20Store;\\n\\n    // CONSTRUCTOR\\n    constructor(\\n          address _erc20Store\\n    )\\n    {\\n        erc20Store = ERC20Store(_erc20Store);\\n    }\\n\\n    // METHODS (ERC20 sub interface impl.)\\n    /// @notice  Core logic of the ERC20 `totalSupply` function.\\n    function totalSupply() external view returns (uint256) {\\n        return erc20Store.totalSupply();\\n    }\\n\\n    /// @notice  Core logic of the ERC20 `balanceOf` function.\\n    function balanceOf(address _owner) external view returns (uint256 balance) {\\n        return erc20Store.balances(_owner);\\n    }\\n\\n    /// @notice  Core logic of the ERC20 `allowance` function.\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\\n        return erc20Store.allowed(_owner, _spender);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_custodian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"CallWithDataFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"CallWithDataSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newCustodian\",\"type\":\"address\"}],\"name\":\"CustodianChangeConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_proposedCustodian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockRequestIdx\",\"type\":\"uint256\"}],\"name\":\"CustodianChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newImpl\",\"type\":\"address\"}],\"name\":\"ImplChangeConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_proposedImpl\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockRequestIdx\",\"type\":\"uint256\"}],\"name\":\"ImplChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"confirmCustodianChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"confirmImplChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"custodian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"custodianChangeReqs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposedNew\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"emitApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"emitTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20Impl\",\"outputs\":[{\"internalType\":\"contract ERC20Impl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"executeCallWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"implChangeReqs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposedNew\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockRequestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposedCustodian\",\"type\":\"address\"}],\"name\":\"requestCustodianChange\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"lockId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposedImpl\",\"type\":\"address\"}],\"name\":\"requestImplChange\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"lockId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20Proxy","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000120000000000000000000000001890bd6bb07bee625e3a2cc6ee3d83850da55c090000000000000000000000000000000000000000000000000000000000000019457468657265756d20577261707065642046696c65636f696e0000000000000000000000000000000000000000000000000000000000000000000000000000046546494c00000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://30b64a0e5ec6b3b880d8cf538043b2ee039773ec7b90b5d3363beb4a2e640f1a"}]}