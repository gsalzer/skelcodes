{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"TornadoTrees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./ENS.sol\\\";\\r\\nimport \\\"./OwnableMerkleTree.sol\\\";\\r\\nimport \\\"./ITornadoTrees.sol\\\";\\r\\nimport \\\"./IHasher.sol\\\";\\r\\n\\r\\ncontract TornadoTrees is ITornadoTrees, EnsResolve {\\r\\n  OwnableMerkleTree public immutable depositTree;\\r\\n  OwnableMerkleTree public immutable withdrawalTree;\\r\\n  IHasher public immutable hasher;\\r\\n  address public immutable tornadoProxy;\\r\\n\\r\\n  bytes32[] public deposits;\\r\\n  uint256 public lastProcessedDepositLeaf;\\r\\n\\r\\n  bytes32[] public withdrawals;\\r\\n  uint256 public lastProcessedWithdrawalLeaf;\\r\\n\\r\\n  event DepositData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\\r\\n  event WithdrawalData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\\r\\n\\r\\n  struct TreeLeaf {\\r\\n    address instance;\\r\\n    bytes32 hash;\\r\\n    uint256 block;\\r\\n  }\\r\\n\\r\\n  modifier onlyTornadoProxy {\\r\\n    require(msg.sender == tornadoProxy, \\\"Not authorized\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor(\\r\\n    bytes32 _tornadoProxy,\\r\\n    bytes32 _hasher2,\\r\\n    bytes32 _hasher3,\\r\\n    uint32 _levels\\r\\n  ) public {\\r\\n    tornadoProxy = resolve(_tornadoProxy);\\r\\n    hasher = IHasher(resolve(_hasher3));\\r\\n    depositTree = new OwnableMerkleTree(_levels, IHasher(resolve(_hasher2)));\\r\\n    withdrawalTree = new OwnableMerkleTree(_levels, IHasher(resolve(_hasher2)));\\r\\n  }\\r\\n\\r\\n  function registerDeposit(address _instance, bytes32 _commitment) external override onlyTornadoProxy {\\r\\n    deposits.push(keccak256(abi.encode(_instance, _commitment, blockNumber())));\\r\\n  }\\r\\n\\r\\n  function registerWithdrawal(address _instance, bytes32 _nullifier) external override onlyTornadoProxy {\\r\\n    withdrawals.push(keccak256(abi.encode(_instance, _nullifier, blockNumber())));\\r\\n  }\\r\\n\\r\\n  function updateRoots(TreeLeaf[] calldata _deposits, TreeLeaf[] calldata _withdrawals) external {\\r\\n    if (_deposits.length > 0) updateDepositTree(_deposits);\\r\\n    if (_withdrawals.length > 0) updateWithdrawalTree(_withdrawals);\\r\\n  }\\r\\n\\r\\n  function updateDepositTree(TreeLeaf[] calldata _deposits) public {\\r\\n    bytes32[] memory leaves = new bytes32[](_deposits.length);\\r\\n    uint256 offset = lastProcessedDepositLeaf;\\r\\n\\r\\n    for (uint256 i = 0; i < _deposits.length; i++) {\\r\\n      TreeLeaf memory deposit = _deposits[i];\\r\\n      bytes32 leafHash = keccak256(abi.encode(deposit.instance, deposit.hash, deposit.block));\\r\\n      require(deposits[offset + i] == leafHash, \\\"Incorrect deposit\\\");\\r\\n\\r\\n      leaves[i] = hasher.poseidon([bytes32(uint256(deposit.instance)), deposit.hash, bytes32(deposit.block)]);\\r\\n      delete deposits[offset + i];\\r\\n\\r\\n      emit DepositData(deposit.instance, deposit.hash, deposit.block, offset + i);\\r\\n    }\\r\\n\\r\\n    lastProcessedDepositLeaf = offset + _deposits.length;\\r\\n    depositTree.bulkInsert(leaves);\\r\\n  }\\r\\n\\r\\n  function updateWithdrawalTree(TreeLeaf[] calldata _withdrawals) public {\\r\\n    bytes32[] memory leaves = new bytes32[](_withdrawals.length);\\r\\n    uint256 offset = lastProcessedWithdrawalLeaf;\\r\\n\\r\\n    for (uint256 i = 0; i < _withdrawals.length; i++) {\\r\\n      TreeLeaf memory withdrawal = _withdrawals[i];\\r\\n      bytes32 leafHash = keccak256(abi.encode(withdrawal.instance, withdrawal.hash, withdrawal.block));\\r\\n      require(withdrawals[offset + i] == leafHash, \\\"Incorrect withdrawal\\\");\\r\\n\\r\\n      leaves[i] = hasher.poseidon([bytes32(uint256(withdrawal.instance)), withdrawal.hash, bytes32(withdrawal.block)]);\\r\\n      delete withdrawals[offset + i];\\r\\n\\r\\n      emit WithdrawalData(withdrawal.instance, withdrawal.hash, withdrawal.block, offset + i);\\r\\n    }\\r\\n\\r\\n    lastProcessedWithdrawalLeaf = offset + _withdrawals.length;\\r\\n    withdrawalTree.bulkInsert(leaves);\\r\\n  }\\r\\n\\r\\n  function validateRoots(bytes32 _depositRoot, bytes32 _withdrawalRoot) public view {\\r\\n    require(depositTree.isKnownRoot(_depositRoot), \\\"Incorrect deposit tree root\\\");\\r\\n    require(withdrawalTree.isKnownRoot(_withdrawalRoot), \\\"Incorrect withdrawal tree root\\\");\\r\\n  }\\r\\n\\r\\n  function depositRoot() external view returns (bytes32) {\\r\\n    return depositTree.getLastRoot();\\r\\n  }\\r\\n\\r\\n  function withdrawalRoot() external view returns (bytes32) {\\r\\n    return withdrawalTree.getLastRoot();\\r\\n  }\\r\\n\\r\\n  function getRegisteredDeposits() external view returns (bytes32[] memory _deposits) {\\r\\n    uint256 count = deposits.length - lastProcessedDepositLeaf;\\r\\n    _deposits = new bytes32[](count);\\r\\n    for (uint256 i = 0; i < count; i++) {\\r\\n      _deposits[i] = deposits[lastProcessedDepositLeaf + i];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getRegisteredWithdrawals() external view returns (bytes32[] memory _withdrawals) {\\r\\n    uint256 count = withdrawals.length - lastProcessedWithdrawalLeaf;\\r\\n    _withdrawals = new bytes32[](count);\\r\\n    for (uint256 i = 0; i < count; i++) {\\r\\n      _withdrawals[i] = withdrawals[lastProcessedWithdrawalLeaf + i];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function blockNumber() public view virtual returns (uint256) {\\r\\n    return block.number;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"OwnableMerkleTree.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./MerkleTreeWithHistory.sol\\\";\\r\\n\\r\\ncontract OwnableMerkleTree is Ownable, MerkleTreeWithHistory {\\r\\n  constructor(uint32 _treeLevels, IHasher _hasher) public MerkleTreeWithHistory(_treeLevels, _hasher) {}\\r\\n\\r\\n  function insert(bytes32 _leaf) external onlyOwner returns (uint32 index) {\\r\\n    return _insert(_leaf);\\r\\n  }\\r\\n\\r\\n  function bulkInsert(bytes32[] calldata _leaves) external onlyOwner {\\r\\n    _bulkInsert(_leaves);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"MerkleTreeWithHistory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\nimport \\\"./IHasher.sol\\\";\\r\\n\\r\\ncontract MerkleTreeWithHistory {\\r\\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\r\\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\\\"tornado\\\") % FIELD_SIZE\\r\\n\\r\\n  uint32 public immutable levels;\\r\\n  IHasher public hasher; // todo immutable\\r\\n\\r\\n  bytes32[] public filledSubtrees;\\r\\n  bytes32[] public zeros;\\r\\n  uint32 public currentRootIndex = 0;\\r\\n  uint32 public nextIndex = 0;\\r\\n  uint32 public constant ROOT_HISTORY_SIZE = 10;\\r\\n  bytes32[ROOT_HISTORY_SIZE] public roots;\\r\\n\\r\\n  constructor(uint32 _treeLevels, IHasher _hasher) public {\\r\\n    require(_treeLevels > 0, \\\"_treeLevels should be greater than zero\\\");\\r\\n    require(_treeLevels < 32, \\\"_treeLevels should be less than 32\\\");\\r\\n    levels = _treeLevels;\\r\\n    hasher = _hasher;\\r\\n\\r\\n    bytes32 currentZero = bytes32(ZERO_VALUE);\\r\\n    zeros.push(currentZero);\\r\\n    filledSubtrees.push(currentZero);\\r\\n\\r\\n    for (uint32 i = 1; i < _treeLevels; i++) {\\r\\n      currentZero = hashLeftRight(currentZero, currentZero);\\r\\n      zeros.push(currentZero);\\r\\n      filledSubtrees.push(currentZero);\\r\\n    }\\r\\n\\r\\n    filledSubtrees.push(hashLeftRight(currentZero, currentZero));\\r\\n    roots[0] = filledSubtrees[_treeLevels];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    @dev Hash 2 tree leaves, returns poseidon(_left, _right)\\r\\n  */\\r\\n  function hashLeftRight(bytes32 _left, bytes32 _right) public view returns (bytes32) {\\r\\n    return hasher.poseidon([_left, _right]);\\r\\n  }\\r\\n\\r\\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\\r\\n    uint32 currentIndex = nextIndex;\\r\\n    require(currentIndex != uint32(2)**levels, \\\"Merkle tree is full. No more leaves can be added\\\");\\r\\n    nextIndex = currentIndex + 1;\\r\\n    bytes32 currentLevelHash = _leaf;\\r\\n    bytes32 left;\\r\\n    bytes32 right;\\r\\n\\r\\n    for (uint32 i = 0; i < levels; i++) {\\r\\n      if (currentIndex % 2 == 0) {\\r\\n        left = currentLevelHash;\\r\\n        right = zeros[i];\\r\\n        filledSubtrees[i] = currentLevelHash;\\r\\n      } else {\\r\\n        left = filledSubtrees[i];\\r\\n        right = currentLevelHash;\\r\\n      }\\r\\n\\r\\n      currentLevelHash = hashLeftRight(left, right);\\r\\n      currentIndex /= 2;\\r\\n    }\\r\\n\\r\\n    currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\\r\\n    roots[currentRootIndex] = currentLevelHash;\\r\\n    return nextIndex - 1;\\r\\n  }\\r\\n\\r\\n  function _bulkInsert(bytes32[] memory _leaves) internal {\\r\\n    uint32 insertIndex = nextIndex;\\r\\n    require(insertIndex + _leaves.length <= uint32(2)**levels, \\\"Merkle doesn't have enough capacity to add specified leaves\\\");\\r\\n\\r\\n    bytes32[] memory subtrees = new bytes32[](levels);\\r\\n    bool[] memory modifiedSubtrees = new bool[](levels);\\r\\n    for (uint32 j = 0; j < _leaves.length - 1; j++) {\\r\\n      uint256 index = insertIndex + j;\\r\\n      bytes32 currentLevelHash = _leaves[j];\\r\\n\\r\\n      for (uint32 i = 0; ; i++) {\\r\\n        if (index % 2 == 0) {\\r\\n          modifiedSubtrees[i] = true;\\r\\n          subtrees[i] = currentLevelHash;\\r\\n          break;\\r\\n        }\\r\\n\\r\\n        if (subtrees[i] == bytes32(0)) {\\r\\n          subtrees[i] = filledSubtrees[i];\\r\\n        }\\r\\n        currentLevelHash = hashLeftRight(subtrees[i], currentLevelHash);\\r\\n        index /= 2;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    for (uint32 i = 0; i < levels; i++) {\\r\\n      // using local map to save on gas on writes if elements were not modified\\r\\n      if (modifiedSubtrees[i]) {\\r\\n        filledSubtrees[i] = subtrees[i];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    nextIndex = uint32(insertIndex + _leaves.length - 1);\\r\\n    _insert(_leaves[_leaves.length - 1]);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    @dev Whether the root is present in the root history\\r\\n  */\\r\\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\\r\\n    if (_root == 0) {\\r\\n      return false;\\r\\n    }\\r\\n    uint32 i = currentRootIndex;\\r\\n    do {\\r\\n      if (_root == roots[i]) {\\r\\n        return true;\\r\\n      }\\r\\n      if (i == 0) {\\r\\n        i = ROOT_HISTORY_SIZE;\\r\\n      }\\r\\n      i--;\\r\\n    } while (i != currentRootIndex);\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    @dev Returns the last root\\r\\n  */\\r\\n  function getLastRoot() public view returns (bytes32) {\\r\\n    return roots[currentRootIndex];\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"ITornadoTrees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface ITornadoTrees {\\r\\n  function registerDeposit(address instance, bytes32 commitment) external;\\r\\n\\r\\n  function registerWithdrawal(address instance, bytes32 nullifier) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"IHasher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface IHasher {\\r\\n  function poseidon(bytes32[2] calldata inputs) external pure returns (bytes32);\\r\\n\\r\\n  function poseidon(bytes32[3] calldata inputs) external pure returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"ENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface ENS {\\r\\n  function resolver(bytes32 node) external view returns (Resolver);\\r\\n}\\r\\n\\r\\ninterface Resolver {\\r\\n  function addr(bytes32 node) external view returns (address);\\r\\n}\\r\\n\\r\\ncontract EnsResolve {\\r\\n  function resolve(bytes32 node) public view virtual returns (address) {\\r\\n    ENS Registry = ENS(\\r\\n      getChainId() == 1 ? 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e : 0x8595bFb0D940DfEDC98943FA8a907091203f25EE\\r\\n    );\\r\\n    return Registry.resolver(node).addr(node);\\r\\n  }\\r\\n\\r\\n  function bulkResolve(bytes32[] memory domains) public view returns (address[] memory result) {\\r\\n    result = new address[](domains.length);\\r\\n    for (uint256 i = 0; i < domains.length; i++) {\\r\\n      result[i] = resolve(domains[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getChainId() internal pure returns (uint256) {\\r\\n    uint256 chainId;\\r\\n    assembly {\\r\\n      chainId := chainid()\\r\\n    }\\r\\n    return chainId;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_tornadoProxy\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_hasher2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_hasher3\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_levels\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DepositData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"WithdrawalData\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"domains\",\"type\":\"bytes32[]\"}],\"name\":\"bulkResolve\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositTree\",\"outputs\":[{\"internalType\":\"contract OwnableMerkleTree\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredDeposits\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_deposits\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredWithdrawals\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_withdrawals\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasher\",\"outputs\":[{\"internalType\":\"contract IHasher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedDepositLeaf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedWithdrawalLeaf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"registerDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nullifier\",\"type\":\"bytes32\"}],\"name\":\"registerWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tornadoProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"internalType\":\"struct TornadoTrees.TreeLeaf[]\",\"name\":\"_deposits\",\"type\":\"tuple[]\"}],\"name\":\"updateDepositTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"internalType\":\"struct TornadoTrees.TreeLeaf[]\",\"name\":\"_deposits\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"internalType\":\"struct TornadoTrees.TreeLeaf[]\",\"name\":\"_withdrawals\",\"type\":\"tuple[]\"}],\"name\":\"updateRoots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"internalType\":\"struct TornadoTrees.TreeLeaf[]\",\"name\":\"_withdrawals\",\"type\":\"tuple[]\"}],\"name\":\"updateWithdrawalTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_depositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_withdrawalRoot\",\"type\":\"bytes32\"}],\"name\":\"validateRoots\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalTree\",\"outputs\":[{\"internalType\":\"contract OwnableMerkleTree\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TornadoTrees","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"c5218f28a24f5edf943eee83f1caf29303762bfa2807c222d35975b522e66e7a71cadf5505c665c54e3ccdd64387c0efedfca0667038b4ee45ae7bf86bf70c08be56438c8b3dc62ba90ba8498d77bebe835d8ab1db9a55378e5224783d5748650000000000000000000000000000000000000000000000000000000000000014","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d9b9dec9144ac2d263d83b6a7ab0164b3923ff87ea652a2cd0874b062feb0ace"}]}