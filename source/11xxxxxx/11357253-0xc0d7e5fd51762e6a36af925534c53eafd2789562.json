{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.10;\\n\\nimport {InterestRateModelInterface} from \\\"./RhoInterfaces.sol\\\";\\n\\ncontract InterestRateModel is InterestRateModelInterface {\\n\\n\\tuint public immutable yOffset;\\n\\tuint public immutable slopeFactor;\\n\\tuint public immutable rateFactorSensitivity;\\n\\tuint public immutable range;\\n\\tuint public immutable feeBase;\\n\\tuint public immutable feeSensitivity;\\n\\n\\tconstructor(\\n\\t\\tuint yOffset_,\\n\\t\\tuint slopeFactor_,\\n\\t\\tuint rateFactorSensitivity_,\\n\\t\\tuint feeBase_,\\n\\t\\tuint feeSensitivity_,\\n\\t\\tuint range_\\n\\t) public {\\n\\t\\trequire(slopeFactor_ > 0 && rateFactorSensitivity_ > 0 && range_ > 0 , \\\"Zero params not allowed\\\");\\n\\n\\t\\tyOffset = yOffset_;\\n\\t\\tslopeFactor = slopeFactor_;\\n\\t\\trateFactorSensitivity = rateFactorSensitivity_;\\n\\t\\tfeeBase = feeBase_;\\n\\t\\tfeeSensitivity = feeSensitivity_;\\n\\t\\trange = range_;\\n\\t}\\n\\n\\t/* @dev Calculates the per-block interest rate to offer an incoming swap based on the rateFactor stored in Rho.sol.\\n\\t * @param userPayingFixed : If the user is paying fixed in incoming swap\\n\\t * @param orderNotional : Notional order size of the incoming swap\\n\\t * @param lockedCollateralUnderlying : The amount of the protocol's liquidity that is locked at the time of the swap in underlying tokens\\n\\t * @param supplierLiquidityUnderlying : Total amount of the protocol's liquidity in underlying tokens\\n\\t */\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external override view returns (uint rate, int rateFactorNew) {\\n\\t\\trequire(supplierLiquidityUnderlying != 0, \\\"supplied liquidity 0\\\");\\n\\t\\tuint rfDelta = div(mul(rateFactorSensitivity, orderNotional), supplierLiquidityUnderlying);\\n\\t\\trateFactorNew = userPayingFixed ? add(rateFactorPrev, rfDelta) : sub(rateFactorPrev, rfDelta);\\n\\n\\t\\tint num = mul(rateFactorNew, range);\\n\\t\\tuint denom = sqrt(add(square(rateFactorNew), slopeFactor));\\n\\n\\t\\tuint baseRate = toZero(add(div(num, denom), yOffset)); // can not be negative\\n\\t\\tuint fee = getFee(lockedCollateralUnderlying, supplierLiquidityUnderlying);\\n\\n\\t\\t// base + yOffset +- fee\\n\\t\\tif (userPayingFixed) {\\n\\t\\t\\trate = add(baseRate, fee);\\n\\t\\t} else {\\n\\t\\t\\tif (baseRate > fee) {\\n\\t\\t\\t\\trate = sub(baseRate, fee);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trate = 0;\\n\\t\\t\\t\\t// if the rate is negative, don't push rate factor even lower\\n\\t\\t\\t\\trateFactorNew = rateFactorPrev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// @dev Calculates the fee to add to the rate. fee = feeBase + feeSensitivity * locked / total\\n\\tfunction getFee(uint lockedCollateralUnderlying, uint supplierLiquidityUnderlying) public view returns (uint) {\\n\\t\\treturn add(feeBase, div(mul(feeSensitivity, lockedCollateralUnderlying), supplierLiquidityUnderlying));\\n\\t}\\n\\n    // ** Interest Rate Model Math Library **//\\n\\n    // Source: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n\\t// ** UINT SAFE MATH ** //\\n\\t// Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\n\\n\\tfunction mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: Multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        require(b > 0, \\\"SafeMath: Divide by zero\\\");\\n        uint c = a / b;\\n        return c;\\n    }\\n\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint a, uint b) pure internal returns (uint) {\\n        require(b <= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n   \\t// ** INT SAFE MATH ** //\\n   \\t// Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SignedSafeMath.sol\\n\\tint constant private _INT_MIN = -2**255;\\n\\n    function div(int a, int b) internal pure returns (int) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int c = a / b;\\n\\n        return c;\\n    }\\n\\n    function mul(int a, int b) internal pure returns (int) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function add(int a, int b) internal pure returns (int) {\\n        int c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n   \\t// ** INT => UINT MATH ** //\\n\\n   \\t// Set negative ints to 0\\n    function toZero(int x) internal pure returns (uint) {\\n\\t\\treturn x > 0 ? uint(x) : 0;\\n\\t}\\n\\n\\tfunction square(int a) internal pure returns (uint) {\\n\\t\\treturn uint(mul(a, a));\\n\\t}\\n\\n\\t// ** UINT => INT MATH ** //\\n\\n\\tint constant private _INT_MAX = 2**255 - 1;\\n\\n    function add(int a, uint b) internal pure returns (int){\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int addition overflow detected\\\");\\n        return add(a, int(b));\\n    }\\n\\n\\tfunction mul(int a, uint b) internal pure returns (int) {\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int multiplication overflow detected\\\");\\n        return mul(a, int(b));\\n\\t}\\n\\n    function sub(int a, uint b) internal pure returns (int){\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int subtraction overflow detected\\\");\\n        return sub(a, int(b));\\n    }\\n\\n\\tfunction div(int a, uint b) internal pure returns (int) {\\n        require(b < uint(_INT_MAX), \\\"SafeMath: Int division overflow detected\\\");\\n        return div(a, int(b));\\n\\t}\\n\\n}\\n\",\r\n      \"keccak256\": \"0x3687e4d83502a5bb22609a621c023285c7a88fbde0317c3d2ad619352f013b09\"\r\n    },\r\n    \"contracts/RhoInterfaces.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface InterestRateModelInterface {\\n\\tfunction getSwapRate(\\n\\t\\tint rateFactorPrev,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint orderNotional,\\n\\t\\tuint lockedCollateralUnderlying,\\n\\t\\tuint supplierLiquidityUnderlying\\n\\t) external view returns (uint rate, int rateFactorNew);\\n}\\n\\ninterface ERC20Interface {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function balanceOf(address who) external returns (uint);\\n}\\n\\ninterface CompInterface is ERC20Interface{\\n\\tfunction delegate(address delegatee) external;\\n}\\n\\ninterface CTokenInterface is ERC20Interface {\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction accrualBlockNumber() external view returns(uint);\\n\\tfunction borrowRatePerBlock() external view returns(uint);\\n\\tfunction exchangeRateStored() external view returns (uint);\\n}\\n\\nabstract contract RhoInterface is Types {\\n\\tfunction supply(uint cTokenSupplyAmount) external virtual;\\n\\tfunction remove(uint removeCTokenAmount) external virtual;\\n\\tfunction openPayFixedSwap(uint notionalAmount, uint maximumFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction openReceiveFixedSwap(uint notionalAmount, uint minFixedRateMantissa) external virtual returns (bytes32 swapHash);\\n\\tfunction close(\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress owner\\n\\t) external virtual;\\n\\n\\tevent Supply(address indexed supplier, uint cTokenSupplyAmount, uint newSupplyAmount);\\n\\tevent Remove(address indexed supplier, uint removeCTokenAmount, uint newSupplyValue);\\n\\tevent OpenSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\tbool userPayingFixed,\\n\\t\\tuint benchmarkIndexInit,\\n\\t\\tuint initBlock,\\n\\t\\tuint swapFixedRateMantissa,\\n\\t\\tuint notionalAmount,\\n\\t\\tuint userCollateralCTokens,\\n\\t\\taddress indexed owner\\n\\t);\\n\\tevent CloseSwap(\\n\\t\\tbytes32 indexed swapHash,\\n\\t\\taddress indexed owner,\\n\\t\\tuint userPayout,\\n\\t\\tuint penalty,\\n\\t\\tuint benchmarkIndexFinal\\n\\t);\\n\\tevent Accrue(uint supplierLiquidityNew, uint lockedCollateralNew);\\n\\tevent SetInterestRateModel(address newModel, address oldModel);\\n\\tevent SetPause(bool isPaused);\\n\\tevent AdminRenounced();\\n\\tevent CompTransferred(address dest, uint amount);\\n\\tevent CompDelegated(address delegatee);\\n\\tevent SetCollateralRequirements(uint minFloatRateMantissa, uint maxFloatRateMantissa);\\n\\tevent AdminChanged(address oldAdmin, address newAdmin);\\n\\tevent SetLiquidityLimit(uint limit);\\n\\n\\tInterestRateModelInterface public interestRateModel;\\n\\n\\tuint public lastAccrualBlock;\\n\\tExp public benchmarkIndexStored;\\n\\n\\t/* Notional size of each leg, one adjusting for compounding and one static */\\n\\tuint public notionalReceivingFixed;\\n\\tuint public notionalPayingFloat;\\n\\n\\tuint public notionalPayingFixed;\\n\\tuint public notionalReceivingFloat;\\n\\n\\t/* Measure of outstanding swap obligations. 1 Unit = 1e18 notional * 1 block. Used to calculate collateral requirements */\\n\\tint public parBlocksReceivingFixed;\\n\\tint public parBlocksPayingFixed;\\n\\n\\t/* Per block fixed / float interest rates used in collateral calculations */\\n\\tExp public avgFixedRateReceiving;\\n\\tExp public avgFixedRatePaying;\\n\\n\\t/* Per block float rate bounds used in collateral calculations */\\n\\tExp public maxFloatRate;\\n\\tExp public minFloatRate;\\n\\n\\t/* Protocol PnL */\\n\\tuint public supplyIndex;\\n\\tCTokenAmount public supplierLiquidity;\\n\\n\\tint public rateFactor;// for interest rate model\\n\\n\\taddress public admin;\\n\\n\\t/* Pausing safety functions that can pause open and supply functions */\\n\\tbool public isPaused;\\n\\tCTokenAmount public liquidityLimit;\\n\\n\\tmapping(address => SupplyAccount) public supplyAccounts;\\n\\tmapping(bytes32 => bool) public swaps;\\n\\n\\tstruct SupplyAccount {\\n\\t\\tCTokenAmount amount;\\n\\t\\tuint lastBlock;\\n\\t\\tuint index;\\n\\t}\\n\\n\\tstruct Swap {\\n\\t\\tbool userPayingFixed;\\n\\t\\tuint notionalAmount;\\n\\t\\tuint swapFixedRateMantissa;\\n\\t\\tuint benchmarkIndexInit;\\n\\t\\tuint userCollateralCTokens;\\n\\t\\tuint initBlock;\\n\\t\\taddress owner;\\n\\t}\\n\\n}\\n\",\r\n      \"keccak256\": \"0xb5de435fab04d6ea7331a179997e5df99991e12b1eb651b48f66163aff0e44b5\"\r\n    },\r\n    \"contracts/Types.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.10;\\n\\ncontract Types {\\n\\n    /*@dev A type to store amounts of cTokens, to make sure they are not confused with amounts of the underlying */\\n    struct CTokenAmount {\\n        uint val;\\n    }\\n\\n    /* @dev A type to store numbers scaled up by 18 decimals*/\\n    struct Exp {\\n        uint mantissa;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x3420c97975694664fba3d84ac78149b669b452a2ac4aee8bab41e02407a494d5\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yOffset_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slopeFactor_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateFactorSensitivity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBase_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeSensitivity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"range_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"feeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSensitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"rateFactorPrev\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"userPayingFixed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"orderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplierLiquidityUnderlying\",\"type\":\"uint256\"}],\"name\":\"getSwapRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rateFactorNew\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateFactorSensitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slopeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InterestRateModel","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000046c7cfe000000000000000000000000000000000000604be73de4838ad9a5cf880000000000000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000000000000000000000000000000000003b9aca000000000000000000000000000000000000000000000000000000000059682f0000000000000000000000000000000000000000000000000000000005d21dba00","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}