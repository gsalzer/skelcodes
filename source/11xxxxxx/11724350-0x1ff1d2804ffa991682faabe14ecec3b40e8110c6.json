{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title Address\\n * @author Paul Razvan Berg\\n * @notice Collection of functions related to the address type.\\n * @dev Forked from OpenZeppelin\\n * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v3.1.0/contracts/utils/Address.sol\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`.\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n}\\n\"},\"Admin.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AdminInterface.sol\\\";\\n\\n/**\\n * @title Admin\\n * @author Paul Razvan Berg\\n * @notice Contract module which provides a basic access control mechanism, where there is\\n * an account (an admin) that can be granted exclusive access to specific functions.\\n *\\n * By default, the admin account will be the one that deploys the contract. This can later\\n * be changed with {transferAdmin}.\\n *\\n * This module is used through inheritance. It will make available the modifier `onlyAdmin`,\\n * which can be applied to your functions to restrict their use to the admin.\\n *\\n * @dev Forked from OpenZeppelin\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/access/Ownable.sol\\n */\\nabstract contract Admin is AdminInterface {\\n    /**\\n     * @notice Throws if called by any account other than the admin.\\n     */\\n    modifier onlyAdmin() {\\n        require(admin == msg.sender, \\\"ERR_NOT_ADMIN\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract setting the deployer as the initial admin.\\n     */\\n    constructor() {\\n        address msgSender = msg.sender;\\n        admin = msgSender;\\n        emit TransferAdmin(address(0x00), msgSender);\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without admin, so it will not be possible to call\\n     * `onlyAdmin` functions anymore.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the administrator.\\n     *\\n     * WARNING: Doing this will leave the contract without an admin,\\n     * thereby removing any functionality that is only available to the admin.\\n     */\\n    function _renounceAdmin() external virtual override onlyAdmin {\\n        emit TransferAdmin(admin, address(0x00));\\n        admin = address(0x00);\\n    }\\n\\n    /**\\n     * @notice Transfers the admin of the contract to a new account (`newAdmin`).\\n     * Can only be called by the current admin.\\n     * @param newAdmin The acount of the new admin.\\n     */\\n    function _transferAdmin(address newAdmin) external virtual override onlyAdmin {\\n        require(newAdmin != address(0x00), \\\"ERR_SET_ADMIN_ZERO_ADDRESS\\\");\\n        emit TransferAdmin(admin, newAdmin);\\n        admin = newAdmin;\\n    }\\n}\\n\"},\"AdminInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AdminStorage.sol\\\";\\n\\n/**\\n * @title AdminInterface\\n * @author Paul Razvan Berg\\n */\\nabstract contract AdminInterface is AdminStorage {\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function _renounceAdmin() external virtual;\\n\\n    function _transferAdmin(address newAdmin) external virtual;\\n\\n    /**\\n     * EVENTS\\n     */\\n    event TransferAdmin(address indexed oldAdmin, address indexed newAdmin);\\n}\\n\"},\"AdminStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nabstract contract AdminStorage {\\n    /**\\n     * @notice The address of the administrator account or contract.\\n     */\\n    address public admin;\\n}\\n\"},\"AggregatorV3Interface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title AggregatorV3Interface\\n * @author Hifi\\n * @dev Forked from Chainlink\\n * https://github.com/smartcontractkit/chainlink/blob/v0.9.9/evm-contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\\n */\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    /*\\n     * getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n     * if they do not have data to report, instead of returning unset values\\n     * which could be misinterpreted as actual reported values.\\n     */\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"},\"BalanceSheetInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalanceSheetStorage.sol\\\";\\n\\n/**\\n * @title BalanceSheetInterface\\n * @author Hifi\\n */\\nabstract contract BalanceSheetInterface is BalanceSheetStorage {\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address borrower)\\n        public\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getHypotheticalCollateralizationRatio(\\n        FyTokenInterface fyToken,\\n        address borrower,\\n        uint256 lockedCollateral,\\n        uint256 debt\\n    ) public view virtual returns (uint256);\\n\\n    function getVault(FyTokenInterface fyToken, address borrower)\\n        external\\n        view\\n        virtual\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool\\n        );\\n\\n    function getVaultDebt(FyTokenInterface fyToken, address borrower) external view virtual returns (uint256);\\n\\n    function getVaultLockedCollateral(FyTokenInterface fyToken, address borrower)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function isAccountUnderwater(FyTokenInterface fyToken, address borrower) external view virtual returns (bool);\\n\\n    function isVaultOpen(FyTokenInterface fyToken, address borrower) external view virtual returns (bool);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n\\n    function clutchCollateral(\\n        FyTokenInterface fyToken,\\n        address liquidator,\\n        address borrower,\\n        uint256 clutchedCollateralAmount\\n    ) external virtual returns (bool);\\n\\n    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    function openVault(FyTokenInterface fyToken) external virtual returns (bool);\\n\\n    function setVaultDebt(\\n        FyTokenInterface fyToken,\\n        address borrower,\\n        uint256 newVaultDebt\\n    ) external virtual returns (bool);\\n\\n    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n\\n    event ClutchCollateral(\\n        FyTokenInterface indexed fyToken,\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 clutchedCollateralAmount\\n    );\\n\\n    event DepositCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n\\n    event FreeCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n\\n    event LockCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n\\n    event OpenVault(FyTokenInterface indexed fyToken, address indexed borrower);\\n\\n    event SetVaultDebt(FyTokenInterface indexed fyToken, address indexed borrower, uint256 oldDebt, uint256 newDebt);\\n\\n    event WithdrawCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n}\\n\"},\"BalanceSheetStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./FyTokenInterface.sol\\\";\\n\\n/**\\n * @title BalanceSheetStorage\\n * @author Hifi\\n */\\nabstract contract BalanceSheetStorage {\\n    struct Vault {\\n        uint256 debt;\\n        uint256 freeCollateral;\\n        uint256 lockedCollateral;\\n        bool isOpen;\\n    }\\n\\n    /**\\n     * @notice The unique Fintroller associated with this contract.\\n     */\\n    FintrollerInterface public fintroller;\\n\\n    /**\\n     * @dev One vault for each fyToken for each account.\\n     */\\n    mapping(address =\\u003e mapping(address =\\u003e Vault)) internal vaults;\\n\\n    /**\\n     * @notice Indicator that this is a BalanceSheet contract, for inspection.\\n     */\\n    bool public constant isBalanceSheet = true;\\n}\\n\"},\"CarefulMath.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @notice Possible error codes that can be returned.\\n */\\nenum MathError { NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW, MODULO_BY_ZERO }\\n\\n/**\\n * @title CarefulMath\\n * @author Paul Razvan Berg\\n * @notice Exponential module for storing fixed-precision decimals.\\n * @dev Forked from Compound\\n * https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CarefulMath.sol\\n */\\nabstract contract CarefulMath {\\n    /**\\n     * @notice Adds two numbers, returns an error on overflow.\\n     */\\n    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        uint256 c = a + b;\\n\\n        if (c \\u003e= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add `a` and `b` and then subtract `c`.\\n     */\\n    function addThenSubUInt(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure returns (MathError, uint256) {\\n        (MathError err0, uint256 sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n\\n    /**\\n     * @notice Integer division of two numbers, truncating the quotient.\\n     */\\n    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n     * @notice Returns the remainder of dividing two numbers.\\n     * @dev Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     */\\n    function modUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b == 0) {\\n            return (MathError.MODULO_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a % b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers, returns an error on overflow.\\n     */\\n    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint256 c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n     * @notice Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b \\u003c= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n}\\n\"},\"ChainlinkOperatorInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./Erc20Interface.sol\\\";\\n\\nimport \\\"./ChainlinkOperatorStorage.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title ChainlinkOperatorInterface\\n * @author Hifi\\n */\\nabstract contract ChainlinkOperatorInterface is ChainlinkOperatorStorage {\\n    /**\\n     * EVENTS\\n     */\\n    event DeleteFeed(Erc20Interface indexed asset, AggregatorV3Interface indexed feed);\\n\\n    event SetFeed(Erc20Interface indexed asset, AggregatorV3Interface indexed feed);\\n\\n    /**\\n     * CONSTANT FUNCTIONS.\\n     */\\n    function getAdjustedPrice(string memory symbol) external view virtual returns (uint256);\\n\\n    function getFeed(string memory symbol)\\n        external\\n        view\\n        virtual\\n        returns (\\n            Erc20Interface,\\n            AggregatorV3Interface,\\n            bool\\n        );\\n\\n    function getPrice(string memory symbol) public view virtual returns (uint256);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS.\\n     */\\n    function deleteFeed(string memory symbol) external virtual returns (bool);\\n\\n    function setFeed(Erc20Interface asset, AggregatorV3Interface feed) external virtual returns (bool);\\n}\\n\"},\"ChainlinkOperatorStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\n\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title ChainlinkOperatorStorage\\n * @author Hifi\\n */\\nabstract contract ChainlinkOperatorStorage {\\n    struct Feed {\\n        Erc20Interface asset;\\n        AggregatorV3Interface id;\\n        bool isSet;\\n    }\\n\\n    /**\\n     * @dev Mapping between Erc20 symbols and Feed structs.\\n     */\\n    mapping(string =\\u003e Feed) internal feeds;\\n\\n    /**\\n     * @notice Chainlink price precision for USD-quoted data.\\n     */\\n    uint256 public constant pricePrecision = 8;\\n\\n    /**\\n     * @notice The ratio between mantissa precision (1e18) and the Chainlink price precision (1e8).\\n     */\\n    uint256 public constant pricePrecisionScalar = 1.0e10;\\n}\\n\"},\"Erc20.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./CarefulMath.sol\\\";\\n\\n/**\\n * @title Erc20\\n * @author Paul Razvan Berg\\n * @notice Implementation of the {Erc20Interface} interface.\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of Erc20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the Erc may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {Erc20Interface-approve}.\\n *\\n * @dev Forked from OpenZeppelin\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/token/Erc20/Erc20.sol\\n */\\ncontract Erc20 is\\n    CarefulMath, /* no dependency */\\n    Erc20Interface /* one dependency */\\n{\\n    /**\\n     * @notice All three of these values are immutable: they can only be set once during construction.\\n     * @param name_ Erc20 name of this token.\\n     * @param symbol_ Erc20 symbol of this token.\\n     * @param decimals_ Erc20 decimal precision of this token.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) {\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n    }\\n\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n\\n    /**\\n     * @notice Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\\n        return allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return balances[account];\\n    }\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n\\n    /**\\n     * @notice Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * @dev IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        approveInternal(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {Erc20Interface-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\n        MathError mathErr;\\n        uint256 newAllowance;\\n        (mathErr, newAllowance) = subUInt(allowances[msg.sender][spender], subtractedValue);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_DECREASE_ALLOWANCE_UNDERFLOW\\\");\\n        approveInternal(msg.sender, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described above.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\n        MathError mathErr;\\n        uint256 newAllowance;\\n        (mathErr, newAllowance) = addUInt(allowances[msg.sender][spender], addedValue);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_INCREASE_ALLOWANCE_OVERFLOW\\\");\\n        approveInternal(msg.sender, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * @dev Emits a {Transfer} event.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - The caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\\n        transferInternal(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice See Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * @dev Emits a {Transfer} event. Emits an {Approval} event indicating the\\n     * updated allowance. This is not required by the Erc. See the note at the\\n     * beginning of {Erc20};\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - The caller must have allowance for ``sender``\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external virtual override returns (bool) {\\n        transferInternal(sender, recipient, amount);\\n        MathError mathErr;\\n        uint256 newAllowance;\\n        (mathErr, newAllowance) = subUInt(allowances[sender][msg.sender], amount);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_TRANSFER_FROM_INSUFFICIENT_ALLOWANCE\\\");\\n        approveInternal(sender, msg.sender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * INTERNAL FUNCTIONS\\n     */\\n\\n    /**\\n     * @notice Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * @dev This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approveInternal(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0x00), \\\"ERR_ERC20_APPROVE_FROM_ZERO_ADDRESS\\\");\\n        require(spender != address(0x00), \\\"ERR_ERC20_APPROVE_TO_ZERO_ADDRESS\\\");\\n\\n        allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Destroys `burnAmount` tokens from `holder`, recuding the token supply.\\n     *\\n     * @dev Emits a {Burn} event.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `holder` must have at least `amount` tokens.\\n     */\\n    function burnInternal(address holder, uint256 burnAmount) internal {\\n        MathError mathErr;\\n        uint256 newHolderBalance;\\n        uint256 newTotalSupply;\\n\\n        /* Burn the yTokens. */\\n        (mathErr, newHolderBalance) = subUInt(balances[holder], burnAmount);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_BURN_BALANCE_UNDERFLOW\\\");\\n        balances[holder] = newHolderBalance;\\n\\n        /* Reduce the total supply. */\\n        (mathErr, newTotalSupply) = subUInt(totalSupply, burnAmount);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_BURN_TOTAL_SUPPLY_UNDERFLOW\\\");\\n        totalSupply = newTotalSupply;\\n\\n        emit Burn(holder, burnAmount);\\n    }\\n\\n    /** @notice Prints new tokens into existence and assigns them to `beneficiary`,\\n     * increasing the total supply.\\n     *\\n     * @dev Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - The beneficiary\\u0027s balance and the total supply cannot overflow.\\n     */\\n    function mintInternal(address beneficiary, uint256 mintAmount) internal {\\n        MathError mathErr;\\n        uint256 newBeneficiaryBalance;\\n        uint256 newTotalSupply;\\n\\n        /* Mint the yTokens. */\\n        (mathErr, newBeneficiaryBalance) = addUInt(balances[beneficiary], mintAmount);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_MINT_BALANCE_OVERFLOW\\\");\\n        balances[beneficiary] = newBeneficiaryBalance;\\n\\n        /* Increase the total supply. */\\n        (mathErr, newTotalSupply) = addUInt(totalSupply, mintAmount);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_MINT_TOTAL_SUPPLY_OVERFLOW\\\");\\n        totalSupply = newTotalSupply;\\n\\n        emit Mint(beneficiary, mintAmount);\\n    }\\n\\n    /**\\n     * @notice Moves `amount` tokens from `sender` to `recipient`.\\n     *\\n     * @dev This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function transferInternal(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0x00), \\\"ERR_ERC20_TRANSFER_FROM_ZERO_ADDRESS\\\");\\n        require(recipient != address(0x00), \\\"ERR_ERC20_TRANSFER_TO_ZERO_ADDRESS\\\");\\n\\n        MathError mathErr;\\n        uint256 newSenderBalance;\\n        uint256 newRecipientBalance;\\n\\n        (mathErr, newSenderBalance) = subUInt(balances[sender], amount);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_ERC20_TRANSFER_SENDER_BALANCE_UNDERFLOW\\\");\\n        balances[sender] = newSenderBalance;\\n\\n        (mathErr, newRecipientBalance) = addUInt(balances[recipient], amount);\\n        assert(mathErr == MathError.NO_ERROR);\\n        balances[recipient] = newRecipientBalance;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n}\\n\"},\"Erc20Interface.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Storage.sol\\\";\\n\\n/**\\n * @title Erc20Interface\\n * @author Paul Razvan Berg\\n * @notice Interface of the Erc20 standard\\n * @dev Forked from OpenZeppelin\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/token/ERC20/IERC20.sol\\n */\\nabstract contract Erc20Interface is Erc20Storage {\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n    function allowance(address owner, address spender) external view virtual returns (uint256);\\n\\n    function balanceOf(address account) external view virtual returns (uint256);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    function transfer(address recipient, uint256 amount) external virtual returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    event Burn(address indexed holder, uint256 burnAmount);\\n\\n    event Mint(address indexed beneficiary, uint256 mintAmount);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\"},\"Erc20Permit.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20.sol\\\";\\nimport \\\"./Erc20PermitInterface.sol\\\";\\n\\n/**\\n * @title Erc20Permit\\n * @author Paul Razvan Berg\\n * @notice Extension of Erc20 that allows token holders to use their tokens\\n * without sending any transactions by setting the allowance with a signature\\n * using the `permit` method, and then spend them via `transferFrom`.\\n * @dev See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ncontract Erc20Permit is\\n    Erc20PermitInterface, /* one dependency */\\n    Erc20 /* three dependencies */\\n{\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) Erc20(name_, symbol_, decimals_) {\\n        uint256 chainId;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`\\u0027s tokens,\\n     * assuming the latter\\u0027s signed approval.\\n     *\\n     * IMPORTANT: The same issues Erc20 `approve` has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the Eip712-formatted function arguments.\\n     * - The signature must use `owner`\\u0027s current nonce.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(owner != address(0x00), \\\"ERR_ERC20_PERMIT_OWNER_ZERO_ADDRESS\\\");\\n        require(spender != address(0x00), \\\"ERR_ERC20_PERMIT_SPENDER_ZERO_ADDRESS\\\");\\n        require(deadline \\u003e= block.timestamp, \\\"ERR_ERC20_PERMIT_EXPIRED\\\");\\n\\n        /* It\\u0027s safe to use the \\\"+\\\" operator here because the nonce cannot realistically overflow, ever. */\\n        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\n        address recoveredOwner = ecrecover(digest, v, r, s);\\n\\n        require(recoveredOwner != address(0x00), \\\"ERR_ERC20_PERMIT_RECOVERED_OWNER_ZERO_ADDRESS\\\");\\n        require(recoveredOwner == owner, \\\"ERR_ERC20_PERMIT_INVALID_SIGNATURE\\\");\\n\\n        approveInternal(owner, spender, amount);\\n    }\\n}\\n\"},\"Erc20PermitInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\n/* solhint-disable var-name-mixedcase */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20PermitStorage.sol\\\";\\n\\n/**\\n * @notice Erc20PermitInterface\\n * @author Paul Razvan Berg\\n */\\nabstract contract Erc20PermitInterface is Erc20PermitStorage {\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual;\\n}\\n\"},\"Erc20PermitStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\n/* solhint-disable var-name-mixedcase */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @notice Erc20PermitStorage\\n * @author Paul Razvan Berg\\n */\\nabstract contract Erc20PermitStorage {\\n    /**\\n     * @notice The Eip712 domain\\u0027s keccak256 hash.\\n     */\\n    bytes32 public DOMAIN_SEPARATOR;\\n\\n    /**\\n     * @notice keccak256(\\\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\\\");\\n     */\\n    bytes32 public constant PERMIT_TYPEHASH = 0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f;\\n\\n    /**\\n     * @notice Provides replay protection.\\n     */\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    /**\\n     * @notice Eip712 version of this implementation.\\n     */\\n    string public constant version = \\\"1\\\";\\n}\\n\"},\"Erc20Recover.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Admin.sol\\\";\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./Erc20RecoverInterface.sol\\\";\\nimport \\\"./SafeErc20.sol\\\";\\n\\n/**\\n * @title Erc20Recover\\n * @author Paul Razvan Berg\\n * @notice Gives the administrator the ability to recover the Erc20 tokens that\\n * had been sent (accidentally, or not) to the contract.\\n */\\nabstract contract Erc20Recover is\\n    Erc20RecoverInterface, /* one dependency */\\n    Admin /* two dependencies */\\n{\\n    using SafeErc20 for Erc20Interface;\\n\\n    /**\\n     * @notice Sets the tokens that this contract cannot recover.\\n     *\\n     * @dev Emits a {SetNonRecoverableTokens} event.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the administrator.\\n     * - The contract must be non-initialized.\\n     * - The array of given tokens cannot be empty.\\n     *\\n     * @param tokens The array of tokens to set as non-recoverable.\\n     */\\n    function _setNonRecoverableTokens(Erc20Interface[] calldata tokens) external override onlyAdmin {\\n        /* Checks */\\n        require(isRecoverInitialized == false, \\\"ERR_INITALIZED\\\");\\n\\n        /* Iterate over the token list, sanity check each and update the mapping. */\\n        uint256 length = tokens.length;\\n        for (uint256 i = 0; i \\u003c length; i += 1) {\\n            tokens[i].symbol();\\n            nonRecoverableTokens.push(tokens[i]);\\n        }\\n\\n        /* Effects: prevent this function from ever being called again. */\\n        isRecoverInitialized = true;\\n\\n        emit SetNonRecoverableTokens(admin, tokens);\\n    }\\n\\n    /**\\n     * @notice Recover Erc20 tokens sent to this contract (by accident or otherwise).\\n     * @dev Emits a {RecoverToken} event.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the administrator.\\n     * - The contract must be initialized.\\n     * - The amount to recover cannot be zero.\\n     * - The token to recover cannot be among the non-recoverable tokens.\\n     *\\n     * @param token The token to make the recover for.\\n     * @param recoverAmount The uint256 amount to recover, specified in the token\\u0027s decimal system.\\n     */\\n    function _recover(Erc20Interface token, uint256 recoverAmount) external override onlyAdmin {\\n        /* Checks */\\n        require(isRecoverInitialized == true, \\\"ERR_NOT_INITALIZED\\\");\\n        require(recoverAmount \\u003e 0, \\\"ERR_RECOVER_ZERO\\\");\\n\\n        bytes32 tokenSymbolHash = keccak256(bytes(token.symbol()));\\n        uint256 length = nonRecoverableTokens.length;\\n\\n        /**\\n         * We iterate over the non-recoverable token array and check that:\\n         *\\n         *   1. The addresses of the tokens are not the same\\n         *   2. The symbols of the tokens are not the same\\n         *\\n         * It is true that the second check may lead to a false positive, but\\n         * there is no better way to fend off against proxied tokens.\\n         */\\n        for (uint256 i = 0; i \\u003c length; i += 1) {\\n            require(\\n                address(token) != address(nonRecoverableTokens[i]) \\u0026\\u0026\\n                    tokenSymbolHash != keccak256(bytes(nonRecoverableTokens[i].symbol())),\\n                \\\"ERR_RECOVER_NON_RECOVERABLE_TOKEN\\\"\\n            );\\n        }\\n\\n        /* Interactions */\\n        token.safeTransfer(admin, recoverAmount);\\n\\n        emit Recover(admin, token, recoverAmount);\\n    }\\n}\\n\"},\"Erc20RecoverInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./Erc20RecoverStorage.sol\\\";\\n\\nabstract contract Erc20RecoverInterface is Erc20RecoverStorage {\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function _recover(Erc20Interface token, uint256 recoverAmount) external virtual;\\n\\n    function _setNonRecoverableTokens(Erc20Interface[] calldata tokens) external virtual;\\n\\n    /**\\n     * EVENTS\\n     */\\n    event Recover(address indexed admin, Erc20Interface token, uint256 recoverAmount);\\n    event SetNonRecoverableTokens(address indexed admin, Erc20Interface[] nonRecoverableTokens);\\n}\\n\"},\"Erc20RecoverStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\n\\nabstract contract Erc20RecoverStorage {\\n    /**\\n     * @notice The tokens that can be recovered cannot be in this mapping.\\n     */\\n    Erc20Interface[] public nonRecoverableTokens;\\n\\n    /**\\n     * @dev A flag that signals whether the the non-recoverable tokens were set or not.\\n     */\\n    bool internal isRecoverInitialized;\\n}\\n\"},\"Erc20Storage.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title ExponentialStorage\\n * @author Paul Razvan Berg\\n * @notice The storage interface ancillary to an Erc20 contract.\\n */\\nabstract contract Erc20Storage {\\n    /**\\n     * @notice Returns the number of decimals used to get its user representation.\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Returns the name of the token.\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice Returns the symbol of the token, usually a shorter version of\\n     * the name.\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice Returns the amount of tokens in existence.\\n     */\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal allowances;\\n\\n    mapping(address =\\u003e uint256) internal balances;\\n}\\n\"},\"Exponential.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./ExponentialStorage.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals.\\n * @author Paul Razvan Berg\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n * Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is: `Exp({mantissa: 5100000000000000000})`.\\n * @dev Forked from Compound\\n * https://github.com/compound-finance/compound-protocol/blob/v2.6/contracts/Exponential.sol\\n */\\nabstract contract Exponential is\\n    CarefulMath, /* no dependency */\\n    ExponentialStorage /* no dependency */\\n{\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({ mantissa: result }));\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     * (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b.\\n     * NOTE: Returns an error if (`num` * 10e18) \\u003e MAX_INT, or if `denom` is zero.\\n     */\\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 scaledNumerator) = mulUInt(a.mantissa, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({ mantissa: 0 }));\\n        }\\n\\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, b.mantissa);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({ mantissa: 0 }));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({ mantissa: rational }));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({ mantissa: 0 }));\\n        }\\n\\n        /*\\n         * We add half the scale before dividing so that we get rounding instead of truncation.\\n         * See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n         * Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n         */\\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({ mantissa: 0 }));\\n        }\\n\\n        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        /* The only possible error `div` is MathError.DIVISION_BY_ZERO but we control `expScale` and it\\u0027s not zero. */\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({ mantissa: product }));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(\\n        Exp memory a,\\n        Exp memory b,\\n        Exp memory c\\n    ) internal pure returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({ mantissa: result }));\\n    }\\n}\\n\"},\"ExponentialStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LPGL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title ExponentialStorage\\n * @author Paul Razvan Berg\\n * @notice The storage interface ancillary to an Exponential contract.\\n */\\nabstract contract ExponentialStorage {\\n    struct Exp {\\n        uint256 mantissa;\\n    }\\n\\n    /**\\n     * @dev In Exponential denomination, 1e18 is 1.\\n     */\\n    uint256 internal constant expScale = 1e18;\\n    uint256 internal constant halfExpScale = expScale / 2;\\n    uint256 internal constant mantissaOne = expScale;\\n}\\n\"},\"FintrollerInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LPGL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./FintrollerStorage.sol\\\";\\nimport \\\"./FyTokenInterface.sol\\\";\\nimport \\\"./ChainlinkOperatorInterface.sol\\\";\\n\\nabstract contract FintrollerInterface is FintrollerStorage {\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n\\n    function getBond(FyTokenInterface fyToken)\\n        external\\n        view\\n        virtual\\n        returns (\\n            uint256 debtCeiling,\\n            uint256 collateralizationRatioMantissa,\\n            bool isBorrowAllowed,\\n            bool isDepositCollateralAllowed,\\n            bool isLiquidateBorrowAllowed,\\n            bool isListed,\\n            bool isRedeemFyTokenAllowed,\\n            bool isRepayBorrowAllowed,\\n            bool isSupplyUnderlyingAllowed\\n        );\\n\\n    function getBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view virtual returns (uint256);\\n\\n    function getBondDebtCeiling(FyTokenInterface fyToken) external view virtual returns (uint256);\\n\\n    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n\\n    function listBond(FyTokenInterface fyToken) external virtual returns (bool);\\n\\n    function setBondCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)\\n        external\\n        virtual\\n        returns (bool);\\n\\n    function setBondDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling) external virtual returns (bool);\\n\\n    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external virtual returns (bool);\\n\\n    function setOracle(ChainlinkOperatorInterface newOracle) external virtual returns (bool);\\n\\n    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event ListBond(address indexed admin, FyTokenInterface indexed fyToken);\\n\\n    event SetBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetBondCollateralizationRatio(\\n        address indexed admin,\\n        FyTokenInterface indexed fyToken,\\n        uint256 oldCollateralizationRatio,\\n        uint256 newCollateralizationRatio\\n    );\\n\\n    event SetBondDebtCeiling(\\n        address indexed admin,\\n        FyTokenInterface indexed fyToken,\\n        uint256 oldDebtCeiling,\\n        uint256 newDebtCeiling\\n    );\\n\\n    event SetDepositCollateralAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetLiquidateBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetLiquidationIncentive(\\n        address indexed admin,\\n        uint256 oldLiquidationIncentive,\\n        uint256 newLiquidationIncentive\\n    );\\n\\n    event SetRedeemFyTokensAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetRepayBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetOracle(address indexed admin, address oldOracle, address newOracle);\\n\\n    event SetSupplyUnderlyingAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n}\\n\"},\"FintrollerStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Exponential.sol\\\";\\n\\nimport \\\"./FyTokenInterface.sol\\\";\\nimport \\\"./ChainlinkOperatorInterface.sol\\\";\\n\\n/**\\n * @title FintrollerStorage\\n * @author Hifi\\n */\\nabstract contract FintrollerStorage is Exponential {\\n    struct Bond {\\n        Exp collateralizationRatio;\\n        uint256 debtCeiling;\\n        bool isBorrowAllowed;\\n        bool isDepositCollateralAllowed;\\n        bool isLiquidateBorrowAllowed;\\n        bool isListed;\\n        bool isRedeemFyTokenAllowed;\\n        bool isRepayBorrowAllowed;\\n        bool isSupplyUnderlyingAllowed;\\n    }\\n\\n    /**\\n     * @dev Maps the fyToken address to the Bond structs.\\n     */\\n    mapping(FyTokenInterface =\\u003e Bond) internal bonds;\\n\\n    /**\\n     * @notice The contract that provides price data for the collateral and the underlying asset.\\n     */\\n    ChainlinkOperatorInterface public oracle;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives.\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @dev The threshold below which the collateralization ratio cannot be set, equivalent to 100%.\\n     */\\n    uint256 internal constant collateralizationRatioLowerBoundMantissa = 1.0e18;\\n\\n    /**\\n     * @dev The threshold above which the collateralization ratio cannot be set, equivalent to 10,000%.\\n     */\\n    uint256 internal constant collateralizationRatioUpperBoundMantissa = 1.0e20;\\n\\n    /**\\n     * @dev The dafault collateralization ratio set when a new bond is listed, equivalent to 150%.\\n     */\\n    uint256 internal constant defaultCollateralizationRatioMantissa = 1.5e18;\\n\\n    /**\\n     * @dev The threshold below which the liquidation incentive cannot be set, equivalent to 100%.\\n     */\\n    uint256 internal constant liquidationIncentiveLowerBoundMantissa = 1.0e18;\\n\\n    /**\\n     * @dev The threshold above which the liquidation incentive cannot be set, equivalent to 150%.\\n     */\\n    uint256 internal constant liquidationIncentiveUpperBoundMantissa = 1.5e18;\\n\\n    /**\\n     * @notice Indicator that this is a Fintroller contract, for inspection.\\n     */\\n    bool public constant isFintroller = true;\\n}\\n\"},\"FyToken.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Admin.sol\\\";\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./Erc20.sol\\\";\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./Erc20Permit.sol\\\";\\nimport \\\"./Erc20Recover.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\nimport \\\"./BalanceSheetInterface.sol\\\";\\nimport \\\"./FintrollerInterface.sol\\\";\\nimport \\\"./FyTokenInterface.sol\\\";\\nimport \\\"./RedemptionPool.sol\\\";\\n\\n/**\\n * @title FyToken\\n * @author Hifi\\n * @notice Zero-coupon bond that tracks an Erc20 underlying asset.\\n */\\ncontract FyToken is\\n    ReentrancyGuard, /* no depedency */\\n    FyTokenInterface, /* one dependency */\\n    Admin, /* two dependencies */\\n    Exponential, /* two dependencies */\\n    Erc20, /* three dependencies */\\n    Erc20Permit, /* five dependencies */\\n    Erc20Recover /* five dependencies */\\n{\\n    modifier isVaultOpen(address account) {\\n        require(balanceSheet.isVaultOpen(this, account), \\\"ERR_VAULT_NOT_OPEN\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice The fyToken always has 18 decimals.\\n     * @dev Instantiates the Redemption Pool.\\n     * @param name_ Erc20 name of this token.\\n     * @param symbol_ Erc20 symbol of this token.\\n     * @param expirationTime_ Unix timestamp in seconds for when this token expires.\\n     * @param fintroller_ The address of the Fintroller contract.\\n     * @param balanceSheet_ The address of the BalanceSheet contract.\\n     * @param underlying_ The contract address of the underlying asset.\\n     * @param collateral_ The contract address of the collateral asset.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 expirationTime_,\\n        FintrollerInterface fintroller_,\\n        BalanceSheetInterface balanceSheet_,\\n        Erc20Interface underlying_,\\n        Erc20Interface collateral_\\n    ) Erc20Permit(name_, symbol_, 18) Admin() {\\n        uint8 defaultNumberOfDecimals = 18;\\n\\n        /* Set the underlying contract and calculate the decimal scalar offsets. */\\n        uint256 underlyingDecimals = underlying_.decimals();\\n        require(underlyingDecimals \\u003e 0, \\\"ERR_FYTOKEN_CONSTRUCTOR_UNDERLYING_DECIMALS_ZERO\\\");\\n        require(underlyingDecimals \\u003c= defaultNumberOfDecimals, \\\"ERR_FYTOKEN_CONSTRUCTOR_UNDERLYING_DECIMALS_OVERFLOW\\\");\\n        underlyingPrecisionScalar = 10**(defaultNumberOfDecimals - underlyingDecimals);\\n        underlying = underlying_;\\n\\n        /* Set the collateral contract and calculate the decimal scalar offsets. */\\n        uint256 collateralDecimals = collateral_.decimals();\\n        require(collateralDecimals \\u003e 0, \\\"ERR_FYTOKEN_CONSTRUCTOR_COLLATERAL_DECIMALS_ZERO\\\");\\n        require(defaultNumberOfDecimals \\u003e= collateralDecimals, \\\"ERR_FYTOKEN_CONSTRUCTOR_COLLATERAL_DECIMALS_OVERFLOW\\\");\\n        collateralPrecisionScalar = 10**(defaultNumberOfDecimals - collateralDecimals);\\n        collateral = collateral_;\\n\\n        /* Set the unix expiration time. */\\n        require(expirationTime_ \\u003e block.timestamp, \\\"ERR_FYTOKEN_CONSTRUCTOR_EXPIRATION_TIME_NOT_VALID\\\");\\n        expirationTime = expirationTime_;\\n\\n        /* Set the Fintroller contract and sanity check it. */\\n        fintroller = fintroller_;\\n        fintroller.isFintroller();\\n\\n        /* Set the Balance Sheet contract and sanity check it. */\\n        balanceSheet = balanceSheet_;\\n        balanceSheet.isBalanceSheet();\\n\\n        /* Create the Redemption Pool contract and transfer the owner from the fyToken itself to the current caller. */\\n        redemptionPool = new RedemptionPool(fintroller_, this);\\n        AdminInterface(address(redemptionPool))._transferAdmin(msg.sender);\\n    }\\n\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n\\n    /**\\n     * @notice Checks if the bond matured.\\n     * @return true = bond matured, otherwise it didn\\u0027t.\\n     */\\n    function isMatured() public view override returns (bool) {\\n        return block.timestamp \\u003e= expirationTime;\\n    }\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n\\n    struct BorrowLocalVars {\\n        MathError mathErr;\\n        uint256 debt;\\n        uint256 debtCeiling;\\n        uint256 lockedCollateral;\\n        uint256 hypotheticalCollateralizationRatioMantissa;\\n        uint256 hypotheticalTotalSupply;\\n        uint256 newDebt;\\n        uint256 thresholdCollateralizationRatioMantissa;\\n    }\\n\\n    /**\\n     * @notice Increases the debt of the caller and mints new fyToken.\\n     *\\n     * @dev Emits a {Borrow}, {Mint} and {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - The vault must be open.\\n     * - Must be called prior to maturation.\\n     * - The amount to borrow cannot be zero.\\n     * - The Fintroller must allow this action to be performed.\\n     * - The locked collateral cannot be zero.\\n     * - The total supply of fyTokens cannot exceed the debt ceiling.\\n     * - The caller must not fall below the threshold collateralization ratio.\\n     *\\n     * @param borrowAmount The amount of fyTokens to borrow and print into existence.\\n     * @return bool true = success, otherwise it reverts.\\n     */\\n    function borrow(uint256 borrowAmount) public override isVaultOpen(msg.sender) nonReentrant returns (bool) {\\n        BorrowLocalVars memory vars;\\n\\n        /* Checks: bond not matured. */\\n        require(isMatured() == false, \\\"ERR_BOND_MATURED\\\");\\n\\n        /* Checks: the zero edge case. */\\n        require(borrowAmount \\u003e 0, \\\"ERR_BORROW_ZERO\\\");\\n\\n        /* Checks: the Fintroller allows this action to be performed. */\\n        require(fintroller.getBorrowAllowed(this), \\\"ERR_BORROW_NOT_ALLOWED\\\");\\n\\n        /* Checks: debt ceiling. */\\n        (vars.mathErr, vars.hypotheticalTotalSupply) = addUInt(totalSupply, borrowAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"ERR_BORROW_MATH_ERROR\\\");\\n        vars.debtCeiling = fintroller.getBondDebtCeiling(this);\\n        require(vars.hypotheticalTotalSupply \\u003c= vars.debtCeiling, \\\"ERR_BORROW_DEBT_CEILING_OVERFLOW\\\");\\n\\n        /* Add the borrow amount to the borrower account\\u0027s current debt. */\\n        (vars.debt, , vars.lockedCollateral, ) = balanceSheet.getVault(this, msg.sender);\\n        require(vars.lockedCollateral \\u003e 0, \\\"ERR_BORROW_LOCKED_COLLATERAL_ZERO\\\");\\n        (vars.mathErr, vars.newDebt) = addUInt(vars.debt, borrowAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"ERR_BORROW_MATH_ERROR\\\");\\n\\n        /* Checks: the hypothetical collateralization ratio is above the threshold. */\\n        vars.hypotheticalCollateralizationRatioMantissa = balanceSheet.getHypotheticalCollateralizationRatio(\\n            this,\\n            msg.sender,\\n            vars.lockedCollateral,\\n            vars.newDebt\\n        );\\n        vars.thresholdCollateralizationRatioMantissa = fintroller.getBondCollateralizationRatio(this);\\n        require(\\n            vars.hypotheticalCollateralizationRatioMantissa \\u003e= vars.thresholdCollateralizationRatioMantissa,\\n            \\\"ERR_BELOW_COLLATERALIZATION_RATIO\\\"\\n        );\\n\\n        /* Effects: print the new fyTokens into existence. */\\n        mintInternal(msg.sender, borrowAmount);\\n\\n        /* Emit a Transfer event. */\\n        emit Transfer(address(this), msg.sender, borrowAmount);\\n\\n        /* Interactions: increase the debt of the borrower account. */\\n        require(balanceSheet.setVaultDebt(this, msg.sender, vars.newDebt), \\\"ERR_BORROW_CALL_SET_VAULT_DEBT\\\");\\n\\n        /* Emit a Borrow event. */\\n        emit Borrow(msg.sender, borrowAmount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Destroys `burnAmount` tokens from `holder`, reducing the token supply.\\n     *\\n     * @dev Emits a {Burn} and a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - Must be called prior to maturation.\\n     * - Can only be called by the Redemption Pool.\\n     * - The amount to burn cannot be zero.\\n     *\\n     * @param holder The account whose fyTokens to burn.\\n     * @param burnAmount The amount of fyTokens to burn.\\n     * @return bool true = success, otherwise it reverts.\\n     */\\n    function burn(address holder, uint256 burnAmount) external override nonReentrant returns (bool) {\\n        /* Checks: the caller is the Redemption Pool. */\\n        require(msg.sender == address(redemptionPool), \\\"ERR_BURN_NOT_AUTHORIZED\\\");\\n\\n        /* Checks: the zero edge case. */\\n        require(burnAmount \\u003e 0, \\\"ERR_BURN_ZERO\\\");\\n\\n        /* Effects: burns the fyTokens. */\\n        burnInternal(holder, burnAmount);\\n\\n        /* Emit a Transfer event. */\\n        emit Transfer(holder, address(this), burnAmount);\\n\\n        return true;\\n    }\\n\\n    struct LiquidateBorrowsLocalVars {\\n        MathError mathErr;\\n        uint256 collateralizationRatioMantissa;\\n        uint256 lockedCollateral;\\n        bool isAccountUnderwater;\\n    }\\n\\n    /**\\n     * @notice Repays the debt of the borrower and rewards the caler with a surplus of collateral.\\n     *\\n     * @dev Emits a {RepayBorrow}, {Transfer}, {ClutchCollateral} and {LiquidateBorrow} event.\\n     *\\n     * Requirements:\\n     *\\n     * - The vault must be open.\\n     * - The liquidator cannot liquidate themselves.\\n     * - The amount to repay cannot be zero.\\n     * - The Fintroller must allow this action to be performed.\\n     * - The borrower must be underwater if the bond didn\\u0027t mature.\\n     * - The caller must have at least `repayAmount` fyTokens.\\n     * - The borrower must have at least `repayAmount` debt.\\n     * - The amount of clutched collateral cannot be more than what the borrower has in the vault.\\n     *\\n     * @param borrower The account to liquidate.\\n     * @param repayAmount The amount of fyTokens to repay.\\n     * @return true = success, otherwise it reverts.\\n     */\\n    function liquidateBorrow(address borrower, uint256 repayAmount)\\n        external\\n        override\\n        isVaultOpen(borrower)\\n        nonReentrant\\n        returns (bool)\\n    {\\n        LiquidateBorrowsLocalVars memory vars;\\n\\n        /* Checks: borrowers cannot self liquidate. */\\n        require(msg.sender != borrower, \\\"ERR_LIQUIDATE_BORROW_SELF\\\");\\n\\n        /* Checks: the zero edge case. */\\n        require(repayAmount \\u003e 0, \\\"ERR_LIQUIDATE_BORROW_ZERO\\\");\\n\\n        /* Checks: the Fintroller allows this action to be performed. */\\n        require(fintroller.getLiquidateBorrowAllowed(this), \\\"ERR_LIQUIDATE_BORROW_NOT_ALLOWED\\\");\\n\\n        /* After maturation, any vault can be liquidated, irrespective of collateralization ratio. */\\n        if (isMatured() == false) {\\n            /* Checks: the borrower fell below the threshold collateralization ratio. */\\n            vars.isAccountUnderwater = balanceSheet.isAccountUnderwater(this, borrower);\\n            require(vars.isAccountUnderwater, \\\"ERR_ACCOUNT_NOT_UNDERWATER\\\");\\n        }\\n\\n        /* Effects \\u0026 Interactions: repay the borrower\\u0027s debt. */\\n        repayBorrowInternal(msg.sender, borrower, repayAmount);\\n\\n        /* Interactions: clutch the collateral. */\\n        uint256 clutchableCollateralAmount = balanceSheet.getClutchableCollateral(this, repayAmount);\\n        require(\\n            balanceSheet.clutchCollateral(this, msg.sender, borrower, clutchableCollateralAmount),\\n            \\\"ERR_LIQUIDATE_BORROW_CALL_CLUTCH_COLLATERAL\\\"\\n        );\\n\\n        emit LiquidateBorrow(msg.sender, borrower, repayAmount, clutchableCollateralAmount);\\n\\n        return true;\\n    }\\n\\n    /**\\n    /** @notice Prints new tokens into existence and assigns them to `beneficiary`,\\n     * increasing the total supply.\\n     *\\n     * @dev Emits a {Mint} and a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - Can only be called by the Redemption Pool.\\n     * - The amount to mint cannot be zero.\\n     *\\n     * @param beneficiary The borrower account for which to mint the tokens.\\n     * @param mintAmount The amount of fyTokens to print into existence.\\n     * @return bool true = success, otherwise it reverts.\\n     */\\n    function mint(address beneficiary, uint256 mintAmount) external override nonReentrant returns (bool) {\\n        /* Checks: the caller is the Redemption Pool. */\\n        require(msg.sender == address(redemptionPool), \\\"ERR_MINT_NOT_AUTHORIZED\\\");\\n\\n        /* Checks: the zero edge case. */\\n        require(mintAmount \\u003e 0, \\\"ERR_MINT_ZERO\\\");\\n\\n        /* Effects: print the new fyTokens into existence. */\\n        mintInternal(beneficiary, mintAmount);\\n\\n        /* Emit a Transfer event. */\\n        emit Transfer(address(this), beneficiary, mintAmount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Deletes the borrower account\\u0027s debt from the registry and take the fyTokens\\n     * out of circulation.\\n     *\\n     * @dev Emits a {Burn}, {Transfer} and {RepayBorrow} event.\\n     *\\n     * Requirements:\\n     *\\n     * - The vault must be open.\\n     * - The amount to repay cannot be zero.\\n     * - The Fintroller must allow this action to be performed.\\n     * - The caller must have at least `repayAmount` fyTokens.\\n     * - The caller must have at least `repayAmount` debt.\\n     *\\n     * @param repayAmount The amount of fyTokens to repay.\\n     * @return true = success, otherwise it reverts.\\n     */\\n    function repayBorrow(uint256 repayAmount) external override isVaultOpen(msg.sender) nonReentrant returns (bool) {\\n        repayBorrowInternal(msg.sender, msg.sender, repayAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Clears the borrower account\\u0027s debt from the registry and take the fyTokens\\n     * out of circulation.\\n     *\\n     * @dev Emits a {Burn}, {Transfer} and {RepayBorrow} event.\\n     *\\n     * Requirements: same as the `repayBorrow` function, but here `borrower` is the account that must\\n     * have at least `repayAmount` fyTokens to repay the borrow.\\n     *\\n     * @param borrower The borrower account for which to repay the borrow.\\n     * @param repayAmount The amount of fyTokens to repay.\\n     * @return true = success, otherwise it reverts.\\n     */\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\\n        external\\n        override\\n        isVaultOpen(borrower)\\n        nonReentrant\\n        returns (bool)\\n    {\\n        repayBorrowInternal(msg.sender, borrower, repayAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Updates the Fintroller contract\\u0027s address saved in storage.\\n     *\\n     * @dev Throws a {SetFintroller} event.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the admin.\\n     * - The new Fintroller must pass the inspection.\\n     *\\n     * @param newFintroller The address of the new Fintroller contract.\\n     * @return bool true = success, otherwise it reverts.\\n     */\\n    function _setFintroller(FintrollerInterface newFintroller) external override onlyAdmin returns (bool) {\\n        /* Checks: sanity check the new Fintroller contract. */\\n        require(newFintroller.isFintroller(), \\\"ERR_SET_FINTROLLER_INSPECTION\\\");\\n\\n        /* Effects: update storage. */\\n        FintrollerInterface oldFintroller = fintroller;\\n        fintroller = newFintroller;\\n\\n        emit SetFintroller(admin, oldFintroller, newFintroller);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * INTERNAL FUNCTIONS\\n     */\\n\\n    /**\\n     * @dev See the documentation for the public functions that call this internal function.\\n     */\\n    function repayBorrowInternal(\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) internal {\\n        /* Checks: the zero edge case. */\\n        require(repayAmount \\u003e 0, \\\"ERR_REPAY_BORROW_ZERO\\\");\\n\\n        /* Checks: the Fintroller allows this action to be performed. */\\n        require(fintroller.getRepayBorrowAllowed(this), \\\"ERR_REPAY_BORROW_NOT_ALLOWED\\\");\\n\\n        /* Checks: borrower has a debt to pay. */\\n        uint256 debt = balanceSheet.getVaultDebt(this, borrower);\\n        require(debt \\u003e= repayAmount, \\\"ERR_REPAY_BORROW_INSUFFICIENT_DEBT\\\");\\n\\n        /* Checks: the payer has enough fyTokens. */\\n        require(balanceOf(payer) \\u003e= repayAmount, \\\"ERR_REPAY_BORROW_INSUFFICIENT_BALANCE\\\");\\n\\n        /* Effects: burn the fyTokens. */\\n        burnInternal(payer, repayAmount);\\n\\n        /* Emit a Transfer event. */\\n        emit Transfer(payer, address(this), repayAmount);\\n\\n        /* Calculate the new debt of the borrower. */\\n        MathError mathErr;\\n        uint256 newDebt;\\n        (mathErr, newDebt) = subUInt(debt, repayAmount);\\n        /* This operation can\\u0027t fail because of the previous `require`. */\\n        assert(mathErr == MathError.NO_ERROR);\\n\\n        /* Interactions: reduce the debt of the borrower . */\\n        require(balanceSheet.setVaultDebt(this, borrower, newDebt), \\\"ERR_REPAY_BORROW_CALL_SET_VAULT_DEBT\\\");\\n\\n        /* Emit both a RepayBorrow event. */\\n        emit RepayBorrow(payer, borrower, repayAmount, newDebt);\\n    }\\n}\\n\"},\"FyTokenInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./FyTokenStorage.sol\\\";\\n\\n/**\\n * @title FyTokenInterface\\n * @author Hifi\\n */\\nabstract contract FyTokenInterface is\\n    FyTokenStorage, /* no dependency */\\n    Erc20Interface /* one dependency */\\n{\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n    function isMatured() public view virtual returns (bool);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function borrow(uint256 borrowAmount) external virtual returns (bool);\\n\\n    function burn(address holder, uint256 burnAmount) external virtual returns (bool);\\n\\n    function liquidateBorrow(address borrower, uint256 repayAmount) external virtual returns (bool);\\n\\n    function mint(address beneficiary, uint256 mintAmount) external virtual returns (bool);\\n\\n    function repayBorrow(uint256 repayAmount) external virtual returns (bool);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (bool);\\n\\n    function _setFintroller(FintrollerInterface newFintroller) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event Borrow(address indexed borrower, uint256 borrowAmount);\\n\\n    event LiquidateBorrow(\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        uint256 clutchedCollateralAmount\\n    );\\n\\n    event RepayBorrow(address indexed payer, address indexed borrower, uint256 repayAmount, uint256 newDebt);\\n\\n    event SetFintroller(address indexed admin, FintrollerInterface oldFintroller, FintrollerInterface newFintroller);\\n}\\n\"},\"FyTokenStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./BalanceSheetInterface.sol\\\";\\nimport \\\"./FintrollerInterface.sol\\\";\\nimport \\\"./RedemptionPoolInterface.sol\\\";\\n\\n/**\\n * @title FyTokenStorage\\n * @author Hifi\\n */\\nabstract contract FyTokenStorage {\\n    /**\\n     * STORAGE PROPERTIES\\n     */\\n\\n    /**\\n     * @notice The global debt registry.\\n     */\\n    BalanceSheetInterface public balanceSheet;\\n\\n    /**\\n     * @notice The Erc20 asset that backs the borrows of this fyToken.\\n     */\\n    Erc20Interface public collateral;\\n\\n    /**\\n     * @notice The ratio between mantissa precision (1e18) and the collateral precision.\\n     */\\n    uint256 public collateralPrecisionScalar;\\n\\n    /**\\n     * @notice Unix timestamp in seconds for when this token expires.\\n     */\\n    uint256 public expirationTime;\\n\\n    /**\\n     * @notice The unique Fintroller associated with this contract.\\n     */\\n    FintrollerInterface public fintroller;\\n\\n    /**\\n     * @notice The unique Redemption Pool associated with this contract.\\n     */\\n    RedemptionPoolInterface public redemptionPool;\\n\\n    /**\\n     * @notice The Erc20 underlying, or target, asset for this fyToken.\\n     */\\n    Erc20Interface public underlying;\\n\\n    /**\\n     * @notice The ratio between mantissa precision (1e18) and the underlying precision.\\n     */\\n    uint256 public underlyingPrecisionScalar;\\n\\n    /**\\n     * @notice Indicator that this is a FyToken contract, for inspection.\\n     */\\n    bool public constant isFyToken = true;\\n}\\n\"},\"RedemptionPool.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Admin.sol\\\";\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./Erc20Recover.sol\\\";\\nimport \\\"./SafeErc20.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\nimport \\\"./FintrollerInterface.sol\\\";\\nimport \\\"./RedemptionPoolInterface.sol\\\";\\n\\n/**\\n * @title RedemptionPool\\n * @author Hifi\\n * @notice Mints 1 fyToken in exhchange for 1 underlying before maturation and burns 1 fyToken\\n * in exchange for 1 underlying after maturation.\\n * @dev Instantiated by the fyToken in its constructor.\\n */\\ncontract RedemptionPool is\\n    CarefulMath, /* no dependency */\\n    ReentrancyGuard, /* no dependency */\\n    RedemptionPoolInterface, /* one dependency */\\n    Admin, /* two dependencies */\\n    Erc20Recover /* five dependencies */\\n{\\n    using SafeErc20 for Erc20Interface;\\n\\n    /**\\n     * @param fintroller_ The address of the Fintroller contract.\\n     * @param fyToken_ The address of the fyToken contract.\\n     */\\n    constructor(FintrollerInterface fintroller_, FyTokenInterface fyToken_) Admin() {\\n        /* Set the Fintroller contract and sanity check it. */\\n        fintroller = fintroller_;\\n        fintroller.isFintroller();\\n\\n        /**\\n         * Set the fyToken contract. It cannot be sanity-checked because the fyToken creates this\\n         * contract in its own constructor and contracts cannot be called while initializing.\\n         */\\n        fyToken = fyToken_;\\n    }\\n\\n    struct RedeemFyTokensLocalVars {\\n        MathError mathErr;\\n        uint256 newUnderlyingTotalSupply;\\n        uint256 underlyingPrecisionScalar;\\n        uint256 underlyingAmount;\\n    }\\n\\n    /**\\n     * @notice Pays the token holder the face value at maturation time.\\n     *\\n     * @dev Emits a {RedeemFyTokens} event.\\n     *\\n     * Requirements:\\n     *\\n     * - Must be called after maturation.\\n     * - The amount to redeem cannot be zero.\\n     * - The Fintroller must allow this action to be performed.\\n     * - There must be enough liquidity in the Redemption Pool.\\n     *\\n     * @param fyTokenAmount The amount of fyTokens to redeem for the underlying asset.\\n     * @return true = success, otherwise it reverts.\\n     */\\n    function redeemFyTokens(uint256 fyTokenAmount) external override nonReentrant returns (bool) {\\n        RedeemFyTokensLocalVars memory vars;\\n\\n        /* Checks: maturation time. */\\n        require(block.timestamp \\u003e= fyToken.expirationTime(), \\\"ERR_BOND_NOT_MATURED\\\");\\n\\n        /* Checks: the zero edge case. */\\n        require(fyTokenAmount \\u003e 0, \\\"ERR_REDEEM_FYTOKENS_ZERO\\\");\\n\\n        /* Checks: the Fintroller allows this action to be performed. */\\n        require(fintroller.getRedeemFyTokensAllowed(fyToken), \\\"ERR_REDEEM_FYTOKENS_NOT_ALLOWED\\\");\\n\\n        /* Checks: there is enough liquidity. */\\n        require(fyTokenAmount \\u003c= totalUnderlyingSupply, \\\"ERR_REDEEM_FYTOKENS_INSUFFICIENT_UNDERLYING\\\");\\n\\n        /**\\n         * fyTokens always have 18 decimals so the underlying amount needs to be downscaled.\\n         * If the precision scalar is 1, it means that the underlying also has 18 decimals.\\n         */\\n        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();\\n        if (vars.underlyingPrecisionScalar != 1) {\\n            (vars.mathErr, vars.underlyingAmount) = divUInt(fyTokenAmount, vars.underlyingPrecisionScalar);\\n            require(vars.mathErr == MathError.NO_ERROR, \\\"ERR_REDEEM_FYTOKENS_MATH_ERROR\\\");\\n        } else {\\n            vars.underlyingAmount = fyTokenAmount;\\n        }\\n\\n        /* Effects: decrease the remaining supply of underlying. */\\n        (vars.mathErr, vars.newUnderlyingTotalSupply) = subUInt(totalUnderlyingSupply, vars.underlyingAmount);\\n        assert(vars.mathErr == MathError.NO_ERROR);\\n        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;\\n\\n        /* Interactions: burn the fyTokens. */\\n        require(fyToken.burn(msg.sender, fyTokenAmount), \\\"ERR_SUPPLY_UNDERLYING_CALL_BURN\\\");\\n\\n        /* Interactions: perform the Erc20 transfer. */\\n        fyToken.underlying().safeTransfer(msg.sender, vars.underlyingAmount);\\n\\n        emit RedeemFyTokens(msg.sender, fyTokenAmount, vars.underlyingAmount);\\n\\n        return true;\\n    }\\n\\n    struct SupplyUnderlyingLocalVars {\\n        MathError mathErr;\\n        uint256 fyTokenAmount;\\n        uint256 newUnderlyingTotalSupply;\\n        uint256 underlyingPrecisionScalar;\\n    }\\n\\n    /**\\n     * @notice An alternative to the usual minting method that does not involve taking on debt.\\n     *\\n     * @dev Emits a {SupplyUnderlying} event.\\n     *\\n     * Requirements:\\n     *\\n     * - Must be called prior to maturation.\\n     * - The amount to supply cannot be zero.\\n     * - The Fintroller must allow this action to be performed.\\n     * - The caller must have allowed this contract to spend `underlyingAmount` tokens.\\n     *\\n     * @param underlyingAmount The amount of underlying to supply to the Redemption Pool.\\n     * @return true = success, otherwise it reverts.\\n     */\\n    function supplyUnderlying(uint256 underlyingAmount) external override nonReentrant returns (bool) {\\n        SupplyUnderlyingLocalVars memory vars;\\n\\n        /* Checks: maturation time. */\\n        require(block.timestamp \\u003c fyToken.expirationTime(), \\\"ERR_BOND_MATURED\\\");\\n\\n        /* Checks: the zero edge case. */\\n        require(underlyingAmount \\u003e 0, \\\"ERR_SUPPLY_UNDERLYING_ZERO\\\");\\n\\n        /* Checks: the Fintroller allows this action to be performed. */\\n        require(fintroller.getSupplyUnderlyingAllowed(fyToken), \\\"ERR_SUPPLY_UNDERLYING_NOT_ALLOWED\\\");\\n\\n        /* Effects: update storage. */\\n        (vars.mathErr, vars.newUnderlyingTotalSupply) = addUInt(totalUnderlyingSupply, underlyingAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"ERR_SUPPLY_UNDERLYING_MATH_ERROR\\\");\\n        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;\\n\\n        /**\\n         * fyTokens always have 18 decimals so the underlying amount needs to be upscaled.\\n         * If the precision scalar is 1, it means that the underlying also has 18 decimals.\\n         */\\n        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();\\n        if (vars.underlyingPrecisionScalar != 1) {\\n            (vars.mathErr, vars.fyTokenAmount) = mulUInt(underlyingAmount, vars.underlyingPrecisionScalar);\\n            require(vars.mathErr == MathError.NO_ERROR, \\\"ERR_SUPPLY_UNDERLYING_MATH_ERROR\\\");\\n        } else {\\n            vars.fyTokenAmount = underlyingAmount;\\n        }\\n\\n        /* Interactions: mint the fyTokens. */\\n        require(fyToken.mint(msg.sender, vars.fyTokenAmount), \\\"ERR_SUPPLY_UNDERLYING_CALL_MINT\\\");\\n\\n        /* Interactions: perform the Erc20 transfer. */\\n        fyToken.underlying().safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n\\n        emit SupplyUnderlying(msg.sender, underlyingAmount, vars.fyTokenAmount);\\n\\n        return true;\\n    }\\n}\\n\"},\"RedemptionPoolInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./RedemptionPoolStorage.sol\\\";\\n\\n/**\\n * @title RedemptionPoolInterface\\n * @author Hifi\\n */\\nabstract contract RedemptionPoolInterface is RedemptionPoolStorage {\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function redeemFyTokens(uint256 fyTokenAmount) external virtual returns (bool);\\n\\n    function supplyUnderlying(uint256 underlyingAmount) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event RedeemFyTokens(address indexed account, uint256 fyTokenAmount, uint256 underlyingAmount);\\n\\n    event SupplyUnderlying(address indexed account, uint256 underlyingAmount, uint256 fyTokenAmount);\\n}\\n\"},\"RedemptionPoolStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./FintrollerInterface.sol\\\";\\nimport \\\"./FyTokenInterface.sol\\\";\\n\\n/**\\n * @title RedemptionPoolStorage\\n * @author Hifi\\n */\\nabstract contract RedemptionPoolStorage {\\n    /**\\n     * @notice The unique Fintroller associated with this contract.\\n     */\\n    FintrollerInterface public fintroller;\\n\\n    /**\\n     * @notice The amount of the underlying asset available to be redeemed after maturation.\\n     */\\n    uint256 public totalUnderlyingSupply;\\n\\n    /**\\n     * The unique fyToken associated with this Redemption Pool.\\n     */\\n    FyTokenInterface public fyToken;\\n\\n    /**\\n     * @notice Indicator that this is a Redemption Pool contract, for inspection.\\n     */\\n    bool public constant isRedemptionPool = true;\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title ReentrancyGuard\\n * @author Paul Razvan Berg\\n * @notice Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * @dev Forked from OpenZeppelin\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/math/ReentrancyGuard.sol\\n */\\nabstract contract ReentrancyGuard {\\n    bool private notEntered;\\n\\n    /*\\n     * Storing an initial non-zero value makes deployment a bit more expensive\\n     * but in exchange the refund on every call to nonReentrant will be lower\\n     * in amount. Since refunds are capped to a percetange of the total\\n     * transaction\\u0027s gas, it is best to keep them low in cases like this\\n     * one, to increase the likelihood of the full refund coming into effect.\\n     */\\n    constructor() {\\n        notEntered = true;\\n    }\\n\\n    /**\\n     * @notice Prevents a contract from calling itself, directly or indirectly.\\n     * @dev Calling a `nonReentrant` function from another `nonReentrant` function\\n     * is not supported. It is possible to prevent this from happening by making\\n     * the `nonReentrant` function external, and make it call a `private`\\n     * function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        /* On the first call to nonReentrant, _notEntered will be true. */\\n        require(notEntered, \\\"ERR_REENTRANT_CALL\\\");\\n\\n        /* Any calls to nonReentrant after this point will fail. */\\n        notEntered = false;\\n\\n        _;\\n\\n        /*\\n         * By storing the original value once again, a refund is triggered (see\\n         * https://eips.ethereum.org/EIPS/eip-2200).\\n         */\\n        notEntered = true;\\n    }\\n}\\n\"},\"SafeErc20.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeErc20.sol\\n * @author Paul Razvan Berg\\n * @notice Wraps around Erc20 operations that throw on failure (when the token contract\\n * returns false). Tokens that return no value (and instead revert or throw\\n * on failure) are also supported, non-reverting calls are assumed to be successful.\\n *\\n * To use this library you can add a `using SafeErc20 for Erc20Interface;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n *\\n * @dev Forked from OpenZeppelin\\n * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v3.1.0/contracts/utils/Address.sol\\n */\\nlibrary SafeErc20 {\\n    using Address for address;\\n\\n    /**\\n     * INTERNAL FUNCTIONS\\n     */\\n\\n    function safeTransfer(\\n        Erc20Interface token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\\n    }\\n\\n    function safeTransferFrom(\\n        Erc20Interface token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\\n    }\\n\\n    /**\\n     * PRIVATE FUNCTIONS\\n     */\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it cannot be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(Erc20Interface token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n        bytes memory returndata = functionCall(address(token), data, \\\"ERR_SAFE_ERC20_LOW_LEVEL_CALL\\\");\\n        if (returndata.length \\u003e 0) {\\n            /* Return data is optional. */\\n            require(abi.decode(returndata, (bool)), \\\"ERR_SAFE_ERC20_ERC20_OPERATION\\\");\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(target.isContract(), \\\"ERR_SAFE_ERC20_CALL_TO_NON_CONTRACT\\\");\\n\\n        /* solhint-disable-next-line avoid-low-level-calls */\\n        (bool success, bytes memory returndata) = target.call(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            /* Look for revert reason and bubble it up if present */\\n            if (returndata.length \\u003e 0) {\\n                /* The easiest way to bubble the revert reason is using memory via assembly. */\\n\\n                /* solhint-disable-next-line no-inline-assembly */\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime_\",\"type\":\"uint256\"},{\"internalType\":\"contract FintrollerInterface\",\"name\":\"fintroller_\",\"type\":\"address\"},{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet_\",\"type\":\"address\"},{\"internalType\":\"contract Erc20Interface\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"contract Erc20Interface\",\"name\":\"collateral_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"clutchedCollateralAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Erc20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recoverAmount\",\"type\":\"uint256\"}],\"name\":\"Recover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebt\",\"type\":\"uint256\"}],\"name\":\"RepayBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FintrollerInterface\",\"name\":\"oldFintroller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FintrollerInterface\",\"name\":\"newFintroller\",\"type\":\"address\"}],\"name\":\"SetFintroller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Erc20Interface[]\",\"name\":\"nonRecoverableTokens\",\"type\":\"address[]\"}],\"name\":\"SetNonRecoverableTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Erc20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"recoverAmount\",\"type\":\"uint256\"}],\"name\":\"_recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FintrollerInterface\",\"name\":\"newFintroller\",\"type\":\"address\"}],\"name\":\"_setFintroller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Erc20Interface[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"_setNonRecoverableTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"_transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceSheet\",\"outputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"contract Erc20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralPrecisionScalar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expirationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fintroller\",\"outputs\":[{\"internalType\":\"contract FintrollerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMatured\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonRecoverableTokens\",\"outputs\":[{\"internalType\":\"contract Erc20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionPool\",\"outputs\":[{\"internalType\":\"contract RedemptionPoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract Erc20Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingPrecisionScalar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FyToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000060117ff0000000000000000000000000b66a6c742a326876e1d826d8369a645d2300972600000000000000000000000010fc2350baa7d3690bf6a8d680e9c1fb55d90a7c000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000000000000000000000000000000000000000000014686679555344432028323032312d30312d323729000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d686679555344432d4a414e323100000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e2912551cf7dda107adc783192248d9392b9cf60edb09013658bce45cc015d69"}]}