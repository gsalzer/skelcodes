pragma solidity 0.4.25;contract GenePoolInterface{function isGenePool()public pure returns(bool);function breed(uint256[2] mother,uint256[2] father,uint256 seed)public view returns(uint256[2]);function randomDNA(uint256 seed)public pure returns(uint256[2]);}contract PepeGenePool{function isGenePool()public pure returns(bool){return true;}uint8 private constant R=5;function breed(uint256[2] mother,uint256[2] father,uint256 seed)public view returns(uint256[2] memOffset){assembly{memOffset:=mload(0x40)mstore(0x40,add(memOffset,64))mstore(0x0,seed)mstore(0x20,timestamp)let hash:=keccak256(0,64)function shiftR(value,offset)->result{result:=div(value,exp(2,offset))}function processSide(fatherSrc,motherSrc,rngSrc)->result{{{if eq(and(rngSrc,0x1),0){let temp:=fatherSrc fatherSrc:=motherSrc motherSrc:=temp}rngSrc:=shiftR(rngSrc,1)}let mask:=0 let cap:=0 let crossoverLen:=and(rngSrc,0x7f)rngSrc:=shiftR(rngSrc,7)let crossoverPos:=crossoverLen let crossoverPosLeading1:=1 for{}and(lt(crossoverPos,256),lt(cap,4)){crossoverLen:=and(rngSrc,0x7f)rngSrc:=shiftR(rngSrc,7)crossoverPos:=add(crossoverPos,crossoverLen)cap:=add(cap,1)}{mask:=sub(crossoverPosLeading1,1)crossoverPosLeading1:=mul(1,exp(2,crossoverPos))mask:=xor(mask,sub(crossoverPosLeading1,1))result:=or(result,and(mask,fatherSrc))let temp:=fatherSrc fatherSrc:=motherSrc motherSrc:=temp}mask:=not(sub(crossoverPosLeading1,1))result:=or(result,and(mask,fatherSrc))mstore(0x0,rngSrc)mstore(0x20,0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)let mutations:=and(and(and(keccak256(0,32),keccak256(1,33)),and(keccak256(2,34),keccak256(3,35))),keccak256(0,36))result:=xor(result,mutations)}}{let relativeFatherSideLoc:=mul(and(hash,0x1),0x20)let relativeMotherSideLoc:=mul(and(hash,0x2),0x10)hash:=div(hash,4)mstore(memOffset,processSide(mload(add(father,relativeFatherSideLoc)),mload(add(mother,relativeMotherSideLoc)),hash))relativeFatherSideLoc:=xor(relativeFatherSideLoc,0x20)relativeMotherSideLoc:=xor(relativeMotherSideLoc,0x20)mstore(0x0,seed)mstore(0x20,not(timestamp))hash:=keccak256(0,64)mstore(add(memOffset,0x20),processSide(mload(add(father,relativeFatherSideLoc)),mload(add(mother,relativeMotherSideLoc)),hash))}}}function randomDNA(uint256 seed)public pure returns(uint256[2] memOffset){assembly{memOffset:=mload(0x40)mstore(0x40,add(memOffset,64))mstore(0x0,seed)mstore(0x20,0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21){let hash:=keccak256(0,64)mstore(memOffset,hash)hash:=keccak256(0,32)mstore(add(memOffset,32),hash)}}}}
