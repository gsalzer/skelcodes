{"status":"1","message":"OK","result":[{"SourceCode":"{\"DeFiatEXT_Farming.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport {IERC20, IDungeon} from \\\"./_Interfaces.sol\\\";\\n\\n// File: @defiat-crypto/defiat/blob/master/contracts/XXXXXX.sol\\n/**\\n * @dev Delegated Farming Contract.\\n * Implements a conditoin on the DFT-DFT farming pool for users to generate more rewards\\n */\\ncontract DeFiat_EXTFarming_V2 {\\n    using SafeMath for uint256;\\n\\n    //Structs\\n    struct PoolMetrics {\\n        address stakedToken;\\n        uint256 staked;         // sum of tokens staked in the contract\\n        uint256 stakingFee;     // entry fee\\n        \\n        uint256 stakingPoints;\\n\\n        address rewardToken;\\n        uint256 rewards;        // current rewards in the pool\\n        uint256 totalRewards;\\n\\n        uint256 startTime;      // when the pool opens\\n        uint256 closingTime;    // when the pool closes. \\n        uint256 duration;       // duration of the staking\\n        uint256 lastEvent;      // last time metrics were updated.\\n        \\n        uint256  ratePerToken;  // CALCULATED pool reward Rate per Token (calculated based on total stake and time)\\n        \\n        address DftDungeon;     // used to calculate the DeFiatScore\\n        bool boostedRewards;\\n    }\\n    PoolMetrics public poolMetrics;\\n\\n    struct UserMetrics {\\n        uint256 stake;          // native token stake (balanceOf)\\n        uint256 stakingPoints;  // staking points at lastEvent\\n        uint256 poolPoints;     // pool point at lastEvent\\n        uint256 lastEvent;\\n\\n        uint256 rewardAccrued;  // accrued rewards over time based on staking points\\n        uint256 rewardsPaid;    // for information only\\n\\n        uint256 lastTxBlock;    // latest transaction from the user (antiSpam)\\n    }\\n    mapping(address =\\u003e UserMetrics) public userMetrics;\\n    \\n        address public poolOperator; address public owner;\\n        \\n\\n//== constructor \\n    constructor(address _stakedToken, address _rewardToken, uint256 _feeBase1000, uint256 _durationHours) public {\\n        owner = msg.sender;\\n        poolOperator = msg.sender;\\n        \\n        poolMetrics.stakedToken = address(_stakedToken);\\n        poolMetrics.rewardToken = address(_rewardToken);\\n        poolMetrics.stakingFee = _feeBase1000; //10 = 1%\\n        \\n        poolMetrics.duration = _durationHours.mul(3600); //\\n        poolMetrics.startTime = block.timestamp;\\n        poolMetrics.closingTime = block.timestamp + poolMetrics.duration;\\n        \\n        poolMetrics.stakingPoints = 1; //avoirds div by 0 at start\\n        poolMetrics.boostedRewards = true;\\n    }\\n\\n//==Events\\n    event PoolInitalized(uint256 amountAdded, string  _desc);\\n    event RewardTaken(address indexed user, uint256 reward, string  _desc);\\n\\n    event userStaking(address indexed user, uint256 amount, string  _desc);\\n    event userWithdrawal(address indexed user, uint256 amount, string  _desc);\\n\\n    modifier poolLive() {\\n        require(block.timestamp \\u003e= poolMetrics.startTime,\\\"Pool not started Yet\\\"); //good for delayed starts.\\n        require(block.timestamp \\u003c= poolMetrics.closingTime,\\\"Pool closed\\\"); //good for delayed starts.\\n        _;\\n    }\\n    modifier poolStarted() {\\n        require(block.timestamp \\u003e= poolMetrics.startTime,\\\"Pool not started Yet\\\"); //good for delayed starts.\\n        _;\\n    }\\n    modifier poolEnded() {\\n        require(block.timestamp \\u003e poolMetrics.closingTime,\\\"Pool not ended Yet\\\"); //good for delayed starts.\\n        _;\\n    }\\n    \\n    modifier antiSpam(uint256 _blocks) {\\n        require(block.number \\u003e userMetrics[msg.sender].lastTxBlock.add(_blocks), \\\"Wait X BLOCKS between Transactions\\\");\\n        userMetrics[msg.sender].lastTxBlock = block.number; //update\\n        _;\\n    } \\n    modifier onlyPoolOperator() {\\n        require(msg.sender== poolOperator || msg.sender == owner, \\\"msg.sender is not allowed to operate Pool\\\");\\n        _;\\n    }\\n    modifier onlyOwner() {\\n        require(msg.sender== owner, \\\"Only Owner\\\");\\n        _;\\n    }\\n    modifier antiWhale(address _address) {\\n        require(myStakeShare(_address) \\u003c 20000, \\\"User stake% share too high. Leave some for the smaller guys ;-)\\\"); //max 20%\\n        _;\\n    } \\n    // avoids stakes being deposited once a user reached 20%. \\n    // Simplistic implementation as if we calculate \\\"futureStake\\\" value very 1st stakers will not be able to deposit.\\n    \\n    \\n//==Basics \\n    function currentTime() public view returns (uint256) {\\n        return SafeMath.min(block.timestamp, poolMetrics.closingTime); //allows expiration\\n    } // SafeMath.min(now, endTime)\\n    \\n//==DeFiat Boost\\n    function setDungeon(address _dungeon) public onlyOwner {\\n        poolMetrics.DftDungeon = _dungeon;\\n    }\\n    \\n    /**\\n    * @dev Function gets the amount of DFT in the DFT dungeon farm \\n    * to calculate a score that boosts the StakingRewards calculation\\n    * DFT requirements to get a boost are hard coded into the contract\\n    * 0DFT to 100 DFT staked respectfully generate a 0% to 100% bonus on Staking.\\n    * returned is a number between 50 and 100\\n    */\\n    function viewDftBoost(address _address) public view returns(uint256) {\\n        uint256 _userStake = IDungeon(poolMetrics.DftDungeon).myStake(_address).div(1e18);\\n        return SafeMath.min(200, _userStake.add(100));\\n    }\\n    \\n//==Points locking    \\n    function viewPoolPoints() public view returns(uint256) {\\n        uint256 _previousPoints = poolMetrics.stakingPoints;    // previous points shapshot \\n        uint256 _previousStake = poolMetrics.staked;             // previous stake snapshot\\n        \\n        uint256 _timeHeld = currentTime().sub(\\n                    SafeMath.max(poolMetrics.lastEvent, poolMetrics.startTime)\\n                                                );                 // time held with _previous Event\\n                                                \\n        return  _previousPoints.add(_previousStake.mul(_timeHeld));    //generated points since event\\n    }\\n\\n    function lockPoolPoints() internal returns (uint256) { //ON STAKE/UNSTAKE EVENT\\n        poolMetrics.stakingPoints = viewPoolPoints();\\n        poolMetrics.lastEvent = currentTime();   // update lastStakingEvent\\n        return poolMetrics.stakingPoints;\\n    } \\n    \\n    function viewPointsOf(address _address) public view returns(uint256) {\\n        uint256 _previousPoints = userMetrics[_address].stakingPoints;    \\n        uint256 _previousStake = userMetrics[_address].stake; // boosted stake before event\\n    \\n        uint256 _timeHeld = currentTime().sub(\\n                    SafeMath.max(userMetrics[_address].lastEvent, poolMetrics.startTime)\\n                                                );                          // time held since lastEvent (take RWD, STK, unSTK)\\n        \\n        uint256 _result = _previousPoints.add(_previousStake.mul(_timeHeld));   \\n        \\n        if(_result \\u003e poolMetrics.stakingPoints){_result = poolMetrics.stakingPoints;}\\n        \\n        \\n        return _result;\\n    }\\n\\n    function lockPointsOf(address _address) internal returns (uint256) {\\n        userMetrics[_address].poolPoints = viewPoolPoints();  // snapshot of pool points at lockEvent\\n        userMetrics[_address].stakingPoints = viewPointsOf(_address); \\n        userMetrics[_address].lastEvent = currentTime(); \\n\\n        return userMetrics[_address].stakingPoints;\\n    }\\n\\n    function pointsSnapshot(address _address) public returns (bool) {\\n        lockPointsOf(_address);\\n        lockPoolPoints();\\n        return true;\\n    }\\n     \\n    //==Rewards\\n    function viewTrancheReward(uint256 _period) internal view returns(uint256) {\\n        //uint256 _poolRewards = poolMetrics.rewards; //tokens in the pool. Note: This can be setup to a fixed amount (totalRewards)\\n        uint256 _poolRewards = poolMetrics.totalRewards; \\n        \\n        if(poolMetrics.boostedRewards == false){ _poolRewards = SafeMath.min(poolMetrics.staked, _poolRewards);} \\n        // baseline is the min( staked, rewards); avoids ultra_farming \\u003e staking pool - EXPERIMENTAL\\n        \\n        uint256 _timeRate = _period.mul(1e18).div(poolMetrics.duration);\\n        return _poolRewards.mul(_timeRate).div(1e18); //tranche of rewards on period\\n    }\\n    \\n    function userRateOnPeriod(address _address) public view returns (uint256){\\n        //calculates the delta of pool points and user points since last Event\\n        uint256 _deltaUser = viewPointsOf(_address).sub(userMetrics[_address].stakingPoints); // points generated since lastEvent\\n        uint256 _deltaPool = viewPoolPoints().sub(userMetrics[_address].poolPoints);          // pool points generated since lastEvent\\n        uint256 _rate = 0;\\n        if(_deltaUser == 0 || _deltaPool == 0 ){_rate = 0;} //rounding\\n        else {_rate = _deltaUser.mul(1e18).div(_deltaPool);}\\n        \\n        return viewDftBoost(_address).mul(_rate).div(200); //applies bossted rate on period based on the DFT in the dungeon.\\n    }\\n    \\n    function viewAdditionalRewardOf(address _address) public view returns(uint256) { // rewards generated since last Event\\n        require(poolMetrics.rewards \\u003e 0, \\\"No Rewards in the Pool\\\");\\n        \\n        // user weighted average share of Pool since lastEvent\\n        uint256 _userRateOnPeriod = userRateOnPeriod(_address); //can drop if pool size increases within period -\\u003e slows rewards generation\\n        \\n        // Pool Yield Rate \\n        uint256 _period = currentTime().sub(\\n                            SafeMath.max(userMetrics[_address].lastEvent, poolMetrics.startTime)  \\n                            );        // time elapsed since last reward or pool started (if never taken rewards)\\n\\n        // Calculate reward\\n        uint256 _reward = viewTrancheReward(_period).mul(_userRateOnPeriod).div(1e18);  //user rate on pool rewards\\u0027 tranche\\n\\n        return _reward;\\n    }\\n    \\n    function lockRewardOf(address _address) public returns(uint256) {\\n        uint256 _additional = viewAdditionalRewardOf(_address); //stakeShare(sinceLastEvent) * poolRewards(sinceLastEvent)\\n        userMetrics[_address].rewardAccrued = userMetrics[_address].rewardAccrued.add(_additional); //snapshot rewards.\\n        \\n        pointsSnapshot(_address); //updates lastEvent and points\\n        return userMetrics[_address].rewardAccrued;\\n    }  \\n    \\n    function takeRewards() public poolStarted antiSpam(1) { //1 blocks between rewards\\n        require(poolMetrics.rewards \\u003e 0, \\\"No Rewards in the Pool\\\");\\n        \\n        uint256 _reward = lockRewardOf(msg.sender); //returns already accrued + additional (also resets time counters)\\n\\n        userMetrics[msg.sender].rewardsPaid = _reward;   // update user paid rewards\\n        \\n        userMetrics[msg.sender].rewardAccrued = 0; //flush previously accrued rewards.\\n        \\n        poolMetrics.rewards = poolMetrics.rewards.sub(_reward);           // update pool rewards\\n            \\n        IERC20(poolMetrics.rewardToken).transfer(msg.sender, _reward);  // transfer\\n            \\n        pointsSnapshot(msg.sender); //updates lastEvent\\n        //lockRewardOf(msg.sender);\\n            \\n        emit RewardTaken(msg.sender, _reward, \\\"Rewards Sent\\\");          \\n    }\\n    \\n//==staking \\u0026 unstaking\\n\\n    function stake(uint256 _amount) public poolLive antiSpam(1) antiWhale(msg.sender){\\n        require(_amount \\u003e 0, \\\"Cannot stake 0\\\");\\n        \\n        //initialize\\n        userMetrics[msg.sender].rewardAccrued = lockRewardOf(msg.sender); //Locks previous eligible rewards based on lastRewardEvent and lastStakingEvent\\n        pointsSnapshot(msg.sender);\\n\\n        //receive staked\\n        uint256 _balanceNow = IERC20(address(poolMetrics.stakedToken)).balanceOf(address(this));\\n        IERC20(poolMetrics.stakedToken).transferFrom(msg.sender, address(this), _amount); //will require allowance\\n        uint256 amount = IERC20(address(poolMetrics.stakedToken)).balanceOf(address(this)).sub(_balanceNow); //actually received\\n        \\n        //update pool and user based on stake and fee\\n        uint256 _fee = amount.mul(poolMetrics.stakingFee).div(1000);\\n        amount = amount.sub(_fee);\\n        \\n        if(poolMetrics.stakedToken == poolMetrics.rewardToken){poolMetrics.rewards = poolMetrics.rewards.add(_fee);}\\n        poolMetrics.staked = poolMetrics.staked.add(amount);\\n        userMetrics[msg.sender].stake = userMetrics[msg.sender].stake.add(amount);\\n\\n        //finalize\\n        pointsSnapshot(msg.sender); //updates lastEvent\\n        emit userStaking(msg.sender, amount, \\\"Staking... ... \\\");\\n        \\n    } \\n    \\n    function unStake(uint256 _amount) public poolStarted antiSpam(1) { \\n        require(_amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\n        require(_amount \\u003c= userMetrics[msg.sender].stake, \\\"Cannot withdraw more than stake\\\");\\n\\n        //initialize\\n        userMetrics[msg.sender].rewardAccrued = lockRewardOf(msg.sender); //snapshot of  previous eligible rewards based on lastStakingEvent\\n        pointsSnapshot(msg.sender);\\n\\n        // update metrics\\n        userMetrics[msg.sender].stake = userMetrics[msg.sender].stake.sub(_amount);\\n        poolMetrics.staked = poolMetrics.staked.sub(_amount);\\n\\n        // transfer _amount. Put at the end of the function to avoid reentrancy.\\n        IERC20(poolMetrics.stakedToken).transfer(msg.sender, _amount);\\n        \\n        //finalize\\n        emit userWithdrawal(msg.sender, _amount, \\\"Widhtdrawal\\\");\\n    }\\n\\n    function myStake(address _address) public view returns(uint256) {\\n        return userMetrics[_address].stake;\\n    }\\n\\n    function myStakeShare(address _address) public view returns(uint256) {\\n        if(poolMetrics.staked == 0){return 0;}\\n        else {\\n        return (userMetrics[_address].stake).mul(100000).div(poolMetrics.staked);}\\n    } //base 100,000\\n\\n    function myPointsShare(address _address) public view returns(uint256) {  //weighted average of your stake over time vs the pool\\n        return viewPointsOf(_address).mul(100000).div(viewPoolPoints());\\n    } //base 100,000. Drops when taking rewards.=\\u003e Refills after (favors strong hands)\\n\\n    function myRewards(address _address) public view returns(uint256) {\\n        //delayed start obfuscation (avoids disturbances in the force...)\\n        if(block.timestamp \\u003c= poolMetrics.startTime || poolMetrics.rewards == 0){return 0;}\\n        else { return userMetrics[_address].rewardAccrued.add(viewAdditionalRewardOf(_address));} //previousLock + time based extra\\n    }\\n \\n\\n//== OPERATOR FUNCTIONS ==\\n    \\n    function setBoostedRewards(bool _bool) public onlyPoolOperator {\\n        poolMetrics.boostedRewards = _bool;\\n    }\\n\\n    function loadRewards(uint256 _amount, uint256 _preStake) public onlyPoolOperator { //load tokens in the rewards pool.\\n        \\n        uint256 _balanceNow = IERC20(address(poolMetrics.rewardToken)).balanceOf(address(this));\\n        IERC20(address(poolMetrics.rewardToken)).transferFrom( msg.sender,  address(this),  _amount);\\n        uint256 amount = IERC20(address(poolMetrics.rewardToken)).balanceOf(address(this)).sub(_balanceNow); //actually received\\n        \\n\\n        if(poolMetrics.rewards == 0){                                   // initialization\\n        poolMetrics.staked = SafeMath.add(poolMetrics.staked,_preStake);}  // creates baseline for pool. Avoids massive movements on rewards\\n        \\n        poolMetrics.rewards = SafeMath.add(poolMetrics.rewards,amount);\\n        poolMetrics.totalRewards = poolMetrics.totalRewards.add(_amount);\\n    }    \\n    \\n    function flushPool(address _recipient, address _ERC20address) external onlyPoolOperator poolEnded {\\n        uint256 _amount = IERC20(_ERC20address).balanceOf(address(this));\\n        IERC20(_ERC20address).transfer(_recipient, _amount); //use of the _ERC20 traditional transfer\\n        //return true;\\n    } //get tokens sent by error to contract\\n\\n    function setPoolOperator(address _address) public onlyPoolOperator {\\n        poolOperator = _address;\\n    }\\n    \\n    function setFee(uint256 _fee) public onlyOwner {\\n        poolMetrics.stakingFee = _fee;\\n    }\\n    \\n    function killPool() public onlyOwner poolEnded returns(bool) {\\n        selfdestruct(msg.sender);\\n    } //frees space on the ETH chain\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// File: @openzeppelin/contracts/math/Math.sol\\n//\\n\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\npragma solidity ^0.6.0;\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath{\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n    \\n        /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\"},\"_Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IDungeon {\\n    function myStake(address _address) external view returns(uint256);\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBase1000\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_durationHours\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"PoolInitalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"RewardTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"userStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"userWithdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ERC20address\",\"type\":\"address\"}],\"name\":\"flushPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_preStake\",\"type\":\"uint256\"}],\"name\":\"loadRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lockRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myPointsShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myStakeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"pointsSnapshot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolMetrics\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastEvent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratePerToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"DftDungeon\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"boostedRewards\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setBoostedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dungeon\",\"type\":\"address\"}],\"name\":\"setDungeon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPoolOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMetrics\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastEvent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTxBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"userRateOnPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewAdditionalRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewDftBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewPointsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DeFiat_EXTFarming_V2","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b469899812f74ee43bffe2d2022590111da864250000000000000000000000009a7a4c141a3bcce4a31e42c1192ac6add35069b40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2131e5f6f85019179498cb6df8d7b124b50da1f0e8386b0c85fa70690eb221a8"}]}