{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/*\r\nGet up 5 % profit every month with a contract Cloud Mining!\r\n*\r\n* - lifetime payments\r\n* - unprecedentedly reliable\r\n* - bring luck\r\n* - first minimum contribution from 0.1 eth, all next from 0.01 eth\r\n* - Currency and Payment - ETH\r\n* - Contribution allocation schemes:\r\n* - 100% of payments - only 6% percent for support and 3% percent referral system!\r\n* \r\n*\r\n* RECOMMENDED GAS LIMIT: 200,000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* DO NOT TRANSFER DIRECTLY FROM AN EXCHANGE (only use your ETH wallet, from which you have a private key)\r\n* You can check payments on the website etherscan.io, in the “Internal Txns” tab of your wallet.\r\n*\r\n*@FOR USER'S:\r\n* This smart contract is a public offer.\r\n* In accordance with the law on digital assets adopted in the Russian Federation, \r\n* we bother you that you perform all actions in a smart contract exclusively independently and at your own peril and risk.\r\n* The developers are not responsible for your actions.\r\n* By submitting your digital assets to a smart contract, you agree to this offer.\r\n* How to use:\r\n* 1. Send from your ETH wallet to the address of the smart contract\r\n* any amount first from 0.1 ETH and all next from 0.01 ETH.\r\n* 2. Confirm your transaction in the history of your application or etherscan.io, indicating the address of your wallet.\r\n* Take profit by sending 0 eth to contract (profit is calculated every second).\r\n*\r\n*@DEV https://github.com/alexburndev/miningmasters/blob/main/cloudmining.sol\r\n**/\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract CloudMinig_byMiningMasters \r\n{\r\n    using SafeMath for uint256;\r\n    \r\n    address payable public owner = 0x1a08070FFE5695aB0Eb4612640EeC11bf2Cf58eE;\r\n    address payable public addressSupportProject = 0x009AE8DDCBF8aba5b04d49d034146A6b8E3a8B0a;\r\n    address payable public addressAdverstingProject = 0x54a39674A0c22Cb2f9022f285b366a4f4d525266;\r\n    \r\n\r\n    \r\n    uint p;\r\n    uint d = 100;\r\n    uint p0 = 2;\r\n    uint p1 = 3;\r\n    uint p2 = 4;\r\n    uint p3 = 5;\r\n    uint refer = 3;\r\n    uint sup = 3;\r\n    uint adv;\r\n    \r\n    struct InvestorData {\r\n        uint256 funds;\r\n        uint256 lastDatetime;\r\n        uint256 totalProfit;\r\n    }\r\n    mapping (address => InvestorData) investors;\r\n    \r\n    modifier onlyOwner()\r\n    {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function withdraw(uint256 amount)  public onlyOwner {\r\n        owner.transfer(amount);\r\n    }\r\n    \r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n  \r\n    \r\n    function SetProcp0 (uint _p0, uint _d) public onlyOwner {\r\n        p0 = _p0;\r\n        if (_d == 0) d = 100;\r\n    }\r\n    \r\n    function SetProcp1 (uint _p1, uint _d) public onlyOwner {\r\n        p1 = _p1;\r\n        if (_d == 0) d = 100;\r\n    }\r\n    \r\n    function SetProcp2 (uint _p2, uint _d) public onlyOwner {\r\n        p2 = _p2;\r\n        if (_d == 0) d = 100;\r\n    }\r\n    \r\n    function SetProcp3 (uint _p3, uint _d) public onlyOwner {\r\n        p3 = _p3;\r\n        if (_d == 0) d = 100;\r\n    }\r\n    \r\n    \r\n    function SetProcrefer (uint _refer, uint _d) public onlyOwner {\r\n        refer = _refer;\r\n        if (_d == 0) d = 100;\r\n    }\r\n    \r\n    function ChangeAdverstingProject (address payable _NewAddress) public onlyOwner {\r\n       addressAdverstingProject = _NewAddress;\r\n    }\r\n    \r\n    function ChangeAddressSupport (address payable _NewAddress) public onlyOwner {\r\n       addressSupportProject = _NewAddress;\r\n    }\r\n \r\n    \r\n    \r\n    function itisnecessary() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n        selfdestruct(owner);\r\n    }    \r\n    \r\n    function addInvestment( uint investment, address payable investorAddr) public onlyOwner  {\r\n        investorAddr.transfer(investment);\r\n    } \r\n  \r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address payable addr) {\r\n        assembly {\r\n          addr := mload(add(bys,20))\r\n        } \r\n    }\r\n    \r\n    \r\n    \r\n    function getInfo(address investor) view public returns (uint256 totalFunds, uint256 pendingReward, \r\n    uint256 totalProfit )\r\n    {\r\n        InvestorData memory data = investors[investor];\r\n        totalFunds = data.funds;\r\n        if (data.funds > 0) pendingReward = data.funds.mul(p).div(d).mul(block.timestamp - data.lastDatetime).div(30 days);\r\n        totalProfit = data.totalProfit;\r\n       }\r\n    \r\n    function() payable external\r\n    {\r\n        assert(msg.sender == tx.origin); // prevent bots to interact with contract\r\n        \r\n        if (msg.sender == owner) return;\r\n        \r\n        \r\n        \r\n        InvestorData storage data = investors[msg.sender];\r\n        \r\n        if (msg.value > 0) \r\n        \r\n        {\r\n            // first investment at least 0.1 ether, all next at least 0.01 ether\r\n          assert(msg.value >= 0.1 ether || (data.funds != 0 && msg.value >= 0.01 ether));\r\n          if (msg.data.length == 20) {\r\n            address payable ref = bytesToAddress(msg.data);\r\n            assert(ref != msg.sender);\r\n            ref.transfer(msg.value.mul(refer).div(100));   // 3%\r\n            addressAdverstingProject.transfer(msg.value.mul(100-refer-sup-10).div(d));\r\n               \r\n            } else if (msg.data.length == 0) {\r\n               \r\n                addressAdverstingProject.transfer(msg.value.mul(100-sup-10).div(d));\r\n            }\r\n            \r\n            addressSupportProject.transfer(msg.value.mul(sup).div(d));\r\n            \r\n            \r\n        }\r\n        \r\n      \r\n          \r\n       \r\n        \r\n      if (data.funds < 10 ether) {\r\n          p = p0;\r\n      \r\n       } else if ( 10 ether <= data.funds && data.funds < 30 ether) {\r\n           p = p1;\r\n       } else if ( 30 ether <= data.funds && data.funds < 50 ether) {\r\n           p = p2;\r\n       } else if ( data.funds >=50 ether) {\r\n           p = p3;\r\n       }\r\n        \r\n          \r\n        \r\n        if (data.funds != 0) {\r\n            // % per 30 days\r\n            uint256 reward = data.funds.mul(p).div(d).mul(block.timestamp - data.lastDatetime).div(30 days);\r\n            data.totalProfit = data.totalProfit.add(reward);\r\n            \r\n            address(msg.sender).transfer(reward);\r\n        }\r\n\r\n        data.lastDatetime = block.timestamp;\r\n        data.funds = data.funds.add(msg.value.mul(94).div(100));\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function getrewardInfo(address investor) view public returns (uint256 totalFunds, uint256 pendingReward, \r\n    uint256 totalProfit,uint _yourProcent)\r\n    \r\n    {\r\n        InvestorData memory data = investors[investor];\r\n        totalFunds = data.funds;\r\n         _yourProcent = p;\r\n        if (data.funds > 0) pendingReward = data.funds.mul(p).div(d).mul(block.timestamp - data.lastDatetime).div(30 days);\r\n        totalProfit = data.totalProfit;\r\n     \r\n    }    \r\n        \r\n        \r\n        \r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"itisnecessary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_p2\",\"type\":\"uint256\"},{\"name\":\"_d\",\"type\":\"uint256\"}],\"name\":\"SetProcp2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_NewAddress\",\"type\":\"address\"}],\"name\":\"ChangeAdverstingProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getrewardInfo\",\"outputs\":[{\"name\":\"totalFunds\",\"type\":\"uint256\"},{\"name\":\"pendingReward\",\"type\":\"uint256\"},{\"name\":\"totalProfit\",\"type\":\"uint256\"},{\"name\":\"_yourProcent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_p0\",\"type\":\"uint256\"},{\"name\":\"_d\",\"type\":\"uint256\"}],\"name\":\"SetProcp0\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"addInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_p1\",\"type\":\"uint256\"},{\"name\":\"_d\",\"type\":\"uint256\"}],\"name\":\"SetProcp1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressSupportProject\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refer\",\"type\":\"uint256\"},{\"name\":\"_d\",\"type\":\"uint256\"}],\"name\":\"SetProcrefer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressAdverstingProject\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_p3\",\"type\":\"uint256\"},{\"name\":\"_d\",\"type\":\"uint256\"}],\"name\":\"SetProcp3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_NewAddress\",\"type\":\"address\"}],\"name\":\"ChangeAddressSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"totalFunds\",\"type\":\"uint256\"},{\"name\":\"pendingReward\",\"type\":\"uint256\"},{\"name\":\"totalProfit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CloudMinig_byMiningMasters","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bb492e37d1dd47e002d7d126a378d2102f769c0fd511ec637319fabce75959bc"}]}