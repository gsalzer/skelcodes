{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IOneSplitMini.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\ncontract IOneSplit {\\n    function getExpectedReturn(\\n        IERC20 fromToken,\\n        IERC20 destToken,\\n        //address fromToken,\\n        //address destToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 flags // See constants in IOneSplit.sol\\n    )\\n        public\\n        view\\n        returns(\\n            uint256 returnAmount,\\n            uint256[] memory distribution\\n        );\\n\\n    function getExpectedReturnWithGas(\\n        IERC20 fromToken,\\n        IERC20 destToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 flags, // See constants in IOneSplit.sol\\n        uint256 destTokenEthPriceTimesGasPrice\\n    )\\n        public\\n        view\\n        returns(\\n            uint256 returnAmount,\\n            uint256 estimateGasAmount,\\n            uint256[] memory distribution\\n        );\\n\\n    function swap(\\n        IERC20 fromToken,\\n        IERC20 destToken,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] memory distribution,\\n        uint256 flags\\n    )\\n        public\\n        payable\\n        returns(uint256 returnAmount);\\n}\"},\"testSplit.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IOneSplitMini.sol\\\";\\n\\ncontract OneSplitTest {\\n\\naddress constant oneSplitEth = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\\n//address public oneSplitProto = 0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e;\\n\\n//address public fromToken = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\\n//address public toToken = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\\n\\n\\n//IERC20 public fromIERC20 = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n//IERC20 public toIERC20 = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\\n//amount = 1e18\\n    \\n    /*\\n    function testSplit(address OneSplitAddr, address fromToken, address toToken, uint amount) public view returns (uint) {\\n        \\n        IERC20 fromIERC20 = IERC20(fromToken);\\n        IERC20 toIERC20 = IERC20(toToken);\\n\\n        (uint256 returnAmount0,) = IOneSplit(OneSplitAddr).getExpectedReturn(fromIERC20, toIERC20, amount, 100, 0 );\\n        \\n        return returnAmount0;\\n        \\n    }*/\\n    \\n    function testChange(address fromToken, address toToken, uint amount) external returns (uint) {\\n        \\n        IERC20 fromIERC20 = IERC20(fromToken);\\n        IERC20 toIERC20 = IERC20(toToken);\\n\\n        IERC20(fromToken).transferFrom(msg.sender, address(this), amount);\\n        \\n        (, uint256[] memory distribution) = IOneSplit(oneSplitEth).getExpectedReturn(fromIERC20, toIERC20, amount, 100, 0 );\\n        \\n        uint returnAmount = IOneSplit(oneSplitEth).swap(fromIERC20, toIERC20, amount, 0, distribution, 0);\\n        \\n        IERC20(toToken).transfer(msg.sender, returnAmount);\\n        \\n        return returnAmount;\\n    }\\n    \\n    \\n    function transferTokenBack(address TokenAddress) external returns (uint256){\\n        IERC20 Token = IERC20(TokenAddress);\\n        uint256 balance = Token.balanceOf(address(this));\\n        bool result = Token.transfer(msg.sender, balance);\\n        \\n        if (!result) { \\n            balance = 0;\\n        }\\n        \\n        return balance;\\n    }\\n    \\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"fromToken\",\"type\":\"address\"},{\"name\":\"toToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"testChange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TokenAddress\",\"type\":\"address\"}],\"name\":\"transferTokenBack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OneSplitTest","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://286996e0e48847aa57e2cf9d9803518637ec55da6142da96cc48df9d257efe9a"}]}