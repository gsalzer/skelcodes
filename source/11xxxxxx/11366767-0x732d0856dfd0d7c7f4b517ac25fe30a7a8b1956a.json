{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/contracts/gelato/ProviderModuleDSA.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\n// solhint-disable\\n\\nenum Operation {Call, Delegatecall}\\n\\nenum DataFlow {None, In, Out, InAndOut}\\n\\ninterface IGelatoCondition {\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(\\n        uint256 _taskReceiptId,\\n        bytes calldata _conditionData,\\n        uint256 _cycleId\\n    ) external view returns (string memory);\\n}\\n\\nstruct Condition {\\n    IGelatoCondition inst; // can be AddressZero for self-conditional Actions\\n    bytes data; // can be bytes32(0) for self-conditional Actions\\n}\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions; // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit; // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil; // optional: 0 defaults to NO_CEIL\\n}\\n\\ninterface IGelatoProviderModule {\\n    /// @notice Check if provider agrees to pay for inputted task receipt\\n    /// @dev Enables arbitrary checks by provider\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @return \\\"OK\\\" if provider agrees\\n    function isProvided(\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task\\n    ) external view returns (string memory);\\n\\n    /// @notice Convert action specific payload into proxy specific payload\\n    /// @dev Encoded multiple actions into a multisend\\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\\n    /// @return Encoded payload that will be used for low-level .call on user proxy\\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\\n    function execPayload(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task,\\n        uint256 _cycleId\\n    ) external view returns (bytes memory, bool checkReturndata);\\n\\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\\n}\\n\\nabstract contract GelatoProviderModuleStandard is IGelatoProviderModule {\\n    string internal constant OK = \\\"OK\\\";\\n\\n    function isProvided(\\n        address,\\n        address,\\n        Task calldata\\n    ) external view virtual override returns (string memory) {\\n        return OK;\\n    }\\n\\n    /// @dev Overriding fns should revert with the revertMsg they detected on the userProxy\\n    function execRevertCheck(bytes calldata) external pure virtual override {\\n        // By default no reverts detected => do nothing\\n    }\\n}\\n\\n/// @dev InstaDapp Index\\ninterface IndexInterface {\\n    function connectors(uint256 version) external view returns (address);\\n\\n    function list() external view returns (address);\\n}\\n\\n/// @dev InstaDapp List\\ninterface ListInterface {\\n    function accountID(address _account) external view returns (uint64);\\n}\\n\\n/// @dev InstaDapp Connectors\\ninterface ConnectorsInterface {\\n    function isConnector(address[] calldata logicAddr)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isStaticConnector(address[] calldata logicAddr)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\n/// @dev InstaDapp Defi Smart Account wallet\\ninterface AccountInterface {\\n    function version() external view returns (uint256);\\n\\n    function isAuth(address user) external view returns (bool);\\n\\n    function shield() external view returns (bool);\\n\\n    function cast(\\n        address[] calldata _targets,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32[] memory responses);\\n}\\n\\ncontract ProviderModuleDSA is GelatoProviderModuleStandard {\\n    IndexInterface public immutable index;\\n    address public immutable gelatoCore;\\n\\n    constructor(IndexInterface _index, address _gelatoCore) {\\n        index = _index;\\n        gelatoCore = _gelatoCore;\\n    }\\n\\n    // ================= GELATO PROVIDER MODULE STANDARD ================\\n    function isProvided(\\n        address _userProxy,\\n        address,\\n        Task calldata\\n    ) external view override returns (string memory) {\\n        // Verify InstaDapp account identity\\n        if (ListInterface(index.list()).accountID(_userProxy) == 0)\\n            return \\\"ProviderModuleDSA.isProvided:InvalidUserProxy\\\";\\n\\n        // Is GelatoCore authorized\\n        if (!AccountInterface(_userProxy).isAuth(gelatoCore))\\n            return \\\"ProviderModuleDSA.isProvided:GelatoCoreNotAuth\\\";\\n\\n        // @dev commented out for gas savings\\n\\n        // // Is connector valid\\n        // ConnectorsInterface connectors = ConnectorsInterface(index.connectors(\\n        //     AccountInterface(_userProxy).version()\\n        // ));\\n\\n        // address[] memory targets = new address[](_task.actions.length);\\n        // for (uint i = 0; i < _task.actions.length; i++)\\n        //     targets[i] = _task.actions[i].addr;\\n\\n        // bool isShield = AccountInterface(_userProxy).shield();\\n        // if (isShield)\\n        //     if (!connectors.isStaticConnector(targets))\\n        //         return \\\"ProviderModuleDSA.isProvided:not-static-connector\\\";\\n        // else\\n        //     if (!connectors.isConnector(targets))\\n        //         return \\\"ProviderModuleDSA.isProvided:not-connector\\\";\\n\\n        return OK;\\n    }\\n\\n    /// @dev DS PROXY ONLY ALLOWS DELEGATE CALL for single actions, that's why we also use multisend\\n    function execPayload(\\n        uint256,\\n        address,\\n        address,\\n        Task calldata _task,\\n        uint256\\n    ) external view override returns (bytes memory payload, bool) {\\n        address[] memory targets = new address[](_task.actions.length);\\n        for (uint256 i = 0; i < _task.actions.length; i++)\\n            targets[i] = _task.actions[i].addr;\\n\\n        bytes[] memory datas = new bytes[](_task.actions.length);\\n        for (uint256 i = 0; i < _task.actions.length; i++)\\n            datas[i] = _task.actions[i].data;\\n\\n        payload = abi.encodeWithSelector(\\n            AccountInterface.cast.selector,\\n            targets,\\n            datas,\\n            gelatoCore\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IndexInterface\",\"name\":\"_index\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gelatoCore\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IGelatoCondition\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task\",\"name\":\"_task\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"execPayload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"execRevertCheck\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelatoCore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"internalType\":\"contract IndexInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IGelatoCondition\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"isProvided\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProviderModuleDSA","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002971adfa57b20e5a416ae5a708a8655a9c74f723000000000000000000000000025030bdaa159f281cae63873e68313a703725a5","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}