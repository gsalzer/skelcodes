{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/travis/Documents/Ubuntu_Shared/misc-frax-contracts/contracts/IFraxPartial.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.7;\\n\\ninterface IFraxPartial {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function owner_address() external returns (address);\\n    function creator_address() external returns (address);\\n    function timelock_address() external returns (address);\\n    function controller_address() external returns (address);\\n    function fxs_address() external returns (address);\\n    function frax_eth_oracle_address() external returns (address);\\n    function fxs_eth_oracle_address() external returns (address);\\n    function weth_address() external returns (address);\\n    function eth_usd_consumer_address() external returns (address);\\n\\n    function genesis_supply() external returns (uint256);\\n    function frax_pools_array() external returns (address[] memory);\\n\\n    function frax_pools(address a) external returns (bool);\\n    function global_collateral_ratio() external returns (uint256);\\n    function redemption_fee() external returns (uint256);\\n    function minting_fee() external returns (uint256);\\n    function frax_step() external returns (uint256);\\n    function refresh_cooldown() external returns (uint256);\\n    function price_target() external returns (uint256);\\n    function price_band() external returns (uint256);\\n\\n    function DEFAULT_ADMIN_ADDRESS() external returns (address);\\n    function COLLATERAL_RATIO_PAUSER() external returns (bytes32);\\n    function collateral_ratio_paused() external returns (bool);\\n    function last_call_time() external returns (uint256);\\n    \\n    /* ========== VIEWS ========== */\\n    function frax_price() external returns (uint256);\\n    function fxs_price()  external returns (uint256);\\n    function eth_usd_price() external returns (uint256);\\n    function frax_info() external returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256);\\n    function globalCollateralValue() external returns (uint256);\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n    function refreshCollateralRatio() external;\\n}\"\r\n    },\r\n    \"/home/travis/Documents/Ubuntu_Shared/misc-frax-contracts/contracts/IFraxPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.7;\\n\\ninterface IFraxPool {\\n    function minting_fee() external returns (uint256);\\n    function redemption_fee() external returns (uint256);\\n    function buyback_fee() external returns (uint256);\\n    function recollat_fee() external returns (uint256);\\n    function collatDollarBalance() external returns (uint256);\\n    function availableExcessCollatDV() external returns (uint256);\\n    function getCollateralPrice() external returns (uint256);\\n    function setCollatETHOracle(address _collateral_weth_oracle_address, address _weth_address) external;\\n    function mint1t1FRAX(uint256 collateral_amount, uint256 FRAX_out_min) external;\\n    function mintAlgorithmicFRAX(uint256 fxs_amount_d18, uint256 FRAX_out_min) external;\\n    function mintFractionalFRAX(uint256 collateral_amount, uint256 fxs_amount, uint256 FRAX_out_min) external;\\n    function redeem1t1FRAX(uint256 FRAX_amount, uint256 COLLATERAL_out_min) external;\\n    function redeemFractionalFRAX(uint256 FRAX_amount, uint256 FXS_out_min, uint256 COLLATERAL_out_min) external;\\n    function redeemAlgorithmicFRAX(uint256 FRAX_amount, uint256 FXS_out_min) external;\\n    function collectRedemption() external;\\n    function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external;\\n    function buyBackFXS(uint256 FXS_amount, uint256 COLLATERAL_out_min) external;\\n    function toggleMinting() external;\\n    function toggleRedeeming() external;\\n    function toggleRecollateralize() external;\\n    function toggleBuyBack() external;\\n    function toggleCollateralPrice(uint256 _new_price) external;\\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external;\\n    function setTimelock(address new_timelock) external;\\n    function setOwner(address _owner_address) external;\\n}\"\r\n    },\r\n    \"/home/travis/Documents/Ubuntu_Shared/misc-frax-contracts/contracts/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.7;\\n\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"/home/travis/Documents/Ubuntu_Shared/misc-frax-contracts/contracts/IWETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\ncontract IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\"\r\n    },\r\n    \"/home/travis/Documents/Ubuntu_Shared/misc-frax-contracts/contracts/StakingUtilities.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport './IUniswapV2Router02.sol';\\nimport './IFraxPool.sol';\\nimport './IFraxPartial.sol';\\nimport './IWETH.sol';\\n\\n\\ncontract StakingUtilities {\\n    using SafeMath for uint256;\\n    address constant private USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address constant private WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address constant private FRAX_ADDRESS = 0x853d955aCEf822Db058eb8505911ED77F175b99e;\\n    address constant private FXS_ADDRESS = 0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0;\\n    address payable constant public UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public POOL_ADDRESS = 0x1864Ca3d47AaB98Ee78D11fc9DCC5E7bADdA1c0d;\\n    address public NULL_ADDRESS = 0x0000000000000000000000000000000000000000;\\n\\n    IERC20 constant internal USDC_ERC20 = IERC20(USDC_ADDRESS);\\n    IERC20 constant internal WETH_ERC20 = IERC20(WETH_ADDRESS);\\n    IERC20 constant internal FRAX_ERC20 = IERC20(FRAX_ADDRESS);\\n    IERC20 constant internal FXS_ERC20 = IERC20(FXS_ADDRESS);\\n    IERC20 constant internal ETH_ERC20 = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    IWETH constant internal WETH_IWETH = IWETH(WETH_ADDRESS);\\n\\n    IFraxPool internal FRAX_POOL = IFraxPool(POOL_ADDRESS);\\n    IFraxPartial internal FRAX = IFraxPartial(FRAX_ADDRESS);\\n\\n    IUniswapV2Router02 constant internal UniswapV2Router02 = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\\n\\n    address public owner_address;\\n    \\n    address payable public owner_address_payable;\\n    bool public is_paused;\\n    uint256 public minting_fee;\\n    uint256 private missing_decimals;\\n    uint256 public ADD_LIQUIDITY_SLIPPAGE = 970; // will be .div(1000)\\n\\n    // Super jank\\n    mapping(uint256 => address[]) PATHS; \\n\\n    struct MintFF_Params {\\n        uint256 fxs_price_usd; \\n        uint256 col_price_usd;\\n        uint256 fxs_amount;\\n        uint256 collateral_amount;\\n        uint256 col_ratio;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner_address, \\\"Only the contract owner may perform this action\\\");\\n        _;\\n    }\\n\\n    modifier notPaused {\\n        require(is_paused == false, \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor () public {\\n        owner_address = msg.sender;\\n        owner_address_payable = msg.sender;\\n        is_paused = false;\\n        PATHS[0] = [WETH_ADDRESS, USDC_ADDRESS];\\n        PATHS[1] = [WETH_ADDRESS, FRAX_ADDRESS, FXS_ADDRESS];\\n        minting_fee = FRAX_POOL.minting_fee();\\n        missing_decimals = 12; // manually set for USDC now\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    // Must be internal because of the struct\\n    function calcMintFractionalFRAX(MintFF_Params memory params) public view returns (uint256, uint256) {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint FRAX. We do this by seeing the minimum mintable FRAX based on each amount \\n        uint256 fxs_dollar_value_d18;\\n        uint256 c_dollar_value_d18;\\n        \\n        // Scoping for stack concerns\\n        {    \\n            // USD amounts of the collateral and the FXS\\n            fxs_dollar_value_d18 = params.fxs_amount.mul(params.fxs_price_usd).div(1e6);\\n            c_dollar_value_d18 = params.collateral_amount.mul(params.col_price_usd).div(1e6);\\n\\n        }\\n        uint calculated_fxs_dollar_value_d18 = \\n                    (c_dollar_value_d18.mul(1e6).div(params.col_ratio))\\n                    .sub(c_dollar_value_d18);\\n\\n        uint fxs_needed = calculated_fxs_dollar_value_d18.mul(1e6).div(params.fxs_price_usd);\\n\\n        uint mint_amount = c_dollar_value_d18.add(calculated_fxs_dollar_value_d18);\\n        mint_amount = (mint_amount.mul(uint(1e6).sub(minting_fee))).div(1e6);\\n\\n        return (\\n            mint_amount,\\n            fxs_needed\\n        );\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n\\n    function mintFRAXWrapper(\\n        uint256 input_collat,\\n        uint256 input_fxs,\\n        uint256 frax_out_min\\n    ) public returns (uint256 [2] memory)\\n    {\\n        uint256 collateral_amount_d18 = input_collat * (10 ** missing_decimals);\\n\\n        MintFF_Params memory input_params = MintFF_Params(\\n            FRAX.fxs_price(),\\n            FRAX_POOL.getCollateralPrice(),\\n            input_fxs,\\n            collateral_amount_d18,\\n            FRAX.global_collateral_ratio()\\n        );\\n\\n        (uint256 mint_amount, uint256 fxs_needed) = calcMintFractionalFRAX(input_params);\\n\\n        require(input_fxs >= fxs_needed, \\\"input_fxs >= fxs_needed\\\");\\n\\n        require(mint_amount >= frax_out_min, \\\"Not enough FRAX minted\\\");\\n\\n        // Approve FXS for FraxPool\\n        IERC20(FXS_ADDRESS).approve(POOL_ADDRESS, fxs_needed);\\n\\n        // Approve USDC for FraxPool\\n        IERC20(USDC_ADDRESS).approve(POOL_ADDRESS, input_collat);\\n\\n        // Mint\\n        FRAX_POOL.mintFractionalFRAX(input_collat, fxs_needed, mint_amount);\\n\\n        return [mint_amount, fxs_needed];\\n    }\\n\\n    function FXS_To_USDC(\\n        uint256 FXS_for_USDC_swap,\\n        uint256 col_out_min\\n    ) public returns (uint256)\\n    {\\n        address[] memory FXS_FRAX_USDC_PATH = new address[](3);\\n        FXS_FRAX_USDC_PATH[0] = FXS_ADDRESS;\\n        FXS_FRAX_USDC_PATH[1] = FRAX_ADDRESS;\\n        FXS_FRAX_USDC_PATH[2] = USDC_ADDRESS;\\n\\n        // Do the swap\\n        (uint[] memory amounts) = UniswapV2Router02.swapExactTokensForTokens(\\n            FXS_for_USDC_swap,\\n            col_out_min,\\n            FXS_FRAX_USDC_PATH,\\n            address(this),\\n            2105300114 // A long time from now\\n        );\\n\\n        // Make sure enough USDC was received\\n        require(amounts[2] >= col_out_min, \\\"FXS_To_USDC: Not enough USDC received from swap\\\");\\n\\n        return (amounts[2]);\\n    }\\n\\n    function FXS_To_WETH(\\n        uint256 FXS_for_WETH_swap,\\n        uint256 weth_out_min\\n    ) public returns (uint256)\\n    {\\n        address[] memory FXS_FRAX_WETH_PATH = new address[](3);\\n        FXS_FRAX_WETH_PATH[0] = FXS_ADDRESS;\\n        FXS_FRAX_WETH_PATH[1] = FRAX_ADDRESS;\\n        FXS_FRAX_WETH_PATH[2] = WETH_ADDRESS;\\n\\n        // Do the swap\\n        (uint[] memory amounts) = UniswapV2Router02.swapExactTokensForTokens(\\n            FXS_for_WETH_swap,\\n            weth_out_min,\\n            FXS_FRAX_WETH_PATH,\\n            address(this),\\n            2105300114 // A long time from now\\n        );\\n\\n        // Make sure enough WETH was received\\n        require(amounts[2] >= weth_out_min, \\\"FXS_To_WETH: Not enough WETH received from swap\\\");\\n\\n        return (amounts[2]);\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    // Assumes a FRAX_USDC LP \\n    // INPUT_PARAMS[0] uint256 FXS_total_input\\n    // INPUT_PARAMS[1] uint256 FXS_for_mint\\n    // INPUT_PARAMS[2] uint256 FXS_for_USDC_swap\\n    // INPUT_PARAMS[3] uint256 col_out_min\\n    // INPUT_PARAMS[4] uint256 col_allocated_for_mint_slipped\\n    // INPUT_PARAMS[5] uint256 frax_out_min\\n    function swapFXSForFRAXUSDCLP(\\n        uint256[] calldata INPUT_PARAMS\\n    ) external payable notPaused {\\n\\n        // =================== Pull in the needed FXS ===================\\n        IERC20(FXS_ADDRESS).transferFrom(msg.sender, address(this), INPUT_PARAMS[0]);\\n\\n        // =================== Approve FXS for Uniswap ===================\\n        IERC20(FXS_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, INPUT_PARAMS[0]);\\n\\n        // =================== FXS -> USDC via Uniswap ===================\\n        (uint256 received_USDC) = FXS_To_USDC(INPUT_PARAMS[2], INPUT_PARAMS[3]);\\n\\n        // =================== Estimate and mint the FRAX component ===================\\n        // (uint256 mint_amount, uint256 fxs_needed )\\n        uint256[2] memory mint_results = mintFRAXWrapper(INPUT_PARAMS[4], INPUT_PARAMS[1], INPUT_PARAMS[5]);\\n\\n        // =================== Add Liquidity ===================\\n\\n        // Approve FRAX for Uniswap\\n        IERC20(FRAX_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, mint_results[0]);\\n\\n        // Approve USDC for Uniswap\\n        IERC20(USDC_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, received_USDC);\\n\\n        // Add liquidity and send the token to the sender \\n        (uint256 lp_frax_used, uint256 lp_usdc_used, ) = UniswapV2Router02.addLiquidity(\\n\\t\\t\\tFRAX_ADDRESS, \\n\\t\\t\\tUSDC_ADDRESS,\\n\\t\\t\\tmint_results[0], \\n\\t\\t\\tmint_results[0].div(1e12), \\n            mint_results[0].mul(ADD_LIQUIDITY_SLIPPAGE).div(1000),\\n            mint_results[0].mul(ADD_LIQUIDITY_SLIPPAGE).div(1e15), // div(1e12).mul(ADD_LIQUIDITY_SLIPPAGE).div(1e3)\\n            msg.sender,\\n            2105300114 // A long time from now\\n\\t\\t);\\n\\n        // Return unused FRAX to sender.\\n        FRAX_ERC20.transfer(msg.sender, mint_results[0].sub(lp_frax_used));\\n\\n        // Return unused USDC to sender.\\n        USDC_ERC20.transfer(msg.sender, received_USDC.sub(INPUT_PARAMS[4]).sub(lp_usdc_used));\\n\\n        // Return unused FXS to sender.\\n        FXS_ERC20.transfer(msg.sender, INPUT_PARAMS[0].sub(INPUT_PARAMS[2]).sub(mint_results[1]));\\n\\n    }\\n\\n    // Assumes a FRAX_WETH LP \\n    // INPUT_PARAMS[0] uint256 FXS_total_input\\n    // INPUT_PARAMS[1] uint256 FXS_for_mint\\n    // INPUT_PARAMS[2] uint256 FXS_for_col_swap\\n    // INPUT_PARAMS[3] uint256 col_out_min\\n    // INPUT_PARAMS[4] uint256 FXS_for_WETH_swap\\n    // INPUT_PARAMS[5] uint256 weth_out_min\\n    // INPUT_PARAMS[6] uint256 frax_out_min\\n    function swapFXSForFRAXWETHLP(\\n        uint256[] calldata INPUT_PARAMS\\n    ) external payable notPaused {\\n\\n        // =================== Pull in the needed FXS ===================\\n        IERC20(FXS_ADDRESS).transferFrom(msg.sender, address(this), INPUT_PARAMS[0]);\\n\\n        // =================== Approve FXS for Uniswap ===================\\n        IERC20(FXS_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, INPUT_PARAMS[0]);\\n\\n        // =================== FXS -> USDC via Uniswap ===================\\n        (uint256 received_USDC) = FXS_To_USDC(INPUT_PARAMS[2], INPUT_PARAMS[3]);\\n\\n        // =================== FXS -> WETH via Uniswap ===================\\n        (uint256 received_WETH) = FXS_To_WETH(INPUT_PARAMS[4], INPUT_PARAMS[5]);\\n\\n        // =================== Estimate and mint the FRAX component ===================\\n        // (uint256 mint_amount, uint256 fxs_needed )\\n        uint256[2] memory mint_results = mintFRAXWrapper(INPUT_PARAMS[3], INPUT_PARAMS[1], INPUT_PARAMS[6]);\\n\\n         // =================== Add Liquidity ===================\\n\\n        // Approve FRAX for Uniswap\\n        IERC20(FRAX_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, mint_results[0]);\\n\\n        // Approve USDC for Uniswap\\n        IERC20(WETH_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, received_WETH);\\n\\n        // Add liquidity and send the token to the sender \\n        (uint256 lp_frax_used, uint256 lp_weth_used, ) = UniswapV2Router02.addLiquidity(\\n\\t\\t\\tFRAX_ADDRESS, \\n\\t\\t\\tWETH_ADDRESS,\\n\\t\\t\\tmint_results[0], \\n\\t\\t\\treceived_WETH, \\n            mint_results[0].mul(ADD_LIQUIDITY_SLIPPAGE),\\n            received_WETH.mul(ADD_LIQUIDITY_SLIPPAGE), // div(1e12).mul(ADD_LIQUIDITY_SLIPPAGE).div(1e3)\\n            msg.sender,\\n            2105300114 // A long time from now\\n\\t\\t);\\n\\n        {}\\n\\n        // Return unused FRAX to sender.\\n        FRAX_ERC20.transfer(msg.sender, mint_results[0].sub(lp_frax_used));\\n\\n        // Return unused USDC to sender.\\n        USDC_ERC20.transfer(msg.sender, received_USDC.sub(INPUT_PARAMS[3]));\\n\\n        // Return unused WETH to sender.\\n        WETH_ERC20.transfer(msg.sender, received_WETH.sub(INPUT_PARAMS[5]).sub(lp_weth_used));\\n\\n        // Return unused FXS to sender.\\n        FXS_ERC20.transfer(msg.sender, INPUT_PARAMS[0].sub(INPUT_PARAMS[2]).sub(INPUT_PARAMS[4]).sub(mint_results[1]));\\n\\n    }\\n\\n    // Assumes a FRAX_FXS LP \\n    // INPUT_PARAMS[0] uint256 FXS_total_input\\n    // INPUT_PARAMS[1] uint256 FXS_for_mint\\n    // INPUT_PARAMS[2] uint256 FXS_for_col_swap\\n    // INPUT_PARAMS[3] uint256 col_out_min\\n    // INPUT_PARAMS[4] uint256 FXS_bypassed\\n    // INPUT_PARAMS[5] uint256 fxs_bypassed_min\\n    // INPUT_PARAMS[6] uint256 frax_out_min\\n    function swapFXSForFRAXFXSLP(\\n        uint256[] calldata INPUT_PARAMS\\n    ) external payable notPaused {\\n\\n        // =================== Pull in the needed FXS ===================\\n        IERC20(FXS_ADDRESS).transferFrom(msg.sender, address(this), INPUT_PARAMS[0]);\\n\\n        // =================== Approve FXS for Uniswap ===================\\n        IERC20(FXS_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, INPUT_PARAMS[0]);\\n\\n        // =================== FXS -> USDC via Uniswap ===================\\n        (uint256 received_USDC) = FXS_To_USDC(INPUT_PARAMS[2], INPUT_PARAMS[3]);\\n\\n        // =================== Estimate and mint the FRAX component ===================\\n        // (uint256 mint_amount, uint256 fxs_needed )\\n        uint256[2] memory mint_results = mintFRAXWrapper(INPUT_PARAMS[3], INPUT_PARAMS[1], INPUT_PARAMS[6]);\\n\\n         // =================== Add Liquidity ===================\\n\\n        // Approve FRAX for Uniswap\\n        IERC20(FRAX_ADDRESS).approve(UNISWAP_ROUTER_ADDRESS, mint_results[0]);\\n\\n        // Add liquidity and send the token to the sender \\n        (uint256 lp_frax_used, uint256 lp_fxs_used, ) = UniswapV2Router02.addLiquidity(\\n\\t\\t\\tFRAX_ADDRESS, \\n\\t\\t\\tFXS_ADDRESS,\\n\\t\\t\\tmint_results[0], \\n\\t\\t\\tINPUT_PARAMS[4], \\n            mint_results[0].mul(ADD_LIQUIDITY_SLIPPAGE),\\n            INPUT_PARAMS[5].mul(ADD_LIQUIDITY_SLIPPAGE), // div(1e12).mul(ADD_LIQUIDITY_SLIPPAGE).div(1e3)\\n            msg.sender,\\n            2105300114 // A long time from now\\n\\t\\t);\\n\\n        // Return unused FRAX to sender.\\n        FRAX_ERC20.transfer(msg.sender, mint_results[0].sub(lp_frax_used));\\n\\n        // Return unused USDC to sender.\\n        USDC_ERC20.transfer(msg.sender, received_USDC.sub(INPUT_PARAMS[3]));\\n\\n        // Return unused FXS to sender.\\n        FXS_ERC20.transfer(msg.sender, INPUT_PARAMS[0].sub(INPUT_PARAMS[2]).sub(mint_results[1]).sub(lp_fxs_used));\\n\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    // The smart contract should never end up having to need this as there should be no deposits. Just for emergency purposes\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\\n        IERC20(tokenAddress).transfer(owner_address, tokenAmount);\\n    }\\n\\n    function withdraw() external onlyOwner\\n    {\\n        msg.sender.transfer(address(this).balance);\\n    }\\n\\n    function selfDestruct() external payable onlyOwner {\\n        selfdestruct(owner_address_payable);\\n    }\\n\\n    function togglePaused() external onlyOwner {\\n        is_paused = !is_paused;\\n    } \\n\\n    function setPoolAddress(address _pool_address) external onlyOwner {\\n        POOL_ADDRESS = _pool_address;\\n        FRAX_POOL = IFraxPool(_pool_address);\\n    }\\n\\n    function setLiquiditySlippage(uint256 _add_liquidity_slippage) external onlyOwner {\\n        ADD_LIQUIDITY_SLIPPAGE = _add_liquidity_slippage;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADD_LIQUIDITY_SLIPPAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"FXS_for_USDC_swap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_out_min\",\"type\":\"uint256\"}],\"name\":\"FXS_To_USDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"FXS_for_WETH_swap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weth_out_min\",\"type\":\"uint256\"}],\"name\":\"FXS_To_WETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NULL_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"POOL_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNISWAP_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fxs_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fxs_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingUtilities.MintFF_Params\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calcMintFractionalFRAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"is_paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input_collat\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"input_fxs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frax_out_min\",\"type\":\"uint256\"}],\"name\":\"mintFRAXWrapper\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minting_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_address_payable\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_add_liquidity_slippage\",\"type\":\"uint256\"}],\"name\":\"setLiquiditySlippage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool_address\",\"type\":\"address\"}],\"name\":\"setPoolAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"INPUT_PARAMS\",\"type\":\"uint256[]\"}],\"name\":\"swapFXSForFRAXFXSLP\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"INPUT_PARAMS\",\"type\":\"uint256[]\"}],\"name\":\"swapFXSForFRAXUSDCLP\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"INPUT_PARAMS\",\"type\":\"uint256[]\"}],\"name\":\"swapFXSForFRAXWETHLP\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"togglePaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingUtilities","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}