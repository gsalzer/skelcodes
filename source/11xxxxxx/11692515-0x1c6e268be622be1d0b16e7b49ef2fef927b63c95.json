{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libminingv1/MiningV1Op.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeMath.sol\\\";\\nimport \\\"../lib/SafeERC20.sol\\\";\\nimport '../lib/TransferHelper.sol';\\nimport \\\"../lib/ABDKMath64x64.sol\\\";\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\nimport \\\"../libminingv1/MiningV1Data.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\n/// @title  NestMiningV1/MiningV1Calc\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\nlibrary MiningV1Op {\\n\\n    using SafeMath for uint256;\\n\\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\\n    /// @param token The address of token(ntoken)\\n    /// @param index The position of the sheet in priceSheetList[token]\\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\\n    function _biteToken(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index, \\n            uint256 biteNum, \\n            uint256 newTokenAmountPerEth\\n        )\\n        external\\n    {\\n        // check parameters\\n        require(token != address(0x0), \\\"Nest:Mine:(token)=0\\\"); \\n        require(newTokenAmountPerEth > 0, \\\"Nest:Mine:(price)=0\\\");\\n        require(biteNum >= state.miningEthUnit && biteNum % state.miningEthUnit == 0, \\\"Nest:Mine:!(bite)\\\");\\n\\n        // check sheet\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index]; \\n        require(uint256(_sheet.height) + state.priceDurationBlock >= block.number, \\\"Nest:Mine:!EFF(sheet)\\\");\\n        require(uint256(_sheet.remainNum) >= biteNum, \\\"Nest:Mine:!(remain)\\\");\\n\\n        // load address of NestPool \\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n        // check sheet sate\\n        uint256 _state = uint256(_sheet.state);\\n        require(_state == MiningV1Data.PRICESHEET_STATE_POSTED \\n             || _state == MiningV1Data.PRICESHEET_STATE_BITTEN,  \\\"Nest:Mine:!(state)\\\");\\n\\n        {\\n            // load NTOKEN\\n            address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n            // calculate fee\\n            uint256 _ethFee = biteNum.mul(1 ether).mul(state.biteFeeRate).div(1000);\\n\\n            // save the changes into miner's virtual account\\n            if (msg.value.sub(_ethFee) > 0) {\\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\\n            }\\n\\n            // pump fee into staking pool\\n            if (_ethFee > 0) {\\n                INestStaking(state.C_NestStaking).addETHReward{value:_ethFee}(_ntoken);\\n            }\\n        }\\n \\n        // post a new price sheet\\n        { \\n            // check bitting conditions\\n            uint256 _newEthNum;\\n            uint256 _newNestNum1k = uint256(_sheet.nestNum1k);\\n            {\\n                uint256 _level = uint256(_sheet.level);\\n                uint256 _newLevel;\\n                \\n                // calculate `(_newEthNum, _newNestNum1k, _newLevel)`\\n                if (_level > state.maxBiteNestedLevel && _level < 127) { // bitten sheet, nest doubling\\n                    _newEthNum = biteNum;\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                } else if (_level <= state.maxBiteNestedLevel) {  // bitten sheet, eth doubling \\n                    _newEthNum = biteNum.mul(state.biteInflateFactor);\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                }\\n\\n                // freeze NEST \\n                _C_NestPool.freezeNest(address(msg.sender), _newNestNum1k.mul(1000 * 1e18));\\n\\n                // freeze(TOKEN, ETH); or freeeze(ETH) but unfreeze(TOKEN)\\n                if (_newEthNum.mul(newTokenAmountPerEth) < biteNum * _sheet.tokenAmountPerEth) {\\n                    uint256 _unfreezetokenAmount;\\n                    _unfreezetokenAmount = uint256(_sheet.tokenAmountPerEth).mul(biteNum).sub((uint256(newTokenAmountPerEth)).mul(_newEthNum));               \\n                    _C_NestPool.unfreezeToken(msg.sender, token, _unfreezetokenAmount);\\n                    _C_NestPool.freezeEth(msg.sender, _newEthNum.add(biteNum).mul(1 ether));\\n                } else {\\n                    _C_NestPool.freezeEthAndToken(msg.sender, _newEthNum.add(biteNum).mul(1 ether), \\n                        token, _newEthNum.mul(newTokenAmountPerEth)\\n                                         .sub(biteNum * _sheet.tokenAmountPerEth));\\n                }\\n\\n                MiningV1Data.PriceSheet[] storage _sheetOfToken = state.priceSheetList[token];\\n                // append a new price sheet\\n                _sheetOfToken.push(MiningV1Data.PriceSheet(\\n                    uint160(msg.sender),                // miner \\n                    uint32(block.number),               // atHeight\\n                    uint32(_newEthNum),                 // ethNum\\n                    uint32(_newEthNum),                 // remainNum\\n                    uint8(_newLevel),                   // level\\n                    uint8(_sheet.typ),                  // typ\\n                    uint8(MiningV1Data.PRICESHEET_STATE_POSTED),  // state \\n                    uint8(0),                           // _reserved\\n                    uint32(_newEthNum),                 // ethNumBal\\n                    uint32(_newEthNum),                 // tokenNumBal\\n                    uint32(_newNestNum1k),              // nestNum1k\\n                    uint128(newTokenAmountPerEth)     // tokenAmountPerEth\\n                ));\\n              \\n            }\\n\\n            // update the bitten sheet\\n            _sheet.state = MiningV1Data.PRICESHEET_STATE_BITTEN;\\n            _sheet.ethNumBal = uint32(uint256(_sheet.ethNumBal).add(biteNum));\\n            _sheet.tokenNumBal = uint32(uint256(_sheet.tokenNumBal).sub(biteNum));\\n            _sheet.remainNum = uint32(uint256(_sheet.remainNum).sub(biteNum));\\n            state.priceSheetList[token][index] = _sheet;\\n            \\n        }\\n\\n        emit MiningV1Data.TokenBought(address(msg.sender), address(token), index, biteNum.mul(1 ether), biteNum.mul(_sheet.tokenAmountPerEth));\\n        return; \\n\\n    }\\n\\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\\n    /// @param token The address of token(ntoken)\\n    /// @param index The position of the sheet in priceSheetList[token]\\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\\n    function _biteEth(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index, \\n            uint256 biteNum, \\n            uint256 newTokenAmountPerEth\\n        )\\n        external\\n    {\\n        // check parameters\\n        require(token != address(0x0), \\\"Nest:Mine:(token)=0\\\"); \\n        require(newTokenAmountPerEth > 0, \\\"Nest:Mine:(price)=0\\\");\\n        require(biteNum >= state.miningEthUnit && biteNum % state.miningEthUnit == 0, \\\"Nest:Mine:!(bite)\\\");\\n\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index]; \\n        require(uint256(_sheet.height) + state.priceDurationBlock >= block.number, \\\"Nest:Mine:!EFF(sheet)\\\");\\n        require(uint256(_sheet.remainNum) >= biteNum, \\\"Nest:Mine:!(remain)\\\");\\n\\n        // load NestPool\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n        // check state\\n        uint256 _state = uint256(_sheet.state);\\n        require(_state == MiningV1Data.PRICESHEET_STATE_POSTED \\n            || _state == MiningV1Data.PRICESHEET_STATE_BITTEN,  \\\"Nest:Mine:!(state)\\\");\\n\\n        {\\n            // load NTOKEN\\n            address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n\\n            // calculate fee\\n            uint256 _ethFee = biteNum.mul(1 ether).mul(state.biteFeeRate).div(1000);\\n\\n            // save the changes into miner's virtual account\\n            if (msg.value.sub(_ethFee) > 0) {\\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\\n            }\\n\\n            // pump fee into NestStaking\\n            INestStaking(state.C_NestStaking).addETHReward{value:_ethFee}(_ntoken);\\n        }\\n        \\n        // post a new price sheet\\n        { \\n            // check bitting conditions\\n            uint256 _newEthNum;\\n            uint256 _newNestNum1k = uint256(_sheet.nestNum1k);\\n            {\\n                uint256 _level = uint256(_sheet.level);\\n                uint256 _newLevel;\\n\\n                if (_level > state.maxBiteNestedLevel && _level < 127) { // bitten sheet, nest doubling\\n                    _newEthNum = biteNum;\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                } else if (_level <= state.maxBiteNestedLevel) {  // bitten sheet, eth doubling \\n                    _newEthNum = biteNum.mul(state.biteInflateFactor);\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                }\\n\\n                MiningV1Data.PriceSheet[] storage _sheetOfToken = state.priceSheetList[token];\\n                // append a new price sheet\\n                _sheetOfToken.push(MiningV1Data.PriceSheet(\\n                    uint160(msg.sender),             // miner \\n                    uint32(block.number),            // atHeight\\n                    uint32(_newEthNum),                 // ethNum\\n                    uint32(_newEthNum),                 // remainNum\\n                    uint8(_newLevel),                // level\\n                    uint8(_sheet.typ),               // typ\\n                    uint8(MiningV1Data.PRICESHEET_STATE_POSTED),  // state \\n                    uint8(0),                        // _reserved\\n                    uint32(_newEthNum),                 // ethNumBal\\n                    uint32(_newEthNum),                 // tokenNumBal\\n                    uint32(_newNestNum1k),           // nestNum1k\\n                    uint128(newTokenAmountPerEth)    // tokenAmountPerEth\\n                ));\\n            }\\n\\n            // freeze NEST \\n            _C_NestPool.freezeNest(address(msg.sender), _newNestNum1k.mul(1000 * 1e18));\\n\\n            // freeze(TOKEN, ETH)\\n            _C_NestPool.freezeEthAndToken(msg.sender, _newEthNum.sub(biteNum).mul(1 ether), \\n                token, _newEthNum.mul(newTokenAmountPerEth)\\n                                    .add(biteNum.mul(_sheet.tokenAmountPerEth)));\\n\\n            // update the bitten sheet\\n            _sheet.state = MiningV1Data.PRICESHEET_STATE_BITTEN;\\n            _sheet.ethNumBal = uint32(uint256(_sheet.ethNumBal).sub(biteNum));\\n            _sheet.tokenNumBal = uint32(uint256(_sheet.tokenNumBal).add(biteNum));\\n            _sheet.remainNum = uint32(uint256(_sheet.remainNum).sub(biteNum));\\n            state.priceSheetList[token][index] = _sheet;\\n        }\\n\\n        emit MiningV1Data.TokenSold(address(msg.sender), address(token), index, biteNum.mul(1 ether), biteNum.mul(_sheet.tokenAmountPerEth));\\n        return; \\n    }\\n\\n    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\\n    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \\n    /// @param token The address of TOKEN contract\\n    /// @param index The index of the price sheet w.r.t. `token`\\n    function _close(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index\\n        )\\n        external\\n    {\\n        // load sheet\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\\n        // check if the sheet is closable\\n        require(uint256(_sheet.height) + state.priceDurationBlock < block.number // safe_math\\n            || _sheet.remainNum == 0, \\\"Nest:Mine:!(height)\\\");\\n\\n        // check owner\\n        require(address(_sheet.miner) == address(msg.sender), \\\"Nest:Mine:!(miner)\\\");\\n        // check state flag\\n        require(uint256(_sheet.state) != MiningV1Data.PRICESHEET_STATE_CLOSED, \\\"Nest:Mine:!unclosed\\\");\\n\\n        // load ntoken\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n\\n        // distribute rewards (NEST or NTOKEN)\\n        {\\n            uint256 h = _sheet.height;\\n            if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD && _sheet.level == 0) {   // for (USDT, NEST)\\n                uint256 _nestH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_nestH).div(_ethH);\\n                _C_NestPool.addNest(address(msg.sender), _reward);\\n            } else if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN && _sheet.level == 0) { // for (ERC20, NTOKEN)\\n                uint256 _ntokenH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH);\\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\\n            }\\n        }\\n\\n        // unfreeze the assets withheld by the sheet\\n        {\\n            uint256 _ethAmount = uint256(_sheet.ethNumBal).mul(1 ether);\\n            uint256 _tokenAmount = uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth);\\n            uint256 _nestAmount = uint256(_sheet.nestNum1k).mul(1000 * 1e18);\\n            _sheet.ethNumBal = 0;\\n            _sheet.tokenNumBal = 0;\\n            _sheet.nestNum1k = 0;\\n\\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n            _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \\n        }\\n\\n        // update the state flag\\n        _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\\n\\n        // write back\\n        state.priceSheetList[token][index] = _sheet;\\n\\n        // emit an event\\n        emit MiningV1Data.PriceClosed(address(msg.sender), token, index);\\n    }\\n\\n    /// @notice Close a price sheet and withdraw assets for WEB users.  \\n    /// @dev Contracts aren't allowed to call it.\\n    /// @param token The address of TOKEN contract\\n    /// @param index The index of the price sheet w.r.t. `token`\\n    function _closeAndWithdraw(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index\\n        ) \\n        external \\n    {\\n        // check sheet if passing verification\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\\n        require(uint256(_sheet.height) + state.priceDurationBlock < block.number // safe_math\\n            || _sheet.remainNum == 0, \\\"Nest:Mine:!(height)\\\");\\n\\n        // check ownership and state\\n        require(address(_sheet.miner) == address(msg.sender), \\\"Nest:Mine:!(miner)\\\");\\n        require(uint256(_sheet.state) != MiningV1Data.PRICESHEET_STATE_CLOSED, \\\"Nest:Mine:!unclosed\\\");\\n\\n        // get ntoken\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n\\n        {\\n            uint256 h = uint256(_sheet.height);\\n            if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD && _sheet.level == 0) {\\n                uint256 _nestH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_nestH).div(_ethH);\\n                _C_NestPool.addNest(address(msg.sender), _reward);\\n            } else if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN && _sheet.level == 0) {\\n                uint256 _ntokenH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH);\\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\\n            }\\n        }\\n\\n        {\\n            uint256 _ethAmount = uint256(_sheet.ethNumBal).mul(1 ether);\\n            uint256 _tokenAmount = uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth);\\n            uint256 _nestAmount = uint256(_sheet.nestNum1k).mul(1000 * 1e18);\\n            _sheet.ethNumBal = 0;\\n            _sheet.tokenNumBal = 0;\\n            _sheet.nestNum1k = 0;\\n\\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n            _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \\n            _C_NestPool.withdrawEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n            _C_NestPool.withdrawNest(address(msg.sender), _nestAmount);\\n        }\\n\\n        /*  \\n        - Issue #23: \\n            Uncomment the following code to support withdrawing ethers cached \\n        {\\n            uint256 _ethAmount = _C_NestPool.balanceOfEthInPool(address(msg.sender));\\n            if (_ethAmount > 0) {\\n                _C_NestPool.withdrawEth(address(msg.sender), _ethAmount);\\n            }\\n        }\\n        */\\n\\n        _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\\n\\n        state.priceSheetList[token][index] = _sheet;\\n\\n        emit MiningV1Data.PriceClosed(address(msg.sender), token, index);    \\n    }\\n\\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\\n    /// @param token The address of TOKEN contract\\n    /// @param indices A list of indices of sheets w.r.t. `token`\\n    function _closeList(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint32[] memory indices) \\n        external \\n    {\\n        uint256 _ethAmount;\\n        uint256 _tokenAmount;\\n        uint256 _nestAmount;\\n        uint256 _reward;\\n\\n        // load storage point to the list of price sheets\\n        MiningV1Data.PriceSheet[] storage prices = state.priceSheetList[token];\\n        \\n        // loop\\n        for (uint i=0; i<indices.length; i++) {\\n            // load one sheet\\n            MiningV1Data.PriceSheet memory _sheet = prices[indices[i]];\\n\\n            // check owner\\n            if (uint256(_sheet.miner) != uint256(msg.sender)) {\\n                continue;\\n            }\\n\\n            // check state\\n            if(_sheet.state == MiningV1Data.PRICESHEET_STATE_CLOSED) {\\n                continue;\\n            }\\n\\n            uint256 h = uint256(_sheet.height);\\n            // check if the sheet closable\\n            if (h + state.priceDurationBlock < block.number || _sheet.remainNum == 0) { // safe_math: untainted values\\n\\n                // count up assets in the sheet\\n                _ethAmount = _ethAmount.add(uint256(_sheet.ethNumBal).mul(1 ether));\\n                _tokenAmount = _tokenAmount.add(uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth));\\n                _nestAmount = _nestAmount.add(uint256(_sheet.nestNum1k).mul(1000 * 1e18));\\n\\n                // clear bits in the sheet\\n                _sheet.ethNumBal = 0;\\n                _sheet.tokenNumBal = 0;\\n                _sheet.nestNum1k = 0;\\n                \\n                // update state flag\\n                _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\\n                \\n                // write back\\n                prices[indices[i]] = _sheet;\\n\\n                // count up the reward\\n                if(_sheet.level == 0 && (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD || _sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN)) {\\n                    uint256 _ntokenH = uint256(state.minedAtHeight[token][h] >> 128);\\n                    uint256 _ethH = uint256(state.minedAtHeight[token][h] << 128 >> 128);\\n                    _reward = _reward.add(uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH));\\n                }\\n                emit MiningV1Data.PriceClosed(address(msg.sender), token, indices[i]);\\n            }\\n        }\\n        \\n        // load address of NestPool (for gas saving)\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n        // unfreeze assets\\n        if (_ethAmount > 0 || _tokenAmount > 0) {\\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n        }\\n        _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \\n\\n        // distribute the rewards\\n        {\\n            uint256 _typ = prices[indices[0]].typ;\\n            if  (_typ == MiningV1Data.PRICESHEET_TYPE_USD) {\\n                _C_NestPool.addNest(address(msg.sender), _reward);\\n            } else if (_typ == MiningV1Data.PRICESHEET_TYPE_TOKEN) {\\n                address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\\n            }\\n        }\\n    }\\n\\n    /*\\n    /// @dev This function is only for post dual-price-sheet before upgrading without assets\\n    function _post2Only4Upgrade(\\n            MiningV1Data.State storage state,\\n            address token,\\n            uint256 ethNum,\\n            uint256 tokenAmountPerEth,\\n            uint256 ntokenAmountPerEth\\n        )\\n        external \\n    {\\n        // check parameters \\n        require(ethNum == state.miningEthUnit, \\\"Nest:Mine:!(ethNum)\\\");\\n        require(tokenAmountPerEth > 0 && ntokenAmountPerEth > 0, \\\"Nest:Mine:!(price)\\\");\\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\\n\\n        // no eth fee, no freezing\\n\\n        // push sheets\\n        {\\n            uint8 typ1;\\n            uint8 typ2; \\n            if (_ntoken == address(state.C_NestToken)) {\\n                typ1 = MiningV1Data.PRICESHEET_TYPE_USD;\\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NEST;\\n            } else {\\n                typ1 = MiningV1Data.PRICESHEET_TYPE_TOKEN;\\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NTOKEN;\\n            }\\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\\n            // append a new price sheet\\n            _sheetToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(typ1),     // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_CLOSED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),        // nestNum1k\\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\\n            ));\\n\\n            MiningV1Data.PriceSheet[] storage _sheetNToken = state.priceSheetList[_ntoken];\\n            // append a new price sheet for ntoken\\n            _sheetNToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(typ2),     // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_CLOSED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),        // nestNum1k\\n                uint128(ntokenAmountPerEth)      // tokenAmountPerEth\\n            ));\\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \\n            emit MiningV1Data.PricePosted(msg.sender, _ntoken, (_sheetNToken.length - 1), ethNum.mul(1 ether), ntokenAmountPerEth.mul(ethNum)); \\n        }\\n\\n        // no mining\\n\\n        return; \\n    }\\n    */\\n\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y > 0, \\\"ds-math-div-zero\\\");\\n        z = x / y;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Copyright © 2019 by ABDK Consulting\\n\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity 0.6.12;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /**\\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /**\\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    return int64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    require (x >= 0);\\n    return uint64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    int256 result = x >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    return int256 (x) << 64;\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) + y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) - y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) * y >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    if (x == MIN_64x64) {\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\n      return -y << 63;\\n    } else {\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x;\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <=\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <=\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (absoluteResult);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    if (y == 0) return 0;\\n\\n    require (x >= 0);\\n\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n    uint256 hi = uint256 (x) * (y >> 128);\\n\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    hi <<= 64;\\n\\n    require (hi <=\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n    return hi + lo;\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    require (y != 0);\\n    int256 result = (int256 (x) << 64) / y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    require (y != 0);\\n\\n    bool negativeResult = false;\\n    if (x < 0) {\\n      x = -x; // We rely on overflow behavior here\\n      negativeResult = true;\\n    }\\n    if (y < 0) {\\n      y = -y; // We rely on overflow behavior here\\n      negativeResult = !negativeResult;\\n    }\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    require (y != 0);\\n    uint128 result = divuu (x, y);\\n    require (result <= uint128 (MAX_64x64));\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return -x;\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return x < 0 ? -x : x;\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    require (x != 0);\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    int256 m = int256 (x) * int256 (y);\\n    require (m >= 0);\\n    require (m <\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    uint256 absoluteResult;\\n    bool negativeResult = false;\\n    if (x >= 0) {\\n      absoluteResult = powu (uint256 (x) << 63, y);\\n    } else {\\n      // We rely on overflow behavior here\\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\\n      negativeResult = y & 1 > 0;\\n    }\\n\\n    absoluteResult >>= 63;\\n\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    require (x >= 0);\\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    int256 msb = 0;\\n    int256 xc = x;\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n    int256 result = msb - 64 << 64;\\n    uint256 ux = uint256 (x) << 127 - msb;\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n      ux *= ux;\\n      uint256 b = ux >> 255;\\n      ux >>= 127 + b;\\n      result += bit * int256 (b);\\n    }\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    return int128 (\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    uint256 result = 0x80000000000000000000000000000000;\\n\\n    if (x & 0x8000000000000000 > 0)\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n    if (x & 0x4000000000000000 > 0)\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n    if (x & 0x2000000000000000 > 0)\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n    if (x & 0x1000000000000000 > 0)\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n    if (x & 0x800000000000000 > 0)\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n    if (x & 0x400000000000000 > 0)\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n    if (x & 0x200000000000000 > 0)\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n    if (x & 0x100000000000000 > 0)\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n    if (x & 0x80000000000000 > 0)\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n    if (x & 0x40000000000000 > 0)\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n    if (x & 0x20000000000000 > 0)\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n    if (x & 0x10000000000000 > 0)\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n    if (x & 0x8000000000000 > 0)\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n    if (x & 0x4000000000000 > 0)\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n    if (x & 0x2000000000000 > 0)\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n    if (x & 0x1000000000000 > 0)\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n    if (x & 0x800000000000 > 0)\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n    if (x & 0x400000000000 > 0)\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n    if (x & 0x200000000000 > 0)\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n    if (x & 0x100000000000 > 0)\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n    if (x & 0x80000000000 > 0)\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n    if (x & 0x40000000000 > 0)\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n    if (x & 0x20000000000 > 0)\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n    if (x & 0x10000000000 > 0)\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n    if (x & 0x8000000000 > 0)\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n    if (x & 0x4000000000 > 0)\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n    if (x & 0x2000000000 > 0)\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n    if (x & 0x1000000000 > 0)\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n    if (x & 0x800000000 > 0)\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n    if (x & 0x400000000 > 0)\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n    if (x & 0x200000000 > 0)\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n    if (x & 0x100000000 > 0)\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n    if (x & 0x80000000 > 0)\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n    if (x & 0x40000000 > 0)\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n    if (x & 0x20000000 > 0)\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n    if (x & 0x10000000 > 0)\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n    if (x & 0x8000000 > 0)\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n    if (x & 0x4000000 > 0)\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n    if (x & 0x2000000 > 0)\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n    if (x & 0x1000000 > 0)\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n    if (x & 0x800000 > 0)\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n    if (x & 0x400000 > 0)\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n    if (x & 0x200000 > 0)\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n    if (x & 0x100000 > 0)\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n    if (x & 0x80000 > 0)\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n    if (x & 0x40000 > 0)\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n    if (x & 0x20000 > 0)\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n    if (x & 0x10000 > 0)\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n    if (x & 0x8000 > 0)\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n    if (x & 0x4000 > 0)\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n    if (x & 0x2000 > 0)\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n    if (x & 0x1000 > 0)\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n    if (x & 0x800 > 0)\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n    if (x & 0x400 > 0)\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n    if (x & 0x200 > 0)\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n    if (x & 0x100 > 0)\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n    if (x & 0x80 > 0)\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n    if (x & 0x40 > 0)\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n    if (x & 0x20 > 0)\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n    if (x & 0x10 > 0)\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n    if (x & 0x8 > 0)\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n    if (x & 0x4 > 0)\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n    if (x & 0x2 > 0)\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n    if (x & 0x1 > 0)\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n    result >>= 63 - (x >> 64);\\n    require (result <= uint256 (MAX_64x64));\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    return exp_2 (\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    require (y != 0);\\n\\n    uint256 result;\\n\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      result = (x << 64) / y;\\n    else {\\n      uint256 msb = 192;\\n      uint256 xc = x >> 192;\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 hi = result * (y >> 128);\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 xh = x >> 192;\\n      uint256 xl = x << 64;\\n\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n      lo = hi << 128;\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n\\n      assert (xh == hi >> 128);\\n\\n      result += xl / y;\\n    }\\n\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    return uint128 (result);\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x unsigned 129.127-bit fixed point number\\n   * @param y uint256 value\\n   * @return unsigned 129.127-bit fixed point number\\n   */\\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\\n    if (y == 0) return 0x80000000000000000000000000000000;\\n    else if (x == 0) return 0;\\n    else {\\n      int256 msb = 0;\\n      uint256 xc = x;\\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 xe = msb - 127;\\n      if (xe > 0) x >>= xe;\\n      else x <<= -xe;\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n      int256 re = 0;\\n\\n      while (y > 0) {\\n        if (y & 1 > 0) {\\n          result = result * x;\\n          y -= 1;\\n          re += xe;\\n          if (result >=\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\n            result >>= 128;\\n            re += 1;\\n          } else result >>= 127;\\n          if (re < -127) return 0; // Underflow\\n          require (re < 128); // Overflow\\n        } else {\\n          x = x * x;\\n          y >>= 1;\\n          xe <<= 1;\\n          if (x >=\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\n            x >>= 128;\\n            xe += 1;\\n          } else x >>= 127;\\n          if (xe < -127) return 0; // Underflow\\n          require (xe < 128); // Overflow\\n        }\\n      }\\n\\n      if (re > 0) result <<= re;\\n      else if (re < 0) result >>= -re;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\\n    if (x == 0) return 0;\\n    else {\\n      require (r > 0);\\n      while (true) {\\n        uint256 rr = x / r;\\n        if (r == rr || r + 1 == rr) return uint128 (r);\\n        else if (r == rr + 1) return uint128 (rr);\\n        r = r + rr + 1 >> 1;\\n      }\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/iface/INestPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\ninterface INestPool {\\n\\n    // function getNTokenFromToken(address token) view external returns (address);\\n    // function setNTokenToToken(address token, address ntoken) external; \\n\\n    function addNest(address miner, uint256 amount) external;\\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\\n\\n    function depositEth(address miner) external payable;\\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\\n\\n    function freezeEth(address miner, uint256 ethAmount) external; \\n    function unfreezeEth(address miner, uint256 ethAmount) external;\\n\\n    function freezeNest(address miner, uint256 nestAmount) external;\\n    function unfreezeNest(address miner, uint256 nestAmount) external;\\n\\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n\\n    function getNTokenFromToken(address token) external view returns (address); \\n    function setNTokenToToken(address token, address ntoken) external; \\n\\n    function withdrawEth(address miner, uint256 ethAmount) external;\\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function withdrawNest(address miner, uint256 amount) external;\\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\\n\\n\\n    function balanceOfNestInPool(address miner) external view returns (uint256);\\n    function balanceOfEthInPool(address miner) external view returns (uint256);\\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\\n\\n    function addrOfNestToken() external view returns (address);\\n    function addrOfNestMining() external view returns (address);\\n    function addrOfNTokenController() external view returns (address);\\n    function addrOfNNRewardPool() external view returns (address);\\n    function addrOfNNToken() external view returns (address);\\n    function addrOfNestStaking() external view returns (address);\\n    function addrOfNestQuery() external view returns (address);\\n    function addrOfNestDAO() external view returns (address);\\n\\n    function addressOfBurnedNest() external view returns (address);\\n\\n    function setGovernance(address _gov) external; \\n    function governance() external view returns(address);\\n    function initNestLedger(uint256 amount) external;\\n    function drainNest(address to, uint256 amount, address gov) external;\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\ninterface INestStaking {\\n    // Views\\n\\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @return The total amount of XTokens deposited in this staking pool\\n    function totalStaked(address ntoken) external view returns (uint256);\\n\\n    /// @dev How many stakingToken (XToken) deposited by the target account\\n    /// @param  ntoken The address of NToken\\n    /// @param  account The target account\\n    /// @return The total amount of XToken deposited in this staking pool\\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\\n\\n\\n    // Mutative\\n    /// @dev Stake/Deposit into the reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function stake(address ntoken, uint256 amount) external;\\n\\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\\n\\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function unstake(address ntoken, uint256 amount) external;\\n\\n    /// @dev Claim the reward the user earned\\n    /// @param ntoken The address of NToken\\n    /// @return The amount of ethers as rewards\\n    function claim(address ntoken) external returns (uint256);\\n\\n    /// @dev Add ETH reward to the staking pool\\n    /// @param ntoken The address of NToken\\n    function addETHReward(address ntoken) external payable;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    function pause() external;\\n\\n    function resume() external;\\n\\n    //function setParams(uint8 dividendShareRate) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Events\\n    event RewardAdded(address ntoken, address sender, uint256 reward);\\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\\n\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/iface/INToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INToken {\\n    // mint ntoken for value\\n    function mint(uint256 amount, address account) external;\\n\\n    // the block height where the ntoken was created\\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\\n    // the owner (auction winner) of the ntoken\\n    function checkBidder() external view returns(address);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INNRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n/// @title NNRewardPool\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\n\\ninterface INNRewardPool {\\n    \\n    /* [DEPRECATED]\\n        uint256 constant DEV_REWARD_PERCENTAGE   = 5;\\n        uint256 constant NN_REWARD_PERCENTAGE    = 15;\\n        uint256 constant MINER_REWARD_PERCENTAGE = 80;\\n    */\\n\\n    /// @notice Add rewards for Nest-Nodes, only governance or NestMining (contract) are allowed\\n    /// @dev  The rewards need to pull from NestPool\\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\\n    function addNNReward(uint256 _amount) external;\\n\\n    /// @notice Claim rewards by Nest-Nodes\\n    /// @dev The rewards need to pull from NestPool\\n    function claimNNReward() external ;  \\n\\n    /// @dev The callback function called by NNToken.transfer()\\n    /// @param fromAdd The address of 'from' to transfer\\n    /// @param toAdd The address of 'to' to transfer\\n    function nodeCount(address fromAdd, address toAdd) external;\\n\\n    /// @notice Show the amount of rewards unclaimed\\n    /// @return reward The reward of a NN holder\\n    function unclaimedNNReward() external view returns (uint256 reward);\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    /* ========== EVENTS ============== */\\n\\n    /// @notice When rewards are added to the pool\\n    /// @param reward The amount of Nest Token\\n    /// @param allRewards The snapshot of all rewards accumulated\\n    event NNRewardAdded(uint256 reward, uint256 allRewards);\\n\\n    /// @notice When rewards are claimed by nodes \\n    /// @param nnode The address of the nest node\\n    /// @param share The amount of Nest Token claimed by the nest node\\n    event NNRewardClaimed(address nnode, uint256 share);\\n\\n    /// @notice When flag of state is set by governance \\n    /// @param gov The address of the governance\\n    /// @param flag The value of the new flag\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/libminingv1/MiningV1Data.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\n\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author 0x00  - <0x00@nestprotocol.org>\\nlibrary MiningV1Data {\\n\\n    /* ========== CONSTANTS ========== */\\n\\n    uint256 constant MINING_NEST_YIELD_CUTBACK_PERIOD = 2400000; // ~ 1 years \\n    uint256 constant MINING_NEST_YIELD_CUTBACK_RATE = 80;     // percentage = 80%\\n\\n    // yield amount (per block) after the first ten years\\n    uint256 constant MINING_NEST_YIELD_OFF_PERIOD_AMOUNT = 40 ether;\\n    // yield amount (per block) in the first year, it drops to 80% in the following nine years\\n    uint256 constant MINING_NEST_YIELD_PER_BLOCK_BASE = 400 ether;\\n\\n    uint256 constant MINING_NTOKEN_YIELD_CUTBACK_RATE = 80;\\n    uint256 constant MINING_NTOKEN_YIELD_OFF_PERIOD_AMOUNT = 0.4 ether;\\n    uint256 constant MINING_NTOKEN_YIELD_PER_BLOCK_BASE = 4 ether;\\n\\n    uint256 constant MINING_FINAL_BLOCK_NUMBER = 173121488;\\n\\n\\n    uint256 constant MINING_NEST_FEE_DIVIDEND_RATE = 80;    // percentage = 80%\\n    uint256 constant MINING_NEST_FEE_DAO_RATE = 20;         // percentage = 20%\\n\\n    uint256 constant MINING_NTOKEN_FEE_DIVIDEND_RATE        = 60;     // percentage = 60%\\n    uint256 constant MINING_NTOKEN_FEE_DAO_RATE             = 20;     // percentage = 20%\\n    uint256 constant MINING_NTOKEN_FEE_NEST_DAO_RATE        = 20;     // percentage = 20%\\n\\n    uint256 constant MINING_NTOKEN_YIELD_BLOCK_LIMIT = 100;\\n\\n    uint256 constant NN_NEST_REWARD_PERCENTAGE = 15;\\n    uint256 constant DAO_NEST_REWARD_PERCENTAGE = 5;\\n    uint256 constant MINER_NEST_REWARD_PERCENTAGE = 80;\\n\\n    uint256 constant MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE = 95;\\n    uint256 constant MINING_LEGACY_NTOKEN_BIDDER_REWARD_PERCENTAGE = 5;\\n\\n    uint8 constant PRICESHEET_STATE_CLOSED = 0;\\n    uint8 constant PRICESHEET_STATE_POSTED = 1;\\n    uint8 constant PRICESHEET_STATE_BITTEN = 2;\\n\\n    uint8 constant PRICESHEET_TYPE_USD     = 1;\\n    uint8 constant PRICESHEET_TYPE_NEST    = 2;\\n    uint8 constant PRICESHEET_TYPE_TOKEN   = 3;\\n    uint8 constant PRICESHEET_TYPE_NTOKEN  = 4;\\n    uint8 constant PRICESHEET_TYPE_BITTING = 8;\\n\\n\\n    uint8 constant STATE_FLAG_UNINITIALIZED    = 0;\\n    uint8 constant STATE_FLAG_SETUP_NEEDED     = 1;\\n    uint8 constant STATE_FLAG_ACTIVE           = 3;\\n    uint8 constant STATE_FLAG_MINING_STOPPED   = 4;\\n    uint8 constant STATE_FLAG_CLOSING_STOPPED  = 5;\\n    uint8 constant STATE_FLAG_WITHDRAW_STOPPED = 6;\\n    uint8 constant STATE_FLAG_PRICE_STOPPED    = 7;\\n    uint8 constant STATE_FLAG_SHUTDOWN         = 127;\\n\\n    uint256 constant MINING_NTOKEN_NON_DUAL_POST_THRESHOLD = 5_000_000 ether;\\n\\n\\n    /// @dev size: (2 x 256 bit)\\n    struct PriceSheet {    \\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;      //\\n        uint32  ethNum;   \\n        uint32  remainNum;    \\n\\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint8   _reserved;       // for padding\\n        uint32  ethNumBal;\\n        uint32  tokenNumBal;\\n        uint32  nestNum1k;\\n        uint128 tokenAmountPerEth;\\n    }\\n    \\n    /// @dev size: (3 x 256 bit)\\n    struct PriceInfo {\\n        uint32  index;\\n        uint32  height;         // NOTE: the height of being posted\\n        uint32  ethNum;         //  the balance of eth\\n        uint32  _reserved;\\n        uint128 tokenAmount;    //  the balance of token \\n        int128  volatility_sigma_sq;\\n        int128  volatility_ut_sq;\\n        uint128  avgTokenAmount;  // avg = (tokenAmount : perEth)\\n        uint128 _reserved2;     \\n    }\\n\\n\\n    /// @dev The struct is for public data in a price sheet, so as to protect prices from being read\\n    struct PriceSheetPub {\\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;\\n        uint32  ethNum;   \\n\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint32  ethNumBal;\\n        uint32  tokenNumBal;\\n    }\\n\\n\\n    struct PriceSheetPub2 {\\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;\\n        uint32  ethNum;   \\n        uint32  remainNum; \\n\\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint256 index;           // return to the quotation of index\\n        uint32  nestNum1k;\\n        uint128 tokenAmountPerEth;   \\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event PricePosted(address miner, address token, uint256 index, uint256 ethAmount, uint256 tokenAmount);\\n    event PriceClosed(address miner, address token, uint256 index);\\n    event Deposit(address miner, address token, uint256 amount);\\n    event Withdraw(address miner, address token, uint256 amount);\\n    event TokenBought(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\\n    event TokenSold(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\\n\\n    event VolaComputed(uint32 h, uint32 pos, uint32 ethA, uint128 tokenA, int128 sigma_sq, int128 ut_sq);\\n\\n    event SetParams(uint8 miningEthUnit, uint32 nestStakedNum1k, uint8 biteFeeRate,\\n                    uint8 miningFeeRate, uint8 priceDurationBlock, uint8 maxBiteNestedLevel,\\n                    uint8 biteInflateFactor, uint8 biteNestInflateFactor);\\n\\n    // event GovSet(address oldGov, address newGov);\\n\\n    /* ========== GIANT STATE VARIABLE ========== */\\n\\n    struct State {\\n        // TODO: more comments\\n\\n        uint8   miningEthUnit;      // = 30 on mainnet;\\n        uint32  nestStakedNum1k;    // = 100;\\n        uint8   biteFeeRate;        // \\n        uint8   miningFeeRate;      // = 10;  \\n        uint8   priceDurationBlock; // = 25;\\n        uint8   maxBiteNestedLevel; // = 3;\\n        uint8   biteInflateFactor;  // = 2;\\n        uint8   biteNestInflateFactor; // = 2;\\n\\n        uint32  genesisBlock;       // = 6236588;\\n\\n        uint128  latestMiningHeight;  // latest block number of NEST mining\\n        uint128  minedNestAmount;     // the total amount of mined NEST\\n        \\n        address  _developer_address;  // WARNING: DO NOT delete this unused variable\\n        address  _NN_address;         // WARNING: DO NOT delete this unused variable\\n\\n        address  C_NestPool;\\n        address  C_NestToken;\\n        address  C_NestStaking;\\n        address  C_NNRewardPool;\\n        address  C_NestQuery;\\n        address  C_NestDAO;\\n\\n        uint256[10] _mining_nest_yield_per_block_amount;\\n        uint256[10] _mining_ntoken_yield_per_block_amount;\\n\\n        // A mapping (from token(address) to an array of PriceSheet)\\n        mapping(address => PriceSheet[]) priceSheetList;\\n\\n        // from token(address) to Price\\n        mapping(address => PriceInfo) priceInfo;\\n\\n        // (token-address, block-number) => (ethFee-total, nest/ntoken-mined-total)\\n        mapping(address => mapping(uint256 => uint256)) minedAtHeight;\\n\\n        // WARNING: DO NOT delete these variables, reserved for future use\\n        uint256  _reserved1;\\n        uint256  _reserved2;\\n        uint256  _reserved3;\\n        uint256  _reserved4;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{value:amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"MiningV1Op","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}