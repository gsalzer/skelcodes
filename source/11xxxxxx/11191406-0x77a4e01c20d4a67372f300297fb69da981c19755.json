{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/spec_interfaces/IStakingContractHandler.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Staking contract handler contract interface in addition to IStakeChangeNotifier\r\ninterface IStakingContractHandler {\r\n    event StakeChangeNotificationSkipped(address indexed stakeOwner);\r\n    event StakeChangeBatchNotificationSkipped(address[] stakeOwners);\r\n    event StakeMigrationNotificationSkipped(address indexed stakeOwner);\r\n\r\n    /*\r\n    * External functions\r\n    */\r\n\r\n    /// Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param stakeOwner address The address to check.\r\n    /// @return uint256 The total stake.\r\n    function getStakeBalanceOf(address stakeOwner) external view returns (uint256);\r\n\r\n    /// Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 is the total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external view returns (uint256);\r\n\r\n    /*\r\n    * Governance functions\r\n    */\r\n\r\n    event NotifyDelegationsChanged(bool notifyDelegations);\r\n\r\n    /// Sets notifications to the delegation contract\r\n    /// @dev staking while notifications are disabled may lead to a discrepancy in the delegation data  \r\n    /// @dev governance function called only by the migration manager\r\n    /// @param notifyDelegations is a bool indicating whether to notify the delegation contract\r\n    function setNotifyDelegations(bool notifyDelegations) external; /* onlyMigrationManager */\r\n\r\n    /// Returns the notifications to the delegation contract status\r\n    /// @return notifyDelegations is a bool indicating whether notifications are enabled\r\n    function getNotifyDelegations() external view returns (bool);\r\n}\r\n\r\n// File: contracts/IStakeChangeNotifier.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\r\ninterface IStakeChangeNotifier {\r\n    /// @dev Notifies of stake change event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The difference in the total staked amount.\r\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\r\n    /// @param _updatedStake uint256 The updated total staked amount.\r\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\r\n\r\n    /// @dev Notifies of multiple stake change events.\r\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\r\n    /// @param _amounts uint256[] The differences in total staked amounts.\r\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\r\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\r\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\r\n        uint256[] calldata _updatedStakes) external;\r\n\r\n    /// @dev Notifies of stake migration event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The migrated amount.\r\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IMigratableStakingContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/// @title An interface for staking contracts which support stake migration.\r\ninterface IMigratableStakingContract {\r\n    /// @dev Returns the address of the underlying staked token.\r\n    /// @return IERC20 The address of the token.\r\n    function getToken() external view returns (IERC20);\r\n\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _stakeOwner address The specified stake owner.\r\n    /// @param _amount uint256 The number of tokens to stake.\r\n    function acceptMigration(address _stakeOwner, uint256 _amount) external;\r\n\r\n    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n}\r\n\r\n// File: contracts/IStakingContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/// @title An interface for staking contracts.\r\ninterface IStakingContract {\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _amount uint256 The amount of tokens to stake.\r\n    function stake(uint256 _amount) external;\r\n\r\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\r\n    /// msg.sender would be able to withdraw all of his tokens.\r\n    /// @param _amount uint256 The amount of tokens to unstake.\r\n    function unstake(uint256 _amount) external;\r\n\r\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\r\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\r\n    /// requested to release all stakes).\r\n    function withdraw() external;\r\n\r\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\r\n    function restake() external;\r\n\r\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\r\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\r\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\r\n    /// callers will be able to properly batch/paginate their requests.\r\n    /// @param _totalAmount uint256 The total amount of rewards to distribute.\r\n    /// @param _stakeOwners address[] The addresses of the stake owners.\r\n    /// @param _amounts uint256[] The amounts of the rewards.\r\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\r\n\r\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return uint256 The total stake.\r\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\r\n\r\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 The total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external view returns (uint256);\r\n\r\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\r\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\r\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\r\n        uint256 cooldownEndTime);\r\n\r\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\r\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\r\n    /// @param _amount uint256 The amount of tokens to migrate.\r\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\r\n\r\n    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n}\r\n\r\n// File: contracts/spec_interfaces/IManagedContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title managed contract interface, used by the contracts registry to notify the contract on updates\r\ninterface IManagedContract /* is ILockable, IContractRegistryAccessor, Initializable */ {\r\n\r\n    /// Refreshes the address of the other contracts the contract interacts with\r\n    /// @dev called by the registry contract upon an update of a contract in the registry\r\n    function refreshContracts() external;\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Contract registry contract interface\r\n/// @dev The contract registry holds Orbs PoS contracts and managers lists\r\n/// @dev The contract registry updates the managed contracts on changes in the contract list\r\n/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \r\n/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \r\n/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \r\ninterface IContractRegistry {\r\n\r\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\r\n\tevent ManagerChanged(string role, address newManager);\r\n\tevent ContractRegistryUpdated(address newContractRegistry);\r\n\r\n\t/*\r\n\t* External functions\r\n\t*/\r\n\r\n    /// Updates the contracts address and emits a corresponding event\r\n    /// @dev governance function called only by the migrationManager or registryAdmin\r\n    /// @param contractName is the contract name, used to identify it\r\n    /// @param addr is the contract updated address\r\n    /// @param managedContract indicates whether the contract is managed by the registry and notified on changes\r\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdminOrMigrationManager */;\r\n\r\n    /// Returns the current address of the given contracts\r\n    /// @param contractName is the contract name, used to identify it\r\n    /// @return addr is the contract updated address\r\n\tfunction getContract(string calldata contractName) external view returns (address);\r\n\r\n    /// Returns the list of contract addresses managed by the registry\r\n    /// @dev Managed contracts are updated on changes in the registry contracts addresses \r\n    /// @return addrs is the list of managed contracts\r\n\tfunction getManagedContracts() external view returns (address[] memory);\r\n\r\n    /// Locks all the managed contracts \r\n    /// @dev governance function called only by the migrationManager or registryAdmin\r\n    /// @dev When set all onlyWhenActive functions will revert\r\n\tfunction lockContracts() external /* onlyAdminOrMigrationManager */;\r\n\r\n    /// Unlocks all the managed contracts \r\n    /// @dev governance function called only by the migrationManager or registryAdmin\r\n\tfunction unlockContracts() external /* onlyAdminOrMigrationManager */;\r\n\t\r\n    /// Updates a manager address and emits a corresponding event\r\n    /// @dev governance function called only by the registryAdmin\r\n    /// @dev the managers list is a flexible list of role to the manager's address\r\n    /// @param role is the managers' role name, for example \"functionalManager\"\r\n    /// @param manager is the manager updated address\r\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\r\n\r\n    /// Returns the current address of the given manager\r\n    /// @param role is the manager name, used to identify it\r\n    /// @return addr is the manager updated address\r\n\tfunction getManager(string calldata role) external view returns (address);\r\n\r\n    /// Sets a new contract registry to migrate to\r\n    /// @dev governance function called only by the registryAdmin\r\n    /// @dev updates the registry address record in all the managed contracts\r\n    /// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\r\n    /// @param newRegistry is the new registry contract \r\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\r\n\r\n    /// Returns the previous contract registry address \r\n    /// @dev used when the setting the contract as a new registry to assure a valid registry\r\n    /// @return previousContractRegistry is the previous contract registry\r\n\tfunction getPreviousContractRegistry() external view returns (address);\r\n}\r\n\r\n// File: contracts/spec_interfaces/IContractRegistryAccessor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IContractRegistryAccessor {\r\n\r\n    /// Sets the contract registry address\r\n    /// @dev governance function called only by an admin\r\n    /// @param newRegistry is the new registry contract \r\n    function setContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\r\n\r\n    /// Returns the contract registry address\r\n    /// @return contractRegistry is the contract registry address\r\n    function getContractRegistry() external view returns (IContractRegistry contractRegistry);\r\n\r\n    function setRegistryAdmin(address _registryAdmin) external /* onlyInitializationAdmin */;\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/WithClaimableRegistryManagement.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract WithClaimableRegistryManagement is Context {\r\n    address private _registryAdmin;\r\n    address private _pendingRegistryAdmin;\r\n\r\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _registryAdmin = msgSender;\r\n        emit RegistryManagementTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current registryAdmin.\r\n     */\r\n    function registryAdmin() public view returns (address) {\r\n        return _registryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the registryAdmin.\r\n     */\r\n    modifier onlyRegistryAdmin() {\r\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current registryAdmin.\r\n     */\r\n    function isRegistryAdmin() public view returns (bool) {\r\n        return _msgSender() == _registryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\r\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\r\n     *\r\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\r\n     * thereby removing any functionality that is only available to the registryAdmin.\r\n     */\r\n    function renounceRegistryManagement() public onlyRegistryAdmin {\r\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\r\n        _registryAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\r\n     */\r\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\r\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\r\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\r\n        _registryAdmin = newRegistryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingManager.\r\n     */\r\n    modifier onlyPendingRegistryAdmin() {\r\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current registryAdmin to set the pendingManager address.\r\n     * @param newRegistryAdmin The address to transfer registryManagement to.\r\n     */\r\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\r\n        _pendingRegistryAdmin = newRegistryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\r\n     */\r\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\r\n        _transferRegistryManagement(_pendingRegistryAdmin);\r\n        _pendingRegistryAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current pendingRegistryAdmin\r\n    */\r\n    function pendingRegistryAdmin() public view returns (address) {\r\n       return _pendingRegistryAdmin;  \r\n    }\r\n}\r\n\r\n// File: contracts/Initializable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Initializable {\r\n\r\n    address private _initializationAdmin;\r\n\r\n    event InitializationComplete();\r\n\r\n    /// Constructor\r\n    /// Sets the initializationAdmin to the contract deployer\r\n    /// The initialization admin may call any manager only function until initializationComplete\r\n    constructor() public{\r\n        _initializationAdmin = msg.sender;\r\n    }\r\n\r\n    modifier onlyInitializationAdmin() {\r\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * External functions\r\n    */\r\n\r\n    /// Returns the initializationAdmin address\r\n    function initializationAdmin() public view returns (address) {\r\n        return _initializationAdmin;\r\n    }\r\n\r\n    /// Finalizes the initialization and revokes the initializationAdmin role \r\n    function initializationComplete() external onlyInitializationAdmin {\r\n        _initializationAdmin = address(0);\r\n        emit InitializationComplete();\r\n    }\r\n\r\n    /// Checks if the initialization was completed\r\n    function isInitializationComplete() public view returns (bool) {\r\n        return _initializationAdmin == address(0);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ContractRegistryAccessor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\ncontract ContractRegistryAccessor is IContractRegistryAccessor, WithClaimableRegistryManagement, Initializable {\r\n\r\n    IContractRegistry private contractRegistry;\r\n\r\n    /// Constructor\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\r\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\r\n        setContractRegistry(_contractRegistry);\r\n        _transferRegistryManagement(_registryAdmin);\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationManager {\r\n        require(isMigrationManager(), \"sender is not the migration manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyFunctionalManager {\r\n        require(isFunctionalManager(), \"sender is not the functional manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    /// Checks whether the caller is Admin: either the contract registry, the registry admin, or the initialization admin\r\n    function isAdmin() internal view returns (bool) {\r\n        return msg.sender == address(contractRegistry) || msg.sender == registryAdmin() || msg.sender == initializationAdmin();\r\n    }\r\n\r\n    /// Checks whether the caller is a specific manager role or and Admin\r\n    /// @dev queries the registry contract for the up to date manager assignment\r\n    function isManager(string memory role) internal view returns (bool) {\r\n        IContractRegistry _contractRegistry = contractRegistry;\r\n        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;\r\n    }\r\n\r\n    /// Checks whether the caller is the migration manager\r\n    function isMigrationManager() internal view returns (bool) {\r\n        return isManager('migrationManager');\r\n    }\r\n\r\n    /// Checks whether the caller is the functional manager\r\n    function isFunctionalManager() internal view returns (bool) {\r\n        return isManager('functionalManager');\r\n    }\r\n\r\n    /* \r\n     * Contract getters, return the address of a contract by calling the contract registry \r\n     */ \r\n\r\n    function getProtocolContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"protocol\");\r\n    }\r\n\r\n    function getStakingRewardsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingRewards\");\r\n    }\r\n\r\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\r\n    }\r\n\r\n    function getCommitteeContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"committee\");\r\n    }\r\n\r\n    function getElectionsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"elections\");\r\n    }\r\n\r\n    function getDelegationsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"delegations\");\r\n    }\r\n\r\n    function getGuardiansRegistrationContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"guardiansRegistration\");\r\n    }\r\n\r\n    function getCertificationContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"certification\");\r\n    }\r\n\r\n    function getStakingContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"staking\");\r\n    }\r\n\r\n    function getSubscriptionsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"subscriptions\");\r\n    }\r\n\r\n    function getStakingRewardsWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\r\n    }\r\n\r\n    function getBootstrapRewardsWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\r\n    }\r\n\r\n    function getGeneralFeesWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"generalFeesWallet\");\r\n    }\r\n\r\n    function getCertifiedFeesWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\r\n    }\r\n\r\n    function getStakingContractHandler() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingContractHandler\");\r\n    }\r\n\r\n    /*\r\n    * Governance functions\r\n    */\r\n\r\n    event ContractRegistryAddressUpdated(address addr);\r\n\r\n    /// Sets the contract registry address\r\n    /// @dev governance function called only by an admin\r\n    /// @param newContractRegistry is the new registry contract \r\n    function setContractRegistry(IContractRegistry newContractRegistry) public override onlyAdmin {\r\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\r\n        contractRegistry = newContractRegistry;\r\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\r\n    }\r\n\r\n    /// Returns the contract registry that the contract is set to use\r\n    /// @return contractRegistry is the registry contract address\r\n    function getContractRegistry() public override view returns (IContractRegistry) {\r\n        return contractRegistry;\r\n    }\r\n\r\n    function setRegistryAdmin(address _registryAdmin) external override onlyInitializationAdmin {\r\n        _transferRegistryManagement(_registryAdmin);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/ILockable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title lockable contract interface, allows to lock a contract\r\ninterface ILockable {\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    /// Locks the contract to external non-governance function calls\r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon locking all managed contracts\r\n    /// @dev getters and migration functions remain active also for locked contracts\r\n    /// @dev checked by the onlyWhenActive modifier\r\n    function lock() external /* onlyMigrationManager */;\r\n\r\n    /// Unlocks the contract \r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\r\n    function unlock() external /* onlyMigrationManager */;\r\n\r\n    /// Returns the contract locking status\r\n    /// @return isLocked is a bool indicating the contract is locked \r\n    function isLocked() view external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/Lockable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/// @title lockable contract\r\ncontract Lockable is ILockable, ContractRegistryAccessor {\r\n\r\n    bool public locked;\r\n\r\n    /// Constructor\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\r\n\r\n    /// Locks the contract to external non-governance function calls\r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon locking all managed contracts\r\n    /// @dev getters and migration functions remain active also for locked contracts\r\n    /// @dev checked by the onlyWhenActive modifier\r\n    function lock() external override onlyMigrationManager {\r\n        locked = true;\r\n        emit Locked();\r\n    }\r\n\r\n    /// Unlocks the contract \r\n    /// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\r\n    function unlock() external override onlyMigrationManager {\r\n        locked = false;\r\n        emit Unlocked();\r\n    }\r\n\r\n    /// Returns the contract locking status\r\n    /// @return isLocked is a bool indicating the contract is locked \r\n    function isLocked() external override view returns (bool) {\r\n        return locked;\r\n    }\r\n\r\n    modifier onlyWhenActive() {\r\n        require(!locked, \"contract is locked for this operation\");\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/ManagedContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/// @title managed contract\r\ncontract ManagedContract is IManagedContract, Lockable {\r\n\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\r\n\r\n    /// Refreshes the address of the other contracts the contract interacts with\r\n    /// @dev called by the registry contract upon an update of a contract in the registry\r\n    function refreshContracts() virtual override external {}\r\n\r\n}\r\n\r\n// File: contracts/StakingContractHandler.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Staking contract handler\r\n/// @dev instantiated between the staking contract and delegation contract\r\n/// @dev handles migration and governance for the staking contract notification\r\ncontract StakingContractHandler is IStakingContractHandler, IStakeChangeNotifier, ManagedContract {\r\n\r\n    IStakingContract stakingContract;\r\n    struct Settings {\r\n        IStakeChangeNotifier delegationsContract;\r\n        bool notifyDelegations;\r\n    }\r\n    Settings settings;\r\n\r\n    /// @param _contractRegistry is the contract registry address\r\n    /// @param _registryAdmin is the registry admin address\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public ManagedContract(_contractRegistry, _registryAdmin) {\r\n        settings.notifyDelegations = true;\r\n    }\r\n\r\n    modifier onlyStakingContract() {\r\n        require(msg.sender == address(stakingContract), \"caller is not the staking contract\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * External functions\r\n    */\r\n\r\n    /// @dev Notifies of stake change event.\r\n    /// @dev IStakeChangeNotifier interface function.\r\n    /// @param stakeOwner address The address of the subject stake owner.\r\n    /// @param amount uint256 The difference in the total staked amount.\r\n    /// @param sign bool The sign of the added (true) or subtracted (false) amount.\r\n    /// @param updatedStake uint256 The updated total staked amount.\r\n    function stakeChange(address stakeOwner, uint256 amount, bool sign, uint256 updatedStake) external override onlyStakingContract {\r\n        Settings memory _settings = settings;\r\n        if (!_settings.notifyDelegations) {\r\n            emit StakeChangeNotificationSkipped(stakeOwner);\r\n            return;\r\n        }\r\n\r\n        _settings.delegationsContract.stakeChange(stakeOwner, amount, sign, updatedStake);\r\n    }\r\n\r\n    /// @dev Notifies of multiple stake change events.\r\n    /// @dev IStakeChangeNotifier interface function.\r\n    /// @param stakeOwners address[] The addresses of subject stake owners.\r\n    /// @param amounts uint256[] The differences in total staked amounts.\r\n    /// @param signs bool[] The signs of the added (true) or subtracted (false) amounts.\r\n    /// @param updatedStakes uint256[] The updated total staked amounts.\r\n    function stakeChangeBatch(address[] calldata stakeOwners, uint256[] calldata amounts, bool[] calldata signs, uint256[] calldata updatedStakes) external override onlyStakingContract {\r\n        Settings memory _settings = settings;\r\n        if (!_settings.notifyDelegations) {\r\n            emit StakeChangeBatchNotificationSkipped(stakeOwners);\r\n            return;\r\n        }\r\n\r\n        _settings.delegationsContract.stakeChangeBatch(stakeOwners, amounts, signs, updatedStakes);\r\n    }\r\n\r\n    /// @dev Notifies of stake migration event.\r\n    /// @dev IStakeChangeNotifier interface function.\r\n    /// @param stakeOwner address The address of the subject stake owner.\r\n    /// @param amount uint256 The migrated amount.\r\n    function stakeMigration(address stakeOwner, uint256 amount) external override onlyStakingContract {\r\n        Settings memory _settings = settings;\r\n        if (!_settings.notifyDelegations) {\r\n            emit StakeMigrationNotificationSkipped(stakeOwner);\r\n            return;\r\n        }\r\n\r\n        _settings.delegationsContract.stakeMigration(stakeOwner, amount);\r\n    }\r\n\r\n    /// Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param stakeOwner address The address to check.\r\n    /// @return uint256 The total stake.\r\n    function getStakeBalanceOf(address stakeOwner) external override view returns (uint256) {\r\n        return stakingContract.getStakeBalanceOf(stakeOwner);\r\n    }\r\n\r\n    /// Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 is the total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external override view returns (uint256) {\r\n        return stakingContract.getTotalStakedTokens();\r\n    }\r\n\r\n    /*\r\n    * Governance functions\r\n    */\r\n\r\n    /// Sets notifications to the delegation contract\r\n    /// @dev staking while notifications are disabled may lead to a discrepancy in the delegation data\r\n    /// @dev governance function called only by the migration manager\r\n    /// @param notifyDelegations is a bool indicating whether to notify the delegation contract\r\n    function setNotifyDelegations(bool notifyDelegations) external override onlyMigrationManager {\r\n        settings.notifyDelegations = notifyDelegations;\r\n        emit NotifyDelegationsChanged(notifyDelegations);\r\n    }\r\n\r\n    /// Returns the notifications to the delegation contract status\r\n    /// @return notifyDelegations is a bool indicating whether notifications are enabled\r\n    function getNotifyDelegations() external view override returns (bool) {\r\n        return settings.notifyDelegations;\r\n    }\r\n\r\n    /*\r\n     * Contracts topology / registry interface\r\n     */\r\n\r\n    /// Refreshes the address of the other contracts the contract interacts with\r\n    /// @dev called by the registry contract upon an update of a contract in the registry\r\n    function refreshContracts() external override {\r\n        settings.delegationsContract = IStakeChangeNotifier(getDelegationsContract());\r\n        stakingContract = IStakingContract(getStakingContract());\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitializationComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"notifyDelegations\",\"type\":\"bool\"}],\"name\":\"NotifyDelegationsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRegistryAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"RegistryManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"stakeOwners\",\"type\":\"address[]\"}],\"name\":\"StakeChangeBatchNotificationSkipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"}],\"name\":\"StakeChangeNotificationSkipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"}],\"name\":\"StakeMigrationNotificationSkipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractRegistry\",\"outputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNotifyDelegations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"}],\"name\":\"getStakeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitializationComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRegistryAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRegistryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"newContractRegistry\",\"type\":\"address\"}],\"name\":\"setContractRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"notifyDelegations\",\"type\":\"bool\"}],\"name\":\"setNotifyDelegations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"}],\"name\":\"setRegistryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"updatedStake\",\"type\":\"uint256\"}],\"name\":\"stakeChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"stakeOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"signs\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"updatedStakes\",\"type\":\"uint256[]\"}],\"name\":\"stakeChangeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"transferRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingContractHandler","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000d859701c81119ab12a1e62af6270ad2ae05c7ab3000000000000000000000000f1fd5233e60e7ef797025fe9dd066d60d59bcb92","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ef917d3800330277c042c4f55619d9a09876bd1547ba82be07d5b85d17f6a0bf"}]}