{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.9;\r\n//SPDX-License-Identifier: MIT\r\n\r\n\r\nlibrary SafeMathChainlink {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\ncontract VRFRequestIDBase {\r\n\r\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\r\n    address _requester, uint256 _nonce)\r\n    internal pure returns (uint256)\r\n  {\r\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n  }\r\n\r\n  function makeRequestId(\r\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\r\n  }\r\n}\r\n\r\n\r\nabstract contract VRFConsumerBase is VRFRequestIDBase {\r\n\r\n  using SafeMathChainlink for uint256;\r\n\r\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\r\n    internal virtual;\r\n\r\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\r\n    internal returns (bytes32 requestId)\r\n  {\r\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\r\n\r\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\r\n\r\n    nonces[_keyHash] = nonces[_keyHash].add(1);\r\n    return makeRequestId(_keyHash, vRFSeed);\r\n  }\r\n\r\n  LinkTokenInterface immutable internal LINK;\r\n  address immutable private vrfCoordinator;\r\n\r\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\r\n\r\n  constructor(address _vrfCoordinator, address _link) public {\r\n    vrfCoordinator = _vrfCoordinator;\r\n    LINK = LinkTokenInterface(_link);\r\n  }\r\n\r\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\r\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n    fulfillRandomness(requestId, randomness);\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n} \r\n\r\ncontract CandorFi is VRFConsumerBase{\r\n    uint[] private entryArray;\r\n    address[] public userAddresses;\r\n    address public owner;\r\n    uint public totalEntry;\r\n    uint public round;\r\n    uint public random;\r\n    uint public ticketPrice = 10 * 1e6; // 10$ ticket price (18 decimals)\r\n    uint public poolLimit = 20000 * 1e6; // 10000$ pool limit\r\n    uint public adminFee = 50; //50% admin fee\r\n    IERC20 public token;\r\n    \r\n    bytes32 internal keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\r\n\tuint internal fee;\r\n\tuint public randomResult;\r\n\tuint public oldRandomResult;\r\n\t\r\n    struct User{\r\n        bool isEntered;\r\n        uint totalEntries;\r\n    }\r\n    modifier onlyOwner{\r\n        require(msg.sender == owner,\"Only owner allowed\");\r\n        _;\r\n    }\r\n    mapping(uint => address) public entryMapping;\r\n    mapping(uint => mapping(address => User)) public userInfo;\r\n    \r\n    event RandomNumberGenerated(bytes32,uint256);\r\n    event EntryComplete(address,uint,uint);\r\n    event WinnerPicked(address,uint);\r\n    \r\n    function setTicketPrice(uint value) external onlyOwner{\r\n       ticketPrice = value; \r\n    }\r\n    \r\n    function setPoolLimit(uint value) external onlyOwner{\r\n        poolLimit = value;\r\n    }\r\n    \r\n    function setAdminFee(uint value) external onlyOwner{\r\n        adminFee = value;\r\n    }\r\n    \r\n    function withdrawLink(uint value) external onlyOwner {\r\n    \trequire(LINK.transfer(msg.sender, value), \"Unable to transfer\");\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) external onlyOwner{\r\n        owner = newOwner;\r\n    }\r\n    \r\n    //Mainnet network\r\n    constructor() VRFConsumerBase (\r\n            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,  //VRF Coordinator\r\n\t        0x514910771AF9Ca656af840dff83E8264EcF986CA   //LINK token\r\n           ) public {\r\n        fee = 2000000000000000000; // 2 LINK\r\n        owner = msg.sender;\r\n        token = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC contract address\r\n    }\r\n    \r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\r\n        randomResult = randomness;\r\n        emit RandomNumberGenerated(requestId,randomResult);\r\n    }\r\n    \r\n    function getRandomNumber() public onlyOwner returns (bytes32 requestId) {\r\n        require(LINK.balanceOf(address(this)) > fee, \"Not enough LINK - fill contract with faucet\");\r\n        return requestRandomness(keyHash, fee, getSeed());\r\n    }\r\n    \r\n    function enterLottery(uint256 amount) external {\r\n        require(amount >= ticketPrice && amount <= (poolLimit / 4),\"Invalid amount!\");\r\n        require(!userInfo[round][msg.sender].isEntered,\"Already entered!\");\r\n        require(token.allowance(msg.sender,address(this)) >= amount,\"Set allowance first!\");\r\n        bool success = token.transferFrom(msg.sender,address(this),amount);\r\n        require(success,\"Transfer failed\");\r\n        require(token.balanceOf(address(this)) <= poolLimit,\"Pool already full\");\r\n        uint ticketCount = amount.div(ticketPrice);\r\n        require((totalEntry + ticketCount) <= (poolLimit / ticketPrice),\"Buy lower amount of tickets\");\r\n        userInfo[round][msg.sender].totalEntries = ticketCount;\r\n        userInfo[round][msg.sender].isEntered = true;\r\n        entryArray.push(totalEntry);\r\n        entryMapping[totalEntry] = msg.sender; \r\n        totalEntry += ticketCount;\r\n        userAddresses.push(msg.sender);\r\n        emit EntryComplete(msg.sender,amount,ticketCount);\r\n    }\r\n    \r\n    function pickWinner() external onlyOwner{\r\n        require(userAddresses.length >=4,\"Atleast 4 participants\");\r\n        require(oldRandomResult != randomResult,\"Update random number first!\");\r\n        oldRandomResult = randomResult;\r\n        uint totalBalance = token.balanceOf(address(this));\r\n        uint winner = calculateWinner((randomResult.mod(totalEntry)));\r\n        address wonUser = entryMapping[winner];\r\n        token.transfer(owner,(totalBalance * adminFee) / 100);\r\n        totalBalance -= (totalBalance * adminFee) / 100;\r\n        token.transfer(wonUser,totalBalance);\r\n        emit WinnerPicked(wonUser,(randomResult.mod(totalEntry)));\r\n        totalEntry = 0;\r\n        entryArray = new uint[](0);\r\n        userAddresses = new address[](0);\r\n        round++;\r\n    }\r\n    \r\n    function getSeed() private view returns(uint) {\r\n\t\treturn uint(keccak256(abi.encodePacked(block.difficulty, now, userAddresses)));\r\n\t}\r\n\t\r\n\tfunction calculateWinner(uint target) internal view returns(uint){\r\n\t    uint last = entryArray.length; \r\n\t    uint first = 0;\r\n\t    uint mid = 0;\r\n\t    if(target <= entryArray[0]){\r\n\t        return entryArray[0];\r\n\t    }\r\n\t    \r\n\t    if(target >= entryArray[last-1]){\r\n\t        return entryArray[last-1];\r\n\t    }\r\n\t    \r\n\t    while(first < last){\r\n\t        mid = (first + last) / 2;\r\n\t        \r\n\t        if(entryArray[mid] == target){\r\n\t            return entryArray[mid];\r\n\t        }\r\n\t        \r\n\t        if(target < entryArray[mid]){\r\n\t            if(mid > 0 && target > entryArray[mid - 1]){\r\n\t                return entryArray[mid - 1];\r\n\t            }\r\n\t            \r\n\t            last = mid;\r\n\t        }\r\n\t        else{\r\n\t            if(mid < last - 1 && target < entryArray[mid + 1]){\r\n\t                return entryArray[mid];\r\n\t            }\r\n\t            \r\n\t            first = mid + 1;\r\n\t        }\r\n\t    }\r\n\t    return entryArray[mid];\r\n\t}\r\n\t\r\n\tfunction winningAmount() public view returns(uint amount,uint winchance){\r\n\t    return(\r\n\t        token.balanceOf(address(this)) * 8 / 10,\r\n\t        (userInfo[round][msg.sender].totalEntries * 100) / totalEntry);\r\n\t}\r\n\t\r\n\tfunction allUsers() external view returns(address[] memory){\r\n\t    return userAddresses;\r\n\t}\r\n\t\r\n\tfunction transferAnyERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\r\n\t    require(_tokenAddress != address(token),\"Not USDT\");\r\n        IERC20(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n\t\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EntryComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RandomNumberGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WinnerPicked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entryMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldRandomResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pickWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setAdminFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setPoolLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEntered\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalEntries\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winningAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winchance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CandorFi","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://99a3ff118f913b967c4188a84d1131952a1121dc5059c440d3aeb7195a7a355c"}]}