{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/simple-uniswap-oracle/SimpleUniswapOracle.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./libraries/UQ112x112.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./interfaces/ISimpleUniswapOracle.sol\\\";\\r\\n\\r\\ncontract SimpleUniswapOracle is ISimpleUniswapOracle {\\r\\n\\tusing UQ112x112 for uint224;\\r\\n\\t\\r\\n\\tuint32 public constant MIN_T = 1800;\\r\\n\\t\\r\\n\\tstruct Pair {\\r\\n\\t\\tuint256 priceCumulativeA;\\r\\n\\t\\tuint256 priceCumulativeB;\\r\\n\\t\\tuint32 updateA;\\r\\n\\t\\tuint32 updateB;\\r\\n\\t\\tbool lastIsA;\\r\\n\\t\\tbool initialized;\\r\\n\\t}\\r\\n\\tmapping(address => Pair) public getPair;\\r\\n\\r\\n\\tevent PriceUpdate(address indexed pair, uint256 priceCumulative, uint32 blockTimestamp, bool lastIsA);\\r\\n\\t\\r\\n\\tfunction toUint224(uint256 input) internal pure returns (uint224) {\\r\\n\\t\\trequire(input <= uint224(-1), \\\"UniswapOracle: UINT224_OVERFLOW\\\");\\r\\n\\t\\treturn uint224(input);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction getPriceCumulativeCurrent(address uniswapV2Pair) internal view returns (uint256 priceCumulative) {\\r\\n\\t\\tpriceCumulative = IUniswapV2Pair(uniswapV2Pair).price0CumulativeLast();\\r\\n\\t\\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(uniswapV2Pair).getReserves();\\r\\n\\t\\tuint224 priceLast = UQ112x112.encode(reserve1).uqdiv(reserve0);\\r\\n\\t\\tuint32 timeElapsed = getBlockTimestamp() - blockTimestampLast; // overflow is desired\\r\\n\\t\\t// * never overflows, and + overflow is desired\\r\\n\\t\\tpriceCumulative += uint256(priceLast) * timeElapsed;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction initialize(address uniswapV2Pair) external {\\r\\n\\t\\tPair storage pairStorage = getPair[uniswapV2Pair];\\r\\n\\t\\trequire(!pairStorage.initialized, \\\"UniswapOracle: ALREADY_INITIALIZED\\\");\\r\\n\\t\\t\\r\\n\\t\\tuint256 priceCumulativeCurrent = getPriceCumulativeCurrent(uniswapV2Pair);\\r\\n\\t\\tuint32 blockTimestamp = getBlockTimestamp();\\r\\n\\t\\tpairStorage.priceCumulativeA = priceCumulativeCurrent;\\r\\n\\t\\tpairStorage.priceCumulativeB = priceCumulativeCurrent;\\r\\n\\t\\tpairStorage.updateA = blockTimestamp;\\r\\n\\t\\tpairStorage.updateB = blockTimestamp;\\r\\n\\t\\tpairStorage.lastIsA = true;\\r\\n\\t\\tpairStorage.initialized = true;\\r\\n\\t\\temit PriceUpdate(uniswapV2Pair, priceCumulativeCurrent, blockTimestamp, true);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T) {\\r\\n\\t\\tPair memory pair = getPair[uniswapV2Pair];\\r\\n\\t\\trequire(pair.initialized, \\\"UniswapOracle: NOT_INITIALIZED\\\");\\r\\n\\t\\tPair storage pairStorage = getPair[uniswapV2Pair];\\r\\n\\t\\t\\t\\t\\r\\n\\t\\tuint32 blockTimestamp = getBlockTimestamp();\\r\\n\\t\\tuint32 updateLast = pair.lastIsA ? pair.updateA : pair.updateB;\\r\\n\\t\\tuint256 priceCumulativeCurrent = getPriceCumulativeCurrent(uniswapV2Pair);\\r\\n\\t\\tuint256 priceCumulativeLast;\\r\\n\\t\\t\\r\\n\\t\\tif (blockTimestamp - updateLast >= MIN_T) {\\r\\n\\t\\t\\t// update\\r\\n\\t\\t\\tpriceCumulativeLast = pair.lastIsA ? pair.priceCumulativeA : pair.priceCumulativeB;\\r\\n\\t\\t\\tif (pair.lastIsA) {\\r\\n\\t\\t\\t\\tpairStorage.priceCumulativeB = priceCumulativeCurrent;\\r\\n\\t\\t\\t\\tpairStorage.updateB = blockTimestamp;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tpairStorage.priceCumulativeA = priceCumulativeCurrent;\\r\\n\\t\\t\\t\\tpairStorage.updateA = blockTimestamp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpairStorage.lastIsA = !pair.lastIsA;\\r\\n\\t\\t\\temit PriceUpdate(uniswapV2Pair, priceCumulativeCurrent, blockTimestamp, !pair.lastIsA);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// don't update and return price using previous priceCumulative\\r\\n\\t\\t\\tupdateLast = pair.lastIsA ? pair.updateB : pair.updateA;\\r\\n\\t\\t\\tpriceCumulativeLast = pair.lastIsA ? pair.priceCumulativeB : pair.priceCumulativeA;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tT = blockTimestamp - updateLast; // overflow is desired\\r\\n\\t\\trequire(T >= MIN_T, \\\"UniswapOracle: NOT_READY\\\"); //reverts only if the pair has just been initialized\\r\\n\\t\\t// / is safe, and - overflow is desired\\r\\n\\t\\tprice = toUint224((priceCumulativeCurrent - priceCumulativeLast) / T);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/*** Utilities ***/\\r\\n\\t\\r\\n\\tfunction getBlockTimestamp() public view returns (uint32) {\\r\\n\\t\\treturn uint32(block.timestamp % 2**32);\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/simple-uniswap-oracle/interfaces/ISimpleUniswapOracle.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\ninterface ISimpleUniswapOracle {\\r\\n\\tevent PriceUpdate(address indexed pair, uint256 priceCumulative, uint32 blockTimestamp, bool lastIsA);\\r\\n\\tfunction MIN_T() external pure returns (uint32);\\r\\n\\tfunction getBlockTimestamp() external view returns (uint32);\\r\\n\\tfunction getPair(address uniswapV2Pair) external view returns (\\r\\n\\t\\tuint256 priceCumulativeA,\\r\\n\\t\\tuint256 priceCumulativeB,\\r\\n\\t\\tuint32 updateA,\\r\\n\\t\\tuint32 updateB,\\r\\n\\t\\tbool lastIsA,\\r\\n\\t\\tbool initialized\\r\\n\\t);\\r\\n\\tfunction initialize(address uniswapV2Pair) external;\\r\\n\\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T);\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/simple-uniswap-oracle/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/simple-uniswap-oracle/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceCumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lastIsA\",\"type\":\"bool\"}],\"name\":\"PriceUpdate\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_T\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceCumulativeA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceCumulativeB\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateA\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"updateB\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"lastIsA\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"}],\"name\":\"getResult\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"price\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"T\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SimpleUniswapOracle","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}