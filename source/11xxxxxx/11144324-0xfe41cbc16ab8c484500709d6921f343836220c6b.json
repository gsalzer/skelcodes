{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/ISettingsRegistry.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ISettingsRegistry {\r\n    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\r\n\r\n    function uintOf(bytes32 _propertyName) public view returns (uint256);\r\n\r\n    function stringOf(bytes32 _propertyName) public view returns (string);\r\n\r\n    function addressOf(bytes32 _propertyName) public view returns (address);\r\n\r\n    function bytesOf(bytes32 _propertyName) public view returns (bytes);\r\n\r\n    function boolOf(bytes32 _propertyName) public view returns (bool);\r\n\r\n    function intOf(bytes32 _propertyName) public view returns (int);\r\n\r\n    function setUintProperty(bytes32 _propertyName, uint _value) public;\r\n\r\n    function setStringProperty(bytes32 _propertyName, string _value) public;\r\n\r\n    function setAddressProperty(bytes32 _propertyName, address _value) public;\r\n\r\n    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\r\n\r\n    function setBoolProperty(bytes32 _propertyName, bool _value) public;\r\n\r\n    function setIntProperty(bytes32 _propertyName, int _value) public;\r\n\r\n    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\r\n\r\n    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IBurnableERC20.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IBurnableERC20 {\r\n    function burn(address _from, uint _value) public;\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IMintableERC20.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IMintableERC20 {\r\n\r\n    function mint(address _to, uint256 _value) public;\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IAuthority.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract IAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\n// File: @evolutionland/common/contracts/DSAuth.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n/**\r\n * @title DSAuth\r\n * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\r\n * But in the isAuthorized method, the src from address(this) is remove for safty concern.\r\n */\r\ncontract DSAuth is DSAuthEvents {\r\n    IAuthority   public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(IAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (authority == IAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @evolutionland/common/contracts/SettingIds.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n    Id definitions for SettingsRegistry.sol\r\n    Can be used in conjunction with the settings registry to get properties\r\n*/\r\ncontract SettingIds {\r\n    bytes32 public constant CONTRACT_RING_ERC20_TOKEN = \"CONTRACT_RING_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_KTON_ERC20_TOKEN = \"CONTRACT_KTON_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN = \"CONTRACT_GOLD_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN = \"CONTRACT_WOOD_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_WATER_ERC20_TOKEN = \"CONTRACT_WATER_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN = \"CONTRACT_FIRE_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN = \"CONTRACT_SOIL_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_OBJECT_OWNERSHIP = \"CONTRACT_OBJECT_OWNERSHIP\";\r\n\r\n    bytes32 public constant CONTRACT_TOKEN_LOCATION = \"CONTRACT_TOKEN_LOCATION\";\r\n\r\n    bytes32 public constant CONTRACT_LAND_BASE = \"CONTRACT_LAND_BASE\";\r\n\r\n    bytes32 public constant CONTRACT_USER_POINTS = \"CONTRACT_USER_POINTS\";\r\n\r\n    bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER = \"CONTRACT_INTERSTELLAR_ENCODER\";\r\n\r\n    bytes32 public constant CONTRACT_DIVIDENDS_POOL = \"CONTRACT_DIVIDENDS_POOL\";\r\n\r\n    bytes32 public constant CONTRACT_TOKEN_USE = \"CONTRACT_TOKEN_USE\";\r\n\r\n    bytes32 public constant CONTRACT_REVENUE_POOL = \"CONTRACT_REVENUE_POOL\";\r\n\r\n    bytes32 public constant CONTRACT_ERC721_BRIDGE = \"CONTRACT_ERC721_BRIDGE\";\r\n\r\n    bytes32 public constant CONTRACT_PET_BASE = \"CONTRACT_PET_BASE\";\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // this can be considered as transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set ownerCut to 4%\r\n    // ownerCut = 400;\r\n    bytes32 public constant UINT_AUCTION_CUT = \"UINT_AUCTION_CUT\";  // Denominator is 10000\r\n\r\n    bytes32 public constant UINT_TOKEN_OFFER_CUT = \"UINT_TOKEN_OFFER_CUT\";  // Denominator is 10000\r\n\r\n    // Cut referer takes on each auction, measured in basis points (1/100 of a percent).\r\n    // which cut from transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set refererCut to 4%\r\n    // refererCut = 400;\r\n    bytes32 public constant UINT_REFERER_CUT = \"UINT_REFERER_CUT\";\r\n\r\n    bytes32 public constant CONTRACT_LAND_RESOURCE = \"CONTRACT_LAND_RESOURCE\";\r\n}\r\n\r\n// File: contracts/BankSettingIds.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract BankSettingIds is SettingIds {\r\n\r\n    // depositing X RING for 12 months, interest is about (1 * _unitInterest * X / 10**7) KTON\r\n    // default: 1000\r\n    bytes32 public constant UINT_BANK_UNIT_INTEREST = \"UINT_BANK_UNIT_INTEREST\";\r\n\r\n    // penalty multiplier\r\n    // default: 3\r\n    bytes32 public constant UINT_BANK_PENALTY_MULTIPLIER = \"UINT_BANK_PENALTY_MULTIPLIER\";\r\n}\r\n\r\n// File: contracts/GringottsBankV2.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract  GringottsBank is DSAuth, BankSettingIds {\r\n    /*\r\n     *  Events\r\n     */\r\n    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\r\n\r\n    event NewDeposit(uint256 indexed _depositID, address indexed _depositor, uint _value, uint _month, uint _interest);\r\n\r\n    event ClaimedDeposit(uint256 indexed _depositID, address indexed _depositor, uint _value, bool isPenalty, uint penaltyAmount);\r\n\r\n    event TransferDeposit(uint256 indexed _depositID, address indexed _oldDepositor, address indexed _newDepositor);\r\n\r\n    event BurnAndRedeem(uint256 indexed _depositID,  address _depositor, uint48 _months, uint48 _startAt, uint64 _unitInterest, uint128 _value, bytes _data);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint public constant MONTH = 30 * 1 days;\r\n\r\n    /*\r\n     *  Structs\r\n     */\r\n    struct Deposit {\r\n        address depositor;\r\n        uint48 months; // Length of time from the deposit's beginning to end (in months), For now, months must >= 1 and <= 36\r\n        uint48 startAt;   // when player deposit, timestamp in seconds\r\n        uint128 value;  // amount of ring\r\n        uint64 unitInterest;\r\n        bool claimed;\r\n    }\r\n\r\n\r\n    /*\r\n     *  Storages\r\n     */\r\n\r\n    bool private singletonLock = false;\r\n\r\n\r\n    ISettingsRegistry public registry;\r\n\r\n    mapping (uint256 => Deposit) public deposits;\r\n\r\n    uint public depositCount;\r\n\r\n    mapping (address => uint[]) public userDeposits;\r\n\r\n    // player => totalDepositRING, total number of ring that the player has deposited\r\n    mapping (address => uint256) public userTotalDeposit;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier singletonLockCall() {\r\n        require(!singletonLock, \"Only can call once\");\r\n        _;\r\n        singletonLock = true;\r\n    }\r\n\r\n    modifier canBeStoredWith128Bits(uint256 _value) {\r\n        require(_value < 340282366920938463463374607431768211455);\r\n        _;\r\n    }\r\n\r\n    modifier canBeStoredWith48Bits(uint256 _value) {\r\n        require(_value < 281474976710656);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Bank's constructor which set the token address and unitInterest_\r\n     */\r\n    constructor () public {\r\n        // initializeContract(_registry);\r\n    }\r\n\r\n    /**\r\n     * @dev Same with constructor, but is used and called by storage proxy as logic contract.\r\n     * @param _registry - address of SettingsRegistry\r\n     */\r\n    function initializeContract(address _registry) public singletonLockCall {\r\n        // call Ownable's constructor\r\n        owner = msg.sender;\r\n\r\n        emit LogSetOwner(msg.sender);\r\n\r\n        registry = ISettingsRegistry(_registry);\r\n    }\r\n\r\n    function getDeposit(uint _id) public view returns (address, uint128, uint128, uint256, uint256, bool ) {\r\n        return (deposits[_id].depositor, deposits[_id].value, deposits[_id].months,\r\n            deposits[_id].startAt, deposits[_id].unitInterest, deposits[_id].claimed);\r\n    }\r\n\r\n    /**\r\n     * @dev ERC223 fallback function, make sure to check the msg.sender is from target token contracts\r\n     * @param _from - person who transfer token in for deposits or claim deposit with penalty KTON.\r\n     * @param _amount - amount of token.\r\n     * @param _data - data which indicate the operations.\r\n     */\r\n    function tokenFallback(address _from, uint256 _amount, bytes _data) public {\r\n        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\r\n        address kryptonite = registry.addressOf(SettingIds.CONTRACT_KTON_ERC20_TOKEN);\r\n\r\n        // deposit entrance\r\n        if(ring == msg.sender) {\r\n            uint months = bytesToUint256(_data);\r\n            _deposit(_from, _amount, months);\r\n        }\r\n        //  Early Redemption entrance\r\n\r\n        if (kryptonite == msg.sender) {\r\n            uint _depositID = bytesToUint256(_data);\r\n\r\n            require(_amount >= computePenalty(_depositID), \"No enough amount of KTON penalty.\");\r\n\r\n            _claimDeposit(_from, _depositID, true, _amount);\r\n\r\n            // burn the KTON transferred in\r\n            IBurnableERC20(kryptonite).burn(address(this), _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev transfer of deposit from  Ethereum network to Darwinia Network, params can be obtained by the function 'getDeposit'\r\n     * @param _depositID - ID of deposit.\r\n     * @param _data - receiving address of darwinia network.\r\n\r\n     */\r\n    function burnAndRedeem(uint256 _depositID, bytes _data) public {\r\n        bytes32 darwiniaAddress;\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            darwiniaAddress := mload(add(ptr, 100))\r\n        }\r\n\r\n        // Check the validity of the deposit\r\n        require(deposits[_depositID].claimed == false, \"Already claimed\");\r\n        require(deposits[_depositID].startAt > 0, \"Deposit not created.\");\r\n        require(deposits[_depositID].depositor == msg.sender, \"Permission denied\");\r\n\r\n        require(_data.length == 32, \"The address (Darwinia Network) must be in a 32 bytes hexadecimal format\");\r\n        require(darwiniaAddress != bytes32(0x0), \"Darwinia Network Address can't be empty\");\r\n\r\n        removeUserDepositsByID(_depositID, msg.sender);\r\n\r\n        require(deposits[_depositID].value <= userTotalDeposit[msg.sender], \"Subtraction overflow\");\r\n        userTotalDeposit[msg.sender] -= deposits[_depositID].value;\r\n\r\n        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\r\n        IBurnableERC20(ring).burn(address(this), deposits[_depositID].value);\r\n        \r\n        emit BurnAndRedeem(\r\n            _depositID, \r\n            deposits[_depositID].depositor, \r\n            deposits[_depositID].months, \r\n            deposits[_depositID].startAt, \r\n            deposits[_depositID].unitInterest, \r\n            deposits[_depositID].value, \r\n            _data\r\n        );\r\n\r\n        delete deposits[_depositID];\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit for msg sender, require the token approvement ahead.\r\n     * @param _amount - amount of token.\r\n     * @param _months - the amount of months that the token will be locked in the deposit.\r\n     */\r\n    function deposit(uint256 _amount, uint256 _months) public {\r\n        deposit(msg.sender, _amount, _months);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit for benificiary, require the token approvement ahead.\r\n     * @param _benificiary - benificiary of the deposit, which will get the KTON and RINGs after deposit being claimed.\r\n     * @param _amount - amount of token.\r\n     * @param _months - the amount of months that the token will be locked in the deposit.\r\n     */\r\n    function deposit(address _benificiary, uint256 _amount, uint256 _months) public {\r\n\r\n        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\r\n        require(ERC20(ring).transferFrom(msg.sender, address(this), _amount), \"RING token tranfer failed.\");\r\n\r\n\r\n        _deposit(_benificiary, _amount, _months);\r\n    }\r\n\r\n    function claimDeposit(uint _depositID) public {\r\n        _claimDeposit(msg.sender, _depositID, false, 0);\r\n    }\r\n\r\n    function claimDepositWithPenalty(uint _depositID) public {\r\n        address kryptonite = ERC20(registry.addressOf(SettingIds.CONTRACT_KTON_ERC20_TOKEN));\r\n        uint256 _penalty = computePenalty(_depositID);\r\n\r\n        require(ERC20(kryptonite).transferFrom(msg.sender, address(this), _penalty));\r\n\r\n        _claimDeposit(msg.sender, _depositID, true, _penalty);\r\n\r\n        IBurnableERC20(kryptonite).burn(address(this), _penalty);\r\n    }\r\n\r\n    function transferDeposit(address _benificiary, uint _depositID) public {\r\n        require(deposits[_depositID].depositor == msg.sender, \"Depositor must be the msg.sender\");\r\n        require(_benificiary != 0x0, \"Benificiary can not be zero\");\r\n        require(deposits[_depositID].claimed == false, \"Already claimed, can not transfer.\");\r\n\r\n        // update the depositor of the deposit.\r\n        deposits[_depositID].depositor = _benificiary;\r\n\r\n        // update the deposit ids of the original user and new user.\r\n        removeUserDepositsByID(_depositID, msg.sender);\r\n        userDeposits[_benificiary].push(_depositID);\r\n\r\n        // update the balance of the original depositor and new depositor.\r\n        require(deposits[_depositID].value <= userTotalDeposit[msg.sender], \"Subtraction overflow\");\r\n        userTotalDeposit[msg.sender] -= deposits[_depositID].value;\r\n\r\n        userTotalDeposit[_benificiary] += deposits[_depositID].value;\r\n        require(userTotalDeposit[_benificiary] >= deposits[_depositID].value, \"Addition overflow\");\r\n\r\n        emit TransferDeposit(_depositID, msg.sender, _benificiary);\r\n    }\r\n\r\n    // normal Redemption, withdraw at maturity\r\n    function _claimDeposit(address _depositor, uint _depositID, bool isPenalty, uint _penaltyAmount) internal {\r\n\r\n        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\r\n\r\n        require(deposits[_depositID].startAt > 0, \"Deposit not created.\");\r\n        require(deposits[_depositID].claimed == false, \"Already claimed\");\r\n        require(deposits[_depositID].depositor == _depositor, \"Depositor must match.\");\r\n\r\n        if (isPenalty) {\r\n            require(now - deposits[_depositID].startAt < deposits[_depositID].months * MONTH );\r\n        } else {\r\n            require(now - deposits[_depositID].startAt >= deposits[_depositID].months * MONTH );\r\n        }\r\n\r\n        deposits[_depositID].claimed = true;\r\n        userTotalDeposit[_depositor] -= deposits[_depositID].value;\r\n\r\n        require(ERC20(ring).transfer(_depositor, deposits[_depositID].value));\r\n\r\n\r\n        emit ClaimedDeposit(_depositID, _depositor, deposits[_depositID].value, isPenalty, _penaltyAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev deposit actions\r\n     * @param _depositor - person who deposits\r\n     * @param _value - depositor wants to deposit how many tokens\r\n     * @param _month - Length of time from the deposit's beginning to end (in months).\r\n     */\r\n\r\n    function _deposit(address _depositor, uint _value, uint _month)\r\n        canBeStoredWith128Bits(_value) canBeStoredWith128Bits(_month) internal returns (uint _depositId) {\r\n\r\n        address kryptonite = ERC20(registry.addressOf(SettingIds.CONTRACT_KTON_ERC20_TOKEN));\r\n\r\n        require( _value > 0 );  // because the _value is pass in from token transfer, token transfer will help check, so there should not be overflow issues.\r\n        require( _month <= 36 && _month >= 1 );\r\n\r\n        _depositId = depositCount;\r\n\r\n        uint64 _unitInterest = uint64(registry.uintOf(BankSettingIds.UINT_BANK_UNIT_INTEREST));\r\n\r\n        deposits[_depositId] = Deposit({\r\n            depositor: _depositor,\r\n            value: uint128(_value),\r\n            months: uint48(_month),\r\n            startAt: uint48(now),\r\n            unitInterest: uint48(_unitInterest),\r\n            claimed: false\r\n        });\r\n\r\n        depositCount += 1;\r\n\r\n        userDeposits[_depositor].push(_depositId);\r\n\r\n        userTotalDeposit[_depositor] += _value;\r\n        require(userTotalDeposit[_depositor] >= _value, \"Addition overflow\");\r\n\r\n        // give the player interest immediately\r\n        uint interest = computeInterest(_value, _month, _unitInterest);\r\n        IMintableERC20(kryptonite).mint(_depositor, interest);\r\n\r\n        emit NewDeposit(_depositId, _depositor, _value, _month, interest);\r\n    }\r\n\r\n    /**\r\n     * @dev compute interst based on deposit amount and deposit time\r\n     * @param _value - Amount of ring  (in deceimal units)\r\n     * @param _month - Length of time from the deposit's beginning to end (in months).\r\n     * @param _unitInterest - Parameter of basic interest for deposited RING.(default value is 1000, returns _unitInterest/ 10**7 for one year)\r\n     */\r\n    function computeInterest(uint _value, uint _month, uint _unitInterest)\r\n        public canBeStoredWith128Bits(_value) canBeStoredWith48Bits(_month) pure returns (uint) {\r\n        // these two actually mean the multiplier is 1.015\r\n        uint numerator = 67 ** _month;\r\n        uint denominator = 66 ** _month;\r\n        uint quotient;\r\n        uint remainder;\r\n\r\n        assembly {\r\n            quotient := div(numerator, denominator)\r\n            remainder := mod(numerator, denominator)\r\n        }\r\n        // depositing X RING for 12 months, interest is about (1 * _unitInterest * X / 10**7) KTON\r\n        // and the multiplier is about 3\r\n        // ((quotient - 1) * 1000 + remainder * 1000 / denominator) is 197 when _month is 12.\r\n        return (_unitInterest * uint128(_value)) * ((quotient - 1) * 1000 + remainder * 1000 / denominator) / (197 * 10**7);\r\n    }\r\n\r\n    function isClaimRequirePenalty(uint _depositID) public view returns (bool) {\r\n        return (deposits[_depositID].startAt > 0 &&\r\n                !deposits[_depositID].claimed &&\r\n                (now - deposits[_depositID].startAt < deposits[_depositID].months * MONTH ));\r\n    }\r\n\r\n    function computePenalty(uint _depositID) public view returns (uint256) {\r\n        require(isClaimRequirePenalty(_depositID), \"Claim do not need Penalty.\");\r\n\r\n        uint256 monthsDuration = (now - deposits[_depositID].startAt) / MONTH;\r\n\r\n        uint256 penalty = registry.uintOf(BankSettingIds.UINT_BANK_PENALTY_MULTIPLIER) *\r\n            (computeInterest(deposits[_depositID].value, deposits[_depositID].months, deposits[_depositID].unitInterest) - computeInterest(deposits[_depositID].value, monthsDuration, deposits[_depositID].unitInterest));\r\n\r\n\r\n        return penalty;\r\n    }\r\n\r\n    function getDepositIds(address _user) public view returns(uint256[]) {\r\n        return userDeposits[_user];\r\n    }\r\n\r\n    function bytesToUint256(bytes _encodedParam) public pure returns (uint256 a) {\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            a := mload(add(_encodedParam, /*BYTES_HEADER_SIZE*/32))\r\n        }\r\n    }\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        if (_token == 0x0) {\r\n            owner.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n        token.transfer(owner, balance);\r\n\r\n        emit ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    function setRegistry(address _registry) public onlyOwner {\r\n        registry = ISettingsRegistry(_registry);\r\n    }\r\n\r\n    function removeUserDepositsByID(uint _depositID, address _depositor) private{\r\n        // update the deposit ids of the original user and new user.\r\n        bool found = false;\r\n        for(uint i = 0 ; i < userDeposits[_depositor].length; i++)\r\n        {\r\n            if (!found && userDeposits[_depositor][i] == _depositID){\r\n                found = true;\r\n                delete userDeposits[_depositor][i];\r\n            }\r\n\r\n            if (found && i < userDeposits[_depositor].length - 1)\r\n            {\r\n                // shifts value to left\r\n                userDeposits[_depositor][i] =  userDeposits[_depositor][i+1];\r\n            }\r\n        }\r\n\r\n        delete userDeposits[_depositor][userDeposits[_depositor].length-1];\r\n        //reducing the length\r\n        userDeposits[_depositor].length--;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_USER_POINTS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_benificiary\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_months\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WATER_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_GOLD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_RING_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_AUCTION_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_BANK_UNIT_INTEREST\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_LOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_depositID\",\"type\":\"uint256\"}],\"name\":\"computePenalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_benificiary\",\"type\":\"address\"},{\"name\":\"_depositID\",\"type\":\"uint256\"}],\"name\":\"transferDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_month\",\"type\":\"uint256\"},{\"name\":\"_unitInterest\",\"type\":\"uint256\"}],\"name\":\"computeInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_KTON_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WOOD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositID\",\"type\":\"uint256\"}],\"name\":\"claimDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FIRE_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_BANK_PENALTY_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_depositID\",\"type\":\"uint256\"}],\"name\":\"isClaimRequirePenalty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_INTERSTELLAR_ENCODER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_PET_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_SOIL_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_OBJECT_OWNERSHIP\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_USE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"months\",\"type\":\"uint48\"},{\"name\":\"startAt\",\"type\":\"uint48\"},{\"name\":\"value\",\"type\":\"uint128\"},{\"name\":\"unitInterest\",\"type\":\"uint64\"},{\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"initializeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ERC721_BRIDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_REVENUE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDepositIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_encodedParam\",\"type\":\"bytes\"}],\"name\":\"bytesToUint256\",\"outputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_RESOURCE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MONTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_REFERER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_months\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositID\",\"type\":\"uint256\"}],\"name\":\"claimDepositWithPenalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_TOKEN_OFFER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_DIVIDENDS_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositID\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"burnAndRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_depositID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_month\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_interest\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_depositID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isPenalty\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimedDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_depositID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_oldDepositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newDepositor\",\"type\":\"address\"}],\"name\":\"TransferDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_depositID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_months\",\"type\":\"uint48\"},{\"indexed\":false,\"name\":\"_startAt\",\"type\":\"uint48\"},{\"indexed\":false,\"name\":\"_unitInterest\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"BurnAndRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"GringottsBank","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5a2535e74ab3831b5dcf27ca7267f6bfc49ad5208b1300592ef9272d64cdcc0a"}]}