{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ncontract ParsiqDistributor {\r\n  using SafeMath for uint256;\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  uint256 private _status;\r\n\r\n  constructor () public {\r\n      _status = _NOT_ENTERED;\r\n  }\r\n\r\n  function distributeTokensAndEth(\r\n    address token,\r\n    address[] calldata recipients,\r\n    uint256[] calldata shares,\r\n    uint256 tokensToDistribute\r\n  )\r\n    external\r\n    payable\r\n    nonReentrant\r\n  {\r\n    require(recipients.length == shares.length, \"Invalid array length\");\r\n\r\n    IERC20TransferMany(token).transferFrom(\r\n      msg.sender,\r\n      address(this),\r\n      tokensToDistribute\r\n    );\r\n\r\n    uint256[] memory tokens = new uint256[](recipients.length);\r\n    uint256 ethToDistribute = msg.value;\r\n\r\n    uint256 totalShares = 0;\r\n    for (uint256 i = 0; i < shares.length; i++) {\r\n      totalShares = totalShares.add(shares[i]);\r\n    }\r\n    require(totalShares > 0, \"Zero shares\");\r\n\r\n    uint256 sharesDistributed = 0;\r\n    uint256 ethDistributed = 0;\r\n    uint256 tokensDistributed = 0;\r\n\r\n    for (uint256 i = 0; i < shares.length; i++) {\r\n      sharesDistributed = sharesDistributed.add(shares[i]);\r\n      {      \r\n        uint256 tokensDistributedX = sharesDistributed\r\n          .mul(tokensToDistribute)\r\n          .div(totalShares);\r\n\r\n        tokens[i] = shares[i]\r\n          .mul(tokensToDistribute)\r\n          .div(totalShares);\r\n\r\n        tokensDistributed = tokensDistributed.add(tokens[i]);\r\n        uint256 tokenRoundingError = tokensDistributedX.sub(tokensDistributed);\r\n        tokens[i] = tokens[i].add(tokenRoundingError);\r\n        tokensDistributed = tokensDistributed.add(tokenRoundingError);\r\n      }\r\n\r\n      {\r\n        uint256 ethDistributedX = sharesDistributed\r\n          .mul(ethToDistribute)\r\n          .div(totalShares);\r\n        uint256 ethers = shares[i]\r\n          .mul(ethToDistribute)\r\n          .div(totalShares);\r\n        ethDistributed = ethDistributed.add(ethers);\r\n        uint256 ethRoundingError = ethDistributedX.sub(ethDistributed);\r\n        ethers = ethers.add(ethRoundingError);\r\n        ethDistributed = ethDistributed.add(ethRoundingError); \r\n\r\n        if (ethers > 0) {\r\n          payable(recipients[i]).transfer(ethers);\r\n        }\r\n      }\r\n    }\r\n    require(tokensDistributed == tokensToDistribute, \"Tokens distribution failed\");\r\n    require(ethDistributed == ethToDistribute, \"ETH distribution failed\");\r\n\r\n    IERC20TransferMany(token).transferMany(recipients, tokens);\r\n  }\r\n\r\n  modifier nonReentrant() {\r\n      require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n      _status = _ENTERED;\r\n      _;\r\n      _status = _NOT_ENTERED;\r\n  }\r\n}\r\ninterface IERC20TransferMany {\r\n  function transferMany(\r\n    address[] calldata recipients,\r\n    uint256[] calldata amounts\r\n  ) external;\r\n  \r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"tokensToDistribute\",\"type\":\"uint256\"}],\"name\":\"distributeTokensAndEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ParsiqDistributor","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4a6ba364e3303c0ab98878100f4ec554c29f39752caeaf469837de7de63d869b"}]}