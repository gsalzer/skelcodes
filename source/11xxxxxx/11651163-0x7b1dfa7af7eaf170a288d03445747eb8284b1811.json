{"status":"1","message":"OK","result":[{"SourceCode":"{\"MainToken.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2020-09-03\\n*/\\n\\n/*\\n * This file was generated by MyWish Platform (https://mywish.io/)\\n * The complete code could be found at https://github.com/MyWishPlatform/\\n * Copyright (C) 2018 MyWish\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with this program. If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n */\\npragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  function totalSupply() public view returns (uint256);\\n  function balanceOf(address who) public view returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\\n\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n\\n  mapping(address =\\u003e uint256) balances;\\n\\n  uint256 totalSupply_;\\n\\n  /**\\n  * @dev total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return totalSupply_;\\n  }\\n\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    return balances[_owner];\\n  }\\n\\n}\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender)\\n    public view returns (uint256);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    public returns (bool);\\n\\n  function approve(address spender, uint256 value) public returns (bool);\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * @dev https://github.com/ethereum/EIPs/issues/20\\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint256 the amount of tokens to be transferred\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   *\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\n   *\\n   * approve should be called when allowed[_spender] == 0. To increment\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseApproval(\\n    address _spender,\\n    uint _addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    allowed[msg.sender][_spender] = (\\n      allowed[msg.sender][_spender].add(_addedValue));\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n   *\\n   * approve should be called when allowed[_spender] == 0. To decrement\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseApproval(\\n    address _spender,\\n    uint _subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    uint oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n}\\n\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address _newOwner) public onlyOwner {\\n    _transferOwnership(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0));\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n}\\n\\n\\n/**\\n * @title Mintable token\\n * @dev Simple ERC20 Token example, with mintable token creation\\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\\n */\\ncontract MintableToken is StandardToken, Ownable {\\n  event Mint(address indexed to, uint256 amount);\\n  event MintFinished();\\n\\n  bool public mintingFinished = false;\\n\\n\\n  modifier canMint() {\\n    require(!mintingFinished);\\n    _;\\n  }\\n\\n  modifier hasMintPermission() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Function to mint tokens\\n   * @param _to The address that will receive the minted tokens.\\n   * @param _amount The amount of tokens to mint.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function mint(\\n    address _to,\\n    uint256 _amount\\n  )\\n    hasMintPermission\\n    canMint\\n    public\\n    returns (bool)\\n  {\\n    totalSupply_ = totalSupply_.add(_amount);\\n    balances[_to] = balances[_to].add(_amount);\\n    emit Mint(_to, _amount);\\n    emit Transfer(address(0), _to, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to stop minting new tokens.\\n   * @return True if the operation was successful.\\n   */\\n  function finishMinting() onlyOwner canMint public returns (bool) {\\n    mintingFinished = true;\\n    emit MintFinished();\\n    return true;\\n  }\\n}\\n\\n\\ncontract FreezableToken is StandardToken {\\n    // freezing chains\\n    mapping (bytes32 =\\u003e uint64) internal chains;\\n    // freezing amounts for each chain\\n    mapping (bytes32 =\\u003e uint) internal freezings;\\n    // total freezing balance per address\\n    mapping (address =\\u003e uint) internal freezingBalance;\\n\\n    event Freezed(address indexed to, uint64 release, uint amount);\\n    event Released(address indexed owner, uint amount);\\n\\n    /**\\n     * @dev Gets the balance of the specified address include freezing tokens.\\n     * @param _owner The address to query the the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return super.balanceOf(_owner) + freezingBalance[_owner];\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address without freezing tokens.\\n     * @param _owner The address to query the the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\\n        return super.balanceOf(_owner);\\n    }\\n\\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\\n        return freezingBalance[_owner];\\n    }\\n\\n    /**\\n     * @dev gets freezing count\\n     * @param _addr Address of freeze tokens owner.\\n     */\\n    function freezingCount(address _addr) public view returns (uint count) {\\n        uint64 release = chains[toKey(_addr, 0)];\\n        while (release != 0) {\\n            count++;\\n            release = chains[toKey(_addr, release)];\\n        }\\n    }\\n\\n    /**\\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\\n     * @param _addr Address of freeze tokens owner.\\n     * @param _index Freezing portion index. It ordered by release date descending.\\n     */\\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\\n        for (uint i = 0; i \\u003c _index + 1; i++) {\\n            _release = chains[toKey(_addr, _release)];\\n            if (_release == 0) {\\n                return;\\n            }\\n        }\\n        _balance = freezings[toKey(_addr, _release)];\\n    }\\n\\n    /**\\n     * @dev freeze your tokens to the specified address.\\n     *      Be careful, gas usage is not deterministic,\\n     *      and depends on how many freezes _to address already has.\\n     * @param _to Address to which token will be freeze.\\n     * @param _amount Amount of token to freeze.\\n     * @param _until Release date, must be in future.\\n     */\\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\\n        require(_to != address(0));\\n        require(_amount \\u003c= balances[msg.sender]);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\\n\\n        bytes32 currentKey = toKey(_to, _until);\\n        freezings[currentKey] = freezings[currentKey].add(_amount);\\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\\n\\n        freeze(_to, _until);\\n        emit Transfer(msg.sender, _to, _amount);\\n        emit Freezed(_to, _until, _amount);\\n    }\\n\\n    /**\\n     * @dev release first available freezing tokens.\\n     */\\n    function releaseOnce() public {\\n        bytes32 headKey = toKey(msg.sender, 0);\\n        uint64 head = chains[headKey];\\n        require(head != 0);\\n        require(uint64(block.timestamp) \\u003e head);\\n        bytes32 currentKey = toKey(msg.sender, head);\\n\\n        uint64 next = chains[currentKey];\\n\\n        uint amount = freezings[currentKey];\\n        delete freezings[currentKey];\\n\\n        balances[msg.sender] = balances[msg.sender].add(amount);\\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\\n\\n        if (next == 0) {\\n            delete chains[headKey];\\n        } else {\\n            chains[headKey] = next;\\n            delete chains[currentKey];\\n        }\\n        emit Released(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\\n     * @return how many tokens was released\\n     */\\n    function releaseAll() public returns (uint tokens) {\\n        uint release;\\n        uint balance;\\n        (release, balance) = getFreezing(msg.sender, 0);\\n        while (release != 0 \\u0026\\u0026 block.timestamp \\u003e release) {\\n            releaseOnce();\\n            tokens += balance;\\n            (release, balance) = getFreezing(msg.sender, 0);\\n        }\\n    }\\n\\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\\n        // WISH masc to increase entropy\\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\\n        assembly {\\n            result := or(result, mul(_addr, 0x10000000000000000))\\n            result := or(result, _release)\\n        }\\n    }\\n\\n    function freeze(address _to, uint64 _until) internal {\\n        require(_until \\u003e block.timestamp);\\n        bytes32 key = toKey(_to, _until);\\n        bytes32 parentKey = toKey(_to, uint64(0));\\n        uint64 next = chains[parentKey];\\n\\n        if (next == 0) {\\n            chains[parentKey] = _until;\\n            return;\\n        }\\n\\n        bytes32 nextKey = toKey(_to, next);\\n        uint parent;\\n\\n        while (next != 0 \\u0026\\u0026 _until \\u003e next) {\\n            parent = next;\\n            parentKey = nextKey;\\n\\n            next = chains[nextKey];\\n            nextKey = toKey(_to, next);\\n        }\\n\\n        if (_until == next) {\\n            return;\\n        }\\n\\n        if (next != 0) {\\n            chains[key] = next;\\n        }\\n\\n        chains[parentKey] = _until;\\n    }\\n}\\n\\n\\n/**\\n * @title Burnable Token\\n * @dev Token that can be irreversibly burned (destroyed).\\n */\\ncontract BurnableToken is BasicToken {\\n\\n  event Burn(address indexed burner, uint256 value);\\n\\n  /**\\n   * @dev Burns a specific amount of tokens.\\n   * @param _value The amount of token to be burned.\\n   */\\n  function burn(uint256 _value) public {\\n    _burn(msg.sender, _value);\\n  }\\n\\n  function _burn(address _who, uint256 _value) internal {\\n    require(_value \\u003c= balances[_who]);\\n    // no need to require value \\u003c= totalSupply, since that would imply the\\n    // sender\\u0027s balance is greater than the totalSupply, which *should* be an assertion failure\\n\\n    balances[_who] = balances[_who].sub(_value);\\n    totalSupply_ = totalSupply_.sub(_value);\\n    emit Burn(_who, _value);\\n    emit Transfer(_who, address(0), _value);\\n  }\\n}\\n\\n\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyOwner whenNotPaused public {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() onlyOwner whenPaused public {\\n    paused = false;\\n    emit Unpause();\\n  }\\n}\\n\\n\\ncontract FreezableMintableToken is FreezableToken, MintableToken {\\n    /**\\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\\n     *      Be careful, gas usage is not deterministic,\\n     *      and depends on how many freezes _to address already has.\\n     * @param _to Address to which token will be freeze.\\n     * @param _amount Amount of token to mint and freeze.\\n     * @param _until Release date, must be in future.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\\n        totalSupply_ = totalSupply_.add(_amount);\\n\\n        bytes32 currentKey = toKey(_to, _until);\\n        freezings[currentKey] = freezings[currentKey].add(_amount);\\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\\n\\n        freeze(_to, _until);\\n        emit Mint(_to, _amount);\\n        emit Freezed(_to, _until, _amount);\\n        emit Transfer(msg.sender, _to, _amount);\\n        return true;\\n    }\\n}\\n\\n\\n\\ncontract Consts {\\n    uint public constant TOKEN_DECIMALS = 18;\\n    uint8 public constant TOKEN_DECIMALS_UINT8 = 18;\\n    uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\\n\\n    string public constant TOKEN_NAME = \\\"yearn4.finance\\\";\\n    string public constant TOKEN_SYMBOL = \\\"YF4\\\";\\n    bool public constant PAUSED = false;\\n    address public constant TARGET_USER = 0xA5403B1849CD49e7C9df080993EFA829EcF8f624;\\n    \\n    bool public constant CONTINUE_MINTING = true;\\n}\\n\\n\\n\\n\\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\\n    \\n{\\n    \\n    event Initialized();\\n    bool public initialized = false;\\n\\n    constructor() public {\\n        init();\\n        transferOwnership(TARGET_USER);\\n    }\\n    \\n\\n    function name() public pure returns (string _name) {\\n        return TOKEN_NAME;\\n    }\\n\\n    function symbol() public pure returns (string _symbol) {\\n        return TOKEN_SYMBOL;\\n    }\\n\\n    function decimals() public pure returns (uint8 _decimals) {\\n        return TOKEN_DECIMALS_UINT8;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\\n        require(!paused);\\n        return super.transferFrom(_from, _to, _value);\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\\n        require(!paused);\\n        return super.transfer(_to, _value);\\n    }\\n\\n    \\n    function init() private {\\n        require(!initialized);\\n        initialized = true;\\n\\n        if (PAUSED) {\\n            pause();\\n        }\\n\\n        \\n\\n        if (!CONTINUE_MINTING) {\\n            finishMinting();\\n        }\\n\\n        emit Initialized();\\n    }\\n    \\n}\"},\"YF4StakingPool001.sol\":{\"content\":\"// SPDX-License-Identifier: CC-BY-NC-4.0\\npragma solidity \\u003e=0.4.20;\\nimport \\\"./MainToken.sol\\\";\\n\\ncontract  YF4StakingPool001{\\n    \\n    address public owner;\\n    address  a;\\n   \\n    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    \\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address _newOwner) internal {\\n        require(_newOwner != address(0));\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n\\n    using SafeMath for uint256;\\n    using SafeMath for uint8;\\n    \\n    ERC20 public token;\\n    \\n    uint8 decimals;\\n    uint8 ERC20decimals;\\n    \\n    struct User{\\n        bool referred;\\n        address referred_by;\\n        uint256 total_invested_amount;\\n        uint256 referal_profit;\\n    }\\n    \\n    struct Referal_levels{\\n        uint256 level_1;\\n        uint256 level_2;\\n        uint256 level_3;\\n    }\\n\\n    struct Panel_1{\\n        uint256 invested_amount;\\n        uint256 profit;\\n        uint256 profit_withdrawn;\\n        uint256 start_time;\\n        uint256 exp_time;\\n        bool time_started;\\n        uint256 remaining_inv_prof;\\n    }\\n\\n\\n    mapping(address =\\u003e Panel_1) public panel_1;\\n\\n    mapping(address =\\u003e User) public user_info;\\n    mapping(address =\\u003e Referal_levels) public refer_info;\\n    uint public totalcontractamount;\\n\\n    \\n    mapping(address =\\u003e uint256) public overall_profit;\\n\\n    constructor() public {\\n        ERC20decimals = 18; //  Decimal places of ERC20 token\\n        token = ERC20(0x38ACeFAd338b870373fB8c810fE705569E1C7225);\\n    }\\n\\n    function getContractERC20Balance() public view returns (uint256){\\n       return token.balanceOf(address(this));\\n    }\\n\\n\\n\\nfunction invest_panel1(uint256 t_value) public {\\n        // 50,000,000 = 50 trx\\n        require(t_value \\u003e= 50 * (10 ** 18), \\u0027Please Enter Amount no less than 100\\u0027);\\n        require(t_value \\u003c= 1000 * (10 ** 18), \\u0027Please Enter Amount no greater than 1000\\u0027);\\n        \\n        if( panel_1[msg.sender].time_started == false){\\n            panel_1[msg.sender].start_time = now;\\n            panel_1[msg.sender].time_started = true;\\n            panel_1[msg.sender].exp_time = now + 210 days; //210*24*60*60  = 210 days\\n        }\\n            // // Approve to contract for taking tokens in\\n            // token.approve(address(this), t_value); // doesn\\u0027t work external\\n\\n            // transfer the tokens from user to contract\\n            totalcontractamount += t_value ;\\n            token.transferFrom(msg.sender, address(this), t_value);\\n\\n            // assign token amount to bot accout\\n            panel_1[msg.sender].invested_amount += t_value;\\n            user_info[msg.sender].total_invested_amount += t_value; \\n            \\n            referral_system(t_value);\\n            \\n            //neg\\n        if(panel1_days() \\u003c= 210){ //210\\n            panel_1[msg.sender].profit += ((t_value*1*(210 - panel1_days()))/(100)); // 210 - panel_days()\\n        }\\n\\n    }\\n\\n    function is_plan_completed_p1() public view returns(bool){\\n\\n        uint256 local_overall_profit = overall_profit[msg.sender];\\n        uint256 local_current_profit = current_profit_p1();\\n\\n        if(panel_1[msg.sender].exp_time != 0){\\n\\n            if((local_current_profit + local_overall_profit) \\u003e= panel_1[msg.sender].profit){\\n                return true;\\n            }\\n            if(now \\u003e= panel_1[msg.sender].exp_time){\\n                return true;\\n            }\\n            if(now \\u003c panel_1[msg.sender].exp_time){\\n                return false;\\n            }\\n        }else{\\n            return false;\\n        }\\n\\n    }\\n\\n    function plan_completed_p1() public  returns(bool){\\n        uint256 local_overall_profit = overall_profit[msg.sender];\\n        uint256 local_current_profit = current_profit_p1();\\n\\n        if( panel_1[msg.sender].exp_time != 0){\\n\\n            if( (local_current_profit + local_overall_profit) \\u003e= panel_1[msg.sender].profit ){\\n                reset_panel_1();\\n                return true;\\n            }\\n            if(now \\u003e= panel_1[msg.sender].exp_time){\\n                reset_panel_1();\\n                return true;\\n            }\\n            if(now \\u003c panel_1[msg.sender].exp_time){\\n                return false;\\n            }\\n\\n        }\\n\\n    }\\n\\n    function current_profit_p1() public view returns(uint256){\\n        uint256 local_profit ;\\n\\n        if(now \\u003c= panel_1[msg.sender].exp_time){\\n            if((((panel_1[msg.sender].profit + panel_1[msg.sender].profit_withdrawn)*(now-panel_1[msg.sender].start_time))/(210*(1 days))) \\u003e panel_1[msg.sender].profit_withdrawn){  // 210 * 1 days\\n                local_profit = (((panel_1[msg.sender].profit + panel_1[msg.sender].profit_withdrawn)*(now-panel_1[msg.sender].start_time))/(210*(1 days))) - panel_1[msg.sender].profit_withdrawn; // 210*24*60*60\\n                return local_profit;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if(now \\u003e panel_1[msg.sender].exp_time){\\n            return panel_1[msg.sender].profit;\\n        }\\n\\n    }\\n\\n    function panel1_days() public view returns(uint256){\\n        if(panel_1[msg.sender].time_started == true){\\n            return ((now - panel_1[msg.sender].start_time)/(1 days)); // change to 24*60*60   1 days\\n        }\\n        else {\\n            return 0;\\n        }\\n    }\\n    \\n    function withdraw_profit_panel1(uint256 amount) public payable {\\n        uint256 current_profit = current_profit_p1();\\n        require(amount \\u003e= 10 * (10 ** 18), \\u0027 Amount sould be less than profit\\u0027); /////////change min withdrawal to 10YF4\\n        require(amount \\u003c= current_profit, \\u0027 Amount sould be less than profit\\u0027);\\n\\n        panel_1[msg.sender].profit_withdrawn = panel_1[msg.sender].profit_withdrawn + amount;\\n        //neg\\n        panel_1[msg.sender].profit = panel_1[msg.sender].profit - amount;\\n        token.transfer(msg.sender, (amount - ((5*amount)/100)));\\n        token.transfer(a, ((5*amount)/100));\\n    }\\n\\n    function is_valid_time_p1() public view returns(bool){\\n        if(panel_1[msg.sender].time_started == true){\\n        return (now \\u003e l_l1())\\u0026\\u0026(now \\u003c u_l1());    \\n        }\\n        else {\\n            return true;\\n        }\\n    }\\n\\n    function l_l1() public view returns(uint256){\\n        if(panel_1[msg.sender].time_started == true){\\n            return (1 days)*panel1_days() + panel_1[msg.sender].start_time;     // 24*60*60 1 days\\n        }else{\\n            return now;\\n        }\\n    }\\n    \\n    function u_l1() public view returns(uint256){\\n        if(panel_1[msg.sender].time_started == true){\\n            return ((1 days)*panel1_days() + panel_1[msg.sender].start_time + 10 hours);    // 1 days  , 10 hours\\n        }else {\\n            return now + (10 hours);  // 10*60*60  8 hours\\n        }\\n    }\\n\\n    function reset_panel_1() private{\\n        uint256 local_current_profit = current_profit_p1();\\n\\n        panel_1[msg.sender].remaining_inv_prof = local_current_profit ;\\n\\n        panel_1[msg.sender].invested_amount = 0;\\n        panel_1[msg.sender].profit = 0;\\n        panel_1[msg.sender].profit_withdrawn = 0;\\n        panel_1[msg.sender].start_time = 0;\\n        panel_1[msg.sender].exp_time = 0;\\n        panel_1[msg.sender].time_started = false;\\n        overall_profit[msg.sender] = 0;\\n    }  \\n\\n    function withdraw_all_p1() public payable{\\n\\n        token.transfer(msg.sender, panel_1[msg.sender].remaining_inv_prof);\\n        panel_1[msg.sender].remaining_inv_prof = 0;\\n\\n    }\\n\\n\\n    \\n\\n\\n //------------------- Referal System ------------------------\\n\\n    function refer(address ref_add) public {\\n        require(user_info[msg.sender].referred == false, \\u0027 Already referred \\u0027);\\n        require(ref_add != msg.sender, \\u0027 You cannot refer yourself \\u0027);\\n        \\n        user_info[msg.sender].referred_by = ref_add;\\n        user_info[msg.sender].referred = true;        \\n        \\n        address level1 = user_info[msg.sender].referred_by;\\n        address level2 = user_info[level1].referred_by;\\n        address level3 = user_info[level2].referred_by;\\n        \\n        if( (level1 != msg.sender) \\u0026\\u0026 (level1 != address(0)) ){\\n            refer_info[level1].level_1 += 1;\\n        }\\n        if( (level2 != msg.sender) \\u0026\\u0026 (level2 != address(0)) ){\\n            refer_info[level2].level_2 += 1;\\n        }\\n        if( (level3 != msg.sender) \\u0026\\u0026 (level3 != address(0)) ){\\n            refer_info[level3].level_3 += 1;\\n        }\\n        \\n    }\\n\\n    function referral_system(uint256 amount) private {\\n        \\n        address level1 = user_info[msg.sender].referred_by;\\n        address level2 = user_info[level1].referred_by;\\n        address level3 = user_info[level2].referred_by;\\n\\n        if( (level1 != msg.sender) \\u0026\\u0026 (level1 != address(0)) ){\\n            user_info[level1].referal_profit += (amount*10)/(100);\\n            overall_profit[level1] += (amount*10)/(100);\\n        }\\n        if( (level2 != msg.sender) \\u0026\\u0026 (level2 != address(0)) ){\\n            user_info[level2].referal_profit += (amount*5)/(100);\\n            overall_profit[level2] += (amount*5)/(100);\\n        }\\n        if( (level3 != msg.sender) \\u0026\\u0026 (level3 != address(0)) ){\\n            user_info[level3].referal_profit += (amount*1)/(100);\\n            overall_profit[level3] += (amount*1)/(100);\\n        }\\n\\n    }\\n\\n    function referal_withdraw() public {\\n        uint256 t = user_info[msg.sender].referal_profit;\\n        user_info[msg.sender].referal_profit = 0;\\n        \\n        token.transfer(msg.sender, t);\\n    }  \\n\\n}\\n\\n \\n\\n//  YF4 Staking Yield Platform\\n// Daily ROI Reward 1%\\n// (Maximum get profit 210% from the daily reward including refferal bonus, after received 210% member must be reinvest to get more daily reward and refferal bonus)\\n\\n// Minimum stake 100 YF4\\n// Maximum stake 1000 YF4\\n\\n// Minimum Withdrawal 10 YF4 daily, Maximum Withdrawal Same amount of member deposit\\n\\n// Refferal Bonus : \\n// Level 01 - 10%\\n// Level 02 - 5%\\n// Level 03 - 1%\\n// (note: every member withdrwal the leader will be get refferal bonus automaticly)\\n\\n// Fee withdrawal 5% going to owner wallet\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"panel_1\",\"outputs\":[{\"name\":\"invested_amount\",\"type\":\"uint256\"},{\"name\":\"profit\",\"type\":\"uint256\"},{\"name\":\"profit_withdrawn\",\"type\":\"uint256\"},{\"name\":\"start_time\",\"type\":\"uint256\"},{\"name\":\"exp_time\",\"type\":\"uint256\"},{\"name\":\"time_started\",\"type\":\"bool\"},{\"name\":\"remaining_inv_prof\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"l_l1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractERC20Balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref_add\",\"type\":\"address\"}],\"name\":\"refer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_info\",\"outputs\":[{\"name\":\"referred\",\"type\":\"bool\"},{\"name\":\"referred_by\",\"type\":\"address\"},{\"name\":\"total_invested_amount\",\"type\":\"uint256\"},{\"name\":\"referal_profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"is_plan_completed_p1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"plan_completed_p1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"u_l1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_profit_p1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"panel1_days\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw_profit_panel1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"is_valid_time_p1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw_all_p1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"t_value\",\"type\":\"uint256\"}],\"name\":\"invest_panel1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"overall_profit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refer_info\",\"outputs\":[{\"name\":\"level_1\",\"type\":\"uint256\"},{\"name\":\"level_2\",\"type\":\"uint256\"},{\"name\":\"level_3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalcontractamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"referal_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"YF4StakingPool001","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5aa8eedd3ae205679c55a8b81db1dacaa8f2094f48a295292f6a4580f246b849"}]}