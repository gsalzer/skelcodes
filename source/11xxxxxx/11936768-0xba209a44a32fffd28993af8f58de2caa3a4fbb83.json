{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\npragma solidity 0.5.17;\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IDextokenPool {\r\n    event TokenDeposit(\r\n        address indexed token, \r\n        address indexed account, \r\n        uint amount,\r\n        uint spotPrice\r\n    );\r\n\r\n    event TokenWithdraw(\r\n        address indexed token, \r\n        address indexed account, \r\n        uint amount,\r\n        uint spotPrice\r\n    );\r\n\r\n    event SwapExactETHForTokens(\r\n        address indexed poolOut, \r\n        uint amountOut, \r\n        uint amountIn,\r\n        uint spotPrice,\r\n        address indexed account\r\n    );\r\n\r\n    event SwapExactTokensForETH(\r\n        address indexed poolOut, \r\n        uint amountOut, \r\n        uint amountIn, \r\n        uint spotPrice,\r\n        address indexed account\r\n    );\r\n\r\n    /// Speculative AMM\r\n    function initialize(address _token0, address _token1, uint _Ct, uint _Pt) external;\r\n    function updateAMM() external returns (uint, uint);\r\n    function mean() external view returns (uint);\r\n    function getLastUpdateTime() external view returns (uint);\r\n    function getCirculatingSupply() external view returns (uint);\r\n    function getUserbase() external view returns (uint);\r\n    function getPrice() external view returns (uint);\r\n    function getSpotPrice(uint _Ct, uint _Nt) external pure returns (uint);\r\n    function getToken() external view returns (address);\r\n\r\n    /// Pool Management\r\n    function getPoolBalance() external view returns (uint);    \r\n    function getTotalLiquidity() external view returns (uint);\r\n    function liquidityOf(address account) external view returns (uint);\r\n    function liquiditySharesOf(address account) external view returns (uint);\r\n    function liquidityTokenToAmount(uint token) external view returns (uint);\r\n    function liquidityFromAmount(uint amount) external view returns (uint);\r\n    function deposit(uint amount) external;\r\n    function withdraw(uint tokens) external;\r\n\r\n    /// Trading\r\n    function swapExactETHForTokens(\r\n        uint amountIn,\r\n        uint minAmountOut,\r\n        uint maxPrice,\r\n        uint deadline\r\n    ) external returns (uint);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint minAmountOut,\r\n        uint minPrice,\r\n        uint deadline\r\n    ) external returns (uint);\r\n}\r\n\r\ninterface IDextokenExchange {\r\n    event SwapExactAmountOut(\r\n        address indexed poolIn, \r\n        uint amountSwapIn, \r\n        address indexed poolOut, \r\n        uint exactAmountOut,\r\n        address indexed to\r\n    );\r\n\r\n    event SwapExactAmountIn(\r\n        address indexed poolIn, \r\n        uint amountSwapIn, \r\n        address indexed poolOut, \r\n        uint exactAmountOut,\r\n        address indexed to\r\n    );\r\n    \r\n    function swapMaxAmountOut(\r\n        address poolIn,\r\n        address poolOut, \r\n        uint maxAmountOut,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactAmountIn(\r\n        address poolIn,\r\n        address poolOut, \r\n        uint exactAmountIn,\r\n        uint deadline\r\n    ) external;  \r\n}\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\ncontract DextokenExchange is IDextokenExchange, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n\r\n    uint constant MAX = uint(-1);\r\n\r\n    address public owner;\r\n    IERC20 public WETH;\r\n\r\n    constructor(address _token0) public {\r\n        owner = msg.sender;\r\n        WETH = IERC20(_token0);        \r\n    }\r\n\r\n    function swapMaxAmountOut(\r\n        address poolIn,\r\n        address poolOut, \r\n        uint maxAmountOut,\r\n        uint deadline\r\n    ) \r\n        external \r\n        nonReentrant\r\n    {\r\n        require(poolIn != address(0), \"exchange: Invalid token address\");\r\n        require(poolOut != address(0), \"exchange: Invalid token address\");\r\n        require(maxAmountOut > 0, \"exchange: Invalid maxAmountOut\");\r\n\r\n        IERC20 poolInToken = IERC20(IDextokenPool(poolIn).getToken());\r\n        IERC20 poolOutToken = IERC20(IDextokenPool(poolOut).getToken());\r\n        IERC20 _WETH = WETH;\r\n\r\n        /// calculate the pair price\r\n        uint closingPrice;\r\n        {\r\n            uint priceIn = IDextokenPool(poolIn).getPrice();\r\n            uint priceOut = IDextokenPool(poolOut).getPrice();\r\n            closingPrice = priceOut.mul(1e18).div(priceIn);\r\n        }\r\n\r\n        /// evalucate the swap in amount\r\n        uint amountSwapIn = maxAmountOut.mul(closingPrice).div(1e18);\r\n        require(amountSwapIn >= 1e2, \"exchange: invalid amountSwapIn\");    \r\n\r\n        /// transfer tokens in\r\n        poolInToken.safeTransferFrom(msg.sender, address(this), amountSwapIn);\r\n        require(poolInToken.balanceOf(address(this)) >= amountSwapIn, \"exchange: Invalid token balance\");\r\n\r\n        if (poolInToken.allowance(address(this), poolIn) < amountSwapIn) {       \r\n            poolInToken.approve(poolIn, MAX);\r\n        }\r\n\r\n        IDextokenPool(poolIn).swapExactTokensForETH(\r\n            amountSwapIn,\r\n            0,\r\n            0,\r\n            deadline\r\n        );\r\n\r\n        uint balanceETH = _WETH.balanceOf(address(this));\r\n        uint spotPriceOut = IDextokenPool(poolOut).getSpotPrice(\r\n            IDextokenPool(poolOut).getCirculatingSupply(),\r\n            IDextokenPool(poolOut).getUserbase().add(balanceETH)\r\n        );\r\n        uint minAmountOut = balanceETH.mul(1e18).div(spotPriceOut);\r\n\r\n        /// swap ETH for tokens\r\n        if (_WETH.allowance(address(this), poolOut) < balanceETH) {         \r\n            _WETH.approve(poolOut, MAX);\r\n        }\r\n\r\n        IDextokenPool(poolOut).swapExactETHForTokens(\r\n            balanceETH,\r\n            minAmountOut,\r\n            spotPriceOut,\r\n            deadline\r\n        );\r\n\r\n        /// transfer all tokens\r\n        uint exactAmountOut = poolOutToken.balanceOf(address(this));\r\n        require(exactAmountOut <= maxAmountOut, \"exchange: Exceed maxAmountOut\");\r\n        poolOutToken.safeTransfer(msg.sender, exactAmountOut);\r\n\r\n        emit SwapExactAmountOut(poolIn, amountSwapIn, poolOut, exactAmountOut, msg.sender);\r\n    }\r\n\r\n    function swapExactAmountIn(\r\n        address poolIn,\r\n        address poolOut, \r\n        uint exactAmountIn,\r\n        uint deadline\r\n    ) \r\n        external \r\n        nonReentrant\r\n    {\r\n        require(poolIn != address(0), \"exchange: Invalid token address\");\r\n        require(poolOut != address(0), \"exchange: Invalid token address\");\r\n        require(exactAmountIn > 0, \"exchange: Invalid exactAmountIn\");\r\n\r\n        IERC20 poolInToken = IERC20(IDextokenPool(poolIn).getToken());\r\n        IERC20 poolOutToken = IERC20(IDextokenPool(poolOut).getToken());\r\n        IERC20 _WETH = WETH;\r\n\r\n        /// transfer tokens in\r\n        poolInToken.safeTransferFrom(msg.sender, address(this), exactAmountIn);\r\n        require(poolInToken.balanceOf(address(this)) >= exactAmountIn, \"exchange: Invalid token balance\");\r\n\r\n        if (poolInToken.allowance(address(this), poolIn) < exactAmountIn) {\r\n            poolInToken.approve(address(poolIn), MAX);\r\n        }\r\n\r\n        uint balanceETH = IDextokenPool(poolIn).swapExactTokensForETH(\r\n            exactAmountIn,\r\n            0,\r\n            0,\r\n            deadline\r\n        );\r\n\r\n        if (_WETH.allowance(address(this), poolOut) < balanceETH) {       \r\n            _WETH.approve(address(poolOut), MAX);\r\n        }\r\n\r\n        uint exactAmountOut = IDextokenPool(poolOut).swapExactETHForTokens(\r\n            balanceETH,\r\n            0,\r\n            MAX,\r\n            deadline\r\n        );\r\n\r\n        /// transfer all tokens\r\n        poolOutToken.safeTransfer(msg.sender, exactAmountOut);\r\n\r\n        emit SwapExactAmountIn(poolIn, exactAmountIn, poolOut, exactAmountOut, msg.sender);\r\n    }            \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSwapIn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exactAmountOut\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SwapExactAmountIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSwapIn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exactAmountOut\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SwapExactAmountOut\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exactAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapMaxAmountOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DextokenExchange","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6f46f315d6a745038271685a608fbd47024ed4adcde5457405b724a487cbfedb"}]}