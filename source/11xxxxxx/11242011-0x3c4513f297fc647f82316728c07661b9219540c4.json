{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/bancor/BancorFormula.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract BancorFormula {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    string public version = '0.3';\r\n\r\n    uint256 private constant ONE = 1;\r\n    uint32 private constant MAX_WEIGHT = 1000000;\r\n    uint8 private constant MIN_PRECISION = 32;\r\n    uint8 private constant MAX_PRECISION = 127;\r\n\r\n    /**\r\n        Auto-generated via 'PrintIntScalingFactors.py'\r\n    */\r\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\r\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\r\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\r\n\r\n    /**\r\n        Auto-generated via 'PrintLn2ScalingFactors.py'\r\n    */\r\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\r\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\r\n\r\n    /**\r\n        Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\r\n    */\r\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\r\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\r\n\r\n    /**\r\n        Auto-generated via 'PrintFunctionConstructor.py'\r\n    */\r\n    uint256[128] private maxExpArray;\r\n    constructor() public {\r\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\r\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\r\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\r\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\r\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\r\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\r\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\r\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\r\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\r\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\r\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\r\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\r\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\r\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\r\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\r\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\r\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\r\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\r\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\r\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\r\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\r\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\r\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\r\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\r\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\r\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\r\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\r\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\r\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\r\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\r\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\r\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\r\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\r\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\r\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\r\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\r\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\r\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\r\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\r\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\r\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\r\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\r\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\r\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\r\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\r\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\r\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\r\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\r\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\r\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\r\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\r\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\r\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\r\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\r\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\r\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\r\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\r\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\r\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\r\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\r\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\r\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\r\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\r\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\r\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\r\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\r\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\r\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\r\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\r\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\r\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\r\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\r\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\r\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\r\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\r\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\r\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\r\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\r\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\r\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\r\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\r\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\r\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\r\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\r\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\r\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\r\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\r\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\r\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\r\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\r\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\r\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\r\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\r\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\r\n        calculates the return for a given conversion (in the main token)\r\n        Formula:\r\n        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\r\n        @param _supply              token total supply\r\n        @param _connectorBalance    total connector balance\r\n        @param _connectorWeight     connector weight, represented in ppm, 1-1000000\r\n        @param _depositAmount       deposit amount, in connector token\r\n        @return purchase return amount\r\n    */\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\r\n\r\n        // special case for 0 deposit amount\r\n        if (_depositAmount == 0)\r\n            return 0;\r\n\r\n        // special case if the weight = 100%\r\n        if (_connectorWeight == MAX_WEIGHT)\r\n            return _supply.mul(_depositAmount) / _connectorBalance;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = _depositAmount.add(_connectorBalance);\r\n        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\r\n        uint256 temp = _supply.mul(result) >> precision;\r\n        return temp - _supply;\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, connector balance, weight and a sell amount (in the main token),\r\n        calculates the return for a given conversion (in the connector token)\r\n        Formula:\r\n        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\r\n        @param _supply              token total supply\r\n        @param _connectorBalance    total connector\r\n        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\r\n        @param _sellAmount          sell amount, in the token itself\r\n        @return sale return amount\r\n    */\r\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\r\n\r\n        // special case for 0 sell amount\r\n        if (_sellAmount == 0)\r\n            return 0;\r\n\r\n        // special case for selling the entire supply\r\n        if (_sellAmount == _supply)\r\n            return _connectorBalance;\r\n\r\n        // special case if the weight = 100%\r\n        if (_connectorWeight == MAX_WEIGHT)\r\n            return _connectorBalance.mul(_sellAmount) / _supply;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseD = _supply - _sellAmount;\r\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\r\n        uint256 temp1 = _connectorBalance.mul(result);\r\n        uint256 temp2 = _connectorBalance << precision;\r\n        return (temp1 - temp2) / result;\r\n    }\r\n\r\n    /**\r\n        @dev given two connector balances/weights and a sell amount (in the first connector token),\r\n        calculates the return for a conversion from the first connector token to the second connector token (in the second connector token)\r\n        Formula:\r\n        Return = _toConnectorBalance * (1 - (_fromConnectorBalance / (_fromConnectorBalance + _amount)) ^ (_fromConnectorWeight / _toConnectorWeight))\r\n        @param _fromConnectorBalance    input connector balance\r\n        @param _fromConnectorWeight     input connector weight, represented in ppm, 1-1000000\r\n        @param _toConnectorBalance      output connector balance\r\n        @param _toConnectorWeight       output connector weight, represented in ppm, 1-1000000\r\n        @param _amount                  input connector amount\r\n        @return second connector amount\r\n    */\r\n    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256) {\r\n        // validate input\r\n        require(_fromConnectorBalance > 0 && _fromConnectorWeight > 0 && _fromConnectorWeight <= MAX_WEIGHT && _toConnectorBalance > 0 && _toConnectorWeight > 0 && _toConnectorWeight <= MAX_WEIGHT);\r\n\r\n        // special case for equal weights\r\n        if (_fromConnectorWeight == _toConnectorWeight)\r\n            return _toConnectorBalance.mul(_amount) / _fromConnectorBalance.add(_amount);\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = _fromConnectorBalance.add(_amount);\r\n        (result, precision) = power(baseN, _fromConnectorBalance, _fromConnectorWeight, _toConnectorWeight);\r\n        uint256 temp1 = _toConnectorBalance.mul(result);\r\n        uint256 temp2 = _toConnectorBalance << precision;\r\n        return (temp1 - temp2) / result;\r\n    }\r\n\r\n    /**\r\n        @dev General Description:\r\n            Determine a value of precision.\r\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\r\n            Return the result along with the precision used.\r\n        Detailed Description:\r\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\r\n            The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\r\n            The larger \"precision\" is, the more accurately this value represents the real value.\r\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\r\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\r\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\r\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\r\n            This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\r\n    */\r\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal view returns (uint256, uint8) {\r\n        require(_baseN < MAX_NUM);\r\n\r\n        uint256 baseLog;\r\n        uint256 base = _baseN * FIXED_1 / _baseD;\r\n        if (base < OPT_LOG_MAX_VAL) {\r\n            baseLog = optimalLog(base);\r\n        }\r\n        else {\r\n            baseLog = generalLog(base);\r\n        }\r\n\r\n        uint256 baseLogTimesExp = baseLog * _expN / _expD;\r\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\r\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\r\n        }\r\n        else {\r\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\r\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev computes log(x / FIXED_1) * FIXED_1.\r\n        This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\r\n    */\r\n    function generalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\r\n        if (x >= FIXED_2) {\r\n            uint8 count = floorLog2(x / FIXED_1);\r\n            x >>= count;\r\n            // now x < 2\r\n            res = count * FIXED_1;\r\n        }\r\n\r\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\r\n        if (x > FIXED_1) {\r\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\r\n                x = (x * x) / FIXED_1;\r\n                // now 1 < x < 4\r\n                if (x >= FIXED_2) {\r\n                    x >>= 1;\r\n                    // now 1 < x < 2\r\n                    res += ONE << (i - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\r\n    }\r\n\r\n    /**\r\n        @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\r\n    */\r\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\r\n        uint8 res = 0;\r\n\r\n        if (_n < 256) {\r\n            // At most 8 iterations\r\n            while (_n > 1) {\r\n                _n >>= 1;\r\n                res += 1;\r\n            }\r\n        }\r\n        else {\r\n            // Exactly 8 iterations\r\n            for (uint8 s = 128; s > 0; s >>= 1) {\r\n                if (_n >= (ONE << s)) {\r\n                    _n >>= s;\r\n                    res |= s;\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\r\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\r\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\r\n    */\r\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\r\n        uint8 lo = MIN_PRECISION;\r\n        uint8 hi = MAX_PRECISION;\r\n\r\n        while (lo + 1 < hi) {\r\n            uint8 mid = (lo + hi) / 2;\r\n            if (maxExpArray[mid] >= _x)\r\n                lo = mid;\r\n            else\r\n                hi = mid;\r\n        }\r\n\r\n        if (maxExpArray[hi] >= _x)\r\n            return hi;\r\n        if (maxExpArray[lo] >= _x)\r\n            return lo;\r\n\r\n        require(false);\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n        @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\r\n        it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\r\n        it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\r\n        the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\r\n        the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n    */\r\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\r\n        uint256 xi = _x;\r\n        uint256 res = 0;\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000;\r\n        // add x^02 * (33! / 02!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x116b96f757c380fb287fd0e40000000;\r\n        // add x^03 * (33! / 03!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000;\r\n        // add x^04 * (33! / 04!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00defabf91302cd95b9ffda50000000;\r\n        // add x^05 * (33! / 05!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x002529ca9832b22439efff9b8000000;\r\n        // add x^06 * (33! / 06!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00054f1cf12bd04e516b6da88000000;\r\n        // add x^07 * (33! / 07!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000;\r\n        // add x^08 * (33! / 08!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000012e066e7b839fa050c309000000;\r\n        // add x^09 * (33! / 09!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000001e33d7d926c329a1ad1a800000;\r\n        // add x^10 * (33! / 10!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000;\r\n        // add x^11 * (33! / 11!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000003a9316fa79b88eccf2a00000;\r\n        // add x^12 * (33! / 12!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000048177ebe1fa812375200000;\r\n        // add x^13 * (33! / 13!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000005263fe90242dcbacf00000;\r\n        // add x^14 * (33! / 14!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000057e22099c030d94100000;\r\n        // add x^15 * (33! / 15!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000057e22099c030d9410000;\r\n        // add x^16 * (33! / 16!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000052b6b54569976310000;\r\n        // add x^17 * (33! / 17!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000004985f67696bf748000;\r\n        // add x^18 * (33! / 18!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000003dea12ea99e498000;\r\n        // add x^19 * (33! / 19!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000031880f2214b6e000;\r\n        // add x^20 * (33! / 20!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000025bcff56eb36000;\r\n        // add x^21 * (33! / 21!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000001b722e10ab1000;\r\n        // add x^22 * (33! / 22!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000001317c70077000;\r\n        // add x^23 * (33! / 23!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000cba84aafa00;\r\n        // add x^24 * (33! / 24!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000082573a0a00;\r\n        // add x^25 * (33! / 25!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000005035ad900;\r\n        // add x^26 * (33! / 26!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000002f881b00;\r\n        // add x^27 * (33! / 27!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000001b29340;\r\n        // add x^28 * (33! / 28!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000efc40;\r\n        // add x^29 * (33! / 29!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000007fe0;\r\n        // add x^30 * (33! / 30!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000420;\r\n        // add x^31 * (33! / 31!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000021;\r\n        // add x^32 * (33! / 32!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000001;\r\n        // add x^33 * (33! / 33!)\r\n\r\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision);\r\n        // divide by 33! and then add x^1 / 1! + x^0 / 0!\r\n    }\r\n\r\n    /**\r\n        @dev computes log(x / FIXED_1) * FIXED_1\r\n        Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\r\n        Auto-generated via 'PrintFunctionOptimalLog.py'\r\n        Detailed description:\r\n        - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\r\n        - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\r\n        - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\r\n        - The natural logarithm of the input is calculated by summing up the intermediate results above\r\n        - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\r\n    */\r\n    function optimalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n        uint256 w;\r\n\r\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;}\r\n        // add 1 / 2^1\r\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;}\r\n        // add 1 / 2^2\r\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;}\r\n        // add 1 / 2^3\r\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;}\r\n        // add 1 / 2^4\r\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;}\r\n        // add 1 / 2^5\r\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;}\r\n        // add 1 / 2^6\r\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;}\r\n        // add 1 / 2^7\r\n        if (x >= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;}\r\n        // add 1 / 2^8\r\n\r\n        z = y = x - FIXED_1;\r\n        w = y * y / FIXED_1;\r\n        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^01 / 01 - y^02 / 02\r\n        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^03 / 03 - y^04 / 04\r\n        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^05 / 05 - y^06 / 06\r\n        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^07 / 07 - y^08 / 08\r\n        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^09 / 09 - y^10 / 10\r\n        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^11 / 11 - y^12 / 12\r\n        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n        // add y^13 / 13 - y^14 / 14\r\n        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;\r\n        // add y^15 / 15 - y^16 / 16\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        @dev computes e ^ (x / FIXED_1) * FIXED_1\r\n        input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\r\n        auto-generated via 'PrintFunctionOptimalExp.py'\r\n        Detailed description:\r\n        - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\r\n        - The exponentiation of each binary exponent is given (pre-calculated)\r\n        - The exponentiation of r is calculated via Taylor series for e^x, where x = r\r\n        - The exponentiation of the input is calculated by multiplying the intermediate results above\r\n        - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\r\n    */\r\n    function optimalExp(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n\r\n        z = y = x % 0x10000000000000000000000000000000;\r\n        // get the input modulo 2^(-3)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x10e1b3be415a0000;\r\n        // add y^02 * (20! / 02!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x05a0913f6b1e0000;\r\n        // add y^03 * (20! / 03!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0168244fdac78000;\r\n        // add y^04 * (20! / 04!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x004807432bc18000;\r\n        // add y^05 * (20! / 05!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000c0135dca04000;\r\n        // add y^06 * (20! / 06!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0001b707b1cdc000;\r\n        // add y^07 * (20! / 07!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000036e0f639b800;\r\n        // add y^08 * (20! / 08!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x00000618fee9f800;\r\n        // add y^09 * (20! / 09!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000009c197dcc00;\r\n        // add y^10 * (20! / 10!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000e30dce400;\r\n        // add y^11 * (20! / 11!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000000012ebd1300;\r\n        // add y^12 * (20! / 12!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000017499f00;\r\n        // add y^13 * (20! / 13!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000001a9d480;\r\n        // add y^14 * (20! / 14!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x00000000001c6380;\r\n        // add y^15 * (20! / 15!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000000000001c638;\r\n        // add y^16 * (20! / 16!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000000001ab8;\r\n        // add y^17 * (20! / 17!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000000000000017c;\r\n        // add y^18 * (20! / 18!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000000000014;\r\n        // add y^19 * (20! / 19!)\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000000000001;\r\n        // add y^20 * (20! / 20!)\r\n        res = res / 0x21c3677c82b40000 + y + FIXED_1;\r\n        // divide by 20! and then add y^1 / 1! + y^0 / 0!\r\n\r\n        if ((x & 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776;\r\n        // multiply by e^2^(-3)\r\n        if ((x & 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4;\r\n        // multiply by e^2^(-2)\r\n        if ((x & 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\r\n        // multiply by e^2^(-1)\r\n        if ((x & 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\r\n        // multiply by e^2^(+0)\r\n        if ((x & 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea;\r\n        // multiply by e^2^(+1)\r\n        if ((x & 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d;\r\n        // multiply by e^2^(+2)\r\n        if ((x & 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11;\r\n        // multiply by e^2^(+3)\r\n\r\n        return res;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_connectorBalance\",\"type\":\"uint256\"},{\"name\":\"_connectorWeight\",\"type\":\"uint32\"},{\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePurchaseReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_connectorBalance\",\"type\":\"uint256\"},{\"name\":\"_connectorWeight\",\"type\":\"uint32\"},{\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"calculateSaleReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromConnectorBalance\",\"type\":\"uint256\"},{\"name\":\"_fromConnectorWeight\",\"type\":\"uint32\"},{\"name\":\"_toConnectorBalance\",\"type\":\"uint256\"},{\"name\":\"_toConnectorWeight\",\"type\":\"uint32\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateCrossConnectorReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BancorFormula","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6a0aeaf7d5ea632c830a19f3aae8b46ac25759818f2cc269f40de55016479a9a"}]}