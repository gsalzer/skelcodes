{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n\r\ninterface LiquidityPool {\r\n    function borrow(\r\n        address _token,\r\n        uint256 _amount,\r\n        bytes calldata _data\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IDistributor {\r\n    function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external;\r\n}\r\n\r\ncontract TestBorrower {\r\n    address payable immutable owner;\r\n\r\n    address constant borrowProxy = 0x82151CA501c81108d032C490E25f804787BEF3b8;\r\n\r\n    address payable constant liquidityPool = 0x53463cd0b074E5FDafc55DcE7B1C82ADF1a43B2E;\r\n    \r\n    IDistributor constant distributor = IDistributor(0xF55A73a366F1F9F03CEf4cc10D3cD21e5c6A9026);\r\n    \r\n    address constant rook = 0xfA5047c9c78B8877af97BDcb85Db743fD7313d4a;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"NOT OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyBorrowProxy {\r\n        require(msg.sender == borrowProxy, \"NOT BORROW PROXY\");\r\n        _;\r\n    }\r\n    \r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function doBorrow(address[] memory tokens) external payable onlyOwner {\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            LiquidityPool(liquidityPool).borrow(\r\n                token,\r\n                1,\r\n                abi.encodeWithSelector(\r\n                    this.borrowCallback.selector,\r\n                    token\r\n                )\r\n            );\r\n        }\r\n    }\r\n    \r\n    function borrowCallback(address token) external onlyBorrowProxy {\r\n        if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n            (bool success, bytes memory retData) = liquidityPool.call{ value: address(this).balance }(\"\");\r\n            require(success, string(retData));\r\n        } else {\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\r\n            require(IERC20(token).transfer(liquidityPool, balance), \"ERC20 error\");\r\n        }\r\n    }\r\n    \r\n    function claim(address _to, uint256 _earningsToDate, uint256 _nonce, bytes memory _signature) external {\r\n        distributor.claim(_to, _earningsToDate, _nonce, _signature);\r\n        withdrawTokens(rook);\r\n    }\r\n    \r\n    function withdrawTokens(address token) public {\r\n        if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n            owner.transfer(address(this).balance);\r\n        } else {\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\r\n            require(IERC20(token).transfer(owner, balance), \"ERC20 error\");\r\n        }\r\n    }\r\n    \r\n    function delegateCall(address to, bytes memory data) external payable onlyOwner {\r\n        (bool success, bytes memory retData) = to.delegatecall(data);\r\n        require(success, string(retData));\r\n    }\r\n    \r\n    fallback() external payable { return; }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"borrowCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_earningsToDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"doBorrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TestBorrower","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4d939cd26404614cf87534f087d5b34b878aeeb6939072681a163adab48adaaa"}]}