{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Owned contract interface\n*/\ninterface IOwned {\n    // this function isn't since the compiler emits automatically generated getter functions as external\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n    function acceptOwnership() external;\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\n\npragma solidity 0.6.12;\n\n\n/*\n    Converter Anchor interface\n*/\ninterface IConverterAnchor is IOwned {\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    ERC20 Standard Token interface\n*/\ninterface IERC20Token {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n}\n\n// File: solidity/contracts/token/interfaces/IDSToken.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n/*\n    DSToken interface\n*/\ninterface IDSToken is IConverterAnchor, IERC20Token {\n    function issue(address _to, uint256 _amount) external;\n    function destroy(address _from, uint256 _amount) external;\n}\n\n// File: solidity/contracts/liquidity-protection/interfaces/ILiquidityProtectionStore.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n\n/*\n    Liquidity Protection Store interface\n*/\ninterface ILiquidityProtectionStore is IOwned {\n    function addPoolToWhitelist(IConverterAnchor _anchor) external;\n    function removePoolFromWhitelist(IConverterAnchor _anchor) external;\n    function isPoolWhitelisted(IConverterAnchor _anchor) external view returns (bool);\n\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\n\n    function protectedLiquidity(uint256 _id)\n        external\n        view\n        returns (address, IDSToken, IERC20Token, uint256, uint256, uint256, uint256, uint256);\n\n    function addProtectedLiquidity(\n        address _provider,\n        IDSToken _poolToken,\n        IERC20Token _reserveToken,\n        uint256 _poolAmount,\n        uint256 _reserveAmount,\n        uint256 _reserveRateN,\n        uint256 _reserveRateD,\n        uint256 _timestamp\n    ) external returns (uint256);\n\n    function updateProtectedLiquidityAmounts(uint256 _id, uint256 _poolNewAmount, uint256 _reserveNewAmount) external;\n    function removeProtectedLiquidity(uint256 _id) external;\n    \n    function lockedBalance(address _provider, uint256 _index) external view returns (uint256, uint256);\n    function lockedBalanceRange(address _provider, uint256 _startIndex, uint256 _endIndex) external view returns (uint256[] memory, uint256[] memory);\n\n    function addLockedBalance(address _provider, uint256 _reserveAmount, uint256 _expirationTime) external returns (uint256);\n    function removeLockedBalance(address _provider, uint256 _index) external;\n\n    function systemBalance(IERC20Token _poolToken) external view returns (uint256);\n    function incSystemBalance(IERC20Token _poolToken, uint256 _poolAmount) external;\n    function decSystemBalance(IERC20Token _poolToken, uint256 _poolAmount ) external;\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\n\r\npragma solidity 0.6.12;\r\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public override owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public override ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() override public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\n\npragma solidity 0.6.12;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _spender approved address\n      * @param _value   allowance amount\n    */\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\n    }\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\n\n// File: solidity/contracts/liquidity-protection/LiquidityProtectionStore.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n\n\n/**\n  * @dev The Liquidity Protection Store contract serves as the storage of the liquidity protection\n  * mechanism. It holds the data and tokens and is non upgradable.\n  *\n*/\ncontract LiquidityProtectionStore is ILiquidityProtectionStore, Owned, TokenHandler, Utils {\n    using SafeMath for uint256;\n\n    struct PoolIndex {\n        bool isValid;\n        uint256 value;\n    }\n\n    struct ProtectedLiquidity {\n        address provider;           // liquidity provider\n        uint256 index;              // index in the provider liquidity ids array\n        IDSToken poolToken;         // pool token address\n        IERC20Token reserveToken;   // reserve token address\n        uint256 poolAmount;         // pool token amount\n        uint256 reserveAmount;      // reserve token amount\n        uint256 reserveRateN;       // rate of 1 protected reserve token in units of the other reserve token (numerator)\n        uint256 reserveRateD;       // rate of 1 protected reserve token in units of the other reserve token (denominator)\n        uint256 timestamp;          // timestamp\n    }\n\n    struct LockedBalance {\n        uint256 amount;         // amount of network tokens\n        uint256 expirationTime; // lock expiration time\n    }\n\n    // list of whitelisted pools and mapping of pool anchor address -> index in the pool whitelist for quick access\n    IConverterAnchor[] private poolWhitelist;\n    mapping(IConverterAnchor => PoolIndex) private poolWhitelistIndices;\n\n    // protected liquidity by provider\n    uint256 private nextProtectedLiquidityId;\n    mapping (address => uint256[]) private protectedLiquidityIdsByProvider;\n    mapping (uint256 => ProtectedLiquidity) private protectedLiquidities;\n\n    // user locked network token balances\n    mapping (address => LockedBalance[]) private lockedBalances;\n\n    // system balances\n    mapping (IERC20Token => uint256) private systemBalances;\n\n    // total protected pool supplies / reserve amounts\n    mapping (IDSToken =>    uint256) private totalProtectedPoolAmounts;\n    mapping (IDSToken =>    mapping (IERC20Token => uint256)) private totalProtectedReserveAmounts;\n\n    /**\n      * @dev triggered when the pool whitelist is updated\n      *\n      * @param _poolAnchor  pool anchor\n      * @param _added       true if the pool was added to the whitelist, false if it was removed\n    */\n    event PoolWhitelistUpdated(\n        IConverterAnchor indexed _poolAnchor,\n        bool _added\n    );\n\n    /**\n      * @dev triggered when liquidity protection is added\n      *\n      * @param _provider        liquidity provider\n      * @param _poolToken       pool token address\n      * @param _reserveToken    reserve token address\n      * @param _poolAmount      amount of pool tokens\n      * @param _reserveAmount   amount of reserve tokens\n    */\n    event ProtectionAdded(\n        address indexed _provider,\n        IDSToken indexed    _poolToken,\n        IERC20Token indexed _reserveToken,\n        uint256 _poolAmount,\n        uint256 _reserveAmount\n    );\n\n    /**\n      * @dev triggered when liquidity protection is updated\n      *\n      * @param _provider            liquidity provider\n      * @param _prevPoolAmount      previous amount of pool tokens\n      * @param _prevReserveAmount   previous amount of reserve tokens\n      * @param _newPoolAmount       new amount of pool tokens\n      * @param _newReserveAmount    new amount of reserve tokens\n    */\n    event ProtectionUpdated(\n        address indexed _provider,\n        uint256 _prevPoolAmount,\n        uint256 _prevReserveAmount,\n        uint256 _newPoolAmount,\n        uint256 _newReserveAmount\n    );\n\n    /**\n      * @dev triggered when liquidity protection is removed\n      *\n      * @param _provider        liquidity provider\n      * @param _poolToken       pool token address\n      * @param _reserveToken    reserve token address\n      * @param _poolAmount      amount of pool tokens\n      * @param _reserveAmount   amount of reserve tokens\n    */\n    event ProtectionRemoved(\n        address indexed _provider,\n        IDSToken indexed    _poolToken,\n        IERC20Token indexed _reserveToken,\n        uint256 _poolAmount,\n        uint256 _reserveAmount\n    );\n\n    /**\n      * @dev triggered when network tokens are locked\n      *\n      * @param _provider        provider of the network tokens\n      * @param _amount          amount of network tokens\n      * @param _expirationTime  lock expiration time\n    */\n    event BalanceLocked(\n        address indexed _provider,\n        uint256 _amount,\n        uint256 _expirationTime\n    );\n\n    /**\n      * @dev triggered when network tokens are unlocked\n      *\n      * @param _provider    provider of the network tokens\n      * @param _amount      amount of network tokens\n    */\n    event BalanceUnlocked(\n        address indexed _provider,\n        uint256 _amount\n    );\n\n    /**\n      * @dev triggered when the system balance for a given token is updated\n      *\n      * @param _token       token address\n      * @param _prevAmount  previous amount\n      * @param _newAmount   new amount\n    */\n    event SystemBalanceUpdated(\n        IERC20Token _token,\n        uint256 _prevAmount,\n        uint256 _newAmount\n    );\n\n    /**\n      * @dev adds a pool to the whitelist\n      * can only be called by the contract owner\n      *\n      * @param _poolAnchor pool anchor\n    */\n    function addPoolToWhitelist(IConverterAnchor _poolAnchor)\n        external\n        override\n        ownerOnly\n        validAddress(address(_poolAnchor))\n        notThis(address(_poolAnchor))\n    {\n        // validate input\n        PoolIndex storage poolIndex = poolWhitelistIndices[_poolAnchor];\n        require(!poolIndex.isValid, \"ERR_POOL_ALREADY_WHITELISTED\");\n\n        poolIndex.value = poolWhitelist.length;\n        poolWhitelist.push(_poolAnchor);\n        poolIndex.isValid = true;\n\n        emit PoolWhitelistUpdated(_poolAnchor, true);\n    }\n\n    /**\n      * @dev removes a pool from the whitelist\n      * can only be called by the contract owner\n      *\n      * @param _poolAnchor pool anchor\n    */\n    function removePoolFromWhitelist(IConverterAnchor _poolAnchor)\n        external\n        override\n        ownerOnly\n        validAddress(address(_poolAnchor))\n        notThis(address(_poolAnchor))\n    {\n        // validate input\n        PoolIndex storage poolIndex = poolWhitelistIndices[_poolAnchor];\n        require(poolIndex.isValid, \"ERR_POOL_NOT_WHITELISTED\");\n\n        uint256 index = poolIndex.value;\n        uint256 length = poolWhitelist.length;\n        assert(length > 0);\n\n        uint256 lastIndex = length - 1;\n        if (index < lastIndex) {\n            IConverterAnchor lastAnchor = poolWhitelist[lastIndex];\n            poolWhitelistIndices[lastAnchor].value = index;\n            poolWhitelist[index] = lastAnchor;\n        }\n\n        poolWhitelist.pop();\n        delete poolWhitelistIndices[_poolAnchor];\n\n        emit PoolWhitelistUpdated(_poolAnchor, false);\n    }\n\n    /**\n      * @dev returns the number of whitelisted pools\n      *\n      * @return number of whitelisted pools\n    */\n    function whitelistedPoolCount() external view returns (uint256) {\n        return poolWhitelist.length;\n    }\n\n    /**\n      * @dev returns the list of whitelisted pools\n      *\n      * @return list of whitelisted pools\n    */\n    function whitelistedPools() external view returns (IConverterAnchor[] memory) {\n        return poolWhitelist;\n    }\n\n    /**\n      * @dev returns the whitelisted pool at a given index\n      *\n      * @param _index index\n      * @return whitelisted pool anchor\n    */\n    function whitelistedPool(uint256 _index) external view returns (IConverterAnchor) {\n        return poolWhitelist[_index];\n    }\n\n    /**\n      * @dev checks whether a given pool is whitelisted\n      *\n      * @param _poolAnchor pool anchor\n      * @return true if the given pool is whitelisted, false otherwise\n    */\n    function isPoolWhitelisted(IConverterAnchor _poolAnchor) external view override returns (bool) {\n        return poolWhitelistIndices[_poolAnchor].isValid;\n    }\n\n    /**\n      * @dev withdraws tokens held by the contract\n      * can only be called by the contract owner\n      *\n      * @param _token   token address\n      * @param _to      recipient address\n      * @param _amount  amount to withdraw\n    */\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n        external\n        override\n        ownerOnly\n        validAddress(_to)\n        notThis(_to)\n    {\n        safeTransfer(_token, _to, _amount);\n    }\n\n    /**\n      * @dev returns the number of protected liquidities for the given provider\n      *\n      * @param _provider    liquidity provider\n      * @return number of protected liquidities\n    */\n    function protectedLiquidityCount(address _provider) external view returns (uint256) {\n        return protectedLiquidityIdsByProvider[_provider].length;\n    }\n\n    /**\n      * @dev returns the list of protected liquidity ids for the given provider\n      *\n      * @param _provider    liquidity provider\n      * @return protected liquidity ids\n    */\n    function protectedLiquidityIds(address _provider) external view returns (uint256[] memory) {\n        return protectedLiquidityIdsByProvider[_provider];\n    }\n\n    /**\n      * @dev returns the id of a protected liquidity for the given provider at a specific index\n      *\n      * @param _provider    liquidity provider\n      * @param _index       protected liquidity index\n      * @return protected liquidity id\n    */\n    function protectedLiquidityId(address _provider, uint256 _index) external view returns (uint256) {\n        return protectedLiquidityIdsByProvider[_provider][_index];\n    }\n\n    /**\n      * @dev returns an existing protected liquidity details\n      *\n      * @param _id  protected liquidity id\n      *\n      * @return liquidity provider\n      * @return pool token address\n      * @return reserve token address\n      * @return pool token amount\n      * @return reserve token amount\n      * @return rate of 1 protected reserve token in units of the other reserve token (numerator)\n      * @return rate of 1 protected reserve token in units of the other reserve token (denominator)\n      * @return timestamp\n    */\n    function protectedLiquidity(uint256 _id)\n        external\n        view\n        override\n        returns (address, IDSToken,    IERC20Token, uint256, uint256, uint256, uint256, uint256) \n    {\n        ProtectedLiquidity storage liquidity = protectedLiquidities[_id];\n        return (\n            liquidity.provider,\n            liquidity.poolToken,\n            liquidity.reserveToken,\n            liquidity.poolAmount,\n            liquidity.reserveAmount,\n            liquidity.reserveRateN,\n            liquidity.reserveRateD,\n            liquidity.timestamp\n        );\n    }\n\n    /**\n      * @dev adds protected liquidity\n      * can only be called by the contract owner\n      *\n      * @param _provider        liquidity provider\n      * @param _poolToken       pool token address\n      * @param _reserveToken    reserve token address\n      * @param _poolAmount      pool token amount\n      * @param _reserveAmount   reserve token amount\n      * @param _reserveRateN    rate of 1 protected reserve token in units of the other reserve token (numerator)\n      * @param _reserveRateD    rate of 1 protected reserve token in units of the other reserve token (denominator)\n      * @param _timestamp       timestamp\n      * @return new protected liquidity id\n    */\n    function addProtectedLiquidity(\n        address _provider,\n        IDSToken _poolToken,   \n        IERC20Token _reserveToken,\n        uint256 _poolAmount,\n        uint256 _reserveAmount,\n        uint256 _reserveRateN,\n        uint256 _reserveRateD,\n        uint256 _timestamp\n    ) external override ownerOnly returns (uint256) {\n        // validate input\n        require(\n            _provider != address(0) &&\n            _provider != address(this) &&\n            address(_poolToken) != address(0) &&\n            address(_poolToken) != address(this) &&\n            address(_reserveToken) != address(0) &&\n            address(_reserveToken) != address(this),\n            \"ERR_INVALID_ADDRESS\"\n        );\n        require(\n            _poolAmount > 0 &&\n            _reserveAmount > 0 &&\n            _reserveRateN > 0 &&\n            _reserveRateD > 0 &&\n            _timestamp > 0,\n            \"ERR_ZERO_VALUE\"\n        );\n\n\n        // add the protected liquidity\n        uint256[] storage ids = protectedLiquidityIdsByProvider[_provider];\n        uint256 id = nextProtectedLiquidityId;\n        nextProtectedLiquidityId += 1;\n\n        protectedLiquidities[id] = ProtectedLiquidity({\n            provider: _provider,\n            index: ids.length,\n            poolToken: _poolToken,\n            reserveToken: _reserveToken,\n            poolAmount: _poolAmount,\n            reserveAmount: _reserveAmount,\n            reserveRateN: _reserveRateN,\n            reserveRateD: _reserveRateD,\n            timestamp: _timestamp\n        });\n\n        ids.push(id);\n\n        // update the total amounts\n        totalProtectedPoolAmounts[_poolToken] = totalProtectedPoolAmounts[_poolToken].add(_poolAmount);\n        totalProtectedReserveAmounts[_poolToken][_reserveToken] = totalProtectedReserveAmounts[_poolToken][_reserveToken].add(_reserveAmount);\n\n        emit ProtectionAdded(_provider, _poolToken, _reserveToken, _poolAmount, _reserveAmount);\n        return id;\n    }\n\n    /**\n      * @dev updates an existing protected liquidity pool/reserve amounts\n      * can only be called by the contract owner\n      *\n      * @param _id                  protected liquidity id\n      * @param _newPoolAmount       new pool tokens amount\n      * @param _newReserveAmount    new reserve tokens amount\n    */\n    function updateProtectedLiquidityAmounts(uint256 _id, uint256 _newPoolAmount, uint256 _newReserveAmount)\n        external\n        override\n        ownerOnly\n        greaterThanZero(_newPoolAmount)\n        greaterThanZero(_newReserveAmount)\n    {\n        // update the protected liquidity\n        ProtectedLiquidity storage liquidity = protectedLiquidities[_id];\n\n        // validate input\n        address provider = liquidity.provider;\n        require(provider != address(0), \"ERR_INVALID_ID\");\n\n        IDSToken poolToken    = liquidity.poolToken;\n        IERC20Token reserveToken = liquidity.reserveToken;\n        uint256 prevPoolAmount = liquidity.poolAmount;\n        uint256 prevReserveAmount = liquidity.reserveAmount;\n        liquidity.poolAmount = _newPoolAmount;\n        liquidity.reserveAmount = _newReserveAmount;\n\n        // update the total amounts\n        totalProtectedPoolAmounts[poolToken] = totalProtectedPoolAmounts[poolToken].add(_newPoolAmount).sub(prevPoolAmount);\n        totalProtectedReserveAmounts[poolToken][reserveToken] = totalProtectedReserveAmounts[poolToken][reserveToken].add(_newReserveAmount).sub(prevReserveAmount);\n\n        emit ProtectionUpdated(provider, prevPoolAmount, prevReserveAmount, _newPoolAmount, _newReserveAmount);\n    }\n\n    /**\n      * @dev removes protected liquidity\n      * can only be called by the contract owner\n      *\n      * @param _id  protected liquidity id\n    */\n    function removeProtectedLiquidity(uint256 _id) external override ownerOnly {\n        // remove the protected liquidity\n        ProtectedLiquidity storage liquidity = protectedLiquidities[_id];\n\n        // validate input\n        address provider = liquidity.provider;\n        require(provider != address(0), \"ERR_INVALID_ID\");\n\n        uint256 index = liquidity.index;\n        IDSToken poolToken    = liquidity.poolToken;\n        IERC20Token reserveToken = liquidity.reserveToken;\n        uint256 poolAmount = liquidity.poolAmount;\n        uint256 reserveAmount = liquidity.reserveAmount;\n        delete protectedLiquidities[_id];\n\n        uint256[] storage ids = protectedLiquidityIdsByProvider[provider];\n        uint256 length = ids.length;\n        assert(length > 0);\n\n        uint256 lastIndex = length - 1;\n        if (index < lastIndex) {\n            uint256 lastId = ids[lastIndex];\n            ids[index] = lastId;\n            protectedLiquidities[lastId].index = index;\n        }\n\n        ids.pop();\n\n        // update the total amounts\n        totalProtectedPoolAmounts[poolToken] = totalProtectedPoolAmounts[poolToken].sub(poolAmount);\n        totalProtectedReserveAmounts[poolToken][reserveToken] = totalProtectedReserveAmounts[poolToken][reserveToken].sub(reserveAmount);\n\n        emit ProtectionRemoved(provider, poolToken, reserveToken, poolAmount, reserveAmount);\n    }\n\n    /**\n      * @dev returns the number of network token locked balances for a given provider\n      *\n      * @param _provider    locked balances provider\n      * @return the number of network token locked balances\n    */\n    function lockedBalanceCount(address _provider) external view returns (uint256) {\n        return lockedBalances[_provider].length;\n    }\n\n    /**\n      * @dev returns an existing locked network token balance details\n      *\n      * @param _provider    locked balances provider\n      * @param _index       start index\n      * @return amount of network tokens\n      * @return lock expiration time\n    */\n    function lockedBalance(address _provider, uint256 _index) external view override returns (uint256, uint256) {\n        LockedBalance storage balance = lockedBalances[_provider][_index];\n        return (\n            balance.amount,\n            balance.expirationTime\n        );\n    }\n\n    /**\n      * @dev returns a range of locked network token balances for a given provider\n      *\n      * @param _provider    locked balances provider\n      * @param _startIndex  start index\n      * @param _endIndex    end index (exclusive)\n      * @return locked amounts\n      * @return expiration times\n    */\n    function lockedBalanceRange(address _provider, uint256 _startIndex, uint256 _endIndex)\n        external\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        // limit the end index by the number of locked balances\n        if (_endIndex > lockedBalances[_provider].length) {\n            _endIndex = lockedBalances[_provider].length;\n        }\n\n        // ensure that the end index is higher than the start index\n        require(_endIndex > _startIndex, \"ERR_INVALID_INDICES\");\n\n        // get the locked balances for the given range and return them\n        uint256 length = _endIndex - _startIndex;\n        uint256[] memory amounts = new uint256[](length);\n        uint256[] memory expirationTimes = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            LockedBalance storage balance = lockedBalances[_provider][_startIndex + i];\n            amounts[i] = balance.amount;\n            expirationTimes[i] = balance.expirationTime;\n        }\n\n        return (amounts, expirationTimes);\n    }\n\n    /**\n      * @dev adds new locked network token balance\n      * can only be called by the contract owner\n      *\n      * @param _provider        liquidity provider\n      * @param _amount          token amount\n      * @param _expirationTime  lock expiration time\n      * @return new locked balance index\n    */\n    function addLockedBalance(address _provider, uint256 _amount, uint256 _expirationTime)\n        external\n        override\n        ownerOnly\n        validAddress(_provider)\n        notThis(_provider)\n        greaterThanZero(_amount)\n        greaterThanZero(_expirationTime)\n        returns (uint256)\n    {\n        lockedBalances[_provider].push(LockedBalance({\n            amount: _amount,\n            expirationTime: _expirationTime\n        }));\n\n        emit BalanceLocked(_provider, _amount, _expirationTime);\n        return lockedBalances[_provider].length - 1;\n    }\n\n    /**\n      * @dev removes a locked network token balance\n      * can only be called by the contract owner\n      *\n      * @param _provider    liquidity provider\n      * @param _index       index of the locked balance\n    */\n    function removeLockedBalance(address _provider, uint256 _index)\n        external\n        override\n        ownerOnly\n        validAddress(_provider)\n    {\n        LockedBalance[] storage balances = lockedBalances[_provider];\n        uint256 length = balances.length;\n        \n        // validate input\n        require(_index < length, \"ERR_INVALID_INDEX\");\n\n        uint256 amount = balances[_index].amount;\n        uint256 lastIndex = length - 1;\n        if (_index < lastIndex) {\n            balances[_index] = balances[lastIndex];\n        }\n\n        balances.pop();\n\n        emit BalanceUnlocked(_provider, amount);\n    }\n\n    /**\n      * @dev returns the system balance for a given token\n      *\n      * @param _token   token address\n      * @return system balance\n    */\n    function systemBalance(IERC20Token _token) external view override returns (uint256) {\n        return systemBalances[_token];\n    }\n\n    /**\n      * @dev increases the system balance for a given token\n      * can only be called by the contract owner\n      *\n      * @param _token   token address\n      * @param _amount  token amount\n    */\n    function incSystemBalance(IERC20Token _token, uint256 _amount)\n        external\n        override\n        ownerOnly\n        validAddress(address(_token))\n    {\n        uint256 prevAmount = systemBalances[_token];\n        uint256 newAmount = prevAmount.add(_amount);\n        systemBalances[_token] = newAmount;\n\n        emit SystemBalanceUpdated(_token, prevAmount, newAmount);\n    }\n\n    /**\n      * @dev decreases the system balance for a given token\n      * can only be called by the contract owner\n      *\n      * @param _token   token address\n      * @param _amount  token amount\n    */\n    function decSystemBalance(IERC20Token _token, uint256 _amount)\n        external\n        override\n        ownerOnly\n        validAddress(address(_token))\n    {\n        uint256 prevAmount = systemBalances[_token];\n        uint256 newAmount = prevAmount.sub(_amount);\n        systemBalances[_token] = newAmount;\n\n        emit SystemBalanceUpdated(_token, prevAmount, newAmount);\n    }\n\n    /**\n      * @dev returns the total protected pool token amount for a given pool\n      *\n      * @param _poolToken   pool token address\n      * @return total protected amount\n    */\n    function totalProtectedPoolAmount(IDSToken _poolToken)    external view returns (uint256) {\n        return totalProtectedPoolAmounts[_poolToken];\n    }\n\n    /**\n      * @dev returns the total protected reserve amount for a given pool\n      *\n      * @param _poolToken       pool token address\n      * @param _reserveToken    reserve token address\n      * @return total protected amount\n    */\n    function totalProtectedReserveAmount(IDSToken _poolToken,    IERC20Token _reserveToken) external view returns (uint256) {\n        return totalProtectedReserveAmounts[_poolToken][_reserveToken];\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"BalanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BalanceUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IConverterAnchor\",\"name\":\"_poolAnchor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_added\",\"type\":\"bool\"}],\"name\":\"PoolWhitelistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IDSToken\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20Token\",\"name\":\"_reserveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_poolAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reserveAmount\",\"type\":\"uint256\"}],\"name\":\"ProtectionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IDSToken\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20Token\",\"name\":\"_reserveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_poolAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reserveAmount\",\"type\":\"uint256\"}],\"name\":\"ProtectionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevPoolAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevReserveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newPoolAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newReserveAmount\",\"type\":\"uint256\"}],\"name\":\"ProtectionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20Token\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"name\":\"SystemBalanceUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"addLockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"_poolAnchor\",\"type\":\"address\"}],\"name\":\"addPoolToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"contract IDSToken\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Token\",\"name\":\"_reserveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveRateN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveRateD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"addProtectedLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decSystemBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"incSystemBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"_poolAnchor\",\"type\":\"address\"}],\"name\":\"isPoolWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"lockedBalanceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"}],\"name\":\"lockedBalanceRange\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"protectedLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract IDSToken\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"protectedLiquidityCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"protectedLiquidityId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"protectedLiquidityIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeLockedBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"_poolAnchor\",\"type\":\"address\"}],\"name\":\"removePoolFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"removeProtectedLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"systemBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDSToken\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"totalProtectedPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDSToken\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Token\",\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"totalProtectedReserveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newPoolAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newReserveAmount\",\"type\":\"uint256\"}],\"name\":\"updateProtectedLiquidityAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"whitelistedPool\",\"outputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistedPoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistedPools\",\"outputs\":[{\"internalType\":\"contract IConverterAnchor[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityProtectionStore","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}