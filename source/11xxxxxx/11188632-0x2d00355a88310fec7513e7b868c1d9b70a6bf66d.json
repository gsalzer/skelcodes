{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/CompoundInterfaces.sol\r\n\r\npragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract ERC20{\r\n    uint public decimals;\r\n\r\n    function balanceOf(address _address) external view returns (uint256 balance);\r\n}\r\n\r\ncontract CTokenInterface{\r\n\r\n    uint public totalBorrows;\r\n    uint public totalReserves;\r\n    string public symbol;\r\n\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external view returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n}\r\n\r\ncontract Comptroller{\r\n   struct Market {\r\n          bool isListed;\r\n          uint collateralFactorMantissa;\r\n          bool isComped;\r\n    }\r\n\r\n    mapping(address => Market) public markets;\r\n    mapping(address => uint) public compAccrued;\r\n    function compSpeeds(address cTokenAddress) external view returns(uint);\r\n    function getAllMarkets() public view returns (CToken[] memory) {}\r\n}\r\n\r\ncontract PriceOracle{\r\n\r\n    function getUnderlyingPrice(CToken cToken) public view returns (uint);\r\n}\r\n\r\ncontract CToken{\r\n\r\n}\r\n\r\ncontract CompoundLens {\r\n\r\n    struct CompBalanceMetadataExt {\r\n            uint balance;\r\n            uint votes;\r\n            address delegate;\r\n            uint allocated;\r\n    }\r\n\r\n    function getCompBalanceMetadataExt(Comp comp, ComptrollerLensInterface comptroller, address account) external returns (CompBalanceMetadataExt memory);\r\n\r\n}\r\n\r\ncontract Comp{\r\n\r\n}\r\n\r\ninterface ComptrollerLensInterface {\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract UniswapAnchoredView{\r\n    function price(string calldata symbol) external view returns (uint);\r\n    function getUnderlyingPrice(address cToken) external view returns (uint);\r\n}\r\n\r\ncontract CErc20{\r\n    address public underlying;\r\n}\r\n\r\n// File: contracts/math/CarefulMath.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author Compound\r\n  * @notice Derived from OpenZeppelin's SafeMath library\r\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\n// File: contracts/math/Exponential.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev turn a number with mantissa(<18) to a mantissa of 18\r\n     * Note: returns error if the existing mantissa is greater than 18\r\n     */\r\n    function getExp18(uint numMantissa, uint mantissa) pure internal returns (Exp memory) {\r\n\r\n        uint scaledNum;\r\n\r\n        if(mantissa > 18){\r\n            scaledNum = div_(numMantissa, 10**sub_(mantissa, 18));\r\n        }else{\r\n            scaledNum = mul_(numMantissa, 10**sub_(18, mantissa));\r\n        }\r\n\r\n        return Exp({mantissa: scaledNum});\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n\r\n// File: contracts/utility/ErrorReporter.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ncontract CompFarmingSummaryErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        CTOKEN_NOT_FOUND,\r\n        CETH_NOT_SUPPORTED,\r\n        ACCOUNT_SNAPSHOT_ERROR,\r\n        UNAUTHORIZED\r\n    }\r\n\r\n    enum FailureInfo {\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK\r\n    }\r\n\r\n\r\n     event Failure(uint error, uint info, uint detail);\r\n\r\n     function fail(Error err, FailureInfo info) internal returns (uint) {\r\n         emit Failure(uint(err), uint(info), 0);\r\n\r\n         return uint(err);\r\n     }\r\n\r\n     function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n         emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n         return uint(err);\r\n     }\r\n\r\n}\r\n\r\n// File: contracts/CompFarmingSummaryInterface.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ninterface CompFarmingSummaryInterface {\r\n\r\n     struct CompProfile{\r\n          uint balance;\r\n          uint yetToClaimed;\r\n     }\r\n\r\n     function getPriceCOMP() external view returns (uint256 priceInUSD);\r\n     function sortedCompDistSpeedAllMarkets() external view returns (string[] memory sortedCTokenNameList, uint[] memory sortedCompSpeedList);\r\n     function compProfile(address account) external returns(CompProfile memory _compProfile);\r\n     function totalCompIncomePerYear(address _account) external view returns(uint errCode, string memory errCTokenSymbol, uint256 totalCompIncomeMantissa);\r\n}\r\n\r\n// File: contracts/CompFarmingSummaryProxyStorage.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ncontract CompFarmingSummaryProxyStorage {\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    address public compFarmingSummaryImplmentation;\r\n    address public pendingCompFarmingSummaryImplmentation;\r\n}\r\n\r\n\r\ncontract CompFarmingSummaryStorageV1 is CompFarmingSummaryProxyStorage{\r\n  \r\n}\r\n\r\n// File: contracts/CompFarmingSummaryProxy.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\n\r\ncontract CompFarmingSummaryProxy is CompFarmingSummaryProxyStorage, CompFarmingSummaryErrorReporter{\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingCompFarmingSummaryImplmentation;\r\n\r\n        pendingCompFarmingSummaryImplmentation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingCompFarmingSummaryImplmentation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _acceptImplementation() public returns (uint) {\r\n\r\n        if (msg.sender != pendingCompFarmingSummaryImplmentation || pendingCompFarmingSummaryImplmentation == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = compFarmingSummaryImplmentation;\r\n        address oldPendingImplementation = pendingCompFarmingSummaryImplmentation;\r\n\r\n        compFarmingSummaryImplmentation = pendingCompFarmingSummaryImplmentation;\r\n\r\n        pendingCompFarmingSummaryImplmentation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, compFarmingSummaryImplmentation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingCompFarmingSummaryImplmentation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _acceptAdmin() public returns (uint) {\r\n\r\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        admin = pendingAdmin;\r\n\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function () payable external {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = compFarmingSummaryImplmentation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n// File: contracts/CompFarmingSummaryV1.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CompFarmingSummaryV1 is CompFarmingSummaryStorageV1, CompFarmingSummaryInterface, Exponential, CompFarmingSummaryErrorReporter{\r\n\r\n\r\n    struct CompIncomeLocalVars{\r\n        uint cTokenDecimals;\r\n        uint underlyingDecimals;\r\n        uint compDistSpeedErrCode;\r\n        uint getAccountSnapshotErrCode;\r\n        uint cTokenBalanceMantissa18;\r\n        uint borrowBalanceMantissa18;\r\n        uint exchangeRateMantissa18;\r\n        uint supplyRatePerBlock;\r\n        uint borrowRatePerBlock;\r\n        uint totalSupply;\r\n        uint totalBorrow;\r\n        Exp compIncomePerBlockExp;\r\n        Exp underlyingTokenBalanceExp;\r\n        Exp loanBalanceExp;\r\n        Exp loanBalanceWithInterestExp;\r\n        Exp supplyPercentageExp;\r\n        Exp borrowPercentageExp;\r\n        Exp compIncomeOnSupplyExp;\r\n        Exp compIncomeOnBorrowExp;\r\n        Exp compIncomeExp;\r\n        Exp compReleasedExp;\r\n    }\r\n\r\n    struct getAccountSnapshotLocalVars{\r\n        uint errCode;\r\n        uint cTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint cTokenBalanceMantissa18;\r\n        uint borrowBalanceMantissa18;\r\n        uint exchangeRateMantissa18;\r\n        MathError cTokenBalanceExpErr;\r\n        Exp cTokenBalanceExp;\r\n        MathError borrowBalanceExpErr;\r\n        Exp borrowBalanceExp;\r\n        MathError exchangeRateExpErr;\r\n        Exp exchangeRateExp;\r\n    }\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    //note: add view\r\n    function getPriceCOMP() external view returns (uint256 priceInUSD){\r\n        UniswapAnchoredView uniswapAnchoredView = UniswapAnchoredView(getUniswapAnchoredViewAddress());\r\n        priceInUSD = uniswapAnchoredView.price(\"COMP\");\r\n    }\r\n\r\n    //note: add view\r\n    function sortedCompDistSpeedAllMarkets() external view returns (string[] memory sortedCTokenNameList, uint[] memory sortedCompSpeedList) {\r\n\r\n        string[] memory cTokenNameList = cTokenNameList();\r\n\r\n        string[] memory _cTokenNameList = new string[](cTokenNameList.length);\r\n        uint[] memory compSpeedList = new uint[](cTokenNameList.length);\r\n\r\n        Exp memory compAmountPerBlockExp;\r\n\r\n        for(uint i = 0; i < cTokenNameList.length; i++){\r\n\r\n                compAmountPerBlockExp = compDistSpeed(contractSymbolToAddressMap(cTokenNameList[i]));\r\n                _cTokenNameList[i] = cTokenNameList[i];\r\n                compSpeedList[i] = compAmountPerBlockExp.mantissa;\r\n\r\n        }\r\n\r\n        //sort compSpeedList\r\n        (sortedCTokenNameList, sortedCompSpeedList) = quickSortDESC(_cTokenNameList, compSpeedList);\r\n    }\r\n\r\n    //note: add view\r\n    function compProfile(address account) external returns(CompProfile memory _compProfile){\r\n\r\n        CompoundLens compoundLens = CompoundLens(getCompoundLensAddress());\r\n        CompoundLens.CompBalanceMetadataExt memory result = compoundLens.getCompBalanceMetadataExt(Comp(getCompAddress()), ComptrollerLensInterface(getUnitrollerAddress()), account);\r\n        _compProfile.balance = result.balance;\r\n        _compProfile.yetToClaimed = result.allocated;\r\n    }\r\n\r\n    //note: add view\r\n    function totalCompIncomePerYear(address _account) external view returns(uint errCode, string memory, uint256 totalCompIncomeMantissa){\r\n        (Error err, string memory _errCTokenSymbol, Exp memory totalCompIncomeExp) = totalCompIncome(_account, div_(estimatedNumberOfBlocksPerYear(), expScale));\r\n        //require(err == Error.NO_ERROR, appendStrings(\"Error occured on: \", errCTokenSymbol));\r\n        if(err != Error.NO_ERROR){\r\n            return (uint(err), _errCTokenSymbol, 0);\r\n        }\r\n\r\n        return (0, \"\", totalCompIncomeExp.mantissa);\r\n    }\r\n\r\n\r\n    //note: add view\r\n    function totalCompIncome(address _account, uint numberOfBlocks) internal view returns(Error, string memory, Exp memory compIncomeForThePeriodExp){\r\n\r\n        string[] memory cTokenNameList = cTokenNameList();\r\n\r\n        uint256 numberOfMarkets = cTokenNameList.length;\r\n\r\n        Error err = Error.NO_ERROR;\r\n        Exp[] memory compIncomeExpOfTheMarketList = new Exp[](numberOfMarkets);\r\n        compIncomeForThePeriodExp = Exp({mantissa: 0});\r\n\r\n        for(uint i = 0; i < numberOfMarkets; i++){\r\n\r\n            string memory cTokenName = cTokenNameList[i];\r\n\r\n            (err, compIncomeExpOfTheMarketList[i]) = compIncomeByCToken(_account, contractSymbolToAddressMap(cTokenName), numberOfBlocks);\r\n\r\n            if(err != Error.NO_ERROR){\r\n                return (err, cTokenName, Exp({mantissa: 0}));\r\n            }\r\n            //addLog(cTokenName);\r\n            //addLog(compIncomeExpOfTheMarketList[i].mantissa);\r\n            compIncomeForThePeriodExp = add_(compIncomeForThePeriodExp, compIncomeExpOfTheMarketList[i]);\r\n        }\r\n\r\n\r\n\r\n        return (Error.NO_ERROR, \"\", compIncomeForThePeriodExp);\r\n\r\n    }\r\n\r\n\r\n\r\n    //note: add view\r\n    function compIncomeByCToken(address _account, address cTokenAddress, uint numberOfBlocks) internal view returns(Error, Exp memory){\r\n\r\n\r\n        CompIncomeLocalVars memory v;\r\n\r\n        //get cToken Decimals\r\n        v.cTokenDecimals = ERC20(cTokenAddress).decimals();\r\n        v.underlyingDecimals = underlyingDecimals(cTokenAddress);\r\n\r\n        //get comp token distrubtion speed\r\n        v.compIncomePerBlockExp = compDistSpeed(cTokenAddress);\r\n        //continue to refractor here\r\n\r\n        //get account snapshot\r\n        (v.getAccountSnapshotErrCode, v.cTokenBalanceMantissa18, v.borrowBalanceMantissa18, v.exchangeRateMantissa18) = getAccountSnapshot(_account, cTokenAddress);\r\n        if(v.getAccountSnapshotErrCode != 0){\r\n            return (Error.ACCOUNT_SNAPSHOT_ERROR, Exp({mantissa: 0}));\r\n        }\r\n        //underlyingTokenBalance\r\n        v.underlyingTokenBalanceExp = mul_(Exp({mantissa: v.cTokenBalanceMantissa18}), Exp({mantissa: v.exchangeRateMantissa18}));\r\n\r\n        //loanBalanceExp\r\n        v.loanBalanceExp = Exp({mantissa: v.borrowBalanceMantissa18});\r\n\r\n        //totalSupplyWithInterest\r\n        v.totalSupply = getTotalSupply(cTokenAddress);\r\n\r\n        //totalBorrowWithInterest\r\n        v.totalBorrow = getTotalBorrow(cTokenAddress);\r\n\r\n        //supplyPercentageMantissa\r\n        v.supplyPercentageExp = div_(mul_(v.underlyingTokenBalanceExp, expScale), v.totalSupply);\r\n        v.borrowPercentageExp = div_(mul_(v.loanBalanceExp, expScale), v.totalBorrow);\r\n\r\n        v.compReleasedExp = mul_(v.compIncomePerBlockExp, numberOfBlocks);\r\n\r\n        v.compIncomeOnSupplyExp = mul_(v.compReleasedExp, v.supplyPercentageExp);\r\n\r\n        v.compIncomeOnBorrowExp = mul_(v.compReleasedExp, v.borrowPercentageExp);\r\n\r\n        v.compIncomeExp = add_(v.compIncomeOnSupplyExp, v.compIncomeOnBorrowExp);\r\n\r\n\r\n        return (Error.NO_ERROR, v.compIncomeExp);\r\n    }\r\n\r\n    //note: add view\r\n    function getCTokenTotalSupply (address cTokenAddress) internal view returns (Error err, uint256 totalSupplyValueInUSD) {\r\n\r\n        string[] memory cTokenNameList = cTokenNameList();\r\n\r\n        //check\r\n        require(hasCToken(cTokenAddress, cTokenNameList), \"cToken not found!\");\r\n\r\n        address underlyingAddress = CErc20(cTokenAddress).underlying();\r\n\r\n        uint256 totalSupply = getTotalSupply(cTokenAddress);\r\n\r\n        Exp memory totalSupplyExp = getExp18(totalSupply, ERC20(underlyingAddress).decimals());//Exp({mantissa: mul_(totalSupply, 10**(sub_(18, ERC20(underlyingAddress).decimals()))});\r\n        Exp memory underlyingPriceInUSDExp = Exp({mantissa: getPriceInUSD(cTokenAddress)});\r\n        Exp memory totalSupplyValueExp = mul_(totalSupplyExp, underlyingPriceInUSDExp);\r\n\r\n        totalSupplyValueInUSD = totalSupplyValueExp.mantissa;\r\n\r\n        return (Error.NO_ERROR, totalSupplyValueInUSD);\r\n\r\n    }\r\n\r\n\r\n    function getPriceInUSD(address cTokenAddress) public view returns (uint256 priceInUSD) {\r\n        UniswapAnchoredView uniswapAnchoredView = UniswapAnchoredView(getUniswapAnchoredViewAddress());\r\n        priceInUSD = uniswapAnchoredView.getUnderlyingPrice(cTokenAddress);\r\n    }\r\n\r\n    function getTotalSupply(address cTokenAddress) internal view returns (uint256 totalSupply){\r\n        uint256 cash = CTokenInterface(cTokenAddress).getCash();\r\n        uint256 totalBorrow = CTokenInterface(cTokenAddress).totalBorrows();\r\n        uint256 totalReserves = CTokenInterface(cTokenAddress).totalReserves();\r\n\r\n        totalSupply = sub_(add_(cash, totalBorrow), totalReserves);\r\n\r\n    }\r\n\r\n    function getAccountSnapshot(address _account, address cTokenAddress) internal view returns (uint256, uint256, uint256, uint256){\r\n\r\n        getAccountSnapshotLocalVars memory v;\r\n\r\n        CTokenInterface cToken = CTokenInterface(cTokenAddress);\r\n        uint256 cTokenDecimals = ERC20(cTokenAddress).decimals();\r\n        uint256 _underlyingDecimals = underlyingDecimals(cTokenAddress);\r\n\r\n\r\n        (v.errCode, v.cTokenBalance, v.borrowBalance, v.exchangeRateMantissa) = cToken.getAccountSnapshot(_account);\r\n\r\n        if(v.errCode != 0){\r\n            return (v.errCode, 0, 0, 0);\r\n        }\r\n\r\n        v.cTokenBalanceExp = getExp18(v.cTokenBalance, cTokenDecimals);\r\n        v.borrowBalanceExp = getExp18(v.borrowBalance, _underlyingDecimals);\r\n        v.exchangeRateExp = getExp18(v.exchangeRateMantissa, mantissaOfExchangeRate(cTokenAddress));\r\n        v.cTokenBalanceMantissa18 = v.cTokenBalanceExp.mantissa;\r\n        v.borrowBalanceMantissa18 = v.borrowBalanceExp.mantissa;\r\n        v.exchangeRateMantissa18 = v.exchangeRateExp.mantissa;\r\n\r\n        return (0, v.cTokenBalanceMantissa18, v.borrowBalanceMantissa18, v.exchangeRateMantissa18);\r\n    }\r\n\r\n\r\n\r\n    function cTokenNameList() internal view returns(string[] memory _cTokenNameList){\r\n          Comptroller comptroller = Comptroller(getUnitrollerAddress());\r\n          CToken[] memory allMarkets = comptroller.getAllMarkets();\r\n\r\n          bool isListed;\r\n          bool isComped;\r\n          address addressOfMarket;\r\n          uint _index;\r\n          string[] memory _cTokenNameListFullSize = new string[](allMarkets.length);\r\n\r\n          for(uint i = 0; i < allMarkets.length; i++){\r\n              addressOfMarket = address(allMarkets[i]);\r\n              (isListed, , isComped) = comptroller.markets(addressOfMarket);\r\n\r\n              if(isListed && isComped){\r\n                  address cTokenAddress = address(allMarkets[i]);\r\n                  string memory cTokenName = CTokenInterface(cTokenAddress).symbol();\r\n                  _cTokenNameListFullSize[_index] = cTokenName;\r\n\r\n                  _index++;\r\n              }\r\n          }\r\n\r\n          _cTokenNameList = new string[](_index);\r\n\r\n          for(uint i = 0; i < _cTokenNameList.length; i++){\r\n              _cTokenNameList[i] = _cTokenNameListFullSize[i];\r\n          }\r\n    }\r\n\r\n    function contractSymbolToAddressMap(string memory symbol) internal view returns (address){\r\n          Comptroller comptroller = Comptroller(getUnitrollerAddress());\r\n          CToken[] memory allMarkets = comptroller.getAllMarkets();\r\n\r\n          for(uint i = 0; i < allMarkets.length; i++){\r\n              address addressOfMarket = address(allMarkets[i]);\r\n              string memory symbolOfMarket = CTokenInterface(addressOfMarket).symbol();\r\n\r\n              if(compareStrings(symbolOfMarket, symbol)){\r\n                  return addressOfMarket;\r\n              }\r\n          }\r\n\r\n          return address(0);\r\n    }\r\n\r\n    function hasCToken(address cTokenAddress, string[] memory _cTokenNameList) internal view returns (bool) {\r\n        for(uint i = 0; i < _cTokenNameList.length; i++){\r\n            if(compareStrings(_cTokenNameList[i], CTokenInterface(cTokenAddress).symbol())){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    //require to check cTokenAddress is valid\r\n    function underlyingDecimals(address cTokenAddress) internal view returns (uint256) {\r\n\r\n        if(cTokenAddress == getCEthAddress()){\r\n            return 18;\r\n        }\r\n\r\n        address underlyingAddress = CErc20(cTokenAddress).underlying();\r\n\r\n        return ERC20(underlyingAddress).decimals();\r\n    }\r\n\r\n    function mantissaOfExchangeRate(address cTokenAddress) internal view returns (uint256 mantissa) {\r\n\r\n        uint256 _underlyingDecimals = underlyingDecimals(cTokenAddress);\r\n        uint256 cTokenDecimals = ERC20(cTokenAddress).decimals();\r\n\r\n        mantissa = sub_(add_(18, _underlyingDecimals), cTokenDecimals);\r\n    }\r\n\r\n    function getTotalBorrow(address cTokenAddress) internal view returns (uint totalBorrow){\r\n        CTokenInterface cToken = CTokenInterface(cTokenAddress);\r\n        totalBorrow = cToken.totalBorrows();\r\n    }\r\n\r\n    function compDistSpeed(address cTokenAddress) internal view returns (Exp memory compAmountPerBlockExp){\r\n\r\n        Comptroller comptroller = Comptroller(getUnitrollerAddress());\r\n\r\n        uint256 compDecimals = ERC20(getCompAddress()).decimals();\r\n\r\n        uint256 compAmountPerBlock = comptroller.compSpeeds(cTokenAddress);\r\n\r\n        compAmountPerBlockExp = getExp18(compAmountPerBlock, compDecimals);//Exp({mantissa: mul_(compAmountPerBlock, 10**sub_(18, compDecimals))});\r\n\r\n        return compAmountPerBlockExp;\r\n\r\n    }\r\n\r\n    function estimatedNumberOfBlocksPerYear() internal pure returns (uint256 numberOfBlocksPerYearMantissa){\r\n        uint256 numberOfBlockPerSec = 14;\r\n        uint256 secsPerYear = 31536000;\r\n\r\n        (MathError err, Exp memory numberOfBlocksPerYearExp) = getExp(secsPerYear, numberOfBlockPerSec);\r\n        if(err != MathError.NO_ERROR){ return 0; }\r\n\r\n        numberOfBlocksPerYearMantissa = numberOfBlocksPerYearExp.mantissa;\r\n    }\r\n\r\n    function compareStrings (string memory a, string memory b) public pure returns (bool) {\r\n          return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n    }\r\n\r\n    function quickSortDESC(string[] memory keys, uint[] memory values) internal pure returns (string[] memory, uint[] memory){\r\n\r\n          string[] memory keysPlus = new string[](keys.length + 1);\r\n          uint[] memory valuesPlus = new uint[](values.length + 1);\r\n\r\n          for(uint i = 0; i < keys.length; i++){\r\n              keysPlus[i] = keys[i];\r\n              valuesPlus[i] = values[i];\r\n          }\r\n\r\n          (keysPlus, valuesPlus) = quickSort(keysPlus, valuesPlus, 0, keysPlus.length - 1);\r\n\r\n          string[] memory keys_desc = new string[](keys.length);\r\n          uint[] memory values_desc = new uint[](values.length);\r\n          for(uint i = 0; i < keys.length; i++){\r\n              keys_desc[keys.length - 1 - i] = keysPlus[i + 1];\r\n              values_desc[keys.length - 1 - i] = valuesPlus[i + 1];\r\n          }\r\n\r\n          return (keys_desc, values_desc);\r\n    }\r\n\r\n    function quickSort(string[] memory keys, uint[] memory values, uint left, uint right) internal pure returns (string[] memory, uint[] memory){\r\n          uint i = left;\r\n          uint j = right;\r\n          uint pivot = values[left + (right - left) / 2];\r\n          while (i <= j) {\r\n              while (values[i] < pivot) i++;\r\n              while (pivot < values[j]) j--;\r\n              if (i <= j) {\r\n                  (keys[i], keys[j]) = (keys[j], keys[i]);\r\n                  (values[i], values[j]) = (values[j], values[i]);\r\n                  i++;\r\n                  j--;\r\n              }\r\n          }\r\n          if (left < j)\r\n              quickSort(keys, values, left, j);\r\n\r\n          if (i < right)\r\n              quickSort(keys, values, i, right);\r\n\r\n              return (keys, values);\r\n    }\r\n\r\n    function getCEthAddress() internal pure returns(address){\r\n          return 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    function getCompAddress() internal pure returns(address){\r\n          return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n    }\r\n\r\n    function getUnitrollerAddress() internal pure returns(address){\r\n          return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    function getCompoundLensAddress() internal pure returns(address){\r\n          return 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\r\n    }\r\n\r\n    function getUniswapAnchoredViewAddress() internal pure returns(address){\r\n          return 0x922018674c12a7F0D394ebEEf9B58F186CdE13c1;\r\n    }\r\n\r\n    //admin functions\r\n    function _become(CompFarmingSummaryProxy proxy) public {\r\n        require(msg.sender == proxy.admin(), \"only admin can change brains\");\r\n\r\n        require(proxy._acceptImplementation() == 0, \"changes not permitted\");\r\n    }\r\n\r\n\r\n    function getVersion() external pure returns(uint){\r\n          return 1;\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract CompFarmingSummaryProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"_become\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compFarmingSummaryImplmentation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"compProfile\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yetToClaimed\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryInterface.CompProfile\",\"name\":\"_compProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"b\",\"type\":\"string\"}],\"name\":\"compareStrings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPriceCOMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceInUSD\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddress\",\"type\":\"address\"}],\"name\":\"getPriceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceInUSD\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingCompFarmingSummaryImplmentation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sortedCompDistSpeedAllMarkets\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"sortedCTokenNameList\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sortedCompSpeedList\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"totalCompIncomePerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"errCode\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalCompIncomeMantissa\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompFarmingSummaryV1","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f7e9029c086c93a927ba4b0e6074084da17ba9e1ae467786cd9f379bbc939224"}]}