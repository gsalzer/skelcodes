{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* https://tornado.cash\r\n*\r\n* d888888P                                           dP              a88888b.                   dP\r\n*    88                                              88             d8'   `88                   88\r\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n*/\r\n\r\n// File: contracts/interfaces/IVerifier.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IVerifier {\r\n  function verifyProof(bytes calldata proof, uint256[4] calldata input) external view returns (bool);\r\n\r\n  function verifyProof(bytes calldata proof, uint256[7] calldata input) external view returns (bool);\r\n\r\n  function verifyProof(bytes calldata proof, uint256[12] calldata input) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IRewardSwap.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface IRewardSwap {\r\n  function swap(address recipient, uint256 amount) external returns (uint256);\r\n\r\n  function setPoolWeight(uint256 newWeight) external;\r\n}\r\n\r\n// File: torn-token/contracts/ENS.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface ENS {\r\n  function resolver(bytes32 node) external view returns (Resolver);\r\n}\r\n\r\ninterface Resolver {\r\n  function addr(bytes32 node) external view returns (address);\r\n}\r\n\r\ncontract EnsResolve {\r\n  function resolve(bytes32 node) public view virtual returns (address) {\r\n    ENS Registry = ENS(\r\n      getChainId() == 1 ? 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e : 0x8595bFb0D940DfEDC98943FA8a907091203f25EE\r\n    );\r\n    return Registry.resolver(node).addr(node);\r\n  }\r\n\r\n  function bulkResolve(bytes32[] memory domains) public view returns (address[] memory result) {\r\n    result = new address[](domains.length);\r\n    for (uint256 i = 0; i < domains.length; i++) {\r\n      result[i] = resolve(domains[i]);\r\n    }\r\n  }\r\n\r\n  function getChainId() internal pure returns (uint256) {\r\n    uint256 chainId;\r\n    assembly {\r\n      chainId := chainid()\r\n    }\r\n    return chainId;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IHasher.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface IHasher {\r\n  function poseidon(bytes32[2] calldata inputs) external pure returns (bytes32);\r\n\r\n  function poseidon(bytes32[3] calldata inputs) external pure returns (bytes32);\r\n}\r\n\r\n// File: contracts/utils/MerkleTreeWithHistory.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ncontract MerkleTreeWithHistory {\r\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\r\n\r\n  uint32 public immutable levels;\r\n  IHasher public hasher; // todo immutable\r\n\r\n  bytes32[] public filledSubtrees;\r\n  bytes32[] public zeros;\r\n  uint32 public currentRootIndex = 0;\r\n  uint32 public nextIndex = 0;\r\n  uint32 public constant ROOT_HISTORY_SIZE = 10;\r\n  bytes32[ROOT_HISTORY_SIZE] public roots;\r\n\r\n  constructor(uint32 _treeLevels, IHasher _hasher) public {\r\n    require(_treeLevels > 0, \"_treeLevels should be greater than zero\");\r\n    require(_treeLevels < 32, \"_treeLevels should be less than 32\");\r\n    levels = _treeLevels;\r\n    hasher = _hasher;\r\n\r\n    bytes32 currentZero = bytes32(ZERO_VALUE);\r\n    zeros.push(currentZero);\r\n    filledSubtrees.push(currentZero);\r\n\r\n    for (uint32 i = 1; i < _treeLevels; i++) {\r\n      currentZero = hashLeftRight(currentZero, currentZero);\r\n      zeros.push(currentZero);\r\n      filledSubtrees.push(currentZero);\r\n    }\r\n\r\n    filledSubtrees.push(hashLeftRight(currentZero, currentZero));\r\n    roots[0] = filledSubtrees[_treeLevels];\r\n  }\r\n\r\n  /**\r\n    @dev Hash 2 tree leaves, returns poseidon(_left, _right)\r\n  */\r\n  function hashLeftRight(bytes32 _left, bytes32 _right) public view returns (bytes32) {\r\n    return hasher.poseidon([_left, _right]);\r\n  }\r\n\r\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\r\n    uint32 currentIndex = nextIndex;\r\n    require(currentIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\r\n    nextIndex = currentIndex + 1;\r\n    bytes32 currentLevelHash = _leaf;\r\n    bytes32 left;\r\n    bytes32 right;\r\n\r\n    for (uint32 i = 0; i < levels; i++) {\r\n      if (currentIndex % 2 == 0) {\r\n        left = currentLevelHash;\r\n        right = zeros[i];\r\n        filledSubtrees[i] = currentLevelHash;\r\n      } else {\r\n        left = filledSubtrees[i];\r\n        right = currentLevelHash;\r\n      }\r\n\r\n      currentLevelHash = hashLeftRight(left, right);\r\n      currentIndex /= 2;\r\n    }\r\n\r\n    currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\r\n    roots[currentRootIndex] = currentLevelHash;\r\n    return nextIndex - 1;\r\n  }\r\n\r\n  function _bulkInsert(bytes32[] memory _leaves) internal {\r\n    uint32 insertIndex = nextIndex;\r\n    require(insertIndex + _leaves.length <= uint32(2)**levels, \"Merkle doesn't have enough capacity to add specified leaves\");\r\n\r\n    bytes32[] memory subtrees = new bytes32[](levels);\r\n    bool[] memory modifiedSubtrees = new bool[](levels);\r\n    for (uint32 j = 0; j < _leaves.length - 1; j++) {\r\n      uint256 index = insertIndex + j;\r\n      bytes32 currentLevelHash = _leaves[j];\r\n\r\n      for (uint32 i = 0; ; i++) {\r\n        if (index % 2 == 0) {\r\n          modifiedSubtrees[i] = true;\r\n          subtrees[i] = currentLevelHash;\r\n          break;\r\n        }\r\n\r\n        if(subtrees[i] == bytes32(0)) {\r\n          subtrees[i] = filledSubtrees[i];\r\n        }\r\n        currentLevelHash = hashLeftRight(subtrees[i], currentLevelHash);\r\n        index /= 2;\r\n      }\r\n    }\r\n\r\n    for (uint32 i = 0; i < levels; i++) {\r\n      // using local map to save on gas on writes if elements were not modified\r\n      if (modifiedSubtrees[i]) {\r\n        filledSubtrees[i] = subtrees[i];\r\n      }\r\n    }\r\n\r\n    nextIndex = uint32(insertIndex + _leaves.length - 1);\r\n    _insert(_leaves[_leaves.length - 1]);\r\n  }\r\n\r\n  /**\r\n    @dev Whether the root is present in the root history\r\n  */\r\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\r\n    if (_root == 0) {\r\n      return false;\r\n    }\r\n    uint32 i = currentRootIndex;\r\n    do {\r\n      if (_root == roots[i]) {\r\n        return true;\r\n      }\r\n      if (i == 0) {\r\n        i = ROOT_HISTORY_SIZE;\r\n      }\r\n      i--;\r\n    } while (i != currentRootIndex);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n    @dev Returns the last root\r\n  */\r\n  function getLastRoot() public view returns (bytes32) {\r\n    return roots[currentRootIndex];\r\n  }\r\n}\r\n\r\n// File: contracts/utils/OwnableMerkleTree.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract OwnableMerkleTree is Ownable, MerkleTreeWithHistory {\r\n  constructor(uint32 _treeLevels, IHasher _hasher) public MerkleTreeWithHistory(_treeLevels, _hasher) {}\r\n\r\n  function insert(bytes32 _leaf) external onlyOwner returns (uint32 index) {\r\n    return _insert(_leaf);\r\n  }\r\n\r\n  function bulkInsert(bytes32[] calldata _leaves) external onlyOwner {\r\n    _bulkInsert(_leaves);\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/ITornadoTrees.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface ITornadoTrees {\r\n  function registerDeposit(address instance, bytes32 commitment) external;\r\n\r\n  function registerWithdrawal(address instance, bytes32 nullifier) external;\r\n}\r\n\r\n// File: contracts/TornadoTrees.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract TornadoTrees is ITornadoTrees, EnsResolve {\r\n  OwnableMerkleTree public immutable depositTree;\r\n  OwnableMerkleTree public immutable withdrawalTree;\r\n  IHasher public immutable hasher;\r\n  address public immutable tornadoProxy;\r\n\r\n  bytes32[] public deposits;\r\n  uint256 public lastProcessedDepositLeaf;\r\n\r\n  bytes32[] public withdrawals;\r\n  uint256 public lastProcessedWithdrawalLeaf;\r\n\r\n  event DepositData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\r\n  event WithdrawalData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\r\n\r\n  struct TreeLeaf {\r\n    address instance;\r\n    bytes32 hash;\r\n    uint256 block;\r\n  }\r\n\r\n  modifier onlyTornadoProxy {\r\n    require(msg.sender == tornadoProxy, \"Not authorized\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    bytes32 _tornadoProxy,\r\n    bytes32 _hasher2,\r\n    bytes32 _hasher3,\r\n    uint32 _levels\r\n  ) public {\r\n    tornadoProxy = resolve(_tornadoProxy);\r\n    hasher = IHasher(resolve(_hasher3));\r\n    depositTree = new OwnableMerkleTree(_levels, IHasher(resolve(_hasher2)));\r\n    withdrawalTree = new OwnableMerkleTree(_levels, IHasher(resolve(_hasher2)));\r\n  }\r\n\r\n  function registerDeposit(address _instance, bytes32 _commitment) external override onlyTornadoProxy {\r\n    deposits.push(keccak256(abi.encode(_instance, _commitment, blockNumber())));\r\n  }\r\n\r\n  function registerWithdrawal(address _instance, bytes32 _nullifier) external override onlyTornadoProxy {\r\n    withdrawals.push(keccak256(abi.encode(_instance, _nullifier, blockNumber())));\r\n  }\r\n\r\n  function updateRoots(TreeLeaf[] calldata _deposits, TreeLeaf[] calldata _withdrawals) external {\r\n    if (_deposits.length > 0) updateDepositTree(_deposits);\r\n    if (_withdrawals.length > 0) updateWithdrawalTree(_withdrawals);\r\n  }\r\n\r\n  function updateDepositTree(TreeLeaf[] calldata _deposits) public {\r\n    bytes32[] memory leaves = new bytes32[](_deposits.length);\r\n    uint256 offset = lastProcessedDepositLeaf;\r\n\r\n    for (uint256 i = 0; i < _deposits.length; i++) {\r\n      TreeLeaf memory deposit = _deposits[i];\r\n      bytes32 leafHash = keccak256(abi.encode(deposit.instance, deposit.hash, deposit.block));\r\n      require(deposits[offset + i] == leafHash, \"Incorrect deposit\");\r\n\r\n      leaves[i] = hasher.poseidon([bytes32(uint256(deposit.instance)), deposit.hash, bytes32(deposit.block)]);\r\n      delete deposits[offset + i];\r\n\r\n      emit DepositData(deposit.instance, deposit.hash, deposit.block, offset + i);\r\n    }\r\n\r\n    lastProcessedDepositLeaf = offset + _deposits.length;\r\n    depositTree.bulkInsert(leaves);\r\n  }\r\n\r\n  function updateWithdrawalTree(TreeLeaf[] calldata _withdrawals) public {\r\n    bytes32[] memory leaves = new bytes32[](_withdrawals.length);\r\n    uint256 offset = lastProcessedWithdrawalLeaf;\r\n\r\n    for (uint256 i = 0; i < _withdrawals.length; i++) {\r\n      TreeLeaf memory withdrawal = _withdrawals[i];\r\n      bytes32 leafHash = keccak256(abi.encode(withdrawal.instance, withdrawal.hash, withdrawal.block));\r\n      require(withdrawals[offset + i] == leafHash, \"Incorrect withdrawal\");\r\n\r\n      leaves[i] = hasher.poseidon([bytes32(uint256(withdrawal.instance)), withdrawal.hash, bytes32(withdrawal.block)]);\r\n      delete withdrawals[offset + i];\r\n\r\n      emit WithdrawalData(withdrawal.instance, withdrawal.hash, withdrawal.block, offset + i);\r\n    }\r\n\r\n    lastProcessedWithdrawalLeaf = offset + _withdrawals.length;\r\n    withdrawalTree.bulkInsert(leaves);\r\n  }\r\n\r\n  function validateRoots(bytes32 _depositRoot, bytes32 _withdrawalRoot) public view {\r\n    require(depositTree.isKnownRoot(_depositRoot), \"Incorrect deposit tree root\");\r\n    require(withdrawalTree.isKnownRoot(_withdrawalRoot), \"Incorrect withdrawal tree root\");\r\n  }\r\n\r\n  function depositRoot() external view returns (bytes32) {\r\n    return depositTree.getLastRoot();\r\n  }\r\n\r\n  function withdrawalRoot() external view returns (bytes32) {\r\n    return withdrawalTree.getLastRoot();\r\n  }\r\n\r\n  function getRegisteredDeposits() external view returns (bytes32[] memory _deposits) {\r\n    uint256 count = deposits.length - lastProcessedDepositLeaf;\r\n    _deposits = new bytes32[](count);\r\n    for (uint256 i = 0; i < count; i++) {\r\n      _deposits[i] = deposits[lastProcessedDepositLeaf + i];\r\n    }\r\n  }\r\n\r\n  function getRegisteredWithdrawals() external view returns (bytes32[] memory _withdrawals) {\r\n    uint256 count = withdrawals.length - lastProcessedWithdrawalLeaf;\r\n    _withdrawals = new bytes32[](count);\r\n    for (uint256 i = 0; i < count; i++) {\r\n      _withdrawals[i] = withdrawals[lastProcessedWithdrawalLeaf + i];\r\n    }\r\n  }\r\n\r\n  function blockNumber() public view virtual returns (uint256) {\r\n    return block.number;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Miner.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Miner is EnsResolve {\r\n  using SafeMath for uint256;\r\n\r\n  IVerifier public rewardVerifier;\r\n  IVerifier public withdrawVerifier;\r\n  IVerifier public treeUpdateVerifier;\r\n  IRewardSwap public immutable rewardSwap;\r\n  address public immutable governance;\r\n  TornadoTrees public tornadoTrees;\r\n\r\n  mapping(bytes32 => bool) public accountNullifiers;\r\n  mapping(bytes32 => bool) public rewardNullifiers;\r\n  mapping(address => uint256) public rates;\r\n\r\n  uint256 public accountCount;\r\n  uint256 public constant ACCOUNT_ROOT_HISTORY_SIZE = 100;\r\n  bytes32[ACCOUNT_ROOT_HISTORY_SIZE] public accountRoots;\r\n\r\n  event NewAccount(bytes32 commitment, bytes32 nullifier, bytes encryptedAccount, uint256 index);\r\n  event RateChanged(address instance, uint256 value);\r\n  event VerifiersUpdated(address reward, address withdraw, address treeUpdate);\r\n\r\n  struct TreeUpdateArgs {\r\n    bytes32 oldRoot;\r\n    bytes32 newRoot;\r\n    bytes32 leaf;\r\n    uint256 pathIndices;\r\n  }\r\n\r\n  struct AccountUpdate {\r\n    bytes32 inputRoot;\r\n    bytes32 inputNullifierHash;\r\n    bytes32 outputRoot;\r\n    uint256 outputPathIndices;\r\n    bytes32 outputCommitment;\r\n  }\r\n\r\n  struct RewardExtData {\r\n    address relayer;\r\n    bytes encryptedAccount;\r\n  }\r\n\r\n  struct RewardArgs {\r\n    uint256 rate;\r\n    uint256 fee;\r\n    address instance;\r\n    bytes32 rewardNullifier;\r\n    bytes32 extDataHash;\r\n    bytes32 depositRoot;\r\n    bytes32 withdrawalRoot;\r\n    RewardExtData extData;\r\n    AccountUpdate account;\r\n  }\r\n\r\n  struct WithdrawExtData {\r\n    uint256 fee;\r\n    address recipient;\r\n    address relayer;\r\n    bytes encryptedAccount;\r\n  }\r\n\r\n  struct WithdrawArgs {\r\n    uint256 amount;\r\n    bytes32 extDataHash;\r\n    WithdrawExtData extData;\r\n    AccountUpdate account;\r\n  }\r\n\r\n  struct Rate {\r\n    bytes32 instance;\r\n    uint256 value;\r\n  }\r\n\r\n  modifier onlyGovernance() {\r\n    require(msg.sender == governance, \"Only governance can perform this action\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    bytes32 _rewardSwap,\r\n    bytes32 _governance,\r\n    bytes32 _tornadoTrees,\r\n    bytes32[3] memory _verifiers,\r\n    bytes32 _accountRoot,\r\n    Rate[] memory _rates\r\n  ) public {\r\n    rewardSwap = IRewardSwap(resolve(_rewardSwap));\r\n    governance = resolve(_governance);\r\n    tornadoTrees = TornadoTrees(resolve(_tornadoTrees));\r\n\r\n    // insert empty tree root without incrementing accountCount counter\r\n    accountRoots[0] = _accountRoot;\r\n\r\n    _setRates(_rates);\r\n    // prettier-ignore\r\n    _setVerifiers([\r\n      IVerifier(resolve(_verifiers[0])),\r\n      IVerifier(resolve(_verifiers[1])),\r\n      IVerifier(resolve(_verifiers[2]))\r\n    ]);\r\n  }\r\n\r\n  function reward(bytes memory _proof, RewardArgs memory _args) public {\r\n    reward(_proof, _args, new bytes(0), TreeUpdateArgs(0, 0, 0, 0));\r\n  }\r\n\r\n  function batchReward(bytes[] calldata _rewardArgs) external {\r\n    for (uint256 i = 0; i < _rewardArgs.length; i++) {\r\n      (bytes memory proof, RewardArgs memory args) = abi.decode(_rewardArgs[i], (bytes, RewardArgs));\r\n      reward(proof, args);\r\n    }\r\n  }\r\n\r\n  function reward(\r\n    bytes memory _proof,\r\n    RewardArgs memory _args,\r\n    bytes memory _treeUpdateProof,\r\n    TreeUpdateArgs memory _treeUpdateArgs\r\n  ) public {\r\n    validateAccountUpdate(_args.account, _treeUpdateProof, _treeUpdateArgs);\r\n    tornadoTrees.validateRoots(_args.depositRoot, _args.withdrawalRoot);\r\n    require(_args.extDataHash == keccak248(abi.encode(_args.extData)), \"Incorrect external data hash\");\r\n    require(_args.fee < 2**248, \"Fee value out of range\");\r\n    require(_args.rate == rates[_args.instance] && _args.rate > 0, \"Invalid reward rate\");\r\n    require(!rewardNullifiers[_args.rewardNullifier], \"Reward has been already spent\");\r\n    require(\r\n      rewardVerifier.verifyProof(\r\n        _proof,\r\n        [\r\n          uint256(_args.rate),\r\n          uint256(_args.fee),\r\n          uint256(_args.instance),\r\n          uint256(_args.rewardNullifier),\r\n          uint256(_args.extDataHash),\r\n          uint256(_args.account.inputRoot),\r\n          uint256(_args.account.inputNullifierHash),\r\n          uint256(_args.account.outputRoot),\r\n          uint256(_args.account.outputPathIndices),\r\n          uint256(_args.account.outputCommitment),\r\n          uint256(_args.depositRoot),\r\n          uint256(_args.withdrawalRoot)\r\n        ]\r\n      ),\r\n      \"Invalid reward proof\"\r\n    );\r\n\r\n    accountNullifiers[_args.account.inputNullifierHash] = true;\r\n    rewardNullifiers[_args.rewardNullifier] = true;\r\n    insertAccountRoot(_args.account.inputRoot == getLastAccountRoot() ? _args.account.outputRoot : _treeUpdateArgs.newRoot);\r\n    if (_args.fee > 0) {\r\n      rewardSwap.swap(_args.extData.relayer, _args.fee);\r\n    }\r\n\r\n    emit NewAccount(\r\n      _args.account.outputCommitment,\r\n      _args.account.inputNullifierHash,\r\n      _args.extData.encryptedAccount,\r\n      accountCount - 1\r\n    );\r\n  }\r\n\r\n  function withdraw(bytes memory _proof, WithdrawArgs memory _args) public {\r\n    withdraw(_proof, _args, new bytes(0), TreeUpdateArgs(0, 0, 0, 0));\r\n  }\r\n\r\n  function withdraw(\r\n    bytes memory _proof,\r\n    WithdrawArgs memory _args,\r\n    bytes memory _treeUpdateProof,\r\n    TreeUpdateArgs memory _treeUpdateArgs\r\n  ) public {\r\n    validateAccountUpdate(_args.account, _treeUpdateProof, _treeUpdateArgs);\r\n    require(_args.extDataHash == keccak248(abi.encode(_args.extData)), \"Incorrect external data hash\");\r\n    require(_args.amount < 2**248, \"Amount value out of range\");\r\n    require(\r\n      withdrawVerifier.verifyProof(\r\n        _proof,\r\n        [\r\n          uint256(_args.amount),\r\n          uint256(_args.extDataHash),\r\n          uint256(_args.account.inputRoot),\r\n          uint256(_args.account.inputNullifierHash),\r\n          uint256(_args.account.outputRoot),\r\n          uint256(_args.account.outputPathIndices),\r\n          uint256(_args.account.outputCommitment)\r\n        ]\r\n      ),\r\n      \"Invalid withdrawal proof\"\r\n    );\r\n\r\n    insertAccountRoot(_args.account.inputRoot == getLastAccountRoot() ? _args.account.outputRoot : _treeUpdateArgs.newRoot);\r\n    accountNullifiers[_args.account.inputNullifierHash] = true;\r\n    // allow submitting noop withdrawals (amount == 0)\r\n    uint256 amount = _args.amount.sub(_args.extData.fee, \"Amount should be greater than fee\");\r\n    if (amount > 0) {\r\n      rewardSwap.swap(_args.extData.recipient, amount);\r\n    }\r\n    // Note. The relayer swap rate always will be worse than estimated\r\n    if (_args.extData.fee > 0) {\r\n      rewardSwap.swap(_args.extData.relayer, _args.extData.fee);\r\n    }\r\n\r\n    emit NewAccount(\r\n      _args.account.outputCommitment,\r\n      _args.account.inputNullifierHash,\r\n      _args.extData.encryptedAccount,\r\n      accountCount - 1\r\n    );\r\n  }\r\n\r\n  function setRates(Rate[] memory _rates) external onlyGovernance {\r\n    _setRates(_rates);\r\n  }\r\n\r\n  function setVerifiers(IVerifier[3] calldata _verifiers) external onlyGovernance {\r\n    _setVerifiers(_verifiers);\r\n  }\r\n\r\n  function setTornadoTreesContract(TornadoTrees _tornadoTrees) external onlyGovernance {\r\n    tornadoTrees = _tornadoTrees;\r\n  }\r\n\r\n  function setPoolWeight(uint256 _newWeight) external onlyGovernance {\r\n    rewardSwap.setPoolWeight(_newWeight);\r\n  }\r\n\r\n  // ------VIEW-------\r\n\r\n  /**\r\n    @dev Whether the root is present in the root history\r\n    */\r\n  function isKnownAccountRoot(bytes32 _root, uint256 _index) public view returns (bool) {\r\n    return _root != 0 && accountRoots[_index % ACCOUNT_ROOT_HISTORY_SIZE] == _root;\r\n  }\r\n\r\n  /**\r\n    @dev Returns the last root\r\n    */\r\n  function getLastAccountRoot() public view returns (bytes32) {\r\n    return accountRoots[accountCount % ACCOUNT_ROOT_HISTORY_SIZE];\r\n  }\r\n\r\n  // -----INTERNAL-------\r\n\r\n  function keccak248(bytes memory _data) internal pure returns (bytes32) {\r\n    return keccak256(_data) & 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n  }\r\n\r\n  function validateTreeUpdate(\r\n    bytes memory _proof,\r\n    TreeUpdateArgs memory _args,\r\n    bytes32 _commitment\r\n  ) internal view {\r\n    require(_proof.length > 0, \"Outdated account merkle root\");\r\n    require(_args.oldRoot == getLastAccountRoot(), \"Outdated tree update merkle root\");\r\n    require(_args.leaf == _commitment, \"Incorrect commitment inserted\");\r\n    require(_args.pathIndices == accountCount, \"Incorrect account insert index\");\r\n    require(\r\n      treeUpdateVerifier.verifyProof(\r\n        _proof,\r\n        [uint256(_args.oldRoot), uint256(_args.newRoot), uint256(_args.leaf), uint256(_args.pathIndices)]\r\n      ),\r\n      \"Invalid tree update proof\"\r\n    );\r\n  }\r\n\r\n  function validateAccountUpdate(\r\n    AccountUpdate memory _account,\r\n    bytes memory _treeUpdateProof,\r\n    TreeUpdateArgs memory _treeUpdateArgs\r\n  ) internal view {\r\n    require(!accountNullifiers[_account.inputNullifierHash], \"Outdated account state\");\r\n    if (_account.inputRoot != getLastAccountRoot()) {\r\n      // _account.outputPathIndices (= last tree leaf index) is always equal to root index in the history mapping\r\n      // because we always generate a new root for each new leaf\r\n      require(isKnownAccountRoot(_account.inputRoot, _account.outputPathIndices), \"Invalid account root\");\r\n      validateTreeUpdate(_treeUpdateProof, _treeUpdateArgs, _account.outputCommitment);\r\n    } else {\r\n      require(_account.outputPathIndices == accountCount, \"Incorrect account insert index\");\r\n    }\r\n  }\r\n\r\n  function insertAccountRoot(bytes32 _root) internal {\r\n    accountRoots[++accountCount % ACCOUNT_ROOT_HISTORY_SIZE] = _root;\r\n  }\r\n\r\n  function _setRates(Rate[] memory _rates) internal {\r\n    for (uint256 i = 0; i < _rates.length; i++) {\r\n      require(_rates[i].value < 2**128, \"Incorrect rate\");\r\n      address instance = resolve(_rates[i].instance);\r\n      rates[instance] = _rates[i].value;\r\n      emit RateChanged(instance, _rates[i].value);\r\n    }\r\n  }\r\n\r\n  function _setVerifiers(IVerifier[3] memory _verifiers) internal {\r\n    rewardVerifier = _verifiers[0];\r\n    withdrawVerifier = _verifiers[1];\r\n    treeUpdateVerifier = _verifiers[2];\r\n    emit VerifiersUpdated(address(_verifiers[0]), address(_verifiers[1]), address(_verifiers[2]));\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rewardSwap\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_governance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_tornadoTrees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[3]\",\"name\":\"_verifiers\",\"type\":\"bytes32[3]\"},{\"internalType\":\"bytes32\",\"name\":\"_accountRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"instance\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Miner.Rate[]\",\"name\":\"_rates\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nullifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encryptedAccount\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"NewAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdraw\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treeUpdate\",\"type\":\"address\"}],\"name\":\"VerifiersUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACCOUNT_ROOT_HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accountCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"accountNullifiers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_rewardArgs\",\"type\":\"bytes[]\"}],\"name\":\"batchReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"domains\",\"type\":\"bytes32[]\"}],\"name\":\"bulkResolve\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastAccountRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"isKnownAccountRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rewardNullifier\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"extDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"depositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawalRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encryptedAccount\",\"type\":\"bytes\"}],\"internalType\":\"struct Miner.RewardExtData\",\"name\":\"extData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"inputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputNullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"outputPathIndices\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"outputCommitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Miner.AccountUpdate\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Miner.RewardArgs\",\"name\":\"_args\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_treeUpdateProof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"oldRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"pathIndices\",\"type\":\"uint256\"}],\"internalType\":\"struct Miner.TreeUpdateArgs\",\"name\":\"_treeUpdateArgs\",\"type\":\"tuple\"}],\"name\":\"reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rewardNullifier\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"extDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"depositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawalRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encryptedAccount\",\"type\":\"bytes\"}],\"internalType\":\"struct Miner.RewardExtData\",\"name\":\"extData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"inputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputNullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"outputPathIndices\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"outputCommitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Miner.AccountUpdate\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Miner.RewardArgs\",\"name\":\"_args\",\"type\":\"tuple\"}],\"name\":\"reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"rewardNullifiers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardSwap\",\"outputs\":[{\"internalType\":\"contract IRewardSwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardVerifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newWeight\",\"type\":\"uint256\"}],\"name\":\"setPoolWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"instance\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Miner.Rate[]\",\"name\":\"_rates\",\"type\":\"tuple[]\"}],\"name\":\"setRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TornadoTrees\",\"name\":\"_tornadoTrees\",\"type\":\"address\"}],\"name\":\"setTornadoTreesContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVerifier[3]\",\"name\":\"_verifiers\",\"type\":\"address[3]\"}],\"name\":\"setVerifiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tornadoTrees\",\"outputs\":[{\"internalType\":\"contract TornadoTrees\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeUpdateVerifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extDataHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encryptedAccount\",\"type\":\"bytes\"}],\"internalType\":\"struct Miner.WithdrawExtData\",\"name\":\"extData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"inputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputNullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"outputPathIndices\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"outputCommitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Miner.AccountUpdate\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Miner.WithdrawArgs\",\"name\":\"_args\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extDataHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encryptedAccount\",\"type\":\"bytes\"}],\"internalType\":\"struct Miner.WithdrawExtData\",\"name\":\"extData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"inputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputNullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"outputPathIndices\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"outputCommitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Miner.AccountUpdate\",\"name\":\"account\",\"type\":\"tuple\"}],\"internalType\":\"struct Miner.WithdrawArgs\",\"name\":\"_args\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_treeUpdateProof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"oldRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"pathIndices\",\"type\":\"uint256\"}],\"internalType\":\"struct Miner.TreeUpdateArgs\",\"name\":\"_treeUpdateArgs\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawVerifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Miner","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"f06c24d1d0c5da2628caf6a7912f231ca834476d6c3505f1fb8e5926ab7f9ba594d63e9067c3ab2d966702f604484c43b5ea247ecd08c28762caa50df5dc02bdf364752a68271f46f4a51f0ccd3ecaf066404a7a1cdfc0687e213360662586306016a87815201af7399a07a43aab1af334e85c9fe43aa35026012cde9b5d23fba6a8f1f25e21baffc58dcecb043a994f9e940ec8971a903e48518609e3ade2f53ebe6d0e58fe1b929d4482eac2a7b7e760d1863a0cad5a84ab2c5d48b8ce171b29f9a0a07a22ab214d00aaa0190f54509e853f3119009baecb0035347606b0a900000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000004c041982b4f77cbbd82ef3b9ea748738ac6c281d3f1af198770d29f75ac32d80a000000000000000000000000000000000000000000000000000000000000000a9e5bc9215eecd103644145a5db4f69d5efaf4885bb5bf968f8db271ec5cd539b0000000000000000000000000000000000000000000000000000000000000014917e42347647689051abc744f502bff342c76ad30c0670b46b305b2f7e1f893d0000000000000000000000000000000000000000000000000000000000000032ddfc726d74f912f49389ef7471e75291969852ce7e5df0509a17bc1e466469850000000000000000000000000000000000000000000000000000000000000190","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1ce4490a9602839876fe9668dd0d550aac3b551bf27150c591e321ac21daf4cc"}]}