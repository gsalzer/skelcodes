{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/collateralSplits/ICollateralSplit.sol\r\n\r\npragma solidity >=0.4.21 <0.7.0;\r\n\r\n/// @title Collateral Split interface\r\n/// @notice Contains mathematical functions used to calculate relative claim\r\n/// on collateral of primary and complement assets after settlement.\r\n/// @dev Created independently from specification and published to the CollateralSplitRegistry\r\ninterface ICollateralSplit {\r\n\r\n    /// @notice Proof of collateral split contract\r\n    /// @dev Verifies that contract is a collateral split contract\r\n    /// @return true if contract is a collateral split contract\r\n    function isCollateralSplit() external pure returns(bool);\r\n\r\n    /// @notice Symbol of the collateral split\r\n    /// @dev Should be resolved through CollateralSplitRegistry contract\r\n    /// @return collateral split specification symbol\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Calcs primary asset class' share of collateral at settlement.\r\n    /// @dev Returns ranged value between 0 and 1 multiplied by 10 ^ 12\r\n    /// @param _underlyingStartRoundHints specify for each oracle round of the start of Live period\r\n    /// @param _underlyingEndRoundHints specify for each oracle round of the end of Live period\r\n    /// @return _split primary asset class' share of collateral at settlement\r\n    /// @return _underlyingStarts underlying values in the start of Live period\r\n    /// @return _underlyingEnds underlying values in the end of Live period\r\n    function split(\r\n        address[] memory _oracles,\r\n        address[] memory _oracleIterators,\r\n        uint _liveTime,\r\n        uint _settleTime,\r\n        uint[] memory _underlyingStartRoundHints,\r\n        uint[] memory _underlyingEndRoundHints)\r\n    external view returns(uint _split, int[] memory _underlyingStarts, int[] memory _underlyingEnds);\r\n}\r\n\r\n// File: contracts/oracleIterators/IOracleIterator.sol\r\n\r\npragma solidity >=0.4.21 <0.7.0;\r\n\r\ninterface IOracleIterator {\r\n    /// @notice Proof of oracle iterator contract\r\n    /// @dev Verifies that contract is a oracle iterator contract\r\n    /// @return true if contract is a oracle iterator contract\r\n    function isOracleIterator() external pure returns(bool);\r\n\r\n    /// @notice Symbol of the oracle iterator\r\n    /// @dev Should be resolved through OracleIteratorRegistry contract\r\n    /// @return oracle iterator symbol\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\r\n    //  finds the value closest to a given timestamp\r\n    /// @param _oracle iteratable oracle through\r\n    /// @param _timestamp a given timestamp\r\n    /// @param _roundHints specified rounds for a given timestamp\r\n    /// @return the value closest to a given timestamp\r\n    function getUnderlingValue(address _oracle, uint _timestamp, uint[] memory _roundHints) external view returns(int);\r\n}\r\n\r\n// File: contracts/collateralSplits/CollateralSplitParent.sol\r\n\r\npragma solidity >=0.4.21 <0.7.0;\r\n\r\n\r\n\r\nabstract contract CollateralSplitParent is ICollateralSplit {\r\n    int public constant FRACTION_MULTIPLIER = 10**12;\r\n    int public constant NEGATIVE_INFINITY = type(int256).min;\r\n\r\n    function isCollateralSplit() external override pure returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    function split(\r\n        address[] memory _oracles,\r\n        address[] memory _oracleIterators,\r\n        uint _liveTime,\r\n        uint _settleTime,\r\n        uint[] memory _underlyingStartRoundHints,\r\n        uint[] memory _underlyingEndRoundHints)\r\n    external override virtual view returns(uint _split, int[] memory _underlyingStarts, int[] memory _underlyingEnds) {\r\n        require(_oracles.length == 1, \"More than one oracle\");\r\n        require(_oracles[0] != address(0), \"Oracle is empty\");\r\n        require(_oracleIterators[0] != address(0), \"Oracle iterator is empty\");\r\n\r\n        _underlyingStarts = new int[](1);\r\n        _underlyingEnds = new int[](1);\r\n\r\n        IOracleIterator iterator = IOracleIterator(_oracleIterators[0]);\r\n        require(iterator.isOracleIterator(), \"Not oracle iterator\");\r\n\r\n        _underlyingStarts[0] = iterator.getUnderlingValue(_oracles[0], _liveTime, _underlyingStartRoundHints);\r\n        _underlyingEnds[0] = iterator.getUnderlingValue(_oracles[0], _settleTime, _underlyingEndRoundHints);\r\n\r\n        _split = range(\r\n            splitNominalValue(\r\n                normalize( _underlyingStarts[0], _underlyingEnds[0] )\r\n            )\r\n        );\r\n    }\r\n\r\n    function splitNominalValue(int _normalizedValue) public virtual pure returns(int);\r\n\r\n    function normalize(int _u_0, int _u_T) public virtual pure returns(int){\r\n        require(_u_0 != NEGATIVE_INFINITY, \"u_0 is absent\");\r\n        require(_u_T != NEGATIVE_INFINITY, \"u_T is absent\");\r\n        require(_u_0 > 0, \"u_0 is less or equal zero\");\r\n\r\n        if(_u_T < 0) {\r\n            _u_T = 0;\r\n        }\r\n\r\n        return (_u_T - _u_0) * FRACTION_MULTIPLIER / _u_0;\r\n    }\r\n\r\n    function range(int _split) public pure returns(uint) {\r\n        if(_split >= FRACTION_MULTIPLIER) {\r\n            return uint(FRACTION_MULTIPLIER);\r\n        }\r\n        if(_split <= 0) {\r\n            return 0;\r\n        }\r\n        return uint(_split);\r\n    }\r\n}\r\n\r\n// File: contracts/collateralSplits/CallOptionSplit.sol\r\n\r\n// \"SPDX-License-Identifier: GNU General Public License v3.0\"\r\n\r\npragma solidity >=0.4.21 <0.7.0;\r\n\r\n\r\ncontract CallOptionSplit is CollateralSplitParent{\r\n\r\n    function symbol() external override view returns (string memory) {\r\n        return 'CallOption';\r\n    }\r\n\r\n    function splitNominalValue(int _normalizedValue) public override pure returns(int){\r\n        if(_normalizedValue < 0) { // < 0\r\n            return 0; // 0%\r\n        }\r\n\r\n        if(_normalizedValue >= 0) { // >= 0\r\n            return FRACTION_MULTIPLIER * _normalizedValue / (FRACTION_MULTIPLIER + _normalizedValue );  // U/(1+U)\r\n        }\r\n        return 0;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"FRACTION_MULTIPLIER\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NEGATIVE_INFINITY\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCollateralSplit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_u_0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_u_T\",\"type\":\"int256\"}],\"name\":\"normalize\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_split\",\"type\":\"int256\"}],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_oracleIterators\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_liveTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingStartRoundHints\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"split\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_split\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"_underlyingStarts\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_underlyingEnds\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_normalizedValue\",\"type\":\"int256\"}],\"name\":\"splitNominalValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CallOptionSplit","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4539b1db7fcd9621b4a6571396f704c7719c6584f57e2fcc4243c4e4b7a990cd"}]}