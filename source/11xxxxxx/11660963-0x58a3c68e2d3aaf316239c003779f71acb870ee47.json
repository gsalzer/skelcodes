{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.8\r\n\"\"\"\r\n@title Curve SynthSwap\r\n@author Curve.fi\r\n@license MIT\r\n@notice Allows cross-asset swaps via Curve and Synthetix\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nfrom vyper.interfaces import ERC721\r\n\r\nimplements: ERC721\r\n\r\n\r\ninterface AddressProvider:\r\n    def get_registry() -> address: view\r\n    def get_address(_id: uint256) -> address: view\r\n\r\ninterface Curve:\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: view\r\n\r\ninterface Registry:\r\n    def get_coins(_pool: address) -> address[8]: view\r\n    def get_coin_indices(pool: address, _from: address, _to: address) -> (int128, int128): view\r\n\r\ninterface RegistrySwap:\r\n    def exchange(\r\n        _pool: address,\r\n        _from: address,\r\n        _to: address,\r\n        _amount: uint256,\r\n        _expected: uint256,\r\n        _receiver: address,\r\n    ) -> uint256: payable\r\n\r\ninterface SNXAddressResolver:\r\n    def getAddress(name: bytes32) -> address: view\r\n\r\ninterface Synth:\r\n    def currencyKey() -> bytes32: nonpayable\r\n\r\ninterface Exchanger:\r\n    def getAmountsForExchange(\r\n        sourceAmount: uint256,\r\n        sourceCurrencyKey: bytes32,\r\n        destinationCurrencyKey: bytes32\r\n    ) -> (uint256, uint256, uint256): view\r\n    def maxSecsLeftInWaitingPeriod(account: address, currencyKey: bytes32) -> uint256: view\r\n    def settlementOwing(account: address, currencyKey: bytes32) -> (uint256, uint256): view\r\n    def settle(user: address, currencyKey: bytes32): nonpayable\r\n\r\ninterface Settler:\r\n    def initialize(): nonpayable\r\n    def synth() -> address: view\r\n    def time_to_settle() -> uint256: view\r\n    def convert_synth(\r\n        _target: address,\r\n        _amount: uint256,\r\n        _source_key: bytes32,\r\n        _dest_key: bytes32\r\n    ) -> bool: nonpayable\r\n    def exchange(\r\n        _target: address,\r\n        _pool: address,\r\n        _amount: uint256,\r\n        _expected: uint256,\r\n        _receiver: address,\r\n    ) -> uint256: nonpayable\r\n    def withdraw(_receiver: address, _amount: uint256) -> uint256: nonpayable\r\n\r\ninterface ERC721Receiver:\r\n    def onERC721Received(\r\n            _operator: address,\r\n            _from: address,\r\n            _token_id: uint256,\r\n            _data: Bytes[1024]\r\n        ) -> bytes32: view\r\n\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    token_id: indexed(uint256)\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    approved: indexed(address)\r\n    token_id: indexed(uint256)\r\n\r\nevent ApprovalForAll:\r\n    owner: indexed(address)\r\n    operator: indexed(address)\r\n    approved: bool\r\n\r\nevent NewSettler:\r\n    addr: address\r\n\r\nevent NewSynth:\r\n    synth: address\r\n    pool: address\r\n\r\nevent TokenUpdate:\r\n    token_id: indexed(uint256)\r\n    owner: indexed(address)\r\n    synth: indexed(address)\r\n    underlying_balance: uint256\r\n\r\n\r\nstruct TokenInfo:\r\n    owner: address\r\n    synth: address\r\n    underlying_balance: uint256\r\n    time_to_settle: uint256\r\n\r\n\r\nADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\r\n\r\nSNX_ADDRESS_RESOLVER: constant(address) = 0x4E3b31eB0E5CB73641EE1E65E7dCEFe520bA3ef2\r\nEXCHANGER_KEY: constant(bytes32) = 0x45786368616e6765720000000000000000000000000000000000000000000000\r\n\r\n# token id -> owner\r\nid_to_owner: HashMap[uint256, address]\r\n# token id -> address approved to transfer this nft\r\nid_to_approval: HashMap[uint256, address]\r\n# owner -> number of nfts\r\nowner_to_token_count: HashMap[address, uint256]\r\n# owner -> operator -> is approved?\r\nowner_to_operators: HashMap[address, HashMap[address, bool]]\r\n\r\n# implementation contract used for `Settler` proxies\r\nsettler_implementation: address\r\n\r\n# list of available token IDs\r\n# each token ID has an associated `Settler` contract, and to reduce\r\n# gas costs these contracts are reused. Each token ID is created from\r\n# [12 byte nonce][20 byte settler address]. The nonce starts at 0 and is\r\n# incremented each time the token ID is \"freed\" (added to `available_token_ids`)\r\navailable_token_ids: uint256[4294967296]\r\nid_count: uint256\r\n\r\n# synth -> curve pool where it can be traded\r\nsynth_pools: public(HashMap[address, address])\r\n# coin -> synth that it can be swapped for\r\nswappable_synth: public(HashMap[address, address])\r\n# token id -> is synth settled?\r\nis_settled: public(HashMap[uint256, bool])\r\n# coin -> spender -> is approved to transfer from this contract?\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n# synth -> currency key\r\ncurrency_keys: HashMap[address, bytes32]\r\n\r\n# Synthetix exchanger contract\r\nexchanger: Exchanger\r\n\r\n\r\n@external\r\ndef __init__(_settler_implementation: address, _settler_count: uint256):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _settler_implementation `Settler` implementation deployment\r\n    \"\"\"\r\n    self.settler_implementation = _settler_implementation\r\n    self.exchanger = Exchanger(SNXAddressResolver(SNX_ADDRESS_RESOLVER).getAddress(EXCHANGER_KEY))\r\n\r\n    # deploy settler contracts immediately\r\n    self.id_count = _settler_count\r\n    for i in range(100):\r\n        if i == _settler_count:\r\n            break\r\n        settler: address = create_forwarder_to(_settler_implementation)\r\n        Settler(settler).initialize()\r\n        self.available_token_ids[i] = convert(settler, uint256)\r\n        log NewSettler(settler)\r\n\r\n\r\n@view\r\n@external\r\ndef name() -> String[15]:\r\n    return \"Curve SynthSwap\"\r\n\r\n\r\n@view\r\n@external\r\ndef symbol() -> String[6]:\r\n    return \"CRV/SS\"\r\n\r\n\r\n@view\r\n@external\r\ndef supportsInterface(_interface_id: bytes32) -> bool:\r\n    \"\"\"\r\n    @dev Interface identification is specified in ERC-165\r\n    @param _interface_id Id of the interface\r\n    @return bool Is interface supported?\r\n    \"\"\"\r\n    return _interface_id in [\r\n        0x0000000000000000000000000000000000000000000000000000000001ffc9a7,  # ERC165\r\n        0x0000000000000000000000000000000000000000000000000000000080ac58cd,  # ERC721\r\n    ]\r\n\r\n\r\n@view\r\n@external\r\ndef balanceOf(_owner: address) -> uint256:\r\n    \"\"\"\r\n    @notice Return the number of NFTs owned by `_owner`\r\n    @dev Reverts if `_owner` is the zero address. NFTs assigned\r\n         to the zero address are considered invalid\r\n    @param _owner Address for whom to query the balance\r\n    @return uint256 Number of NFTs owned by `_owner`\r\n    \"\"\"\r\n    assert _owner != ZERO_ADDRESS\r\n    return self.owner_to_token_count[_owner]\r\n\r\n\r\n@view\r\n@external\r\ndef ownerOf(_token_id: uint256) -> address:\r\n    \"\"\"\r\n    @notice Return the address of the owner of the NFT\r\n    @dev Reverts if `_token_id` is not a valid NFT\r\n    @param _token_id The identifier for an NFT\r\n    @return address NFT owner\r\n    \"\"\"\r\n    owner: address = self.id_to_owner[_token_id]\r\n    assert owner != ZERO_ADDRESS\r\n    return owner\r\n\r\n\r\n@view\r\n@external\r\ndef getApproved(_token_id: uint256) -> address:\r\n    \"\"\"\r\n    @notice Get the approved address for a single NFT\r\n    @dev Reverts if `_token_id` is not a valid NFT\r\n    @param _token_id ID of the NFT to query the approval of\r\n    @return address Address approved to transfer this NFT\r\n    \"\"\"\r\n    assert self.id_to_owner[_token_id] != ZERO_ADDRESS\r\n    return self.id_to_approval[_token_id]\r\n\r\n\r\n@view\r\n@external\r\ndef isApprovedForAll(_owner: address, _operator: address) -> bool:\r\n    \"\"\"\r\n    @notice Check if `_operator` is an approved operator for `_owner`\r\n    @param _owner The address that owns the NFTs\r\n    @param _operator The address that acts on behalf of the owner\r\n    @return bool Is operator approved?\r\n    \"\"\"\r\n    return self.owner_to_operators[_owner][_operator]\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _token_id: uint256, _caller: address):\r\n    assert _from != ZERO_ADDRESS, \"Cannot send from zero address\"\r\n    assert _to != ZERO_ADDRESS, \"Cannot send to zero address\"\r\n    owner: address = self.id_to_owner[_token_id]\r\n    assert owner == _from, \"Incorrect owner for Token ID\"\r\n\r\n    approved_for: address = self.id_to_approval[_token_id]\r\n    if _caller != _from:\r\n        assert approved_for == _caller or self.owner_to_operators[owner][_caller], \"Caller is not owner or operator\"\r\n\r\n    if approved_for != ZERO_ADDRESS:\r\n        self.id_to_approval[_token_id] = ZERO_ADDRESS\r\n\r\n    self.id_to_owner[_token_id] = _to\r\n    self.owner_to_token_count[_from] -= 1\r\n    self.owner_to_token_count[_to] += 1\r\n\r\n    log Transfer(_from, _to, _token_id)\r\n\r\n\r\n@external\r\ndef transferFrom(_from: address, _to: address, _token_id: uint256):\r\n    \"\"\"\r\n    @notice Transfer ownership of `_token_id` from `_from` to `_to`\r\n    @dev Reverts unless `msg.sender` is the current owner, an\r\n         authorized operator, or the approved address for `_token_id`\r\n         Reverts if `_to` is the zero address\r\n    @param _from The current owner of `_token_id`\r\n    @param _to Address to transfer the NFT to\r\n    @param _token_id ID of the NFT to transfer\r\n    \"\"\"\r\n    self._transfer(_from, _to, _token_id, msg.sender)\r\n\r\n\r\n@external\r\ndef safeTransferFrom(\r\n    _from: address,\r\n    _to: address,\r\n    _token_id: uint256,\r\n    _data: Bytes[1024]=b\"\"\r\n):\r\n    \"\"\"\r\n    @notice Transfer ownership of `_token_id` from `_from` to `_to`\r\n    @dev If `_to` is a smart contract, it must implement the `onERC721Received` function\r\n         and return the value `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    @param _from The current owner of `_token_id`\r\n    @param _to Address to transfer the NFT to\r\n    @param _token_id ID of the NFT to transfer\r\n    @param _data Additional data with no specified format, sent in call to `_to`\r\n    \"\"\"\r\n    self._transfer(_from, _to, _token_id, msg.sender)\r\n\r\n    if _to.is_contract:\r\n        response: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _token_id, _data)\r\n        assert response == 0x150b7a0200000000000000000000000000000000000000000000000000000000\r\n\r\n\r\n@external\r\ndef approve(_approved: address, _token_id: uint256):\r\n    \"\"\"\r\n    @notice Set or reaffirm the approved address for an NFT.\r\n            The zero address indicates there is no approved address.\r\n    @dev Reverts unless `msg.sender` is the current NFT owner, or an authorized\r\n         operator of the current owner. Reverts if `_token_id` is not a valid NFT.\r\n    @param _approved Address to be approved for the given NFT ID\r\n    @param _token_id ID of the token to be approved\r\n    \"\"\"\r\n    owner: address = self.id_to_owner[_token_id]\r\n\r\n    if msg.sender != self.id_to_owner[_token_id]:\r\n        assert owner != ZERO_ADDRESS, \"Unknown Token ID\"\r\n        assert self.owner_to_operators[owner][msg.sender], \"Caller is not owner or operator\"\r\n\r\n    self.id_to_approval[_token_id] = _approved\r\n    log Approval(owner, _approved, _token_id)\r\n\r\n\r\n@external\r\ndef setApprovalForAll(_operator: address, _approved: bool):\r\n    \"\"\"\r\n    @notice Enable or disable approval for a third party (\"operator\") to manage all\r\n         NFTs owned by `msg.sender`.\r\n    @param _operator Address to set operator authorization for.\r\n    @param _approved True if the operators is approved, False to revoke approval.\r\n    \"\"\"\r\n    self.owner_to_operators[msg.sender][_operator] = _approved\r\n    log ApprovalForAll(msg.sender, _operator, _approved)\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_swap_into(_from: address, _synth: address, _amount: uint256) -> uint256:\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n\r\n    intermediate_synth: address = self.swappable_synth[_from]\r\n    pool: address = self.synth_pools[intermediate_synth]\r\n\r\n    synth_amount: uint256 = _amount\r\n    if _from != intermediate_synth:\r\n        i: int128 = 0\r\n        j: int128 = 0\r\n        i, j = Registry(registry).get_coin_indices(pool, _from, intermediate_synth)\r\n\r\n        synth_amount = Curve(pool).get_dy(i, j, _amount)\r\n\r\n    return self.exchanger.getAmountsForExchange(\r\n        synth_amount,\r\n        self.currency_keys[intermediate_synth],\r\n        self.currency_keys[_synth],\r\n    )[0]\r\n\r\n\r\n@view\r\n@external\r\ndef get_swap_into_synth_amount(_from: address, _synth: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Return the amount received when performing a cross-asset swap\r\n    @dev Used to calculate `_expected` when calling `swap_into_synth`. Be sure to\r\n         reduce the value slightly to account for market movement prior to the\r\n         transaction confirmation.\r\n    @param _from Address of the initial asset being exchanged\r\n    @param _synth Address of the synth being swapped into\r\n    @param _amount Amount of `_from` to swap\r\n    @return uint256 Expected amount of `_synth` received\r\n    \"\"\"\r\n    return self._get_swap_into(_from, _synth, _amount)\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_swap_from(_synth: address, _to: address, _amount: uint256) -> uint256:\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n    pool: address = self.synth_pools[_synth]\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    i, j = Registry(registry).get_coin_indices(pool, _synth, _to)\r\n\r\n    return Curve(pool).get_dy(i, j, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_swap_from_synth_amount(_synth: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Return the amount received when swapping out of a settled synth\r\n    @dev Used to calculate `_expected` when calling `swap_from_synth`. Be sure to\r\n         reduce the value slightly to account for market movement prior to the\r\n         transaction confirmation.\r\n    @param _synth Address of the synth being swapped out of\r\n    @param _to Address of the asset to swap into\r\n    @param _amount Amount of `_synth` being exchanged\r\n    @return uint256 Expected amount of `_to` received\r\n    \"\"\"\r\n    return self._get_swap_from(_synth, _to, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_estimated_swap_amount(_from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate the final amount received when swapping between `_from` and `_to`\r\n    @dev Actual received amount may be different if synth rates change during settlement\r\n    @param _from Address of the initial asset being exchanged\r\n    @param _to Address of the asset to swap into\r\n    @param _amount Amount of `_from` being exchanged\r\n    @return uint256 Estimated amount of `_to` received\r\n    \"\"\"\r\n    synth: address = self.swappable_synth[_to]\r\n    synth_amount: uint256 = self._get_swap_into(_from, synth, _amount)\r\n    return self._get_swap_from(synth, _to, synth_amount)\r\n\r\n\r\n@view\r\n@external\r\ndef token_info(_token_id: uint256) -> TokenInfo:\r\n    \"\"\"\r\n    @notice Get information about the synth represented by an NFT\r\n    @param _token_id NFT token ID to query info about\r\n    @return NFT owner\r\n            Address of synth within the NFT\r\n            Balance of the synth\r\n            Max settlement time in seconds\r\n    \"\"\"\r\n    info: TokenInfo = empty(TokenInfo)\r\n    info.owner = self.id_to_owner[_token_id]\r\n    assert info.owner != ZERO_ADDRESS\r\n\r\n    settler: address = convert(_token_id % (2**160), address)\r\n    info.synth = Settler(settler).synth()\r\n    info.underlying_balance = ERC20(info.synth).balanceOf(settler)\r\n\r\n    if not self.is_settled[_token_id]:\r\n        currency_key: bytes32 = self.currency_keys[info.synth]\r\n        reclaim: uint256 = 0\r\n        rebate: uint256 = 0\r\n        reclaim, rebate = self.exchanger.settlementOwing(settler, currency_key)\r\n        info.underlying_balance = info.underlying_balance - reclaim + rebate\r\n        info.time_to_settle = self.exchanger.maxSecsLeftInWaitingPeriod(settler, currency_key)\r\n\r\n    return info\r\n\r\n\r\n@payable\r\n@external\r\ndef swap_into_synth(\r\n    _from: address,\r\n    _synth: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n    _existing_token_id: uint256 = 0,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform a cross-asset swap between `_from` and `_synth`\r\n    @dev Synth swaps require a settlement time to complete and so the newly\r\n         generated synth cannot immediately be transferred onward. Calling\r\n         this function mints an NFT which represents ownership of the generated\r\n         synth. Once the settlement time has passed, the owner may claim the\r\n         synth by calling to `swap_from_synth` or `withdraw`.\r\n    @param _from Address of the initial asset being exchanged\r\n    @param _synth Address of the synth being swapped into\r\n    @param _amount Amount of `_from` to swap\r\n    @param _expected Minimum amount of `_synth` to receive\r\n    @param _receiver Address of the recipient of `_synth`, if not given\r\n                       defaults to `msg.sender`\r\n    @param _existing_token_id Token ID to deposit `_synth` into. If left as 0, a new NFT\r\n                       is minted for the generated synth. If non-zero, the token ID\r\n                       must be owned by `msg.sender` and must represent the same\r\n                       synth as is being swapped into.\r\n    @return uint256 NFT token ID\r\n    \"\"\"\r\n    settler: address = ZERO_ADDRESS\r\n    token_id: uint256 = 0\r\n\r\n    if _existing_token_id == 0:\r\n        # if no token ID is given we are initiating a new swap\r\n        count: uint256 = self.id_count\r\n        if count == 0:\r\n            # if there are no availale settler contracts we must deploy a new one\r\n            settler = create_forwarder_to(self.settler_implementation)\r\n            Settler(settler).initialize()\r\n            token_id = convert(settler, uint256)\r\n            log NewSettler(settler)\r\n        else:\r\n            count -= 1\r\n            token_id = self.available_token_ids[count]\r\n            settler = convert(token_id % (2**160), address)\r\n            self.id_count = count\r\n    else:\r\n        # if a token ID is given we are adding to the balance of an existing swap\r\n        # so must check to make sure this is a permitted action\r\n        settler = convert(_existing_token_id % (2**160), address)\r\n        token_id = _existing_token_id\r\n        owner: address = self.id_to_owner[_existing_token_id]\r\n        if msg.sender != owner:\r\n            assert owner != ZERO_ADDRESS, \"Unknown Token ID\"\r\n            assert (\r\n                self.owner_to_operators[owner][msg.sender] or\r\n                msg.sender == self.id_to_approval[_existing_token_id]\r\n            ), \"Caller is not owner or operator\"\r\n        assert owner == _receiver, \"Receiver is not owner\"\r\n        assert Settler(settler).synth() == _synth, \"Incorrect synth for Token ID\"\r\n\r\n    registry_swap: address = AddressProvider(ADDRESS_PROVIDER).get_address(2)\r\n    intermediate_synth: address = self.swappable_synth[_from]\r\n    synth_amount: uint256 = 0\r\n\r\n    if intermediate_synth == _from:\r\n        # if `_from` is already a synth, no initial curve exchange is required\r\n        assert ERC20(_from).transferFrom(msg.sender, settler, _amount)\r\n        synth_amount = _amount\r\n    else:\r\n        if _from != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            # Vyper equivalent of SafeERC20Transfer, handles most ERC20 return values\r\n            response: Bytes[32] = raw_call(\r\n                _from,\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(_amount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n            if not self.is_approved[_from][registry_swap]:\r\n                response = raw_call(\r\n                    _from,\r\n                    concat(\r\n                        method_id(\"approve(address,uint256)\"),\r\n                        convert(registry_swap, bytes32),\r\n                        convert(MAX_UINT256, bytes32),\r\n                    ),\r\n                    max_outsize=32,\r\n                )\r\n                if len(response) != 0:\r\n                    assert convert(response, bool)\r\n                self.is_approved[_from][registry_swap] = True\r\n\r\n        # use Curve to exchange for initial synth, which is sent to the settler\r\n        synth_amount = RegistrySwap(registry_swap).exchange(\r\n            self.synth_pools[intermediate_synth],\r\n            _from,\r\n            intermediate_synth,\r\n            _amount,\r\n            0,\r\n            settler,\r\n            value=msg.value\r\n        )\r\n\r\n    # use Synthetix to convert initial synth into the target synth\r\n    initial_balance: uint256 = ERC20(_synth).balanceOf(settler)\r\n    Settler(settler).convert_synth(\r\n        _synth,\r\n        synth_amount,\r\n        self.currency_keys[intermediate_synth],\r\n        self.currency_keys[_synth]\r\n    )\r\n    final_balance: uint256 = ERC20(_synth).balanceOf(settler)\r\n    assert final_balance - initial_balance >= _expected, \"Rekt by slippage\"\r\n\r\n    # if this is a new swap, mint an NFT to represent the unsettled conversion\r\n    if _existing_token_id == 0:\r\n        self.id_to_owner[token_id] = _receiver\r\n        self.owner_to_token_count[_receiver] += 1\r\n        log Transfer(ZERO_ADDRESS, _receiver, token_id)\r\n\r\n    log TokenUpdate(token_id, _receiver, _synth, final_balance)\r\n\r\n    return token_id\r\n\r\n\r\n@external\r\ndef swap_from_synth(\r\n    _token_id: uint256,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Swap the synth represented by an NFT into another asset.\r\n    @dev Callable by the owner or operator of `_token_id` after the synth settlement\r\n         period has passed. If `_amount` is equal to the entire balance within\r\n         the NFT, the NFT is burned.\r\n    @param _token_id The identifier for an NFT\r\n    @param _to Address of the asset to swap into\r\n    @param _amount Amount of the synth to swap\r\n    @param _expected Minimum amount of `_to` to receive\r\n    @param _receiver Address of the recipient of the synth,\r\n                     if not given defaults to `msg.sender`\r\n    @return uint256 Synth balance remaining in `_token_id`\r\n    \"\"\"\r\n    owner: address = self.id_to_owner[_token_id]\r\n    if msg.sender != self.id_to_owner[_token_id]:\r\n        assert owner != ZERO_ADDRESS, \"Unknown Token ID\"\r\n        assert (\r\n            self.owner_to_operators[owner][msg.sender] or\r\n            msg.sender == self.id_to_approval[_token_id]\r\n        ), \"Caller is not owner or operator\"\r\n\r\n    settler: address = convert(_token_id % (2**160), address)\r\n    synth: address = self.swappable_synth[_to]\r\n    pool: address = self.synth_pools[synth]\r\n\r\n    # ensure the synth is settled prior to swapping\r\n    if not self.is_settled[_token_id]:\r\n        currency_key: bytes32 = self.currency_keys[synth]\r\n        self.exchanger.settle(settler, currency_key)\r\n        self.is_settled[_token_id] = True\r\n\r\n    # use Curve to exchange the synth for another asset which is sent to the receiver\r\n    remaining: uint256 = Settler(settler).exchange(_to, pool, _amount, _expected, _receiver)\r\n\r\n    # if the balance of the synth within the NFT is now zero, burn the NFT\r\n    if remaining == 0:\r\n        self.id_to_owner[_token_id] = ZERO_ADDRESS\r\n        self.id_to_approval[_token_id] = ZERO_ADDRESS\r\n        self.is_settled[_token_id] = False\r\n        self.owner_to_token_count[msg.sender] -= 1\r\n\r\n        count: uint256 = self.id_count\r\n        # add 2**160 to increment the nonce for next time this settler is used\r\n        self.available_token_ids[count] = _token_id + 2**160\r\n        self.id_count = count + 1\r\n\r\n        owner = ZERO_ADDRESS\r\n        synth = ZERO_ADDRESS\r\n        log Transfer(msg.sender, ZERO_ADDRESS, _token_id)\r\n\r\n    log TokenUpdate(_token_id, owner, synth, remaining)\r\n\r\n    return remaining\r\n\r\n\r\n@external\r\ndef withdraw(_token_id: uint256, _amount: uint256, _receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw the synth represented by an NFT.\r\n    @dev Callable by the owner or operator of `_token_id` after the synth settlement\r\n         period has passed. If `_amount` is equal to the entire balance within\r\n         the NFT, the NFT is burned.\r\n    @param _token_id The identifier for an NFT\r\n    @param _amount Amount of the synth to withdraw\r\n    @param _receiver Address of the recipient of the synth,\r\n                     if not given defaults to `msg.sender`\r\n    @return uint256 Synth balance remaining in `_token_id`\r\n    \"\"\"\r\n    owner: address = self.id_to_owner[_token_id]\r\n    if msg.sender != self.id_to_owner[_token_id]:\r\n        assert owner != ZERO_ADDRESS, \"Unknown Token ID\"\r\n        assert (\r\n            self.owner_to_operators[owner][msg.sender] or\r\n            msg.sender == self.id_to_approval[_token_id]\r\n        ), \"Caller is not owner or operator\"\r\n\r\n    settler: address = convert(_token_id % (2**160), address)\r\n    synth: address = Settler(settler).synth()\r\n\r\n    # ensure the synth is settled prior to withdrawal\r\n    if not self.is_settled[_token_id]:\r\n        currency_key: bytes32 = self.currency_keys[synth]\r\n        self.exchanger.settle(settler, currency_key)\r\n        self.is_settled[_token_id] = True\r\n\r\n    remaining: uint256 = Settler(settler).withdraw(_receiver, _amount)\r\n\r\n    # if the balance of the synth within the NFT is now zero, burn the NFT\r\n    if remaining == 0:\r\n        self.id_to_owner[_token_id] = ZERO_ADDRESS\r\n        self.id_to_approval[_token_id] = ZERO_ADDRESS\r\n        self.is_settled[_token_id] = False\r\n        self.owner_to_token_count[msg.sender] -= 1\r\n\r\n        count: uint256 = self.id_count\r\n        # add 2**160 to increment the nonce for next time this settler is used\r\n        self.available_token_ids[count] = _token_id + 2**160\r\n        self.id_count = count + 1\r\n\r\n        owner = ZERO_ADDRESS\r\n        synth = ZERO_ADDRESS\r\n        log Transfer(msg.sender, ZERO_ADDRESS, _token_id)\r\n\r\n\r\n    log TokenUpdate(_token_id, owner, synth, remaining)\r\n\r\n    return remaining\r\n\r\n\r\n@external\r\ndef settle(_token_id: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Settle the synth represented in an NFT.\r\n    @dev Settlement is performed when swapping or withdrawing, there\r\n         is no requirement to call this function separately.\r\n    @param _token_id The identifier for an NFT\r\n    @return bool Success\r\n    \"\"\"\r\n    if not self.is_settled[_token_id]:\r\n        assert self.id_to_owner[_token_id] != ZERO_ADDRESS, \"Unknown Token ID\"\r\n\r\n        settler: address = convert(_token_id % (2**160), address)\r\n        synth: address = Settler(settler).synth()\r\n        currency_key: bytes32 = self.currency_keys[synth]\r\n        self.exchanger.settle(settler, currency_key)  # dev: settlement failed\r\n        self.is_settled[_token_id] = True\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef add_synth(_synth: address, _pool: address):\r\n    \"\"\"\r\n    @notice Add a new swappable synth\r\n    @dev Callable by anyone, however `_pool` must exist within the Curve\r\n         pool registry and `_synth` must be a valid synth that is swappable\r\n         within the pool\r\n    @param _synth Address of the synth to add\r\n    @param _pool Address of the Curve pool where `_synth` is swappable\r\n    \"\"\"\r\n    assert self.synth_pools[_synth] == ZERO_ADDRESS  # dev: already added\r\n\r\n    # this will revert if `_synth` is not actually a synth\r\n    self.currency_keys[_synth] = Synth(_synth).currencyKey()\r\n\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n    pool_coins: address[8] = Registry(registry).get_coins(_pool)\r\n\r\n    has_synth: bool = False\r\n    for coin in pool_coins:\r\n        if coin == ZERO_ADDRESS:\r\n            assert has_synth  # dev: synth not in pool\r\n            break\r\n        if coin == _synth:\r\n            self.synth_pools[_synth] = _pool\r\n            has_synth = True\r\n        self.swappable_synth[coin] = _synth\r\n\r\n    log NewSynth(_synth, _pool)\r\n\r\n\r\n@external\r\ndef rebuildCache():\r\n    \"\"\"\r\n    @notice Update the current address of the SNX Exchanger contract\r\n    @dev The SNX exchanger address is kept in the local contract storage to reduce gas costs.\r\n         If this address changes, contract will stop working until the local address is updated.\r\n         Synthetix automates this process within their own architecture by exposing a `rebuildCache`\r\n         method in their own contracts, and calling them all to update via `AddressResolver.rebuildCaches`,\r\n         so we use the same API in order to be able to receive updates from them as well.\r\n         https://docs.synthetix.io/contracts/source/contracts/AddressResolver/#rebuildcaches\r\n    \"\"\"\r\n    self.exchanger = Exchanger(SNXAddressResolver(SNX_ADDRESS_RESOLVER).getAddress(EXCHANGER_KEY))","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"sender\",\"indexed\":true},{\"type\":\"address\",\"name\":\"receiver\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_id\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"approved\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_id\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApprovalForAll\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"operator\",\"indexed\":true},{\"type\":\"bool\",\"name\":\"approved\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewSettler\",\"inputs\":[{\"type\":\"address\",\"name\":\"addr\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewSynth\",\"inputs\":[{\"type\":\"address\",\"name\":\"synth\",\"indexed\":false},{\"type\":\"address\",\"name\":\"pool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenUpdate\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"token_id\",\"indexed\":true},{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"synth\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"underlying_balance\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_settler_implementation\"},{\"type\":\"uint256\",\"name\":\"_settler_count\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4579},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4609},{\"name\":\"supportsInterface\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"_interface_id\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":845},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1553},{\"name\":\"ownerOf\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1498},{\"name\":\"getApproved\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2425},{\"name\":\"isApprovedForAll\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_operator\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1761},{\"name\":\"transferFrom\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":134578},{\"name\":\"safeTransferFrom\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"safeTransferFrom\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_token_id\"},{\"type\":\"bytes\",\"name\":\"_data\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"approve\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_approved\"},{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":40888},{\"name\":\"setApprovalForAll\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_operator\"},{\"type\":\"bool\",\"name\":\"_approved\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38179},{\"name\":\"get_swap_into_synth_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_synth\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8579},{\"name\":\"get_swap_from_synth_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_synth\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4312},{\"name\":\"get_estimated_swap_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":12949},{\"name\":\"token_info\",\"outputs\":[{\"type\":\"address\",\"name\":\"owner\"},{\"type\":\"address\",\"name\":\"synth\"},{\"type\":\"uint256\",\"name\":\"underlying_balance\"},{\"type\":\"uint256\",\"name\":\"time_to_settle\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8207},{\"name\":\"swap_into_synth\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_synth\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"swap_into_synth\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_synth\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"},{\"type\":\"address\",\"name\":\"_receiver\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"swap_into_synth\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_synth\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"},{\"type\":\"address\",\"name\":\"_receiver\"},{\"type\":\"uint256\",\"name\":\"_existing_token_id\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"swap_from_synth\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"swap_from_synth\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"},{\"type\":\"address\",\"name\":\"_receiver\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_receiver\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"settle\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_id\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":42848},{\"name\":\"add_synth\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_synth\"},{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":605929},{\"name\":\"rebuildCache\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36338},{\"name\":\"synth_pools\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2086},{\"name\":\"swappable_synth\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2116},{\"name\":\"is_settled\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2046}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.8","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000082c1cc1685be4825400854ce5b1c7d86da75b7ac0000000000000000000000000000000000000000000000000000000000000005","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}