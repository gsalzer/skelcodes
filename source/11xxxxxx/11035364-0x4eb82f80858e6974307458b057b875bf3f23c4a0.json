{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/Governed.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMaster {\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    function dAppToken() public view returns(address);\r\n    function isInternal(address _address) public view returns(bool);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IMemberRoles.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMemberRoles {\r\n\r\n    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n    \r\n    enum Role {UnAssigned, AdvisoryBoard, TokenHolder, DisputeResolution}\r\n\r\n    function setInititorAddress(address _initiator) external;\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _authorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _authorized) public;\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256);\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint);\r\n    \r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address);\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \r\n}\r\n\r\n// File: contracts/interfaces/IMarketRegistry.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarketRegistry {\r\n\r\n    enum MarketType {\r\n      HourlyMarket,\r\n      DailyMarket,\r\n      WeeklyMarket\r\n    }\r\n    address public owner;\r\n    address public tokenController;\r\n    address public marketUtility;\r\n    bool public marketCreationPaused;\r\n\r\n    mapping(address => bool) public isMarket;\r\n    function() external payable{}\r\n\r\n    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\r\n\r\n    function burnDisputedProposalTokens(uint _proposaId) external;\r\n\r\n    function isWhitelistedSponsor(address _address) public view returns(bool);\r\n\r\n    function transferAssets(address _asset, address _to, uint _amount) external;\r\n\r\n    /**\r\n    * @dev Initialize the PlotX.\r\n    * @param _marketConfig The address of market config.\r\n    * @param _plotToken The address of PLOT token.\r\n    */\r\n    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\r\n\r\n    /**\r\n    * @dev Create proposal if user wants to raise the dispute.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    * @param actionHash The action hash for solution.\r\n    * @param stakeForDispute The token staked to raise the diospute.\r\n    * @param user The address who raises the dispute.\r\n    */\r\n    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the PlacePrediction event and sets user data.\r\n    * @param _user The address who placed prediction.\r\n    * @param _value The amount of ether user staked.\r\n    * @param _predictionPoints The positions user will get.\r\n    * @param _predictionAsset The prediction assets user will get.\r\n    * @param _prediction The option range on which user placed prediction.\r\n    * @param _leverage The leverage selected by user at the time of place prediction.\r\n    */\r\n    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the claimed event.\r\n    * @param _user The address who claim their reward.\r\n    * @param _reward The reward which is claimed by user.\r\n    * @param incentives The incentives of user.\r\n    * @param incentiveToken The incentive tokens of user.\r\n    */\r\n    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\r\n    }\r\n\r\n        /**\r\n    * @dev Emits the MarketResult event.\r\n    * @param _totalReward The amount of reward to be distribute.\r\n    * @param _winningOption The winning option of the market.\r\n    * @param _closeValue The closing value of the market currency.\r\n    */\r\n    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IbLOTToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IbLOTToken {\r\n    function initiatebLOT(address _defaultMinter) external;\r\n    function convertToPLOT(address _of, address _to, uint256 amount) public;\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/Iupgradable.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract Iupgradable {\r\n\r\n    /**\r\n     * @dev change master address\r\n     */\r\n    function setMasterAddress() public;\r\n}\r\n\r\n// File: contracts/Master.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Master is Governed {\r\n    bytes2[] public allContractNames;\r\n    address public dAppToken;\r\n    address public dAppLocker;\r\n    bool public masterInitialised;\r\n\r\n    mapping(address => bool) public contractsActive;\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    mapping(bytes2 => address payable) public contractAddress;\r\n\r\n    /**\r\n     * @dev modifier that allows only the authorized addresses to execute the function\r\n     */\r\n    modifier onlyAuthorizedToGovern() {\r\n        require(getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize the Master.\r\n     * @param _implementations The address of market implementation.\r\n     * @param _token The address of PLOT token.\r\n     * @param _marketUtiliy The addresses of market utility.\r\n     */\r\n    function initiateMaster(\r\n        address[] calldata _implementations,\r\n        address _token,\r\n        address _defaultAddress,\r\n        address _marketUtiliy,\r\n        address payable[] calldata _configParams,\r\n        address _vesting\r\n    ) external {\r\n        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\r\n            address(uint160(address(this)))\r\n        );\r\n        require(!masterInitialised);\r\n        require(msg.sender == proxy.proxyOwner(), \"Sender is not proxy owner.\");\r\n        masterInitialised = true;\r\n\r\n        //Initial contract names\r\n        allContractNames.push(\"MR\");\r\n        allContractNames.push(\"PC\");\r\n        allContractNames.push(\"GV\");\r\n        allContractNames.push(\"PL\");\r\n        allContractNames.push(\"TC\");\r\n        allContractNames.push(\"BL\");\r\n\r\n        require(\r\n            allContractNames.length == _implementations.length,\r\n            \"Implementation length not match\"\r\n        );\r\n        contractsActive[address(this)] = true;\r\n        dAppToken = _token;\r\n        for (uint256 i = 0; i < allContractNames.length; i++) {\r\n            _generateProxy(allContractNames[i], _implementations[i]);\r\n        }\r\n        dAppLocker = contractAddress[\"TC\"];\r\n\r\n        _setMasterAddress();\r\n\r\n        IMarketRegistry(contractAddress[\"PL\"]).initiate(\r\n            _defaultAddress,\r\n            _marketUtiliy,\r\n            _token,\r\n            _configParams\r\n        );\r\n        IbLOTToken(contractAddress[\"BL\"]).initiatebLOT(_defaultAddress);\r\n        ITokenController(contractAddress[\"TC\"]).initiateVesting(_vesting);\r\n        IMemberRoles(contractAddress[\"MR\"]).setInititorAddress(_defaultAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev adds a new contract type to master\r\n     */\r\n    function addNewContract(bytes2 _contractName, address _contractAddress)\r\n        external\r\n        onlyAuthorizedToGovern\r\n    {\r\n        require(_contractName != \"MS\", \"Name cannot be master\");\r\n        require(_contractAddress != address(0), \"Zero address\");\r\n        require(\r\n            contractAddress[_contractName] == address(0),\r\n            \"Contract code already available\"\r\n        );\r\n        allContractNames.push(_contractName);\r\n        _generateProxy(_contractName, _contractAddress);\r\n        Iupgradable up = Iupgradable(contractAddress[_contractName]);\r\n        up.setMasterAddress();\r\n    }\r\n\r\n    /**\r\n     * @dev upgrades a multiple contract implementations\r\n     */\r\n    function upgradeMultipleImplementations(\r\n        bytes2[] calldata _contractNames,\r\n        address[] calldata _contractAddresses\r\n    ) external onlyAuthorizedToGovern {\r\n        require(\r\n            _contractNames.length == _contractAddresses.length,\r\n            \"Array length should be equal.\"\r\n        );\r\n        for (uint256 i = 0; i < _contractNames.length; i++) {\r\n            require(\r\n                _contractAddresses[i] != address(0),\r\n                \"null address is not allowed.\"\r\n            );\r\n            _replaceImplementation(_contractNames[i], _contractAddresses[i]);\r\n        }\r\n    }\r\n\r\n    function whitelistSponsor(address _address) external onlyAuthorizedToGovern {\r\n        whitelistedSponsor[_address] = true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev To check if we use the particular contract.\r\n     * @param _address The contract address to check if it is active or not.\r\n     */\r\n    function isInternal(address _address) public view returns (bool) {\r\n        return contractsActive[_address];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets latest contract address\r\n     * @param _contractName Contract name to fetch\r\n     */\r\n    function getLatestAddress(bytes2 _contractName)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return contractAddress[_contractName];\r\n    }\r\n\r\n    /**\r\n     * @dev checks if an address is authorized to govern\r\n     */\r\n    function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\r\n        return (getLatestAddress(\"GV\") == _toCheck);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes Master contract address\r\n     */\r\n    function _setMasterAddress() internal {\r\n        for (uint256 i = 0; i < allContractNames.length; i++) {\r\n            Iupgradable up = Iupgradable(contractAddress[allContractNames[i]]);\r\n            up.setMasterAddress();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Replaces the implementations of the contract.\r\n     * @param _contractsName The name of the contract.\r\n     * @param _contractAddress The address of the contract to replace the implementations for.\r\n     */\r\n    function _replaceImplementation(\r\n        bytes2 _contractsName,\r\n        address _contractAddress\r\n    ) internal {\r\n        OwnedUpgradeabilityProxy tempInstance = OwnedUpgradeabilityProxy(\r\n            contractAddress[_contractsName]\r\n        );\r\n        tempInstance.upgradeTo(_contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev to generator proxy\r\n     * @param _contractAddress of the proxy\r\n     */\r\n    function _generateProxy(bytes2 _contractName, address _contractAddress)\r\n        internal\r\n    {\r\n        OwnedUpgradeabilityProxy tempInstance = new OwnedUpgradeabilityProxy(\r\n            _contractAddress\r\n        );\r\n        contractAddress[_contractName] = address(tempInstance);\r\n        contractsActive[address(tempInstance)] = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes2\"}],\"name\":\"getLatestAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractsActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"contractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"isAuthorizedToGovern\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes2\"},{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"addNewContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dAppLocker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractNames\",\"type\":\"bytes2[]\"},{\"name\":\"_contractAddresses\",\"type\":\"address[]\"}],\"name\":\"upgradeMultipleImplementations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_implementations\",\"type\":\"address[]\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_defaultAddress\",\"type\":\"address\"},{\"name\":\"_marketUtiliy\",\"type\":\"address\"},{\"name\":\"_configParams\",\"type\":\"address[]\"},{\"name\":\"_vesting\",\"type\":\"address\"}],\"name\":\"initiateMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedSponsor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"whitelistSponsor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allContractNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterInitialised\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isInternal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dAppToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Master","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2afa98ada87597ac16b08032003bc2b279bed28a81b5fa9b06b5dd901e7b9927"}]}