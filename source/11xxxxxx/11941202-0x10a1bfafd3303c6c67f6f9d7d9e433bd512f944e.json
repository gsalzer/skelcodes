{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) { return 0; }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Owner {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, 'Caller must be the owner!');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), 'New owner is the zero address.');\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function transferOwnershipAccept() public {\r\n        require(msg.sender == newOwner, 'Caller must be the owner!');\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract Campaigns is Owner {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    enum ProjectType {ETH, USDT}\r\n\r\n    Project[] private projects;\r\n    ProjectUSDT[] private projects_usdt;\r\n\r\n    event ProjectStarted(address contractAddress, address projectStarter, string projectTitle, string projectDesc, uint256 deadline,\r\n    uint256 goalAmount, ProjectType projectType);\r\n\r\n    function startProject(string calldata title, string calldata description, uint deadline, uint amountToRaise, uint hold, ProjectType projectType) external onlyOwner {\r\n        \r\n        if(projectType == ProjectType.ETH) {\r\n            Project newProject = new Project(msg.sender, title, description, deadline, amountToRaise, hold);\r\n            projects.push(newProject);\r\n            emit ProjectStarted(address(newProject), msg.sender, title, description, deadline, amountToRaise, ProjectType.ETH);\r\n        }\r\n        else if (projectType == ProjectType.USDT) {\r\n            ProjectUSDT newProject = new ProjectUSDT(msg.sender, title, description, deadline, amountToRaise, hold);\r\n            projects_usdt.push(newProject);\r\n            emit ProjectStarted(address(newProject), msg.sender, title, description, deadline, amountToRaise, ProjectType.USDT);            \r\n        }\r\n        \r\n    }                                                                                                                                   \r\n\r\n    function returnAllProjects() external view returns(Project[] memory) {\r\n        return projects;\r\n    }\r\n    function returnAllProjectsUSDT() external view returns(ProjectUSDT[] memory) {\r\n        return projects_usdt;\r\n    }\r\n}\r\n\r\ncontract Project {\r\n    using SafeMath for uint256;\r\n    \r\n    enum State {INITIATED, SUCCESSFUL, SENDED, CANCELED}\r\n\r\n    address payable public creator;\r\n    \r\n    uint public assetAmount;\r\n    uint public completeAt;\r\n    uint public deadline;\r\n    uint public refundFEE = 0;\r\n    uint public currentBalance;\r\n    uint public earnings = 0;\r\n    uint public fHold;\r\n    uint constant CAP = 1000000000000000000; //smallest currency unit\r\n\r\n    string public title;\r\n    string public description;\r\n    \r\n    State public state = State.INITIATED; \r\n    \r\n    struct Investment {\r\n        uint fund;\r\n        uint rate;\r\n        uint earningTotal;\r\n    }\r\n\r\n    mapping (address => Investment) public investor;\r\n\r\n    event FundingReceived(address investor, uint amount, uint currentTotal);\r\n    event RefundSent(address investor, uint amount, uint currentTotal);\r\n    event Cancel(address creator, string title, uint assetAmount, uint currentTotal);\r\n    event CreatorReceives(address recipient, uint amount);\r\n    event DepositedEarnings(uint deposit);\r\n    event InvestorReceived(uint amount);\r\n\r\n    IERC20 FDO = IERC20(0x361887C1D1B73557018c47c8001711168128cf69);\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, 'Only for the creator.');\r\n        _;\r\n    }\r\n\r\n    constructor (address payable projectStarter, string memory projectTitle, string memory projectDesc, uint fundRaisingDeadline, uint goalAmount, uint hold) {\r\n        creator = projectStarter;\r\n        title = projectTitle;\r\n        description = projectDesc;\r\n        assetAmount = goalAmount;\r\n        deadline = fundRaisingDeadline;\r\n        currentBalance = 0;\r\n        fHold = hold;\r\n    }\r\n    \r\n    function setAssetAmount(uint newAssetAmount) internal {\r\n        require(newAssetAmount > 0, 'New asset amount value must be greater than 0.');\r\n        require(newAssetAmount >= assetAmount, 'New asset amount value must be greater than the old value.');\r\n        assetAmount = newAssetAmount;\r\n    }\r\n    \r\n    function setNewDeadline(uint newDeadline) internal {\r\n        require(newDeadline > 0, 'New deadline value must be greater than 0.');\r\n        require(newDeadline >= deadline, 'New deadline value must be greater than the old value.');\r\n        deadline = newDeadline;\r\n    }\r\n    \r\n    function setNewRefundFEE(uint _FEE) internal {\r\n        require(_FEE >= 0 && _FEE <= 100, 'New fee must be between 0 and 100');\r\n        refundFEE = _FEE;\r\n    }\r\n    \r\n    function setNewFHold(uint newF) internal {\r\n        require(newF >= 0, 'New Fhold total value must be greater than or equal to 0.');\r\n        fHold = newF;\r\n    }\r\n    \r\n    function setNewValues(uint newAssetAmount, uint newDeadline, uint _FEE, uint newF) external onlyCreator {\r\n        require(state == State.INITIATED, 'Invalid state');\r\n        setAssetAmount(newAssetAmount);\r\n        setNewDeadline(newDeadline);\r\n        setNewRefundFEE(_FEE);\r\n        setNewFHold(newF);\r\n    }\r\n\r\n    function buy() external payable {\r\n        uint dif = assetAmount.sub(currentBalance);\r\n        \r\n        require(fHold <= FDO.balanceOf(msg.sender), 'You must have Firdaos tokens in your portfolio to be able to invest.');\r\n        require(msg.value <= dif, 'Higher than allowed value');\r\n        require(msg.value > 0, 'Invest a value greater than 0.');\r\n        require(block.timestamp < deadline, 'Campaign timed out.');\r\n        require(state == State.INITIATED, 'Invalid state');\r\n        require(msg.sender != creator, 'Creator cannot invest in the project.');\r\n        \r\n        Investment memory investment = investor[msg.sender];\r\n        \r\n        investment.fund = investment.fund + msg.value;\r\n        investment.rate = investment.fund.mul(CAP).div(assetAmount);\r\n        currentBalance = currentBalance.add(msg.value);\r\n\r\n        investor[msg.sender] = Investment(investment.fund, investment.rate, 0);\r\n        \r\n        emit FundingReceived(msg.sender, msg.value, currentBalance);\r\n        \r\n        if(currentBalance >= assetAmount) {\r\n            state = State.SUCCESSFUL;  \r\n            completeAt = block.timestamp;\r\n        }\r\n    }\r\n    \r\n    function refund() external {\r\n        require(state == State.INITIATED || state == State.CANCELED, 'Invalid state');\r\n        \r\n        Investment memory investment = investor[msg.sender];\r\n        uint temp = investment.fund;\r\n        \r\n        require(temp > 0, 'Your invested amount is 0');\r\n        temp = temp.mul(100-refundFEE).div(100);\r\n        msg.sender.transfer(temp);\r\n        currentBalance = currentBalance.sub(temp);\r\n        \r\n        investor[msg.sender] = Investment(0, 0, 0);\r\n        \r\n        emit RefundSent(msg.sender, temp, currentBalance);\r\n    }\r\n    \r\n    function payout() external onlyCreator {\r\n        require(state == State.SUCCESSFUL, 'Invalid state');\r\n        uint temp = currentBalance;\r\n        \r\n        creator.transfer(temp);\r\n        \r\n        emit CreatorReceives(creator, temp);\r\n\r\n        currentBalance = 0;\r\n        state = State.SENDED;  \r\n    }\r\n    \r\n    function cancel() external onlyCreator {\r\n        require(state == State.INITIATED || state == State.SUCCESSFUL, 'Invalid state');\r\n      \r\n        emit Cancel(creator, title, assetAmount, currentBalance);\r\n        state = State.CANCELED; \r\n    }\r\n    \r\n    function depositEarnings() external payable onlyCreator {\r\n        require(state == State.SENDED, 'Invalid state');\r\n        earnings = earnings + msg.value;\r\n        emit DepositedEarnings(msg.value);   \r\n    }\r\n    \r\n    function withdrawEarnings() external {\r\n        require(state == State.SENDED, 'Invalid state');\r\n        Investment memory investment = investor[msg.sender];\r\n        uint temp = investment.fund;\r\n        require(temp > 0, 'Your invested amount is 0');\r\n        uint earning_temp = earnings.mul(investment.rate).div(CAP).sub(investment.earningTotal);\r\n        if(earning_temp > 0) { \r\n            msg.sender.transfer(earning_temp); \r\n            investor[msg.sender] = Investment(temp, investment.rate, earning_temp + investment.earningTotal);\r\n            emit InvestorReceived(earning_temp);\r\n        }\r\n    }\r\n    \r\n    function getInvestor(address inv) public view returns\r\n    (\r\n        uint256 fund,\r\n        uint256 rate,\r\n        uint256 earningTotal\r\n    ) {\r\n        Investment memory investment = investor[inv];\r\n        fund = investment.fund;\r\n        rate = investment.rate;\r\n        earningTotal = investment.earningTotal;\r\n    }\r\n\r\n    function getDetails() public view returns \r\n    (\r\n        address payable projectStarter,\r\n        string memory projectTitle,\r\n        string memory projectDesc,\r\n        uint256 deadLine,\r\n        State currentState,\r\n        uint256 currentAmount,\r\n        uint256 goalAmount,\r\n        uint256 valueToComplete,\r\n        uint256 fpay\r\n    ) {\r\n        projectStarter = creator;\r\n        projectTitle = title;\r\n        projectDesc = description;\r\n        deadLine = deadline;\r\n        currentState = state;\r\n        currentAmount = currentBalance;\r\n        goalAmount = assetAmount;\r\n        valueToComplete = assetAmount.sub(currentBalance);\r\n        fpay = fHold;\r\n    }\r\n    \r\n    receive() external payable { \r\n\r\n    }\r\n}\r\n\r\ncontract ProjectUSDT {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    enum State {INITIATED, SUCCESSFUL, SENDED, CANCELED}\r\n\r\n    address payable public creator;\r\n    \r\n    uint public assetAmount;\r\n    uint public completeAt;\r\n    uint public deadline;\r\n    uint public refundFEE = 0;\r\n    uint public currentBalance;\r\n    uint public earnings = 0;\r\n    uint public fHold;\r\n    uint constant CAP = 1000000; //smallest currency unit\r\n\r\n    string public title;\r\n    string public description;\r\n    \r\n    State public state = State.INITIATED; \r\n    \r\n    struct Investment {\r\n        uint fund;\r\n        uint rate;\r\n        uint earningTotal;\r\n    }\r\n\r\n    mapping (address => Investment) public investor;\r\n\r\n    event FundingReceived(address investor, uint amount, uint currentTotal);\r\n    event RefundSent(address investor, uint amount, uint currentTotal);\r\n    event Cancel(address creator, string title, uint assetAmount, uint currentTotal);\r\n    event CreatorReceives(address recipient, uint amount);\r\n    event DepositedEarnings(uint deposit);\r\n    event InvestorReceived(uint amount);\r\n    \r\n    IERC20 FDO = IERC20(0x361887C1D1B73557018c47c8001711168128cf69);\r\n    IERC20 USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, 'Only for the creator.');\r\n        _;\r\n    }\r\n\r\n    constructor (address payable projectStarter, string memory projectTitle, string memory projectDesc, uint fundRaisingDeadline, uint goalAmount, uint hold) {\r\n        creator = projectStarter;\r\n        title = projectTitle;\r\n        description = projectDesc;\r\n        assetAmount = goalAmount;\r\n        deadline = fundRaisingDeadline;\r\n        currentBalance = 0;\r\n        fHold = hold;\r\n    }\r\n    \r\n    function setAssetAmount(uint newAssetAmount) internal {\r\n        require(newAssetAmount > 0, 'New asset amount value must be greater than 0.');\r\n        require(newAssetAmount >= assetAmount, 'New asset amount value must be greater than the old value.');\r\n        assetAmount = newAssetAmount;\r\n    }\r\n    \r\n    function setNewDeadline(uint newDeadline) internal {\r\n        require(newDeadline > 0, 'New deadline value must be greater than 0.');\r\n        require(newDeadline >= deadline, 'New deadline value must be greater than the old value.');\r\n        deadline = newDeadline;\r\n    }\r\n    \r\n    function setNewRefundFEE(uint _FEE) internal {\r\n        require(_FEE >= 0 && _FEE <= 100, 'New fee must be between 0 and 100');\r\n        refundFEE = _FEE;\r\n    }\r\n    \r\n    function setNewFHold(uint newF) internal {\r\n        require(newF >= 0, 'New Fhold total value must be greater than or equal to 0.');\r\n        fHold = newF;\r\n    }\r\n    \r\n    function setNewValues(uint newAssetAmount, uint newDeadline, uint _FEE, uint newF) external onlyCreator {\r\n        require(state == State.INITIATED, 'Invalid state');\r\n        setAssetAmount(newAssetAmount);\r\n        setNewDeadline(newDeadline);\r\n        setNewRefundFEE(_FEE);\r\n        setNewFHold(newF);\r\n    }\r\n\r\n    function buy(uint payment) external {\r\n        uint dif = assetAmount.sub(currentBalance);\r\n        \r\n        require(fHold <= FDO.balanceOf(msg.sender), 'You must have Firdaos tokens in your portfolio to be able to invest.');\r\n        \r\n        require(USDT.balanceOf(msg.sender) >= payment, 'You dont have enough tokens.');\r\n        USDT.safeTransferFrom(msg.sender, address(this), payment);\r\n        \r\n        require(payment <= dif, 'Higher than allowed value');\r\n        require(payment > 0, 'Invest a value greater than 0.');\r\n        require(block.timestamp < deadline, 'Campaign timed out.');\r\n        require(state == State.INITIATED, 'Invalid state');\r\n        require(msg.sender != creator, 'Creator cannot invest in the project.');\r\n        \r\n        Investment memory investment = investor[msg.sender];\r\n        \r\n        investment.fund = investment.fund + payment;\r\n        investment.rate = investment.fund.mul(CAP).div(assetAmount);\r\n        currentBalance = currentBalance.add(payment);\r\n\r\n        investor[msg.sender] = Investment(investment.fund, investment.rate, 0);\r\n        \r\n        emit FundingReceived(msg.sender, payment, currentBalance);\r\n        \r\n        if(currentBalance >= assetAmount) {\r\n            state = State.SUCCESSFUL;  \r\n            completeAt = block.timestamp;\r\n        }\r\n    }\r\n    \r\n    function refund() external {\r\n        require(state == State.INITIATED || state == State.CANCELED, 'Invalid state');\r\n        \r\n        Investment memory investment = investor[msg.sender];\r\n        uint temp = investment.fund;\r\n        \r\n        require(temp > 0, 'Your invested amount is 0');\r\n        temp = temp.mul(100-refundFEE).div(100);\r\n        \r\n        USDT.safeTransfer(msg.sender, temp);\r\n        \r\n        currentBalance = currentBalance.sub(temp);\r\n        \r\n        investor[msg.sender] = Investment(0, 0, 0);\r\n        \r\n        emit RefundSent(msg.sender, temp, currentBalance);\r\n    }\r\n    \r\n    function payout() external onlyCreator {\r\n        require(state == State.SUCCESSFUL, 'Invalid state');\r\n        uint temp = currentBalance;\r\n        \r\n        USDT.safeTransfer(creator, temp);\r\n        \r\n        emit CreatorReceives(creator, temp);\r\n\r\n        currentBalance = 0;\r\n        state = State.SENDED;  \r\n    }\r\n    \r\n    function cancel() external onlyCreator {\r\n        require(state == State.INITIATED || state == State.SUCCESSFUL, 'Invalid state');\r\n      \r\n        emit Cancel(creator, title, assetAmount, currentBalance);\r\n        state = State.CANCELED; \r\n    }\r\n    \r\n    function depositEarnings(uint payment) external onlyCreator {\r\n        require(USDT.balanceOf(msg.sender) >= payment, 'You dont have enough tokens.');\r\n        USDT.safeTransferFrom(msg.sender, address(this), payment);\r\n        \r\n        require(state == State.SENDED, 'Invalid state');\r\n        earnings = earnings + payment;\r\n        emit DepositedEarnings(payment);   \r\n    }\r\n    \r\n    function withdrawEarnings() external {\r\n        require(state == State.SENDED, 'Invalid state');\r\n        Investment memory investment = investor[msg.sender];\r\n        uint temp = investment.fund;\r\n        require(temp > 0, 'Your invested amount is 0');\r\n        uint earning_temp = earnings.mul(investment.rate).div(CAP).sub(investment.earningTotal);\r\n        if(earning_temp > 0) { \r\n            USDT.safeTransfer(msg.sender, earning_temp); \r\n            investor[msg.sender] = Investment(temp, investment.rate, earning_temp + investment.earningTotal);\r\n            emit InvestorReceived(earning_temp);\r\n        }\r\n    }\r\n    \r\n    function getInvestor(address inv) public view returns\r\n    (\r\n        uint256 fund,\r\n        uint256 rate,\r\n        uint256 earningTotal\r\n    ) {\r\n        Investment memory investment = investor[inv];\r\n        fund = investment.fund;\r\n        rate = investment.rate;\r\n        earningTotal = investment.earningTotal;\r\n    }\r\n\r\n    function getDetails() public view returns \r\n    (\r\n        address payable projectStarter,\r\n        string memory projectTitle,\r\n        string memory projectDesc,\r\n        uint256 deadLine,\r\n        State currentState,\r\n        uint256 currentAmount,\r\n        uint256 goalAmount,\r\n        uint256 valueToComplete,\r\n        uint256 fpay\r\n    ) {\r\n        projectStarter = creator;\r\n        projectTitle = title;\r\n        projectDesc = description;\r\n        deadLine = deadline;\r\n        currentState = state;\r\n        currentAmount = currentBalance;\r\n        goalAmount = assetAmount;\r\n        valueToComplete = assetAmount.sub(currentBalance);\r\n        fpay = fHold;\r\n    }\r\n    \r\n    receive() external payable { \r\n\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"projectStarter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"projectTitle\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"projectDesc\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"goalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Campaigns.ProjectType\",\"name\":\"projectType\",\"type\":\"uint8\"}],\"name\":\"ProjectStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnAllProjects\",\"outputs\":[{\"internalType\":\"contract Project[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnAllProjectsUSDT\",\"outputs\":[{\"internalType\":\"contract ProjectUSDT[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToRaise\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hold\",\"type\":\"uint256\"},{\"internalType\":\"enum Campaigns.ProjectType\",\"name\":\"projectType\",\"type\":\"uint8\"}],\"name\":\"startProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferOwnershipAccept\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Campaigns","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e920e03faf6fbdcd9a88cda7d5b32f207166f4ebb0128d1c6a24495994f4318e"}]}