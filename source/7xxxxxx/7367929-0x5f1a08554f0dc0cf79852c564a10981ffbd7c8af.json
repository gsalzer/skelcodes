{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n\r\n\r\n/**\r\n * Copyright Â© 2017-2019 Ramp Network sp. z o.o. All rights reserved (MIT License).\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\r\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\r\n * is furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all copies\r\n * or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\r\n * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/**\r\n * Abstract class for an asset adapter -- a class handling the binary asset description,\r\n * encapsulating the asset-specific transfer logic.\r\n * The `assetData` bytes consist of a 2-byte (uint16) asset type, followed by asset-specific data.\r\n * The asset type bytes must be equal to the `ASSET_TYPE` constant in each subclass.\r\n *\r\n * @dev Subclasses of this class are used as mixins to their respective main swap contract.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract AssetAdapter {\r\n\r\n    uint16 public ASSET_TYPE;\r\n    bytes32 internal EIP712_SWAP_TYPEHASH;\r\n    bytes32 internal EIP712_ASSET_TYPEHASH;\r\n\r\n    constructor(\r\n        uint16 assetType,\r\n        bytes32 swapTypehash,\r\n        bytes32 assetTypehash\r\n    ) internal {\r\n        ASSET_TYPE = assetType;\r\n        EIP712_SWAP_TYPEHASH = swapTypehash;\r\n        EIP712_ASSET_TYPEHASH = assetTypehash;\r\n    }\r\n\r\n    /**\r\n     * Ensure the described asset is sent to the given address.\r\n     * Should revert if the transfer failed, but callers must also handle `false` being returned,\r\n     * much like ERC20's `transfer`.\r\n     */\r\n    function sendAssetTo(bytes memory assetData, address payable _to) internal returns (bool success);\r\n\r\n    /**\r\n     * Ensure the described asset is sent to the contract (check `msg.value` for ether,\r\n     * do a `transferFrom` for tokens, etc).\r\n     * Should revert if the transfer failed, but callers must also handle `false` being returned,\r\n     * much like ERC20's `transfer`.\r\n     *\r\n     * @dev subclasses that don't use ether should mark this with the `noEther` modifier, to make\r\n     * sure no ether is sent -- because, to have one consistent interface, the `create` function\r\n     * in `AbstractRampSwaps` is marked `payable`.\r\n     */\r\n    function lockAssetFrom(bytes memory assetData, address _from) internal returns (bool success);\r\n\r\n    /**\r\n     * Returns the EIP712 hash of the handled asset data struct.\r\n     * See `getAssetTypedHash` in the subclasses for asset struct type description.\r\n     */\r\n    function getAssetTypedHash(bytes memory data) internal view returns (bytes32);\r\n\r\n    /**\r\n     * Verify that the passed asset data should be handled by this adapter.\r\n     *\r\n     * @dev it's sufficient to use this only when creating a new swap -- all the other swap\r\n     * functions first check if the swap hash is valid, while a swap hash with invalid\r\n     * asset type wouldn't be created at all.\r\n     *\r\n     * @dev asset type is 2 bytes long, and it's at offset 32 in `assetData`'s memory (the first 32\r\n     * bytes are the data length). We load the word at offset 2 (it ends with the asset type bytes),\r\n     * and retrieve its last 2 bytes into a `uint16` variable.\r\n     */\r\n    modifier checkAssetType(bytes memory assetData) {\r\n        uint16 assetType;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            assetType := and(\r\n                mload(add(assetData, 2)),\r\n                0xffff\r\n            )\r\n        }\r\n        require(assetType == ASSET_TYPE, \"invalid asset type\");\r\n        _;\r\n    }\r\n\r\n    modifier noEther() {\r\n        require(msg.value == 0, \"this asset doesn't accept ether\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * An adapter for handling ether swaps.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract EthAdapter is AssetAdapter {\r\n\r\n    uint16 internal constant ETH_TYPE_ID = 1;\r\n\r\n    // the hashes are generated using `genTypeHashes` from `eip712.swaps`\r\n    constructor() internal AssetAdapter(\r\n        ETH_TYPE_ID,\r\n        0x3f5e83ffc9f619035e6bbc5b772db010a6ea49213f31e8a5d137b6cebf8d19c7,\r\n        0x4edc3bd27f6cb13e1f0e97fa9dd936fa2dc988debb1378354f49e2bb59be435e\r\n    ) {}\r\n\r\n    /**\r\n    * @dev byte offsets, byte length & contents for ether asset data:\r\n    * +00  32  uint256  data length (== 0x22 == 34 bytes)\r\n    * +32   2  uint16   asset type  (== 1)\r\n    * +34  32  uint256  ether amount in wei\r\n    */\r\n    function getAmount(bytes memory assetData) internal pure returns (uint256 amount) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            amount := mload(add(assetData, 34))\r\n        }\r\n    }\r\n\r\n    function sendAssetTo(\r\n        bytes memory assetData, address payable _to\r\n    ) internal returns (bool success) {\r\n        _to.transfer(getAmount(assetData));  // always throws on failure\r\n        return true;\r\n    }\r\n\r\n    function lockAssetFrom(\r\n        bytes memory assetData, address _from\r\n    ) internal returns (bool success) {\r\n        require(msg.sender == _from, \"invalid ether sender\");\r\n        require(msg.value == getAmount(assetData), \"invalid ether amount sent\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the EIP712 hash of the eth asset data struct:\r\n     * EIP712EthAsset {\r\n     *    ethAmount: uint256;\r\n     * }\r\n     */\r\n    function getAssetTypedHash(bytes memory data) internal view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712_ASSET_TYPEHASH,\r\n                getAmount(data)\r\n            )\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    constructor() internal {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only the owner can call this\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * An extended version of the standard `Pausable` contract, with more possible statuses:\r\n *  * STOPPED: all swap actions cannot be executed until the status is changed,\r\n *  * RETURN_ONLY: the existing swaps can only be returned, no new swaps can be created;\r\n *  * FINALIZE_ONLY: the existing swaps can be released or returned, no new swaps can be created;\r\n *  * ACTIVE: all swap actions can be executed.\r\n *\r\n * @dev the status enum is strictly monotonic, and the default 0 is mapped to STOPPED for safety.\r\n */\r\ncontract WithStatus is Ownable {\r\n\r\n    enum Status {\r\n        STOPPED,\r\n        RETURN_ONLY,\r\n        FINALIZE_ONLY,\r\n        ACTIVE\r\n    }\r\n\r\n    event StatusChanged(Status oldStatus, Status newStatus);\r\n\r\n    Status public status = Status.ACTIVE;\r\n\r\n    constructor() internal {}\r\n\r\n    function setStatus(Status _status) external onlyOwner {\r\n        emit StatusChanged(status, _status);\r\n        status = _status;\r\n    }\r\n\r\n    modifier statusAtLeast(Status _status) {\r\n        require(status >= _status, \"invalid contract status\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * An owner-managed list of oracles, that are allowed to claim, release or return swaps.\r\n */\r\ncontract WithOracles is Ownable {\r\n\r\n    mapping (address => bool) oracles;\r\n\r\n    /**\r\n     * The deployer is the default oracle.\r\n     */\r\n    constructor() internal {\r\n        oracles[msg.sender] = true;\r\n    }\r\n\r\n    function approveOracle(address _oracle) external onlyOwner {\r\n        oracles[_oracle] = true;\r\n    }\r\n\r\n    function revokeOracle(address _oracle) external onlyOwner {\r\n        oracles[_oracle] = false;\r\n    }\r\n\r\n    modifier isOracle(address _oracle) {\r\n        require(oracles[_oracle], \"invalid oracle address\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracle(address _oracle) {\r\n        require(\r\n            msg.sender == _oracle && oracles[msg.sender],\r\n            \"only the oracle can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracleOrSender(address _sender, address _oracle) {\r\n        require(\r\n            msg.sender == _sender || (msg.sender == _oracle && oracles[msg.sender]),\r\n            \"only the oracle or the sender can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlySender(address _sender) {\r\n        require(msg.sender == _sender, \"only the sender can call this\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * The main contract managing Ramp Swaps escrows lifecycle: create, claim, release and return.\r\n * Uses an abstract AssetAdapter to carry out the transfers and handle the particular asset data.\r\n * With a corresponding off-chain protocol allows for atomic-swap-like transfer between\r\n * fiat currencies and crypto assets.\r\n *\r\n * @dev an active swap is represented by a hash of its details, mapped to its escrow expiration\r\n * timestamp. When the swap is created, but not yet claimed, its end time is set to SWAP_UNCLAIMED.\r\n * The hashed swap details are:\r\n *  * address sender: the swap's creator, that sells the crypto asset;\r\n *  * address receiver: the user that buys the crypto asset, `0x0` until the swap is claimed;\r\n *  * address oracle: address of the oracle that handles this particular swap;\r\n *  * bytes assetData: description of the crypto asset, handled by an AssetAdapter;\r\n *  * bytes32 paymentDetailsHash: hash of the fiat payment details: account numbers, fiat value\r\n *    and currency, and the transfer reference (title), that can be verified off-chain.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract AbstractRampSwaps is Ownable, WithStatus, WithOracles, AssetAdapter {\r\n\r\n    /// @dev contract version, defined in semver\r\n    string public constant VERSION = \"0.3.1\";\r\n\r\n    /// @dev used as a special swap endTime value, to denote a yet unclaimed swap\r\n    uint32 internal constant SWAP_UNCLAIMED = 1;\r\n    uint32 internal constant MIN_ACTUAL_TIMESTAMP = 1000000000;\r\n\r\n    /// @notice how long are sender's funds locked from a claim until he can cancel the swap\r\n    uint32 internal constant SWAP_LOCK_TIME_S = 3600 * 24 * 7;\r\n\r\n    event Created(bytes32 indexed swapHash);\r\n    event BuyerSet(bytes32 indexed oldSwapHash, bytes32 indexed newSwapHash);\r\n    event Claimed(bytes32 indexed oldSwapHash, bytes32 indexed newSwapHash);\r\n    event Released(bytes32 indexed swapHash);\r\n    event SenderReleased(bytes32 indexed swapHash);\r\n    event Returned(bytes32 indexed swapHash);\r\n    event SenderReturned(bytes32 indexed swapHash);\r\n\r\n    /**\r\n     * @notice Mapping from swap details hash to its end time (as a unix timestamp).\r\n     * After the end time the swap can be cancelled, and the funds will be returned to the sender.\r\n     * Value `(SWAP_UNCLAIMED)` is used to denote that a swap exists, but has not yet been claimed\r\n     * by any receiver, and can also be cancelled until that.\r\n     */\r\n    mapping (bytes32 => uint32) internal swaps;\r\n\r\n    /**\r\n     * @dev EIP712 type hash for the struct:\r\n     * EIP712Domain {\r\n     *   name: string;\r\n     *   version: string;\r\n     *   chainId: uint256;\r\n     *   verifyingContract: address;\r\n     * }\r\n     */\r\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n    bytes32 internal EIP712_DOMAIN_HASH;\r\n\r\n    constructor(uint256 _chainId) internal {\r\n        EIP712_DOMAIN_HASH = keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(\"RampSwaps\")),\r\n                keccak256(bytes(VERSION)),\r\n                _chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Swap creation, called by the crypto sender. Checks swap parameters and ensures the crypto\r\n     * asset is locked on this contract.\r\n     * Additionally to the swap details, this function takes params v, r, s, which is checked to be\r\n     * an ECDSA signature of the swap hash made by the oracle -- to prevent users from creating\r\n     * swaps outside Ramp Network.\r\n     *\r\n     * Emits a `Created` event with the swap hash.\r\n     */\r\n    function create(\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        payable\r\n        statusAtLeast(Status.ACTIVE)\r\n        isOracle(_oracle)\r\n        checkAssetType(_assetData)\r\n        returns\r\n        (bool success)\r\n    {\r\n        bytes32 swapHash = getSwapHash(\r\n            msg.sender, address(0), _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapNotExists(swapHash);\r\n        require(ecrecover(swapHash, v, r, s) == _oracle, \"invalid swap oracle signature\");\r\n        // Set up swap status before transfer, to avoid reentrancy attacks.\r\n        // Even if a malicious token is somehow passed to this function (despite the oracle\r\n        // signature of its details), the state of this contract is already fully updated,\r\n        // so it will behave correctly (as it would be a separate call).\r\n        swaps[swapHash] = SWAP_UNCLAIMED;\r\n        require(\r\n            lockAssetFrom(_assetData, msg.sender),\r\n            \"failed to lock asset on escrow\"\r\n        );\r\n        emit Created(swapHash);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Swap claim, called by the swap's oracle on behalf of the receiver, to confirm his interest\r\n     * in buying the crypto asset.\r\n     * Additional v, r, s parameters are checked to be the receiver's EIP712 typed data signature\r\n     * of the swap's details and a 'claim this swap' action -- which verifies the receiver's address\r\n     * and the authenthicity of his claim request. See `getClaimTypedHash` for description of the\r\n     * signed swap struct.\r\n     *\r\n     * Emits a `Claimed` event with the current swap hash and the new swap hash, updated with\r\n     * receiver's address. The current swap hash equal to the hash emitted in `create`, unless\r\n     * `setBuyer` was called in the meantime -- then the current swap hash is equal to the new\r\n     * swap hash, because the receiver's address was already set.\r\n     */\r\n    function claim(\r\n        address _sender,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external statusAtLeast(Status.ACTIVE) onlyOracle(_oracle) {\r\n        // Verify claim signature\r\n        bytes32 claimTypedHash = getClaimTypedHash(\r\n            _sender,\r\n            _receiver,\r\n            _assetData,\r\n            _paymentDetailsHash\r\n        );\r\n        require(ecrecover(claimTypedHash, v, r, s) == _receiver, \"invalid claim receiver signature\");\r\n        // Verify swap hashes\r\n        bytes32 oldSwapHash = getSwapHash(\r\n            _sender, address(0), _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        bytes32 newSwapHash = getSwapHash(\r\n            _sender, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        bytes32 claimFromHash;\r\n        // We want this function to be universal, regardless of whether `setBuyer` was called before.\r\n        // If it was, the hash is already changed\r\n        if (swaps[oldSwapHash] == 0) {\r\n            claimFromHash = newSwapHash;\r\n            requireSwapUnclaimed(newSwapHash);\r\n        } else {\r\n            claimFromHash = oldSwapHash;\r\n            requireSwapUnclaimed(oldSwapHash);\r\n            requireSwapNotExists(newSwapHash);\r\n            swaps[oldSwapHash] = 0;\r\n        }\r\n        // any overflow security warnings can be safely ignored -- SWAP_LOCK_TIME_S is a small\r\n        // constant, so this won't overflow an uint32 until year 2106\r\n        // solium-disable-next-line security/no-block-members\r\n        swaps[newSwapHash] = uint32(block.timestamp) + SWAP_LOCK_TIME_S;\r\n        emit Claimed(claimFromHash, newSwapHash);\r\n    }\r\n\r\n    /**\r\n     * Swap release, which transfers the crypto asset to the receiver and removes the swap from\r\n     * the active swap mapping. Normally called by the swap's oracle after it confirms a matching\r\n     * wire transfer on sender's bank account. Can be also called by the sender, for example in case\r\n     * of a dispute, when the parties reach an agreement off-chain.\r\n     *\r\n     * Emits a `Released` event with the swap's hash.\r\n     */\r\n    function release(\r\n        address _sender,\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.FINALIZE_ONLY) onlyOracleOrSender(_sender, _oracle) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _sender, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapClaimed(swapHash);\r\n        // Delete the swap status before transfer, to avoid reentrancy attacks.\r\n        swaps[swapHash] = 0;\r\n        require(\r\n            sendAssetTo(_assetData, _receiver),\r\n            \"failed to send asset to receiver\"\r\n        );\r\n        if (msg.sender == _sender) {\r\n            emit SenderReleased(swapHash);\r\n        } else {\r\n            emit Released(swapHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Swap return, which transfers the crypto asset back to the sender and removes the swap from\r\n     * the active swap mapping. Can be called by the sender or the swap's oracle, but only if the\r\n     * swap is not claimed, or was claimed but the escrow lock time expired.\r\n     *\r\n     * Emits a `Returned` event with the swap's hash.\r\n     */\r\n    function returnFunds(\r\n        address payable _sender,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.RETURN_ONLY) onlyOracleOrSender(_sender, _oracle) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _sender, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapUnclaimedOrExpired(swapHash);\r\n        // Delete the swap status before transfer, to avoid reentrancy attacks.\r\n        swaps[swapHash] = 0;\r\n        require(\r\n            sendAssetTo(_assetData, _sender),\r\n            \"failed to send asset to sender\"\r\n        );\r\n        if (msg.sender == _sender) {\r\n            emit SenderReturned(swapHash);\r\n        } else {\r\n            emit Returned(swapHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * After the sender creates a swap, he can optionally call this function to restrict the swap\r\n     * to a particular receiver address. The swap can't then be claimed by any other receiver.\r\n     *\r\n     * Emits a `BuyerSet` event with the created swap hash and new swap hash, updated with\r\n     * receiver's address.\r\n     */\r\n    function setBuyer(\r\n        address _sender,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.ACTIVE) onlySender(_sender) {\r\n        bytes32 assetHash = keccak256(_assetData);\r\n        bytes32 oldSwapHash = getSwapHash(\r\n            _sender, address(0), _oracle, assetHash, _paymentDetailsHash\r\n        );\r\n        requireSwapUnclaimed(oldSwapHash);\r\n        bytes32 newSwapHash = getSwapHash(\r\n            _sender, _receiver, _oracle, assetHash, _paymentDetailsHash\r\n        );\r\n        requireSwapNotExists(newSwapHash);\r\n        swaps[oldSwapHash] = 0;\r\n        swaps[newSwapHash] = SWAP_UNCLAIMED;\r\n        emit BuyerSet(oldSwapHash, newSwapHash);\r\n    }\r\n\r\n    /**\r\n     * Given all valid swap details, returns its status. To check a swap with unset buyer,\r\n     * use `0x0` as the `_receiver` address. The return can be:\r\n     * 0: the swap details are invalid, swap doesn't exist, or was already released/returned.\r\n     * 1: the swap was created, and is not claimed yet.\r\n     * >1: the swap was claimed, and the value is a timestamp indicating end of its lock time.\r\n     */\r\n    function getSwapStatus(\r\n        address _sender,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external view returns (uint32 status) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _sender, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        return swaps[swapHash];\r\n    }\r\n\r\n    /**\r\n     * Calculates the swap hash used to reference the swap in this contract's storage.\r\n     */\r\n    function getSwapHash(\r\n        address _sender,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes32 assetHash,\r\n        bytes32 _paymentDetailsHash\r\n    ) internal pure returns (bytes32 hash) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                _sender, _receiver, _oracle, assetHash, _paymentDetailsHash\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the EIP712 typed hash for the struct:\r\n     * EIP712<Type>Swap {\r\n     *   action: bytes32;\r\n     *   sender: address;\r\n     *   receiver: address;\r\n     *   asset: asset data struct, see `getAssetTypedHash` in specific AssetAdapter contracts\r\n     *   paymentDetailsHash: bytes32;\r\n     * }\r\n     */\r\n    function getClaimTypedHash(\r\n        address _sender,\r\n        address _receiver,\r\n        bytes memory _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) internal view returns(bytes32 msgHash) {\r\n        bytes32 dataHash = keccak256(\r\n            abi.encode(\r\n                EIP712_SWAP_TYPEHASH,\r\n                bytes32(\"claim this swap\"),\r\n                _sender,\r\n                _receiver,\r\n                getAssetTypedHash(_assetData),\r\n                _paymentDetailsHash\r\n            )\r\n        );\r\n        return keccak256(abi.encodePacked(bytes2(0x1901), EIP712_DOMAIN_HASH, dataHash));\r\n    }\r\n\r\n    function requireSwapNotExists(bytes32 swapHash) internal view {\r\n        require(swaps[swapHash] == 0, \"swap already exists\");\r\n    }\r\n\r\n    function requireSwapUnclaimed(bytes32 swapHash) internal view {\r\n        require(swaps[swapHash] == SWAP_UNCLAIMED, \"swap already claimed or invalid\");\r\n    }\r\n\r\n    function requireSwapClaimed(bytes32 swapHash) internal view {\r\n        require(swaps[swapHash] > MIN_ACTUAL_TIMESTAMP, \"swap unclaimed or invalid\");\r\n    }\r\n\r\n    function requireSwapUnclaimedOrExpired(bytes32 swapHash) internal view {\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            (swaps[swapHash] > MIN_ACTUAL_TIMESTAMP && block.timestamp > swaps[swapHash]) ||\r\n                swaps[swapHash] == SWAP_UNCLAIMED,\r\n            \"swap not expired or invalid\"\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Ramp Swaps contract with the ether asset adapter.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract EthRampSwaps is AbstractRampSwaps, EthAdapter {\r\n    constructor(uint256 _chainId) public AbstractRampSwaps(_chainId) {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"setStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"revokeOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"setBuyer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"getSwapStatus\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"returnFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"approveOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldSwapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"newSwapHash\",\"type\":\"bytes32\"}],\"name\":\"BuyerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldSwapHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"newSwapHash\",\"type\":\"bytes32\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"SenderReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Returned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"SenderReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"StatusChanged\",\"type\":\"event\"}]","ContractName":"EthRampSwaps","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://d60f7c96691c0355a0f4914b706eeb0282cc54115a30bb41824d7940071e939e"}]}