{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    function changeOwner(address _addr) onlyOwner {\r\n        if (_addr == 0x0) throw;\r\n        owner = _addr;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Mutex is Owned {\r\n    bool locked = false;\r\n    modifier mutexed {\r\n        if (locked) throw;\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function unMutex() onlyOwner {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n\r\ncontract Rental is Owned {\r\n    function Rental(address _owner) {\r\n        if (_owner == 0x0) throw;\r\n        owner = _owner;\r\n    }\r\n\r\n    function offer(address from, uint num) {\r\n\r\n    }\r\n\r\n    function claimBalance(address) returns(uint) {\r\n        return 0;\r\n    }\r\n\r\n    function exec(address dest) onlyOwner {\r\n        if (!dest.call(msg.data)) throw;\r\n    }\r\n}\r\n\r\ncontract Token is Owned, Mutex {\r\n    uint ONE = 10**8;\r\n    uint price = 5000;\r\n    Ledger ledger;\r\n    Rental rentalContract;\r\n    uint8 rollOverTime = 4;\r\n    uint8 startTime = 8;\r\n    bool live = false;\r\n    address club;\r\n    uint lockedSupply = 0;\r\n    string public name;\r\n    uint8 public decimals; \r\n    string public symbol;     \r\n    string public version = '0.2';  \r\n    bool transfersOn = true;\r\n\r\n\r\n\r\n    function Token(address _owner, string _tokenName, uint8 _decimals, string _symbol, address _ledger, address _rental) {\r\n        if (_owner == 0x0) throw;\r\n        owner = _owner;\r\n\r\n        name = _tokenName;\r\n        decimals = _decimals;\r\n        symbol = _symbol;\r\n        ONE = 10**uint(decimals);\r\n        ledger = Ledger(_ledger);\r\n        rentalContract = Rental(_rental);\r\n    }\r\n\r\n    /*\r\n    *   Bookkeeping and Admin Functions\r\n    */\r\n\r\n    event LedgerUpdated(address,address);\r\n\r\n    function changeClub(address _addr) onlyOwner {\r\n        if (_addr == 0x0) throw;\r\n\r\n        club = _addr;\r\n    }\r\n\r\n    function changePrice(uint _num) onlyOwner {\r\n        price = _num;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) returns (uint) {\r\n        if ((a + b) < a) throw;\r\n        return (a + b);\r\n    }\r\n\r\n    function changeLedger(address _addr) onlyOwner {\r\n        if (_addr == 0x0) throw;\r\n\r\n        LedgerUpdated(msg.sender, _addr);\r\n        ledger = Ledger(_addr);\r\n    }\r\n\r\n    function changeRental(address _addr) onlyOwner {\r\n        if (_addr == 0x0) throw;\r\n        rentalContract = Rental(_addr);\r\n    }\r\n\r\n    function changeTimes(uint8 _rollOver, uint8 _start) onlyOwner {\r\n        rollOverTime = _rollOver;\r\n        startTime = _start;\r\n    }\r\n\r\n    /*\r\n    * Locking is a feature that turns a user's balances into\r\n    * un-issued tokens, taking them out of an account and reducing the supply.\r\n    * Diluting is so named to remind the caller that they are changing the money supply.\r\n        */\r\n\r\n    function lock(address _seizeAddr) onlyOwner mutexed {\r\n        uint myBalance = ledger.balanceOf(_seizeAddr);\r\n\r\n        lockedSupply += myBalance;\r\n        ledger.setBalance(_seizeAddr, 0);\r\n    }\r\n\r\n    event Dilution(address, uint);\r\n\r\n    function dilute(address _destAddr, uint amount) onlyOwner {\r\n        if (amount > lockedSupply) throw;\r\n\r\n        Dilution(_destAddr, amount);\r\n\r\n        lockedSupply -= amount;\r\n\r\n        uint curBalance = ledger.balanceOf(_destAddr);\r\n        curBalance = safeAdd(amount, curBalance);\r\n        ledger.setBalance(_destAddr, curBalance);\r\n    }\r\n\r\n    /* \r\n     * Crowdsale -- \r\n     *\r\n     */\r\n    function completeCrowdsale() onlyOwner {\r\n        // Lock unsold tokens\r\n        // allow transfers for arbitrary owners\r\n        transfersOn = true;\r\n        lock(owner);\r\n    }\r\n\r\n    function pauseTransfers() onlyOwner {\r\n        transfersOn = false;\r\n    }\r\n\r\n    function resumeTransfers() onlyOwner {\r\n        transfersOn = true;\r\n    }\r\n\r\n    /*\r\n    * Renting -- Logic TBD later. For now, we trust the rental contract\r\n    * to manage everything about the rentals, including bookkeeping on earnings\r\n    * and returning tokens.\r\n    */\r\n\r\n    function rentOut(uint num) {\r\n        if (ledger.balanceOf(msg.sender) < num) throw;\r\n        rentalContract.offer(msg.sender, num);\r\n        ledger.tokenTransfer(msg.sender, rentalContract, num);\r\n    }\r\n\r\n    function claimUnrented() {  \r\n        uint amount = rentalContract.claimBalance(msg.sender); // this should reduce sender's claimableBalance to 0\r\n\r\n        ledger.tokenTransfer(rentalContract, msg.sender, amount);\r\n    }\r\n\r\n    /*\r\n    * Burning -- We allow any user to burn tokens.\r\n    *\r\n     */\r\n\r\n    function burn(uint _amount) {\r\n        uint balance = ledger.balanceOf(msg.sender);\r\n        if (_amount > balance) throw;\r\n\r\n        ledger.setBalance(msg.sender, balance - _amount);\r\n    }\r\n\r\n    /*\r\n    Entry\r\n    */\r\n    function checkIn(uint _numCheckins) returns(bool) {\r\n        int needed = int(price * ONE* _numCheckins);\r\n        if (int(ledger.balanceOf(msg.sender)) > needed) {\r\n            ledger.changeUsed(msg.sender, needed);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // ERC20 Support. This could also use the fallback but\r\n    // I prefer the control for now.\r\n\r\n    event Transfer(address, address, uint);\r\n    event Approval(address, address, uint);\r\n\r\n    function totalSupply() constant returns(uint) {\r\n        return ledger.totalSupply();\r\n    }\r\n\r\n    function transfer(address _to, uint _amount) returns(bool) {\r\n        if (!transfersOn && msg.sender != owner) return false;\r\n        if (! ledger.tokenTransfer(msg.sender, _to, _amount)) { return false; }\r\n\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _amount) returns (bool) {\r\n        if (!transfersOn && msg.sender != owner) return false;\r\n        if (! ledger.tokenTransferFrom(msg.sender, _from, _to, _amount) ) { return false;}\r\n\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _from, address _to) constant returns(uint) {\r\n        return ledger.allowance(_from, _to); \r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        if ( ledger.tokenApprove(msg.sender, _spender, _value) ) {\r\n            Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function balanceOf(address _addr) constant returns(uint) {\r\n        return ledger.balanceOf(_addr);\r\n    }\r\n}\r\n\r\ncontract Ledger is Owned {\r\n    mapping (address => uint) balances;\r\n    mapping (address => uint) usedToday;\r\n\r\n    mapping (address => bool) seenHere;\r\n    address[] public seenHereA;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    address token;\r\n    uint public totalSupply = 0;\r\n\r\n    function Ledger(address _owner, uint _preMined, uint ONE) {\r\n        if (_owner == 0x0) throw;\r\n        owner = _owner;\r\n\r\n        seenHere[_owner] = true;\r\n        seenHereA.push(_owner);\r\n\r\n        totalSupply = _preMined *ONE;\r\n        balances[_owner] = totalSupply;\r\n    }\r\n\r\n    modifier onlyToken {\r\n        if (msg.sender != token) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenOrOwner {\r\n        if (msg.sender != token && msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    function tokenTransfer(address _from, address _to, uint amount) onlyToken returns(bool) {\r\n        if (amount > balances[_from]) return false;\r\n        if ((balances[_to] + amount) < balances[_to]) return false;\r\n        if (amount == 0) { return false; }\r\n\r\n        balances[_from] -= amount;\r\n        balances[_to] += amount;\r\n\r\n        if (seenHere[_to] == false) {\r\n            seenHereA.push(_to);\r\n            seenHere[_to] = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function tokenTransferFrom(address _sender, address _from, address _to, uint amount) onlyToken returns(bool) {\r\n        if (allowed[_from][_sender] <= amount) return false;\r\n        if (amount > balanceOf(_from)) return false;\r\n        if (amount == 0) return false;\r\n\r\n        if ((balances[_to] + amount) < amount) return false;\r\n\r\n        balances[_from] -= amount;\r\n        balances[_to] += amount;\r\n        allowed[_from][_sender] -= amount;\r\n\r\n        if (seenHere[_to] == false) {\r\n            seenHereA.push(_to);\r\n            seenHere[_to] = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function changeUsed(address _addr, int amount) onlyToken {\r\n        int myToday = int(usedToday[_addr]) + amount;\r\n        usedToday[_addr] = uint(myToday);\r\n    }\r\n\r\n    function resetUsedToday(uint8 startI, uint8 numTimes) onlyTokenOrOwner returns(uint8) {\r\n        uint8 numDeleted;\r\n        for (uint i = 0; i < numTimes && i + startI < seenHereA.length; i++) {\r\n            if (usedToday[seenHereA[i+startI]] != 0) { \r\n                delete usedToday[seenHereA[i+startI]];\r\n                numDeleted++;\r\n            }\r\n        }\r\n        return numDeleted;\r\n    }\r\n\r\n    function balanceOf(address _addr) constant returns (uint) {\r\n        // don't forget to subtract usedToday\r\n        if (usedToday[_addr] >= balances[_addr]) { return 0;}\r\n        return balances[_addr] - usedToday[_addr];\r\n    }\r\n\r\n    event Approval(address, address, uint);\r\n\r\n    function tokenApprove(address _from, address _spender, uint256 _value) onlyToken returns (bool) {\r\n        allowed[_from][_spender] = _value;\r\n        Approval(_from, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function changeToken(address _token) onlyOwner {\r\n        token = Token(_token);\r\n    }\r\n\r\n    function reduceTotalSupply(uint amount) onlyToken {\r\n        if (amount > totalSupply) throw;\r\n\r\n        totalSupply -= amount;    \r\n    }\r\n\r\n    function setBalance(address _addr, uint amount) onlyTokenOrOwner {\r\n        if (balances[_addr] == amount) { return; }\r\n        if (balances[_addr] < amount) {\r\n            // increasing totalSupply\r\n            uint increase = amount - balances[_addr];\r\n            totalSupply += increase;\r\n        } else {\r\n            // decreasing totalSupply\r\n            uint decrease = balances[_addr] - amount;\r\n            //TODO: safeSub\r\n            totalSupply -= decrease;\r\n        }\r\n        balances[_addr] = amount;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unMutex\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeRental\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rollOver\",\"type\":\"uint8\"},{\"name\":\"_start\",\"type\":\"uint8\"}],\"name\":\"changeTimes\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"completeCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeLedger\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimUnrented\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"rentOut\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeClub\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"dilute\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numCheckins\",\"type\":\"uint256\"}],\"name\":\"checkIn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seizeAddr\",\"type\":\"address\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_ledger\",\"type\":\"address\"},{\"name\":\"_rental\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"address\"}],\"name\":\"LedgerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Dilution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.12+commit.194ff033","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fbb1b73c4f0bda4f67dca266ce6ef42f520fbb9800000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000100000000000000000000000000ee57d52408be2fe49999fe09a16dc0a9e0545aeb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044d4f52450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044d4f524500000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://b6b9ce3166f8a0a4722cc970140ce4c176a7bf2bf8aaebfdb103180f2929a19f"}]}