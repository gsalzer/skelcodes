{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/ExpectedRateInterface.sol\r\n\r\ninterface ExpectedRateInterface {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\n// File: contracts/FeeBurnerInterface.sol\r\n\r\ninterface FeeBurnerInterface {\r\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\r\n    function setReserveData(address reserve, uint feesInBps, address kncWallet) public;\r\n}\r\n\r\n// File: contracts/KyberNetworkInterface.sol\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress,\r\n        uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n// File: contracts/KyberReserveInterface.sol\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/Utils2.sol\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/WhiteListInterface.sol\r\n\r\ncontract WhiteListInterface {\r\n    function getUserCapInWei(address user) external view returns (uint userCapWei);\r\n}\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Withdrawable.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/KyberNetwork.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private guardCounter = 1;\r\n\r\n    /**\r\n     * @dev Prevents a function from calling itself, directly or indirectly.\r\n     * Calling one `nonReentrant` function from\r\n     * another is not supported. Instead, you can implement a\r\n     * `private` function doing the actual work, and an `external`\r\n     * wrapper marked as `nonReentrant`.\r\n     */\r\n    modifier nonReentrant() {\r\n        guardCounter += 1;\r\n        uint256 localCounter = guardCounter;\r\n        _;\r\n        require(localCounter == guardCounter);\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title Kyber Network main contract\r\ncontract KyberNetwork is Withdrawable, Utils2, KyberNetworkInterface, ReentrancyGuard {\r\n\r\n    bytes public constant PERM_HINT = \"PERM\";\r\n    uint  public constant PERM_HINT_GET_RATE = 1 << 255; // for get rate. bit mask hint.\r\n\r\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\r\n    KyberReserveInterface[] public reserves;\r\n    mapping(address=>ReserveType) public reserveType;\r\n    WhiteListInterface public whiteListContract;\r\n    ExpectedRateInterface public expectedRateContract;\r\n    FeeBurnerInterface    public feeBurnerContract;\r\n    address               public kyberNetworkProxyContract;\r\n    uint                  public maxGasPriceValue = 50 * 1000 * 1000 * 1000; // 50 gwei\r\n    bool                  public isEnabled = false; // network is enabled\r\n    mapping(bytes32=>uint) public infoFields; // this is only a UI field for external app.\r\n\r\n    mapping(address=>address[]) public reservesPerTokenSrc; //reserves supporting token to eth\r\n    mapping(address=>address[]) public reservesPerTokenDest;//reserves support eth to token\r\n\r\n    enum ReserveType {NONE, PERMISSIONED, PERMISSIONLESS}\r\n    bytes internal constant EMPTY_HINT = \"\";\r\n\r\n    function KyberNetwork(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    event EtherReceival(address indexed sender, uint amount);\r\n\r\n    /* solhint-disable no-complex-fallback */\r\n    // To avoid users trying to swap tokens using default payable function. We added this short code\r\n    //  to verify Ethers will be received only from reserves if transferred without a specific function call.\r\n    function() public payable {\r\n        require(reserveType[msg.sender] != ReserveType.NONE);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }\r\n    /* solhint-enable no-complex-fallback */\r\n\r\n    struct TradeInput {\r\n        address trader;\r\n        ERC20 src;\r\n        uint srcAmount;\r\n        ERC20 dest;\r\n        address destAddress;\r\n        uint maxDestAmount;\r\n        uint minConversionRate;\r\n        address walletId;\r\n        bytes hint;\r\n    }\r\n\r\n    function tradeWithHint(\r\n        address trader,\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId,\r\n        bytes hint\r\n    )\r\n        public\r\n        nonReentrant\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(msg.sender == kyberNetworkProxyContract);\r\n        require((hint.length == 0) || (hint.length == 4));\r\n\r\n        TradeInput memory tradeInput;\r\n\r\n        tradeInput.trader = trader;\r\n        tradeInput.src = src;\r\n        tradeInput.srcAmount = srcAmount;\r\n        tradeInput.dest = dest;\r\n        tradeInput.destAddress = destAddress;\r\n        tradeInput.maxDestAmount = maxDestAmount;\r\n        tradeInput.minConversionRate = minConversionRate;\r\n        tradeInput.walletId = walletId;\r\n        tradeInput.hint = hint;\r\n\r\n        return trade(tradeInput);\r\n    }\r\n\r\n    event AddReserveToNetwork(KyberReserveInterface indexed reserve, bool add, bool isPermissionless);\r\n\r\n    /// @notice can be called only by operator\r\n    /// @dev add or deletes a reserve to/from the network.\r\n    /// @param reserve The reserve address.\r\n    /// @param isPermissionless is the new reserve from permissionless type.\r\n    function addReserve(KyberReserveInterface reserve, bool isPermissionless) public onlyOperator\r\n        returns(bool)\r\n    {\r\n        require(reserveType[reserve] == ReserveType.NONE);\r\n        reserves.push(reserve);\r\n\r\n        reserveType[reserve] = isPermissionless ? ReserveType.PERMISSIONLESS : ReserveType.PERMISSIONED;\r\n\r\n        AddReserveToNetwork(reserve, true, isPermissionless);\r\n\r\n        return true;\r\n    }\r\n\r\n    event RemoveReserveFromNetwork(KyberReserveInterface reserve);\r\n\r\n    /// @notice can be called only by operator\r\n    /// @dev removes a reserve from Kyber network.\r\n    /// @param reserve The reserve address.\r\n    /// @param index in reserve array.\r\n    function removeReserve(KyberReserveInterface reserve, uint index) public onlyOperator\r\n        returns(bool)\r\n    {\r\n\r\n        require(reserveType[reserve] != ReserveType.NONE);\r\n        require(reserves[index] == reserve);\r\n\r\n        reserveType[reserve] = ReserveType.NONE;\r\n        reserves[index] = reserves[reserves.length - 1];\r\n        reserves.length--;\r\n\r\n        RemoveReserveFromNetwork(reserve);\r\n\r\n        return true;\r\n    }\r\n\r\n    event ListReservePairs(address indexed reserve, ERC20 src, ERC20 dest, bool add);\r\n\r\n    /// @notice can be called only by operator\r\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserve The reserve address.\r\n    /// @param token token address\r\n    /// @param ethToToken will it support ether to token trade\r\n    /// @param tokenToEth will it support token to ether trade\r\n    /// @param add If true then list this pair, otherwise unlist it.\r\n    function listPairForReserve(address reserve, ERC20 token, bool ethToToken, bool tokenToEth, bool add)\r\n        public\r\n        onlyOperator\r\n        returns(bool)\r\n    {\r\n        require(reserveType[reserve] != ReserveType.NONE);\r\n\r\n        if (ethToToken) {\r\n            listPairs(reserve, token, false, add);\r\n\r\n            ListReservePairs(reserve, ETH_TOKEN_ADDRESS, token, add);\r\n        }\r\n\r\n        if (tokenToEth) {\r\n            listPairs(reserve, token, true, add);\r\n\r\n            if (add) {\r\n                require(token.approve(reserve, 2**255)); // approve infinity\r\n            } else {\r\n                require(token.approve(reserve, 0));\r\n            }\r\n\r\n            ListReservePairs(reserve, token, ETH_TOKEN_ADDRESS, add);\r\n        }\r\n\r\n        setDecimals(token);\r\n\r\n        return true;\r\n    }\r\n\r\n    event WhiteListContractSet(WhiteListInterface newContract, WhiteListInterface currentContract);\r\n\r\n    ///@param whiteList can be empty\r\n    function setWhiteList(WhiteListInterface whiteList) public onlyAdmin {\r\n        WhiteListContractSet(whiteList, whiteListContract);\r\n        whiteListContract = whiteList;\r\n    }\r\n\r\n    event ExpectedRateContractSet(ExpectedRateInterface newContract, ExpectedRateInterface currentContract);\r\n\r\n    function setExpectedRate(ExpectedRateInterface expectedRate) public onlyAdmin {\r\n        require(expectedRate != address(0));\r\n\r\n        ExpectedRateContractSet(expectedRate, expectedRateContract);\r\n        expectedRateContract = expectedRate;\r\n    }\r\n\r\n    event FeeBurnerContractSet(FeeBurnerInterface newContract, FeeBurnerInterface currentContract);\r\n\r\n    function setFeeBurner(FeeBurnerInterface feeBurner) public onlyAdmin {\r\n        require(feeBurner != address(0));\r\n\r\n        FeeBurnerContractSet(feeBurner, feeBurnerContract);\r\n        feeBurnerContract = feeBurner;\r\n    }\r\n\r\n    event KyberNetwrokParamsSet(uint maxGasPrice, uint negligibleRateDiff);\r\n\r\n    function setParams(\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_negligibleRateDiff <= 100 * 100); // at most 100%\r\n\r\n        maxGasPriceValue = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n        KyberNetwrokParamsSet(maxGasPriceValue, negligibleRateDiff);\r\n    }\r\n\r\n    event KyberNetworkSetEnable(bool isEnabled);\r\n\r\n    function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n            require(kyberNetworkProxyContract != address(0));\r\n        }\r\n        isEnabled = _enable;\r\n\r\n        KyberNetworkSetEnable(isEnabled);\r\n    }\r\n\r\n    function setInfo(bytes32 field, uint value) public onlyOperator {\r\n        infoFields[field] = value;\r\n    }\r\n\r\n    event KyberProxySet(address proxy, address sender);\r\n\r\n    function setKyberProxy(address networkProxy) public onlyAdmin {\r\n        require(networkProxy != address(0));\r\n        kyberNetworkProxyContract = networkProxy;\r\n        KyberProxySet(kyberNetworkProxyContract, msg.sender);\r\n    }\r\n\r\n    /// @dev returns number of reserves\r\n    /// @return number of reserves\r\n    function getNumReserves() public view returns(uint) {\r\n        return reserves.length;\r\n    }\r\n\r\n    /// @notice should be called off chain\r\n    /// @dev get an array of all reserves\r\n    /// @return An array of all reserves\r\n    function getReserves() public view returns(KyberReserveInterface[]) {\r\n        return reserves;\r\n    }\r\n\r\n    function maxGasPrice() public view returns(uint) {\r\n        return maxGasPriceValue;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns(uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        bool includePermissionless = true;\r\n\r\n        if (srcQty & PERM_HINT_GET_RATE > 0) {\r\n            includePermissionless = false;\r\n            srcQty = srcQty & ~PERM_HINT_GET_RATE;\r\n        }\r\n\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty, includePermissionless);\r\n    }\r\n\r\n    function getExpectedRateOnlyPermission(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns(uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty, false);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        if (whiteListContract == address(0)) return (2 ** 255);\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) {\r\n        //future feature\r\n        user;\r\n        token;\r\n        require(false);\r\n    }\r\n\r\n    struct BestRateResult {\r\n        uint rate;\r\n        address reserve1;\r\n        address reserve2;\r\n        uint weiAmount;\r\n        uint rateSrcToEth;\r\n        uint rateEthToDest;\r\n        uint destAmount;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /// @return obsolete - used to return best reserve index. not relevant anymore for this API.\r\n    function findBestRate(ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint obsolete, uint rate) {\r\n        BestRateResult memory result = findBestRateTokenToToken(src, dest, srcAmount, EMPTY_HINT);\r\n        return(0, result.rate);\r\n    }\r\n\r\n    function findBestRateOnlyPermission(ERC20 src, ERC20 dest, uint srcAmount)\r\n        public\r\n        view\r\n        returns(uint obsolete, uint rate)\r\n    {\r\n        BestRateResult memory result = findBestRateTokenToToken(src, dest, srcAmount, PERM_HINT);\r\n        return(0, result.rate);\r\n    }\r\n\r\n    function enabled() public view returns(bool) {\r\n        return isEnabled;\r\n    }\r\n\r\n    function info(bytes32 field) public view returns(uint) {\r\n        return infoFields[field];\r\n    }\r\n\r\n    /* solhint-disable code-complexity */\r\n    // Regarding complexity. Below code follows the required algorithm for choosing a reserve.\r\n    //  It has been tested, reviewed and found to be clear enough.\r\n    //@dev this function always src or dest are ether. can't do token to token\r\n    function searchBestRate(ERC20 src, ERC20 dest, uint srcAmount, bool usePermissionless)\r\n        public\r\n        view\r\n        returns(address, uint)\r\n    {\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n\r\n        //return 1 for ether to ether\r\n        if (src == dest) return (reserves[bestReserve], PRECISION);\r\n\r\n        address[] memory reserveArr;\r\n\r\n        reserveArr = src == ETH_TOKEN_ADDRESS ? reservesPerTokenDest[dest] : reservesPerTokenSrc[src];\r\n\r\n        if (reserveArr.length == 0) return (reserves[bestReserve], bestRate);\r\n\r\n        uint[] memory rates = new uint[](reserveArr.length);\r\n        uint[] memory reserveCandidates = new uint[](reserveArr.length);\r\n\r\n        for (uint i = 0; i < reserveArr.length; i++) {\r\n            //list all reserves that have this token.\r\n            if (!usePermissionless && reserveType[reserveArr[i]] == ReserveType.PERMISSIONLESS) {\r\n                continue;\r\n            }\r\n\r\n            rates[i] = (KyberReserveInterface(reserveArr[i])).getConversionRate(src, dest, srcAmount, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < reserveArr.length; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                bestReserve = reserveCandidates[uint(block.blockhash(block.number-1)) % numRelevantReserves];\r\n            } else {\r\n                bestReserve = reserveCandidates[0];\r\n            }\r\n\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (reserveArr[bestReserve], bestRate);\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function findBestRateTokenToToken(ERC20 src, ERC20 dest, uint srcAmount, bytes hint) internal view\r\n        returns(BestRateResult result)\r\n    {\r\n        //by default we use permission less reserves\r\n        bool usePermissionless = true;\r\n\r\n        // if hint in first 4 bytes == 'PERM' only permissioned reserves will be used.\r\n        if ((hint.length >= 4) && (keccak256(hint[0], hint[1], hint[2], hint[3]) == keccak256(PERM_HINT))) {\r\n            usePermissionless = false;\r\n        }\r\n\r\n        (result.reserve1, result.rateSrcToEth) =\r\n            searchBestRate(src, ETH_TOKEN_ADDRESS, srcAmount, usePermissionless);\r\n\r\n        result.weiAmount = calcDestAmount(src, ETH_TOKEN_ADDRESS, srcAmount, result.rateSrcToEth);\r\n\r\n        (result.reserve2, result.rateEthToDest) =\r\n            searchBestRate(ETH_TOKEN_ADDRESS, dest, result.weiAmount, usePermissionless);\r\n\r\n        result.destAmount = calcDestAmount(ETH_TOKEN_ADDRESS, dest, result.weiAmount, result.rateEthToDest);\r\n\r\n        result.rate = calcRateFromQty(srcAmount, result.destAmount, getDecimals(src), getDecimals(dest));\r\n    }\r\n\r\n    function listPairs(address reserve, ERC20 token, bool isTokenToEth, bool add) internal {\r\n        uint i;\r\n        address[] storage reserveArr = reservesPerTokenDest[token];\r\n\r\n        if (isTokenToEth) {\r\n            reserveArr = reservesPerTokenSrc[token];\r\n        }\r\n\r\n        for (i = 0; i < reserveArr.length; i++) {\r\n            if (reserve == reserveArr[i]) {\r\n                if (add) {\r\n                    break; //already added\r\n                } else {\r\n                    //remove\r\n                    reserveArr[i] = reserveArr[reserveArr.length - 1];\r\n                    reserveArr.length--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (add && i == reserveArr.length) {\r\n            //if reserve wasn't found add it\r\n            reserveArr.push(reserve);\r\n        }\r\n    }\r\n\r\n    event KyberTrade(address indexed trader, ERC20 src, ERC20 dest, uint srcAmount, uint dstAmount,\r\n        address destAddress, uint ethWeiValue, address reserve1, address reserve2, bytes hint);\r\n\r\n    /* solhint-disable function-max-lines */\r\n    //  Most of the lines here are functions calls spread over multiple lines. We find this function readable enough\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev trade api for kyber network.\r\n    /// @param tradeInput structure of trade inputs\r\n    function trade(TradeInput tradeInput) internal returns(uint) {\r\n        require(isEnabled);\r\n        require(tx.gasprice <= maxGasPriceValue);\r\n        require(validateTradeInput(tradeInput.src, tradeInput.srcAmount, tradeInput.dest, tradeInput.destAddress));\r\n\r\n        BestRateResult memory rateResult =\r\n            findBestRateTokenToToken(tradeInput.src, tradeInput.dest, tradeInput.srcAmount, tradeInput.hint);\r\n\r\n        require(rateResult.rate > 0);\r\n        require(rateResult.rate < MAX_RATE);\r\n        require(rateResult.rate >= tradeInput.minConversionRate);\r\n\r\n        uint actualDestAmount;\r\n        uint weiAmount;\r\n        uint actualSrcAmount;\r\n\r\n        (actualSrcAmount, weiAmount, actualDestAmount) = calcActualAmounts(tradeInput.src,\r\n            tradeInput.dest,\r\n            tradeInput.srcAmount,\r\n            tradeInput.maxDestAmount,\r\n            rateResult);\r\n\r\n        require(getUserCapInWei(tradeInput.trader) >= weiAmount);\r\n        require(handleChange(tradeInput.src, tradeInput.srcAmount, actualSrcAmount, tradeInput.trader));\r\n\r\n        require(doReserveTrade(     //src to ETH\r\n                tradeInput.src,\r\n                actualSrcAmount,\r\n                ETH_TOKEN_ADDRESS,\r\n                this,\r\n                weiAmount,\r\n                KyberReserveInterface(rateResult.reserve1),\r\n                rateResult.rateSrcToEth,\r\n                true));\r\n\r\n        require(doReserveTrade(     //Eth to dest\r\n                ETH_TOKEN_ADDRESS,\r\n                weiAmount,\r\n                tradeInput.dest,\r\n                tradeInput.destAddress,\r\n                actualDestAmount,\r\n                KyberReserveInterface(rateResult.reserve2),\r\n                rateResult.rateEthToDest,\r\n                true));\r\n\r\n        if (tradeInput.src != ETH_TOKEN_ADDRESS) //\"fake\" trade. (ether to ether) - don't burn.\r\n            require(feeBurnerContract.handleFees(weiAmount, rateResult.reserve1, tradeInput.walletId));\r\n        if (tradeInput.dest != ETH_TOKEN_ADDRESS) //\"fake\" trade. (ether to ether) - don't burn.\r\n            require(feeBurnerContract.handleFees(weiAmount, rateResult.reserve2, tradeInput.walletId));\r\n\r\n        KyberTrade({\r\n            trader: tradeInput.trader,\r\n            src: tradeInput.src,\r\n            dest: tradeInput.dest,\r\n            srcAmount: actualSrcAmount,\r\n            dstAmount: actualDestAmount,\r\n            destAddress: tradeInput.destAddress,\r\n            ethWeiValue: weiAmount,\r\n            reserve1: (tradeInput.src == ETH_TOKEN_ADDRESS) ? address(0) : rateResult.reserve1,\r\n            reserve2:  (tradeInput.dest == ETH_TOKEN_ADDRESS) ? address(0) : rateResult.reserve2,\r\n            hint: tradeInput.hint\r\n        });\r\n\r\n        return actualDestAmount;\r\n    }\r\n    /* solhint-enable function-max-lines */\r\n\r\n    function calcActualAmounts (ERC20 src, ERC20 dest, uint srcAmount, uint maxDestAmount, BestRateResult rateResult)\r\n        internal view returns(uint actualSrcAmount, uint weiAmount, uint actualDestAmount)\r\n    {\r\n        if (rateResult.destAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            weiAmount = calcSrcAmount(ETH_TOKEN_ADDRESS, dest, actualDestAmount, rateResult.rateEthToDest);\r\n            actualSrcAmount = calcSrcAmount(src, ETH_TOKEN_ADDRESS, weiAmount, rateResult.rateSrcToEth);\r\n            require(actualSrcAmount <= srcAmount);\r\n        } else {\r\n            actualDestAmount = rateResult.destAmount;\r\n            actualSrcAmount = srcAmount;\r\n            weiAmount = rateResult.weiAmount;\r\n        }\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a reserve\r\n    /// @param src Src token\r\n    /// @param amount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param reserve Reserve to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is successful\r\n    function doReserveTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserveInterface reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n\r\n        if (src == dest) {\r\n            //this is for a \"fake\" trade when both src and dest are ethers.\r\n            if (destAddress != (address(this)))\r\n                destAddress.transfer(amount);\r\n            return true;\r\n        }\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (destAddress != address(this)) {\r\n            //for token to token dest address is network. and Ether / token already here...\r\n            if (dest == ETH_TOKEN_ADDRESS) {\r\n                destAddress.transfer(expectedDestAmount);\r\n            } else {\r\n                require(dest.transfer(destAddress, expectedDestAmount));\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// when user sets max dest amount we could have too many source tokens == change. so we send it back to user.\r\n    function handleChange (ERC20 src, uint srcAmount, uint requiredSrcAmount, address trader) internal returns (bool) {\r\n\r\n        if (requiredSrcAmount < srcAmount) {\r\n            //if there is \"change\" send back to trader\r\n            if (src == ETH_TOKEN_ADDRESS) {\r\n                trader.transfer(srcAmount - requiredSrcAmount);\r\n            } else {\r\n                require(src.transfer(trader, (srcAmount - requiredSrcAmount)));\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @return true if tradeInput is valid\r\n    function validateTradeInput(ERC20 src, uint srcAmount, ERC20 dest, address destAddress)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(srcAmount != 0);\r\n        require(destAddress != address(0));\r\n        require(src != dest);\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == srcAmount);\r\n        } else {\r\n            require(msg.value == 0);\r\n            //funds should have been moved to this contract already.\r\n            require(src.balanceOf(this) >= srcAmount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/ExpectedRate.sol\r\n\r\ncontract ExpectedRate is Withdrawable, ExpectedRateInterface, Utils2 {\r\n\r\n    KyberNetwork public kyberNetwork;\r\n    uint public quantityFactor = 2;\r\n    uint public worstCaseRateFactorInBps = 50;\r\n    uint constant UNIT_QTY_FOR_FEE_BURNER = 10 ** 18;\r\n    ERC20 public knc;\r\n\r\n    function ExpectedRate(KyberNetwork _kyberNetwork, ERC20 _knc, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_knc != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        admin = _admin;\r\n        knc = _knc;\r\n    }\r\n\r\n    event QuantityFactorSet (uint newFactor, uint oldFactor, address sender);\r\n\r\n    function setQuantityFactor(uint newFactor) public onlyOperator {\r\n        require(newFactor <= 100);\r\n\r\n        QuantityFactorSet(newFactor, quantityFactor, msg.sender);\r\n        quantityFactor = newFactor;\r\n    }\r\n\r\n    event MinSlippageFactorSet (uint newMin, uint oldMin, address sender);\r\n\r\n    function setWorstCaseRateFactor(uint bps) public onlyOperator {\r\n        require(bps <= 100 * 100);\r\n\r\n        MinSlippageFactorSet(bps, worstCaseRateFactorInBps, msg.sender);\r\n        worstCaseRateFactorInBps = bps;\r\n    }\r\n\r\n    //@dev when srcQty too small or 0 the expected rate will be calculated without quantity,\r\n    // will enable rate reference before committing to any quantity\r\n    //@dev when srcQty too small (no actual dest qty) slippage rate will be 0.\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(quantityFactor != 0);\r\n        require(srcQty <= MAX_QTY);\r\n        require(srcQty * quantityFactor <= MAX_QTY);\r\n\r\n        if (srcQty == 0) srcQty = 1;\r\n\r\n        bool didRevert = false;\r\n\r\n        (didRevert, expectedRate, slippageRate) = safeFindBestRate(src, dest, srcQty, usePermissionless);\r\n        if (didRevert) return (0, 0);\r\n\r\n        if (expectedRate == 0) {\r\n            expectedRate = expectedRateSmallQty(src, dest, srcQty, usePermissionless);\r\n        }\r\n\r\n        if (src == knc &&\r\n            dest == ETH_TOKEN_ADDRESS &&\r\n            srcQty == UNIT_QTY_FOR_FEE_BURNER )\r\n        {\r\n            if (checkKncArbitrageRate(expectedRate)) expectedRate = 0;\r\n        }\r\n\r\n        if (expectedRate > MAX_RATE) return (0, 0);\r\n\r\n        uint worstCaseSlippageRate = ((10000 - worstCaseRateFactorInBps) * expectedRate) / 10000;\r\n        if (slippageRate >= worstCaseSlippageRate) {\r\n            slippageRate = worstCaseSlippageRate;\r\n        }\r\n\r\n        return (expectedRate, slippageRate);\r\n    }\r\n\r\n    function checkKncArbitrageRate(uint currentKncToEthRate) public view returns(bool) {\r\n        uint converseRate;\r\n        uint slippage;\r\n    \t(converseRate, slippage) = getExpectedRate(ETH_TOKEN_ADDRESS, knc, UNIT_QTY_FOR_FEE_BURNER, true);\r\n        require(converseRate <= MAX_RATE && currentKncToEthRate <= MAX_RATE);\r\n        return ((converseRate * currentKncToEthRate) > (PRECISION ** 2));\r\n    }\r\n\r\n    //@dev for small src quantities dest qty might be 0, then returned rate is zero.\r\n    //@dev for backward compatibility we would like to return non zero rate (correct one) for small src qty\r\n    function expectedRateSmallQty(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)\r\n        internal view returns(uint)\r\n    {\r\n        address reserve;\r\n        uint rateSrcToEth;\r\n        uint rateEthToDest;\r\n        (reserve, rateSrcToEth) = kyberNetwork.searchBestRate(src, ETH_TOKEN_ADDRESS, srcQty, usePermissionless);\r\n\r\n        uint ethQty = calcDestAmount(src, ETH_TOKEN_ADDRESS, srcQty, rateSrcToEth);\r\n\r\n        (reserve, rateEthToDest) = kyberNetwork.searchBestRate(ETH_TOKEN_ADDRESS, dest, ethQty, usePermissionless);\r\n        return rateSrcToEth * rateEthToDest / PRECISION;\r\n    }\r\n\r\n    function safeFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bool usePermissionless)\r\n        internal view\r\n        returns (bool didRevert, uint expectedRate, uint slippageRate)\r\n    {\r\n        bytes4 sig = usePermissionless ?\r\n            bytes4(keccak256(\"findBestRate(address,address,uint256)\")) :\r\n            bytes4(keccak256(\"findBestRateOnlyPermission(address,address,uint256)\")); //Function signatures\r\n\r\n        (didRevert, expectedRate) = assemblyFindBestRate(src, dest, srcQty, sig);\r\n\r\n        if (didRevert) return (true, 0, 0);\r\n\r\n        if (quantityFactor != 1) {\r\n            (didRevert, slippageRate) = assemblyFindBestRate(src, dest, (srcQty * quantityFactor), sig);\r\n        } else {\r\n            slippageRate = expectedRate;\r\n        }\r\n    }\r\n\r\n    function assemblyFindBestRate(ERC20 src, ERC20 dest, uint srcQty, bytes4 sig)\r\n        internal view\r\n        returns (bool didRevert, uint rate)\r\n    {\r\n        address addr = address(kyberNetwork);  // kyber address\r\n        uint success;\r\n\r\n        assembly {\r\n            let x := mload(0x40)        // \"free memory pointer\"\r\n            mstore(x,sig)               // function signature\r\n            mstore(add(x,0x04),src)     // src address padded to 32 bytes\r\n            mstore(add(x,0x24),dest)    // dest padded to 32 bytes\r\n            mstore(add(x,0x44),srcQty)  // uint 32 bytes\r\n            mstore(0x40,add(x,0xa4))    // set free storage pointer to empty space after output\r\n\r\n            // input size = sig + ERC20 (address) + ERC20 + uint\r\n            // = 4 + 32 + 32 + 32 = 100 = 0x64\r\n            success := staticcall(\r\n                gas,  // gas\r\n                addr, // Kyber addr\r\n                x,    // Inputs at location x\r\n                0x64, // Inputs size bytes\r\n                add(x, 0x64),    // output storage after input\r\n                0x40) // Output size are (uint, uint) = 64 bytes\r\n\r\n            rate := mload(add(x,0x84))  //Assign 2nd output to rate, first output not used,\r\n            mstore(0x40,x)    // Set empty storage pointer back to start position\r\n        }\r\n\r\n        if (success != 1) didRevert = true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"setQuantityFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"worstCaseRateFactorInBps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quantityFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"},{\"name\":\"usePermissionless\",\"type\":\"bool\"}],\"name\":\"getExpectedRate\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bps\",\"type\":\"uint256\"}],\"name\":\"setWorstCaseRateFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"knc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currentKncToEthRate\",\"type\":\"uint256\"}],\"name\":\"checkKncArbitrageRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"name\":\"_knc\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"QuantityFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldMin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"MinSlippageFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"ExpectedRate","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009ae49c0d7f8f9ef4b864e004fe86ac8294e20950000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd20000000000000000000000000045dd1fb5756177c8a7f46362a502e0029d757187","Library":"","SwarmSource":"bzzr://920445e62a8b3f01ab70b3c5a5a6b52d03b6a825d5c0c3098aad39e7e6ee5dcb"}]}