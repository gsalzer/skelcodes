{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Betting contract\r\ncontract FomoBet  {\r\n    using SafeMath for uint;\r\n    //setup\r\n    struct bet {\r\n        address maker;\r\n        address taker;\r\n        uint256 round;\r\n        bool longOrShort;// false if maker bets round will end before - true if maker bets round will last longer then\r\n        bool validated;\r\n        uint256 betEnd; // ending time of bet \r\n        uint256 betSize; // winner gets this amount\r\n        \r\n        }\r\n    struct offer {\r\n        address maker;\r\n        uint256 amount;\r\n        bool longOrShort;// false if maker bets round will end before - true if maker bets round will last longer then\r\n        uint256 betEndInDays; // ending time of bet \r\n        uint256 betSize; // maker gives this amount for each takersize\r\n        uint256 takerSize; // for each offer taken taker gives this amount\r\n        } \r\n    \r\n    FoMo3Dlong constant FoMo3Dlong_ = FoMo3Dlong(0xA62142888ABa8370742bE823c1782D17A0389Da1);    \r\n    mapping(uint256 => bet) public placedBets;\r\n    uint256 public nextBetInLine;\r\n    mapping(uint256 => offer) public OpenOffers;\r\n    uint256 public nextBetOffer;\r\n    mapping(address => uint256) public playerVault;\r\n    // functions\r\n    function vaultToWallet() public {\r\n        \r\n        address sender = msg.sender;\r\n        require(playerVault[sender] > 0);\r\n        uint256 value = playerVault[sender];\r\n        playerVault[sender] = 0;\r\n        sender.transfer(value);\r\n        \r\n    }\r\n    function () external payable{\r\n        address sender= msg.sender;\r\n        playerVault[sender] = playerVault[sender].add(msg.value);\r\n    }\r\n    function setupOffer(uint256 amountOffers, bool longOrShort, uint256 endingInDays, uint256 makerGive, uint256 takerGive) public payable{\r\n        address sender = msg.sender;\r\n        uint256 value = msg.value;\r\n        require(value >= amountOffers.mul(makerGive));\r\n        require(makerGive > 0);\r\n        OpenOffers[nextBetOffer].maker = sender;\r\n        OpenOffers[nextBetOffer].amount = amountOffers;\r\n        OpenOffers[nextBetOffer].longOrShort = longOrShort;\r\n        OpenOffers[nextBetOffer].betEndInDays = endingInDays;\r\n        OpenOffers[nextBetOffer].betSize = makerGive;\r\n        OpenOffers[nextBetOffer].takerSize = takerGive;\r\n        \r\n        nextBetOffer++;\r\n    }\r\n    function addToExistingOffer(uint256 offerNumber, uint256 amountOffers) public payable{\r\n        address sender = msg.sender;\r\n        uint256 value = msg.value;\r\n        require(sender == OpenOffers[offerNumber].maker);\r\n        require(value >= OpenOffers[offerNumber].betSize.mul(amountOffers));\r\n        OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.add(amountOffers);\r\n    }\r\n    function removeFromExistingOffer(uint256 offerNumber, uint256 amountOffers) public {\r\n        address sender = msg.sender;\r\n        \r\n        require(sender == OpenOffers[offerNumber].maker);\r\n        require(amountOffers <= OpenOffers[offerNumber].amount);\r\n        OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers);\r\n        playerVault[sender] = playerVault[sender].add(amountOffers.mul(OpenOffers[offerNumber].betSize));\r\n    }\r\n    function takeOffer(uint256 offerNumber, uint256 amountOffers) public payable{\r\n        // \r\n        address sender = msg.sender;\r\n        uint256 value = msg.value;\r\n        uint256 timer = now;\r\n        \r\n        require(amountOffers >= OpenOffers[offerNumber].amount );\r\n        require(value >= amountOffers.mul(OpenOffers[offerNumber].takerSize));\r\n        placedBets[nextBetOffer].longOrShort = OpenOffers[offerNumber].longOrShort;\r\n        placedBets[nextBetOffer].maker = OpenOffers[offerNumber].maker;\r\n        placedBets[nextBetOffer].taker = sender;\r\n        uint256 timeframe = OpenOffers[offerNumber].betEndInDays * 1 days;\r\n        placedBets[nextBetOffer].betEnd =  timer.add(timeframe);\r\n        placedBets[nextBetOffer].round = FoMo3Dlong_.rID_();\r\n        placedBets[nextBetOffer].betSize = value.add(amountOffers.mul(OpenOffers[offerNumber].betSize));\r\n        OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers);\r\n        nextBetOffer++;\r\n    }\r\n    function validateBet(uint256 betNumber) public {\r\n        \r\n        (uint256 _end,bool _ended,uint256 _eth) = fomoroundInfo(placedBets[betNumber].round);\r\n        uint256 timer = _end;\r\n        \r\n        if(placedBets[betNumber].validated == false){\r\n            if(placedBets[betNumber].longOrShort == true){\r\n                //wincon maker\r\n                if(timer >= placedBets[betNumber].betEnd){\r\n                    placedBets[betNumber].validated = true;\r\n                    playerVault[placedBets[betNumber].maker] = playerVault[placedBets[betNumber].maker].add(placedBets[betNumber].betSize);\r\n                }\r\n                // wincon taker\r\n                if(timer < placedBets[betNumber].betEnd && _ended == true){\r\n                    placedBets[betNumber].validated = true;\r\n                    playerVault[placedBets[betNumber].taker] = playerVault[placedBets[betNumber].taker].add(placedBets[betNumber].betSize);\r\n                }\r\n            }\r\n            if(placedBets[betNumber].longOrShort == false){\r\n                //wincon taker\r\n                if(timer >= placedBets[betNumber].betEnd ){\r\n                    placedBets[betNumber].validated = true;\r\n                    playerVault[placedBets[betNumber].taker] = playerVault[placedBets[betNumber].taker].add(placedBets[betNumber].betSize);\r\n                }\r\n                // wincon maker\r\n                if(timer < placedBets[betNumber].betEnd &&  _ended == true){\r\n                    placedBets[betNumber].validated = true;\r\n                    playerVault[placedBets[betNumber].maker] = playerVault[placedBets[betNumber].maker].add(placedBets[betNumber].betSize);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function death () external {\r\n        require(msg.sender == 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220);\r\n    selfdestruct(0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220);\r\n        \r\n    }\r\n    // view function return all OpenOffers\r\n    function getOfferInfo() public view returns(address[] memory _Owner, uint256[] memory locationData , bool[] memory allows){\r\n          uint i;\r\n          address[] memory _locationOwner = new address[](nextBetOffer);\r\n          uint[] memory _locationData = new uint[](nextBetOffer*5); //Bonds + fills + vault + reinvest + divs + offernumber\r\n          bool[] memory _locationData2 = new bool[](nextBetOffer); //isAlive\r\n          uint y;\r\n          for(uint x = 0; x < nextBetOffer; x+=1){\r\n            \r\n             \r\n                _locationOwner[i] = OpenOffers[i].maker;\r\n                _locationData[y] = OpenOffers[i].amount;\r\n                _locationData[y+1] = OpenOffers[i].betEndInDays;\r\n                _locationData[y+2] = OpenOffers[i].betSize;\r\n                _locationData[y+3] = OpenOffers[i].takerSize;\r\n                _locationData[y+4] = x;// offernumber\r\n                _locationData2[i] = OpenOffers[i].longOrShort;\r\n              y += 5;\r\n              i+=1;\r\n            }\r\n          \r\n          return (_locationOwner,_locationData, _locationData2);\r\n        }\r\n        // view function return all bets\r\n        function getbetsInfo() public view returns(address[] memory _Owner, uint256[] memory locationData , bool[] memory allows){\r\n          uint i;\r\n          address[] memory _locationOwner = new address[](nextBetOffer*2);\r\n          uint[] memory _locationData = new uint[](nextBetOffer*3); //Bonds + fills + vault + reinvest + divs\r\n          bool[] memory _locationData2 = new bool[](nextBetOffer*2); //isAlive\r\n          uint y;\r\n          for(uint x = 0; x < nextBetOffer; x+=1){\r\n            \r\n             \r\n                _locationOwner[i] = placedBets[i].maker;\r\n                _locationOwner[i+1] = placedBets[i].taker;\r\n                _locationData[y] = placedBets[i].round;\r\n                _locationData[y+1] = placedBets[i].betEnd;\r\n                _locationData[y+2] = placedBets[i].betSize;\r\n                _locationData2[i] = placedBets[i].validated;\r\n                _locationData2[i+1] = placedBets[i].longOrShort;\r\n              y += 3;\r\n              i+=2;\r\n            }\r\n          \r\n          return (_locationOwner,_locationData, _locationData2);\r\n        }\r\n        function fomoround () public view returns(uint256 roundNumber){\r\n            uint256 round = FoMo3Dlong_.rID_();\r\n            return(round);\r\n        }//FoMo3Dlong_.rID_();\r\n        function fomoroundInfo (uint256 roundNumber) public view returns(uint256 _end,bool _ended,uint256 _eth){\r\n           plyr = roundNumber;\r\n            \r\n            (uint256 plyr,uint256 team,uint256 end,bool ended,uint256 strt,uint256 keys,uint256 eth,uint256 pot,uint256 mask,uint256 ico,uint256 icoGen,uint256 icoAvg) = FoMo3Dlong_.round_(plyr);\r\n            return( end, ended, eth);\r\n        }\r\n}\r\n// setup fomo interface\r\ninterface FoMo3Dlong {\r\n    \r\n    function rID_() external view returns(uint256);\r\n    function round_(uint256) external view returns(uint256 plyr,uint256 team,uint256 end,bool ended,uint256 strt,uint256 keys,uint256 eth,uint256 pot,uint256 mask,uint256 ico,uint256 icoGen,uint256 icoAvg);\r\n//uint256 plyr,uint256 team,uint256 end,bool ended,uint256 strt,uint256 keys,uint256 eth,uint256 pot,uint256 mask,uint256 ico,uint256 icoGen,uint256 icoAvg; // average key price for ICO phase\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amountOffers\",\"type\":\"uint256\"},{\"name\":\"longOrShort\",\"type\":\"bool\"},{\"name\":\"endingInDays\",\"type\":\"uint256\"},{\"name\":\"makerGive\",\"type\":\"uint256\"},{\"name\":\"takerGive\",\"type\":\"uint256\"}],\"name\":\"setupOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerNumber\",\"type\":\"uint256\"},{\"name\":\"amountOffers\",\"type\":\"uint256\"}],\"name\":\"takeOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOfferInfo\",\"outputs\":[{\"name\":\"_Owner\",\"type\":\"address[]\"},{\"name\":\"locationData\",\"type\":\"uint256[]\"},{\"name\":\"allows\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerNumber\",\"type\":\"uint256\"},{\"name\":\"amountOffers\",\"type\":\"uint256\"}],\"name\":\"addToExistingOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fomoround\",\"outputs\":[{\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OpenOffers\",\"outputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"longOrShort\",\"type\":\"bool\"},{\"name\":\"betEndInDays\",\"type\":\"uint256\"},{\"name\":\"betSize\",\"type\":\"uint256\"},{\"name\":\"takerSize\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"placedBets\",\"outputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"longOrShort\",\"type\":\"bool\"},{\"name\":\"validated\",\"type\":\"bool\"},{\"name\":\"betEnd\",\"type\":\"uint256\"},{\"name\":\"betSize\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"death\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextBetInLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getbetsInfo\",\"outputs\":[{\"name\":\"_Owner\",\"type\":\"address[]\"},{\"name\":\"locationData\",\"type\":\"uint256[]\"},{\"name\":\"allows\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextBetOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betNumber\",\"type\":\"uint256\"}],\"name\":\"validateBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"fomoroundInfo\",\"outputs\":[{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_ended\",\"type\":\"bool\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vaultToWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerNumber\",\"type\":\"uint256\"},{\"name\":\"amountOffers\",\"type\":\"uint256\"}],\"name\":\"removeFromExistingOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"FomoBet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ca83de2fcfc3e1117c35c9235a6e237b4f6df2fc149d9934d9e138b0e820e46f"}]}