{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n//\r\n// base contract for all our horizon contracts and tokens\r\n//\r\ncontract HorizonContractBase {\r\n    // The owner of the contract, set at contract creation to the creator.\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Contract authorization - only allow the owner to perform certain actions.\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the owner can call this function.\");\r\n        _;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\r\n// \r\n// ----------------------------------------------------------------------------\r\ninterface ERC20Interface {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address approver, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed approver, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * ICOToken for the timelessluxurygroup.com by Horizon-Globex.com of Switzerland.\r\n *\r\n * An ERC20 standard\r\n *\r\n * Author: Horizon Globex GmbH Development Team\r\n *\r\n * Dev Notes\r\n *   NOTE: There is no fallback function as this contract will never contain Ether, only the ICO tokens.\r\n *   NOTE: There is no approveAndCall/receiveApproval or ERC223 functionality.\r\n *   NOTE: Coins will never be minted beyond those at contract creation.\r\n *   NOTE: Zero transfers are allowed - we don't want to break a valid transaction chain.\r\n *   NOTE: There is no selfDestruct, changeOwner or migration path - this is the only contract.\r\n */\r\n\r\n\r\ncontract ICOToken is ERC20Interface, HorizonContractBase {\r\n    using SafeMath for uint256;\r\n\r\n    // Contract authorization - only allow the official KYC provider to perform certain actions.\r\n    modifier onlyKycProvider {\r\n        require(msg.sender == regulatorApprovedKycProvider, \"Only the KYC Provider can call this function.\");\r\n        _;\r\n    }\r\n\t\r\n\t// Contract authorization - only allow the official issuer to perform certain actions.\r\n    modifier onlyIssuer {\r\n        require(msg.sender == issuer, \"Only the Issuer can call this function.\");\r\n        _;\r\n    }\r\n\r\n    // The approved KYC provider that verifies all ICO/TGE Contributors.\r\n    address public regulatorApprovedKycProvider;\r\n    \r\n    // The issuer\r\n    address public issuer;\r\n\r\n    // Public identity variables of the token used by ERC20 platforms.\r\n    string public name;\r\n    string public symbol;\r\n    \r\n    // There is no good reason to deviate from 18 decimals, see https://github.com/ethereum/EIPs/issues/724.\r\n    uint8 public decimals = 18;\r\n    \r\n    // The total supply of tokens, set at creation, decreased with burn.\r\n    uint256 public totalSupply_;\r\n\r\n    // The supply of tokens, set at creation, to be allocated for the referral bonuses.\r\n    uint256 public rewardPool_;\r\n\r\n    // The Initial Coin Offering is finished.\r\n    bool public isIcoComplete;\r\n\r\n    // The balances of all accounts.\r\n    mapping (address => uint256) public balances;\r\n\r\n    // KYC submission hashes accepted by KYC service provider for AML/KYC review.\r\n    bytes32[] public kycHashes;\r\n\r\n    // All users that have passed the external KYC verification checks.\r\n    address[] public kycValidated;\r\n\r\n    // Addresses authorized to transfer tokens on an account's behalf.\r\n    mapping (address => mapping (address => uint256)) internal allowanceCollection;\r\n\r\n    // Lookup an ICO/TGE Contributor address to see if it was referred by another address (referee => referrer).\r\n    mapping (address => address) public referredBy;\r\n\r\n    // Emitted when the Initial Coin Offering phase ends, see closeIco().\r\n    event IcoComplete();\r\n\r\n    // Notification when tokens are burned by the owner.\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    // Emitted when mint event ocurred\r\n    // added by andrewju\r\n    event Mint(address indexed from, uint256 value);\r\n\r\n    // Someone who was referred has purchased tokens, when the bonus is awarded log the details.\r\n    event ReferralRedeemed(address indexed referrer, address indexed referee, uint256 value);\r\n\r\n    /**\r\n     * Initialise contract with the 50 million initial supply tokens, allocated to\r\n     * the creator of the contract (the owner).\r\n     */\r\n    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint256 _rewardPool) public {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n        totalSupply_ = totalSupply * 10 ** uint256(decimals);   // Set the total supply of ICO Tokens.\r\n        balances[msg.sender] = totalSupply_;\r\n        rewardPool_ = _rewardPool * 10 ** uint256(decimals);   // Set the total supply of ICO Reward Tokens.\r\n        \r\n        setKycProvider(msg.sender);\r\n        setIssuer(msg.sender);\r\n        \r\n    }\r\n\r\n    /**\r\n     * The total number of tokens that exist.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * The total number of reward pool tokens that remains.\r\n     */\r\n    function rewardPool() public onlyOwner view returns (uint256) {\r\n        return rewardPool_;\r\n    }\r\n\r\n    /**\r\n     * Get the number of tokens for a specific account.\r\n     *\r\n     * @param who    The address to get the token balance of.\r\n     */\r\n    function balanceOf(address who) public view returns (uint256 balance) {\r\n        return balances[who];\r\n    }\r\n\r\n    /**\r\n     * Get the current allowanceCollection that the approver has allowed 'spender' to spend on their behalf.\r\n     *\r\n     * See also: approve() and transferFrom().\r\n     *\r\n     * @param _approver  The account that owns the tokens.\r\n     * @param _spender   The account that can spend the approver's tokens.\r\n     */\r\n    function allowance(address _approver, address _spender) public view returns (uint256) {\r\n        return allowanceCollection[_approver][_spender];\r\n    }\r\n\r\n    /**\r\n     * Add the link between the referrer and who they referred.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform offers functionality for referrers to sign-up\r\n     * to refer Contributors. Upon such referred Contributions, Company shall automatically\r\n     * award 1% of our \"owner\" ICO tokens to the referrer as coded by this Smart Contract.\r\n     *\r\n     * All referrers must successfully complete our ICO KYC review prior to being allowed on-board.\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param referrer  The person doing the referring.\r\n     * @param referee   The person that was referred.\r\n     */\r\n    function refer(address referrer, address referee) public onlyOwner {\r\n        require(referrer != address(0x0), \"Referrer cannot be null\");\r\n        require(referee != address(0x0), \"Referee cannot be null\");\r\n        require(!isIcoComplete, \"Cannot add new referrals after ICO is complete.\");\r\n\r\n        referredBy[referee] = referrer;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from the caller's account to the recipient.\r\n     *\r\n     * @param to    The address of the recipient.\r\n     * @param value The number of tokens to send.\r\n     */\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        return _transfer(msg.sender, to, value);\r\n    }\r\n\t\r\n    /**\r\n     * Transfer pre-approved tokens on behalf of an account.\r\n     *\r\n     * See also: approve() and allowance().\r\n     *\r\n     * @param from  The address of the sender\r\n     * @param to    The address of the recipient\r\n     * @param value The number of tokens to send\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(value <= allowanceCollection[from][msg.sender], \"Amount to transfer is greater than allowance.\");\r\n\t\t\r\n        allowanceCollection[from][msg.sender] = allowanceCollection[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow another address to spend tokens on your behalf.\r\n     *\r\n     * transferFrom can be called multiple times until the approved balance goes to zero.\r\n     * Subsequent calls to this function overwrite the previous balance.\r\n     * To change from a non-zero value to another non-zero value you must first set the\r\n     * allowance to zero - it is best to use safeApprove when doing this as you will\r\n     * manually have to check for transfers to ensure none happened before the zero allowance\r\n     * was set.\r\n     *\r\n     * @param _spender   The address authorized to spend your tokens.\r\n     * @param _value     The maximum amount of tokens they can spend.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        if(allowanceCollection[msg.sender][_spender] > 0 && _value != 0) {\r\n            revert(\"You cannot set a non-zero allowance to another non-zero, you must zero it first.\");\r\n        }\r\n\r\n        allowanceCollection[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow another address to spend tokens on your behalf while mitigating a double spend.\r\n     *\r\n     * Subsequent calls to this function overwrite the previous balance.\r\n     * The old value must match the current allowance otherwise this call reverts.\r\n     *\r\n     * @param spender   The address authorized to spend your tokens.\r\n     * @param value     The maximum amount of tokens they can spend.\r\n     * @param oldValue  The current allowance for this spender.\r\n     */\r\n    function safeApprove(address spender, uint256 value, uint256 oldValue) public returns (bool) {\r\n        require(spender != address(0x0), \"Cannot approve null address.\");\r\n        require(oldValue == allowanceCollection[msg.sender][spender], \"The expected old value did not match current allowance.\");\r\n\r\n        allowanceCollection[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The hash for all Know Your Customer information is calculated outside but stored here.\r\n     * This storage will be cleared once the ICO completes, see closeIco().\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's KYC app will register a hash of the Contributors\r\n     * KYC submission on the blockchain. Our Swiss financial-intermediary KYC provider will be \r\n     * notified of the submission and retrieve the Contributor data for formal review.\r\n     *\r\n     * All Contributors must successfully complete our ICO KYC review prior to being allowed on-board.\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param sha   The hash of the customer data.\r\n    */\r\n    function setKycHash(bytes32 sha) public onlyOwner {\r\n        require(!isIcoComplete, \"The ICO phase has ended, you can no longer set KYC hashes.\");\r\n\r\n        kycHashes.push(sha);\r\n    }\r\n\r\n    /**\r\n     * A user has passed KYC verification, store them on the blockchain in the order it happened.\r\n     * This will be cleared once the ICO completes, see closeIco().\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's registered KYC provider submits their approval\r\n     * for this Contributor to particpate using the ICO-Platform portal. \r\n     *\r\n     * Each Contributor will then be sent the Ethereum, Bitcoin and IBAN account numbers to\r\n     * deposit their Approved Contribution in exchange for ICO Tokens.\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param who   The user's address.\r\n     */\r\n    function kycApproved(address who) public onlyKycProvider {\r\n        require(!isIcoComplete, \"The ICO phase has ended, you can no longer approve.\");\r\n        require(who != address(0x0), \"Cannot approve a null address.\");\r\n\r\n        kycValidated.push(who);\r\n    }\r\n\r\n    /**\r\n     * Set the address that has the authority to approve users by KYC.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform shall register a fully licensed Swiss KYC\r\n     * provider to assess each potential Contributor for KYC and AML under Swiss law. \r\n     *\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param who   The address of the KYC provider.\r\n     */\r\n    function setKycProvider(address who) public onlyOwner {\r\n        regulatorApprovedKycProvider = who;\r\n    }\r\n    \r\n        /**\r\n     * Set the issuer address\r\n     *\r\n     * @param who   The address of the issuer.\r\n     */\r\n    function setIssuer(address who) public onlyOwner {\r\n        issuer = who;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Retrieve the KYC hash from the specified index.\r\n     *\r\n     * @param   index   The index into the array.\r\n     */\r\n    function getKycHash(uint256 index) public view returns (bytes32) {\r\n        return kycHashes[index];\r\n    }\r\n\r\n    /**\r\n     * Retrieve the validated KYC address from the specified index.\r\n     *\r\n     * @param   index   The index into the array.\r\n     */\r\n    function getKycApproved(uint256 index) public view returns (address) {\r\n        return kycValidated[index];\r\n    }\r\n\r\n    /**\r\n     * When someone referred (the referee) purchases tokens the referrer gets a 1% bonus from the central pool.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's portal shall award referrers as part of the ICO\r\n     * ICO Token issuance procedure as overseen by the Swiss KYC provider. \r\n     *\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param referee   The referred account who just purchased some tokens.\r\n     * @param referrer  The account that referred the one purchasing tokens.\r\n     * @param value     The number of tokens purchased by the referee.\r\n    */\r\n    function awardReferralBonus(address referee, address referrer, uint256 value) private {\r\n        uint256 bonus = value / 100;\r\n        balances[owner] = balances[owner].sub(bonus);\r\n        balances[referrer] = balances[referrer].add(bonus);\r\n        rewardPool_ -= bonus;\r\n        emit ReferralRedeemed(referee, referrer, bonus);\r\n    }\r\n\r\n    /**\r\n     * During the ICO phase the owner will allocate tokens once KYC completes and funds are deposited.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's portal shall issue ICO Token to Contributors on receipt of \r\n     * the Approved Contribution funds at the KYC providers Escrow account/wallets.\r\n     * Only after ICO Tokens are issued to the Contributor can the Swiss KYC provider allow the transfer\r\n     * of funds from their Escrow to Company.\r\n     *\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param to       The recipient of the tokens.\r\n     * @param value    The number of tokens to send.\r\n     */\r\n    function icoTransfer(address to, uint256 value) public onlyOwner {\r\n        require(!isIcoComplete, \"ICO is complete, use transfer().\");\r\n\r\n        // If an attempt is made to transfer more tokens than owned, transfer the remainder.\r\n        uint256 toTransfer = (value > (balances[msg.sender] - rewardPool_ )) ? (balances[msg.sender] - rewardPool_) : value;\r\n        \r\n        _transfer(msg.sender, to, toTransfer);\r\n\r\n        // Handle a referred account receiving tokens.\r\n        address referrer = referredBy[to];\r\n        if(referrer != address(0x0)) {\r\n            referredBy[to] = address(0x0);\r\n            awardReferralBonus(to, referrer, toTransfer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * End the ICO phase in accordance with KYC procedures and clean up.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's portal shall halt the ICO at the end of the \r\n     * Contribution Period, as defined in the ICO Terms and Conditions at timelessluxurygroup.com.\r\n     *\r\n     * -- End ICO-Platform Note --\r\n     */\r\n    function closeIco() public onlyOwner {\r\n        require(!isIcoComplete, \"The ICO phase has already ended, you cannot close it again.\");\r\n        require((balances[owner] - rewardPool_) == 0, \"Cannot close ICO when a balance remains in the owner account.\");\r\n\r\n        isIcoComplete = true;\r\n        delete kycHashes;\r\n        delete kycValidated;\r\n\r\n        emit IcoComplete();\r\n    }\r\n\t\r\n    /**\r\n     * Internal transfer, can only be called by this contract\r\n     *\r\n     * @param from     The sender of the tokens.\r\n     * @param to       The recipient of the tokens.\r\n     * @param value    The number of tokens to send.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal returns (bool) {\r\n        require(from != address(0x0), \"Cannot send tokens from null address\");\r\n        require(to != address(0x0), \"Cannot transfer tokens to null\");\r\n        require(balances[from] >= value, \"Insufficient funds\");\r\n\r\n        // Quick exit for zero, but allow it in case this transfer is part of a chain.\r\n        if(value == 0)\r\n            return true;\r\n\t\t\r\n        // Perform the transfer.\r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n\t\t\r\n        // Any tokens sent to to owner are implicitly burned.\r\n        if (to == owner) {\r\n            _burn(to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Permanently mint tokens to increase the totalSupply_.\r\n     *\r\n     * @param value            The number of tokens to mint.\r\n     */\r\n    function mint(uint256 value) public onlyIssuer {\r\n        require(value > 0, \"Tokens to mint must be greater than zero\");\r\n        balances[owner] = balances[owner].add(value);\r\n        totalSupply_ = totalSupply_.add(value);\r\n        \r\n        emit Mint(msg.sender, value);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Permanently destroy tokens from totalSupply_.\r\n     *\r\n     * @param value            The number of tokens to burn.\r\n     */\r\n    function burn(uint256 value) public onlyIssuer {\r\n        _burn(owner, value);\r\n    }\r\n\r\n    /**\r\n     * Permanently destroy tokens belonging to a user.\r\n     *\r\n     * @param addressToBurn    The owner of the tokens to burn.\r\n     * @param value            The number of tokens to burn.\r\n     */\r\n    function _burn(address addressToBurn, uint256 value) private returns (bool success) {\r\n        require(value > 0, \"Tokens to burn must be greater than zero\");\r\n        require(balances[addressToBurn] >= value, \"Tokens to burn exceeds balance\");\r\n\r\n        balances[addressToBurn] = balances[addressToBurn].sub(value);\r\n        totalSupply_ = totalSupply_.sub(value);\r\n\r\n        emit Burn(msg.sender, value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n * Source: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// TradeToken Standard #20 Interface\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\r\n// \r\n// ----------------------------------------------------------------------------\r\ninterface TokenInterface {\r\n    function hold(address who, uint256 quantity) external returns(bool);\r\n}\r\n\r\n/**\r\n * A version of the Regulation D contract (https://www.investopedia.com/terms/r/regulationd.asp) with the\r\n * added role of Transfer Agent to perform specialised actions.\r\n *\r\n * Part of the timelessluxurygroup.com ICO by Horizon-Globex.com of Switzerland.\r\n *\r\n * Author: Horizon Globex GmbH Development Team\r\n */\r\ncontract RegD is HorizonContractBase {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * The details of the tokens bought.\r\n     */\r\n    struct Holding {\r\n        // The number of tokens purchased.\r\n        uint256 quantity;\r\n\r\n        // The date and time when the tokens are no longer restricted.\r\n        uint256 releaseDate;\r\n\r\n        // Whether the holder is an affiliate of the company or not.\r\n        bool isAffiliate;\r\n    }\r\n\r\n    // Restrict functionality to the creator (owner) of the contract - the token issuer.\r\n    modifier onlyIssuer {\r\n        require(msg.sender == owner, \"You must be issuer/owner to execute this function.\");\r\n        _;\r\n    }\r\n\r\n    // Restrict functionaly to the official Transfer Agent.\r\n    modifier onlyTransferAgent {\r\n        require(msg.sender == transferAgent, \"You must be the Transfer Agent to execute this function.\");\r\n        _;\r\n    }\r\n\r\n    // The collection of all held tokens by user.\r\n    mapping(address => Holding) public heldTokens;\r\n\r\n    // The ICO contract, where all tokens this contract holds originate from.\r\n    address public icoContract;\r\n\r\n    // The ERC20 Token contract where tokens past their holding period are released to.\r\n    address public tokenContract;\r\n\r\n    // The authorised Transfer Agent who performs specialist actions on this contract.\r\n    address public transferAgent;\r\n\r\n    // Number of seconds a holding is held for before it can be released.\r\n    uint256 public expiry = 0;\r\n\r\n    // Emitted when someone subject to Regulation D buys tokens and they are held here.\r\n    event TokensHeld(address indexed who, uint256 tokens, uint256 releaseDate);\r\n\r\n    // Emitted when the tokens have passed their release date and have been returned to the original owner.\r\n    event TokensReleased(address indexed who, uint256 tokens);\r\n\r\n    // The Transfer Agent moved tokens from an address to a new wallet, for escheatment obligations.\r\n    event TokensTransferred(address indexed from, address indexed to, uint256 tokens);\r\n\r\n    // The Transfer Agent was unable to verify a token holder and needed to push out the release date.\r\n    event ReleaseDateChanged(address who, uint256 oldReleaseDate, uint256 newReleaseDate);\r\n\r\n    // Extra restrictions apply to company affiliates, notify when the status of an address changes.\r\n    event AffiliateStatusChanged(address who, bool isAffiliate);\r\n\r\n    /**\r\n     * @notice Create this contract and assign the ICO contract where the tokens originate from.\r\n     *\r\n     * @param icoContract_      The address of the ICO contract.\r\n     * @param expiry_           The number of seconds after holding before the tokens can be released.\r\n     */\r\n    constructor(address icoContract_, uint256 expiry_) public {\r\n        icoContract = icoContract_;\r\n        expiry = expiry_;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of the contract where tokens are released to after the holding period.\r\n     *\r\n     * @param tokenContract_    The contract address.\r\n     */\r\n    function setTokenContract(address tokenContract_) public onlyIssuer {\r\n        tokenContract = tokenContract_;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of the Transfer Agent.\r\n     *\r\n     * @param who   The wallet id of the Transfer Agent.\r\n     */\r\n    function setTransferAgent(address who) public onlyIssuer {\r\n        transferAgent = who;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the expiry for subsequent holdings, existing holdings are not affected.\r\n     *\r\n     * @param expiry_   The number of seconds after holding before the tokens can be released.\r\n     */\r\n    function setExpiry(uint256 expiry_) public onlyIssuer {\r\n        expiry = expiry_;\r\n    }\r\n\r\n    /**\r\n     * @notice Keep a US Citizen's tokens for one year.\r\n     *\r\n     * @param who           The wallet of the US Citizen.\r\n     * @param quantity      The number of tokens to store.\r\n     */\r\n    function hold(address who, uint256 quantity) public onlyIssuer {\r\n        require(who != address(0x0), \"The null address cannot own tokens.\");\r\n        require(quantity != 0, \"Quantity must be greater than zero.\");\r\n        require(!isExistingHolding(who), \"Cannot overwrite an existing holding, use a new wallet.\");\r\n\r\n        // Create the holding for the customer who will get these tokens once custody ends.\r\n        Holding memory holding = Holding(quantity, block.timestamp+expiry, false);\r\n        heldTokens[who] = holding;\r\n        emit TokensHeld(who, holding.quantity, holding.releaseDate);\r\n    }\r\n\t\r\n    /**\r\n     * @notice Hold tokens post-ICO with a variable release date on those tokens.\r\n     *\r\n     * @param who           The wallet of the US Citizen.\r\n     * @param quantity      The number of tokens to store.\r\n\t * @param addedTime\t\tThe number of seconds to add to the current date to calculate the release date.\r\n     */\r\n    function postIcoHold(address who, uint256 quantity, uint256 addedTime) public onlyTransferAgent {\r\n        require(who != address(0x0), \"The null address cannot own tokens.\");\r\n        require(quantity != 0, \"Quantity must be greater than zero.\");\r\n        require(!isExistingHolding(who), \"Cannot overwrite an existing holding, use a new wallet.\");\r\n\r\n        bool res = ERC20Interface(icoContract).transferFrom(who, address(this), quantity);\r\n        require(res, \"Unable to complete Post-ICO Custody, token contract transfer failed.\");\r\n        if(res) {\r\n            Holding memory holding = Holding(quantity, block.timestamp+addedTime, false);\r\n            heldTokens[who] = holding;\r\n            emit TokensHeld(who, holding.quantity, holding.releaseDate);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Check if a user's holding are eligible for release.\r\n    *\r\n    * @param who        The user to check the holding of.\r\n    * @return           True if can be released, false if not.\r\n    */\r\n    function canRelease(address who) public view returns (bool) {\r\n        Holding memory holding = heldTokens[who];\r\n        if(holding.releaseDate == 0 || holding.quantity == 0)\r\n            return false;\r\n\r\n        return block.timestamp > holding.releaseDate;\r\n    }\r\n\r\n    /**\r\n     * @notice Release the tokens once the holding period expires, transferring them back to the ERC20 contract to the holder.\r\n     *\r\n     * NOTE: This function preserves the isAffiliate flag of the holder.\r\n     *\r\n     * @param who       The owner of the tokens.\r\n     * @return          True on successful release, false on error.\r\n     */\r\n    function release(address who) public onlyTransferAgent returns (bool) {\r\n        require(tokenContract != address(0x0), \"ERC20 Token contract is null, nowhere to release to.\");\r\n        Holding memory holding = heldTokens[who];\r\n        require(!holding.isAffiliate, \"To release tokens for an affiliate use partialRelease().\");\r\n\r\n        if(block.timestamp > holding.releaseDate) {\r\n            // Transfer the tokens from this contract's ownership to the original owner.\r\n            bool res = TokenInterface(tokenContract).hold(who, holding.quantity);\r\n            if(res) {\r\n                heldTokens[who] = Holding(0, 0, holding.isAffiliate);\r\n                emit TokensReleased(who, holding.quantity);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\t\r\n    /**\r\n     * @notice Release some of an affiliate's tokens to a broker/trading wallet.\r\n     *\r\n     * @param who       \t\tThe owner of the tokens.\r\n\t * @param tradingWallet\t\tThe broker/trader receiving the tokens.\r\n\t * @param amount \t\t\tThe number of tokens to release to the trading wallet.\r\n     */\r\n    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {\r\n        require(tokenContract != address(0x0), \"ERC20 Token contract is null, nowhere to release to.\");\r\n        require(tradingWallet != address(0x0), \"The destination wallet cannot be null.\");\r\n        require(!isExistingHolding(tradingWallet), \"The destination wallet must be a new fresh wallet.\");\r\n        Holding memory holding = heldTokens[who];\r\n        require(holding.isAffiliate, \"Only affiliates can use this function; use release() for non-affiliates.\");\r\n        require(amount <= holding.quantity, \"The holding has less than the specified amount of tokens.\");\r\n\r\n        if(block.timestamp > holding.releaseDate) {\r\n\r\n            // Send the tokens currently held by this contract on behalf of 'who' to the nominated wallet.\r\n            bool res = TokenInterface(tokenContract).hold(tradingWallet, amount);\r\n            if(res) {\r\n                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);\r\n                emit TokensReleased(who, amount);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Under special circumstances the Transfer Agent needs to move tokens around.\r\n     *\r\n     * @dev As the release date is accurate to one second it is very unlikely release dates will\r\n     * match so an address that does not have a holding in this contract is required as the target.\r\n     *\r\n     * @param from      The current holder of the tokens.\r\n     * @param to        The recipient of the tokens - must be a 'clean' address.\r\n     * @param amount    The number of tokens to move.\r\n     */\r\n    function transfer(address from, address to, uint256 amount) public onlyTransferAgent returns (bool) {\r\n        require(to != address(0x0), \"Cannot transfer tokens to the null address.\");\r\n        require(amount > 0, \"Cannot transfer zero tokens.\");\r\n        Holding memory fromHolding = heldTokens[from];\r\n        require(fromHolding.quantity >= amount, \"Not enough tokens to perform the transfer.\");\r\n        require(!isExistingHolding(to), \"Cannot overwrite an existing holding, use a new wallet.\");\r\n\r\n        heldTokens[from] = Holding(fromHolding.quantity.sub(amount), fromHolding.releaseDate, fromHolding.isAffiliate);\r\n        heldTokens[to] = Holding(amount, fromHolding.releaseDate, false);\r\n\r\n        emit TokensTransferred(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice The Transfer Agent may need to add time to the release date if they are unable to verify\r\n     * the holder in a timely manner.\r\n     *\r\n     * @param who       The holder of the tokens.\r\n     * @param tSeconds    The number of seconds to add to the release date.  NOTE: 'tSeconds' appears to\r\n     *                  be a reserved word.\r\n     */\r\n    function addTime(address who, int tSeconds) public onlyTransferAgent returns (bool) {\r\n        require(tSeconds != 0, \"Time added cannot be zero.\");\r\n        \r\n        Holding memory holding = heldTokens[who];\r\n        uint256 oldDate = holding.releaseDate;\r\n        uint256 newDate = tSeconds < 0 ? holding.releaseDate.sub(uint(-tSeconds)) : holding.releaseDate.add(uint(tSeconds));\r\n        heldTokens[who] = Holding(holding.quantity, newDate, holding.isAffiliate);\r\n        \r\n        emit ReleaseDateChanged(who, oldDate, heldTokens[who].releaseDate);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Company affiliates have added restriction, allow the Transfer Agent set/clear this flag\r\n     * as needed.\r\n     *\r\n     * @param who           The address being affiliated/unaffiliated.\r\n     * @param isAffiliate   Whether the address is an affiliate or not.\r\n     */\r\n    function setAffiliate(address who, bool isAffiliate) public onlyTransferAgent returns (bool) {\r\n        require(who != address(0x0), \"The null address cannot be used.\");\r\n\r\n        Holding memory holding = heldTokens[who];\r\n        require(holding.isAffiliate != isAffiliate, \"Attempt to set the same affiliate status that is already set.\");\r\n\r\n        heldTokens[who] = Holding(holding.quantity, holding.releaseDate, isAffiliate);\r\n\r\n        emit AffiliateStatusChanged(who, isAffiliate);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a wallet is already in use, only new/fresh/clean wallets can hold tokens.\r\n     *\r\n     * @param who   The wallet to check.\r\n     * @return      True if the wallet is in use, false otherwise.\r\n     */\r\n    function isExistingHolding(address who) public view returns (bool) {\r\n        Holding memory h = heldTokens[who];\r\n        return (h.quantity != 0 || h.releaseDate != 0);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"expiry_\",\"type\":\"uint256\"}],\"name\":\"setExpiry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"tSeconds\",\"type\":\"int256\"}],\"name\":\"addTime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"canRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"isAffiliate\",\"type\":\"bool\"}],\"name\":\"setAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"hold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isExistingHolding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"tradingWallet\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"partialRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContract_\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"addedTime\",\"type\":\"uint256\"}],\"name\":\"postIcoHold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"heldTokens\",\"outputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"releaseDate\",\"type\":\"uint256\"},{\"name\":\"isAffiliate\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expiry\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"icoContract_\",\"type\":\"address\"},{\"name\":\"expiry_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"releaseDate\",\"type\":\"uint256\"}],\"name\":\"TokensHeld\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"TokensReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"TokensTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldReleaseDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newReleaseDate\",\"type\":\"uint256\"}],\"name\":\"ReleaseDateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAffiliate\",\"type\":\"bool\"}],\"name\":\"AffiliateStatusChanged\",\"type\":\"event\"}]","ContractName":"RegD","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009d5949e224fb235a9ebd4e91a3712264b1be94a90000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://d192b1e8677e62b5960df3cf25c7456aa086b9136ac05dc4ad6f8eed601a9e6d"}]}