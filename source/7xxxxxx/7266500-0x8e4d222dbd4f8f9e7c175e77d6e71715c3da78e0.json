{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/token/IETokenProxy.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Interface of an upgradable token\r\n * @dev See implementation for\r\n */\r\ninterface IETokenProxy {\r\n\r\n    /* solium-disable zeppelin/missing-natspec-comments */\r\n\r\n    /* Taken from ERC20Detailed in openzeppelin-solidity */\r\n    function nameProxy(address sender) external view returns(string);\r\n\r\n    function symbolProxy(address sender)\r\n        external\r\n        view\r\n        returns(string);\r\n\r\n    function decimalsProxy(address sender)\r\n        external\r\n        view\r\n        returns(uint8);\r\n\r\n    /* Taken from IERC20 in openzeppelin-solidity */\r\n    function totalSupplyProxy(address sender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOfProxy(address sender, address who)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowanceProxy(address sender,\r\n                            address owner,\r\n                            address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferProxy(address sender, address to, uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    function approveProxy(address sender,\r\n                          address spender,\r\n                          uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFromProxy(address sender,\r\n                               address from,\r\n                               address to,\r\n                               uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    function mintProxy(address sender, address to, uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    function changeMintingRecipientProxy(address sender,\r\n                                         address mintingRecip)\r\n        external;\r\n\r\n    function burnProxy(address sender, uint256 value) external;\r\n\r\n    function burnFromProxy(address sender,\r\n                           address from,\r\n                           uint256 value)\r\n        external;\r\n\r\n    function increaseAllowanceProxy(address sender,\r\n                                    address spender,\r\n                                    uint addedValue)\r\n        external\r\n        returns (bool success);\r\n\r\n    function decreaseAllowanceProxy(address sender,\r\n                                    address spender,\r\n                                    uint subtractedValue)\r\n        external\r\n        returns (bool success);\r\n\r\n    function pauseProxy(address sender) external;\r\n\r\n    function unpauseProxy(address sender) external;\r\n\r\n    function pausedProxy(address sender) external view returns (bool);\r\n\r\n    function finalizeUpgrade() external;\r\n}\r\n\r\n// File: contracts/token/IEToken.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title EToken interface\r\n * @dev The interface comprising an EToken contract\r\n * This interface is a superset of the ERC20 interface defined at\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IEToken {\r\n\r\n    /* solium-disable zeppelin/missing-natspec-comments */\r\n\r\n    function upgrade(IETokenProxy upgradedToken) external;\r\n\r\n    /* Taken from ERC20Detailed in openzeppelin-solidity */\r\n    function name() external view returns(string);\r\n\r\n    function symbol() external view returns(string);\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /* Taken from IERC20 in openzeppelin-solidity */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    /* Taken from ERC20Mintable */\r\n    function mint(address to, uint256 value) external returns (bool);\r\n\r\n    /* Taken from ERC20Burnable */\r\n    function burn(uint256 value) external;\r\n\r\n    function burnFrom(address from, uint256 value) external;\r\n\r\n    /* Taken from ERC20Pausable */\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint addedValue\r\n    )\r\n        external\r\n        returns (bool success);\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    function paused() external view returns (bool);\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint subtractedValue\r\n    )\r\n        external\r\n        returns (bool success);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/token/ERC20/Storage.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title External ERC20 Storage\r\n *\r\n * @dev The storage contract used in ExternalERC20 token. This contract can\r\n * provide storage for exactly one contract, referred to as the implementor,\r\n * inheriting from the ExternalERC20 contract. Only the current implementor or\r\n * the owner can transfer the implementorship. Change of state is only allowed\r\n * by the implementor.\r\n */\r\ncontract Storage is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    uint256 private totalSupply;\r\n\r\n    address private _implementor;\r\n\r\n    event StorageImplementorTransferred(address indexed from,\r\n                                        address indexed to);\r\n\r\n    /**\r\n     * @dev Contructor.\r\n     * @param owner The address of the owner of the contract.\r\n     * Must not be the zero address.\r\n     * @param implementor The address of the contract that is\r\n     * allowed to change state. Must not be the zero address.\r\n     */\r\n    constructor(address owner, address implementor) public {\r\n\r\n        require(\r\n            owner != address(0),\r\n            \"Owner should not be the zero address\"\r\n        );\r\n\r\n        require(\r\n            implementor != address(0),\r\n            \"Implementor should not be the zero address\"\r\n        );\r\n\r\n        transferOwnership(owner);\r\n        _implementor = implementor;\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether the sender is an implementor.\r\n     */\r\n    function isImplementor() public view returns(bool) {\r\n        return msg.sender == _implementor;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets new balance.\r\n     * Can only be done by owner or implementor contract.\r\n     */\r\n    function setBalance(address owner,\r\n                        uint256 value)\r\n        public\r\n        onlyImplementor\r\n    {\r\n        balances[owner] = value;\r\n    }\r\n\r\n    /**\r\n     * @dev Increases the balances relatively\r\n     * @param owner the address for which to increase balance\r\n     * @param addedValue the value to increase with\r\n     */\r\n    function increaseBalance(address owner, uint256 addedValue)\r\n        public\r\n        onlyImplementor\r\n    {\r\n        balances[owner] = balances[owner].add(addedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Decreases the balances relatively\r\n     * @param owner the address for which to decrease balance\r\n     * @param subtractedValue the value to decrease with\r\n     */\r\n    function decreaseBalance(address owner, uint256 subtractedValue)\r\n        public\r\n        onlyImplementor\r\n    {\r\n        balances[owner] = balances[owner].sub(subtractedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Can only be done by owner or implementor contract.\r\n     * @return The current balance of owner\r\n     */\r\n    function getBalance(address owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets new allowance.\r\n     * Can only be called by implementor contract.\r\n     */\r\n    function setAllowed(address owner,\r\n                        address spender,\r\n                        uint256 value)\r\n        public\r\n        onlyImplementor\r\n    {\r\n        allowed[owner][spender] = value;\r\n    }\r\n\r\n    /**\r\n     * @dev Increases the allowance relatively\r\n     * @param owner the address for which to allow from\r\n     * @param spender the addres for which the allowance increase is granted\r\n     * @param addedValue the value to increase with\r\n     */\r\n    function increaseAllowed(\r\n        address owner,\r\n        address spender,\r\n        uint256 addedValue\r\n    )\r\n        public\r\n        onlyImplementor\r\n    {\r\n        allowed[owner][spender] = allowed[owner][spender].add(addedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Decreases the allowance relatively\r\n     * @param owner the address for which to allow from\r\n     * @param spender the addres for which the allowance decrease is granted\r\n     * @param subtractedValue the value to decrease with\r\n     */\r\n    function decreaseAllowed(\r\n        address owner,\r\n        address spender,\r\n        uint256 subtractedValue\r\n    )\r\n        public\r\n        onlyImplementor\r\n    {\r\n        allowed[owner][spender] = allowed[owner][spender].sub(subtractedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Can only be called by implementor contract.\r\n     * @return The current allowance for spender from owner\r\n     */\r\n    function getAllowed(address owner,\r\n                        address spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Change totalSupply.\r\n     * Can only be called by implementor contract.\r\n     */\r\n    function setTotalSupply(uint256 value)\r\n        public\r\n        onlyImplementor\r\n    {\r\n        totalSupply = value;\r\n    }\r\n\r\n    /**\r\n     * @dev Can only be called by implementor contract.\r\n     * @return Current supply\r\n     */\r\n    function getTotalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer implementor to new contract\r\n     * Can only be called by owner or implementor contract.\r\n     */\r\n    function transferImplementor(address newImplementor)\r\n        public\r\n        requireNonZero(newImplementor)\r\n        onlyImplementorOrOwner\r\n    {\r\n        require(newImplementor != _implementor,\r\n                \"Cannot transfer to same implementor as existing\");\r\n        address curImplementor = _implementor;\r\n        _implementor = newImplementor;\r\n        emit StorageImplementorTransferred(curImplementor, newImplementor);\r\n    }\r\n\r\n    /**\r\n     * @dev Asserts that sender is either owner or implementor.\r\n     */\r\n    modifier onlyImplementorOrOwner() {\r\n        require(isImplementor() || isOwner(), \"Is not implementor or owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Asserts that sender is the implementor.\r\n     */\r\n    modifier onlyImplementor() {\r\n        require(isImplementor(), \"Is not implementor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Asserts that the given address is not the null-address\r\n     */\r\n    modifier requireNonZero(address addr) {\r\n        require(addr != address(0), \"Expected a non-zero address\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Internal implementation of ERC20 functionality with support\r\n * for a separate storage contract\r\n */\r\ncontract ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    Storage private externalStorage;\r\n\r\n    string private name_;\r\n    string private symbol_;\r\n    uint8 private decimals_;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param name The ERC20 detailed token name\r\n     * @param symbol The ERC20 detailed symbol name\r\n     * @param decimals Determines the number of decimals of this token\r\n     * @param _externalStorage The external storage contract.\r\n     * Should be zero address if shouldCreateStorage is true.\r\n     * @param initialDeployment Defines whether it should\r\n     * create a new external storage. Should be false if\r\n     * externalERC20Storage is defined.\r\n     */\r\n    constructor(\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals,\r\n        Storage _externalStorage,\r\n        bool initialDeployment\r\n    )\r\n        public\r\n    {\r\n\r\n        require(\r\n            (_externalStorage != address(0) && (!initialDeployment)) ||\r\n            (_externalStorage == address(0) && initialDeployment),\r\n            \"Cannot both create external storage and use the provided one.\");\r\n\r\n        name_ = name;\r\n        symbol_ = symbol;\r\n        decimals_ = decimals;\r\n\r\n        if (initialDeployment) {\r\n            externalStorage = new Storage(msg.sender, this);\r\n        } else {\r\n            externalStorage = _externalStorage;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return The storage used by this contract\r\n     */\r\n    function getExternalStorage() public view returns(Storage) {\r\n        return externalStorage;\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function _name() internal view returns(string) {\r\n        return name_;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function _symbol() internal view returns(string) {\r\n        return symbol_;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function _decimals() internal view returns(uint8) {\r\n        return decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function _totalSupply() internal view returns (uint256) {\r\n        return externalStorage.getTotalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function _balanceOf(address owner) internal view returns (uint256) {\r\n        return externalStorage.getBalance(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function _allowance(address owner, address spender)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return externalStorage.getAllowed(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param originSender The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address originSender, address to, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(to != address(0));\r\n\r\n        externalStorage.decreaseBalance(originSender, value);\r\n        externalStorage.increaseBalance(to, value);\r\n\r\n        emit Transfer(originSender, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount\r\n     * of tokens on behalf of msg.sender.  Beware that changing an\r\n     * allowance with this method brings the risk that someone may use\r\n     * both the old and the new allowance by unfortunate transaction\r\n     * ordering. One possible solution to mitigate this race condition\r\n     * is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param originSender the original transaction sender\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function _approve(address originSender, address spender, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        externalStorage.setAllowed(originSender, spender, value);\r\n        emit Approval(originSender, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param originSender the original transaction sender\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function _transferFrom(\r\n        address originSender,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n\r\n        externalStorage.decreaseAllowed(from, originSender, value);\r\n\r\n        _transfer(from, to, value);\r\n\r\n        emit Approval(\r\n            from,\r\n            originSender,\r\n            externalStorage.getAllowed(from, originSender)\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param originSender the original transaction sender\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function _increaseAllowance(\r\n        address originSender,\r\n        address spender,\r\n        uint256 addedValue\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        externalStorage.increaseAllowed(originSender, spender, addedValue);\r\n\r\n        emit Approval(\r\n            originSender, spender,\r\n            externalStorage.getAllowed(originSender, spender)\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a\r\n     * spender.  approve should be called when allowed_[_spender] ==\r\n     * 0. To decrement allowed value is better to use this function to\r\n     * avoid 2 calls (and wait until the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param originSender the original transaction sender\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function _decreaseAllowance(\r\n        address originSender,\r\n        address spender,\r\n        uint256 subtractedValue\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        externalStorage.decreaseAllowed(originSender,\r\n                                        spender,\r\n                                        subtractedValue);\r\n\r\n        emit Approval(\r\n            originSender, spender,\r\n            externalStorage.getAllowed(originSender, spender)\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal returns (bool)\r\n    {\r\n        require(account != 0);\r\n\r\n        externalStorage.setTotalSupply(\r\n            externalStorage.getTotalSupply().add(value));\r\n        externalStorage.increaseBalance(account, value);\r\n\r\n        emit Transfer(address(0), account, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param originSender The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address originSender, uint256 value) internal returns (bool)\r\n    {\r\n        require(originSender != 0);\r\n\r\n        externalStorage.setTotalSupply(\r\n            externalStorage.getTotalSupply().sub(value));\r\n        externalStorage.decreaseBalance(originSender, value);\r\n\r\n        emit Transfer(originSender, address(0), value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * @param originSender the original transaction sender\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address originSender, address account, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(value <= externalStorage.getAllowed(account, originSender));\r\n\r\n        externalStorage.decreaseAllowed(account, originSender, value);\r\n        _burn(account, value);\r\n\r\n        emit Approval(account, originSender,\r\n                      externalStorage.getAllowed(account, originSender));\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/token/UpgradeSupport.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Functionality supporting contract upgradability\r\n */\r\ncontract UpgradeSupport is Ownable, ERC20 {\r\n\r\n    event Upgraded(address indexed to);\r\n    event UpgradeFinalized(address indexed upgradedFrom);\r\n\r\n    /**\r\n     * @dev Holds the address of the contract that was upgraded from\r\n     */\r\n    address private _upgradedFrom;\r\n    bool private enabled;\r\n    IETokenProxy private upgradedToken;\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param initialDeployment Set to true if this is the initial deployment of\r\n     * the token. If true it automtically creates a new ExternalERC20Storage.\r\n     * Also, it acts as a confirmation of intention which interlocks\r\n     * upgradedFrom as follows: If initialDeployment is true, then\r\n     * upgradedFrom must be the zero address. Otherwise, upgradedFrom must not\r\n     * be the zero address. The same applies to externalERC20Storage, which must\r\n     * be set to the zero address if initialDeployment is true.\r\n     * @param upgradedFrom The token contract that this contract upgrades. Set\r\n     * to address(0) for initial deployments\r\n     */\r\n    constructor(bool initialDeployment, address upgradedFrom) internal {\r\n        require((upgradedFrom != address(0) && (!initialDeployment)) ||\r\n                (upgradedFrom == address(0) && initialDeployment),\r\n                \"Cannot both be upgraded and initial deployment.\");\r\n\r\n        if (! initialDeployment) {\r\n            // Pause until explicitly unpaused by upgraded contract\r\n            enabled = false;\r\n            _upgradedFrom = upgradedFrom;\r\n        } else {\r\n            enabled = true;\r\n        }\r\n    }\r\n\r\n    modifier upgradeExists() {\r\n        require(_upgradedFrom != address(0),\r\n                \"Must have a contract to upgrade from\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the upgraded contract in order to mark the finalization of\r\n     * the upgrade and activate the new contract\r\n     */\r\n    function finalizeUpgrade()\r\n        external\r\n        upgradeExists\r\n        onlyProxy\r\n    {\r\n        enabled = true;\r\n        emit UpgradeFinalized(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Upgrades the current token\r\n     * @param _upgradedToken The address of the token that this token\r\n     * should be upgraded to\r\n     */\r\n    function upgrade(IETokenProxy _upgradedToken) public onlyOwner {\r\n        require(!isUpgraded(), \"Token is already upgraded\");\r\n        require(_upgradedToken != IETokenProxy(0),\r\n                \"Cannot upgrade to null address\");\r\n        require(_upgradedToken != IETokenProxy(this),\r\n                \"Cannot upgrade to myself\");\r\n        require(getExternalStorage().isImplementor(),\r\n                \"I don't own my storage. This will end badly.\");\r\n\r\n        upgradedToken = _upgradedToken;\r\n        getExternalStorage().transferImplementor(_upgradedToken);\r\n        _upgradedToken.finalizeUpgrade();\r\n        emit Upgraded(_upgradedToken);\r\n    }\r\n\r\n    /**\r\n     * @return Is this token upgraded\r\n     */\r\n    function isUpgraded() public view returns (bool) {\r\n        return upgradedToken != IETokenProxy(0);\r\n    }\r\n\r\n    /**\r\n     * @return The token that this was upgraded to\r\n     */\r\n    function getUpgradedToken() public view returns (IETokenProxy) {\r\n        return upgradedToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Only allow the old contract to access the functions with explicit\r\n     * sender passing\r\n     */\r\n    modifier onlyProxy () {\r\n        require(msg.sender == _upgradedFrom,\r\n                \"Proxy is the only allowed caller\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows execution if token is enabled, i.e. it is the\r\n     * initial deployment or is upgraded from a contract which has\r\n     * called the finalizeUpgrade function.\r\n     */\r\n    modifier isEnabled () {\r\n        require(enabled, \"Token disabled\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(!has(role, account));\r\n\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(has(role, account));\r\n\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: contracts/token/access/roles/PauserRole.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/** @title Contract managing the pauser role */\r\ncontract PauserRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private pausers;\r\n\r\n    constructor() internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender), \"not pauser\");\r\n        _;\r\n    }\r\n\r\n    modifier requirePauser(address account) {\r\n        require(isPauser(account), \"not pauser\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if account is pauser\r\n     * @param account Account to check\r\n     * @return Boolean indicating if account is pauser\r\n     */\r\n    function isPauser(address account) public view returns (bool) {\r\n        return pausers.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a pauser account. Is only callable by owner.\r\n     * @param account Address to be added\r\n     */\r\n    function addPauser(address account) public onlyOwner {\r\n        _addPauser(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a pauser account. Is only callable by owner.\r\n     * @param account Address to be removed\r\n     */\r\n    function removePauser(address account) public onlyOwner {\r\n        _removePauser(account);\r\n    }\r\n\r\n    /** @dev Allows a privileged holder to renounce their role */\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    /** @dev Internal implementation of addPauser */\r\n    function _addPauser(address account) internal {\r\n        pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    /** @dev Internal implementation of removePauser */\r\n    function _removePauser(address account) internal {\r\n        pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/Pausable.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private paused_;\r\n\r\n    constructor() internal {\r\n        paused_ = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function _paused() internal view returns(bool) {\r\n        return paused_;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused_);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused_);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable if a specified account is pauser.\r\n     * @param account the address of the account to check\r\n     */\r\n    modifier requireIsPauser(address account) {\r\n        require(isPauser(account));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the owner to pause, triggers stopped state\r\n     * @param originSender the original sender of this method\r\n     */\r\n    function _pause(address originSender)\r\n        internal\r\n    {\r\n        paused_ = true;\r\n        emit Paused(originSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the owner to unpause, returns to normal state\r\n     * @param originSender the original sender of this method\r\n     */\r\n    function _unpause(address originSender)\r\n        internal\r\n    {\r\n        paused_ = false;\r\n        emit Unpaused(originSender);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/roles/WhitelistAdminRole.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/** @title Contract managing the whitelist admin role */\r\ncontract WhitelistAdminRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private whitelistAdmins;\r\n\r\n    constructor() internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender), \"not whitelistAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier requireWhitelistAdmin(address account) {\r\n        require(isWhitelistAdmin(account), \"not whitelistAdmin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if account is whitelist dmin\r\n     * @param account Account to check\r\n     * @return Boolean indicating if account is whitelist admin\r\n     */\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return whitelistAdmins.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a whitelist admin account. Is only callable by owner.\r\n     * @param account Address to be added\r\n     */\r\n    function addWhitelistAdmin(address account) public onlyOwner {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a whitelist admin account. Is only callable by owner.\r\n     * @param account Address to be removed\r\n     */\r\n    function removeWhitelistAdmin(address account) public onlyOwner {\r\n        _removeWhitelistAdmin(account);\r\n    }\r\n\r\n    /** @dev Allows a privileged holder to renounce their role */\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    /** @dev Internal implementation of addWhitelistAdmin */\r\n    function _addWhitelistAdmin(address account) internal {\r\n        whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    /** @dev Internal implementation of removeWhitelistAdmin */\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/roles/BlacklistAdminRole.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/** @title Contract managing the blacklist admin role */\r\ncontract BlacklistAdminRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event BlacklistAdminAdded(address indexed account);\r\n    event BlacklistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private blacklistAdmins;\r\n\r\n    constructor() internal {\r\n        _addBlacklistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyBlacklistAdmin() {\r\n        require(isBlacklistAdmin(msg.sender), \"not blacklistAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier requireBlacklistAdmin(address account) {\r\n        require(isBlacklistAdmin(account), \"not blacklistAdmin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if account is blacklist admin\r\n     * @param account Account to check\r\n     * @return Boolean indicating if account is blacklist admin\r\n     */\r\n    function isBlacklistAdmin(address account) public view returns (bool) {\r\n        return blacklistAdmins.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a blacklist admin account. Is only callable by owner.\r\n     * @param account Address to be added\r\n     */\r\n    function addBlacklistAdmin(address account) public onlyOwner {\r\n        _addBlacklistAdmin(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a blacklist admin account. Is only callable by owner\r\n     * @param account Address to be removed\r\n     */\r\n    function removeBlacklistAdmin(address account) public onlyOwner {\r\n        _removeBlacklistAdmin(account);\r\n    }\r\n\r\n    /** @dev Allows privilege holder to renounce their role */\r\n    function renounceBlacklistAdmin() public {\r\n        _removeBlacklistAdmin(msg.sender);\r\n    }\r\n\r\n    /** @dev Internal implementation of addBlacklistAdmin */\r\n    function _addBlacklistAdmin(address account) internal {\r\n        blacklistAdmins.add(account);\r\n        emit BlacklistAdminAdded(account);\r\n    }\r\n\r\n    /** @dev Internal implementation of removeBlacklistAdmin */\r\n    function _removeBlacklistAdmin(address account) internal {\r\n        blacklistAdmins.remove(account);\r\n        emit BlacklistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/Accesslist.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The Accesslist contract\r\n * @dev Contract that contains a whitelist and a blacklist and manages them\r\n */\r\ncontract Accesslist is WhitelistAdminRole, BlacklistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdded(address indexed account);\r\n    event WhitelistRemoved(address indexed account);\r\n    event BlacklistAdded(address indexed account);\r\n    event BlacklistRemoved(address indexed account);\r\n\r\n    Roles.Role private whitelist;\r\n    Roles.Role private blacklist;\r\n\r\n    /**\r\n     * @dev Calls internal function _addWhitelisted\r\n     * to add given address to whitelist\r\n     * @param account Address to be added\r\n     */\r\n    function addWhitelisted(address account)\r\n        public\r\n        onlyWhitelistAdmin\r\n    {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calls internal function _removeWhitelisted\r\n     * to remove given address from the whitelist\r\n     * @param account Address to be removed\r\n     */\r\n    function removeWhitelisted(address account)\r\n        public\r\n        onlyWhitelistAdmin\r\n    {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calls internal function _addBlacklisted\r\n     * to add given address to blacklist\r\n     * @param account Address to be added\r\n     */\r\n    function addBlacklisted(address account)\r\n        public\r\n        onlyBlacklistAdmin\r\n    {\r\n        _addBlacklisted(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calls internal function _removeBlacklisted\r\n     * to remove given address from blacklist\r\n     * @param account Address to be removed\r\n     */\r\n    function removeBlacklisted(address account)\r\n        public\r\n        onlyBlacklistAdmin\r\n    {\r\n        _removeBlacklisted(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks to see if the given address is whitelisted\r\n     * @param account Address to be checked\r\n     * @return true if address is whitelisted\r\n     */\r\n    function isWhitelisted(address account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return whitelist.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks to see if given address is blacklisted\r\n     * @param account Address to be checked\r\n     * @return true if address is blacklisted\r\n     */\r\n    function isBlacklisted(address account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return blacklist.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks to see if given address is whitelisted and not blacklisted\r\n     * @param account Address to be checked\r\n     * @return true if address has access\r\n     */\r\n    function hasAccess(address account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isWhitelisted(account) && !isBlacklisted(account);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Adds given address to the whitelist\r\n     * @param account Address to be added\r\n     */\r\n    function _addWhitelisted(address account) internal {\r\n        whitelist.add(account);\r\n        emit WhitelistAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes given address to the whitelist\r\n     * @param account Address to be removed\r\n     */\r\n    function _removeWhitelisted(address account) internal {\r\n        whitelist.remove(account);\r\n        emit WhitelistRemoved(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds given address to the blacklist\r\n     * @param account Address to be added\r\n     */\r\n    function _addBlacklisted(address account) internal {\r\n        blacklist.add(account);\r\n        emit BlacklistAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes given address to the blacklist\r\n     * @param account Address to be removed\r\n     */\r\n    function _removeBlacklisted(address account) internal {\r\n        blacklist.remove(account);\r\n        emit BlacklistRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/AccesslistGuarded.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title The AccesslistGuarded contract\r\n * @dev Contract containing an accesslist and\r\n * modifiers to ensure proper access\r\n */\r\ncontract AccesslistGuarded {\r\n\r\n    Accesslist private accesslist;\r\n    bool private whitelistEnabled;\r\n\r\n    /**\r\n     * @dev Constructor. Checks if the accesslist is a zero address\r\n     * @param _accesslist The access list\r\n     * @param _whitelistEnabled If the whitelist is enabled\r\n     */\r\n    constructor(\r\n        Accesslist _accesslist,\r\n        bool _whitelistEnabled\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            _accesslist != Accesslist(0),\r\n            \"Supplied accesslist is null\"\r\n        );\r\n        accesslist = _accesslist;\r\n        whitelistEnabled = _whitelistEnabled;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that requires given address\r\n     * to be whitelisted and not blacklisted\r\n     * @param account address to be checked\r\n     */\r\n    modifier requireHasAccess(address account) {\r\n        require(hasAccess(account), \"no access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that requires the message sender\r\n     * to be whitelisted and not blacklisted\r\n     */\r\n    modifier onlyHasAccess() {\r\n        require(hasAccess(msg.sender), \"no access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that requires given address\r\n     * to be whitelisted\r\n     * @param account address to be checked\r\n     */\r\n    modifier requireWhitelisted(address account) {\r\n        require(isWhitelisted(account), \"no access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that requires message sender\r\n     * to be whitelisted\r\n     */\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender), \"no access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that requires given address\r\n     * to not be blacklisted\r\n     * @param account address to be checked\r\n     */\r\n    modifier requireNotBlacklisted(address account) {\r\n        require(isNotBlacklisted(account), \"no access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that requires message sender\r\n     * to not be blacklisted\r\n     */\r\n    modifier onlyNotBlacklisted() {\r\n        require(isNotBlacklisted(msg.sender), \"no access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether account has access.\r\n     * If whitelist is enabled a whitelist check is also made,\r\n     * otherwise it only checks for blacklisting.\r\n     * @param account Address to be checked\r\n     * @return true if address has access or is not blacklisted when whitelist\r\n     * is disabled\r\n     */\r\n    function hasAccess(address account) public view returns (bool) {\r\n        if (whitelistEnabled) {\r\n            return accesslist.hasAccess(account);\r\n        } else {\r\n            return isNotBlacklisted(account);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether account is whitelisted\r\n     * @param account Address to be checked\r\n     * @return true if address is whitelisted\r\n     */\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return accesslist.isWhitelisted(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether account is not blacklisted\r\n     * @param account Address to be checked\r\n     * @return true if address is not blacklisted\r\n     */\r\n    function isNotBlacklisted(address account) public view returns (bool) {\r\n        return !accesslist.isBlacklisted(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/roles/BurnerRole.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/** @title Contract managing the burner role */\r\ncontract BurnerRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event BurnerAdded(address indexed account);\r\n    event BurnerRemoved(address indexed account);\r\n\r\n    Roles.Role private burners;\r\n\r\n    constructor() Ownable() internal {\r\n        _addBurner(msg.sender);\r\n    }\r\n\r\n    modifier onlyBurner() {\r\n        require(isBurner(msg.sender), \"not burner\");\r\n        _;\r\n    }\r\n\r\n    modifier requireBurner(address account) {\r\n        require(isBurner(account), \"not burner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if account is burner\r\n     * @param account Account to check\r\n     * @return Boolean indicating if account is burner\r\n     */\r\n    function isBurner(address account) public view returns (bool) {\r\n        return burners.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a burner account\r\n     * @dev Is only callable by owner\r\n     * @param account Address to be added\r\n     */\r\n    function addBurner(address account) public onlyOwner {\r\n        _addBurner(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a burner account\r\n     * @dev Is only callable by owner\r\n     * @param account Address to be removed\r\n     */\r\n    function removeBurner(address account) public onlyOwner {\r\n        _removeBurner(account);\r\n    }\r\n\r\n    /** @dev Allows a privileged holder to renounce their role */\r\n    function renounceBurner() public {\r\n        _removeBurner(msg.sender);\r\n    }\r\n\r\n    /** @dev Internal implementation of addBurner */\r\n    function _addBurner(address account) internal {\r\n        burners.add(account);\r\n        emit BurnerAdded(account);\r\n    }\r\n\r\n    /** @dev Internal implementation of removeBurner */\r\n    function _removeBurner(address account) internal {\r\n        burners.remove(account);\r\n        emit BurnerRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/roles/MinterRole.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/** @title The minter role contract */\r\ncontract MinterRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private minters;\r\n\r\n    /**\r\n     * @dev Checks if the message sender is a minter\r\n     */\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender), \"not minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the given address is a minter\r\n     * @param account Address to be checked\r\n     */\r\n    modifier requireMinter(address account) {\r\n        require(isMinter(account), \"not minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if given address is a minter\r\n     * @param account Address to be checked\r\n     * @return Is the address a minter\r\n     */\r\n    function isMinter(address account) public view returns (bool) {\r\n        return minters.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calls internal function _addMinter with the given address.\r\n     * Can only be called by the owner.\r\n     * @param account Address to be passed\r\n     */\r\n    function addMinter(address account) public onlyOwner {\r\n        _addMinter(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calls internal function _removeMinter with the given address.\r\n     * Can only be called by the owner.\r\n     * @param account Address to be passed\r\n     */\r\n    function removeMinter(address account) public onlyOwner {\r\n        _removeMinter(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calls internal function _removeMinter with message sender\r\n     * as the parameter\r\n     */\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds the given address to minters\r\n     * @param account Address to be added\r\n     */\r\n    function _addMinter(address account) internal {\r\n        minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes given address from minters\r\n     * @param account Address to be removed.\r\n     */\r\n    function _removeMinter(address account) internal {\r\n        minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/token/access/RestrictedMinter.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Restricted minter\r\n * @dev Implements the notion of a restricted minter which is only\r\n * able to mint to a single specified account. Only the owner may\r\n * change this account.\r\n */\r\ncontract RestrictedMinter  {\r\n\r\n    address private mintingRecipientAccount;\r\n\r\n    event MintingRecipientAccountChanged(address prev, address next);\r\n\r\n    /**\r\n     * @dev constructor. Sets minting recipient to given address\r\n     * @param _mintingRecipientAccount address to be set to recipient\r\n     */\r\n    constructor(address _mintingRecipientAccount) internal {\r\n        _changeMintingRecipient(msg.sender, _mintingRecipientAccount);\r\n    }\r\n\r\n    modifier requireMintingRecipient(address account) {\r\n        require(account == mintingRecipientAccount,\r\n                \"is not mintingRecpientAccount\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return The current minting recipient account address\r\n     */\r\n    function getMintingRecipient() public view returns (address) {\r\n        return mintingRecipientAccount;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function allowing the owner to change the current minting recipient account\r\n     * @param originSender The sender address of the request\r\n     * @param _mintingRecipientAccount address of new minting recipient\r\n     */\r\n    function _changeMintingRecipient(\r\n        address originSender,\r\n        address _mintingRecipientAccount\r\n    )\r\n        internal\r\n    {\r\n        originSender;\r\n\r\n        require(_mintingRecipientAccount != address(0),\r\n                \"zero minting recipient\");\r\n        address prev = mintingRecipientAccount;\r\n        mintingRecipientAccount = _mintingRecipientAccount;\r\n        emit MintingRecipientAccountChanged(prev, mintingRecipientAccount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/access/ETokenGuarded.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EToken access guards\r\n * @dev This contract implements access guards for functions comprising\r\n * the EToken public API. Since these functions may be called through\r\n * a proxy, access checks does not rely on the implicit value of\r\n * msg.sender but rather on the originSender parameter which is passed\r\n * to the functions of this contract. The value of originSender is\r\n * captured from msg.sender at the initial landing-point of the\r\n * request.\r\n */\r\ncontract ETokenGuarded is\r\n    Pausable,\r\n    ERC20,\r\n    UpgradeSupport,\r\n    AccesslistGuarded,\r\n    BurnerRole,\r\n    MinterRole,\r\n    RestrictedMinter\r\n{\r\n\r\n    modifier requireOwner(address addr) {\r\n        require(owner() == addr, \"is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param name The ERC20 detailed token name\r\n     * @param symbol The ERC20 detailed symbol name\r\n     * @param decimals Determines the number of decimals of this token\r\n     * @param accesslist Address of a deployed whitelist contract\r\n     * @param whitelistEnabled Create token with whitelist enabled\r\n     * @param externalStorage The external storage contract.\r\n     * Should be zero address if shouldCreateStorage is true.\r\n     * @param initialDeployment Defines whether it should\r\n     * create a new external storage. Should be false if\r\n     * externalERC20Storage is defined.\r\n     */\r\n    constructor(\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals,\r\n        Accesslist accesslist,\r\n        bool whitelistEnabled,\r\n        Storage externalStorage,\r\n        address initialMintingRecipient,\r\n        bool initialDeployment\r\n    )\r\n        internal\r\n        ERC20(name, symbol, decimals, externalStorage, initialDeployment)\r\n        AccesslistGuarded(accesslist, whitelistEnabled)\r\n        RestrictedMinter(initialMintingRecipient)\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.name. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function nameGuarded(address originSender)\r\n        internal\r\n        view\r\n        returns(string)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        return _name();\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.symbol. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function symbolGuarded(address originSender)\r\n        internal\r\n        view\r\n        returns(string)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        return _symbol();\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.decimals. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function decimalsGuarded(address originSender)\r\n        internal\r\n        view\r\n        returns(uint8)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        return _decimals();\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.totalSupply. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function totalSupplyGuarded(address originSender)\r\n        internal\r\n        view\r\n        isEnabled\r\n        returns(uint256)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        return _totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.balanceOf. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function balanceOfGuarded(address originSender, address who)\r\n        internal\r\n        view\r\n        isEnabled\r\n        returns(uint256)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        return _balanceOf(who);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.allowance. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function allowanceGuarded(\r\n        address originSender,\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        view\r\n        isEnabled\r\n        returns(uint256)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        return _allowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.transfer. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function transferGuarded(address originSender, address to, uint256 value)\r\n        internal\r\n        isEnabled\r\n        whenNotPaused\r\n        requireHasAccess(to)\r\n        requireHasAccess(originSender)\r\n        returns (bool)\r\n    {\r\n        _transfer(originSender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.approve. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function approveGuarded(\r\n        address originSender,\r\n        address spender,\r\n        uint256 value\r\n    )\r\n        internal\r\n        isEnabled\r\n        whenNotPaused\r\n        requireHasAccess(spender)\r\n        requireHasAccess(originSender)\r\n        returns (bool)\r\n    {\r\n        _approve(originSender, spender, value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.transferFrom. Also see the documentation for this\r\n     * contract.\r\n     */\r\n    function transferFromGuarded(\r\n        address originSender,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        internal\r\n        isEnabled\r\n        whenNotPaused\r\n        requireHasAccess(originSender)\r\n        requireHasAccess(from)\r\n        requireHasAccess(to)\r\n        returns (bool)\r\n    {\r\n        _transferFrom(\r\n            originSender,\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.increaseAllowance, Also see the general documentation\r\n     * for this contract.\r\n     */\r\n    function increaseAllowanceGuarded(\r\n        address originSender,\r\n        address spender,\r\n        uint256 addedValue\r\n    )\r\n        internal\r\n        isEnabled\r\n        whenNotPaused\r\n        requireHasAccess(originSender)\r\n        requireHasAccess(spender)\r\n        returns (bool)\r\n    {\r\n        _increaseAllowance(originSender, spender, addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.decreaseAllowance. Also see the general documentation\r\n     * for this contract.\r\n     */\r\n    function decreaseAllowanceGuarded(\r\n        address originSender,\r\n        address spender,\r\n        uint256 subtractedValue\r\n    )\r\n        internal\r\n        isEnabled\r\n        whenNotPaused\r\n        requireHasAccess(originSender)\r\n        requireHasAccess(spender)\r\n        returns (bool)  {\r\n        _decreaseAllowance(originSender, spender, subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.burn. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function burnGuarded(address originSender, uint256 value)\r\n        internal\r\n        isEnabled\r\n        requireBurner(originSender)\r\n    {\r\n        _burn(originSender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.burnFrom. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function burnFromGuarded(address originSender, address from, uint256 value)\r\n        internal\r\n        isEnabled\r\n        requireBurner(originSender)\r\n    {\r\n        _burnFrom(originSender, from, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.mint. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function mintGuarded(address originSender, address to, uint256 value)\r\n        internal\r\n        isEnabled\r\n        requireMinter(originSender)\r\n        requireMintingRecipient(to)\r\n        returns (bool success)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n\r\n        _mint(to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.changeMintingRecipient. Also see the general\r\n     * documentation for this contract.\r\n     */\r\n    function changeMintingRecipientGuarded(\r\n        address originSender,\r\n        address mintingRecip\r\n    )\r\n        internal\r\n        isEnabled\r\n        requireOwner(originSender)\r\n    {\r\n        _changeMintingRecipient(originSender, mintingRecip);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.pause. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function pauseGuarded(address originSender)\r\n        internal\r\n        isEnabled\r\n        requireIsPauser(originSender)\r\n        whenNotPaused\r\n    {\r\n        _pause(originSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.unpause. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function unpauseGuarded(address originSender)\r\n        internal\r\n        isEnabled\r\n        requireIsPauser(originSender)\r\n        whenPaused\r\n    {\r\n        _unpause(originSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Permission enforcing wrapper around the functionality of\r\n     * EToken.paused. Also see the general documentation for this\r\n     * contract.\r\n     */\r\n    function pausedGuarded(address originSender)\r\n        internal\r\n        view\r\n        isEnabled\r\n        returns (bool)\r\n    {\r\n        // Silence warnings\r\n        originSender;\r\n        return _paused();\r\n    }\r\n}\r\n\r\n// File: contracts/token/ETokenProxy.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EToken upgradability proxy\r\n * For every call received the following takes place:\r\n * If this token is upgraded, all calls are forwarded to the proxy\r\n * interface of the new contract thereby forming a chain of proxy\r\n * calls.\r\n * If this token is not upgraded, that is, it is the most recent\r\n * generation of ETokens, then calls are forwarded directly to the\r\n * ETokenGuarded interface which performs access\r\n */\r\ncontract ETokenProxy is IETokenProxy, ETokenGuarded {\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param name The ERC20 detailed token name\r\n     * @param symbol The ERC20 detailed symbol name\r\n     * @param decimals Determines the number of decimals of this token\r\n     * @param accesslist Address of a deployed whitelist contract\r\n     * @param whitelistEnabled Create token with whitelist enabled\r\n     * @param externalStorage The external storage contract.\r\n     * Should be zero address if shouldCreateStorage is true.\r\n     * @param initialDeployment Set to true if this is the initial deployment of\r\n     * the token. If true it automtically creates a new ExternalERC20Storage.\r\n     * Also, it acts as a confirmation of intention which interlocks\r\n     * upgradedFrom as follows: If initialDeployment is true, then\r\n     * upgradedFrom must be the zero address. Otherwise, upgradedFrom must not\r\n     * be the zero address. The same applies to externalERC20Storage, which must\r\n     * be set to the zero address if initialDeployment is true.\r\n     * @param upgradedFrom The token contract that this contract upgrades. Set\r\n     * to address(0) for initial deployments\r\n     */\r\n    constructor(\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals,\r\n        Accesslist accesslist,\r\n        bool whitelistEnabled,\r\n        Storage externalStorage,\r\n        address initialMintingRecipient,\r\n        address upgradedFrom,\r\n        bool initialDeployment\r\n    )\r\n        internal\r\n        UpgradeSupport(initialDeployment, upgradedFrom)\r\n        ETokenGuarded(\r\n            name,\r\n            symbol,\r\n            decimals,\r\n            accesslist,\r\n            whitelistEnabled,\r\n            externalStorage,\r\n            initialMintingRecipient,\r\n            initialDeployment\r\n        )\r\n    {\r\n\r\n    }\r\n\r\n    /** Like EToken.name but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function nameProxy(address sender)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns(string)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().nameProxy(sender);\r\n        } else {\r\n            return nameGuarded(sender);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function symbolProxy(address sender)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns(string)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().symbolProxy(sender);\r\n        } else {\r\n            return symbolGuarded(sender);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.decimals but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function decimalsProxy(address sender)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns(uint8)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().decimalsProxy(sender);\r\n        } else {\r\n            return decimalsGuarded(sender);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function totalSupplyProxy(address sender)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns (uint256)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().totalSupplyProxy(sender);\r\n        } else {\r\n            return totalSupplyGuarded(sender);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function balanceOfProxy(address sender, address who)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns (uint256)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().balanceOfProxy(sender, who);\r\n        } else {\r\n            return balanceOfGuarded(sender, who);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function allowanceProxy(address sender, address owner, address spender)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns (uint256)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().allowanceProxy(sender, owner, spender);\r\n        } else {\r\n            return allowanceGuarded(sender, owner, spender);\r\n        }\r\n    }\r\n\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function transferProxy(address sender, address to, uint256 value)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().transferProxy(sender, to, value);\r\n        } else {\r\n            return transferGuarded(sender, to, value);\r\n        }\r\n\r\n    }\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function approveProxy(address sender, address spender, uint256 value)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().approveProxy(sender, spender, value);\r\n        } else {\r\n            return approveGuarded(sender, spender, value);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.symbol but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function transferFromProxy(\r\n        address sender,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().transferFromProxy(\r\n                sender,\r\n                from,\r\n                to,\r\n                value\r\n            );\r\n        } else {\r\n            transferFromGuarded(\r\n                sender,\r\n                from,\r\n                to,\r\n                value\r\n            );\r\n        }\r\n    }\r\n\r\n    /** Like EToken. but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function mintProxy(address sender, address to, uint256 value)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().mintProxy(sender, to, value);\r\n        } else {\r\n            return mintGuarded(sender, to, value);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.changeMintingRecipient but proxies calls as\r\n        described in the documentation for the declaration of this\r\n        contract. */\r\n    function changeMintingRecipientProxy(address sender,\r\n                                         address mintingRecip)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n    {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().changeMintingRecipientProxy(sender, mintingRecip);\r\n        } else {\r\n            changeMintingRecipientGuarded(sender, mintingRecip);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.burn but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function burnProxy(address sender, uint256 value)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n    {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().burnProxy(sender, value);\r\n        } else {\r\n            burnGuarded(sender, value);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.burnFrom but proxies calls as described in the\r\n        documentation for the declaration of this contract. */\r\n    function burnFromProxy(address sender, address from, uint256 value)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n    {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().burnFromProxy(sender, from, value);\r\n        } else {\r\n            burnFromGuarded(sender, from, value);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.increaseAllowance but proxies calls as described\r\n        in the documentation for the declaration of this contract. */\r\n    function increaseAllowanceProxy(\r\n        address sender,\r\n        address spender,\r\n        uint addedValue\r\n    )\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().increaseAllowanceProxy(\r\n                sender, spender, addedValue);\r\n        } else {\r\n            return increaseAllowanceGuarded(sender, spender, addedValue);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.decreaseAllowance but proxies calls as described\r\n        in the documentation for the declaration of this contract. */\r\n    function decreaseAllowanceProxy(\r\n        address sender,\r\n        address spender,\r\n        uint subtractedValue\r\n    )\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().decreaseAllowanceProxy(\r\n                sender, spender, subtractedValue);\r\n        } else {\r\n            return decreaseAllowanceGuarded(sender, spender, subtractedValue);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.pause but proxies calls as described\r\n        in the documentation for the declaration of this contract. */\r\n    function pauseProxy(address sender)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n    {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().pauseProxy(sender);\r\n        } else {\r\n            pauseGuarded(sender);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.unpause but proxies calls as described\r\n        in the documentation for the declaration of this contract. */\r\n    function unpauseProxy(address sender)\r\n        external\r\n        isEnabled\r\n        onlyProxy\r\n    {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().unpauseProxy(sender);\r\n        } else {\r\n            unpauseGuarded(sender);\r\n        }\r\n    }\r\n\r\n    /** Like EToken.paused but proxies calls as described\r\n        in the documentation for the declaration of this contract. */\r\n    function pausedProxy(address sender)\r\n        external\r\n        view\r\n        isEnabled\r\n        onlyProxy\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().pausedProxy(sender);\r\n        } else {\r\n            return pausedGuarded(sender);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/token/EToken.sol\r\n\r\n/**\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 eToroX Labs\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/** @title Main EToken contract */\r\ncontract EToken is IEToken, ETokenProxy {\r\n\r\n    /**\r\n     * @param name The name of the token\r\n     * @param symbol The symbol of the token\r\n     * @param decimals The number of decimals of the token\r\n     * @param accesslist Address of a deployed whitelist contract\r\n     * @param whitelistEnabled Create token with whitelist enabled\r\n     * @param externalStorage Address of a deployed ERC20 storage contract\r\n     * @param initialMintingRecipient The initial minting recipient of the token\r\n     * @param upgradedFrom The token contract that this contract upgrades. Set\r\n     * to address(0) for initial deployments\r\n     * @param initialDeployment Set to true if this is the initial deployment of\r\n     * the token. If true it automtically creates a new ExternalERC20Storage.\r\n     * Also, it acts as a confirmation of intention which interlocks\r\n     * upgradedFrom as follows: If initialDeployment is true, then\r\n     * upgradedFrom must be the zero address. Otherwise, upgradedFrom must not\r\n     * be the zero address. The same applies to externalERC20Storage, which must\r\n     * be set to the zero address if initialDeployment is true.\r\n     */\r\n    constructor(\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals,\r\n        Accesslist accesslist,\r\n        bool whitelistEnabled,\r\n        Storage externalStorage,\r\n        address initialMintingRecipient,\r\n        address upgradedFrom,\r\n        bool initialDeployment\r\n    )\r\n        public\r\n        ETokenProxy(\r\n            name,\r\n            symbol,\r\n            decimals,\r\n            accesslist,\r\n            whitelistEnabled,\r\n            externalStorage,\r\n            initialMintingRecipient,\r\n            upgradedFrom,\r\n            initialDeployment\r\n        )\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns(string) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().nameProxy(msg.sender);\r\n        } else {\r\n            return nameGuarded(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns(string) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().symbolProxy(msg.sender);\r\n        } else {\r\n            return symbolGuarded(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public view returns(uint8) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().decimalsProxy(msg.sender);\r\n        } else {\r\n            return decimalsGuarded(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @return Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().totalSupplyProxy(msg.sender);\r\n        } else {\r\n            return totalSupplyGuarded(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param who The address to query the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address who) public view returns (uint256) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().balanceOfProxy(msg.sender, who);\r\n        } else {\r\n            return balanceOfGuarded(msg.sender, who);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner\r\n     * allowed to a spender.\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available\r\n     * for the spender.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().allowanceProxy(\r\n                msg.sender,\r\n                owner,\r\n                spender\r\n            );\r\n        } else {\r\n            return allowanceGuarded(msg.sender, owner, spender);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().transferProxy(msg.sender, to, value);\r\n        } else {\r\n            return transferGuarded(msg.sender, to, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount\r\n     * of tokens on behalf of msg.sender.  Beware that changing an\r\n     * allowance with this method brings the risk that someone may use\r\n     * both the old and the new allowance by unfortunate transaction\r\n     * ordering. One possible solution to mitigate this race condition\r\n     * is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().approveProxy(msg.sender, spender, value);\r\n        } else {\r\n            return approveGuarded(msg.sender, spender, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().transferFromProxy(\r\n                msg.sender,\r\n                from,\r\n                to,\r\n                value\r\n            );\r\n        } else {\r\n            return transferFromGuarded(\r\n                msg.sender,\r\n                from,\r\n                to,\r\n                value\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param value The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address to, uint256 value) public returns (bool) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().mintProxy(msg.sender, to, value);\r\n        } else {\r\n            return mintGuarded(msg.sender, to, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 value) public {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().burnProxy(msg.sender, value);\r\n        } else {\r\n            burnGuarded(msg.sender, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens from the target address\r\n     * and decrements allowance\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param from address The address which you want to send tokens from\r\n     * @param value uint256 The amount of token to be burned\r\n     */\r\n    function burnFrom(address from, uint256 value) public {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().burnFromProxy(msg.sender, from, value);\r\n        } else {\r\n            burnFromGuarded(msg.sender, from, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint addedValue\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().increaseAllowanceProxy(\r\n                msg.sender,\r\n                spender,\r\n                addedValue\r\n            );\r\n        } else {\r\n            return increaseAllowanceGuarded(msg.sender, spender, addedValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @dev Proxies call to new token if this token is upgraded\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint subtractedValue\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().decreaseAllowanceProxy(\r\n                msg.sender,\r\n                spender,\r\n                subtractedValue\r\n            );\r\n        } else {\r\n            return super.decreaseAllowanceGuarded(\r\n                msg.sender,\r\n                spender,\r\n                subtractedValue\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to change the current minting recipient account\r\n     * @param mintingRecip address of new minting recipient\r\n     */\r\n    function changeMintingRecipient(address mintingRecip) public {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().changeMintingRecipientProxy(\r\n                msg.sender,\r\n                mintingRecip\r\n            );\r\n        } else {\r\n            changeMintingRecipientGuarded(msg.sender, mintingRecip);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows a pauser to pause the current token.\r\n     */\r\n    function pause() public {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().pauseProxy(msg.sender);\r\n        } else {\r\n            pauseGuarded(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows a pauser to unpause the current token.\r\n     */\r\n    function unpause() public {\r\n        if (isUpgraded()) {\r\n            getUpgradedToken().unpauseProxy(msg.sender);\r\n        } else {\r\n            unpauseGuarded(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        if (isUpgraded()) {\r\n            return getUpgradedToken().pausedProxy(msg.sender);\r\n        } else {\r\n            return pausedGuarded(msg.sender);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowanceProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_upgradedToken\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mintingRecip\",\"type\":\"address\"}],\"name\":\"changeMintingRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"decimalsProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"nameProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBurner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"totalSupplyProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowanceProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFromProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasAccess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"pauseProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mintProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"unpauseProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintingRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFromProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isNotBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"pausedProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"symbolProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"mintingRecip\",\"type\":\"address\"}],\"name\":\"changeMintingRecipientProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOfProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"accesslist\",\"type\":\"address\"},{\"name\":\"whitelistEnabled\",\"type\":\"bool\"},{\"name\":\"externalStorage\",\"type\":\"address\"},{\"name\":\"initialMintingRecipient\",\"type\":\"address\"},{\"name\":\"upgradedFrom\",\"type\":\"address\"},{\"name\":\"initialDeployment\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"prev\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"next\",\"type\":\"address\"}],\"name\":\"MintingRecipientAccountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BurnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BurnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"upgradedFrom\",\"type\":\"address\"}],\"name\":\"UpgradeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000120000000000000000000000005b3617771315ac88d120d27426a752130c9a62d8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e65feadd70c2dbffc91c8ec0e282fcf3e4783cb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000c65546f726f2053696c76657200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004534c565800000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://1e438fd2c48222a90e73a06e76b9d5a1b28c95683278a0b4b340a3fa4a5a5aba"}]}