{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\ninterface F2mInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // one time called\r\n    function disableRound0() public;\r\n    function activeBuy() public;\r\n    // Dividends from all sources (DApps, Donate ...)\r\n    function pushDividends() public payable;\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    //function reinvest() public;\r\n    //function buy() public payable;\r\n    function buyFor(address _buyer) public payable;\r\n    function sell(uint256 _tokenAmount) public;\r\n    function exit() public;\r\n    function devTeamWithdraw() public returns(uint256);\r\n    function withdrawFor(address sender) public returns(uint256);\r\n    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function setAutoBuy() public;\r\n    /*==========================================\r\n    =            public FUNCTIONS            =\r\n    ==========================================*/\r\n    // function totalEthBalance() public view returns(uint256);\r\n    function ethBalance(address _address) public view returns(uint256);\r\n    function myBalance() public view returns(uint256);\r\n    function myEthBalance() public view returns(uint256);\r\n\r\n    function swapToken() public;\r\n    function setNewToken(address _newTokenAddress) public;\r\n}\r\n\r\ninterface CitizenInterface {\r\n \r\n    function joinNetwork(address[6] _contract) public;\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function devTeamWithdraw() public;\r\n\r\n    /*----------  WRITE FUNCTIONS  ----------*/\r\n    function updateUsername(string _sNewUsername) public;\r\n    //Sources: Token contract, DApps\r\n    function pushRefIncome(address _sender) public payable;\r\n    function withdrawFor(address _sender) public payable returns(uint256);\r\n    function devTeamReinvest() public returns(uint256);\r\n\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n    function getRefWallet(address _address) public view returns(uint256);\r\n}\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ninterface BankInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // Core functions\r\n    function pushToBank(address _player) public payable;\r\n}\r\n\r\ninterface RewardInterface {\r\n\r\n    function mintReward(\r\n        address _lucker,\r\n        uint256 curRoundId,\r\n        uint256 _tNumberFrom,\r\n        uint256 _tNumberTo,\r\n        uint256 _value,\r\n        uint256 _rewardType)\r\n        public;\r\n        \r\n    function joinNetwork(address[6] _contract) public;\r\n    function pushBounty(uint256 _curRoundId) public payable;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public SDIVIDER = 3450000;\r\n    uint256 constant public PDIVIDER = 3450000;\r\n    uint256 constant public RDIVIDER = 1580000;\r\n    // Starting LS price (SLP)\r\n    uint256 constant public SLP = 0.002 ether;\r\n    // Starting Added Time (SAT)\r\n    uint256 constant public SAT = 30; // seconds\r\n    // Price normalization (PN)\r\n    uint256 constant public PN = 777;\r\n    // EarlyIncome base\r\n    uint256 constant public PBASE = 13;\r\n    uint256 constant public PMULTI = 26;\r\n    uint256 constant public LBase = 15;\r\n\r\n    uint256 constant public ONE_HOUR = 3600;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    \r\n    function bytes32ToString (bytes32 data)\r\n        public\r\n        pure\r\n        returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint j=0; j<32; j++) {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    \r\n    function uintToBytes32(uint256 n)\r\n        public\r\n        pure\r\n        returns (bytes32) \r\n    {\r\n        return bytes32(n);\r\n    }\r\n    \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function uintToString(uint256 _uint) \r\n        public\r\n        pure\r\n        returns (string)\r\n    {\r\n        return bytes32ToString(uintToBytes32(_uint));\r\n    }\r\n\r\n/*     \r\n    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\r\n        bytes memory a = new bytes(end-begin+1);\r\n        for(uint i = 0; i <= end - begin; i++){\r\n            a[i] = bytes(text)[i + begin - 1];\r\n        }\r\n        return string(a);    \r\n    }\r\n */\r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        uint256 len = bytes(_username).length;\r\n        // Im Raum [4, 18]\r\n        if ((len < 4) || (len > 18)) return false;\r\n        // Letzte Char != ' '\r\n        if (bytes(_username)[len-1] == 32) return false;\r\n        // Erste Char != '0'\r\n        return uint256(bytes(_username)[0]) != 48;\r\n    }\r\n\r\n    // Lottery Helper\r\n\r\n    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\r\n    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        //Luppe = 10000 = 10^4\r\n        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        // div 10000^6\r\n        expo = expo / (10**24);\r\n\r\n        if (expo > SAT) return 0;\r\n        return (SAT - expo).mul(_tAmount);\r\n    }\r\n\r\n    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\r\n        uint256 timeout = _slideEndTime.sub(block.timestamp);\r\n        // timeout capped at TIMEOUT1\r\n        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\r\n        _slideEndTime = (block.timestamp).add(timeout);\r\n        // Capped at fixedEndTime\r\n        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\r\n        return _slideEndTime;\r\n    }\r\n\r\n    // get random in range [1, _range] with _seed\r\n    function getRandom(uint256 _seed, uint256 _range)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (_range == 0) return _seed;\r\n        return (_seed % _range) + 1;\r\n    }\r\n\r\n\r\n    function getEarlyIncomeMul(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\r\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base); //^3\r\n        expo = expo.mul(expo) / (ZOOM**6); //^6\r\n        return (1 + PBASE / (1 + expo.mul(PMULTI)));\r\n    }\r\n\r\n    // get reveiced Tickets, based on current round ticketSum\r\n    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tPrice = getTPrice(_ticketSum);\r\n        return _ethAmount.div(_tPrice);\r\n    }\r\n\r\n    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\r\n    function getTMul(uint256 _ticketSum) // Unit Wei\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = _ticketSum * ZOOM / PDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base);\r\n        expo = expo.mul(expo); // ^6\r\n        return 1 + expo.mul(LBase) / (10**18);\r\n    }\r\n\r\n    // get ticket price, based on current round ticketSum\r\n    //unit in ETH, no need / zoom^6\r\n    function getTPrice(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        uint256 tPrice = SLP + expo / PN;\r\n        return tPrice;\r\n    }\r\n\r\n    // get weight of slot, chance to win grandPot\r\n    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\r\n        uint256 _tMul = getTMul(_ticketSum);\r\n        return (_tAmount).mul(_tMul);\r\n    }\r\n\r\n    // used to draw grandpot results\r\n    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\r\n    // grandPot = initGrandPot + round investedSum(for grandPot)\r\n    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        //calculate round grandPot-investedSum\r\n        uint256 grandPotInvest = grandPot - initGrandPot;\r\n        if (grandPotInvest == 0) return 8;\r\n        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\r\n        uint256 weightRange = zoomMul * curRWeight / ZOOM;\r\n        if (weightRange < curRWeight) weightRange = curRWeight;\r\n        return weightRange;\r\n    }\r\n}\r\n\r\ncontract Lottery {\r\n    using SafeMath for uint256;\r\n\r\n    modifier withdrawRight(){\r\n        require(msg.sender == address(bankContract), \"Bank only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDevTeam() {\r\n        require(msg.sender == devTeam, \"only for development team\");\r\n        _;\r\n    }\r\n\r\n    modifier buyable() {\r\n        require(block.timestamp > round[curRoundId].startTime, \"not ready to sell Ticket\");\r\n        require(block.timestamp < round[curRoundId].slideEndTime, \"round over\");\r\n        _;\r\n    }\r\n\r\n    enum RewardType {\r\n        Minor,\r\n        Major,\r\n        Grand,\r\n        Bounty\r\n    }\r\n\r\n    // 1 buy = 1 slot = _ethAmount => (tAmount, tMul) \r\n    struct Slot {\r\n        address buyer;\r\n        uint256 rId;\r\n        // ticket numbers in range and unique in all rounds\r\n        uint256 tNumberFrom;\r\n        uint256 tNumberTo;\r\n        // weight to, used for grandPot finalize\r\n        uint256 wTo;\r\n        uint256 ethAmount;\r\n        uint256 salt;\r\n    }\r\n\r\n    struct Round {\r\n        // earlyIncome weight sum\r\n        uint256 rEarlyIncomeWeight;\r\n        // blockNumber to get hash as random seed\r\n        uint256 keyBlockNr;\r\n        \r\n        mapping(address => uint256) pTicketSum;\r\n        mapping(address => uint256) pInvestedSum;\r\n\r\n        // early income weight by address\r\n        mapping(address => uint256) pEarlyIncomeWeight;\r\n        mapping(address => uint256) pEarlyIncomeCredit;\r\n        mapping(address => uint256) pEarlyIncomeClaimed;\r\n        // early income per weight\r\n        uint256 ppw;\r\n        // endTime increased every slot sold\r\n        // endTime limited by fixedEndTime\r\n        uint256 startTime;\r\n        uint256 slideEndTime;\r\n        uint256 fixedEndTime;\r\n\r\n        // ticketSum from round 1 to this round\r\n        uint256 ticketSum;\r\n        // investedSum from round 1 to this round\r\n        uint256 investedSum;\r\n        // number of slots from round 1 to this round\r\n        uint256 slotSum;\r\n    }\r\n\r\n    // round started with this grandPot amount,\r\n    // used to calculate the rate for grandPot results\r\n    // init in roundInit function\r\n    uint256 initGrandPot;\r\n\r\n    Slot[] slot;\r\n    // slotId logs by address\r\n    mapping( address => uint256[]) pSlot;\r\n    mapping( address => uint256) public pSlotSum;\r\n\r\n    // logs by address\r\n    mapping( address => uint256) public pTicketSum;\r\n    mapping( address => uint256) public pInvestedSum;\r\n\r\n    CitizenInterface public citizenContract;\r\n    F2mInterface public f2mContract;\r\n    BankInterface public bankContract;\r\n    RewardInterface public rewardContract;\r\n\r\n    address public devTeam;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public ONE_HOUR = 60 * 60;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT2 = 7 * ONE_DAY;\r\n    uint256 constant public FINALIZE_WAIT_DURATION = 60; // 60 Seconds\r\n    uint256 constant public NEWROUND_WAIT_DURATION = ONE_DAY; // 24 Hours\r\n\r\n    // 15 seconds on Ethereum, 12 seconds used instead to make sure blockHash unavaiable\r\n    // when slideEndTime reached\r\n    // keyBlockNumber will be estimated again after every slot buy\r\n    uint256 constant public BLOCK_TIME = 12;\r\n    uint256 constant public MAX_BLOCK_DISTANCE = 254;\r\n\r\n    uint256 constant public MAJOR_RATE = 1000;\r\n    uint256 constant public MINOR_RATE = 1000;\r\n    uint256 constant public MAJOR_MIN = 0.1 ether ;\r\n    uint256 constant public MINOR_MIN = 0.1 ether ;\r\n\r\n    //uint256 public toNextPotPercent = 27;\r\n    uint256 public grandRewardPercent = 20;\r\n    uint256 public jRewardPercent = 60;\r\n\r\n    uint256 public toTokenPercent = 12; // 10% dividends 2% fund\r\n    uint256 public toBuyTokenPercent = 1;\r\n    uint256 public earlyIncomePercent = 22;\r\n    uint256 public toRefPercent = 15;\r\n\r\n    // sum == 100% = toPotPercent/100 * investedSum\r\n    // uint256 public grandPercent = 68;\r\n    uint256 public majorPercent = 24;\r\n    uint256 public minorPercent = 8;\r\n\r\n    uint256 public grandPot;\r\n    uint256 public majorPot;\r\n    uint256 public minorPot;\r\n\r\n    uint256 public curRoundId;\r\n    uint256 public lastRoundId = 88888888;\r\n\r\n    uint256 constant public startPrice = 0.002 ether;\r\n\r\n    mapping (address => uint256) public rewardBalance;\r\n    // used to save gas on earlyIncome calculating, curRoundId never included\r\n    // only earlyIncome from round 1st to curRoundId-1 are fixed\r\n    mapping (address => uint256) public lastWithdrawnRound;\r\n    mapping (address => uint256) public earlyIncomeScannedSum;\r\n\r\n    mapping (uint256 => Round) public round;\r\n\r\n    // Current Round\r\n\r\n    // first SlotId in last Block to fire jackpot\r\n    uint256 public jSlot;\r\n    // jackpot results of all slots in same block will be drawed at the same time,\r\n    // by player, who buys the first slot in next block\r\n    uint256 public lastBlockNr;\r\n    // used to calculate grandPot results\r\n    uint256 public curRWeight;\r\n    // added by slot salt after every slot buy\r\n    // does not matter with overflow\r\n    uint256 public curRSalt;\r\n    // ticket sum of current round\r\n    uint256 public curRTicketSum;\r\n\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        // register address in network\r\n        DevTeamInterface(_devTeam).setLotteryAddress(address(this));\r\n        devTeam = _devTeam;\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require(address(citizenContract) == 0x0,\"already setup\");\r\n        f2mContract = F2mInterface(_contract[0]);\r\n        bankContract = BankInterface(_contract[1]);\r\n        citizenContract = CitizenInterface(_contract[2]);\r\n        //lotteryContract = LotteryInterface(lotteryAddress);\r\n        rewardContract = RewardInterface(_contract[4]);\r\n    }\r\n\r\n    function activeFirstRound()\r\n        public\r\n        onlyDevTeam()\r\n    {\r\n        require(curRoundId == 0, \"already activated\");\r\n        initRound();\r\n    }\r\n\r\n    // Core Functions\r\n\r\n    function pushToPot() \r\n        public \r\n        payable\r\n    {\r\n        addPot(msg.value);\r\n    }\r\n\r\n    function checkpoint() \r\n        private\r\n    {\r\n        // dummy slot between every 2 rounds\r\n        // dummy slot never win jackpot cause of min 0.1 ETH\r\n        Slot memory _slot;\r\n        _slot.tNumberTo = round[curRoundId].ticketSum;\r\n        slot.push(_slot);\r\n\r\n        Round memory _round;\r\n        _round.startTime = NEWROUND_WAIT_DURATION.add(block.timestamp);\r\n        // started with 3 hours timeout\r\n        _round.slideEndTime = TIMEOUT0 + _round.startTime;\r\n        _round.fixedEndTime = TIMEOUT2 + _round.startTime;\r\n        _round.keyBlockNr = genEstKeyBlockNr(_round.slideEndTime);\r\n        _round.ticketSum = round[curRoundId].ticketSum;\r\n        _round.investedSum = round[curRoundId].investedSum;\r\n        _round.slotSum = slot.length;\r\n\r\n        curRoundId = curRoundId + 1;\r\n        round[curRoundId] = _round;\r\n\r\n        initGrandPot = grandPot;\r\n        curRWeight = 0;\r\n        curRTicketSum = 0;\r\n    }\r\n\r\n    // from round 18+ function\r\n    function isLastRound()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return (curRoundId == lastRoundId);\r\n    }\r\n\r\n    function goNext()\r\n        private\r\n    {\r\n        uint256 _totalPot = getTotalPot();\r\n        grandPot = 0;\r\n        majorPot = 0;\r\n        minorPot = 0;\r\n        f2mContract.pushDividends.value(_totalPot)();\r\n        // never start\r\n        round[curRoundId].startTime = block.timestamp * 10;\r\n        round[curRoundId].slideEndTime = block.timestamp * 10 + 1;\r\n    }\r\n\r\n    function initRound()\r\n        private\r\n    {\r\n        // update all Round Log\r\n        checkpoint();\r\n        if (isLastRound()) goNext();\r\n    }\r\n\r\n    function finalizeable() \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 finalizeTime = FINALIZE_WAIT_DURATION.add(round[curRoundId].slideEndTime);\r\n        if (finalizeTime > block.timestamp) return false; // too soon to finalize\r\n        if (getEstKeyBlockNr(curRoundId) >= block.number) return false; //block hash not exist\r\n        return curRoundId > 0;\r\n    }\r\n\r\n    // bounty\r\n    function finalize()\r\n        public\r\n    {\r\n        require(finalizeable(), \"Not ready to draw results\");\r\n        // avoid txs blocked => curRTicket ==0 => die\r\n        require((round[curRoundId].pTicketSum[msg.sender] > 0) || (curRTicketSum == 0), \"must buy at least 1 ticket\");\r\n        endRound(msg.sender);\r\n        initRound();\r\n    }\r\n\r\n    function mintReward(\r\n        address _lucker,\r\n        uint256 _slotId,\r\n        uint256 _value,\r\n        RewardType _rewardType)\r\n        private\r\n    {\r\n        // add reward balance\r\n        rewardBalance[_lucker] = rewardBalance[_lucker].add(_value);\r\n        // reward log\r\n        rewardContract.mintReward(\r\n            _lucker,\r\n            curRoundId,\r\n            slot[_slotId].tNumberFrom,\r\n            slot[_slotId].tNumberTo,\r\n            _value,\r\n            uint256(_rewardType)\r\n        );\r\n    }\r\n\r\n    function jackpot()\r\n        private\r\n    {\r\n        // get blocknumber to get blockhash\r\n        uint256 keyBlockNr = getKeyBlockNr(lastBlockNr);//block.number;\r\n        // salt not effected by jackpot, too risk\r\n        uint256 seed = getSeed(keyBlockNr);\r\n        // slot numberic from 1 ... totalSlot(round)\r\n        // jackpot for all slot in last block, jSlot <= i <= lastSlotId (=slotSum - 1)\r\n        // _to = first Slot in new block\r\n        //uint256 _to = round[curRoundId].slotSum;\r\n\r\n        uint256 jReward;\r\n        uint256 toF2mAmount;\r\n        address winner;\r\n        // jackpot check for slots in last block\r\n        while (jSlot + 1 < round[curRoundId].slotSum) {\r\n            // majorPot\r\n            if ((seed % MAJOR_RATE == 6) &&\r\n                (slot[jSlot].ethAmount >= MAJOR_MIN)) {\r\n\r\n                winner = slot[jSlot].buyer;\r\n                jReward = majorPot / 100 * jRewardPercent;\r\n                mintReward(winner, jSlot, jReward, RewardType.Major);\r\n                toF2mAmount = majorPot / 100 * toTokenPercent;\r\n                f2mContract.pushDividends.value(toF2mAmount)();\r\n                majorPot = majorPot - jReward - toF2mAmount;\r\n            }\r\n\r\n            // minorPot\r\n            if (((seed + jSlot) % MINOR_RATE == 8) && \r\n                (slot[jSlot].ethAmount >= MINOR_MIN)) {\r\n\r\n                winner = slot[jSlot].buyer;\r\n                jReward = minorPot / 100 * jRewardPercent;\r\n                mintReward(winner, jSlot, jReward, RewardType.Minor);\r\n                toF2mAmount = minorPot / 100 * toTokenPercent;\r\n                f2mContract.pushDividends.value(toF2mAmount)();\r\n                minorPot = minorPot - jReward - toF2mAmount;\r\n            }\r\n            seed = seed + 1;\r\n            jSlot = jSlot + 1;\r\n        }\r\n    }\r\n\r\n    function endRound(address _bountyHunter)\r\n        private\r\n    {\r\n        uint256 _rId = curRoundId;\r\n        uint256 keyBlockNr = getKeyBlockNr(round[_rId].keyBlockNr);\r\n        uint256 _seed = getSeed(keyBlockNr) + curRSalt;\r\n        uint256 onePercent = grandPot / 100;\r\n        uint256 rGrandReward = onePercent * grandRewardPercent;\r\n\r\n        //PUSH DIVIDENDS\r\n        uint256 toF2mAmount = onePercent * toTokenPercent;\r\n        //uint256 _bountyAmount = onePercent * bountyPercent;\r\n        \r\n        grandPot = grandPot - toF2mAmount - onePercent;\r\n        f2mContract.pushDividends.value(toF2mAmount)();\r\n\r\n        // base on grand-intestedSum current grandPot\r\n        uint256 weightRange = getWeightRange();\r\n\r\n        // roll 3 turns\r\n        for (uint256 i = 0; i < 3; i++){\r\n            uint256 winNr = Helper.getRandom(_seed, weightRange);\r\n            // if winNr > curRoundWeight => no winner this turn\r\n            // win Slot : fromWeight <= winNr <= toWeight\r\n            // got winner this rolling turn\r\n            if (winNr <= curRWeight) {\r\n                grandPot -= rGrandReward;\r\n                uint256 _winSlot = getWinSlot(winNr);\r\n                address _winner = slot[_winSlot].buyer;\r\n                mintReward(_winner, _winSlot, rGrandReward, RewardType.Grand);\r\n                _seed = _seed + (_seed / 10);\r\n            }\r\n        }\r\n        mintReward(_bountyHunter, 0, onePercent * 3 / 10, RewardType.Bounty);\r\n        rewardContract.pushBounty.value(onePercent * 7 / 10)(curRoundId);\r\n    }\r\n\r\n    function buy(string _sSalt)\r\n        public\r\n        payable\r\n    {\r\n        buyFor(_sSalt, msg.sender);\r\n    }\r\n\r\n    function updateInvested(address _buyer, uint256 _ethAmount)\r\n        private\r\n    {\r\n        round[curRoundId].investedSum += _ethAmount;\r\n        round[curRoundId].pInvestedSum[_buyer] += _ethAmount;\r\n        pInvestedSum[_buyer] += _ethAmount;\r\n    }\r\n\r\n    function updateTicketSum(address _buyer, uint256 _tAmount)\r\n        private\r\n    {\r\n        round[curRoundId].ticketSum = round[curRoundId].ticketSum + _tAmount;\r\n        round[curRoundId].pTicketSum[_buyer] = round[curRoundId].pTicketSum[_buyer] + _tAmount;\r\n        curRTicketSum = curRTicketSum + _tAmount;\r\n        pTicketSum[_buyer] = pTicketSum[_buyer] + _tAmount;\r\n    }\r\n\r\n    function updateEarlyIncome(address _buyer, uint256 _pWeight)\r\n        private\r\n    {\r\n        round[curRoundId].rEarlyIncomeWeight = _pWeight.add(round[curRoundId].rEarlyIncomeWeight);\r\n        round[curRoundId].pEarlyIncomeWeight[_buyer] = _pWeight.add(round[curRoundId].pEarlyIncomeWeight[_buyer]);\r\n        round[curRoundId].pEarlyIncomeCredit[_buyer] = round[curRoundId].pEarlyIncomeCredit[_buyer].add(_pWeight.mul(round[curRoundId].ppw));\r\n    }\r\n\r\n    function buyFor(string _sSalt, address _sender) \r\n        public\r\n        payable\r\n        buyable()\r\n    {\r\n        uint256 _salt = Helper.stringToUint(_sSalt);\r\n        uint256 _ethAmount = msg.value;\r\n        uint256 _ticketSum = curRTicketSum;\r\n        require(_ethAmount >= Helper.getTPrice(_ticketSum), \"not enough to buy 1 ticket\");\r\n\r\n        // investedSum logs\r\n        updateInvested(_sender, _ethAmount);\r\n        // update salt\r\n        curRSalt = curRSalt + _salt;\r\n        // init new Slot, Slot Id = 1..curRSlotSum\r\n        Slot memory _slot;\r\n        _slot.rId = curRoundId;\r\n        _slot.buyer = _sender;\r\n        _slot.ethAmount = _ethAmount;\r\n        _slot.salt = _salt;\r\n        uint256 _tAmount = Helper.getTAmount(_ethAmount, _ticketSum);\r\n        uint256 _tMul = Helper.getTMul(_ticketSum);\r\n        uint256 _pMul = Helper.getEarlyIncomeMul(_ticketSum);\r\n        uint256 _pWeight = _pMul.mul(_tAmount);\r\n        uint256 _toAddTime = Helper.getAddedTime(_ticketSum, _tAmount);\r\n        addTime(curRoundId, _toAddTime);\r\n\r\n        // update weight\r\n        uint256 _slotWeight = (_tAmount).mul(_tMul);\r\n        curRWeight = curRWeight.add(_slotWeight);\r\n        _slot.wTo = curRWeight;\r\n        uint256 lastSlot = slot.length - 1;\r\n        // update ticket params\r\n        _slot.tNumberFrom = slot[lastSlot].tNumberTo + 1;\r\n        _slot.tNumberTo = slot[lastSlot].tNumberTo + _tAmount;\r\n        updateTicketSum(_sender, _tAmount);\r\n\r\n        // EarlyIncome Weight\r\n        // ppw and credit zoomed x1000\r\n        // earlyIncome mul of each ticket in this slot\r\n        updateEarlyIncome(_sender, _pWeight);\r\n     \r\n        // add Slot and update round data\r\n        slot.push(_slot);\r\n        round[curRoundId].slotSum = slot.length;\r\n        // add slot to player logs\r\n        pSlot[_sender].push(slot.length - 1);\r\n\r\n        // first slot in this block draw jacpot results for \r\n        // all slot in last block\r\n        if (lastBlockNr != block.number) {\r\n            jackpot();\r\n            lastBlockNr = block.number;\r\n        }\r\n\r\n        distributeSlotBuy(_sender, curRoundId, _ethAmount);\r\n\r\n        round[curRoundId].keyBlockNr = genEstKeyBlockNr(round[curRoundId].slideEndTime);\r\n    }\r\n\r\n    function distributeSlotBuy(address _sender, uint256 _rId, uint256 _ethAmount)\r\n        private\r\n    {\r\n        uint256 onePercent = _ethAmount / 100;\r\n        uint256 toF2mAmount = onePercent * toTokenPercent; // 12\r\n        uint256 toRefAmount = onePercent * toRefPercent; // 10\r\n        uint256 toBuyTokenAmount = onePercent * toBuyTokenPercent; //1\r\n        uint256 earlyIncomeAmount = onePercent * earlyIncomePercent; //27\r\n        uint256 taxAmount = toF2mAmount + toRefAmount + toBuyTokenAmount + earlyIncomeAmount; // 50\r\n        uint256 taxedEthAmount = _ethAmount.sub(taxAmount); // 50\r\n        addPot(taxedEthAmount);\r\n        \r\n        // 10% Ref\r\n        citizenContract.pushRefIncome.value(toRefAmount)(_sender);\r\n        // 2% Fund + 10% Dividends \r\n        f2mContract.pushDividends.value(toF2mAmount)();\r\n        // 1% buy Token\r\n        f2mContract.buyFor.value(toBuyTokenAmount)(_sender);\r\n        // 27% Early\r\n        uint256 deltaPpw = (earlyIncomeAmount * ZOOM).div(round[_rId].rEarlyIncomeWeight);\r\n        round[_rId].ppw = deltaPpw.add(round[_rId].ppw);\r\n    }\r\n\r\n    function claimEarlyIncomebyAddress(address _buyer)\r\n        private\r\n    {\r\n        if (curRoundId == 0) return;\r\n        claimEarlyIncomebyAddressRound(_buyer, curRoundId);\r\n        uint256 _rId = curRoundId - 1;\r\n        while ((_rId > lastWithdrawnRound[_buyer]) && (_rId + 20 > curRoundId)) {\r\n            earlyIncomeScannedSum[_buyer] += claimEarlyIncomebyAddressRound(_buyer, _rId);\r\n            _rId = _rId - 1;\r\n        }\r\n    }\r\n\r\n    function claimEarlyIncomebyAddressRound(address _buyer, uint256 _rId)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = getCurEarlyIncomeByAddressRound(_buyer, _rId);\r\n        if (_amount == 0) return 0;\r\n        round[_rId].pEarlyIncomeClaimed[_buyer] = _amount.add(round[_rId].pEarlyIncomeClaimed[_buyer]);\r\n        rewardBalance[_buyer] = _amount.add(rewardBalance[_buyer]);\r\n        return _amount;\r\n    }\r\n\r\n    function withdrawFor(address _sender)\r\n        public\r\n        withdrawRight()\r\n        returns(uint256)\r\n    {\r\n        if (curRoundId == 0) return;\r\n        claimEarlyIncomebyAddress(_sender);\r\n        lastWithdrawnRound[_sender] = curRoundId - 1;\r\n        uint256 _amount = rewardBalance[_sender];\r\n        rewardBalance[_sender] = 0;\r\n        bankContract.pushToBank.value(_amount)(_sender);\r\n        return _amount;\r\n    }\r\n    \r\n    function addTime(uint256 _rId, uint256 _toAddTime)\r\n        private\r\n    {\r\n        round[_rId].slideEndTime = Helper.getNewEndTime(_toAddTime, round[_rId].slideEndTime, round[_rId].fixedEndTime);\r\n    }\r\n\r\n    // distribute to 3 pots Grand, Majorm Minor\r\n    function addPot(uint256 _amount)\r\n        private\r\n    {\r\n        uint256 onePercent = _amount / 100;\r\n        uint256 toMinor = onePercent * minorPercent;\r\n        uint256 toMajor = onePercent * majorPercent;\r\n        uint256 toGrand = _amount - toMinor - toMajor;\r\n\r\n        minorPot = minorPot + toMinor;\r\n        majorPot = majorPot + toMajor;\r\n        grandPot = grandPot + toGrand;\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////\r\n    // READ FUNCTIONS\r\n    //////////////////////////////////////////////////////////////////\r\n\r\n    function isWinSlot(uint256 _slotId, uint256 _keyNumber)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return (slot[_slotId - 1].wTo < _keyNumber) && (slot[_slotId].wTo >= _keyNumber);\r\n    }\r\n\r\n    function getWeightRange()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getWeightRange(grandPot, initGrandPot, curRWeight);\r\n    }\r\n\r\n    function getWinSlot(uint256 _keyNumber)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // return 0 if not found\r\n        uint256 _to = slot.length - 1;\r\n        uint256 _from = round[curRoundId-1].slotSum + 1; // dummy slot ignore\r\n        uint256 _pivot;\r\n        //Slot memory _slot;\r\n        uint256 _pivotWTo;\r\n        // Binary search\r\n        while (_from <= _to) {\r\n            _pivot = (_from + _to) / 2;\r\n            //_slot = round[_rId].slot[_pivot];\r\n            _pivotWTo = slot[_pivot].wTo;\r\n            if (isWinSlot(_pivot, _keyNumber)) return _pivot;\r\n            if (_pivotWTo < _keyNumber) { // in right side\r\n                _from = _pivot + 1;\r\n            } else { // in left side\r\n                _to = _pivot - 1;\r\n            }\r\n        }\r\n        return _pivot; // never happens or smt gone wrong\r\n    }\r\n\r\n    // Key Block in future\r\n    function genEstKeyBlockNr(uint256 _endTime) \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (block.timestamp >= _endTime) return block.number + 8; \r\n        uint256 timeDist = _endTime - block.timestamp;\r\n        uint256 estBlockDist = timeDist / BLOCK_TIME;\r\n        return block.number + estBlockDist + 8;\r\n    }\r\n\r\n    // get block hash of first block with blocktime > _endTime\r\n    function getSeed(uint256 _keyBlockNr)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Key Block not mined atm\r\n        if (block.number <= _keyBlockNr) return block.number;\r\n        return uint256(blockhash(_keyBlockNr));\r\n    }\r\n\r\n    // current reward balance\r\n    function getRewardBalance(address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rewardBalance[_buyer];\r\n    } \r\n\r\n    // GET endTime\r\n    function getSlideEndTime(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(round[_rId].slideEndTime);\r\n    }\r\n\r\n    function getFixedEndTime(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(round[_rId].fixedEndTime);\r\n    }\r\n\r\n    function getTotalPot()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return grandPot + majorPot + minorPot;\r\n    }\r\n\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _sum = earlyIncomeScannedSum[_buyer];\r\n        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\r\n        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\r\n        uint256 _rId = _fromRound;\r\n        while (_rId <= curRoundId) {\r\n            _sum = _sum + getEarlyIncomeByAddressRound(_buyer, _rId);\r\n            _rId++;\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    // included claimed amount\r\n    function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _pWeight = round[_rId].pEarlyIncomeWeight[_buyer];\r\n        uint256 _ppw = round[_rId].ppw;\r\n        uint256 _rCredit = round[_rId].pEarlyIncomeCredit[_buyer];\r\n        uint256 _rEarlyIncome = ((_ppw.mul(_pWeight)).sub(_rCredit)).div(ZOOM);\r\n        return _rEarlyIncome;\r\n    }\r\n\r\n    function getCurEarlyIncomeByAddress(address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _sum = 0;\r\n        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\r\n        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\r\n        uint256 _rId = _fromRound;\r\n        while (_rId <= curRoundId) {\r\n            _sum = _sum.add(getCurEarlyIncomeByAddressRound(_buyer, _rId));\r\n            _rId++;\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _rEarlyIncome = getEarlyIncomeByAddressRound(_buyer, _rId);\r\n        return _rEarlyIncome.sub(round[_rId].pEarlyIncomeClaimed[_buyer]);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////\r\n\r\n    function getEstKeyBlockNr(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].keyBlockNr;\r\n    }\r\n\r\n    function getKeyBlockNr(uint256 _estKeyBlockNr)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        require(block.number > _estKeyBlockNr, \"blockHash not avaiable\");\r\n        uint256 jump = (block.number - _estKeyBlockNr) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE;\r\n        return _estKeyBlockNr + jump;\r\n    }\r\n\r\n    // Logs\r\n    function getCurRoundId()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return curRoundId;\r\n    }\r\n\r\n    function getTPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getTPrice(curRTicketSum);\r\n    }\r\n\r\n    function getTMul()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getTMul(curRTicketSum);\r\n    }\r\n\r\n    function getPMul()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getEarlyIncomeMul(curRTicketSum);\r\n    }\r\n\r\n    function getPTicketSumByRound(uint256 _rId, address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].pTicketSum[_buyer];\r\n    }\r\n\r\n    function getTicketSumToRound(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].ticketSum;\r\n    }\r\n\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].pInvestedSum[_buyer];\r\n    }\r\n\r\n    function getInvestedSumToRound(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].investedSum;\r\n    }\r\n\r\n    function getPSlotLength(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pSlot[_sender].length;\r\n    }\r\n\r\n    function getSlotLength()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return slot.length;\r\n    }\r\n\r\n    function getSlotId(address _sender, uint256 i)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pSlot[_sender][i];\r\n    }\r\n\r\n    function getSlotInfo(uint256 _slotId)\r\n        public\r\n        view\r\n        returns(address, uint256[4], string)\r\n    {\r\n        Slot memory _slot = slot[_slotId];\r\n        return (_slot.buyer,[_slot.rId, _slot.tNumberFrom, _slot.tNumberTo, _slot.ethAmount], Helper.uintToString(_slot.salt));\r\n    }\r\n\r\n    function cashoutable(address _address) \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        // need 1 ticket or in waiting time to start new round\r\n        return (round[curRoundId].pTicketSum[_address] > 0) || (round[curRoundId].startTime > block.timestamp);\r\n    }\r\n\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) \r\n        public\r\n        onlyDevTeam()\r\n    {\r\n        require(_lastRoundId >= 18 && _lastRoundId > curRoundId, \"too early to end\");\r\n        require(lastRoundId == 88888888, \"already set\");\r\n        lastRoundId = _lastRoundId;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"toBuyTokenPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getCurEarlyIncomeByAddressRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minorPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grandPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAJOR_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jRewardPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getEstKeyBlockNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_estKeyBlockNr\",\"type\":\"uint256\"}],\"name\":\"getKeyBlockNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_HOUR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getPTicketSumByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastWithdrawnRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLastRound\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"f2mContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSlotLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyIncomeScannedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINOR_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"rEarlyIncomeWeight\",\"type\":\"uint256\"},{\"name\":\"keyBlockNr\",\"type\":\"uint256\"},{\"name\":\"ppw\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"slideEndTime\",\"type\":\"uint256\"},{\"name\":\"fixedEndTime\",\"type\":\"uint256\"},{\"name\":\"ticketSum\",\"type\":\"uint256\"},{\"name\":\"investedSum\",\"type\":\"uint256\"},{\"name\":\"slotSum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FINALIZE_WAIT_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[6]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toTokenPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getSlotId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRSalt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRTicketSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sSalt\",\"type\":\"string\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BLOCK_DISTANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getSlideEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"cashoutable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZOOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_slotId\",\"type\":\"uint256\"},{\"name\":\"_keyNumber\",\"type\":\"uint256\"}],\"name\":\"isWinSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minorPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getInvestedSumToRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIMEOUT1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getPSlotLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getTicketSumToRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBlockNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lastRoundId\",\"type\":\"uint256\"}],\"name\":\"setLastRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sSalt\",\"type\":\"string\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEWROUND_WAIT_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getFixedEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getEarlyIncomeByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pTicketSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getCurEarlyIncomeByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAJOR_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toRefPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getPInvestedSumByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIMEOUT2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINOR_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_slotId\",\"type\":\"uint256\"}],\"name\":\"getSlotInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyIncomePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pSlotSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getEarlyIncomeByAddressRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIMEOUT0\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getRewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pushToPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keyBlockNr\",\"type\":\"uint256\"}],\"name\":\"getSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grandRewardPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeightRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"genEstKeyBlockNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keyNumber\",\"type\":\"uint256\"}],\"name\":\"getWinSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pInvestedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activeFirstRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLOCK_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2","Library":"Helper:fe00bdcee68a70bbb7559f83fcdb24da2a357ffe","SwarmSource":"bzzr://e9fa52ef32ab54cf2b82a296f1d52806d2e994fbc0ce7174296c2fea9f393f59"}]}