{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n    // Get the total token supply\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n}\r\n\r\n/// @title Implementation of basic ERC20 function.\r\n/// @notice The only difference from most other ERC20 contracts is that we introduce 2 superusers - the founder and the admin.\r\ncontract _Base20 is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  mapping(address => uint256) internal accounts;\r\n\r\n  address internal admin;\r\n\r\n  address payable internal founder;\r\n\r\n  uint256 internal __totalSupply;\r\n\r\n  constructor(uint256 _totalSupply,\r\n    address payable _founder,\r\n    address _admin) public {\r\n      __totalSupply = _totalSupply;\r\n      admin = _admin;\r\n      founder = _founder;\r\n      accounts[founder] = __totalSupply;\r\n      emit Transfer(address(0), founder, accounts[founder]);\r\n    }\r\n\r\n    // define onlyAdmin\r\n    modifier onlyAdmin {\r\n      require(admin == msg.sender);\r\n      _;\r\n    }\r\n\r\n    // define onlyFounder\r\n    modifier onlyFounder {\r\n      require(founder == msg.sender);\r\n      _;\r\n    }\r\n\r\n    // Change founder\r\n    function changeFounder(address payable who) onlyFounder public {\r\n      founder = who;\r\n    }\r\n\r\n    // show founder address\r\n    function getFounder() onlyFounder public view returns (address) {\r\n      return founder;\r\n    }\r\n\r\n    // Change admin\r\n    function changeAdmin(address who) public {\r\n      require(who == founder || who == admin);\r\n      admin = who;\r\n    }\r\n\r\n    // show admin address\r\n    function getAdmin() public view returns (address) {\r\n      require(msg.sender == founder || msg.sender == admin);\r\n      return admin;\r\n    }\r\n\r\n    //\r\n    // ERC20 spec.\r\n    //\r\n    function totalSupply() public view returns (uint256) {\r\n      return __totalSupply;\r\n    }\r\n\r\n    // ERC20 spec.\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n      return accounts[_owner];\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _value)\r\n    internal returns (bool) {\r\n      require(_to != address(0));\r\n\r\n      require(_value <= accounts[_from]);\r\n\r\n      // This should go first. If SafeMath.add fails, the sender's balance is not changed\r\n      accounts[_to] = accounts[_to].add(_value);\r\n      accounts[_from] = accounts[_from].sub(_value);\r\n\r\n      emit Transfer(_from, _to, _value);\r\n\r\n      return true;\r\n    }\r\n    // ERC20 spec.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n      return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    // ERC20 spec.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool) {\r\n      require(_value <= allowed[_from][msg.sender]);\r\n\r\n      // _transfer is either successful, or throws.\r\n      _transfer(_from, _to, _value);\r\n\r\n      allowed[_from][msg.sender] -= _value;\r\n      emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\r\n\r\n      return true;\r\n    }\r\n\r\n    // ERC20 spec.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n      allowed[msg.sender][_spender] = _value;\r\n      emit Approval(msg.sender, _spender, _value);\r\n      return true;\r\n    }\r\n\r\n    // ERC20 spec.\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/// @title Admin can suspend specific wallets in cases of misbehaving or theft.\r\n/// @notice This contract implements methods to lock tranfers, either globally or for specific accounts.\r\ncontract _Suspendable is _Base20 {\r\n  /// @dev flag whether transfers are allowed on global scale.\r\n  ///    When `isTransferable` is `false`, all transfers between wallets are blocked.\r\n  bool internal isTransferable = false;\r\n  /// @dev set of suspended wallets.\r\n  ///   When `suspendedAddresses[wallet]` is `true`, the `wallet` can't both send and receive COLs.\r\n  mapping(address => bool) internal suspendedAddresses;\r\n\r\n  /// @notice Sets total supply and the addresses of super users - founder and admin.\r\n  /// @param _totalSupply Total amount of Color Coin tokens available.\r\n  /// @param _founder Address of the founder wallet\r\n  /// @param _admin Address of the admin wallet\r\n  constructor(uint256 _totalSupply,\r\n    address payable _founder,\r\n    address _admin) public _Base20(_totalSupply, _founder, _admin)\r\n  {\r\n  }\r\n\r\n  /// @dev specifies that the marked method could be used only when transfers are enabled.\r\n  ///   Founder can always transfer\r\n  modifier transferable {\r\n    require(isTransferable || msg.sender == founder);\r\n    _;\r\n  }\r\n\r\n  /// @notice Getter for the global flag `isTransferable`.\r\n  /// @dev Everyone is allowed to view it.\r\n  function isTransferEnabled() public view returns (bool) {\r\n    return isTransferable;\r\n  }\r\n\r\n  /// @notice Enable tranfers globally.\r\n  ///   Note that suspended acccounts remain to be suspended.\r\n  /// @dev Sets the global flag `isTransferable` to `true`.\r\n  function enableTransfer() onlyAdmin public {\r\n    isTransferable = true;\r\n  }\r\n\r\n  /// @notice Disable tranfers globally.\r\n  ///   All transfers between wallets are blocked.\r\n  /// @dev Sets the global flag `isTransferable` to `false`.\r\n  function disableTransfer() onlyAdmin public {\r\n    isTransferable = false;\r\n  }\r\n\r\n  /// @notice Check whether an address is suspended.\r\n  /// @dev Everyone can check any address they want.\r\n  /// @param _address wallet to check\r\n  /// @return returns `true` if the wallet `who` is suspended.\r\n  function isSuspended(address _address) public view returns(bool) {\r\n    return suspendedAddresses[_address];\r\n  }\r\n\r\n  /// @notice Suspend an individual wallet.\r\n  /// @dev Neither the founder nor the admin could be suspended.\r\n  /// @param who  address of the wallet to suspend.\r\n  function suspend(address who) onlyAdmin public {\r\n    if (who == founder || who == admin) {\r\n      return;\r\n    }\r\n    suspendedAddresses[who] = true;\r\n  }\r\n\r\n  /// @notice Unsuspend an individual wallet\r\n  /// @param who  address of the wallet to unsuspend.\r\n  function unsuspend(address who) onlyAdmin public {\r\n    suspendedAddresses[who] = false;\r\n  }\r\n\r\n  //\r\n  // Update of ERC20 functions\r\n  //\r\n\r\n  /// @dev Internal function for transfers updated.\r\n  ///   Neither source nor destination of the transfer can be suspended.\r\n  function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\r\n    require(!isSuspended(_to));\r\n    require(!isSuspended(_from));\r\n\r\n    return super._transfer(_from, _to, _value);\r\n  }\r\n\r\n  /// @notice `transfer` can't happen when transfers are disabled globally\r\n  /// @dev added modifier `transferable`.\r\n  function transfer(address _to, uint256 _value) public transferable returns (bool) {\r\n    return _transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /// @notice `transferFrom` can't happen when transfers are disabled globally\r\n  /// @dev added modifier `transferable`.\r\n  function transferFrom(address _from, address _to, uint256 _value) public transferable returns (bool) {\r\n    require(!isSuspended(msg.sender));\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  // ERC20 spec.\r\n  /// @notice `approve` can't happen when transfers disabled globally\r\n  ///   Suspended users are not allowed to do approvals as well.\r\n  /// @dev  Added modifier `transferable`.\r\n  function approve(address _spender, uint256 _value) public transferable returns (bool) {\r\n    require(!isSuspended(msg.sender));\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  /// @notice Change founder. New founder must not be suspended.\r\n  function changeFounder(address payable who) onlyFounder public {\r\n    require(!isSuspended(who));\r\n    super.changeFounder(who);\r\n  }\r\n\r\n  /// @notice Change admin. New admin must not be suspended.\r\n  function changeAdmin(address who) public {\r\n    require(!isSuspended(who));\r\n    super.changeAdmin(who);\r\n  }\r\n}\r\n\r\n/// @title Advanced functions for Color Coin token smart contract.\r\n/// @notice Implements functions for private ICO and super users.\r\n/// @dev Not intended for reuse.\r\ncontract ColorCoinBase is _Suspendable {\r\n\r\n  /// @dev Represents a lock-up period.\r\n  struct LockUp {\r\n    /// @dev end of the period, in seconds since the epoch.\r\n    uint256 unlockDate;\r\n    /// @dev amount of coins to be unlocked at the end of the period.\r\n    uint256 amount;\r\n  }\r\n\r\n  /// @dev Represents a wallet with lock-up periods.\r\n  struct Investor {\r\n    /// @dev initial amount of locked COLs\r\n    uint256 initialAmount;\r\n    /// @dev current amount of locked COLs\r\n    uint256 lockedAmount;\r\n    /// @dev current lock-up period, index in the array `lockUpPeriods`\r\n    uint256 currentLockUpPeriod;\r\n    /// @dev the list of lock-up periods\r\n    LockUp[] lockUpPeriods;\r\n  }\r\n\r\n  /// @dev Entry in the `adminTransferLog`, that stores the history of admin operations.\r\n  struct AdminTransfer {\r\n    /// @dev the wallet, where COLs were withdrawn from\r\n    address from;\r\n    /// @dev the wallet, where COLs were deposited to\r\n    address to;\r\n    /// @dev amount of coins transferred\r\n    uint256 amount;\r\n    /// @dev the reason, why super user made this transfer\r\n    string  reason;\r\n  }\r\n\r\n  /// @notice The event that is fired when a lock-up period expires for a certain wallet.\r\n  /// @param  who the wallet where the lock-up period expired\r\n  /// @param  period  the number of the expired period\r\n  /// @param  amount  amount of unlocked coins.\r\n  event Unlock(address who, uint256 period, uint256 amount);\r\n\r\n  /// @notice The event that is fired when a super user makes transfer.\r\n  /// @param  from the wallet, where COLs were withdrawn from\r\n  /// @param  to  the wallet, where COLs were deposited to\r\n  /// @param  requestedAmount  amount of coins, that the super user requested to transfer\r\n  /// @param  returnedAmount  amount of coins, that were actually transferred\r\n  /// @param  reason  the reason, why super user made this transfer\r\n  event SuperAction(address from, address to, uint256 requestedAmount, uint256 returnedAmount, string reason);\r\n\r\n  /// @dev  set of wallets with lock-up periods\r\n  mapping (address => Investor) internal investors;\r\n\r\n  /// @dev wallet with the supply of Color Coins.\r\n  ///   It is used to calculate circulating supply.\r\n  address internal supply;\r\n  /// @dev amount of Color Coins locked in lock-up wallets.\r\n  ///   It is used to calculate circulating supply.\r\n  uint256 internal totalLocked;\r\n\r\n  /// @dev the list of transfers performed by super users\r\n  AdminTransfer[] internal adminTransferLog;\r\n\r\n  /// @notice Sets total supply and the addresses of super users - founder and admin.\r\n  /// @param _totalSupply Total amount of Color Coin tokens available.\r\n  /// @param _founder Address of the founder wallet\r\n  /// @param _admin Address of the admin wallet\r\n  constructor(uint256 _totalSupply,\r\n    address payable _founder,\r\n    address _admin\r\n  ) public _Suspendable (_totalSupply, _founder, _admin)\r\n  {\r\n    supply = founder;\r\n  }\r\n\r\n  //\r\n  // ERC20 spec.\r\n  //\r\n\r\n  /// @notice Returns the balance of a wallet.\r\n  ///   For wallets with lock-up the result of this function inludes both free floating and locked COLs.\r\n  /// @param _owner The address of a wallet.\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return accounts[_owner] + investors[_owner].lockedAmount;\r\n  }\r\n\r\n  /// @dev Performs transfer from one wallet to another.\r\n  ///   The maximum amount of COLs to transfer equals to `balanceOf(_from) - getLockedAmount(_from)`.\r\n  ///   This function unlocks COLs if any of lock-up periods expired at the moment\r\n  ///   of the transaction execution.\r\n  ///   Calls `Suspendable._transfer` to do the actual transfer.\r\n  ///   This function is used by ERC20 `transfer` function.\r\n  /// @param  _from   wallet from which tokens are withdrawn.\r\n  /// @param  _to   wallet to which tokens are deposited.\r\n  /// @param  _value  amount of COLs to transfer.\r\n  function _transfer(address _from, address _to, uint256 _value)\r\n  internal returns (bool) {\r\n    if (hasLockup(_from)) {\r\n      tryUnlock(_from);\r\n    }\r\n    super._transfer(_from, _to, _value);\r\n  }\r\n\r\n  /// @notice The founder sends COLs to early investors and sets lock-up periods.\r\n  ///   Initially all distributed COL's are locked.\r\n  /// @dev  Only founder can call this function.\r\n  /// @param _to  address of the wallet that receives the COls.\r\n  /// @param _value amount of COLs that founder sends to the investor's wallet.\r\n  /// @param unlockDates array of lock-up period dates.\r\n  ///   Each date is in seconds since the epoch. After `unlockDates[i]` is expired,\r\n  ///   the corresponding `amounts[i]` amount of COLs gets unlocked.\r\n  ///   After expiring the last date in this array all COLs become unlocked.\r\n  /// @param amounts array of COL amounts to unlock.\r\n  function distribute(address _to, uint256 _value,\r\n      uint256[] memory unlockDates, uint256[] memory amounts\r\n    ) onlyFounder public returns (bool) {\r\n    // We distribute invested coins to new wallets only\r\n    require(balanceOf(_to) == 0);\r\n    require(_value <= accounts[founder]);\r\n    require(unlockDates.length == amounts.length);\r\n\r\n    // We don't check that unlock dates strictly increase.\r\n    // That doesn't matter. It will work out in tryUnlock function.\r\n\r\n    // We don't check that amounts in total equal to _value.\r\n    // tryUnlock unlocks no more that _value anyway.\r\n\r\n    investors[_to].initialAmount = _value;\r\n    investors[_to].lockedAmount = _value;\r\n    investors[_to].currentLockUpPeriod = 0;\r\n\r\n    for (uint256 i=0; i<unlockDates.length; i++) {\r\n      investors[_to].lockUpPeriods.push(LockUp(unlockDates[i], amounts[i]));\r\n    }\r\n\r\n    // ensureLockUp(_to);\r\n    accounts[founder] -= _value;\r\n    emit Transfer(founder, _to, _value);\r\n    totalLocked = totalLocked.add(_value);\r\n    // Check the lock-up periods. If the leading periods are 0 or already expired\r\n    // unlock corresponding coins.\r\n    tryUnlock(_to);\r\n    return true;\r\n  }\r\n\r\n  /// @notice Returns `true` if the wallet has locked COLs\r\n  /// @param _address address of the wallet.\r\n  /// @return `true` if the wallet has locked COLs and `false` otherwise.\r\n  function hasLockup(address _address) public view returns(bool) {\r\n    return (investors[_address].lockedAmount > 0);\r\n  }\r\n\r\n  //\r\n  // Unlock operations\r\n  //\r\n\r\n  /// @dev tells whether the wallet still has lockup and number of seconds until unlock date.\r\n  /// @return locked if `locked` is true, the wallet still has a lockup period, otherwise all lockups expired.\r\n  /// @return seconds amount of time in seconds until unlock date. Zero means that it has expired,\r\n  ///   and the user can invoke `doUnlock` to release corresponding coins.\r\n  function _nextUnlockDate(address who) internal view returns (bool, uint256) {\r\n    if (!hasLockup(who)) {\r\n      return (false, 0);\r\n    }\r\n\r\n    uint256 i = investors[who].currentLockUpPeriod;\r\n    // This must not happen! but still...\r\n    // If all lockup periods have expired, but there are still locked coins,\r\n    // tell the user to unlock.\r\n    if (i == investors[who].lockUpPeriods.length) return (true, 0);\r\n\r\n    if (now < investors[who].lockUpPeriods[i].unlockDate) {\r\n      // If the next unlock date is in the future, return the number of seconds left\r\n      return (true, investors[who].lockUpPeriods[i].unlockDate - now);\r\n    } else {\r\n      // The current unlock period has expired.\r\n      return (true, 0);\r\n    }\r\n  }\r\n\r\n  /// @notice tells the wallet owner whether the wallet still has lockup and number of seconds until unlock date.\r\n  /// @return locked if `locked` is true, the wallet still has a lockup period, otherwise all lockups expired.\r\n  /// @return seconds amount of time in seconds until unlock date. Zero means that it has expired,\r\n  ///   and the user can invoke `doUnlock` to release corresponding coins.\r\n  function nextUnlockDate() public view returns (bool, uint256) {\r\n    return _nextUnlockDate(msg.sender);\r\n  }\r\n\r\n  /// @notice tells to the admin whether the wallet still has lockup and number of seconds until unlock date.\r\n  /// @return locked if `locked` is true, the wallet still has a lockup period, otherwise all lockups expired.\r\n  /// @return seconds amount of time in seconds until unlock date. Zero means that it has expired,\r\n  ///   and the user can invoke `doUnlock` to release corresponding coins.\r\n  function nextUnlockDate_Admin(address who) public view onlyAdmin returns (bool, uint256) {\r\n    return _nextUnlockDate(who);\r\n  }\r\n\r\n  /// @notice the wallet owner signals that the next unlock period has passed, and some coins could be unlocked\r\n  function doUnlock() public {\r\n    tryUnlock(msg.sender);\r\n  }\r\n\r\n  /// @notice admin unlocks coins in the wallet, if any\r\n  /// @param who the wallet to unlock coins\r\n  function doUnlock_Admin(address who) public onlyAdmin {\r\n    tryUnlock(who);\r\n  }\r\n  /// @notice Returns the amount of locked coins in the wallet.\r\n  ///   This function tells the amount of coins to the wallet owner only.\r\n  /// @return amount of locked COLs by `now`.\r\n  function getLockedAmount() public view returns (uint256) {\r\n    return investors[msg.sender].lockedAmount;\r\n  }\r\n\r\n  /// @notice Returns the amount of locked coins in the wallet.\r\n  /// @return amount of locked COLs by `now`.\r\n  function getLockedAmount_Admin(address who) public view onlyAdmin returns (uint256) {\r\n    return investors[who].lockedAmount;\r\n  }\r\n\r\n  function tryUnlock(address _address) internal {\r\n    if (!hasLockup(_address)) {\r\n      return ;\r\n    }\r\n\r\n    uint256 amount = 0;\r\n    uint256 i;\r\n    uint256 start = investors[_address].currentLockUpPeriod;\r\n    uint256 end = investors[_address].lockUpPeriods.length;\r\n\r\n    for ( i = start;\r\n          i < end;\r\n          i++)\r\n    {\r\n      if (investors[_address].lockUpPeriods[i].unlockDate <= now) {\r\n        amount += investors[_address].lockUpPeriods[i].amount;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (i == investors[_address].lockUpPeriods.length) {\r\n      // all unlock periods expired. Unlock all\r\n      amount = investors[_address].lockedAmount;\r\n    } else if (amount > investors[_address].lockedAmount) {\r\n      amount = investors[_address].lockedAmount;\r\n    }\r\n\r\n    if (amount > 0 || i > start) {\r\n      investors[_address].lockedAmount = investors[_address].lockedAmount.sub(amount);\r\n      investors[_address].currentLockUpPeriod = i;\r\n      accounts[_address] = accounts[_address].add(amount);\r\n      emit Unlock(_address, i, amount);\r\n      totalLocked = totalLocked.sub(amount);\r\n    }\r\n  }\r\n\r\n  //\r\n  // Admin privileges - return coins in the case of errors or theft\r\n  //\r\n\r\n  modifier superuser {\r\n    require(msg.sender == admin || msg.sender == founder);\r\n    _;\r\n  }\r\n\r\n  /// @notice Super user (founder or admin) unconditionally transfers COLs from one account to another.\r\n  ///   This function is designed as the last resort in the case of mistake or theft.\r\n  ///   Superuser provides verbal description of the reason to perform this operation.\r\n  ///  @dev   Only superuser can call this function.\r\n  /// @param from   the wallet, where COLs were withdrawn from\r\n  /// @param to   the wallet, where COLs were deposited to\r\n  /// @param amount  amount of coins transferred\r\n  /// @param reason   description of the reason, why super user invokes this transfer\r\n  function adminTransfer(address from, address to, uint256 amount, string memory reason) public superuser {\r\n    if (amount == 0) return;\r\n\r\n    uint256 requested = amount;\r\n    // Revert as much as possible\r\n    if (accounts[from] < amount) {\r\n      amount = accounts[from];\r\n    }\r\n\r\n    accounts[from] -= amount;\r\n    accounts[to] = accounts[to].add(amount);\r\n    emit SuperAction(from, to, requested, amount, reason);\r\n    adminTransferLog.push(AdminTransfer(from, to, amount, reason));\r\n  }\r\n\r\n  /// @notice Returns size of the history of super user actions\r\n  /// @return the number of elements in the log\r\n  function getAdminTransferLogSize() public view superuser returns (uint256) {\r\n    return adminTransferLog.length;\r\n  }\r\n\r\n  /// @notice Returns an element from the history of super user actions\r\n  /// @param  pos   index of element in the log, the oldest element has index `0`\r\n  /// @return tuple `(from, to, amount, reason)`. See description of `adminTransfer` function.\r\n  function getAdminTransferLogItem(uint32 pos) public view superuser\r\n    returns (address from, address to, uint256 amount, string memory reason)\r\n  {\r\n    require(pos < adminTransferLog.length);\r\n    AdminTransfer storage item = adminTransferLog[pos];\r\n    return (item.from, item.to, item.amount, item.reason);\r\n  }\r\n\r\n  //\r\n  // Circulating supply\r\n  //\r\n\r\n  /// @notice Returns the circulating supply of Color Coins.\r\n  ///   It consists of all unlocked coins in user wallets.\r\n  function circulatingSupply() public view returns(uint256) {\r\n    return __totalSupply.sub(accounts[supply]).sub(totalLocked);\r\n  }\r\n\r\n  //\r\n  // Release contract\r\n  //\r\n\r\n  /// @notice Calls `selfdestruct` operator and transfers all Ethers to the founder (if any)\r\n  function destroy() public onlyAdmin {\r\n    selfdestruct(founder);\r\n  }\r\n}\r\n\r\n/// @title Dedicated methods for Pixel program\r\n/// @notice Pixels are a type of “airdrop” distributed to all Color Coin wallet holders,\r\n///   five Pixels a day. They are awarded on a periodic basis. Starting from Sunday GMT 0:00,\r\n///   the Pixels have a lifespan of 24 hours. Pixels in their original form do not have any value.\r\n///   The only way Pixels have value is by sending them to other wallet holders.\r\n///   Pixels must be sent to another person’s account within 24 hours or they will become void.\r\n///   Each user can send up to five Pixels to a single account per week. Once a wallet holder receives Pixels,\r\n///   the Pixels will become Color Coins. The received Pixels may be converted to Color Coins\r\n///   on weekly basis, after Saturday GMT 24:00.\r\n/// @dev Pixel distribution might require thousands and tens of thousands transactions.\r\n///   The methods in this contract consume less gas compared to batch transactions.\r\ncontract ColorCoinWithPixel is ColorCoinBase {\r\n\r\n  address internal pixelAccount;\r\n\r\n  /// @dev The rate to convert pixels to Color Coins\r\n  uint256 internal pixelConvRate;\r\n\r\n  /// @dev Methods could be called by either the founder of the dedicated account.\r\n  modifier pixelOrFounder {\r\n    require(msg.sender == founder || msg.sender == pixelAccount);\r\n    _;\r\n  }\r\n\r\n  function circulatingSupply() public view returns(uint256) {\r\n    uint256 result = super.circulatingSupply();\r\n    return result - balanceOf(pixelAccount);\r\n  }\r\n\r\n  /// @notice Initialises a newly created instance.\r\n  /// @dev Initialises Pixel-related data and transfers `_pixelCoinSupply` COLs\r\n  ///   from the `_founder` to `_pixelAccount`.\r\n  /// @param _totalSupply Total amount of Color Coin tokens available.\r\n  /// @param _founder Address of the founder wallet\r\n  /// @param _admin Address of the admin wallet\r\n  /// @param _pixelCoinSupply Amount of tokens dedicated for Pixel program\r\n  /// @param _pixelAccount Address of the account that keeps coins for the Pixel program\r\n  constructor(uint256 _totalSupply,\r\n    address payable _founder,\r\n    address _admin,\r\n    uint256 _pixelCoinSupply,\r\n    address _pixelAccount\r\n  ) public ColorCoinBase (_totalSupply, _founder, _admin)\r\n  {\r\n    require(_pixelAccount != _founder);\r\n    require(_pixelAccount != _admin);\r\n\r\n    pixelAccount = _pixelAccount;\r\n    accounts[pixelAccount] = _pixelCoinSupply;\r\n    accounts[_founder] = accounts[_founder].sub(_pixelCoinSupply);\r\n    emit Transfer(founder, pixelAccount, accounts[pixelAccount]);\r\n  }\r\n\r\n  /// @notice Founder or the pixel account set the pixel conversion rate.\r\n  ///   Pixel team first sets this conversion rate and then start sending COLs\r\n  ///   in exchange of pixels that people have received.\r\n  /// @dev This rate is used in `sendCoinsForPixels` functions to calculate the amount\r\n  ///   COLs to transfer to pixel holders.\r\n  function setPixelConversionRate(uint256 _pixelConvRate) public pixelOrFounder {\r\n    pixelConvRate = _pixelConvRate;\r\n  }\r\n\r\n  /// @notice Get the conversion rate that was used in the most recent exchange of pixels to COLs.\r\n  function getPixelConversionRate() public view returns (uint256) {\r\n    return pixelConvRate;\r\n  }\r\n\r\n  /// @notice Distribute COL coins for pixels\r\n  ///   COLs are spent from `pixelAccount` wallet. The amount of COLs is equal to `getPixelConversionRate() * pixels`\r\n  /// @dev Only founder and pixel account can invoke this function.\r\n  /// @param pixels       Amount of pixels to exchange into COLs\r\n  /// @param destination  The wallet that holds the pixels.\r\n  function sendCoinsForPixels(\r\n    uint32 pixels, address destination\r\n  ) public pixelOrFounder {\r\n    uint256 coins = pixels*pixelConvRate;\r\n    if (coins == 0) return;\r\n\r\n    require(coins <= accounts[pixelAccount]);\r\n\r\n    accounts[destination] = accounts[destination].add(coins);\r\n    accounts[pixelAccount] -= coins;\r\n  }\r\n\r\n  /// @notice Distribute COL coins for pixels to multiple users.\r\n  ///   This function consumes less gas compared to a batch transaction of `sendCoinsForPixels`.\r\n  ///   `pixels[i]` specifies the amount of pixels belonging to `destinations[i]` wallet.\r\n  ///   COLs are spent from `pixelAccount` wallet. The amount of COLs sent to i-th wallet is equal to `getPixelConversionRate() * pixels[i]`\r\n  /// @dev Only founder and pixel account can invoke this function.\r\n  /// @param pixels         Array of pixel amounts to exchange into COLs\r\n  /// @param destinations   Array of addresses of wallets that hold pixels.\r\n  function sendCoinsForPixels_Batch(\r\n    uint32[] memory pixels,\r\n    address[] memory destinations\r\n  ) public pixelOrFounder {\r\n    require(pixels.length == destinations.length);\r\n    uint256 total = 0;\r\n    for (uint256 i = 0; i < pixels.length; i++) {\r\n      uint256 coins = pixels[i]*pixelConvRate;\r\n      address dst = destinations[i];\r\n      accounts[dst] = accounts[dst].add(coins);\r\n      total += coins;\r\n    }\r\n\r\n    require(total <= accounts[pixelAccount]);\r\n    accounts[pixelAccount] -= total;\r\n  }\r\n\r\n  /// @notice Distribute COL coins for pixels to multiple users.\r\n  ///   COLs are spent from `pixelAccount` wallet. The amount of COLs sent to each wallet is equal to `getPixelConversionRate() * pixels`\r\n  /// @dev The difference between `sendCoinsForPixels_Array` and `sendCoinsForPixels_Batch`\r\n  ///   is that all destination wallets hold the same amount of pixels.\r\n  ///   This optimization saves about 10% of gas compared to `sendCoinsForPixels_Batch`\r\n  ///   with the same amount of recipients.\r\n  /// @param pixels   Amount of pixels to exchange. All of `recipients` hold the same amount of pixels.\r\n  /// @param recipients Addresses of wallets, holding `pixels` amount of pixels.\r\n  function sendCoinsForPixels_Array(\r\n    uint32 pixels, address[] memory recipients\r\n  ) public pixelOrFounder {\r\n    uint256 coins = pixels*pixelConvRate;\r\n    uint256 total = coins * recipients.length;\r\n\r\n    if (total == 0) return;\r\n    require(total <= accounts[pixelAccount]);\r\n\r\n    for (uint256 i; i < recipients.length; i++) {\r\n      address dst = recipients[i];\r\n      accounts[dst] = accounts[dst].add(coins);\r\n    }\r\n\r\n    accounts[pixelAccount] -= total;\r\n  }\r\n}\r\n\r\n\r\n/// @title Smart contract for Color Coin token.\r\n/// @notice Color is the next generation platform for high-performance sophisticated decentralized applications (dApps). https://www.colors.org/\r\n/// @dev Not intended for reuse.\r\ncontract ColorCoin is ColorCoinWithPixel {\r\n  /// @notice Token name\r\n  string public constant name = \"Color Coin\";\r\n\r\n  /// @notice Token symbol\r\n  string public constant symbol = \"COL\";\r\n\r\n  /// @notice Precision in fixed point arithmetics\r\n  uint8 public constant decimals = 18;\r\n\r\n  /// @notice Initialises a newly created instance\r\n  /// @param _totalSupply Total amount of Color Coin tokens available.\r\n  /// @param _founder Address of the founder wallet\r\n  /// @param _admin Address of the admin wallet\r\n  /// @param _pixelCoinSupply Amount of tokens dedicated for Pixel program\r\n  /// @param _pixelAccount Address of the account that keeps coins for the Pixel program\r\n  constructor(uint256 _totalSupply,\r\n    address payable _founder,\r\n    address _admin,\r\n    uint256 _pixelCoinSupply,\r\n    address _pixelAccount\r\n  ) public ColorCoinWithPixel (_totalSupply, _founder, _admin, _pixelCoinSupply, _pixelAccount)\r\n  {\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"unsuspend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isSuspended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"suspend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pixels\",\"type\":\"uint32\"},{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"sendCoinsForPixels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doUnlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pixels\",\"type\":\"uint32\"},{\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"sendCoinsForPixels_Array\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextUnlockDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pixelConvRate\",\"type\":\"uint256\"}],\"name\":\"setPixelConversionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"doUnlock_Admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"nextUnlockDate_Admin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pixels\",\"type\":\"uint32[]\"},{\"name\":\"destinations\",\"type\":\"address[]\"}],\"name\":\"sendCoinsForPixels_Batch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"changeFounder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFounder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"unlockDates\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pos\",\"type\":\"uint32\"}],\"name\":\"getAdminTransferLogItem\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"reason\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasLockup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTransferEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPixelConversionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getLockedAmount_Admin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdminTransferLogSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"adminTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_founder\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_pixelCoinSupply\",\"type\":\"uint256\"},{\"name\":\"_pixelAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returnedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"SuperAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ColorCoin","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000019d971e4fe8401e74000000000000000000000000000000aeefd5f600461bb89e82d172f7dcd731b7e50c0d000000000000000000000000aeefd5f600461bb89e82d172f7dcd731b7e50c0d000000000000000000000000000000000000000000108b2a2c28029094000000000000000000000000000000cd4062cae0e30740a2ebca09125221f2daf601ca","Library":"","SwarmSource":"bzzr://2cc1f8c6a48cb8392182245bc12f09608be86d1a56bf2c26fe7bcbeaf61b4969"}]}