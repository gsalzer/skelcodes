{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n\r\n/** @title A contract for issuing, redeeming and transfering Sila StableCoins\r\n  *\r\n  * @author www.silamoney.com\r\n  * Email: contact@silamoney.com\r\n  *\r\n  */\r\n\r\n/**Run\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\n \r\nlibrary SafeMath{\r\n    \r\n    \r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  \r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    \r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n\r\n    \r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n \r\n   /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n \r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    \r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    \r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n  \r\n  \r\n \r\n   /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  \r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  \r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n    \r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract hotOwner and ColdOwner, and provides authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\n\r\ncontract Ownable {\r\n    \r\n    // hot and cold wallet addresses\r\n    \r\n    address public hotOwner=0xCd39203A332Ff477a35dA3AD2AD7761cDBEAb7F0;\r\n\r\n    address public coldOwner=0x1Ba688e70bb4F3CB266b8D721b5597bFbCCFF957;\r\n    \r\n    \r\n    //events\r\n    \r\n    event OwnershipTransferred(address indexed _newHotOwner,address indexed _newColdOwner,address indexed _oldColdOwner);\r\n\r\n\r\n    /**\r\n   * @dev Reverts if called by any account other than the hotOwner.\r\n   */\r\n   \r\n    modifier onlyHotOwner() {\r\n        require(msg.sender == hotOwner);\r\n        _;\r\n    }\r\n    \r\n     /**\r\n   * @dev Reverts if called by any account other than the coldOwner.\r\n   */\r\n    \r\n    modifier onlyColdOwner() {\r\n        require(msg.sender == coldOwner);\r\n        _;\r\n    }\r\n    \r\n     /**\r\n   * @dev Function assigns new hotowner and coldOwner\r\n   * @param _newHotOwner address The address which owns the funds.\r\n   * @param _newColdOwner address The address which can change the hotOwner.\r\n   */\r\n    \r\n    function transferOwnership(address _newHotOwner,address _newColdOwner) public onlyColdOwner returns (bool) {\r\n        require(_newHotOwner != address(0));\r\n        require(_newColdOwner!= address(0));\r\n        hotOwner = _newHotOwner;\r\n        coldOwner = _newColdOwner;\r\n        emit OwnershipTransferred(_newHotOwner,_newColdOwner,msg.sender);\r\n        return true;\r\n        \r\n        \r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Authorizable\r\n * @dev The Authorizable contract can be used to authorize addresses to control silatoken main functions\r\n * functions, this will provide more flexibility in terms of signing trasactions\r\n */\r\n\r\ncontract Authorizable is Ownable {\r\n    \r\n    //map to check if the address is authorized to issue, redeem sila\r\n    mapping(address => bool) authorized;\r\n    \r\n    //events for when address is added or removed\r\n    event AuthorityAdded(address indexed _toAdd);\r\n    event AuthorityRemoved(address indexed _toRemove);\r\n    \r\n    //array of authorized address to check for all the authorized addresses\r\n    address[] public authorizedAddresses;\r\n\r\n    \r\n    modifier onlyAuthorized() {\r\n        require(authorized[msg.sender] || hotOwner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    \r\n     \r\n     /**\r\n   * @dev Function addAuthorized adds addresses that can issue,redeem and transfer silas\r\n   * @param _toAdd address of the added authority\r\n   */\r\n\r\n    function addAuthorized(address _toAdd) onlyHotOwner public returns(bool) {\r\n        require(_toAdd != address(0));\r\n        require(!authorized[_toAdd]);\r\n        authorized[_toAdd] = true;\r\n        authorizedAddresses.push(_toAdd);\r\n        emit AuthorityAdded(_toAdd);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n   * @dev Function RemoveAuthorized removes addresses that can issue and redeem silas\r\n   * @param _toRemove address of the added authority\r\n   */\r\n\r\n    function removeAuthorized(address _toRemove,uint _toRemoveIndex) onlyHotOwner public returns(bool) {\r\n        require(_toRemove != address(0));\r\n        require(authorized[_toRemove]);\r\n        authorized[_toRemove] = false;\r\n        authorizedAddresses[_toRemoveIndex] = authorizedAddresses[authorizedAddresses.length-1];\r\n        authorizedAddresses.pop();\r\n        emit AuthorityRemoved(_toRemove);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    // view all the authorized addresses\r\n    function viewAuthorized() external view returns(address[] memory _authorizedAddresses){\r\n        return authorizedAddresses;\r\n    }\r\n    \r\n    \r\n    // check if the address is authorized\r\n    \r\n    function isAuthorized(address _authorized) external view returns(bool _isauthorized){\r\n        return authorized[_authorized];\r\n    }\r\n    \r\n    \r\n  \r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EmergencyToggle\r\n * @dev The EmergencyToggle contract provides a way to pause the contract in emergency\r\n */\r\n\r\ncontract EmergencyToggle is Ownable{\r\n     \r\n    //variable to pause the entire contract if true\r\n    bool public emergencyFlag; \r\n\r\n    //constructor\r\n    constructor () public{\r\n      emergencyFlag = false;                            \r\n      \r\n    }\r\n  \r\n  \r\n   /**\r\n    * @dev onlyHotOwner can can pause the usage of issue,redeem, transfer functions\r\n    */\r\n    \r\n    function emergencyToggle() external onlyHotOwner{\r\n      emergencyFlag = !emergencyFlag;\r\n    }\r\n\r\n    \r\n \r\n }\r\n \r\n /**\r\n * @title  Token is Betalist,Blacklist\r\n */\r\n contract Betalist is Authorizable,EmergencyToggle{\r\n     \r\n    //maps for betalisted and blacklisted addresses\r\n    mapping(address=>bool) betalisted;\r\n    mapping(address=>bool) blacklisted;\r\n\r\n    //events for betalist and blacklist\r\n    event BetalistedAddress (address indexed _betalisted);\r\n    event BlacklistedAddress (address indexed _blacklisted);\r\n    event RemovedFromBlacklist(address indexed _toRemoveBlacklist);\r\n    event RemovedFromBetalist(address indexed _toRemoveBetalist);\r\n    \r\n    //variable to check if betalist is required when calling several functions on smart contract\r\n    bool public requireBetalisted;\r\n\r\n\r\n    //constructor\r\n    constructor () public{\r\n        requireBetalisted=true;\r\n        \r\n    }\r\n    \r\n    \r\n   /**\r\n  * @dev betaList the specified address\r\n  * @param _toBetalist the address to betalist\r\n  */\r\n    function betalistAddress(address _toBetalist) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_toBetalist != address(0));\r\n        require(!blacklisted[_toBetalist]);\r\n        require(!betalisted[_toBetalist]);\r\n        betalisted[_toBetalist]=true;\r\n        emit BetalistedAddress(_toBetalist);\r\n        return true;\r\n        \r\n    }\r\n    \r\n     /**\r\n  * @dev remove from betaList the specified address\r\n  * @param _toRemoveBetalist The address to be removed\r\n  */\r\n    function removeAddressFromBetalist(address _toRemoveBetalist) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_toRemoveBetalist != address(0));\r\n        require(betalisted[_toRemoveBetalist]);\r\n        betalisted[_toRemoveBetalist]=false;\r\n        emit RemovedFromBetalist(_toRemoveBetalist);\r\n        return true;\r\n        \r\n    }\r\n    \r\n      \r\n    /**\r\n  * @dev blackList the specified address\r\n  * @param _toBlacklist The address to blacklist\r\n  */\r\n    function blacklistAddress(address _toBlacklist) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_toBlacklist != address(0));\r\n        require(!blacklisted[_toBlacklist]);\r\n        blacklisted[_toBlacklist]=true;\r\n        emit RemovedFromBlacklist(_toBlacklist);\r\n        return true;\r\n        \r\n    }\r\n    \r\n     /**\r\n  * @dev remove from blackList the specified address\r\n  * @param _toRemoveBlacklist The address to blacklist\r\n  */\r\n    function removeAddressFromBlacklist(address _toRemoveBlacklist) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_toRemoveBlacklist != address(0));\r\n        require(blacklisted[_toRemoveBlacklist]);\r\n        blacklisted[_toRemoveBlacklist]=false;\r\n        emit RemovedFromBlacklist(_toRemoveBlacklist);\r\n        return true;\r\n        \r\n    }\r\n \r\n      /**\r\n  * @dev check the specified address if isBetaListed\r\n  * @param _betalisted The address to transfer to.\r\n  */\r\n    function isBetaListed(address _betalisted) external view returns(bool){\r\n            return (betalisted[_betalisted]);\r\n    }\r\n    \r\n     \r\n      /**\r\n  * @dev check the specified address isBlackListed\r\n  * @param _blacklisted The address to transfer to.\r\n  */\r\n    function isBlackListed(address _blacklisted) external view returns(bool){\r\n        return (blacklisted[_blacklisted]);\r\n        \r\n    }\r\n    \r\n    \r\n}\r\n\r\n/**\r\n * @title  Token is token Interface\r\n */\r\n\r\ncontract Token{\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/**\r\n *@title StandardToken\r\n *@dev Implementation of the basic standard token.\r\n */\r\n\r\ncontract StandardToken is Token,Betalist{\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256)  balances;\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n  \r\n  uint256 public totalSupply;\r\n\r\n\r\n \r\n  \r\n  \r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n  }\r\n\r\n  \r\n  \r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  \r\n  function allowance(address _owner,address _spender)public view returns (uint256){\r\n        return allowed[_owner][_spender];\r\n  }\r\n\r\n \r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  \r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(!emergencyFlag);\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n    if (requireBetalisted){\r\n        require(betalisted[_to]);\r\n        require(betalisted[msg.sender]);\r\n    }\r\n    require(!blacklisted[msg.sender]);\r\n    require(!blacklisted[_to]);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n\r\n  }\r\n  \r\n  \r\n    /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    require(!emergencyFlag);\r\n    if (requireBetalisted){\r\n        require(betalisted[msg.sender]);\r\n        require(betalisted[_spender]);\r\n    }\r\n    require(!blacklisted[msg.sender]);\r\n    require(!blacklisted[_spender]);\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n\r\n  }\r\n  \r\n  \r\n    /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n\r\n  function transferFrom(address _from,address _to,uint256 _value)public returns (bool){\r\n    require(!emergencyFlag);\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n    if (requireBetalisted){\r\n        require(betalisted[_to]);\r\n        require(betalisted[_from]);\r\n        require(betalisted[msg.sender]);\r\n    }\r\n    require(!blacklisted[_to]);\r\n    require(!blacklisted[_from]);\r\n    require(!blacklisted[msg.sender]);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n    \r\n  }\r\n\r\n}\r\n\r\ncontract AssignOperator is StandardToken{\r\n    \r\n    //mappings\r\n    \r\n    mapping(address=>mapping(address=>bool)) isOperator;\r\n    \r\n    \r\n    //Events\r\n    event AssignedOperator (address indexed _operator,address indexed _for);\r\n    event OperatorTransfer (address indexed _developer,address indexed _from,address indexed _to,uint _amount);\r\n    event RemovedOperator  (address indexed _operator,address indexed _for);\r\n    \r\n    \r\n    /**\r\n   * @dev AssignedOperator to transfer tokens on users behalf\r\n   * @param _developer address The address which is allowed to transfer tokens on users behalf\r\n   * @param _user address The address which developer want to transfer from\r\n   */\r\n    \r\n    function assignOperator(address _developer,address _user) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_developer != address(0));\r\n        require(_user != address(0));\r\n        require(!isOperator[_developer][_user]);\r\n        if(requireBetalisted){\r\n            require(betalisted[_user]);\r\n            require(betalisted[_developer]);\r\n        }\r\n        require(!blacklisted[_developer]);\r\n        require(!blacklisted[_user]);\r\n        isOperator[_developer][_user]=true;\r\n        emit AssignedOperator(_developer,_user);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n   * @dev RemoveOperator allowed to transfer tokens on users behalf\r\n   * @param _developer address The address which is allowed to trasnfer tokens on users behalf\r\n   * @param _user address The address which developer want to transfer from\r\n   */\r\n    function removeOperator(address _developer,address _user) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_developer != address(0));\r\n        require(_user != address(0));\r\n        require(isOperator[_developer][_user]);\r\n        isOperator[_developer][_user]=false;\r\n        emit RemovedOperator(_developer,_user);\r\n        return true;\r\n        \r\n    }\r\n    \r\n    /**\r\n   * @dev Operatransfer for developer to transfer tokens on users behalf without requiring ethers in managed  ethereum accounts\r\n   * @param _from address the address to transfer tokens from\r\n   * @param _to address The address which developer want to transfer to\r\n   * @param _amount the amount of tokens user wants to transfer\r\n   */\r\n    \r\n    function operatorTransfer(address _from,address _to,uint _amount) public returns (bool){\r\n        require(!emergencyFlag);\r\n        require(isOperator[msg.sender][_from]);\r\n        require(_amount <= balances[_from]);\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        if (requireBetalisted){\r\n            require(betalisted[_to]);\r\n            require(betalisted[_from]);\r\n            require(betalisted[msg.sender]);\r\n        }\r\n        require(!blacklisted[_to]);\r\n        require(!blacklisted[_from]);\r\n        require(!blacklisted[msg.sender]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit OperatorTransfer(msg.sender,_from, _to, _amount);\r\n        emit Transfer(_from,_to,_amount);\r\n        return true;\r\n        \r\n        \r\n    }\r\n    \r\n     /**\r\n   * @dev checkIsOperator is developer an operator allowed to transfer tokens on users behalf\r\n   * @param _developer the address allowed to trasnfer tokens \r\n   * @param _for address The address which developer want to transfer from\r\n   */\r\n    \r\n    function checkIsOperator(address _developer,address _for) external view returns (bool){\r\n            return (isOperator[_developer][_for]);\r\n    }\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n /**\r\n *@title SilaToken\r\n *@dev Implementation for sila issue,redeem,protectedTransfer and batch functions\r\n */\r\n\r\ncontract SilaToken is AssignOperator{\r\n    using SafeMath for uint256;\r\n    \r\n    // parameters for silatoken\r\n    string  public constant name = \"SilaToken\";\r\n    string  public constant symbol = \"SILA\";\r\n    uint256 public constant decimals = 18;\r\n    string  public version = \"1.0\";\r\n    \r\n     \r\n    //Events fired during successfull execution of main silatoken functions\r\n    event Issued(address indexed _to,uint256 _value);\r\n    event Redeemed(address indexed _from,uint256 _amount);\r\n    event ProtectedTransfer(address indexed _from,address indexed _to,uint256 _amount);\r\n    event ProtectedApproval(address indexed _owner,address indexed _spender,uint256 _amount);\r\n    event GlobalLaunchSila(address indexed _launcher);\r\n    \r\n    \r\n\r\n    /**\r\n   * @dev issue tokens from sila  to _to address\r\n   * @dev onlyAuthorized  addresses can call this function\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _amount uint256 the amount of tokens to be issued\r\n   */\r\n\r\n    function issue(address _to, uint256 _amount) public onlyAuthorized returns (bool) {\r\n        require(!emergencyFlag);\r\n        require(_to !=address(0));\r\n        if (requireBetalisted){\r\n            require(betalisted[_to]);\r\n        }\r\n        require(!blacklisted[_to]);\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);                 \r\n        emit Issued(_to, _amount);                     \r\n        return true;\r\n    }\r\n    \r\n    \r\n      \r\n   /**\r\n   * @dev redeem tokens from _from address\r\n   * @dev onlyAuthorized  addresses can call this function\r\n   * @param _from address is the address from which tokens are burnt\r\n   * @param _amount uint256 the amount of tokens to be burnt\r\n   */\r\n\r\n    function redeem(address _from,uint256 _amount) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_from != address(0));\r\n        require(_amount <= balances[_from]);\r\n        if(requireBetalisted){\r\n            require(betalisted[_from]);\r\n        }\r\n        require(!blacklisted[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);   \r\n        totalSupply = totalSupply.sub(_amount);\r\n        emit Redeemed(_from,_amount);\r\n        return true;\r\n            \r\n\r\n    }\r\n    \r\n    \r\n    /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @dev onlyAuthorized  addresses can call this function\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _amount uint256 the amount of tokens to be transferred\r\n   */\r\n\r\n    function protectedTransfer(address _from,address _to,uint256 _amount) public onlyAuthorized returns(bool){\r\n        require(!emergencyFlag);\r\n        require(_amount <= balances[_from]);\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        if (requireBetalisted){\r\n            require(betalisted[_to]);\r\n            require(betalisted[_from]);\r\n        }\r\n        require(!blacklisted[_to]);\r\n        require(!blacklisted[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit ProtectedTransfer(_from, _to, _amount);\r\n        emit Transfer(_from,_to,_amount);\r\n        return true;\r\n        \r\n    }\r\n    \r\n    \r\n    /**\r\n    * @dev Launch sila for global transfers to work as standard\r\n    */\r\n    \r\n    function globalLaunchSila() public onlyHotOwner{\r\n            require(!emergencyFlag);\r\n            require(requireBetalisted);\r\n            requireBetalisted=false;\r\n            emit GlobalLaunchSila(msg.sender);\r\n    }\r\n    \r\n    \r\n    \r\n     /**\r\n   * @dev batchissue , isuue tokens in batches to multiple addresses at a time\r\n   * @param _amounts The amount of tokens to be issued.\r\n   * @param _toAddresses tokens to be issued to these addresses respectively\r\n    */\r\n    \r\n    function batchIssue(address[] memory _toAddresses,uint256[]  memory _amounts) public onlyAuthorized returns(bool) {\r\n            require(!emergencyFlag);\r\n            require(_toAddresses.length==_amounts.length);\r\n            for(uint i = 0; i < _toAddresses.length; i++) {\r\n                bool check=issue(_toAddresses[i],_amounts[i]);\r\n                require(check);\r\n            }\r\n            return true;\r\n            \r\n    }\r\n    \r\n    \r\n    /**\r\n    * @dev batchredeem , redeem tokens in batches from multiple addresses at a time\r\n    * @param _amounts The amount of tokens to be redeemed.\r\n    * @param _fromAddresses tokens to be redeemed to from addresses respectively\r\n     */\r\n    \r\n    function batchRedeem(address[] memory  _fromAddresses,uint256[]  memory _amounts) public onlyAuthorized returns(bool){\r\n            require(!emergencyFlag);\r\n            require(_fromAddresses.length==_amounts.length);\r\n            for(uint i = 0; i < _fromAddresses.length; i++) {\r\n                bool check=redeem(_fromAddresses[i],_amounts[i]);\r\n                require(check);\r\n            }  \r\n            return true;\r\n        \r\n    }\r\n    \r\n    \r\n      /**\r\n    * @dev batchTransfer, transfer tokens in batches between multiple addresses at a time\r\n    * @param _fromAddresses tokens to be transfered to these addresses respectively\r\n    * @param _toAddresses tokens to be transfered to these addresses respectively\r\n    * @param _amounts The amount of tokens to be transfered\r\n     */\r\n    function protectedBatchTransfer(address[] memory _fromAddresses,address[]  memory _toAddresses,uint256[] memory  _amounts) public onlyAuthorized returns(bool){\r\n            require(!emergencyFlag);\r\n            require(_fromAddresses.length==_amounts.length);\r\n            require(_toAddresses.length==_amounts.length);\r\n            require(_fromAddresses.length==_toAddresses.length);\r\n            for(uint i = 0; i < _fromAddresses.length; i++) {\r\n                bool check=protectedTransfer(_fromAddresses[i],_toAddresses[i],_amounts[i]);\r\n                require(check);\r\n               \r\n            }\r\n            return true;\r\n        \r\n    } \r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"emergencyToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"operatorTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewAuthorized\",\"outputs\":[{\"name\":\"_authorizedAddresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toRemoveBlacklist\",\"type\":\"address\"}],\"name\":\"removeAddressFromBlacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"globalLaunchSila\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coldOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toRemoveBetalist\",\"type\":\"address\"}],\"name\":\"removeAddressFromBetalist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchRedeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHotOwner\",\"type\":\"address\"},{\"name\":\"_newColdOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toBetalist\",\"type\":\"address\"}],\"name\":\"betalistAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hotOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorizedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"},{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"checkIsOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toRemove\",\"type\":\"address\"},{\"name\":\"_toRemoveIndex\",\"type\":\"uint256\"}],\"name\":\"removeAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireBetalisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"name\":\"_toAddresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"protectedBatchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAdd\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_betalisted\",\"type\":\"address\"}],\"name\":\"isBetaListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blacklisted\",\"type\":\"address\"}],\"name\":\"isBlackListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"protectedTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toBlacklist\",\"type\":\"address\"}],\"name\":\"blacklistAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"assignOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_authorized\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"_isauthorized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ProtectedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ProtectedApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_launcher\",\"type\":\"address\"}],\"name\":\"GlobalLaunchSila\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"AssignedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_developer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"OperatorTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"RemovedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_betalisted\",\"type\":\"address\"}],\"name\":\"BetalistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_blacklisted\",\"type\":\"address\"}],\"name\":\"BlacklistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_toRemoveBlacklist\",\"type\":\"address\"}],\"name\":\"RemovedFromBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_toRemoveBetalist\",\"type\":\"address\"}],\"name\":\"RemovedFromBetalist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_toAdd\",\"type\":\"address\"}],\"name\":\"AuthorityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_toRemove\",\"type\":\"address\"}],\"name\":\"AuthorityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newHotOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newColdOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_oldColdOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SilaToken","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e0572e24d8b927324e4b7a7b5068bb3c391971b0d4c91cda7b67de263c67e91d"}]}