{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * Syndicate\r\n **/\r\n\r\n/// @title A way to distribute ownership of Ether in time\r\n/// @author Chance Hudson\r\n/// @notice This contract can be used to manipulate ownership of Ether across\r\n/// time. Funds are linearly distributed over the time period to recipients.\r\ncontract Syndicate {\r\n\r\n  struct Payment {\r\n    address sender;\r\n    address payable receiver;\r\n    uint256 timestamp;\r\n    uint256 time;\r\n    uint256 weiValue;\r\n    uint256 weiPaid;\r\n    bool isFork;\r\n    uint256 parentIndex;\r\n  }\r\n\r\n  Payment[] public payments;\r\n  mapping(uint256 => uint256[]) public paymentForks;\r\n\r\n  event PaymentUpdated(uint256 index);\r\n  event PaymentCreated(uint256 index);\r\n\r\n  /// @notice Create a payment from `msg.sender` of amount `msg.value` to\r\n  /// `_receiver` over `_time` seconds. The funds are linearly distributed in\r\n  /// this time. The `_receiver` may fork the funds to another address but\r\n  /// cannot manipulate the `_time` value.\r\n  /// @param _receiver The address receiving the payment\r\n  /// @param _time The payment time length, in seconds\r\n  function paymentCreate(address payable _receiver, uint256 _time) public payable {\r\n    // Verify that value has been sent\r\n    require(msg.value > 0);\r\n    // Verify the time is non-zero\r\n    require(_time > 0);\r\n    payments.push(Payment({\r\n      sender: msg.sender,\r\n      receiver: _receiver,\r\n      timestamp: block.timestamp,\r\n      time: _time,\r\n      weiValue: msg.value,\r\n      weiPaid: 0,\r\n      isFork: false,\r\n      parentIndex: 0\r\n    }));\r\n    paymentForks[payments.length - 1] = new uint256[](0);\r\n    emit PaymentCreated(payments.length - 1);\r\n  }\r\n\r\n  /// @notice Withdraws the available funds at the current point in time from a\r\n  /// payment to the receiver address.\r\n  /// @dev May be invoked by anyone idempotently.\r\n  /// @param index The payment index to settle\r\n  function paymentSettle(uint256 index) public {\r\n    requirePaymentIndexInRange(index);\r\n    Payment storage payment = payments[index];\r\n    uint256 owedWei = paymentWeiOwed(index);\r\n    payment.weiPaid += owedWei;\r\n    payment.receiver.transfer(owedWei);\r\n    emit PaymentUpdated(index);\r\n  }\r\n\r\n  /// @notice Calculates the amount of wei owed on a payment at the current\r\n  /// `block.timestamp`.\r\n  /// @param index The payment index for which to determine wei owed\r\n  /// @return The wei owed at the current point in time\r\n  function paymentWeiOwed(uint256 index) public view returns (uint256) {\r\n    requirePaymentIndexInRange(index);\r\n    Payment memory payment = payments[index];\r\n    // Calculate owed wei based on current time and total wei owed/paid\r\n    return max(payment.weiPaid, payment.weiValue * min(block.timestamp - payment.timestamp, payment.time) / payment.time) - payment.weiPaid;\r\n  }\r\n\r\n  /// @notice Forks part of a payment to another address for the remaining time\r\n  /// on a payment. Allows responsibility of funds to be delegated to other\r\n  /// addresses by the payment recipient. A payment and all forks share the same\r\n  /// completion time.\r\n  /// @dev Payments may only be forked by the receiver address. The `_weiValue`\r\n  /// being forked must be less than the wei currently available in the payment.\r\n  /// @param index The payment index to be forked\r\n  /// @param _receiver The fork payment recipient\r\n  /// @param _weiValue The amount of wei to fork\r\n  function paymentFork(uint256 index, address payable _receiver, uint256 _weiValue) public {\r\n    requirePaymentIndexInRange(index);\r\n    Payment storage payment = payments[index];\r\n    // Make sure the payment receiver is operating\r\n    require(msg.sender == payment.receiver);\r\n\r\n    uint256 remainingWei = payment.weiValue - payment.weiPaid;\r\n    uint256 remainingTime = max(0, payment.time - (block.timestamp - payment.timestamp));\r\n\r\n    // Ensure there is more remainingWei than requested fork wei\r\n    require(remainingWei > _weiValue);\r\n    require(_weiValue > 0);\r\n\r\n    // Create a new Payment of _weiValue to _receiver over the remaining time of\r\n    // payment at index\r\n\r\n    payment.weiValue -= _weiValue;\r\n\r\n    // Now create the forked payment\r\n    payments.push(Payment({\r\n      sender: payment.receiver,\r\n      receiver: _receiver,\r\n      timestamp: block.timestamp,\r\n      time: remainingTime,\r\n      weiValue: _weiValue,\r\n      weiPaid: 0,\r\n      isFork: true,\r\n      parentIndex: index\r\n    }));\r\n    uint256 forkIndex = payments.length - 1;\r\n    paymentForks[forkIndex] = new uint256[](0);\r\n    paymentForks[index].push(forkIndex);\r\n    emit PaymentUpdated(index);\r\n    emit PaymentCreated(forkIndex);\r\n  }\r\n\r\n  /// @notice Accessor for determining if a given payment has any forks.\r\n  /// @param index The payment to check\r\n  /// @return Whether payment `index` has been forked\r\n  function isPaymentForked(uint256 index) public view returns (bool) {\r\n    requirePaymentIndexInRange(index);\r\n    return paymentForks[index].length > 0;\r\n  }\r\n\r\n  /// @notice Accessor for payment fork count.\r\n  /// @param index The payment for which to get the fork count\r\n  /// @return The number of time payment `index` has been forked\r\n  function paymentForkCount(uint256 index) public view returns (uint256) {\r\n    requirePaymentIndexInRange(index);\r\n    return paymentForks[index].length;\r\n  }\r\n\r\n  /// @notice Accessor for determining if a payment is settled.\r\n  /// @param index The payment to check\r\n  /// @return Whether a payment has been fully paid\r\n  function isPaymentSettled(uint256 index) public view returns (bool) {\r\n    requirePaymentIndexInRange(index);\r\n    return payments[index].weiValue == payments[index].weiPaid;\r\n  }\r\n\r\n  /// @dev Throws if `index` is out of range.\r\n  /// @param index The payment index to check\r\n  function requirePaymentIndexInRange(uint256 index) public view {\r\n    require(index < payments.length);\r\n  }\r\n\r\n  /// @notice Accessor for payments array length.\r\n  /// @return The number of payments that exist in the Syndicate\r\n  function paymentCount() public view returns (uint) {\r\n    return payments.length;\r\n  }\r\n\r\n  /// @dev Return the smaller of two values.\r\n  function min(uint a, uint b) private pure returns (uint) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /// @dev Return the larger of two values.\r\n  function max(uint a, uint b) private pure returns (uint) {\r\n    return a > b ? a : b;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentForkCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isPaymentForked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"requirePaymentIndexInRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentWeiOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isPaymentSettled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"weiValue\",\"type\":\"uint256\"},{\"name\":\"weiPaid\",\"type\":\"uint256\"},{\"name\":\"isFork\",\"type\":\"bool\"},{\"name\":\"parentIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_weiValue\",\"type\":\"uint256\"}],\"name\":\"paymentFork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentForks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paymentCreate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"PaymentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"PaymentCreated\",\"type\":\"event\"}]","ContractName":"Syndicate","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0fa13a5694c1f4154303fdc9c9b2cbd0be0917eb93c04a6319a8274ea054db00"}]}