{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Objects {\r\n    struct Investment {\r\n        uint256 planId;\r\n        uint256 investmentDate;\r\n        uint256 investment;\r\n        uint256 lastWithdrawalDate;\r\n        uint256 currentDividends;\r\n        bool isExpired;\r\n        bool isReInvest;\r\n    }\r\n\r\n    struct Plan {\r\n        uint256 dailyInterest;\r\n        uint256 term; //0 means unlimited\r\n        uint256 limit; //0 means unlimited\r\n        uint256 perInvestorLimit;\r\n        uint256 leftAmount;\r\n        uint256 lastUpdateDate;\r\n    }\r\n\r\n    struct Investor {\r\n        address addr;\r\n        uint256 referrerEarnings;\r\n        uint256 availableReferrerEarnings;\r\n        uint256 referrer;\r\n        uint256 planCount;\r\n        mapping(uint256 => Investment) plans;\r\n        uint256 level1RefCount;\r\n        uint256 level2RefCount;\r\n        uint256 level3RefCount;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event onOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        emit onOwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\ncontract CCBank is Ownable {\r\n    using SafeMath for uint256;\r\n    uint256 public constant DEVELOPER_RATE = 30; //per thousand\r\n    uint256 public constant MARKETING_RATE = 70;\r\n    uint256 public constant REFERENCE_RATE = 80;\r\n    uint256 public constant REFERENCE_LEVEL1_RATE = 50;\r\n    uint256 public constant REFERENCE_LEVEL2_RATE = 20;\r\n    uint256 public constant REFERENCE_LEVEL3_RATE = 10;\r\n    // uint256 public constant REFERENCE_SELF_RATE = 5;\r\n    uint256 public constant MINIMUM = 0.01 ether; // 0.01eth, minimum investment needed\r\n    uint256 public constant REFERRER_CODE = 3466; //default\r\n\r\n    uint256 public latestReferrerCode;\r\n    uint256 private totalInvestments_;\r\n\r\n    address private developerAccount_;\r\n    address private marketingAccount_;\r\n    address private referenceAccount_;\r\n\r\n    mapping(address => uint256) public address2UID;\r\n    mapping(uint256 => Objects.Investor) public uid2Investor;\r\n    Objects.Plan[] private investmentPlans_;\r\n\r\n    event onInvest(address investor, uint256 amount);\r\n    event onReinvest(address investor, uint256 amount);\r\n    event onGrant(address grantor, address beneficiary, uint256 amount);\r\n    event onWithdraw(address investor, uint256 amount);\r\n\r\n    /**\r\n     * @dev Constructor Sets the original roles of the contract\r\n     */\r\n\r\n    constructor() public {\r\n        developerAccount_ = msg.sender;\r\n        marketingAccount_ = msg.sender;\r\n        referenceAccount_ = msg.sender;\r\n        _init();\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value == 0) {\r\n            withdraw();\r\n        } else {\r\n            invest(0, 0); //default to buy plan 0, no referrer\r\n        }\r\n    }\r\n\r\n    function checkIn() public {\r\n    }\r\n\r\n    function setMarketingAccount(address _newMarketingAccount) public onlyOwner {\r\n        require(_newMarketingAccount != address(0));\r\n        marketingAccount_ = _newMarketingAccount;\r\n    }\r\n\r\n    function getMarketingAccount() public view onlyOwner returns (address) {\r\n        return marketingAccount_;\r\n    }\r\n\r\n    function setDeveloperAccount(address _newDeveloperAccount) public onlyOwner {\r\n        require(_newDeveloperAccount != address(0));\r\n        developerAccount_ = _newDeveloperAccount;\r\n    }\r\n\r\n    function getDeveloperAccount() public view onlyOwner returns (address) {\r\n        return developerAccount_;\r\n    }\r\n\r\n    function setReferenceAccount(address _newReferenceAccount) public onlyOwner {\r\n        require(_newReferenceAccount != address(0));\r\n        referenceAccount_ = _newReferenceAccount;\r\n    }\r\n\r\n    function setPlanLimit(uint256 _planId, uint256 _perInvestorLimit, uint256 _addAmount) public onlyOwner {\r\n        require(_planId >= 0 && _planId < investmentPlans_.length, \"Wrong investment plan id\");\r\n        Objects.Plan storage plan = investmentPlans_[_planId];\r\n        plan.perInvestorLimit = _perInvestorLimit;\r\n        plan.leftAmount = plan.leftAmount.add(_addAmount);\r\n        plan.lastUpdateDate = block.timestamp;\r\n    }\r\n\r\n    function getReferenceAccount() public view onlyOwner returns (address) {\r\n        return referenceAccount_;\r\n    }\r\n\r\n    function _init() private {\r\n        latestReferrerCode = REFERRER_CODE;\r\n        address2UID[msg.sender] = latestReferrerCode;\r\n        uid2Investor[latestReferrerCode].addr = msg.sender;\r\n        uid2Investor[latestReferrerCode].referrer = 0;\r\n        uid2Investor[latestReferrerCode].planCount = 0;\r\n        investmentPlans_.push(Objects.Plan( 50,           0, 0,          0,              0, block.timestamp)); // 5%, unlimited\r\n        investmentPlans_.push(Objects.Plan( 60, 45*60*60*24, 0,          0,              0, block.timestamp)); // 6%, 45 days\r\n        investmentPlans_.push(Objects.Plan( 70, 25*60*60*24, 0,          0,              0, block.timestamp)); // 7%, 25 days\r\n        investmentPlans_.push(Objects.Plan( 80, 18*60*60*24, 0,          0,              0, block.timestamp)); // 8%, 18 days\r\n        investmentPlans_.push(Objects.Plan(100,           0, 1, 1 ether, 2000 ether, block.timestamp)); //10%, unlimited, 1 eth, 2000 eth\r\n    }\r\n\r\n    function getCurrentPlans() public view returns (uint256[] memory,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        uint256[] memory) {\r\n        uint256[] memory ids               = new uint256[](investmentPlans_.length);\r\n        uint256[] memory interests         = new uint256[](investmentPlans_.length);\r\n        uint256[] memory terms             = new uint256[](investmentPlans_.length);\r\n        uint256[] memory limits            = new uint256[](investmentPlans_.length);\r\n        uint256[] memory perInvestorLimits = new uint256[](investmentPlans_.length);\r\n        uint256[] memory leftAmounts       = new uint256[](investmentPlans_.length);\r\n        for (uint256 i = 0; i < investmentPlans_.length; i++) {\r\n            Objects.Plan storage plan = investmentPlans_[i];\r\n            ids[i] = i;\r\n            interests[i] = plan.dailyInterest;\r\n            terms[i] = plan.term;\r\n            limits[i] = plan.limit;\r\n            perInvestorLimits[i] = plan.perInvestorLimit;\r\n            leftAmounts[i] = plan.leftAmount;\r\n        }\r\n        return\r\n        (\r\n        ids,\r\n        interests,\r\n        terms,\r\n        limits,\r\n        perInvestorLimits,\r\n        leftAmounts\r\n        );\r\n    }\r\n\r\n    function addNewPlan(uint256 dailyInterest, uint256 term, uint256 limit, uint256 perInvestorLimit, uint256 leftAmount) public onlyOwner {\r\n        investmentPlans_.push(Objects.Plan(dailyInterest,  term, limit, perInvestorLimit, leftAmount, block.timestamp));\r\n    }\r\n\r\n    function getTotalInvestments() public onlyOwner view returns (uint256){\r\n        return totalInvestments_;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getUIDByAddress(address _addr) public view returns (uint256) {\r\n        return address2UID[_addr];\r\n    }\r\n\r\n    function getInvestorInfoByUID(uint256 _uid) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256[] memory, uint256[] memory) {\r\n        if (msg.sender != owner) {\r\n            require(address2UID[msg.sender] == _uid, \"only owner or self can check the investor info.\");\r\n        }\r\n        Objects.Investor storage investor = uid2Investor[_uid];\r\n        uint256[] memory newDividends = new uint256[](investor.planCount);\r\n        uint256[] memory currentDividends = new  uint256[](investor.planCount);\r\n        for (uint256 i = 0; i < investor.planCount; i++) {\r\n            require(investor.plans[i].investmentDate != 0, \"wrong investment date\");\r\n            currentDividends[i] = investor.plans[i].currentDividends;\r\n            if (investor.plans[i].isExpired) {\r\n                newDividends[i] = 0;\r\n            } else {\r\n                if (investmentPlans_[investor.plans[i].planId].term > 0) {\r\n                    if (block.timestamp >= investor.plans[i].investmentDate.add(investmentPlans_[investor.plans[i].planId].term)) {\r\n                        newDividends[i] = _calculateDividends(investor.plans[i].investment, investmentPlans_[investor.plans[i].planId].dailyInterest, investor.plans[i].investmentDate.add(investmentPlans_[investor.plans[i].planId].term), investor.plans[i].lastWithdrawalDate);\r\n                    } else {\r\n                        newDividends[i] = _calculateDividends(investor.plans[i].investment, investmentPlans_[investor.plans[i].planId].dailyInterest, block.timestamp, investor.plans[i].lastWithdrawalDate);\r\n                    }\r\n                } else {\r\n                    newDividends[i] = _calculateDividends(investor.plans[i].investment, investmentPlans_[investor.plans[i].planId].dailyInterest, block.timestamp, investor.plans[i].lastWithdrawalDate);\r\n                }\r\n            }\r\n        }\r\n        return\r\n        (\r\n        investor.referrerEarnings,\r\n        investor.availableReferrerEarnings,\r\n        investor.referrer,\r\n        investor.level1RefCount,\r\n        investor.level2RefCount,\r\n        investor.level3RefCount,\r\n        investor.planCount,\r\n        currentDividends,\r\n        newDividends\r\n        );\r\n    }\r\n\r\n    function getInvestorPlanLimitsByUID(uint256 _uid, uint256 _planId) public view returns (uint256, uint256, uint256) {\r\n        if (msg.sender != owner) {\r\n            require(address2UID[msg.sender] == _uid, \"only owner or self can check the investor info.\");\r\n        }\r\n        require(_planId >= 0 && _planId < investmentPlans_.length, \"Wrong investment plan id\");\r\n\r\n        Objects.Investor storage investor = uid2Investor[_uid];\r\n        Objects.Plan storage plan = investmentPlans_[_planId];\r\n        uint256 totalInvestment = 0;\r\n        uint256 leftInvestmentLimit = 0;\r\n        if (plan.limit != 0) {\r\n            for (uint256 i = 0; i < investor.planCount; i++) {\r\n                require(investor.plans[i].investmentDate != 0, \"wrong investment date\");\r\n                if (investor.plans[i].planId != _planId || investor.plans[i].investmentDate < plan.lastUpdateDate) {\r\n                    continue;\r\n                }\r\n                totalInvestment = totalInvestment.add(investor.plans[i].investment);\r\n            }\r\n            leftInvestmentLimit = (totalInvestment > plan.perInvestorLimit) ? 0 : plan.perInvestorLimit.sub(totalInvestment);\r\n        }\r\n\r\n        return\r\n        (\r\n        plan.limit,\r\n        plan.leftAmount,\r\n        leftInvestmentLimit\r\n        );\r\n    }\r\n\r\n    function getInvestmentPlanByUID(uint256 _uid) public view returns (uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory, bool[] memory) {\r\n        if (msg.sender != owner) {\r\n            require(address2UID[msg.sender] == _uid, \"only owner or self can check the investment plan info.\");\r\n        }\r\n        Objects.Investor storage investor = uid2Investor[_uid];\r\n        uint256[] memory planIds = new  uint256[](investor.planCount);\r\n        uint256[] memory investmentDates = new  uint256[](investor.planCount);\r\n        uint256[] memory investments = new  uint256[](investor.planCount);\r\n        uint256[] memory currentDividends = new  uint256[](investor.planCount);\r\n        bool[] memory isExpireds = new  bool[](investor.planCount);\r\n\r\n        for (uint256 i = 0; i < investor.planCount; i++) {\r\n            require(investor.plans[i].investmentDate != 0, \"wrong investment date\");\r\n            planIds[i] = investor.plans[i].planId;\r\n            currentDividends[i] = investor.plans[i].currentDividends;\r\n            investmentDates[i] = investor.plans[i].investmentDate;\r\n            investments[i] = investor.plans[i].investment;\r\n            if (investor.plans[i].isExpired) {\r\n                isExpireds[i] = true;\r\n            } else {\r\n                isExpireds[i] = false;\r\n                if (investmentPlans_[investor.plans[i].planId].term > 0) {\r\n                    if (block.timestamp >= investor.plans[i].investmentDate.add(investmentPlans_[investor.plans[i].planId].term)) {\r\n                        isExpireds[i] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return\r\n        (\r\n        planIds,\r\n        investmentDates,\r\n        investments,\r\n        currentDividends,\r\n        isExpireds\r\n        );\r\n    }\r\n\r\n    function _addInvestor(address _addr, uint256 _referrerCode) private returns (uint256) {\r\n        if (_referrerCode >= REFERRER_CODE) {\r\n            //require(uid2Investor[_referrerCode].addr != address(0), \"Wrong referrer code\");\r\n            if (uid2Investor[_referrerCode].addr == address(0)) {\r\n                _referrerCode = 0;\r\n            }\r\n        } else {\r\n            _referrerCode = 0;\r\n        }\r\n        address addr = _addr;\r\n        latestReferrerCode = latestReferrerCode.add(1);\r\n        address2UID[addr] = latestReferrerCode;\r\n        uid2Investor[latestReferrerCode].addr = addr;\r\n        uid2Investor[latestReferrerCode].referrer = _referrerCode;\r\n        uid2Investor[latestReferrerCode].planCount = 0;\r\n        if (_referrerCode >= REFERRER_CODE) {\r\n            uint256 _ref1 = _referrerCode;\r\n            uint256 _ref2 = uid2Investor[_ref1].referrer;\r\n            uint256 _ref3 = uid2Investor[_ref2].referrer;\r\n            uid2Investor[_ref1].level1RefCount = uid2Investor[_ref1].level1RefCount.add(1);\r\n            if (_ref2 >= REFERRER_CODE) {\r\n                uid2Investor[_ref2].level2RefCount = uid2Investor[_ref2].level2RefCount.add(1);\r\n            }\r\n            if (_ref3 >= REFERRER_CODE) {\r\n                uid2Investor[_ref3].level3RefCount = uid2Investor[_ref3].level3RefCount.add(1);\r\n            }\r\n        }\r\n        return (latestReferrerCode);\r\n    }\r\n\r\n    function _invest(address _addr, uint256 _planId, uint256 _referrerCode, uint256 _amount, bool isReInvest) private returns (bool) {\r\n        require(_planId >= 0 && _planId < investmentPlans_.length, \"Wrong investment plan id\");\r\n        require(_amount >= MINIMUM, \"Less than the minimum amount of deposit requirement\");\r\n\r\n        uint256 uid = address2UID[_addr];\r\n        if (uid == 0) {\r\n            uid = _addInvestor(_addr, _referrerCode);\r\n            //new user\r\n        } else {//old user\r\n            //do nothing, referrer is permenant\r\n        }\r\n\r\n        _checkLimit(uid, _planId, _amount);\r\n\r\n        uint256 planCount = uid2Investor[uid].planCount;\r\n        Objects.Investor storage investor = uid2Investor[uid];\r\n        investor.plans[planCount].planId = _planId;\r\n        investor.plans[planCount].investmentDate = block.timestamp;\r\n        investor.plans[planCount].lastWithdrawalDate = block.timestamp;\r\n        investor.plans[planCount].investment = _amount;\r\n        investor.plans[planCount].currentDividends = 0;\r\n        investor.plans[planCount].isExpired = false;\r\n        investor.plans[planCount].isReInvest = isReInvest;\r\n\r\n        investor.planCount = investor.planCount.add(1);\r\n\r\n        _calculateReferrerReward(uid, _amount, investor.referrer);\r\n\r\n        totalInvestments_ = totalInvestments_.add(_amount);\r\n\r\n        uint256 developerPercentage = (_amount.mul(DEVELOPER_RATE)).div(1000);\r\n        developerAccount_.transfer(developerPercentage);\r\n        uint256 marketingPercentage = (_amount.mul(MARKETING_RATE)).div(1000);\r\n        marketingAccount_.transfer(marketingPercentage);\r\n        return true;\r\n    }\r\n\r\n    function _checkLimit(uint256 _uid, uint256 _planId, uint256 _amount) private {\r\n        Objects.Plan storage plan = investmentPlans_[_planId];\r\n        if (plan.limit > 0) {\r\n            require(plan.leftAmount >= _amount && plan.perInvestorLimit >= _amount, \"1 - Not enough limit\");\r\n\r\n            Objects.Investor storage investor = uid2Investor[_uid];\r\n            uint256 totalInvestment = 0;\r\n            uint256 leftInvestmentLimit = 0;\r\n            for (uint256 i = 0; i < investor.planCount; i++) {\r\n                require(investor.plans[i].investmentDate != 0, \"wrong investment date\");\r\n                if (investor.plans[i].planId != _planId || investor.plans[i].investmentDate < plan.lastUpdateDate) {\r\n                    continue;\r\n                }\r\n                totalInvestment = totalInvestment.add(investor.plans[i].investment);\r\n\r\n            }\r\n            leftInvestmentLimit = (totalInvestment > plan.perInvestorLimit) ? 0 : plan.perInvestorLimit.sub(totalInvestment);\r\n\r\n            require(leftInvestmentLimit >= _amount, \"2 - Not enough limit\");\r\n\r\n            plan.leftAmount = plan.leftAmount.sub(_amount);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function grant(address addr, uint256 _planId) public payable {\r\n        uint256 grantorUid = address2UID[msg.sender];\r\n        bool isAutoAddReferrer = true;\r\n        uint256 referrerCode = 0;\r\n\r\n        if (grantorUid != 0 && isAutoAddReferrer) {\r\n            referrerCode = grantorUid;\r\n        }\r\n\r\n        if (_invest(addr,_planId,referrerCode,msg.value, false)) {\r\n            emit onGrant(msg.sender, addr, msg.value);\r\n        }\r\n    }\r\n\r\n    function invest(uint256 _referrerCode, uint256 _planId) public payable {\r\n        if (_invest(msg.sender, _planId, _referrerCode, msg.value, false)) {\r\n            emit onInvest(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function reinvest(uint256 _referrerCode, uint256 _planId) public payable {\r\n        require(msg.value == 0, \"Reinvest doesn't allow to transfer trx simultaneously\");\r\n        uint256 uid = address2UID[msg.sender];\r\n        require(uid != 0, \"Can not reinvest because no any investments\");\r\n        uint256 availableInvestAmount = 0;\r\n        for (uint256 i = 0; i < uid2Investor[uid].planCount; i++) {\r\n            if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n            Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans[i].planId];\r\n\r\n            bool isExpired = false;\r\n            uint256 withdrawalDate = block.timestamp;\r\n            if (plan.term > 0) {\r\n                uint256 endTime = uid2Investor[uid].plans[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                    withdrawalDate = endTime;\r\n                    isExpired = true;\r\n                }\r\n            }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans[i].lastWithdrawalDate);\r\n\r\n            availableInvestAmount = availableInvestAmount.add(amount);\r\n\r\n            uid2Investor[uid].plans[i].lastWithdrawalDate = withdrawalDate;\r\n            uid2Investor[uid].plans[i].isExpired = isExpired;\r\n            uid2Investor[uid].plans[i].currentDividends =  uid2Investor[uid].plans[i].currentDividends.add(amount);\r\n        }\r\n\r\n        if (uid2Investor[uid].availableReferrerEarnings>0) {\r\n            availableInvestAmount = availableInvestAmount.add(uid2Investor[uid].availableReferrerEarnings);\r\n            uid2Investor[uid].referrerEarnings = uid2Investor[uid].availableReferrerEarnings.add(uid2Investor[uid].referrerEarnings);\r\n            uid2Investor[uid].availableReferrerEarnings = 0;\r\n        }\r\n\r\n        if (_invest(msg.sender, _planId, _referrerCode, availableInvestAmount, true)) {\r\n            emit onReinvest(msg.sender, availableInvestAmount);\r\n        }\r\n    }\r\n\r\n    function withdraw() public payable {\r\n        require(msg.value == 0, \"withdrawal doesn't allow to transfer trx simultaneously\");\r\n        uint256 uid = address2UID[msg.sender];\r\n        require(uid != 0, \"Can not withdraw because no any investments\");\r\n        uint256 withdrawalAmount = 0;\r\n        for (uint256 i = 0; i < uid2Investor[uid].planCount; i++) {\r\n            if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n            Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans[i].planId];\r\n\r\n            bool isExpired = false;\r\n            uint256 withdrawalDate = block.timestamp;\r\n            if (plan.term > 0) {\r\n                uint256 endTime = uid2Investor[uid].plans[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                    withdrawalDate = endTime;\r\n                    isExpired = true;\r\n                }\r\n            }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans[i].lastWithdrawalDate);\r\n\r\n            withdrawalAmount = withdrawalAmount.add(amount);\r\n            msg.sender.transfer(amount);\r\n\r\n            uid2Investor[uid].plans[i].lastWithdrawalDate = withdrawalDate;\r\n            uid2Investor[uid].plans[i].isExpired = isExpired;\r\n            uid2Investor[uid].plans[i].currentDividends += amount;\r\n        }\r\n\r\n        if (uid2Investor[uid].availableReferrerEarnings>0) {\r\n            msg.sender.transfer(uid2Investor[uid].availableReferrerEarnings);\r\n            uid2Investor[uid].referrerEarnings = uid2Investor[uid].availableReferrerEarnings.add(uid2Investor[uid].referrerEarnings);\r\n            uid2Investor[uid].availableReferrerEarnings = 0;\r\n        }\r\n\r\n        emit onWithdraw(msg.sender, withdrawalAmount);\r\n    }\r\n\r\n    function _calculateDividends(uint256 _amount, uint256 _dailyInterestRate, uint256 _now, uint256 _start) private pure returns (uint256) {\r\n        return (_amount * _dailyInterestRate / 1000 * (_now - _start)) / (60*60*24);\r\n    }\r\n\r\n    function _calculateReferrerReward(uint256 _uid, uint256 _investment, uint256 _referrerCode) private {\r\n\r\n        uint256 _allReferrerAmount = (_investment.mul(REFERENCE_RATE)).div(1000);\r\n        if (_referrerCode != 0) {\r\n            uint256 _ref1 = _referrerCode;\r\n            uint256 _ref2 = uid2Investor[_ref1].referrer;\r\n            uint256 _ref3 = uid2Investor[_ref2].referrer;\r\n            uint256 _refAmount = 0;\r\n\r\n            if (_ref1 != 0) {\r\n                _refAmount = (_investment.mul(REFERENCE_LEVEL1_RATE)).div(1000);\r\n                _allReferrerAmount = _allReferrerAmount.sub(_refAmount);\r\n                uid2Investor[_ref1].availableReferrerEarnings = _refAmount.add(uid2Investor[_ref1].availableReferrerEarnings);\r\n                // _refAmount = (_investment.mul(REFERENCE_SELF_RATE)).div(1000);\r\n                // uid2Investor[_uid].availableReferrerEarnings =  _refAmount.add(uid2Investor[_uid].availableReferrerEarnings);\r\n            }\r\n\r\n            if (_ref2 != 0) {\r\n                _refAmount = (_investment.mul(REFERENCE_LEVEL2_RATE)).div(1000);\r\n                _allReferrerAmount = _allReferrerAmount.sub(_refAmount);\r\n                uid2Investor[_ref2].availableReferrerEarnings = _refAmount.add(uid2Investor[_ref2].availableReferrerEarnings);\r\n            }\r\n\r\n            if (_ref3 != 0) {\r\n                _refAmount = (_investment.mul(REFERENCE_LEVEL3_RATE)).div(1000);\r\n                _allReferrerAmount = _allReferrerAmount.sub(_refAmount);\r\n                uid2Investor[_ref3].availableReferrerEarnings = _refAmount.add(uid2Investor[_ref3].availableReferrerEarnings);\r\n            }\r\n        }\r\n\r\n        if (_allReferrerAmount > 0) {\r\n            referenceAccount_.transfer(_allReferrerAmount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"address2UID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERENCE_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRER_CODE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReferenceAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrerCode\",\"type\":\"uint256\"},{\"name\":\"_planId\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uid\",\"type\":\"uint256\"}],\"name\":\"getInvestmentPlanByUID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERENCE_LEVEL2_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMarketingAccount\",\"type\":\"address\"}],\"name\":\"setMarketingAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_planId\",\"type\":\"uint256\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestReferrerCode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeveloperAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketingAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERENCE_LEVEL1_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newReferenceAccount\",\"type\":\"address\"}],\"name\":\"setReferenceAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERENCE_LEVEL3_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uid2Investor\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"referrerEarnings\",\"type\":\"uint256\"},{\"name\":\"availableReferrerEarnings\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"uint256\"},{\"name\":\"planCount\",\"type\":\"uint256\"},{\"name\":\"level1RefCount\",\"type\":\"uint256\"},{\"name\":\"level2RefCount\",\"type\":\"uint256\"},{\"name\":\"level3RefCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_planId\",\"type\":\"uint256\"},{\"name\":\"_perInvestorLimit\",\"type\":\"uint256\"},{\"name\":\"_addAmount\",\"type\":\"uint256\"}],\"name\":\"setPlanLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uid\",\"type\":\"uint256\"}],\"name\":\"getInvestorInfoByUID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dailyInterest\",\"type\":\"uint256\"},{\"name\":\"term\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"perInvestorLimit\",\"type\":\"uint256\"},{\"name\":\"leftAmount\",\"type\":\"uint256\"}],\"name\":\"addNewPlan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEVELOPER_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrerCode\",\"type\":\"uint256\"},{\"name\":\"_planId\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uid\",\"type\":\"uint256\"},{\"name\":\"_planId\",\"type\":\"uint256\"}],\"name\":\"getInvestorPlanLimitsByUID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPlans\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDeveloperAccount\",\"type\":\"address\"}],\"name\":\"setDeveloperAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUIDByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"grantor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"onOwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CCBank","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ec6c6b6c3020e208c4fff538045bbef44ff48854f3c7f978820bb325b80a5bdb"}]}