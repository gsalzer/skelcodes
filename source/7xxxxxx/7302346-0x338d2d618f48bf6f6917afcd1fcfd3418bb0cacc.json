{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: lib/CanReclaimToken.sol\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20 compatible tokens\r\n   * @param token ERC20 The address of the token contract\r\n   */\r\n  function reclaimToken(IERC20 token) external onlyOwner {\r\n    address payable owner = address(uint160(owner()));\r\n\r\n    if (address(token) == address(0)) {\r\n      owner.transfer(address(this).balance);\r\n      return;\r\n    }\r\n    uint256 balance = token.balanceOf(address(this));\r\n    token.transfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n// File: lib/PPQueue.sol\r\n/**\r\n * @title PPQueue\r\n */\r\nlibrary PPQueue {\r\n  struct Item {\r\n    //    uint idx;\r\n    bool exists;\r\n    uint prev;\r\n    uint next;\r\n  }\r\n\r\n  struct Queue {\r\n    uint length;\r\n    uint first;\r\n    uint last;\r\n    uint counter;\r\n    mapping (uint => Item) items;\r\n  }\r\n\r\n  /**\r\n   * @dev push item to fifo queue\r\n   */\r\n  function push(Queue storage queue, uint index) internal {\r\n    require(!queue.items[index].exists);\r\n    queue.items[index] = Item({\r\n      exists: true,\r\n      prev: queue.last,\r\n      next: 0\r\n      });\r\n\r\n    if (queue.length == 0) {\r\n      queue.first = index;\r\n    } else {\r\n      queue.items[queue.last].next = index;\r\n    }\r\n\r\n    //save last item queue idx\r\n    queue.last = index;\r\n    queue.length++;\r\n  }\r\n\r\n  /**\r\n  * @dev pop item from fifo queue\r\n  */\r\n  function popf(Queue storage queue) internal returns (uint index) {\r\n    index = queue.first;\r\n    remove(queue, index);\r\n  }\r\n\r\n  /**\r\n  * @dev pop item from lifo queue\r\n  */\r\n  function popl(Queue storage queue) internal returns (uint index) {\r\n    index = queue.last;\r\n    remove(queue, index);\r\n  }\r\n\r\n  /**\r\n   * @dev remove an item from queue\r\n   */\r\n  function remove(Queue storage queue, uint index) internal {\r\n    require(queue.length > 0);\r\n    require(queue.items[index].exists);\r\n\r\n\r\n    if (queue.items[index].prev != 0) {\r\n      queue.items[queue.items[index].prev].next = queue.items[index].next;\r\n    } else {\r\n      //assume we delete first item\r\n      queue.first = queue.items[index].next;\r\n    }\r\n\r\n    if (queue.items[index].next != 0) {\r\n      queue.items[queue.items[index].next].prev = queue.items[index].prev;\r\n    } else {\r\n      //assume we delete last item\r\n      queue.last = queue.items[index].prev;\r\n    }\r\n    //del from queue\r\n    delete queue.items[index];\r\n    queue.length--;\r\n\r\n  }\r\n\r\n  /**\r\n  * @dev get queue length\r\n  * @return uint\r\n  */\r\n  function len(Queue storage queue) internal view returns (uint) {\r\n    //auto prevent existing of agents with updated address and same id\r\n    return queue.length;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: contracts/Referrals.sol\r\n\r\ninterface Affiliates {\r\n  function plusByCode(address _token, uint256 _affCode, uint _amount) external payable;\r\n  function upAffCode(uint256 _affCode) external view returns (uint);\r\n  function setUpAffCodeByAddr(address _address, uint _upAffCode) external;\r\n  function getAffCode(uint256 _a) external pure returns (uint);\r\n  function sendAffReward(address _token, address _address) external returns (uint);\r\n}\r\n\r\ncontract Referrals is Ownable, ReentrancyGuard {\r\n  using SafeMath for uint;\r\n\r\n  //1% - 100, 10% - 1000 50% - 5000\r\n  uint256[] public affLevelReward;\r\n  Affiliates public aff;\r\n\r\n  constructor (address _aff) public {\r\n    require(_aff != address(0));\r\n    aff = Affiliates(_aff);\r\n\r\n    // two upper levels for each: winner and loser\r\n    // total sum of level's % must be 100%\r\n    //1% - 100, 10% - 1000 50% - 5000\r\n    affLevelReward.push(0); // level 0, 10% - player self - cacheback\r\n    affLevelReward.push(8000); // level 1, 70% of affPool\r\n    affLevelReward.push(2000); // level 2, 20% of affPool\r\n  }\r\n\r\n\r\n  //AFFILIATES\r\n  function setAffiliateLevel(uint256 _level, uint256 _rewardPercent) external onlyOwner {\r\n    require(_level < affLevelReward.length);\r\n    affLevelReward[_level] = _rewardPercent;\r\n  }\r\n\r\n  function incAffiliateLevel(uint256 _rewardPercent) external onlyOwner {\r\n    affLevelReward.push(_rewardPercent);\r\n  }\r\n\r\n  function decAffiliateLevel() external onlyOwner {\r\n    delete affLevelReward[affLevelReward.length--];\r\n  }\r\n\r\n  function affLevelsCount() external view returns (uint) {\r\n    return affLevelReward.length;\r\n  }\r\n\r\n  function _distributeAffiliateReward(uint256 _sum, uint256 _affCode, uint256 _level, bool _cacheBack) internal {\r\n    uint upAffCode = aff.upAffCode(_affCode);\r\n\r\n    if (affLevelReward[_level] > 0 && _affCode != 0 && (_level > 0 || (_cacheBack && upAffCode != 0))) {\r\n      uint total = _getPercent(_sum, affLevelReward[_level]);\r\n      aff.plusByCode.value(total)(address(0x0), _affCode, total);\r\n    }\r\n\r\n    if (affLevelReward.length > ++_level) {\r\n      _distributeAffiliateReward(_sum, upAffCode, _level, false);\r\n    }\r\n  }\r\n\r\n  function getAffReward() external nonReentrant {\r\n    aff.sendAffReward(address(0x0), msg.sender);\r\n  }\r\n\r\n  //1% - 100, 10% - 1000 50% - 5000\r\n  function _getPercent(uint256 _v, uint256 _p) internal pure returns (uint)    {\r\n    return _v.mul(_p) / 10000;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: lib/ServiceRole.sol\r\ncontract ServiceRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event ServiceAdded(address indexed account);\r\n  event ServiceRemoved(address indexed account);\r\n\r\n  Roles.Role private services;\r\n\r\n  constructor() internal {\r\n    _addService(msg.sender);\r\n  }\r\n\r\n  modifier onlyService() {\r\n    require(isService(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isService(address account) public view returns (bool) {\r\n    return services.has(account);\r\n  }\r\n\r\n  function renounceService() public {\r\n    _removeService(msg.sender);\r\n  }\r\n\r\n  function _addService(address account) internal {\r\n    services.add(account);\r\n    emit ServiceAdded(account);\r\n  }\r\n\r\n  function _removeService(address account) internal {\r\n    services.remove(account);\r\n    emit ServiceRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/Services.sol\r\ncontract Services is Ownable,ServiceRole {\r\n  constructor() public{\r\n\r\n  }\r\n\r\n  function addService(address account) external onlyOwner {\r\n    _addService(account);\r\n  }\r\n\r\n  function removeService(address account) external onlyOwner {\r\n    _removeService(account);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/BetLevels.sol\r\ncontract BetLevels is Ownable {\r\n\r\n  //value => level\r\n  mapping(uint => uint) betLevels;\r\n  //array of avail bets values\r\n  uint[] public betLevelValues;\r\n\r\n  constructor () public {\r\n    //zero level = 0, skip it\r\n    betLevelValues.length += 8;\r\n    _setBetLevel(1, 0.01 ether);\r\n    _setBetLevel(2, 0.05 ether);\r\n    _setBetLevel(3, 0.1 ether);\r\n    _setBetLevel(4, 0.5 ether);\r\n    _setBetLevel(5, 1 ether);\r\n    _setBetLevel(6, 5 ether);\r\n    _setBetLevel(7, 10 ether);\r\n  }\r\n\r\n  function addBetLevel(uint256 value) external onlyOwner {\r\n    require(betLevelValues.length == 0 || betLevelValues[betLevelValues.length - 1] < value);\r\n    betLevelValues.length++;\r\n    _setBetLevel(betLevelValues.length - 1, value);\r\n  }\r\n\r\n  function _setBetLevel(uint level, uint value) internal {\r\n    betLevelValues[level] = value;\r\n    betLevels[value] = level;\r\n  }\r\n\r\n  function setBetLevel(uint level, uint value) external onlyOwner {\r\n    require(betLevelValues.length > level);\r\n    require(betLevelValues[level] != value);\r\n    delete betLevels[betLevelValues[level]];\r\n    _setBetLevel(level, value);\r\n  }\r\n\r\n  function betLevelsCount() external view returns (uint) {\r\n    return betLevelValues.length;\r\n  }\r\n\r\n  function getBetLevel(uint value) internal view returns (uint level) {\r\n    level = betLevels[value];\r\n    require(level != 0);\r\n  }\r\n}\r\n\r\n// File: contracts/BetIntervals.sol\r\ncontract BetIntervals is Ownable {\r\n  event SetInterval(uint startsFrom, uint pastCount, uint newInterval, uint newPeriod);\r\n\r\n  uint public constant BetEpoch = 1550534400; //Tuesday, 19 February 2019 Ð³., 0:00:00\r\n\r\n\r\n  struct RoundInterval {\r\n    uint interval;\r\n    uint from;\r\n    uint count;\r\n    uint period;\r\n  }\r\n  RoundInterval[] public intervalHistory;\r\n\r\n  constructor() public{\r\n    intervalHistory.push(RoundInterval({\r\n      period : 10 * 60,\r\n      from : BetEpoch,\r\n      count : 0,\r\n      interval : 15 * 60\r\n      }));\r\n  }\r\n\r\n  function setInterval(uint _interval, uint _period) external onlyOwner {\r\n    RoundInterval memory i = _getRoundIntervalAt(now);\r\n    uint intervalsCount = (now - i.from) / i.interval + 1;\r\n    RoundInterval memory ni = RoundInterval({\r\n      interval : _interval,\r\n      from : i.from + i.interval * intervalsCount,\r\n      count : intervalsCount + i.count,\r\n      period : _period\r\n      });\r\n    intervalHistory.push(ni);\r\n    emit SetInterval(ni.from, ni.count, _interval, _period);\r\n  }\r\n\r\n  function getCurrentRoundId() public view returns (uint) {\r\n    return getRoundIdAt(now, 0);\r\n  }\r\n\r\n  function getNextRoundId() public view returns (uint) {\r\n    return getRoundIdAt(now, 1);\r\n  }\r\n\r\n  function getRoundIdAt(uint _time, uint _shift) public view returns (uint) {\r\n    uint intervalId = _getRoundIntervalIdAt(_time);\r\n    RoundInterval memory i = intervalHistory[intervalId];\r\n    return _time > i.from ? (_time - i.from) / i.interval + i.count + _shift : 0;\r\n\r\n  }\r\n\r\n\r\n  function getCurrentRoundInterval() public view returns (uint interval, uint period) {\r\n    return getRoundIntervalAt(now);\r\n  }\r\n\r\n  function getRoundIntervalAt(uint _time) public view returns (uint interval, uint period) {\r\n    RoundInterval memory i = _getRoundIntervalAt(_time);\r\n    interval = i.interval;\r\n    period = i.period;\r\n  }\r\n\r\n  function getCurrentRoundInfo() public view returns (\r\n    uint roundId,\r\n    uint startAt,\r\n    uint finishAt\r\n  ) {\r\n    return getRoundInfoAt(now, 0);\r\n  }\r\n\r\n  function getNextRoundInfo() public view returns (\r\n    uint roundId,\r\n    uint startAt,\r\n    uint finishAt\r\n  ) {\r\n    return getRoundInfoAt(now, 1);\r\n  }\r\n\r\n  function getRoundInfoAt(uint _time, uint _shift) public view returns (\r\n    uint roundId,\r\n    uint startAt,\r\n    uint finishAt\r\n  ) {\r\n    RoundInterval memory i = _getRoundIntervalAt(_time);\r\n\r\n    uint intervalsCount = _time > i.from ? (_time - i.from) / i.interval + _shift : 0;\r\n    startAt = i.from + i.interval * intervalsCount;\r\n    roundId = i.count + intervalsCount;\r\n    finishAt = i.period + startAt;\r\n  }\r\n\r\n\r\n  function _getRoundIntervalAt(uint _time) internal view returns (RoundInterval memory) {\r\n    return intervalHistory[_getRoundIntervalIdAt(_time)];\r\n  }\r\n\r\n\r\n  function _getRoundIntervalIdAt(uint _time) internal view returns (uint) {\r\n    require(intervalHistory.length > 0);\r\n    //    if (intervalHistory.length == 0) return 0;\r\n    // Shortcut for the actual value\r\n    if (_time >= intervalHistory[intervalHistory.length - 1].from)\r\n      return intervalHistory.length - 1;\r\n    if (_time < intervalHistory[0].from) return 0;\r\n\r\n    // Binary search of the value in the array\r\n    uint min = 0;\r\n    uint max = intervalHistory.length - 1;\r\n    while (max > min) {\r\n      uint mid = (max + min + 1) / 2;\r\n      if (intervalHistory[mid].from <= _time) {\r\n        min = mid;\r\n      } else {\r\n        max = mid - 1;\r\n      }\r\n    }\r\n    return min;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/ReservedValue.sol\r\n\r\ncontract ReservedValue is Ownable {\r\n  using SafeMath for uint;\r\n  event Income(address source, uint256 amount);\r\n\r\n  address payable public wallet;\r\n  //total reserved eth amount\r\n  uint256 public totalReserved;\r\n\r\n  constructor(address payable _w) public {\r\n    require(_w != address(0));\r\n    wallet = _w;\r\n\r\n  }\r\n\r\n  function setWallet(address payable _w) external onlyOwner {\r\n    require(address(_w) != address(0));\r\n    wallet = _w;\r\n  }\r\n\r\n  /// @notice The fallback function payable\r\n  function() external payable {\r\n    require(msg.value > 0);\r\n    _flushBalance();\r\n  }\r\n\r\n  function _flushBalance() internal {\r\n    uint256 balance = address(this).balance.sub(totalReserved);\r\n    if (balance > 0) {\r\n      address(wallet).transfer(balance);\r\n      emit Income(address(this), balance);\r\n    }\r\n  }\r\n\r\n  function _incTotalReserved(uint value) internal {\r\n    totalReserved = totalReserved.add(value);\r\n  }\r\n\r\n  function _decTotalReserved(uint value) internal {\r\n    totalReserved = totalReserved.sub(value);\r\n  }\r\n}\r\n\r\n// File: contracts/Bets.sol\r\ncontract Bets is Ownable, ReservedValue, BetIntervals, BetLevels, Referrals, Services, CanReclaimToken {\r\n  using SafeMath for uint;\r\n\r\n  event BetCreated(address indexed bettor, uint betId, uint index, uint allyRace, uint enemyRace, uint betLevel, uint value, uint utmSource);\r\n  event BetAccepted(uint betId, uint opBetId, uint roundId);\r\n  event BetCanceled(uint betId);\r\n  event BetRewarded(uint winBetId, uint loseBetId, uint reward, bool noWin);\r\n  event BetRoundCalculated(uint roundId, uint winnerRace, uint loserRace, uint betLevel, uint pool, uint bettorCount);\r\n  event StartBetRound(uint roundId, uint startAt, uint finishAt);\r\n  event RoundRaceResult(uint roundId, uint raceId, int32 result);\r\n  event FinishBetRound(uint roundId, uint startCheckedAt, uint finishCheckedAt);\r\n\r\n  using PPQueue for PPQueue.Queue;\r\n\r\n  struct Bettor {\r\n    uint counter;\r\n    mapping(uint => uint) bets;\r\n  }\r\n\r\n  struct Race {\r\n    uint index;\r\n    bool exists;\r\n    uint count;\r\n    int32 result;\r\n  }\r\n\r\n  struct BetRound {\r\n    uint startedAt;\r\n    uint finishedAt;\r\n    uint startCheckedAt;\r\n    uint finishCheckedAt;\r\n    uint[] bets;\r\n    mapping(uint => Race) races;\r\n    uint[] raceList;\r\n  }\r\n\r\n  uint[] public roundsList;\r\n\r\n  //roundId => BetRound\r\n  mapping(uint => BetRound) betRounds;\r\n\r\n  struct Bet {\r\n    address payable bettor;\r\n    uint roundId;\r\n    uint allyRace;\r\n    uint enemyRace;\r\n    uint value;\r\n    uint level;\r\n    uint opBetId;\r\n    uint reward;\r\n    bool active;\r\n  }\r\n\r\n  struct BetStat {\r\n    uint sum;\r\n    uint pool;\r\n    uint affPool;\r\n    uint count;\r\n    bool taxed;\r\n  }\r\n\r\n  uint public lastBetId;\r\n  mapping(uint => Bet)  bets;\r\n  mapping(address => Bettor)  bettors;\r\n\r\n  struct BetData {\r\n    mapping(uint => BetStat) stat;\r\n    PPQueue.Queue queue;\r\n  }\r\n\r\n  //betLevel => allyRace => enemyRace => BetData\r\n  mapping(uint => mapping(uint => mapping(uint => BetData))) betData;\r\n\r\n  //raceId => allowed\r\n  mapping(uint => bool) public allowedRace;\r\n\r\n  uint public systemFeePcnt;\r\n  uint public affPoolPcnt;\r\n\r\n\r\n  constructor(address payable _w, address _aff) ReservedValue(_w) Referrals(_aff) public payable {\r\n    //    systemFee 5% (from loser sum)\r\n    //    affPoolPercent 5% (from loser  sum)\r\n    setFee(500, 500);\r\n\r\n    //allow races, BTC,LTC,ETH by default\r\n    allowedRace[1] = true;\r\n    allowedRace[2] = true;\r\n    allowedRace[4] = true;\r\n    allowedRace[10] = true;\r\n    allowedRace[13] = true;\r\n  }\r\n\r\n  function setFee(uint _systemFee, uint _affFee) public onlyOwner\r\n  {\r\n    systemFeePcnt = _systemFee;\r\n    affPoolPcnt = _affFee;\r\n  }\r\n\r\n  function allowRace(uint _race, bool _allow) external onlyOwner {\r\n    allowedRace[_race] = _allow;\r\n  }\r\n\r\n  function makeBet(uint allyRace, uint enemyRace, uint _affCode, uint _source) public payable {\r\n    require(allyRace != enemyRace && allowedRace[allyRace] && allowedRace[enemyRace]);\r\n    //require bet level exists\r\n    uint level = getBetLevel(msg.value);\r\n\r\n    Bet storage bet = bets[++lastBetId];\r\n    bet.active = true;\r\n    bet.bettor = msg.sender;\r\n    bet.allyRace = allyRace;\r\n    bet.enemyRace = enemyRace;\r\n    bet.value = msg.value;\r\n    bet.level = level;\r\n\r\n    //save bet to bettor list && inc. bets count\r\n    bettors[bet.bettor].bets[++bettors[bet.bettor].counter] = lastBetId;\r\n\r\n    emit BetCreated(bet.bettor, lastBetId, bettors[bet.bettor].counter, allyRace, enemyRace, level, msg.value, _source);\r\n\r\n    //upd queue\r\n    BetData storage allyData = betData[level][allyRace][enemyRace];\r\n    BetData storage enemyData = betData[level][enemyRace][allyRace];\r\n\r\n    //if there is nobody on opposite side\r\n    if (enemyData.queue.len() == 0) {\r\n      allyData.queue.push(lastBetId);\r\n    } else {\r\n      //accepting bet\r\n      uint nextRoundId = _startNextRound();\r\n      uint opBetId = enemyData.queue.popf();\r\n      bet.opBetId = opBetId;\r\n      bet.roundId = nextRoundId;\r\n      bets[opBetId].opBetId = lastBetId;\r\n      bets[opBetId].roundId = nextRoundId;\r\n\r\n      //upd fight stat\r\n      allyData.stat[nextRoundId].sum = allyData.stat[nextRoundId].sum.add(msg.value);\r\n      allyData.stat[nextRoundId].count++;\r\n\r\n      enemyData.stat[nextRoundId].sum = enemyData.stat[nextRoundId].sum.add(bets[opBetId].value);\r\n      enemyData.stat[nextRoundId].count++;\r\n      if (!betRounds[nextRoundId].races[allyRace].exists) {\r\n        betRounds[nextRoundId].races[allyRace].exists = true;\r\n        betRounds[nextRoundId].races[allyRace].index = betRounds[nextRoundId].raceList.length;\r\n        betRounds[nextRoundId].raceList.push(allyRace);\r\n      }\r\n      betRounds[nextRoundId].races[allyRace].count++;\r\n\r\n      if (!betRounds[nextRoundId].races[enemyRace].exists) {\r\n        betRounds[nextRoundId].races[enemyRace].exists = true;\r\n        betRounds[nextRoundId].races[enemyRace].index = betRounds[nextRoundId].raceList.length;\r\n        betRounds[nextRoundId].raceList.push(enemyRace);\r\n      }\r\n      betRounds[nextRoundId].races[enemyRace].count++;\r\n      betRounds[nextRoundId].bets.push(opBetId);\r\n      betRounds[nextRoundId].bets.push(lastBetId);\r\n\r\n      emit BetAccepted(opBetId, lastBetId, nextRoundId);\r\n    }\r\n    _incTotalReserved(msg.value);\r\n\r\n    // update last affiliate\r\n    aff.setUpAffCodeByAddr(bet.bettor, _affCode);\r\n  }\r\n\r\n  function _startNextRound() internal returns (uint nextRoundId) {\r\n    uint nextStartAt;\r\n    uint nextFinishAt;\r\n    (nextRoundId, nextStartAt, nextFinishAt) = getNextRoundInfo();\r\n    \r\n    if (betRounds[nextRoundId].startedAt == 0) {\r\n      betRounds[nextRoundId].startedAt = nextStartAt;\r\n      roundsList.push(nextRoundId);\r\n      emit StartBetRound(nextRoundId, nextStartAt, nextFinishAt);\r\n    }\r\n  }\r\n\r\n  function cancelBettorBet(address bettor, uint betIndex) external onlyService {\r\n    _cancelBet(bettors[bettor].bets[betIndex]);\r\n  }\r\n\r\n  function cancelMyBet(uint betIndex) external nonReentrant {\r\n    _cancelBet(bettors[msg.sender].bets[betIndex]);\r\n  }\r\n\r\n  function cancelBet(uint betId) external nonReentrant {\r\n    require(bets[betId].bettor == msg.sender);\r\n    _cancelBet(betId);\r\n  }\r\n\r\n  function _cancelBet(uint betId) internal {\r\n    Bet storage bet = bets[betId];\r\n    require(bet.active);\r\n    //can cancel only not yet accepted bets\r\n    require(bet.roundId == 0);\r\n\r\n    //upd queue\r\n    BetData storage allyData = betData[bet.level][bet.allyRace][bet.enemyRace];\r\n    allyData.queue.remove(betId);\r\n\r\n    _decTotalReserved(bet.value);\r\n    bet.bettor.transfer(bet.value);\r\n    emit BetCanceled(betId);\r\n\r\n    // del bet\r\n    delete bets[betId];\r\n  }\r\n\r\n\r\n  function _calcRoundLevel(uint level, uint allyRace, uint enemyRace, uint roundId) internal returns (int32 allyResult, int32 enemyResult){\r\n    require(betRounds[roundId].startedAt != 0 && betRounds[roundId].finishedAt != 0);\r\n\r\n    allyResult = betRounds[roundId].races[allyRace].result;\r\n    enemyResult = betRounds[roundId].races[enemyRace].result;\r\n\r\n    if (allyResult < enemyResult) {\r\n      (allyRace, enemyRace) = (enemyRace, allyRace);\r\n    }\r\n    BetData storage winnerData = betData[level][allyRace][enemyRace];\r\n    BetData storage loserData = betData[level][enemyRace][allyRace];\r\n\r\n    if (!loserData.stat[roundId].taxed) {\r\n      loserData.stat[roundId].taxed = true;\r\n\r\n      //check if really winner\r\n      if (allyResult != enemyResult) {\r\n        //system fee\r\n        uint fee = _getPercent(loserData.stat[roundId].sum, systemFeePcnt);\r\n        _decTotalReserved(fee);\r\n\r\n        //affiliate %\r\n        winnerData.stat[roundId].affPool = _getPercent(loserData.stat[roundId].sum, affPoolPcnt);\r\n        //calc pool for round\r\n        winnerData.stat[roundId].pool = loserData.stat[roundId].sum - fee - winnerData.stat[roundId].affPool;\r\n\r\n        emit BetRoundCalculated(roundId, allyRace, enemyRace, level, winnerData.stat[roundId].pool, winnerData.stat[roundId].count);\r\n      }\r\n    }\r\n\r\n    if (!winnerData.stat[roundId].taxed) {\r\n      winnerData.stat[roundId].taxed = true;\r\n    }\r\n  }\r\n\r\n  function rewardBettorBet(address bettor, uint betIndex) external onlyService {\r\n    _rewardBet(bettors[bettor].bets[betIndex]);\r\n  }\r\n\r\n  function rewardMyBet(uint betIndex) external nonReentrant {\r\n    _rewardBet(bettors[msg.sender].bets[betIndex]);\r\n  }\r\n\r\n  function rewardBet(uint betId) external nonReentrant {\r\n    require(bets[betId].bettor == msg.sender);\r\n    _rewardBet(betId);\r\n  }\r\n\r\n\r\n  function _rewardBet(uint betId) internal {\r\n    Bet storage bet = bets[betId];\r\n    require(bet.active);\r\n    //only accepted bets\r\n    require(bet.roundId != 0);\r\n    (int32 allyResult, int32 enemyResult) = _calcRoundLevel(bet.level, bet.allyRace, bet.enemyRace, bet.roundId);\r\n\r\n    //disabling bet\r\n    bet.active = false;\r\n    if (allyResult >= enemyResult) {\r\n      bet.reward = bet.value;\r\n      if (allyResult > enemyResult) {\r\n        //win\r\n        BetStat memory s = betData[bet.level][bet.allyRace][bet.enemyRace].stat[bet.roundId];\r\n        bet.reward = bet.reward.add(s.pool / s.count);\r\n\r\n        // winner's affiliates + loser's affiliates\r\n        uint affPool = s.affPool / s.count;\r\n        _decTotalReserved(affPool);\r\n        // affiliate pool is 1/2 of total aff. pool, per each winner and loser\r\n        _distributeAffiliateReward(affPool >> 1, aff.getAffCode(uint(bet.bettor)), 0, false); //no cacheback to winner\r\n        _distributeAffiliateReward(affPool >> 1, aff.getAffCode(uint(bets[bet.opBetId].bettor)), 0, true); //cacheback to looser\r\n      }\r\n\r\n\r\n      bet.bettor.transfer(bet.reward);\r\n      _decTotalReserved(bet.reward);\r\n      emit BetRewarded(betId, bet.opBetId, bet.reward, allyResult == enemyResult);\r\n    }\r\n    _flushBalance();\r\n  }\r\n\r\n\r\n  function provisionBetReward(uint betId) public view returns (uint reward) {\r\n    Bet storage bet = bets[betId];\r\n    if (!bet.active) {\r\n      return 0;\r\n    }\r\n\r\n    int32 allyResult = betRounds[bet.roundId].races[bet.allyRace].result;\r\n    int32 enemyResult = betRounds[bet.roundId].races[bet.enemyRace].result;\r\n\r\n    if (allyResult < enemyResult) {\r\n      return 0;\r\n    }\r\n    reward = bet.value;\r\n\r\n    BetData storage allyData = betData[bet.level][bet.allyRace][bet.enemyRace];\r\n    BetData storage enemyData = betData[bet.level][bet.enemyRace][bet.allyRace];\r\n\r\n    if (allyResult > enemyResult) {\r\n      //win\r\n      if (!enemyData.stat[bet.roundId].taxed) {\r\n        uint pool = enemyData.stat[bet.roundId].sum - _getPercent(enemyData.stat[bet.roundId].sum, systemFeePcnt + affPoolPcnt);\r\n        reward = bet.value.add(pool / allyData.stat[bet.roundId].count);\r\n      } else {\r\n        reward = bet.value.add(allyData.stat[bet.roundId].pool / allyData.stat[bet.roundId].count);\r\n      }\r\n    }\r\n  }\r\n\r\n  function provisionBettorBetReward(address bettor, uint betIndex) public view returns (uint reward) {\r\n    return provisionBetReward(bettors[bettor].bets[betIndex]);\r\n  }\r\n\r\n  function finalizeBetRound(uint betLevel, uint allyRace, uint enemyRace, uint roundId) external onlyService {\r\n    _calcRoundLevel(betLevel, allyRace, enemyRace, roundId);\r\n    _flushBalance();\r\n  }\r\n\r\n  function roundsCount() external view returns (uint) {\r\n    return roundsList.length;\r\n  }\r\n\r\n  function getBettorsBetCounter(address bettor) external view returns (uint) {\r\n    return bettors[bettor].counter;\r\n  }\r\n\r\n  function getBettorsBetId(address bettor, uint betIndex) external view returns (uint betId) {\r\n    return bettors[bettor].bets[betIndex];\r\n  }\r\n\r\n  function getBettorsBets(address bettor) external view returns (uint[] memory betIds) {\r\n    Bettor storage b = bettors[bettor];\r\n    uint j;\r\n    for (uint i = 1; i <= b.counter; i++) {\r\n      if (b.bets[i] != 0) {\r\n        j++;\r\n      }\r\n    }\r\n    if (j > 0) {\r\n      betIds = new uint[](j);\r\n      j = 0;\r\n      for (uint i = 1; i <= b.counter; i++) {\r\n        if (b.bets[i] != 0) {\r\n          betIds[j++] = b.bets[i];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  function getBet(uint betId) public view returns (\r\n    address bettor,\r\n    bool active,\r\n    uint roundId,\r\n    uint allyRace,\r\n    uint enemyRace,\r\n    uint value,\r\n    uint level,\r\n    uint opBetId,\r\n    uint reward\r\n  ) {\r\n    Bet memory b = bets[betId];\r\n    return (b.bettor, b.active, b.roundId, b.allyRace, b.enemyRace, b.value, b.level, b.opBetId, b.reward);\r\n  }\r\n\r\n  function getBetRoundStat(uint roundId, uint allyRace, uint enemyRace, uint level) public view returns (\r\n    uint sum,\r\n    uint pool,\r\n    uint affPool,\r\n    uint count,\r\n    bool taxed\r\n  ) {\r\n    BetStat memory bs = betData[level][allyRace][enemyRace].stat[roundId];\r\n    return (bs.sum, bs.pool, bs.affPool, bs.count, bs.taxed);\r\n  }\r\n\r\n  function getBetQueueLength(uint allyRace, uint enemyRace, uint level) public view returns (uint) {\r\n    return betData[level][allyRace][enemyRace].queue.len();\r\n  }\r\n\r\n  function getCurrentBetRound() public view returns (\r\n    uint roundId,\r\n    uint startedAt,\r\n    uint finishedAt,\r\n    uint startCheckedAt,\r\n    uint finishCheckedAt,\r\n    uint betsCount,\r\n    uint raceCount\r\n  ) {\r\n    roundId = getCurrentRoundId();\r\n    (startedAt, finishedAt, startCheckedAt, finishCheckedAt, betsCount, raceCount) = getBetRound(roundId);\r\n  }\r\n\r\n  function getNextBetRound() public view returns (\r\n    uint roundId,\r\n    uint startedAt,\r\n    uint finishedAt,\r\n    uint startCheckedAt,\r\n    uint finishCheckedAt,\r\n    uint betsCount,\r\n    uint raceCount\r\n  ) {\r\n    roundId = getCurrentRoundId() + 1;\r\n    (startedAt, finishedAt, startCheckedAt, finishCheckedAt, betsCount, raceCount) = getBetRound(roundId);\r\n  }\r\n\r\n  function getBetRound(uint roundId) public view returns (\r\n    uint startedAt,\r\n    uint finishedAt,\r\n    uint startCheckedAt,\r\n    uint finishCheckedAt,\r\n    uint betsCount,\r\n    uint raceCount\r\n  ) {\r\n    BetRound memory b = betRounds[roundId];\r\n    return (b.startedAt, b.finishedAt, b.startCheckedAt, b.finishCheckedAt, b.bets.length, b.raceList.length);\r\n  }\r\n\r\n  function getBetRoundBets(uint roundId) public view returns (uint[] memory betIds) {\r\n    return betRounds[roundId].bets;\r\n  }\r\n\r\n  function getBetRoundBetId(uint roundId, uint betIndex) public view returns (uint betId) {\r\n    return betRounds[roundId].bets[betIndex];\r\n  }\r\n\r\n\r\n  function getBetRoundRaces(uint roundId) public view returns (uint[] memory raceIds) {\r\n    return betRounds[roundId].raceList;\r\n  }\r\n\r\n  function getBetRoundRaceStat(uint roundId, uint raceId) external view returns (\r\n    uint index,\r\n    uint count,\r\n    int32 result\r\n  ){\r\n    Race memory r = betRounds[roundId].races[raceId];\r\n    return (r.index, r.count, r.result);\r\n  }\r\n\r\n  function setBetRoundResult(uint roundId, uint count, uint[] memory packedRaces, uint[] memory packedResults) public onlyService {\r\n    require(packedRaces.length == packedResults.length);\r\n    require(packedRaces.length * 8 >= count);\r\n\r\n    BetRound storage r = betRounds[roundId];\r\n    require(r.startedAt != 0 && r.finishedAt == 0);\r\n\r\n    uint raceId;\r\n    int32 result;\r\n    for (uint i = 0; i < count; i++) {\r\n      raceId = _upack(packedRaces[i / 8], i % 8);\r\n      result = int32(_upack(packedResults[i / 8], i % 8));\r\n      r.races[raceId].result = result;\r\n      emit RoundRaceResult(roundId, raceId, result);\r\n    }\r\n  }\r\n\r\n  function finishBetRound(uint roundId, uint startCheckedAt, uint finishCheckedAt) public onlyService {\r\n    BetRound storage r = betRounds[roundId];\r\n    require(r.startedAt != 0 && r.finishedAt == 0);\r\n    uint finishAt;\r\n    (, , finishAt) = getRoundInfoAt(r.startedAt, 0);\r\n    require(now >= finishAt);\r\n    r.finishedAt = finishAt;\r\n    r.startCheckedAt = startCheckedAt;\r\n    r.finishCheckedAt = finishCheckedAt;\r\n    emit FinishBetRound(roundId, startCheckedAt, finishCheckedAt);\r\n  }\r\n\r\n  //extract n-th 32-bit int from uint\r\n  function _upack(uint _v, uint _n) internal pure returns (uint) {\r\n    //    _n = _n & 7; //be sure < 8\r\n    return (_v >> (32 * _n)) & 0xFFFFFFFF;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getBet\",\"outputs\":[{\"name\":\"bettor\",\"type\":\"address\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"allyRace\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"opBetId\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"allyRace\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getBetRoundStat\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint256\"},{\"name\":\"pool\",\"type\":\"uint256\"},{\"name\":\"affPool\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"taxed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"rewardBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"},{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"cancelBettorBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"},{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"provisionBettorBetReward\",\"outputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemFeePcnt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"}],\"name\":\"finishBetRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundsList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aff\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBetLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"},{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"rewardBettorBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betLevelValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInterval\",\"outputs\":[{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"setAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"cancelBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"raceId\",\"type\":\"uint256\"}],\"name\":\"getBetRoundRaceStat\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"},{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"getBettorsBetId\",\"outputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_systemFee\",\"type\":\"uint256\"},{\"name\":\"_affFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"decAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBetId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_interval\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getRoundIntervalAt\",\"outputs\":[{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextRoundInfo\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"startAt\",\"type\":\"uint256\"},{\"name\":\"finishAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BetEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"startAt\",\"type\":\"uint256\"},{\"name\":\"finishAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getAffReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getBetRoundRaces\",\"outputs\":[{\"name\":\"raceIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betLevel\",\"type\":\"uint256\"},{\"name\":\"allyRace\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"finalizeBetRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"cancelMyBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affLevelsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBetRound\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"},{\"name\":\"betsCount\",\"type\":\"uint256\"},{\"name\":\"raceCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affPoolPcnt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"packedRaces\",\"type\":\"uint256[]\"},{\"name\":\"packedResults\",\"type\":\"uint256[]\"}],\"name\":\"setBetRoundResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"provisionBetReward\",\"outputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"incAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"rewardMyBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allyRace\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_source\",\"type\":\"uint256\"}],\"name\":\"makeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betLevelsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextBetRound\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"},{\"name\":\"betsCount\",\"type\":\"uint256\"},{\"name\":\"raceCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"}],\"name\":\"getBettorsBetCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_race\",\"type\":\"uint256\"},{\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"allowRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addBetLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getBetRound\",\"outputs\":[{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"},{\"name\":\"betsCount\",\"type\":\"uint256\"},{\"name\":\"raceCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"}],\"name\":\"getBettorsBets\",\"outputs\":[{\"name\":\"betIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"intervalHistory\",\"outputs\":[{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedRace\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_shift\",\"type\":\"uint256\"}],\"name\":\"getRoundInfoAt\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"startAt\",\"type\":\"uint256\"},{\"name\":\"finishAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_shift\",\"type\":\"uint256\"}],\"name\":\"getRoundIdAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"getBetRoundBetId\",\"outputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"allyRace\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getBetQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"affLevelReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getBetRoundBets\",\"outputs\":[{\"name\":\"betIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_w\",\"type\":\"address\"},{\"name\":\"_aff\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bettor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"allyRace\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"utmSource\",\"type\":\"uint256\"}],\"name\":\"BetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"opBetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"BetAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"BetCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winBetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loseBetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"noWin\",\"type\":\"bool\"}],\"name\":\"BetRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerRace\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loserRace\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bettorCount\",\"type\":\"uint256\"}],\"name\":\"BetRoundCalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finishAt\",\"type\":\"uint256\"}],\"name\":\"StartBetRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"raceId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"int32\"}],\"name\":\"RoundRaceResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finishCheckedAt\",\"type\":\"uint256\"}],\"name\":\"FinishBetRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ServiceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ServiceRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startsFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pastCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"SetInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Income\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Bets","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000edbbdf2c29ccf6a0272b36b10eadc1b17b8d7e67000000000000000000000000e544e5250648882601f9c27674dec6b4924163c2","Library":"","SwarmSource":"bzzr://2f30fb5acec93f19ead9e14fb0ba51e1e95e253ef66010d823220a781fb185f0"}]}