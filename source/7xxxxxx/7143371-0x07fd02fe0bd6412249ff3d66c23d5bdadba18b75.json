{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n    event Transfer (address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n\r\n    uint256 internal totalSupply_;\r\n\r\n    /**\r\n    * @dev Total tokens amount\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner,address _spender) public view returns (uint256){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from,address _to,uint256 _value)public returns (bool){\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender,uint256 _addedValue) public returns (bool){\r\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender,uint256 _subtractedValue) public returns (bool){\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Rate means\r\n * @dev The contract purposed for managing crowdsale financial data,\r\n *      such as rates, prices, limits and etc.\r\n */\r\ncontract Rate  {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    //  Ether / US cent exchange rate\r\n    uint public ETHUSDC;\r\n    \r\n    //  Token price in US cents\r\n    uint public usCentsPrice;\r\n    \r\n    //  Token price in wei\r\n    uint public tokenWeiPrice;\r\n    \r\n    //  Minimum wei amount derived from requiredDollarAmount parameter\r\n    uint public requiredWeiAmount;\r\n    \r\n    //  Minimum dollar amount that investor can provide for purchasing\r\n    uint public requiredDollarAmount;\r\n\r\n    //  Total tokens amount which can be sold at the current crowdsale stage\r\n    uint internal percentLimit;\r\n\r\n    //  All percent limits according to Crowdsale stages\r\n    uint[] internal percentLimits = [10, 27, 53, 0];\r\n    \r\n    //  Event for interacting with OraclizeAPI\r\n    event LogConstructorInitiated(string  nextStep);\r\n    \r\n    //  Event for price updating\r\n    event LogPriceUpdated(string price);\r\n    \r\n    //  Event for logging oraclize queries\r\n    event LogNewOraclizeQuery(string  description);\r\n\r\n\r\n    function ethersToTokens(uint _ethAmount)\r\n    public\r\n    view\r\n    returns(uint microTokens)\r\n    {\r\n        uint centsAmount = _ethAmount.mul(ETHUSDC);\r\n        return centsToTokens(centsAmount);\r\n    }\r\n    \r\n    function centsToTokens(uint _cents)\r\n    public\r\n    view\r\n    returns(uint microTokens)\r\n    {\r\n        require(_cents > 0);\r\n        microTokens = _cents.mul(1000000).div(usCentsPrice);\r\n        return microTokens;\r\n    }\r\n    \r\n    function tokensToWei(uint _microTokensAmount)\r\n    public\r\n    view\r\n    returns(uint weiAmount) {\r\n        uint centsWei = SafeMath.div(1 ether, ETHUSDC);\r\n        uint microTokenWeiPrice = centsWei.mul(usCentsPrice).div(10 ** 6);\r\n        weiAmount = _microTokensAmount.mul(microTokenWeiPrice);\r\n        return weiAmount;\r\n    }\r\n    \r\n    function tokensToCents(uint _microTokenAmount)\r\n    public\r\n    view\r\n    returns(uint centsAmount) {\r\n        centsAmount = _microTokenAmount.mul(usCentsPrice).div(1000000);\r\n        return centsAmount;\r\n    }\r\n    \r\n\r\n    function stringUpdate(string _rate) internal {\r\n        ETHUSDC = getInt(_rate, 0);\r\n        uint centsWei = SafeMath.div(1 ether, ETHUSDC);\r\n        tokenWeiPrice = usCentsPrice.mul(centsWei);\r\n        requiredWeiAmount = requiredDollarAmount.mul(100).mul(1 ether).div(ETHUSDC);\r\n    }\r\n    \r\n    function getInt(string _a, uint _b) private pure returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i < bresult.length; i++) {\r\n            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\r\n                if (decimals) {\r\n                    if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        return mint;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title IMPCoin implementation based on ERC20 standard token\r\n */\r\ncontract IMPERIVMCoin is StandardToken {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    string public name = \"IMPERIVMCoin\";\r\n    string public symbol = \"IMPC\";\r\n    uint8 public decimals = 6;\r\n    \r\n    address owner;\r\n    \r\n    /**\r\n     *  @dev Contract initiallization\r\n     *  @param _initialSupply total tokens amount\r\n     */\r\n    constructor(uint _initialSupply) public {\r\n        totalSupply_ = _initialSupply * 10 ** uint(decimals);\r\n        owner = msg.sender;\r\n        balances[owner] = balances[owner].add(totalSupply_);\r\n    }\r\n    \r\n}  \r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n *      functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    //  The account who initially deployed both an IMPCoin and IMPCrowdsale contracts\r\n    address public initialOwner;\r\n    \r\n    mapping(address => bool) owners;\r\n    \r\n    /**\r\n     * Event for adding owner\r\n     * @param admin is an account gonna be added to the admin list\r\n     */\r\n    event AddOwner(address indexed admin);\r\n    \r\n    /**\r\n     * Event for deleting owner\r\n     * @param admin is an account gonna be deleted from the admin list\r\n     */\r\n    event DeleteOwner(address indexed admin);\r\n    \r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwners() {\r\n        require(\r\n            msg.sender == initialOwner\r\n            || inOwners(msg.sender)\r\n        );\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Throws if called by any account other than the initial owner.\r\n     */\r\n    modifier onlyInitialOwner() {\r\n        require(msg.sender == initialOwner);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev adding admin account to the admins list\r\n     * @param _wallet is an account gonna be approved as an admin account\r\n     */\r\n    function addOwner(address _wallet) public onlyInitialOwner {\r\n        owners[_wallet] = true;\r\n        emit AddOwner(_wallet);\r\n    }\r\n    \r\n    /**\r\n     * @dev deleting admin account from the admins list\r\n     * @param _wallet is an account gonna be deleted from the admins list\r\n     */\r\n    function deleteOwner(address _wallet) public onlyInitialOwner {\r\n        owners[_wallet] = false;\r\n        emit DeleteOwner(_wallet);\r\n    }\r\n    \r\n    /**\r\n     * @dev checking if account is admin or not\r\n     * @param _wallet is an account for checking\r\n     */\r\n    function inOwners(address _wallet)\r\n    public\r\n    view\r\n    returns(bool)\r\n    {\r\n        if(owners[_wallet]){ \r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title Lifecycle means\r\n * @dev The contract purposed for managing crowdsale lifecycle\r\n */\r\ncontract Lifecycle is Ownable, Rate {\r\n    \r\n    /**\r\n     * Enumeration describing all crowdsale stages\r\n     * @ Private for small group of privileged investors\r\n     * @ PreSale for more wide and less privileged group of investors\r\n     * @ Sale for all buyers\r\n     * @ Cancel crowdsale completing stage\r\n     * @ Stopped special stage for updates and force-major handling\r\n     */\r\n    enum Stages {\r\n        Private,\r\n        PreSale,\r\n        Sale,\r\n        Cancel,\r\n        Stopped\r\n    }\r\n    \r\n    //  Previous crowdsale stage\r\n    Stages public previousStage;\r\n    \r\n    //  Current crowdsale stage\r\n    Stages public crowdsaleStage;\r\n    \r\n    //  Event for crowdsale stopping\r\n    event ICOStopped(uint timeStamp);\r\n    \r\n    //  Event for crowdsale continuing after stopping\r\n    event ICOContinued(uint timeStamp);\r\n    \r\n    //  Event for crowdsale starting\r\n    event CrowdsaleStarted(uint timeStamp);\r\n    \r\n    /**\r\n    * Event for ICO stage switching\r\n    * @param timeStamp time of switching\r\n    * @param newPrice one token price (US cents)\r\n    * @param newRequiredDollarAmount new minimum limit for investment\r\n    */\r\n    event ICOSwitched(uint timeStamp,uint newPrice,uint newRequiredDollarAmount);\r\n    \r\n    modifier appropriateStage() {\r\n        require(\r\n            crowdsaleStage != Stages.Cancel,\r\n            \"ICO is finished now\"\r\n        );\r\n        \r\n        require(\r\n            crowdsaleStage != Stages.Stopped,\r\n            \"ICO is temporary stopped at the moment\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    function stopCrowdsale()\r\n    public\r\n    onlyOwners\r\n    {\r\n        require(crowdsaleStage != Stages.Stopped);\r\n        previousStage = crowdsaleStage;\r\n        crowdsaleStage = Stages.Stopped;\r\n        \r\n        emit ICOStopped(now);\r\n    }\r\n    \r\n    function continueCrowdsale()\r\n    public\r\n    onlyOwners\r\n    {\r\n        require(crowdsaleStage == Stages.Stopped);\r\n        crowdsaleStage = previousStage;\r\n        previousStage = Stages.Stopped;\r\n        \r\n        emit ICOContinued(now);\r\n    }\r\n    \r\n    function nextStage(\r\n        uint _cents,\r\n        uint _requiredDollarAmount\r\n    )\r\n    public\r\n    onlyOwners\r\n    appropriateStage\r\n    {\r\n        crowdsaleStage = Stages(uint(crowdsaleStage)+1);\r\n        setUpConditions( _cents, _requiredDollarAmount);\r\n        emit ICOSwitched(now,_cents,_requiredDollarAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Setting up specified parameters for particular ICO stage\r\n     * @param _cents One token cost in U.S. cents\r\n     * @param _requiredDollarAmount Minimal dollar amount whicn Investor can send for buying purpose\r\n     */\r\n    function setUpConditions(\r\n        uint _cents,\r\n        uint _requiredDollarAmount\r\n    )\r\n    internal\r\n    {\r\n        require(_cents > 0);\r\n        require(_requiredDollarAmount > 0);\r\n        \r\n        percentLimit =  percentLimits[ uint(crowdsaleStage) ];\r\n        usCentsPrice = _cents;\r\n        requiredDollarAmount = _requiredDollarAmount;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Verification means\r\n * @dev The contract purposed for validating ethereum accounts\r\n *      able to buy IMP Coin\r\n */\r\ncontract Verification is Ownable {\r\n    \r\n    /**\r\n     * Event for adding buyer\r\n     * @param buyer is a new buyer\r\n     */\r\n    event AddBuyer(address indexed buyer);\r\n    \r\n    /**\r\n     * Event for deleting buyer\r\n     * @param buyer is a buyer gonna be deleted\r\n     * @param success is a result of deleting operation\r\n     */\r\n    event DeleteBuyer(address indexed buyer, bool indexed success);\r\n    \r\n    mapping(address => bool) public approvedBuyers;\r\n    \r\n    /**\r\n     * @dev adding buyer to the list of approved buyers\r\n     * @param _buyer account gonna to be added\r\n     */\r\n    function addBuyer(address _buyer)\r\n    public\r\n    onlyOwners\r\n    returns(bool success)\r\n    {\r\n        approvedBuyers[_buyer] = true;\r\n        emit AddBuyer(_buyer);\r\n        return true;\r\n    }  \r\n    \r\n    /**\r\n     * @dev deleting buyer from the list of approved buyers\r\n     * @param _buyer account gonna to be deleted\r\n     */\r\n    function deleteBuyer(address _buyer)\r\n    public\r\n    onlyOwners\r\n    returns(bool success)\r\n    {\r\n        if (approvedBuyers[_buyer]) {\r\n            delete approvedBuyers[_buyer];\r\n            emit DeleteBuyer(_buyer, true);\r\n            return true;\r\n        } else {\r\n            emit DeleteBuyer(_buyer, false);\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev If specified account address is in approved buyers list\r\n     *      then the function returns true, otherwise returns false\r\n     */\r\n    function getBuyer(address _buyer) public view  returns(bool success){\r\n        if (approvedBuyers[_buyer]){\r\n            return true;  \r\n        }\r\n        return false;        \r\n    }\r\n    \r\n}\r\n/**\r\n * @dev Brainspace crowdsale contract\r\n */\r\ncontract IMPCrowdsale is Lifecycle, Verification {\r\n\r\n    using SafeMath for uint;\r\n     \r\n    //  Token contract for the Crowdsale\r\n    IMPERIVMCoin public token;\r\n    \r\n    //  Total amount of received wei\r\n    uint public weiRaised;\r\n    \r\n    //  Total amount of sold tokens\r\n    uint public totalSold;\r\n    \r\n    //  The variable is purposed for ETHUSD updating\r\n    uint lastTimeStamp;\r\n    \r\n    /**\r\n     * Event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(\r\n        address indexed purchaser,\r\n        uint value,\r\n        uint amount\r\n    );\r\n    \r\n    /**\r\n     * Event for token purchase logging\r\n     * @param rate new rate\r\n     */\r\n    event StringUpdate(string rate);\r\n    \r\n    \r\n    /**\r\n     * Event for manual token transfer\r\n     * @param to receiver address\r\n     * @param value tokens amount\r\n     */\r\n    event ManualTransfer(address indexed to, uint indexed value);\r\n\r\n    constructor(\r\n        IMPERIVMCoin _token,\r\n        uint _cents,\r\n        uint _requiredDollarAmount\r\n    )\r\n    public\r\n    {\r\n        require(_token != address(0));\r\n        token = _token;\r\n        initialOwner = msg.sender;\r\n        setUpConditions( _cents, _requiredDollarAmount);\r\n        crowdsaleStage = Stages.Sale;\r\n    }\r\n    \r\n    /**\r\n     * @dev callback\r\n     */\r\n    function () public payable {\r\n        initialOwner.transfer(msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev low level token purchase ***DO NOT OVERRIDE***\r\n     */\r\n    function buyTokens()\r\n    public\r\n    payable\r\n    appropriateStage\r\n    {\r\n        require(approvedBuyers[msg.sender]);\r\n        require(totalSold <= token.totalSupply().div(100).mul(percentLimit));\r\n\r\n        uint weiAmount = msg.value;\r\n        _preValidatePurchase(weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint tokens = _getTokenAmount(weiAmount);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(tokens);\r\n        \r\n        emit TokenPurchase(\r\n            msg.sender,\r\n            weiAmount,\r\n            tokens\r\n        );\r\n\r\n        _forwardFunds();\r\n        _postValidatePurchase(tokens);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev manual ETHUSD rate updating according to exchange data\r\n     * @param _rate is the rate gonna be set up\r\n     */\r\n    function stringCourse(string _rate) public payable onlyOwners {\r\n        stringUpdate(_rate);\r\n        lastTimeStamp = now;\r\n        emit StringUpdate(_rate);\r\n    }\r\n    \r\n    function manualTokenTransfer(address _to, uint _value)\r\n    public\r\n    onlyOwners\r\n    returns(bool success)\r\n    {\r\n        if(approvedBuyers[_to]) {\r\n            totalSold = totalSold.add(_value);\r\n            token.transferFrom(initialOwner, _to, _value);\r\n            emit ManualTransfer(_to, _value);\r\n            return true;    \r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function _preValidatePurchase(uint _weiAmount)\r\n    internal\r\n    view\r\n    {\r\n        require(\r\n            _weiAmount >= requiredWeiAmount,\r\n            \"Your investment funds are less than minimum allowable amount for tokens buying\"\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n     */\r\n    function _postValidatePurchase(uint _tokensAmount)\r\n    internal\r\n    {\r\n        totalSold = totalSold.add(_tokensAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get tokens amount for purchasing\r\n     * @param _weiAmount Value in wei to be converted into tokens\r\n     * @return Number of tokens that can be purchased with the specified _weiAmount\r\n     */\r\n    function _getTokenAmount(uint _weiAmount)\r\n    internal\r\n    view\r\n    returns (uint)\r\n    {\r\n        uint centsWei = SafeMath.div(1 ether, ETHUSDC);\r\n        uint microTokenWeiPrice = centsWei.mul(usCentsPrice).div(10 ** uint(token.decimals()));\r\n        uint amountTokensForInvestor = _weiAmount.div(microTokenWeiPrice);\r\n        \r\n        return amountTokensForInvestor;\r\n    }\r\n    \r\n    /**\r\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n     * @param _tokenAmount Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(uint _tokenAmount) internal {\r\n        token.transferFrom(initialOwner, msg.sender, _tokenAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n     * @param _tokenAmount Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(uint _tokenAmount) internal {\r\n        _deliverTokens(_tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines how ETH is stored/forwarded on purchases.\r\n     */\r\n    function _forwardFunds() internal {\r\n        initialOwner.transfer(msg.value);\r\n    }\r\n    \r\n    function destroy() public onlyInitialOwner {\r\n        selfdestruct(this);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"requiredDollarAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cents\",\"type\":\"uint256\"},{\"name\":\"_requiredDollarAmount\",\"type\":\"uint256\"}],\"name\":\"nextStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"deleteBuyer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"string\"}],\"name\":\"stringCourse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedBuyers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getBuyer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_microTokensAmount\",\"type\":\"uint256\"}],\"name\":\"tokensToWei\",\"outputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWeiPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"manualTokenTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredWeiAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cents\",\"type\":\"uint256\"}],\"name\":\"centsToTokens\",\"outputs\":[{\"name\":\"microTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHUSDC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_microTokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokensToCents\",\"outputs\":[{\"name\":\"centsAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"addBuyer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"continueCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"deleteOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usCentsPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"inOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"ethersToTokens\",\"outputs\":[{\"name\":\"microTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_cents\",\"type\":\"uint256\"},{\"name\":\"_requiredDollarAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"string\"}],\"name\":\"StringUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ManualTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"AddBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"DeleteBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"ICOStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"ICOContinued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newRequiredDollarAmount\",\"type\":\"uint256\"}],\"name\":\"ICOSwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextStep\",\"type\":\"string\"}],\"name\":\"LogConstructorInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"string\"}],\"name\":\"LogPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"LogNewOraclizeQuery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DeleteOwner\",\"type\":\"event\"}]","ContractName":"IMPCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001d2aee5eaf5e4352965b710293513a5ad99796ff00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000064","Library":"","SwarmSource":"bzzr://9c541864a4b4b8b4df7bbf4c5f39163890b24eb5c025092033fabebb2d918454"}]}