{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title RegistryInterface Interface \r\n */\r\ninterface RegistryInterface {\r\n    function logic(address logicAddr) external view returns (bool);\r\n    function record(address currentOwner, address nextOwner) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Address Registry Record\r\n */\r\ncontract AddressRecord {\r\n\r\n    /**\r\n     * @dev address registry of system, logic and wallet addresses\r\n     */\r\n    address public registry;\r\n\r\n    /**\r\n     * @dev Throws if the logic is not authorised\r\n     */\r\n    modifier logicAuth(address logicAddr) {\r\n        require(logicAddr != address(0), \"logic-proxy-address-required\");\r\n        require(RegistryInterface(registry).logic(logicAddr), \"logic-not-authorised\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title User Auth\r\n */\r\ncontract UserAuth is AddressRecord {\r\n\r\n    event LogSetOwner(address indexed owner);\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev Throws if not called by owner or contract itself\r\n     */\r\n    modifier auth {\r\n        require(isAuth(msg.sender), \"permission-denied\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets new owner\r\n     */\r\n    function setOwner(address nextOwner) public auth {\r\n        RegistryInterface(registry).record(owner, nextOwner);\r\n        owner = nextOwner;\r\n        emit LogSetOwner(nextOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev checks if called by owner or contract itself\r\n     * @param src is the address initiating the call\r\n     */\r\n    function isAuth(address src) public view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (src == address(this)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev logging the execute events\r\n */\r\ncontract UserNote {\r\n    event LogNote(\r\n        bytes4 indexed sig,\r\n        address indexed guy,\r\n        bytes32 indexed foo,\r\n        bytes32 bar,\r\n        uint wad,\r\n        bytes fax\r\n    );\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n        emit LogNote(\r\n            msg.sig, \r\n            msg.sender, \r\n            foo, \r\n            bar, \r\n            msg.value,\r\n            msg.data\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title User Owned Contract Wallet\r\n */\r\ncontract UserWallet is UserAuth, UserNote {\r\n\r\n    event LogExecute(address target, uint srcNum, uint sessionNum);\r\n\r\n    /**\r\n     * @dev sets the \"address registry\", owner's last activity, owner's active period and initial owner\r\n     */\r\n    constructor() public {\r\n        registry = msg.sender;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    /**\r\n     * @dev Execute authorised calls via delegate call\r\n     * @param _target logic proxy address\r\n     * @param _data delegate call data\r\n     * @param _src to find the source\r\n     * @param _session to find the session\r\n     */\r\n    function execute(\r\n        address _target,\r\n        bytes memory _data,\r\n        uint _src,\r\n        uint _session\r\n    ) \r\n        public\r\n        payable\r\n        note\r\n        auth\r\n        logicAuth(_target)\r\n        returns (bytes memory response)\r\n    {\r\n        emit LogExecute(\r\n            _target,\r\n            _src,\r\n            _session\r\n        );\r\n        \r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\r\n            let size := returndatasize\r\n\r\n            response := mload(0x40)\r\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n            mstore(response, size)\r\n            returndatacopy(add(response, 0x20), 0, size)\r\n\r\n            switch iszero(succeeded)\r\n                case 1 {\r\n                    // throw if delegatecall failed\r\n                    revert(add(response, 0x20), size)\r\n                }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title AddressRegistry\r\n/// @notice \r\n/// @dev \r\ncontract AddressRegistry {\r\n    event LogSetAddress(string name, address addr);\r\n\r\n    /// @notice Registry of role and address\r\n    mapping(bytes32 => address) registry;\r\n\r\n    /**\r\n     * @dev Check if msg.sender is admin or owner.\r\n     */\r\n    modifier isAdmin() {\r\n        require(\r\n            msg.sender == getAddress(\"admin\") || \r\n            msg.sender == getAddress(\"owner\"),\r\n            \"permission-denied\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Get the address from system registry \r\n    /// @param _name (string)\r\n    /// @return  (address) Returns address based on role\r\n    function getAddress(string memory _name) public view returns(address) {\r\n        return registry[keccak256(abi.encodePacked(_name))];\r\n    }\r\n\r\n    /// @dev Set new address in system registry \r\n    /// @param _name (string) Role name\r\n    /// @param _userAddress (string) User Address\r\n    function setAddress(string memory _name, address _userAddress) public isAdmin {\r\n        registry[keccak256(abi.encodePacked(_name))] = _userAddress;\r\n        emit LogSetAddress(_name, _userAddress);\r\n    }\r\n}\r\n\r\n\r\n/// @title LogicRegistry\r\n/// @notice\r\n/// @dev LogicRegistry \r\ncontract LogicRegistry is AddressRegistry {\r\n\r\n    event LogEnableStaticLogic(address logicAddress);\r\n    event LogEnableLogic(address logicAddress);\r\n    event LogDisableLogic(address logicAddress);\r\n\r\n    /// @notice Map of static proxy state\r\n    mapping(address => bool) public logicProxiesStatic;\r\n    \r\n    /// @notice Map of logic proxy state\r\n    mapping(address => bool) public logicProxies;\r\n\r\n    /// @dev \r\n    /// @param _logicAddress (address)\r\n    /// @return  (bool)\r\n    function logic(address _logicAddress) public view returns (bool) {\r\n        if (logicProxiesStatic[_logicAddress] || logicProxies[_logicAddress]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev \r\n    /// @param _logicAddress (address)\r\n    /// @return  (bool)\r\n    function logicStatic(address _logicAddress) public view returns (bool) {\r\n        if (logicProxiesStatic[_logicAddress]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Sets the static logic proxy to true\r\n    /// static proxies mostly contains the logic for withdrawal of assets\r\n    /// and can never be false to freely let user withdraw their assets\r\n    /// @param _logicAddress (address)\r\n    function enableStaticLogic(address _logicAddress) public isAdmin {\r\n        logicProxiesStatic[_logicAddress] = true;\r\n        emit LogEnableStaticLogic(_logicAddress);\r\n    }\r\n\r\n    /// @dev Enable logic proxy address\r\n    /// @param _logicAddress (address)\r\n    function enableLogic(address _logicAddress) public isAdmin {\r\n        logicProxies[_logicAddress] = true;\r\n        emit LogEnableLogic(_logicAddress);\r\n    }\r\n\r\n    /// @dev Disable logic proxy address\r\n    /// @param _logicAddress (address)\r\n    function disableLogic(address _logicAddress) public isAdmin {\r\n        logicProxies[_logicAddress] = false;\r\n        emit LogDisableLogic(_logicAddress);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Deploys a new proxy instance and sets msg.sender as owner of proxy\r\n */\r\ncontract WalletRegistry is LogicRegistry {\r\n    \r\n    event Created(address indexed sender, address indexed owner, address proxy);\r\n    event LogRecord(address indexed currentOwner, address indexed nextOwner, address proxy);\r\n    \r\n    /// @notice Address to UserWallet proxy map\r\n    mapping(address => UserWallet) public proxies;\r\n    \r\n    /// @dev Deploys a new proxy instance and sets custom owner of proxy\r\n    /// Throws if the owner already have a UserWallet\r\n    /// @return proxy ()\r\n    function build() public returns (UserWallet proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    /// @dev update the proxy record whenever owner changed on any proxy\r\n    /// Throws if msg.sender is not a proxy contract created via this contract\r\n    /// @return proxy () UserWallet\r\n    function build(address _owner) public returns (UserWallet proxy) {\r\n        require(proxies[_owner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\r\n        proxy = new UserWallet();\r\n        proxies[address(this)] = proxy; // will be changed via record() in next line execution\r\n        proxy.setOwner(_owner);\r\n        emit Created(msg.sender, _owner, address(proxy));\r\n    }\r\n\r\n    /// @dev Transafers ownership\r\n    /// @param _currentOwner (address) Current Owner\r\n    /// @param _nextOwner (address) Next Owner\r\n    function record(address _currentOwner, address _nextOwner) public {\r\n        require(msg.sender == address(proxies[_currentOwner]), \"invalid-proxy-or-owner\");\r\n        require(proxies[_nextOwner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\r\n        proxies[_nextOwner] = proxies[_currentOwner];\r\n        proxies[_currentOwner] = UserWallet(0);\r\n        emit LogRecord(_currentOwner, _nextOwner, address(proxies[_nextOwner]));\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title InstaRegistry\r\n/// @dev Initializing Registry\r\ncontract InstaRegistry is WalletRegistry {\r\n\r\n    constructor() public {\r\n        registry[keccak256(abi.encodePacked(\"admin\"))] = msg.sender;\r\n        registry[keccak256(abi.encodePacked(\"owner\"))] = msg.sender;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_logicAddress\",\"type\":\"address\"}],\"name\":\"logic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logicAddress\",\"type\":\"address\"}],\"name\":\"enableStaticLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"logicProxies\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"logicProxiesStatic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentOwner\",\"type\":\"address\"},{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"record\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logicAddress\",\"type\":\"address\"}],\"name\":\"enableLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"build\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_logicAddress\",\"type\":\"address\"}],\"name\":\"logicStatic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxies\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logicAddress\",\"type\":\"address\"}],\"name\":\"disableLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"build\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nextOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"LogRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"logicAddress\",\"type\":\"address\"}],\"name\":\"LogEnableStaticLogic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"logicAddress\",\"type\":\"address\"}],\"name\":\"LogEnableLogic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"logicAddress\",\"type\":\"address\"}],\"name\":\"LogDisableLogic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"LogSetAddress\",\"type\":\"event\"}]","ContractName":"InstaRegistry","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ad9cc8aa41c61d87638a4b48b17d050a9e9e66d2d8709f400a2357e45cfa2df"}]}