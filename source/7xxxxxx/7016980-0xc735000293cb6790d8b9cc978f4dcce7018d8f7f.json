{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n/*\r\n* In Contracts We Trust\r\n*\r\n* Countdown3D is a provably-fair multi tier lottery played using Ether\r\n*\r\n* ======================== *\r\n*     CRYPTO COUNTDOWN     *\r\n*          3 2 1           *\r\n* ======================== *\r\n* [x] Provably Fair\r\n* [x] Open Source\r\n* [x] Multi Tier Rewards\r\n* [x] Battle Tested with the Team Just community!\r\n*\r\n*/\r\n\r\n// Invest in Hourglass Contract Interface\r\n// 0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe\r\ninterface HourglassInterface {\r\n    // Invest in dividends for bigger better shinier future jackpots\r\n    function buy(address _playerAddress) external payable returns(uint256);\r\n    // Withdraw hourglass dividends to the round pot\r\n    function withdraw() external;\r\n    // Would you look at all those divs\r\n    function dividendsOf(address _playerAddress) external view returns(uint256);\r\n    // Check out that hourglass balance\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n}\r\n\r\n\r\ncontract Countdown3D {\r\n\r\n    /* ==== INTERFACE ==== */\r\n    HourglassInterface internal hourglass;\r\n\r\n    /* ==== EVENTS ==== */\r\n    // Emit event onBuy\r\n    event OnBuy(address indexed _playerAddress, uint indexed _roundId, uint _tickets, uint _value);\r\n    // Emit event when round is capped\r\n    event OnRoundCap(uint _roundId);\r\n    // Emit event when new round starts\r\n    event OnRoundStart(uint _roundId);\r\n\r\n    /* ==== GLOBALS ==== */\r\n    // Crypto Countdown timer\r\n    uint256 constant public COOLDOWN = 7 days;\r\n\r\n    // Cost per ticket\r\n    uint256 constant public COST = 0.01 ether;\r\n\r\n    // Claim your winnings within 5 rounds\r\n    uint256 constant public EXPIRATION = 5;\r\n\r\n    // Minimum number of tickets needed to build a pyramid\r\n    uint256 constant public QUORUM = 21;\r\n\r\n    // Maximum tickets an account can hold at any given time\r\n    uint256 constant public TICKET_MAX = 101;\r\n\r\n    // The Current Round\r\n    uint256 public currentRoundId;\r\n\r\n    // Developers\r\n    address private dev1;\r\n    address private dev2;\r\n\r\n    /* ==== STRUCT ==== */\r\n    struct Round {\r\n        // Balance set after the round is capped\r\n        uint256 balance;\r\n        // Block number that caps this round\r\n        uint256 blockCap;\r\n        // Ether claimed from this round\r\n        uint256 claimed;\r\n        // Pot is composed of tickets, donations, unclaimed winnings, percent of previous round, and hourglass dividends\r\n        uint256 pot;\r\n        // Random index from the future\r\n        uint256 random;\r\n        // Timestamp when this round kicks off\r\n        uint256 startTime;\r\n        // Total tickets in this round\r\n        uint256 tickets;\r\n        // Value of a ticket in each winning tier\r\n        mapping (uint256 => uint256) caste;\r\n        // Validate a round to score a reward\r\n        mapping (address => uint256) reward;\r\n    }\r\n\r\n    struct Account {\r\n        // Store each round an account holds tickets\r\n        uint256[] roundsActive;\r\n        // Store each round an account holds validation rewards\r\n        uint256[] rewards;\r\n        // Map Round id to ticket sets\r\n        mapping(uint256 => TicketSet[]) ticketSets;\r\n        // Total tickets held by account\r\n        uint256 tickets;\r\n    }\r\n\r\n    // A set of tickets\r\n    struct TicketSet {\r\n        // Index of first ticket in set\r\n        uint256 start;\r\n        // Index of last ticket in the set\r\n        uint256 end;\r\n    }\r\n\r\n    // Map a round id to a round\r\n    mapping (uint256 => Round) internal rounds;\r\n    // Map an address to an account\r\n    mapping (address => Account) internal accounts;\r\n\r\n    /* ==== CONSTRUCTOR ==== */\r\n    constructor(address hourglassAddress, address dev1Address, address dev2Address) public {\r\n        // Set round 0 start time here\r\n        rounds[0].startTime = now + 7 days;\r\n        // Set hourglass interface\r\n        hourglass = HourglassInterface(hourglassAddress);\r\n        // Set dev1\r\n        dev1 = dev1Address;\r\n        // Set dev2\r\n        dev2 = dev2Address;\r\n    }\r\n    /* ==== PUBLIC WRITE ==== */\r\n\r\n    // Ether sent directly to contract gets donated to the pot\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // Donate ETH sent directly to contract as long as the sender is not the hourglass contract\r\n        if (msg.sender != address(hourglass)) {\r\n            donateToPot();\r\n        }\r\n    }\r\n\r\n    // Buy a ticket or tickets\r\n    function buy()\r\n        public\r\n        payable\r\n    {\r\n        // Current round or next round\r\n        (Round storage round, uint256 roundId) = getRoundInProgress();\r\n\r\n        // Calculate number of tickets and any change\r\n        (uint256 tickets, uint256 change) = processTickets();\r\n\r\n        // Send change to the round pot\r\n        round.pot = round.pot + change;\r\n\r\n        // Allocate tickets to account\r\n        if (tickets > 0) {\r\n            // Give player their tickets\r\n            pushTicketSetToAccount(roundId, tickets);\r\n            // Increment tickets in the round\r\n            round.tickets = round.tickets + tickets;\r\n        }\r\n        // Broadcast an event when a ticket set is purchased\r\n        emit OnBuy(msg.sender, roundId, tickets, msg.value);\r\n    }\r\n\r\n    // Support a good cause, invest in dividends\r\n    function donateToDivs()\r\n        public\r\n        payable\r\n    {\r\n        // Buys investment tokens from hourglass contract\r\n        hourglass.buy.value(msg.value)(msg.sender);\r\n    }\r\n\r\n    // Support a good cause, donate to the round pot\r\n    function donateToPot()\r\n        public\r\n        payable\r\n    {\r\n        if (msg.value > 0) {\r\n            // Current round or next round\r\n            (Round storage round,) = getRoundInProgress();\r\n            round.pot = round.pot + msg.value;\r\n        }\r\n    }\r\n\r\n    // Complete and Secure the round\r\n    function validate()\r\n        public\r\n    {\r\n        // Current Round\r\n        Round storage round = rounds[currentRoundId];\r\n\r\n        // First check if round was already validated\r\n        require(round.random == 0);\r\n\r\n        // Require minimum number of tickets to build a pyramid\r\n        require(round.tickets >= QUORUM);\r\n\r\n        // Require cooldown between rounds\r\n        require(round.startTime + COOLDOWN <= now);\r\n\r\n        // If blockcap is not set yet, cap the round\r\n        if (round.blockCap == 0) {\r\n            allocateToPot(round);\r\n            allocateFromPot(round);\r\n\r\n            // Set blockcap\r\n            round.blockCap = block.number;\r\n            emit OnRoundCap(currentRoundId);\r\n        } else {\r\n            // Require a future block\r\n            require(block.number > round.blockCap);\r\n\r\n            // Get blockhash from the blockcap block\r\n            uint32 blockhash_ = uint32(bytes4(blockhash(round.blockCap)));\r\n\r\n            // Confirm blockhash has not expired on network\r\n            if (blockhash_ != 0) {\r\n                closeTheRound(round, blockhash_);\r\n            } else {\r\n                // Cap round again\r\n                round.blockCap = block.number;\r\n                emit OnRoundCap(currentRoundId);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Withdraw ticket winnings\r\n    function withdraw()\r\n        public\r\n    {\r\n        // Total amount to withdraw\r\n        uint256 total;\r\n        // Flag to check if account holds current or next round tickets\r\n        bool withholdRounds;\r\n        // Player account\r\n        Account storage account = accounts[msg.sender];\r\n        // Total number of rounds a player holds tickets\r\n        uint256 accountRoundsActiveLength = account.roundsActive.length;\r\n\r\n        // Loop through each round the player holds tickets\r\n        for (uint256 i = 0; i < accountRoundsActiveLength; i++) {\r\n            uint256 roundId = account.roundsActive[i];\r\n\r\n            // Only check if round was already validated\r\n            if (roundId < currentRoundId) {\r\n                // Get amount won in the round\r\n                (uint256 amount, uint256 totalTickets) = getRoundWinnings(msg.sender, roundId);\r\n\r\n                // Subtract tickets from account\r\n                account.tickets = account.tickets - totalTickets;\r\n\r\n                // Delete round from player's account\r\n                delete account.ticketSets[roundId];\r\n\r\n                // If the player won during the round\r\n                if (amount > 0) {\r\n                    // Increment amount claimed\r\n                    rounds[roundId].claimed = rounds[roundId].claimed + amount;\r\n                    // Add to total withdraw\r\n                    total = total + amount;\r\n                }\r\n            } else {\r\n                // Flag to check if account holds current or next round tickets\r\n                withholdRounds = true;\r\n            }\r\n        }\r\n\r\n        // Delete processed rounds\r\n        sweepRoundsActive(withholdRounds);\r\n\r\n        // Last but not least, send ticket winnings\r\n        if (total > 0) {\r\n            msg.sender.transfer(total);\r\n        }\r\n    }\r\n\r\n    // Did you validate a round, claim your rewards here\r\n    function claimRewards()\r\n        public\r\n    {\r\n        // Total amount to withdraw\r\n        uint256 total;\r\n        // Player account\r\n        Account storage account = accounts[msg.sender];\r\n        // Total number of rounds with rewards\r\n        uint256 accountRewardsLength = account.rewards.length;\r\n\r\n        // Loop through each round the player holds rewards\r\n        for (uint256 i = 0; i < accountRewardsLength; i++) {\r\n            // Round with a reward\r\n            uint256 roundId = account.rewards[i];\r\n            // Get reward amount won in the round\r\n            uint256 amount = getRewardWinnings(msg.sender, roundId);\r\n            // Delete reward from round\r\n            delete rounds[roundId].reward[msg.sender];\r\n\r\n            // If player has rewards in the round\r\n            if (amount > 0) {\r\n                // Increment amount claimed\r\n                rounds[roundId].claimed = rounds[roundId].claimed + amount;\r\n                // Add to total withdraw\r\n                total = total + amount;\r\n            }\r\n        }\r\n\r\n        // Delete processed rewards\r\n        delete accounts[msg.sender].rewards;\r\n\r\n        // Transfer rewards to player\r\n        if (total > 0) {\r\n            msg.sender.transfer(total);\r\n        }\r\n    }\r\n\r\n    /* ==== PUBLIC READ ==== */\r\n    // Get global game constants\r\n    function getConfig()\r\n        public\r\n        pure\r\n        returns(uint256 cooldown, uint256 cost, uint256 expiration, uint256 quorum, uint256 ticketMax)\r\n    {\r\n        return(COOLDOWN, COST, EXPIRATION, QUORUM, TICKET_MAX);\r\n    }\r\n\r\n    // Get info for a given Round\r\n    function getRound(uint256 roundId)\r\n        public\r\n        view\r\n        returns(\r\n            uint256 balance, \r\n            uint256 blockCap, \r\n            uint256 claimed, \r\n            uint256 pot, \r\n            uint256 random, \r\n            uint256 startTime, \r\n            uint256 tickets)\r\n    {\r\n        Round storage round = rounds[roundId];\r\n\r\n        return(round.balance, round.blockCap, round.claimed, round.pot, round.random, round.startTime, round.tickets);\r\n    }\r\n\r\n    // Get total number of tickets held by account\r\n    function getTotalTickets(address accountAddress)\r\n        public\r\n        view\r\n        returns(uint256 tickets)\r\n    {\r\n        return accounts[accountAddress].tickets;\r\n    }\r\n\r\n    // Get value of ticket held in each winning caste\r\n    function getRoundCasteValues(uint256 roundId)\r\n        public\r\n        view\r\n        returns(uint256 caste0, uint256 caste1, uint256 caste2)\r\n    {\r\n        return(rounds[roundId].caste[0], rounds[roundId].caste[1], rounds[roundId].caste[2]);\r\n    }\r\n\r\n    // Get rounds account is active\r\n    function getRoundsActive(address accountAddress)\r\n        public\r\n        view\r\n        returns(uint256[] memory)\r\n    {\r\n        return accounts[accountAddress].roundsActive;\r\n    }\r\n\r\n    // Get the rounds an account has unclaimed rewards\r\n    function getRewards(address accountAddress)\r\n        public\r\n        view\r\n        returns(uint256[] memory)\r\n    {\r\n        return accounts[accountAddress].rewards;\r\n    }\r\n\r\n    // Get the total number of ticket sets an account holds for a given round\r\n    function getTotalTicketSetsForRound(address accountAddress, uint256 roundId)\r\n        public\r\n        view\r\n        returns(uint256 ticketSets)\r\n    {\r\n        return accounts[accountAddress].ticketSets[roundId].length;\r\n    }\r\n\r\n    // Get an account's individual ticket set from a round\r\n    function getTicketSet(address accountAddress, uint256 roundId, uint256 index)\r\n        public\r\n        view\r\n        returns(uint256 start, uint256 end)\r\n    {\r\n        TicketSet storage ticketSet = accounts[accountAddress].ticketSets[roundId][index];\r\n\r\n        // Starting ticket and ending ticket in set\r\n        return (ticketSet.start, ticketSet.end);\r\n    }\r\n\r\n    // Get the value of a ticket\r\n    function getTicketValue(uint256 roundId, uint256 ticketIndex)\r\n        public\r\n        view\r\n        returns(uint256 ticketValue)\r\n    {\r\n        // Check if the round expired\r\n        if (currentRoundId > roundId && (currentRoundId - roundId) >= EXPIRATION) {\r\n            return 0;\r\n        }\r\n\r\n        Round storage round = rounds[roundId];\r\n        // Set which tier the ticket is in\r\n        uint256 tier = getTier(roundId, ticketIndex);\r\n\r\n        // Return ticket value based on tier\r\n        if (tier == 5) {\r\n            return 0;\r\n        } else if (tier == 4) {\r\n            return COST / 2;\r\n        } else if (tier == 3) {\r\n            return COST;\r\n        } else {\r\n            return round.caste[tier];\r\n        }\r\n    }\r\n\r\n    // Get which tier a ticket is in\r\n    function getTier(uint256 roundId, uint256 ticketIndex)\r\n        public\r\n        view\r\n        returns(uint256 tier)\r\n    {\r\n        Round storage round = rounds[roundId];\r\n        // Distance from random index\r\n        uint256 distance = Math.distance(round.random, ticketIndex, round.tickets);\r\n        // Tier based on ticket index\r\n        uint256 ticketTier = Caste.tier(distance, round.tickets - 1);\r\n\r\n        return ticketTier;\r\n    }\r\n\r\n    // Get the amount won in a round\r\n    function getRoundWinnings(address accountAddress, uint256 roundId)\r\n        public\r\n        view\r\n        returns(uint256 totalWinnings, uint256 totalTickets)\r\n    {\r\n        // Player account\r\n        Account storage account = accounts[accountAddress];\r\n        // Ticket sets an account holds in a given round\r\n        TicketSet[] storage ticketSets = account.ticketSets[roundId];\r\n\r\n        // Holds total winnings in a round\r\n        uint256 total;\r\n        // Total number of ticket sets\r\n        uint256 ticketSetLength = ticketSets.length;\r\n        // Holds total individual tickets in a round\r\n        uint256 totalTicketsInRound;\r\n\r\n        // Check if round expired\r\n        if (currentRoundId > roundId && (currentRoundId - roundId) >= EXPIRATION) {\r\n            // Round expired\r\n            // Loop through each ticket set\r\n            for (uint256 i = 0; i < ticketSetLength; i++) {\r\n                // Calculate the total number of tickets in a set\r\n                uint256 totalTicketsInSet = (ticketSets[i].end - ticketSets[i].start) + 1;\r\n                // Add the total number of tickets to the total number of tickets in the round\r\n                totalTicketsInRound = totalTicketsInRound + totalTicketsInSet;\r\n            }\r\n\r\n            // After looping through all of the tickets, return total winnings and total tickets in round\r\n            return (total, totalTicketsInRound);\r\n        }\r\n\r\n        // If the round has not expired, Loop through each ticket set\r\n        for (uint256 i = 0; i < ticketSetLength; i++) {\r\n            // Subtract one to get true ticket index\r\n            uint256 startIndex = ticketSets[i].start - 1;\r\n            uint256 endIndex = ticketSets[i].end - 1;\r\n            // Loop through each ticket\r\n            for (uint256 j = startIndex; j <= endIndex; j++) {\r\n                // Add the ticket value to total round winnings\r\n                total = total + getTicketWinnings(roundId, j);\r\n            }\r\n            // Calculate the total number of tickets in a set\r\n            uint256 totalTicketsInSet = (ticketSets[i].end - ticketSets[i].start) + 1;\r\n            // Set the total number of tickets in a round\r\n            totalTicketsInRound = totalTicketsInRound + totalTicketsInSet;\r\n        }\r\n        // After looping through all of the tickets, return total winnings and total tickets in round\r\n        return (total, totalTicketsInRound);\r\n    }\r\n\r\n    // Get the value of a reward in a round such as validator reward\r\n    function getRewardWinnings(address accountAddress, uint256 roundId)\r\n        public\r\n        view\r\n        returns(uint256 reward)\r\n    {\r\n        // Check if round expired\r\n        if (currentRoundId > roundId && (currentRoundId - roundId) >= EXPIRATION) {\r\n            // Reward expired\r\n            return 0;\r\n        }\r\n        // Reward did not expire\r\n        return rounds[roundId].reward[accountAddress];\r\n    }\r\n\r\n    // Get dividends from hourglass contract\r\n    function getDividends()\r\n        public\r\n        view\r\n        returns(uint256 dividends)\r\n    {\r\n        return hourglass.dividendsOf(address(this));\r\n    }\r\n\r\n    // Get total amount of tokens owned by contract\r\n    function getHourglassBalance()\r\n        public\r\n        view\r\n        returns(uint256 hourglassBalance)\r\n    {\r\n        return hourglass.balanceOf(address(this));\r\n    }\r\n\r\n    /* ==== PRIVATE ==== */\r\n    // At the end of the round, distribute percentages from the pot\r\n    function allocateFromPot(Round storage round)\r\n        private\r\n    {\r\n        // 75% to winning Castes\r\n        (round.caste[0], round.caste[1], round.caste[2]) = Caste.values((round.tickets - 1), round.pot, COST);\r\n\r\n        // 15% to next generation\r\n        rounds[currentRoundId + 1].pot = (round.pot * 15) / 100;\r\n\r\n        // 2% to each dev\r\n        uint256 percent2 = (round.pot * 2) / 100;\r\n        round.reward[dev1] = percent2;\r\n        round.reward[dev2] = percent2;\r\n\r\n        // Cleanup unclaimed dev rewards\r\n        if (accounts[dev1].rewards.length == TICKET_MAX) {\r\n            delete accounts[dev1].rewards;\r\n        }\r\n        if (accounts[dev2].rewards.length == TICKET_MAX) {\r\n            delete accounts[dev2].rewards;\r\n        }\r\n        // Store round with reward\r\n        accounts[dev1].rewards.push(currentRoundId);\r\n        accounts[dev2].rewards.push(currentRoundId);\r\n\r\n        // 5% buys hourglass token\r\n        hourglass.buy.value((round.pot * 5) / 100)(msg.sender);\r\n\r\n        // 20% of round pot claimed from 15% to next round and 5% investment in hourglass token\r\n        round.claimed = (round.pot * 20) / 100;\r\n    }\r\n\r\n    // At the end of the round, allocate investment dividends and bottom tiers to the pot\r\n    function allocateToPot(Round storage round)\r\n        private\r\n    {\r\n        // Balance is seed pot combined with total tickets\r\n        round.balance = round.pot + (round.tickets * COST);\r\n\r\n        // Bottom tiers to the pot\r\n        round.pot = round.pot + Caste.pool(round.tickets - 1, COST);\r\n\r\n        // Check investment dividends accrued\r\n        uint256 dividends = getDividends();\r\n        // If there are dividends available\r\n        if (dividends > 0) {\r\n            // Withdraw dividends from hourglass contract\r\n            hourglass.withdraw();\r\n            // Allocate dividends to the round pot\r\n            round.pot = round.pot + dividends;\r\n        }\r\n    }\r\n\r\n    // Close the round\r\n    function closeTheRound(Round storage round, uint32 blockhash_)\r\n        private\r\n    {\r\n        // Prevent devs from validating round since they already get a reward\r\n        require(round.reward[msg.sender] == 0);\r\n        // Reward the validator\r\n        round.reward[msg.sender] = round.pot / 100;\r\n        // If validator hits a limit without withdrawing their rewards\r\n        if (accounts[msg.sender].rewards.length == TICKET_MAX) {\r\n            delete accounts[msg.sender].rewards;\r\n        }\r\n\r\n        // Store round id validator holds a reward\r\n        accounts[msg.sender].rewards.push(currentRoundId);\r\n\r\n        // Set random number\r\n        round.random = Math.random(blockhash_, round.tickets);\r\n\r\n        // Set current round id\r\n        currentRoundId = currentRoundId + 1;\r\n\r\n        // New Round\r\n        Round storage newRound = rounds[currentRoundId];\r\n\r\n        // Set next round start time\r\n        newRound.startTime = now;\r\n\r\n        // Start expiring rounds at Round 5\r\n        if (currentRoundId >= EXPIRATION) {\r\n            // Set expired round\r\n            Round storage expired = rounds[currentRoundId - EXPIRATION];\r\n            // Check if expired round has a balance\r\n            if (expired.balance > expired.claimed) {\r\n                // Allocate expired funds to next round\r\n                newRound.pot = newRound.pot + (expired.balance - expired.claimed);\r\n            }\r\n        }\r\n\r\n        // Broadcast a new round is starting\r\n        emit OnRoundStart(currentRoundId);\r\n    }\r\n\r\n    // Get Current round or next round depending on whether blockcap is set\r\n    function getRoundInProgress()\r\n        private\r\n        view\r\n        returns(Round storage, uint256 roundId)\r\n    {\r\n        // Current Round if blockcap not set yet\r\n        if (rounds[currentRoundId].blockCap == 0) {\r\n            return (rounds[currentRoundId], currentRoundId);\r\n        }\r\n        // Next round if blockcap is set\r\n        return (rounds[currentRoundId + 1], currentRoundId + 1);\r\n    }\r\n\r\n    // Get the value of an individual ticket in a given round\r\n    function getTicketWinnings(uint256 roundId, uint256 index)\r\n        private\r\n        view\r\n        returns(uint256 ticketValue)\r\n    {\r\n        Round storage round = rounds[roundId];\r\n        // Set which tier the ticket is in\r\n        uint256 tier = getTier(roundId, index);\r\n\r\n        // Return ticket value based on tier\r\n        if (tier == 5) {\r\n            return 0;\r\n        } else if (tier == 4) {\r\n            return COST / 2;\r\n        } else if (tier == 3) {\r\n            return COST;\r\n        } else {\r\n            return round.caste[tier];\r\n        }\r\n    }\r\n\r\n    // Calculate total tickets and remainder based on message value\r\n    function processTickets()\r\n        private\r\n        view\r\n        returns(uint256 totalTickets, uint256 totalRemainder)\r\n    {\r\n        // Calculate total tickets based on msg.value and ticket cost\r\n        uint256 tickets = Math.divide(msg.value, COST);\r\n        // Calculate remainder based on msg.value and ticket cost\r\n        uint256 remainder = Math.remainder(msg.value, COST);\r\n\r\n        return (tickets, remainder);\r\n    }\r\n\r\n    // Stores ticket set in player account\r\n    function pushTicketSetToAccount(uint256 roundId, uint256 tickets)\r\n        private\r\n    {\r\n        // Player account\r\n        Account storage account = accounts[msg.sender];\r\n        // Round to add tickets\r\n        Round storage round = rounds[roundId];\r\n\r\n        // Store which rounds the player buys tickets in\r\n        if (account.ticketSets[roundId].length == 0) {\r\n            account.roundsActive.push(roundId);\r\n        }\r\n\r\n        // Require existing tickets plus new tickets\r\n        // Is less than maximum allowable tickets an account can hold\r\n        require((account.tickets + tickets) < TICKET_MAX);\r\n        account.tickets = account.tickets + tickets;\r\n\r\n        // Store ticket set\r\n        account.ticketSets[roundId].push(TicketSet(round.tickets + 1, round.tickets + tickets));\r\n    }\r\n\r\n    // Delete unused state after withdrawing to lower gas cost for the player\r\n    function sweepRoundsActive(bool withholdRounds)\r\n        private\r\n    {\r\n        // Delete any rounds that are not current or next round\r\n        if (withholdRounds != true) {\r\n            // Remove active rounds from player account\r\n            delete accounts[msg.sender].roundsActive;\r\n        } else {\r\n            bool current;\r\n            bool next;\r\n            // Total number of active rounds\r\n            uint256 roundActiveLength = accounts[msg.sender].roundsActive.length;\r\n\r\n            // Loop each round account was active\r\n            for (uint256 i = 0; i < roundActiveLength; i++) {\r\n                uint256 roundId = accounts[msg.sender].roundsActive[i];\r\n\r\n                // Flag if account has tickets in current round\r\n                if (roundId == currentRoundId) {\r\n                    current = true;\r\n                }\r\n                // Flag if account has tickets in next round\r\n                if (roundId > currentRoundId) {\r\n                    next = true;\r\n                }\r\n            }\r\n\r\n            // Remove active rounds from player account\r\n            delete accounts[msg.sender].roundsActive;\r\n\r\n            // Add back current round if player holds tickets in current round\r\n            if (current == true) {\r\n                accounts[msg.sender].roundsActive.push(currentRoundId);\r\n            }\r\n            // Add back current round if player holds tickets in next round\r\n            if (next == true) {\r\n                accounts[msg.sender].roundsActive.push(currentRoundId + 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Math\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary Math {\r\n    /**\r\n    * @dev Calculates a distance between start and finish wrapping around total\r\n    */\r\n    function distance(uint256 start, uint256 finish, uint256 total)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (start < finish) {\r\n            return finish - start;\r\n        }\r\n        if (start > finish) {\r\n            return (total - start) + finish;\r\n        }\r\n        if (start == finish) {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the quotient between the numerator and denominator.\r\n    */\r\n    function divide(uint256 numerator, uint256 denominator)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // EVM does not allow division by zero\r\n        return numerator / denominator;\r\n    }\r\n\r\n    /**\r\n    * @dev Generate random number from blockhash\r\n    */\r\n    function random(uint32 blockhash_, uint256 max)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // encoded blockhash as uint256\r\n        uint256 encodedBlockhash = uint256(keccak256(abi.encodePacked(blockhash_)));\r\n        // random number from 0 to (max - 1)\r\n        return (encodedBlockhash % max);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the remainder between the numerator and denominator.\r\n    */\r\n    function remainder(uint256 numerator, uint256 denominator)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // EVM does not allow division by zero\r\n        return numerator % denominator;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Caste\r\n * @dev Caste operations\r\n */\r\nlibrary Caste {\r\n\r\n    /**\r\n    * @dev Calculates amount of ether to transfer to the pot from the caste pool\r\n    * total is 1 less than total number of tickets to take 0 index into account\r\n    */\r\n    function pool(uint256 total, uint256 cost)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 tier4 = ((total * 70) / 100) - ((total * 45) / 100);\r\n        uint256 tier5 = total - ((total * 70) / 100);\r\n\r\n        return (tier5 * cost) + ((tier4 * cost) / 2);\r\n    }\r\n\r\n    /**\r\n    * @dev Provides the tier based on an index and total in the caste pool\r\n    */\r\n    function tier(uint256 distance, uint256 total)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 percent = (distance * (10**18)) / total;\r\n\r\n        if (percent > 700000000000000000) {\r\n            return 5;\r\n        }\r\n        if (percent > 450000000000000000) {\r\n            return 4;\r\n        }\r\n        if (percent > 250000000000000000) {\r\n            return 3;\r\n        }\r\n        if (percent > 100000000000000000) {\r\n            return 2;\r\n        }\r\n        if (percent > 0) {\r\n            return 1;\r\n        }\r\n        if (distance == 0) {\r\n            return 0;\r\n        } else {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates value per winning caste\r\n    */\r\n    function values(uint256 total, uint256 pot, uint256 cost)\r\n        internal\r\n        pure\r\n        returns(uint256, uint256, uint256)\r\n    {\r\n        uint256 percent10 = (total * 10) / 100;\r\n        uint256 percent25 = (total * 25) / 100;\r\n        uint256 caste0 = (pot * 25) / 100;\r\n        uint256 caste1 = cost + (caste0 / percent10);\r\n        uint256 caste2 = cost + (caste0 / (percent25 - percent10));\r\n\r\n        return (caste0 + cost, caste1, caste2);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getRoundsActive\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUORUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TICKET_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundCasteValues\",\"outputs\":[{\"name\":\"caste0\",\"type\":\"uint256\"},{\"name\":\"caste1\",\"type\":\"uint256\"},{\"name\":\"caste2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"ticketIndex\",\"type\":\"uint256\"}],\"name\":\"getTier\",\"outputs\":[{\"name\":\"tier\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"validate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getTotalTicketSetsForRound\",\"outputs\":[{\"name\":\"ticketSets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"ticketIndex\",\"type\":\"uint256\"}],\"name\":\"getTicketValue\",\"outputs\":[{\"name\":\"ticketValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"blockCap\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"random\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"tickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHourglassBalance\",\"outputs\":[{\"name\":\"hourglassBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COOLDOWN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXPIRATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTicketSet\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"name\":\"cooldown\",\"type\":\"uint256\"},{\"name\":\"cost\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"quorum\",\"type\":\"uint256\"},{\"name\":\"ticketMax\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"getTotalTickets\",\"outputs\":[{\"name\":\"tickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRewardWinnings\",\"outputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDividends\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToDivs\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundWinnings\",\"outputs\":[{\"name\":\"totalWinnings\",\"type\":\"uint256\"},{\"name\":\"totalTickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"hourglassAddress\",\"type\":\"address\"},{\"name\":\"dev1Address\",\"type\":\"address\"},{\"name\":\"dev2Address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"OnBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"OnRoundCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"OnRoundStart\",\"type\":\"event\"}]","ContractName":"Countdown3D","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b3775fb83f7d12a36e0475abdd1fca35c091efbe00000000000000000000000044a654cbed14a8b3d9ec6bd8df9eb86e19b2c3bb000000000000000000000000aa83ad367892cee155ab3f4af52e18dc9f0d78dd","Library":"","SwarmSource":"bzzr://cf2f34ee8f79aae81c2c76bae851446a4666763e8b67f074f0c001ac56918525"}]}