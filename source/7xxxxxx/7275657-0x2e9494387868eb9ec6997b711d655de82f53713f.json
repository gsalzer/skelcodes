{"status":"1","message":"OK","result":[{"SourceCode":"/** \r\n*   ________  __                  __          __      __                        _______             __        __        __    __     \r\n*  |        \\|  \\                |  \\        |  \\    |  \\                      |       \\           |  \\      |  \\      |  \\  |  \\    \r\n*  | $$$$$$$$ \\$$ _______    ____| $$       _| $$_   | $$____    ______        | $$$$$$$\\  ______  | $$____  | $$____   \\$$ _| $$_   \r\n*  | $$__    |  \\|       \\  /      $$      |   $$ \\  | $$    \\  /      \\       | $$__| $$ |      \\ | $$    \\ | $$    \\ |  \\|   $$ \\  \r\n*  | $$  \\   | $$| $$$$$$$\\|  $$$$$$$       \\$$$$$$  | $$$$$$$\\|  $$$$$$\\      | $$    $$  \\$$$$$$\\| $$$$$$$\\| $$$$$$$\\| $$ \\$$$$$$  \r\n*  | $$$$$   | $$| $$  | $$| $$  | $$        | $$ __ | $$  | $$| $$    $$      | $$$$$$$\\ /      $$| $$  | $$| $$  | $$| $$  | $$ __ \r\n*  | $$      | $$| $$  | $$| $$__| $$        | $$|  \\| $$  | $$| $$$$$$$$      | $$  | $$|  $$$$$$$| $$__/ $$| $$__/ $$| $$  | $$|  \\\r\n*  | $$      | $$| $$  | $$ \\$$    $$         \\$$  $$| $$  | $$ \\$$     \\      | $$  | $$ \\$$    $$| $$    $$| $$    $$| $$   \\$$  $$\r\n*   \\$$       \\$$ \\$$   \\$$  \\$$$$$$$          \\$$$$  \\$$   \\$$  \\$$$$$$$       \\$$   \\$$  \\$$$$$$$ \\$$$$$$$  \\$$$$$$$  \\$$    \\$$$$\r\n*\r\n*\r\n*             ╔═╗┌─┐┌─┐┬┌─┐┬┌─┐┬   ┌─────────────────────────┐ ╦ ╦┌─┐┌┐ ╔═╗┬┌┬┐┌─┐ \r\n*             ║ ║├┤ ├┤ ││  │├─┤│   │https://findtherabbit.me │ ║║║├┤ ├┴┐╚═╗│ │ ├┤  \r\n*             ╚═╝└  └  ┴└─┘┴┴ ┴┴─┘ └─┬─────────────────────┬─┘ ╚╩╝└─┘└─┘╚═╝┴ ┴ └─┘      \r\n*/\r\n\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/Messages.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n/**\r\n * EIP712 Ethereum typed structured data hashing and signing\r\n*/\r\ncontract Messages {\r\n    struct AcceptGame {\r\n        uint256 bet;\r\n        bool isHost;\r\n        address opponentAddress;\r\n        bytes32 hashOfMySecret;\r\n        bytes32 hashOfOpponentSecret;\r\n    }\r\n    \r\n    struct SecretData {\r\n        bytes32 salt;\r\n        uint8 secret;\r\n    }\r\n\r\n    /**\r\n     * Domain separator encoding per EIP 712.\r\n     * keccak256(\r\n     *     \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\r\n     * )\r\n     */\r\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n    /**\r\n     * AcceptGame struct type encoding per EIP 712\r\n     * keccak256(\r\n     *     \"AcceptGame(uint256 bet,bool isHost,address opponentAddress,bytes32 hashOfMySecret,bytes32 hashOfOpponentSecret)\"\r\n     * )\r\n     */\r\n    bytes32 private constant ACCEPTGAME_TYPEHASH = 0x5ceee84403c984fbd9fb4ebf11b09c4f28f87290116c8b7f24a3e2a89d26588f;\r\n\r\n    /**\r\n     * Domain separator per EIP 712\r\n     */\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    /**\r\n     * @notice Calculates acceptGameHash according to EIP 712.\r\n     * @param _acceptGame AcceptGame instance to hash.\r\n     * @return bytes32 EIP 712 hash of _acceptGame.\r\n     */\r\n    function _hash(AcceptGame memory _acceptGame) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n            ACCEPTGAME_TYPEHASH,\r\n            _acceptGame.bet,\r\n            _acceptGame.isHost,\r\n            _acceptGame.opponentAddress,\r\n            _acceptGame.hashOfMySecret,\r\n            _acceptGame.hashOfOpponentSecret\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates secretHash according to EIP 712.\r\n     * @param _salt Salt of the gamer.\r\n     * @param _secret Secret of the gamer.\r\n     */\r\n    function _hashOfSecret(bytes32 _salt, uint8 _secret) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_salt, _secret));\r\n    }\r\n\r\n    /**\r\n     * @return the recovered address from the signature\r\n     */\r\n    function _recoverAddress(\r\n        bytes32 messageHash,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address) \r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        bytes1 v;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := mload(add(signature, 0x60))\r\n        }\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            messageHash\r\n        ));\r\n        return ecrecover(digest, uint8(v), r, s);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the gamer signing the AcceptGameMessage\r\n     */\r\n    function _getSignerAddress(\r\n        uint256 _value,\r\n        bool _isHost,\r\n        address _opponentAddress,\r\n        bytes32 _hashOfMySecret,\r\n        bytes32 _hashOfOpponentSecret,\r\n        bytes memory signature\r\n    ) \r\n        internal\r\n        view\r\n        returns (address playerAddress) \r\n    {   \r\n        AcceptGame memory message = AcceptGame({\r\n            bet: _value,\r\n            isHost: _isHost,\r\n            opponentAddress: _opponentAddress,\r\n            hashOfMySecret: _hashOfMySecret,\r\n            hashOfOpponentSecret: _hashOfOpponentSecret\r\n        });\r\n        bytes32 messageHash = _hash(message);\r\n        playerAddress = _recoverAddress(messageHash, signature);\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/Claimable.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner, \"not pending owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(_owner, pendingOwner);\r\n    _owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// File: contracts/lib/ERC20Basic.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n}\r\n\r\n// File: contracts/FindTheRabbit.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FindTheRabbit\r\n * @dev Base game contract\r\n */\r\ncontract FindTheRabbit is Messages, Claimable {\r\n    using SafeMath for uint256;\r\n    enum GameState { \r\n        Invalid, // Default value for a non-created game\r\n        HostBetted, // A player, who initiated an offchain game and made a bet\r\n        JoinBetted, // A player, who joined the game and made a bet\r\n        Filled, // Both players made bets\r\n        DisputeOpenedByHost, // Dispute is opened by the initiating player\r\n        DisputeOpenedByJoin, // Dispute is opened by the joining player\r\n        DisputeWonOnTimeoutByHost, // Dispute is closed on timeout and the prize was taken by the initiating player \r\n        DisputeWonOnTimeoutByJoin, // Dispute is closed on timeout and the prize was taken by the joining player \r\n        CanceledByHost, // The joining player has not made a bet and the game is closed by the initiating player\r\n        CanceledByJoin, // The initiating player has not made a bet and the game is closed by the joining player\r\n        WonByHost, // The initiating has won the game\r\n        WonByJoin // The joining player has won the game\r\n    }\r\n    //Event is triggered after both players have placed their bets\r\n    event GameCreated(\r\n        address indexed host, \r\n        address indexed join, \r\n        uint256 indexed bet, \r\n        bytes32 gameId, \r\n        GameState state\r\n    );\r\n    //Event is triggered after the first bet has been placed\r\n    event GameOpened(bytes32 gameId, address indexed player);\r\n    //Event is triggered after the game has been closed\r\n    event GameCanceled(bytes32 gameId, address indexed player, address indexed opponent);\r\n    /**\r\n     * @dev Event triggered after after opening a dispute\r\n     * @param gameId 32 byte game identifier\r\n     * @param disputeOpener is a player who opened a dispute\r\n     * @param defendant is a player against whom a dispute is opened\r\n     */\r\n    event DisputeOpened(bytes32 gameId, address indexed disputeOpener, address indexed defendant);\r\n    //Event is triggered after a dispute is resolved by the function resolveDispute()\r\n    event DisputeResolved(bytes32 gameId, address indexed player);\r\n    //Event is triggered after a dispute is closed after the amount of time specified in disputeTimer\r\n    event DisputeClosedOnTimeout(bytes32 gameId, address indexed player);\r\n    //Event is triggered after sending the winning to the winner\r\n    event WinnerReward(address indexed winner, uint256 amount);\r\n    //Event is triggered after the jackpot is sent to the winner\r\n    event JackpotReward(bytes32 gameId, address player, uint256 amount);\r\n    //Event is triggered after changing the gameId that claims the jackpot\r\n    event CurrentJackpotGame(bytes32 gameId);\r\n    //Event is triggered after sending the reward to the referrer\r\n    event ReferredReward(address referrer, uint256 amount);\r\n    // Emitted when calimTokens function is invoked.\r\n    event ClaimedTokens(address token, address owner, uint256 amount);\r\n    \r\n    //The address of the contract that will verify the signature per EIP 712.\r\n    //In this case, the current address of the contract.\r\n    address public verifyingContract = address(this);\r\n    //An disambiguating salt for the protocol per EIP 712.\r\n    //Set through the constructor.\r\n    bytes32 public salt;\r\n\r\n    //An address of the creators' account receiving the percentage of Commission for the game\r\n    address payable public teamWallet;\r\n    \r\n    //Percentage of commission from the game that is sent to the creators\r\n    uint256 public commissionPercent;\r\n    \r\n    //Percentage of reward to the player who invited new players\r\n    //0.1% is equal 1\r\n    //0.5% is equal 5\r\n    //1% is equal 10\r\n    //10% is equal 100\r\n    uint256 public referralPercent;\r\n\r\n    //Maximum allowed value of the referralPercent. (10% = 100)\r\n    uint256 public maxReferralPercent = 100;\r\n    \r\n    //Minimum bet value to create a new game\r\n    uint256 public minBet = 0.01 ether; \r\n    \r\n    //Percentage of game commission added to the jackpot value\r\n    uint256 public jackpotPercent;\r\n    \r\n    //Jackpot draw time in UNIX time stamp format.\r\n    uint256 public jackpotDrawTime;\r\n    \r\n    //Current jackpot value\r\n    uint256 public jackpotValue;\r\n    \r\n    //The current value of the gameId of the applicant for the jackpot.\r\n    bytes32 public jackpotGameId;\r\n    \r\n    //Number of seconds added to jackpotDrawTime each time a new game is added to the jackpot.\r\n    uint256 public jackpotGameTimerAddition;\r\n    \r\n    //Initial timeout for a new jackpot round.\r\n    uint256 public jackpotAccumulationTimer;\r\n    \r\n    //Timeout in seconds during which the dispute cannot be opened.\r\n    uint256 public revealTimer;\r\n    \r\n    //Maximum allowed value of the minRevealTimer in seconds. \r\n    uint256 public maxRevealTimer;\r\n    \r\n    //Minimum allowed value of the minRevealTimer in seconds. \r\n    uint256 public minRevealTimer;\r\n    \r\n    //Timeout in seconds during which the dispute cannot be closed \r\n    //and players can call the functions win() and resolveDispute().\r\n    uint256 public disputeTimer; \r\n    \r\n    //Maximum allowed value of the maxDisputeTimer in seconds. \r\n    uint256 public maxDisputeTimer;\r\n    \r\n    //Minimum allowed value of the minDisputeTimer in seconds. \r\n    uint256 public minDisputeTimer; \r\n\r\n    //Timeout in seconds after the first bet \r\n    //during which the second player's bet is expected \r\n    //and the game cannot be closed.\r\n    uint256 public waitingBetTimer;\r\n    \r\n    //Maximum allowed value of the waitingBetTimer in seconds. \r\n    uint256 public maxWaitingBetTimer;\r\n    \r\n    //Minimum allowed value of the waitingBetTimer in seconds. \r\n    uint256 public minWaitingBetTimer;\r\n    \r\n    //The time during which the game must be completed to qualify for the jackpot.\r\n    uint256 public gameDurationForJackpot;\r\n\r\n    uint256 public chainId;\r\n\r\n    //Mapping for storing information about all games\r\n    mapping(bytes32 => Game) public games;\r\n    //Mapping for storing information about all disputes\r\n    mapping(bytes32 => Dispute) public disputes;\r\n    //Mapping for storing information about all players\r\n    mapping(address => Statistics) public players;\r\n\r\n    struct Game {\r\n        uint256 bet; // bet value for the game\r\n        address payable host; // address of the initiating player\r\n        address payable join; // address of the joining player\r\n        uint256 creationTime; // the time of the last bet in the game.\r\n        GameState state; // current state of the game\r\n        bytes hostSignature; // the value of the initiating player's signature\r\n        bytes joinSignature; // the value of the joining player's signature\r\n        bytes32 gameId; // 32 byte game identifier\r\n    }\r\n\r\n    struct Dispute {\r\n        address payable disputeOpener; //  address of the player, who opened the dispute.\r\n        uint256 creationTime; // dispute opening time of the dispute.\r\n        bytes32 opponentHash; // hash from an opponent's secret and salt\r\n        uint256 secret; // secret value of the player, who opened the dispute\r\n        bytes32 salt; // salt value of the player, who opened the dispute\r\n        bool isHost; // true if the player initiated the game.\r\n    }\r\n\r\n    struct Statistics {\r\n        uint256 totalGames; // totalGames played by the player\r\n        uint256 totalUnrevealedGames; // total games that have been disputed against a player for unrevealing the secret on time\r\n        uint256 totalNotFundedGames; // total number of games a player has not send funds on time\r\n        uint256 totalOpenedDisputes; // total number of disputed games created by a player against someone for unrevealing the secret on time\r\n        uint256 avgBetAmount; //  average bet value\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the game state is not Filled. \r\n     */\r\n    modifier isFilled(bytes32 _gameId) {\r\n        require(games[_gameId].state == GameState.Filled, \"game state is not Filled\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the game is not Filled or dispute has not been opened.\r\n     */\r\n    modifier verifyGameState(bytes32 _gameId) {\r\n        require(\r\n            games[_gameId].state == GameState.DisputeOpenedByHost ||\r\n            games[_gameId].state == GameState.DisputeOpenedByJoin || \r\n            games[_gameId].state == GameState.Filled,\r\n            \"game state are not Filled or OpenedDispute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if at least one player has not made a bet.\r\n     */\r\n    modifier isOpen(bytes32 _gameId) {\r\n        require(\r\n            games[_gameId].state == GameState.HostBetted ||\r\n            games[_gameId].state == GameState.JoinBetted,\r\n            \"game state is not Open\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the participant's one in this game.\r\n     */\r\n    modifier onlyParticipant(bytes32 _gameId) {\r\n        require(\r\n            games[_gameId].host == msg.sender || games[_gameId].join == msg.sender,\r\n            \"you are not a participant of this game\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Setting the parameters of the contract.\r\n     * Description of the main parameters can be found above.\r\n     * @param _chainId Id of the current chain.\r\n     * @param _maxValueOfTimer maximum value for revealTimer, disputeTimer and waitingBetTimer.\r\n     * Minimum values are set with revealTimer, disputeTimer, and waitingBetTimer values passed to the constructor.\r\n     */\r\n    constructor (\r\n        uint256 _chainId, \r\n        address payable _teamWallet,\r\n        uint256 _commissionPercent,\r\n        uint256 _jackpotPercent,\r\n        uint256 _referralPercent,\r\n        uint256 _jackpotGameTimerAddition,\r\n        uint256 _jackpotAccumulationTimer,\r\n        uint256 _revealTimer,\r\n        uint256 _disputeTimer,\r\n        uint256 _waitingBetTimer,\r\n        uint256 _gameDurationForJackpot,\r\n        bytes32 _salt,\r\n        uint256 _maxValueOfTimer\r\n    ) public {\r\n        teamWallet = _teamWallet;\r\n        jackpotDrawTime = getTime().add(_jackpotAccumulationTimer);\r\n        jackpotAccumulationTimer = _jackpotAccumulationTimer;\r\n        commissionPercent = _commissionPercent;\r\n        jackpotPercent = _jackpotPercent;\r\n        referralPercent = _referralPercent;\r\n        jackpotGameTimerAddition = _jackpotGameTimerAddition;\r\n        revealTimer = _revealTimer;\r\n        minRevealTimer = _revealTimer;\r\n        maxRevealTimer = _maxValueOfTimer;\r\n        disputeTimer = _disputeTimer;\r\n        minDisputeTimer = _disputeTimer;\r\n        maxDisputeTimer = _maxValueOfTimer;\r\n        waitingBetTimer = _waitingBetTimer;\r\n        minWaitingBetTimer = _waitingBetTimer;\r\n        maxWaitingBetTimer = _maxValueOfTimer;\r\n        gameDurationForJackpot = _gameDurationForJackpot;\r\n        salt = _salt;\r\n        chainId = _chainId;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            keccak256(\"Find The Rabbit\"),\r\n            keccak256(\"0.1\"),\r\n            _chainId,\r\n            verifyingContract,\r\n            salt\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current waitingBetTimer value. \r\n     * Change can be made only within the maximum and minimum values.\r\n     * @param _waitingBetTimer is a new value of waitingBetTimer\r\n     */\r\n    function setWaitingBetTimerValue(uint256 _waitingBetTimer) external onlyOwner {\r\n        require(_waitingBetTimer >= minWaitingBetTimer, \"must be more than minWaitingBetTimer\");\r\n        require(_waitingBetTimer <= maxWaitingBetTimer, \"must be less than maxWaitingBetTimer\");\r\n        waitingBetTimer = _waitingBetTimer;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current disputeTimer value. \r\n     * Change can be made only within the maximum and minimum values.\r\n     * @param _disputeTimer is a new value of disputeTimer.\r\n     */\r\n    function setDisputeTimerValue(uint256 _disputeTimer) external onlyOwner {\r\n        require(_disputeTimer >= minDisputeTimer, \"must be more than minDisputeTimer\");\r\n        require(_disputeTimer <= maxDisputeTimer, \"must be less than maxDisputeTimer\");\r\n        disputeTimer = _disputeTimer;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current revealTimer value. \r\n     * Change can be made only within the maximum and minimum values.\r\n     * @param _revealTimer is a new value of revealTimer\r\n     */\r\n    function setRevealTimerValue(uint256 _revealTimer) external onlyOwner {\r\n        require(_revealTimer >= minRevealTimer, \"must be more than minRevealTimer\");\r\n        require(_revealTimer <= maxRevealTimer, \"must be less than maxRevealTimer\");\r\n        revealTimer = _revealTimer;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current minBet value. \r\n     * @param _newValue is a new value of minBet.\r\n     */\r\n    function setMinBetValue(uint256 _newValue) external onlyOwner {\r\n        require(_newValue != 0, \"must be greater than 0\");\r\n        minBet = _newValue;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current jackpotGameTimerAddition.\r\n     * Change can be made only within the maximum and minimum values.\r\n     * Jackpot should not hold significant value\r\n     * @param _jackpotGameTimerAddition is a new value of jackpotGameTimerAddition\r\n     */\r\n    function setJackpotGameTimerAddition(uint256 _jackpotGameTimerAddition) external onlyOwner {\r\n        if (chainId == 1) {\r\n            // jackpot must be less than 150 DAI. 1 ether = 150 DAI\r\n            require(jackpotValue <= 1 ether);\r\n        }\r\n        if (chainId == 99) {\r\n            // jackpot must be less than 150 DAI. 1 POA = 0.03 DAI\r\n            require(jackpotValue <= 4500 ether);\r\n        }\r\n        require(_jackpotGameTimerAddition >= 2 minutes, \"must be more than 2 minutes\");\r\n        require(_jackpotGameTimerAddition <= 1 hours, \"must be less than 1 hour\");\r\n        jackpotGameTimerAddition = _jackpotGameTimerAddition;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current referralPercent value.\r\n     * Example:\r\n     * 1  = 0.1%\r\n     * 5  = 0.5%\r\n     * 10 = 1%\r\n     * @param _newValue is a new value of referralPercent.\r\n     */\r\n    function setReferralPercentValue(uint256 _newValue) external onlyOwner {\r\n        require(_newValue <= maxReferralPercent, \"must be less than maxReferralPercent\");\r\n        referralPercent = _newValue;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current commissionPercent value.\r\n     * Example:\r\n     * 1  = 1%\r\n     * @param _newValue is a new value of commissionPercent.\r\n     */\r\n    function setCommissionPercent(uint256 _newValue) external onlyOwner {\r\n        require(_newValue <= 20, \"must be less than 20\");\r\n        commissionPercent = _newValue;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current teamWallet address. \r\n     * @param _newTeamWallet is a new teamWallet address.\r\n     */\r\n    function setTeamWalletAddress(address payable _newTeamWallet) external onlyOwner {\r\n        require(_newTeamWallet != address(0));\r\n        teamWallet = _newTeamWallet;\r\n    }\r\n\r\n    /**\r\n     * @return information about the jackpot.\r\n     */\r\n    function getJackpotInfo() \r\n        external \r\n        view \r\n        returns (\r\n            uint256 _jackpotDrawTime, \r\n            uint256 _jackpotValue, \r\n            bytes32 _jackpotGameId\r\n        ) \r\n    {\r\n        _jackpotDrawTime = jackpotDrawTime;\r\n        _jackpotValue = jackpotValue;\r\n        _jackpotGameId = jackpotGameId;\r\n    }\r\n\r\n    /**\r\n     * @return timers used for games.\r\n     */\r\n    function getTimers() \r\n        external\r\n        view \r\n        returns (\r\n            uint256 _revealTimer,\r\n            uint256 _disputeTimer, \r\n            uint256 _waitingBetTimer, \r\n            uint256 _jackpotAccumulationTimer \r\n        )\r\n    {\r\n        _revealTimer = revealTimer;\r\n        _disputeTimer = disputeTimer;\r\n        _waitingBetTimer = waitingBetTimer;\r\n        _jackpotAccumulationTimer = jackpotAccumulationTimer;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer of tokens from the contract  \r\n     * @param _token the address of the tokens to be transferred.\r\n     */\r\n    function claimTokens(address _token) public onlyOwner {\r\n        ERC20Basic erc20token = ERC20Basic(_token);\r\n        uint256 balance = erc20token.balanceOf(address(this));\r\n        erc20token.transfer(owner(), balance);\r\n        emit ClaimedTokens(_token, owner(), balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to create a game and place a bet. \r\n     * @param _isHost True if the sending account initiated the game.\r\n     * @param _hashOfMySecret Hash value of the sending account's secret and salt.\r\n     * @param _hashOfOpponentSecret Hash value of the opponent account's secret and salt.\r\n     * @param _hostSignature Signature of the initiating player from the following values:\r\n     *   bet,\r\n     *   isHost,                 // true\r\n     *   opponentAddress,        // join address\r\n     *   hashOfMySecret,         // hash of host secret\r\n     *   hashOfOpponentSecret    // hash of join secret\r\n     * @param _joinSignature Signature of the joining player from the following values:\r\n     *   bet,\r\n     *   isHost,                 // false\r\n     *   opponentAddress,        // host address\r\n     *   hashOfMySecret,         // hash of join secret\r\n     *   hashOfOpponentSecret    // hash of host secret\r\n     */\r\n    function createGame(\r\n        bool _isHost,\r\n        bytes32 _hashOfMySecret,\r\n        bytes32 _hashOfOpponentSecret,\r\n        bytes memory _hostSignature,\r\n        bytes memory _joinSignature\r\n    )\r\n        public \r\n        payable\r\n    {       \r\n        require(msg.value >= minBet, \"must be greater than the minimum value\");\r\n        bytes32 gameId = getGameId(_hostSignature, _joinSignature);\r\n        address opponent = _getSignerAddress(\r\n            msg.value,\r\n            !_isHost, \r\n            msg.sender,\r\n            _hashOfOpponentSecret, \r\n            _hashOfMySecret,\r\n            _isHost ? _joinSignature : _hostSignature);\r\n        require(opponent != msg.sender, \"send your opponent's signature\");\r\n        Game storage game = games[gameId];\r\n        if (game.gameId == 0){\r\n            _recordGameInfo(msg.value, _isHost, gameId, opponent, _hostSignature, _joinSignature);\r\n            emit GameOpened(game.gameId, msg.sender);\r\n        } else {\r\n            require(game.host == msg.sender || game.join == msg.sender, \"you are not paticipant in this game\");\r\n            require(game.state == GameState.HostBetted || game.state == GameState.JoinBetted, \"the game is not Opened\");\r\n            if (_isHost) {\r\n                require(game.host == msg.sender, \"you are not the host in this game\");\r\n                require(game.join == opponent, \"invalid join signature\");\r\n                require(game.state == GameState.JoinBetted, \"you have already made a bet\");\r\n            } else {\r\n                require(game.join == msg.sender, \"you are not the join in this game.\");\r\n                require(game.host == opponent, \"invalid host signature\");\r\n                require(game.state == GameState.HostBetted, \"you have already made a bet\");\r\n            }\r\n            game.creationTime = getTime();\r\n            game.state = GameState.Filled;\r\n            emit GameCreated(game.host, game.join, game.bet, game.gameId, game.state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev If the disclosure is true, the winner gets a prize. \r\n     * @notice a referrer will be sent a reward to.\r\n     * only if the referrer has previously played the game and the sending account has not.\r\n     * @param _gameId 32 byte game identifier.\r\n     * @param _hostSecret The initiating player's secret.\r\n     * @param _hostSalt The initiating player's salt.\r\n     * @param _joinSecret The joining player's secret.\r\n     * @param _joinSalt The joining player's salt.\r\n     * @param _referrer The winning player's referrer. The referrer must have played games.\r\n     */\r\n    function win(\r\n        bytes32 _gameId,\r\n        uint8 _hostSecret,\r\n        bytes32 _hostSalt,\r\n        uint8 _joinSecret,\r\n        bytes32 _joinSalt,\r\n        address payable _referrer\r\n    ) \r\n        public\r\n        verifyGameState(_gameId)\r\n        onlyParticipant(_gameId)\r\n    {\r\n        Game storage game = games[_gameId];\r\n        bytes32 hashOfHostSecret = _hashOfSecret(_hostSalt, _hostSecret);\r\n        bytes32 hashOfJoinSecret = _hashOfSecret(_joinSalt, _joinSecret);\r\n\r\n        address host = _getSignerAddress(\r\n            game.bet,\r\n            true, \r\n            game.join,\r\n            hashOfHostSecret,\r\n            hashOfJoinSecret, \r\n            game.hostSignature\r\n        );\r\n        address join = _getSignerAddress(\r\n            game.bet,\r\n            false, \r\n            game.host,\r\n            hashOfJoinSecret,\r\n            hashOfHostSecret,\r\n            game.joinSignature\r\n        );\r\n        require(host == game.host && join == game.join, \"invalid reveals\");\r\n        address payable winner;\r\n        if (_hostSecret == _joinSecret){\r\n            winner = game.join;\r\n            game.state = GameState.WonByJoin;\r\n        } else {\r\n            winner = game.host;\r\n            game.state = GameState.WonByHost;\r\n        }\r\n        if (isPlayerExist(_referrer) && _referrer != msg.sender) {\r\n            _processPayments(game.bet, winner, _referrer);\r\n        }\r\n        else {\r\n            _processPayments(game.bet, winner, address(0));\r\n        }\r\n        _jackpotPayoutProcessing(_gameId); \r\n        _recordStatisticInfo(game.host, game.join, game.bet);\r\n    }\r\n\r\n    /**\r\n     * @dev If during the time specified in revealTimer one of the players does not send \r\n     * the secret and salt to the opponent, the player can open a dispute.\r\n     * @param _gameId 32 byte game identifier\r\n     * @param _secret Secret of the player, who opens the dispute.\r\n     * @param _salt Salt of the player, who opens the dispute.\r\n     * @param _isHost True if the sending account initiated the game.\r\n     * @param _hashOfOpponentSecret The hash value of the opponent account's secret and salt.\r\n     */\r\n    function openDispute(\r\n        bytes32 _gameId,\r\n        uint8 _secret,\r\n        bytes32 _salt,\r\n        bool _isHost,\r\n        bytes32 _hashOfOpponentSecret\r\n    )\r\n        public\r\n        onlyParticipant(_gameId)\r\n    {\r\n        require(timeUntilOpenDispute(_gameId) == 0, \"the waiting time for revealing is not over yet\");\r\n        Game storage game = games[_gameId];\r\n        require(isSecretDataValid(\r\n            _gameId,\r\n            _secret,\r\n            _salt,\r\n            _isHost,\r\n            _hashOfOpponentSecret\r\n        ), \"invalid salt or secret\");\r\n        _recordDisputeInfo(_gameId, msg.sender, _hashOfOpponentSecret, _secret, _salt, _isHost);\r\n        game.state = _isHost ? GameState.DisputeOpenedByHost : GameState.DisputeOpenedByJoin;\r\n        address defendant = _isHost ? game.join : game.host;\r\n        players[msg.sender].totalOpenedDisputes = (players[msg.sender].totalOpenedDisputes).add(1);\r\n        players[defendant].totalUnrevealedGames = (players[defendant].totalUnrevealedGames).add(1);\r\n        emit DisputeOpened(_gameId, msg.sender, defendant);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the accused player to make a secret disclosure \r\n     * and pick up the winnings in case of victory.\r\n     * @param _gameId 32 byte game identifier.\r\n     * @param _secret An accused player's secret.\r\n     * @param _salt An accused player's salt.\r\n     * @param _isHost True if the sending account initiated the game.\r\n     * @param _hashOfOpponentSecret The hash value of the opponent account's secret and salt.\r\n     */\r\n    function resolveDispute(\r\n        bytes32 _gameId,\r\n        uint8 _secret,\r\n        bytes32 _salt,\r\n        bool _isHost,\r\n        bytes32 _hashOfOpponentSecret\r\n    ) \r\n        public\r\n        returns(address payable winner)\r\n    {\r\n        require(isDisputeOpened(_gameId), \"there is no dispute\");\r\n        Game storage game = games[_gameId];\r\n        Dispute memory dispute = disputes[_gameId];\r\n        require(msg.sender != dispute.disputeOpener, \"only for the opponent\");\r\n        require(isSecretDataValid(\r\n            _gameId,\r\n            _secret,\r\n            _salt,\r\n            _isHost,\r\n            _hashOfOpponentSecret\r\n        ), \"invalid salt or secret\");\r\n        if (_secret == dispute.secret) {\r\n            winner = game.join;\r\n            game.state = GameState.WonByJoin;\r\n        } else {\r\n            winner = game.host;\r\n            game.state = GameState.WonByHost;\r\n        }\r\n        _processPayments(game.bet, winner, address(0));\r\n        _jackpotPayoutProcessing(_gameId);\r\n        _recordStatisticInfo(game.host, game.join, game.bet);\r\n        emit DisputeResolved(_gameId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev If during the time specified in disputeTimer the accused player does not manage to resolve a dispute\r\n     * the player, who has opened the dispute, can close the dispute and get the win.\r\n     * @param _gameId 32 byte game identifier.\r\n     * @return address of the winning player.\r\n     */\r\n    function closeDisputeOnTimeout(bytes32 _gameId) public returns (address payable winner) {\r\n        Game storage game = games[_gameId];\r\n        Dispute memory dispute = disputes[_gameId];\r\n        require(timeUntilCloseDispute(_gameId) == 0, \"the time has not yet come out\");\r\n        winner = dispute.disputeOpener;\r\n        game.state = (winner == game.host) ? GameState.DisputeWonOnTimeoutByHost : GameState.DisputeWonOnTimeoutByJoin;\r\n        _processPayments(game.bet, winner, address(0));\r\n        _jackpotPayoutProcessing(_gameId);\r\n        _recordStatisticInfo(game.host, game.join, game.bet);\r\n        emit DisputeClosedOnTimeout(_gameId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev If one of the player made a bet and during the time specified in waitingBetTimer\r\n     * the opponent does not make a bet too, the player can take his bet back.\r\n     * @param _gameId 32 byte game identifier.\r\n     */\r\n    function cancelGame(\r\n        bytes32 _gameId\r\n    ) \r\n        public\r\n        onlyParticipant(_gameId) \r\n    {\r\n        require(timeUntilCancel(_gameId) == 0, \"the waiting time for the second player's bet is not over yet\");\r\n        Game storage game = games[_gameId];\r\n        address payable recipient;\r\n        recipient = game.state == GameState.HostBetted ? game.host : game.join;\r\n        address defendant = game.state == GameState.HostBetted ? game.join : game.host;\r\n        game.state = (recipient == game.host) ? GameState.CanceledByHost : GameState.CanceledByJoin;\r\n        recipient.transfer(game.bet);\r\n        players[defendant].totalNotFundedGames = (players[defendant].totalNotFundedGames).add(1);\r\n        emit GameCanceled(_gameId, msg.sender, defendant);\r\n    }\r\n\r\n    /**\r\n     * @dev Jackpot draw if the time has come and there is a winner.\r\n     */\r\n    function drawJackpot() public {\r\n        require(isJackpotAvailable(), \"is not avaliable yet\");\r\n        require(jackpotGameId != 0, \"no game to claim on the jackpot\");\r\n        require(jackpotValue != 0, \"jackpot's empty\");\r\n        _payoutJackpot();\r\n    }\r\n\r\n    /**\r\n     * @return true if there is open dispute for given `_gameId`\r\n     */\r\n    function isDisputeOpened(bytes32 _gameId) public view returns(bool) {\r\n        return (\r\n            games[_gameId].state == GameState.DisputeOpenedByHost ||\r\n            games[_gameId].state == GameState.DisputeOpenedByJoin\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @return true if a player played at least one game and did not Cancel it.\r\n     */\r\n    function isPlayerExist(address _player) public view returns (bool) {\r\n        return players[_player].totalGames != 0;\r\n    }\r\n\r\n    /**\r\n     * @return the time after which a player can close the game.\r\n     * @param _gameId 32 byte game identifier.\r\n     */\r\n    function timeUntilCancel(\r\n        bytes32 _gameId\r\n    )\r\n        public\r\n        view \r\n        isOpen(_gameId) \r\n        returns (uint256 remainingTime) \r\n    {\r\n        uint256 timePassed = getTime().sub(games[_gameId].creationTime);\r\n        if (waitingBetTimer > timePassed) {\r\n            return waitingBetTimer.sub(timePassed);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the time after which a player can open the dispute.\r\n     * @param _gameId 32 byte game identifier.\r\n     */\r\n    function timeUntilOpenDispute(\r\n        bytes32 _gameId\r\n    )\r\n        public\r\n        view \r\n        isFilled(_gameId) \r\n        returns (uint256 remainingTime) \r\n    {\r\n        uint256 timePassed = getTime().sub(games[_gameId].creationTime);\r\n        if (revealTimer > timePassed) {\r\n            return revealTimer.sub(timePassed);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the time after which a player can close the dispute opened by him.\r\n     * @param _gameId 32 byte game identifier.\r\n     */\r\n    function timeUntilCloseDispute(\r\n        bytes32 _gameId\r\n    )\r\n        public\r\n        view \r\n        returns (uint256 remainingTime) \r\n    {\r\n        require(isDisputeOpened(_gameId), \"there is no open dispute\");\r\n        uint256 timePassed = getTime().sub(disputes[_gameId].creationTime);\r\n        if (disputeTimer > timePassed) {\r\n            return disputeTimer.sub(timePassed);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the current time in UNIX timestamp format. \r\n     */\r\n    function getTime() public view returns(uint) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @return the current game state.\r\n     * @param _gameId 32 byte game identifier\r\n     */\r\n    function getGameState(bytes32 _gameId) public view returns(GameState) {\r\n        return games[_gameId].state;\r\n    }\r\n\r\n    /**\r\n     * @return true if the sent secret and salt match the genuine ones.\r\n     * @param _gameId 32 byte game identifier.\r\n     * @param _secret A player's secret.\r\n     * @param _salt A player's salt.\r\n     * @param _isHost True if the sending account initiated the game.\r\n     * @param _hashOfOpponentSecret The hash value of the opponent account's secret and salt.\r\n     */\r\n    function isSecretDataValid(\r\n        bytes32 _gameId,\r\n        uint8 _secret,\r\n        bytes32 _salt,\r\n        bool _isHost,\r\n        bytes32 _hashOfOpponentSecret\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Game memory game = games[_gameId];\r\n        bytes32 hashOfPlayerSecret = _hashOfSecret(_salt, _secret);\r\n        address player = _getSignerAddress(\r\n            game.bet,\r\n            _isHost, \r\n            _isHost ? game.join : game.host,\r\n            hashOfPlayerSecret,\r\n            _hashOfOpponentSecret, \r\n            _isHost ? game.hostSignature : game.joinSignature\r\n        );\r\n        require(msg.sender == player, \"the received address does not match with msg.sender\");\r\n        if (_isHost) {\r\n            return player == game.host;\r\n        } else {\r\n            return player == game.join;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return true if the jackpotDrawTime has come.\r\n     */\r\n    function isJackpotAvailable() public view returns (bool) {\r\n        return getTime() >= jackpotDrawTime;\r\n    }\r\n\r\n    function isGameAllowedForJackpot(bytes32 _gameId) public view returns (bool) {\r\n        return getTime() - games[_gameId].creationTime < gameDurationForJackpot;\r\n    }\r\n\r\n    /**\r\n     * @return an array of statuses for the listed games.\r\n     * @param _games array of games identifier.\r\n     */\r\n    function getGamesStates(bytes32[] memory _games) public view returns(GameState[] memory) {\r\n        GameState[] memory _states = new GameState[](_games.length);\r\n        for (uint i=0; i<_games.length; i++) {\r\n            Game storage game = games[_games[i]];\r\n            _states[i] = game.state;\r\n        }\r\n        return _states;\r\n    }\r\n\r\n    /**\r\n     * @return an array of Statistics for the listed players.\r\n     * @param _players array of players' addresses.\r\n     */\r\n    function getPlayersStatistic(address[] memory _players) public view returns(uint[] memory) {\r\n        uint[] memory _statistics = new uint[](_players.length * 5);\r\n        for (uint i=0; i<_players.length; i++) {\r\n            Statistics storage player = players[_players[i]];\r\n            _statistics[5*i + 0] = player.totalGames;\r\n            _statistics[5*i + 1] = player.totalUnrevealedGames;\r\n            _statistics[5*i + 2] = player.totalNotFundedGames;\r\n            _statistics[5*i + 3] = player.totalOpenedDisputes;\r\n            _statistics[5*i + 4] = player.avgBetAmount;\r\n        }\r\n        return _statistics;\r\n    }\r\n\r\n    /**\r\n     * @return GameId generated for current values of the signatures.\r\n     * @param _signatureHost Signature of the initiating player.\r\n     * @param _signatureJoin Signature of the joining player.\r\n     */\r\n    function getGameId(bytes memory _signatureHost, bytes memory _signatureJoin) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_signatureHost, _signatureJoin));\r\n    }\r\n\r\n    /**\r\n     * @dev jackpot draw.\r\n     */\r\n    function _payoutJackpot() internal {\r\n        Game storage jackpotGame = games[jackpotGameId];\r\n        uint256 reward = jackpotValue.div(2);\r\n        jackpotValue = 0;\r\n        jackpotGameId = 0;\r\n        jackpotDrawTime = (getTime()).add(jackpotAccumulationTimer);\r\n        if (jackpotGame.host.send(reward)) {\r\n            emit JackpotReward(jackpotGame.gameId, jackpotGame.host, reward.mul(2));\r\n        }\r\n        if (jackpotGame.join.send(reward)) {\r\n            emit JackpotReward(jackpotGame.gameId, jackpotGame.join, reward.mul(2));\r\n        }\r\n    }\r\n    /**\r\n     * @dev adds the completed game to the jackpot draw.\r\n     * @param _gameId 32 byte game identifier.\r\n     */ \r\n    function _addGameToJackpot(bytes32 _gameId) internal {\r\n        jackpotDrawTime = jackpotDrawTime.add(jackpotGameTimerAddition);\r\n        jackpotGameId = _gameId;\r\n        emit CurrentJackpotGame(_gameId);\r\n    }\r\n\r\n    /**\r\n     * @dev update jackpot info.\r\n     * @param _gameId 32 byte game identifier.\r\n     */ \r\n    function _jackpotPayoutProcessing(bytes32 _gameId) internal {\r\n        if (isJackpotAvailable()) {\r\n            if (jackpotGameId != 0 && jackpotValue != 0) {\r\n                _payoutJackpot();\r\n            }\r\n            else {\r\n                jackpotDrawTime = (getTime()).add(jackpotAccumulationTimer);\r\n            }\r\n        }\r\n        if (isGameAllowedForJackpot(_gameId)) {\r\n            _addGameToJackpot(_gameId);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev take a commission to the creators, reward to referrer, and commission for the jackpot from the winning amount.\r\n     * Sending prize to winner.\r\n     * @param _bet bet in the current game.\r\n     * @param _winner the winner's address.\r\n     * @param _referrer the referrer's address.\r\n     */ \r\n    function _processPayments(uint256 _bet, address payable _winner, address payable _referrer) internal {\r\n        uint256 doubleBet = (_bet).mul(2);\r\n        uint256 commission = (doubleBet.mul(commissionPercent)).div(100);        \r\n        uint256 jackpotPart = (doubleBet.mul(jackpotPercent)).div(100);\r\n        uint256 winnerStake;\r\n        if (_referrer != address(0) && referralPercent != 0 ) {\r\n            uint256 referrerPart = (doubleBet.mul(referralPercent)).div(1000);\r\n            winnerStake = doubleBet.sub(commission).sub(jackpotPart).sub(referrerPart);\r\n            if (_referrer.send(referrerPart)) {\r\n                emit ReferredReward(_referrer, referrerPart);\r\n            }\r\n        }\r\n        else {\r\n            winnerStake = doubleBet.sub(commission).sub(jackpotPart);\r\n        }\r\n        jackpotValue = jackpotValue.add(jackpotPart);\r\n        _winner.transfer(winnerStake);\r\n        teamWallet.transfer(commission);\r\n        emit WinnerReward(_winner, winnerStake);\r\n    }\r\n\r\n    /**\r\n     * @dev filling in the \"Game\" structure.\r\n     */ \r\n    function _recordGameInfo(\r\n        uint256 _value,\r\n        bool _isHost, \r\n        bytes32 _gameId, \r\n        address _opponent,\r\n        bytes memory _hostSignature,\r\n        bytes memory _joinSignature\r\n    ) internal {\r\n        Game memory _game = Game({\r\n            bet: _value,\r\n            host: _isHost ? msg.sender : address(uint160(_opponent)),\r\n            join: _isHost ? address(uint160(_opponent)) : msg.sender,\r\n            creationTime: getTime(),\r\n            state: _isHost ? GameState.HostBetted : GameState.JoinBetted ,\r\n            gameId: _gameId,\r\n            hostSignature: _hostSignature,\r\n            joinSignature: _joinSignature\r\n        });\r\n        games[_gameId] = _game;  \r\n    }\r\n\r\n    /**\r\n     * @dev filling in the \"Dispute\" structure.\r\n     */ \r\n    function _recordDisputeInfo(\r\n        bytes32 _gameId,\r\n        address payable _disputeOpener,\r\n        bytes32 _hashOfOpponentSecret,\r\n        uint8 _secret,\r\n        bytes32 _salt,\r\n        bool _isHost \r\n    ) internal {\r\n        Dispute memory _dispute = Dispute({\r\n            disputeOpener: _disputeOpener,\r\n            creationTime: getTime(),\r\n            opponentHash: _hashOfOpponentSecret,\r\n            secret: _secret,\r\n            salt: _salt,\r\n            isHost: _isHost\r\n        });\r\n        disputes[_gameId] = _dispute;\r\n    }\r\n\r\n    /**\r\n     * @dev filling in the \"Statistics\" structure.\r\n     */ \r\n    function _recordStatisticInfo(address _host, address _join, uint256 _bet) internal {\r\n        Statistics storage statHost = players[_host];\r\n        Statistics storage statJoin = players[_join];\r\n        statHost.avgBetAmount = _calculateAvgBet(_host, _bet);\r\n        statJoin.avgBetAmount = _calculateAvgBet(_join, _bet);\r\n        statHost.totalGames = (statHost.totalGames).add(1);\r\n        statJoin.totalGames = (statJoin.totalGames).add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev recalculation of an average bet value for a player.\r\n     * @param _player the address of the player.\r\n     * @param _bet bet from the last played game.\r\n     */ \r\n    function _calculateAvgBet(address _player, uint256 _bet) internal view returns (uint256 newAvgBetValue){\r\n        Statistics storage statistics = players[_player];\r\n        uint256 totalBets = (statistics.avgBetAmount).mul(statistics.totalGames).add(_bet);\r\n        newAvgBetValue = totalBets.div(statistics.totalGames.add(1));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"timeUntilOpenDispute\",\"outputs\":[{\"name\":\"remainingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotAccumulationTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_players\",\"type\":\"address[]\"}],\"name\":\"getPlayersStatistic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJackpotInfo\",\"outputs\":[{\"name\":\"_jackpotDrawTime\",\"type\":\"uint256\"},{\"name\":\"_jackpotValue\",\"type\":\"uint256\"},{\"name\":\"_jackpotGameId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"closeDisputeOnTimeout\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputes\",\"outputs\":[{\"name\":\"disputeOpener\",\"type\":\"address\"},{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"opponentHash\",\"type\":\"bytes32\"},{\"name\":\"secret\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"isHost\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameDurationForJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTeamWallet\",\"type\":\"address\"}],\"name\":\"setTeamWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_waitingBetTimer\",\"type\":\"uint256\"}],\"name\":\"setWaitingBetTimerValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"cancelGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"setCommissionPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxReferralPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"isPlayerExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRevealTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"uint8\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"_isHost\",\"type\":\"bool\"},{\"name\":\"_hashOfOpponentSecret\",\"type\":\"bytes32\"}],\"name\":\"resolveDispute\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disputeTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"setMinBetValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRevealTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimers\",\"outputs\":[{\"name\":\"_revealTimer\",\"type\":\"uint256\"},{\"name\":\"_disputeTimer\",\"type\":\"uint256\"},{\"name\":\"_waitingBetTimer\",\"type\":\"uint256\"},{\"name\":\"_jackpotAccumulationTimer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revealTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDisputeTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"uint8\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"_isHost\",\"type\":\"bool\"},{\"name\":\"_hashOfOpponentSecret\",\"type\":\"bytes32\"}],\"name\":\"isSecretDataValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isJackpotAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"timeUntilCancel\",\"outputs\":[{\"name\":\"remainingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_revealTimer\",\"type\":\"uint256\"}],\"name\":\"setRevealTimerValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingBetTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_games\",\"type\":\"bytes32[]\"}],\"name\":\"getGamesStates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"},{\"name\":\"_hostSecret\",\"type\":\"uint8\"},{\"name\":\"_hostSalt\",\"type\":\"bytes32\"},{\"name\":\"_joinSecret\",\"type\":\"uint8\"},{\"name\":\"_joinSalt\",\"type\":\"bytes32\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"win\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotGameTimerAddition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drawJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signatureHost\",\"type\":\"bytes\"},{\"name\":\"_signatureJoin\",\"type\":\"bytes\"}],\"name\":\"getGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"isGameAllowedForJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifyingContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"uint8\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"_isHost\",\"type\":\"bool\"},{\"name\":\"_hashOfOpponentSecret\",\"type\":\"bytes32\"}],\"name\":\"openDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"setReferralPercentValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDisputeTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"isDisputeOpened\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpotGameTimerAddition\",\"type\":\"uint256\"}],\"name\":\"setJackpotGameTimerAddition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeTimer\",\"type\":\"uint256\"}],\"name\":\"setDisputeTimerValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salt\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"getGameState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isHost\",\"type\":\"bool\"},{\"name\":\"_hashOfMySecret\",\"type\":\"bytes32\"},{\"name\":\"_hashOfOpponentSecret\",\"type\":\"bytes32\"},{\"name\":\"_hostSignature\",\"type\":\"bytes\"},{\"name\":\"_joinSignature\",\"type\":\"bytes\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxWaitingBetTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"totalGames\",\"type\":\"uint256\"},{\"name\":\"totalUnrevealedGames\",\"type\":\"uint256\"},{\"name\":\"totalNotFundedGames\",\"type\":\"uint256\"},{\"name\":\"totalOpenedDisputes\",\"type\":\"uint256\"},{\"name\":\"avgBetAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minWaitingBetTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"bytes32\"}],\"name\":\"timeUntilCloseDispute\",\"outputs\":[{\"name\":\"remainingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"bet\",\"type\":\"uint256\"},{\"name\":\"host\",\"type\":\"address\"},{\"name\":\"join\",\"type\":\"address\"},{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"hostSignature\",\"type\":\"bytes\"},{\"name\":\"joinSignature\",\"type\":\"bytes\"},{\"name\":\"gameId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotDrawTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_chainId\",\"type\":\"uint256\"},{\"name\":\"_teamWallet\",\"type\":\"address\"},{\"name\":\"_commissionPercent\",\"type\":\"uint256\"},{\"name\":\"_jackpotPercent\",\"type\":\"uint256\"},{\"name\":\"_referralPercent\",\"type\":\"uint256\"},{\"name\":\"_jackpotGameTimerAddition\",\"type\":\"uint256\"},{\"name\":\"_jackpotAccumulationTimer\",\"type\":\"uint256\"},{\"name\":\"_revealTimer\",\"type\":\"uint256\"},{\"name\":\"_disputeTimer\",\"type\":\"uint256\"},{\"name\":\"_waitingBetTimer\",\"type\":\"uint256\"},{\"name\":\"_gameDurationForJackpot\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"_maxValueOfTimer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"host\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"join\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"GameOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"opponent\",\"type\":\"address\"}],\"name\":\"GameCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"disputeOpener\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"defendant\",\"type\":\"address\"}],\"name\":\"DisputeOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"DisputeClosedOnTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WinnerReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"bytes32\"}],\"name\":\"CurrentJackpotGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferredReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FindTheRabbit","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000081c2c604c4efdddb57bd0b2b5476dd571b0e529a00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000001baf800000000000000000000000000000000000000000000000000000000000000078000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000000b400000000000000000000000000000000000000000000000000000000000007082d387f4d72163f6d1c5679cc2c68d732142a69a7e30895654bbcae92cba153050000000000000000000000000000000000000000000000000000000000015180","Library":"","SwarmSource":"bzzr://7c3bba051cb0358782a0bc80a588df57df2d8db077d96955e5c5fef203966570"}]}