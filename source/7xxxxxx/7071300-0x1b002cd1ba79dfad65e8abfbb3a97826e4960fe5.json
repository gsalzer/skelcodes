{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*\r\n* CryptoMiningWar - Blockchain-based strategy game\r\n* Author: InspiGames\r\n* Website: https://cryptominingwar.github.io/\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send or transfer.\r\n */\r\ncontract PullPayment {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n  * @dev Withdraw accumulated balance, called by payee.\r\n  */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(address(this).balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    payee.transfer(payment);\r\n  }\r\n\r\n  /**\r\n  * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n  * @param dest The destination address of the funds.\r\n  * @param amount The amount to transfer.\r\n  */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n}\r\ninterface MiniGameInterface {\r\n     function setupMiniGame(uint256 _miningWarRoundNumber, uint256 _miningWarDeadline) external;\r\n     function isContractMiniGame() external pure returns( bool _isContractMiniGame );\r\n}\r\ncontract CryptoEngineerInterface {\r\n    address public gameSponsor;\r\n    function isEngineerContract() external pure returns(bool) {}\r\n    function isContractMiniGame() external pure returns( bool /*_isContractMiniGame*/ ) {}\r\n}\r\n\r\n\r\ncontract CryptoMiningWar is PullPayment {\r\n    bool public initialized = false;\r\n    uint256 public roundNumber = 0;\r\n    uint256 public deadline;\r\n    uint256 public CRTSTAL_MINING_PERIOD = 86400; \r\n    uint256 public HALF_TIME = 8 hours;\r\n    uint256 public ROUND_TIME = 86400 * 7;\r\n\tuint256 public prizePool = 0;\r\n    uint256 BASE_PRICE = 0.005 ether;\r\n    uint256 RANK_LIST_LIMIT = 10000;\r\n    uint256 public totalMiniGame = 0;\r\n\r\n    uint256 private numberOfMiners = 8;\r\n    uint256 private numberOfBoosts = 5;\r\n    uint256 private numberOfRank   = 21;\r\n    \r\n    CryptoEngineerInterface  public Engineer;\r\n    \r\n    mapping(uint256 => address) public miniGameAddress;\r\n    //miner info\r\n    mapping(uint256 => MinerData) private minerData;\r\n    \r\n    // plyer info\r\n    mapping(address => Player) public players;\r\n    mapping(address => uint256) public boosterReward;\r\n    //booster info\r\n    mapping(uint256 => BoostData) private boostData;\r\n    //mini game contract info\r\n    mapping(address => bool) public miniGames;   \r\n    \r\n    \r\n    address[21] rankList;\r\n    address public administrator;\r\n    /*** DATATYPES ***/\r\n    struct Player {\r\n        uint256 roundNumber;\r\n        mapping(uint256 => uint256) minerCount;\r\n        uint256 hashrate;\r\n        uint256 crystals;\r\n        uint256 lastUpdateTime;\r\n    }\r\n    struct MinerData {\r\n        uint256 basePrice;\r\n        uint256 baseProduct;\r\n        uint256 limit;\r\n    }\r\n    struct BoostData {\r\n        address owner;\r\n        uint256 boostRate;\r\n        uint256 startingLevel;\r\n        uint256 startingTime;\r\n        uint256 halfLife;\r\n    }\r\n    modifier isNotOver() \r\n    {\r\n        require(now <= deadline);\r\n        _;\r\n    }\r\n    modifier disableContract()\r\n    {\r\n        require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n    modifier isCurrentRound(address _addr) \r\n    {\r\n        require(players[_addr].roundNumber == roundNumber);\r\n        _;\r\n    }\r\n    modifier isAdministrator()\r\n    {\r\n        require(msg.sender == administrator);\r\n        _;\r\n    }\r\n    modifier onlyContractsMiniGame() \r\n    {\r\n        require(miniGames[msg.sender] == true);\r\n        _;\r\n    }\r\n    event GetFreeMiner(address _addr, uint256 _miningWarRound, uint256 _deadline);\r\n    event BuyMiner(address _addr, uint256[8] minerNumbers, uint256 _crystalsPrice, uint256 _hashrateBuy, uint256 _miningWarRound);\r\n    event ChangeHasrate(address _addr, uint256 _hashrate, uint256 _miningWarRound);\r\n    event ChangeCrystal(address _addr, uint256 _crystal, uint256 _type, uint256 _miningWarRound); //_type: 1 add crystal , 2: sub crystal\r\n    event BuyBooster(address _addr, uint256 _miningWarRound, uint256 _boosterId, uint256 _price, address beneficiary, uint256 refundPrize);\r\n    event Lottery(address[10] _topAddr, uint256[10] _reward, uint256 _miningWarRound);\r\n    event WithdrawReward(address _addr, uint256 _reward);\r\n    constructor() public {\r\n        administrator = msg.sender;\r\n        initMinerData();\r\n    }\r\n    function initMinerData() private \r\n    {\r\n         //                      price,          prod.     limit\r\n        minerData[0] = MinerData(10,            10,         10);   //lv1\r\n        minerData[1] = MinerData(100,           200,        2);    //lv2\r\n        minerData[2] = MinerData(400,           800,        4);    //lv3\r\n        minerData[3] = MinerData(1600,          3200,       8);    //lv4 \r\n        minerData[4] = MinerData(6400,          9600,       16);   //lv5 \r\n        minerData[5] = MinerData(25600,         38400,      32);   //lv6 \r\n        minerData[6] = MinerData(204800,        204800,     64);   //lv7 \r\n        minerData[7] = MinerData(1638400,       819200,     65536); //lv8   \r\n    }\r\n    function () public payable\r\n    {\r\n\t\tprizePool = SafeMath.add(prizePool, msg.value);\r\n    }\r\n\r\n    function isMiningWarContract() public pure returns(bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function startGame() public isAdministrator\r\n    {\r\n        require(!initialized);\r\n        \r\n        startNewRound();\r\n        initialized = true;\r\n    }\r\n    function addMiner(address _addr, uint256 idx, uint256 _value) public isNotOver isCurrentRound(_addr) isAdministrator\r\n    {\r\n        require(idx < numberOfMiners);\r\n        require(_value != 0);\r\n\r\n        Player storage p = players[_addr];\r\n        MinerData memory m = minerData[idx];\r\n\r\n        if (SafeMath.add(p.minerCount[idx], _value) > m.limit) revert();\r\n\r\n        updateCrystal( _addr );\r\n\r\n        p.minerCount[idx] = SafeMath.add(p.minerCount[idx], _value);\r\n\r\n        updateHashrate(_addr, SafeMath.mul(_value, m.baseProduct));\r\n    }\r\n    /**\r\n    * @dev add crystals to a player\r\n    * msg.sender should be in the list of mini game\r\n    * @param _addr player address \r\n    */\r\n    function addCrystal( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)\r\n    {\r\n        uint256 crystals = SafeMath.mul(_value, CRTSTAL_MINING_PERIOD);\r\n        Player storage p = players[_addr];\r\n        p.crystals =  SafeMath.add( p.crystals, crystals ); \r\n\r\n        emit ChangeCrystal(_addr, _value, 1, roundNumber);\r\n    }\r\n    /**\r\n    * @dev sub player's crystals\r\n    * msg.sender should be in the list of mini game\r\n    * @param _addr player address\r\n    */\r\n    function subCrystal( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)\r\n    {\r\n        updateCrystal( _addr );\r\n        uint256 crystals = SafeMath.mul(_value,CRTSTAL_MINING_PERIOD);\r\n        require(crystals <= players[_addr].crystals);\r\n\r\n        Player storage p = players[_addr];\r\n        p.crystals =  SafeMath.sub( p.crystals, crystals ); \r\n\r\n         emit ChangeCrystal(_addr, _value, 2, roundNumber);\r\n    }\r\n    /**\r\n    * @dev add hashrate to a player.\r\n    * msg.sender should be in the list of mini game\r\n    */\r\n    function addHashrate( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)\r\n    {\r\n        Player storage p = players[_addr];\r\n        p.hashrate =  SafeMath.add( p.hashrate, _value );\r\n\r\n        emit ChangeHasrate(_addr, p.hashrate, roundNumber); \r\n    }\r\n    /**\r\n    * @dev sub player's hashrate\r\n    * msg.sender should be in the list of mini game\r\n    */\r\n    function subHashrate( address _addr, uint256 _value ) public onlyContractsMiniGame isNotOver isCurrentRound(_addr)\r\n    {\r\n        require(players[_addr].hashrate >= _value);\r\n\r\n        Player storage p = players[_addr];\r\n        \r\n        p.hashrate = SafeMath.sub( p.hashrate, _value ); \r\n\r\n        emit ChangeHasrate(_addr, p.hashrate, roundNumber);\r\n    }\r\n    function setEngineerInterface(address _addr) public isAdministrator\r\n    {\r\n        CryptoEngineerInterface engineerInterface = CryptoEngineerInterface(_addr);\r\n        \r\n        require(engineerInterface.isEngineerContract() == true);\r\n\r\n        Engineer = engineerInterface;\r\n    }   \r\n    function setRoundNumber(uint256 _value) public isAdministrator\r\n    {\r\n        roundNumber = _value;\r\n    } \r\n    function setContractsMiniGame( address _addr ) public  isAdministrator\r\n    {\r\n        require(miniGames[_addr] == false);\r\n        MiniGameInterface MiniGame = MiniGameInterface( _addr );\r\n        require(MiniGame.isContractMiniGame() == true );\r\n\r\n        miniGames[_addr] = true;\r\n        miniGameAddress[totalMiniGame] = _addr;\r\n        totalMiniGame = totalMiniGame + 1;\r\n    }\r\n    /**\r\n    * @dev remove mini game contract from main contract\r\n    * @param _addr mini game contract address\r\n    */\r\n    function removeContractMiniGame(address _addr) public isAdministrator\r\n    {\r\n        miniGames[_addr] = false;\r\n    }\r\n\r\n    function startNewRound() private \r\n    {\r\n        deadline = SafeMath.add(now, ROUND_TIME);\r\n        roundNumber = SafeMath.add(roundNumber, 1);\r\n        initBoostData();\r\n        setupMiniGame();\r\n    }\r\n    function setupMiniGame() private \r\n    {\r\n        for ( uint256 index = 0; index < totalMiniGame; index++ ) {\r\n            if (miniGames[miniGameAddress[index]] == true) {\r\n                MiniGameInterface MiniGame = MiniGameInterface( miniGameAddress[index] );\r\n                MiniGame.setupMiniGame(roundNumber,deadline);\r\n            }   \r\n        }\r\n    }\r\n    function initBoostData() private\r\n    {\r\n        //init booster data\r\n        boostData[0] = BoostData(0, 150, 1, now, HALF_TIME);\r\n        boostData[1] = BoostData(0, 175, 1, now, HALF_TIME);\r\n        boostData[2] = BoostData(0, 200, 1, now, HALF_TIME);\r\n        boostData[3] = BoostData(0, 225, 1, now, HALF_TIME);\r\n        boostData[4] = BoostData(msg.sender, 250, 2, now, HALF_TIME);\r\n        for (uint256 idx = 0; idx < numberOfRank; idx++) {\r\n            rankList[idx] = 0;\r\n        }\r\n    }\r\n    function lottery() public disableContract\r\n    {\r\n        require(now > deadline);\r\n        uint256 balance = SafeMath.div(SafeMath.mul(prizePool, 90), 100);\r\n\t\tuint256 devFee = SafeMath.div(SafeMath.mul(prizePool, 5), 100);\r\n        administrator.transfer(devFee);\r\n        uint8[10] memory profit = [30,20,10,8,7,5,5,5,5,5];\r\n\t\tuint256 totalPayment = 0;\r\n\t\tuint256 rankPayment = 0;\r\n        address[10] memory _topAddr;\r\n        uint256[10] memory _reward;\r\n        for(uint256 idx = 0; idx < 10; idx++){\r\n            if(rankList[idx] != 0){\r\n\r\n\t\t\t\trankPayment = SafeMath.div(SafeMath.mul(balance, profit[idx]),100);\r\n\t\t\t\tasyncSend(rankList[idx], rankPayment);\r\n\t\t\t\ttotalPayment = SafeMath.add(totalPayment, rankPayment);\r\n\r\n                _topAddr[idx] = rankList[idx];\r\n                _reward[idx] = rankPayment;\r\n            }\r\n        }\r\n\t\tprizePool = SafeMath.add(devFee, SafeMath.sub(balance, totalPayment));\r\n        \r\n        emit Lottery(_topAddr, _reward, roundNumber);\r\n\r\n        startNewRound();\r\n    }\r\n    function getRankList() public view returns(address[21])\r\n    {\r\n        return rankList;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Miner \r\n    //--------------------------------------------------------------------------\r\n    /**\r\n    * @dev get a free miner\r\n    */\r\n    function getFreeMiner(address _addr) public isNotOver disableContract\r\n    {\r\n        require(msg.sender == _addr);\r\n        require(players[_addr].roundNumber != roundNumber);\r\n        Player storage p = players[_addr];\r\n        //reset player data\r\n        if(p.hashrate > 0){\r\n            for (uint idx = 1; idx < numberOfMiners; idx++) {\r\n                p.minerCount[idx] = 0;\r\n            }\r\n        }\r\n        MinerData storage m0 = minerData[0];\r\n        p.crystals = 0;\r\n        p.roundNumber = roundNumber;\r\n        //free miner\r\n        p.lastUpdateTime = now;\r\n        p.minerCount[0] = 1;\r\n        p.hashrate = m0.baseProduct;\r\n\r\n        emit GetFreeMiner(_addr, roundNumber, deadline);\r\n    }\r\n    function getFreeMinerForMiniGame(address _addr) public isNotOver onlyContractsMiniGame\r\n    {\r\n        require(players[_addr].roundNumber != roundNumber);\r\n        Player storage p = players[_addr];\r\n        //reset player data\r\n        if(p.hashrate > 0){\r\n            for (uint idx = 1; idx < numberOfMiners; idx++) {\r\n                p.minerCount[idx] = 0;\r\n            }\r\n        }\r\n        MinerData storage m0 = minerData[0];\r\n        p.crystals = 0;\r\n        p.roundNumber = roundNumber;\r\n        //free miner\r\n        p.lastUpdateTime = now;\r\n        p.minerCount[0] = 1;\r\n        p.hashrate = m0.baseProduct;\r\n\r\n        emit GetFreeMiner(_addr, roundNumber, deadline);\r\n    }\r\n    function buyMiner(uint256[8] minerNumbers) public isNotOver isCurrentRound(msg.sender)\r\n    {           \r\n        updateCrystal(msg.sender);\r\n\r\n        Player storage p = players[msg.sender];\r\n        uint256 price = 0;\r\n        uint256 hashrate = 0;\r\n\r\n        for (uint256 minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\r\n            MinerData memory m = minerData[minerIdx];\r\n            uint256 minerNumber = minerNumbers[minerIdx];\r\n           \r\n            if(minerNumbers[minerIdx] > m.limit || minerNumbers[minerIdx] < 0) revert();\r\n           \r\n            if (minerNumber > 0) {\r\n                price = SafeMath.add(price, SafeMath.mul(m.basePrice, minerNumber));\r\n\r\n                uint256 currentMinerCount = p.minerCount[minerIdx];\r\n                p.minerCount[minerIdx] = SafeMath.min(m.limit, SafeMath.add(p.minerCount[minerIdx], minerNumber));\r\n                // calculate no hashrate you want buy\r\n                hashrate = SafeMath.add(hashrate, SafeMath.mul(SafeMath.sub(p.minerCount[minerIdx],currentMinerCount), m.baseProduct));\r\n            }\r\n        }\r\n        \r\n        price = SafeMath.mul(price, CRTSTAL_MINING_PERIOD);\r\n        if(p.crystals < price) revert();\r\n        \r\n        p.crystals = SafeMath.sub(p.crystals, price);\r\n\r\n        updateHashrate(msg.sender, hashrate);\r\n\r\n        emit BuyMiner(msg.sender, minerNumbers, SafeMath.div(price, CRTSTAL_MINING_PERIOD), hashrate, roundNumber);\r\n    }\r\n    function getPlayerData(address addr) public view\r\n    returns (uint256 crystals, uint256 lastupdate, uint256 hashratePerDay, uint256[8] miners, uint256 hasBoost, uint256 playerBalance )\r\n    {\r\n        Player storage p = players[addr];\r\n\r\n        if(p.roundNumber != roundNumber) p = players[0x0];\r\n        \r\n        crystals   = SafeMath.div(p.crystals, CRTSTAL_MINING_PERIOD);\r\n        lastupdate = p.lastUpdateTime;\r\n        hashratePerDay = p.hashrate;\r\n        uint256 i = 0;\r\n        for(i = 0; i < numberOfMiners; i++)\r\n        {\r\n            miners[i] = p.minerCount[i];\r\n        }\r\n        hasBoost = hasBooster(addr);\r\n\t\tplayerBalance = payments[addr];\r\n    }\r\n    function getData(address _addr) \r\n    public \r\n    view \r\n    returns (\r\n        uint256 crystals, \r\n        uint256 lastupdate, \r\n        uint256 hashratePerDay, \r\n        uint256[8] miners, \r\n        uint256 hasBoost, \r\n        uint256 playerBalance, \r\n\r\n        uint256 _miningWarRound,\r\n        uint256 _miningWarDeadline,\r\n        uint256 _miningWarPrizePool \r\n    ){\r\n        (, lastupdate, hashratePerDay, miners, hasBoost, playerBalance) = getPlayerData(_addr);\r\n        crystals = SafeMath.div(calCurrentCrystals(_addr), CRTSTAL_MINING_PERIOD);\r\n        _miningWarRound     = roundNumber;\r\n        _miningWarDeadline  = deadline;\r\n        _miningWarPrizePool = prizePool;\r\n    }\r\n    function getHashratePerDay(address _addr) public view returns (uint256 personalProduction)\r\n    {\r\n        Player memory p = players[_addr];\r\n        personalProduction =  p.hashrate;\r\n        uint256 boosterIdx = hasBooster(_addr);\r\n        if (boosterIdx != 999) {\r\n            BoostData memory b = boostData[boosterIdx];\r\n            personalProduction = SafeMath.div(SafeMath.mul(personalProduction, b.boostRate), 100);\r\n        } \r\n    }\r\n    function getCurrentReward(address _addr) public view returns(uint256)\r\n    {\r\n        return payments[_addr];\r\n    }\r\n    function withdrawReward(address _addr) public \r\n    {\r\n        uint256 currentReward = payments[_addr];\r\n        if (address(this).balance >= currentReward && currentReward > 0) {\r\n            _addr.transfer(currentReward);\r\n            payments[_addr]      = 0;\r\n            boosterReward[_addr] = 0;\r\n            emit WithdrawReward(_addr, currentReward);\r\n        }\r\n    } \r\n    //--------------------------------------------------------------------------\r\n    // BOOSTER \r\n    //--------------------------------------------------------------------------\r\n    function buyBooster(uint256 idx) public isNotOver isCurrentRound(msg.sender) payable \r\n    {\r\n        require(idx < numberOfBoosts);\r\n        BoostData storage b = boostData[idx];\r\n        if(msg.value < getBoosterPrice(idx) || msg.sender == b.owner){\r\n            revert();\r\n        }\r\n        address beneficiary = b.owner;\r\n\t\tuint256 devFeePrize = devFee(getBoosterPrice(idx));\r\n        address gameSponsor = Engineer.gameSponsor();\r\n        gameSponsor.transfer(devFeePrize);\r\n\t\tuint256 refundPrize = 0;\r\n        if(beneficiary != 0){\r\n\t\t\trefundPrize = SafeMath.div(SafeMath.mul(getBoosterPrice(idx), 55), 100);\r\n\t\t\tasyncSend(beneficiary, refundPrize);\r\n            boosterReward[beneficiary] = SafeMath.add(boosterReward[beneficiary], refundPrize);\r\n        }\r\n\t\tprizePool = SafeMath.add(prizePool, SafeMath.sub(msg.value, SafeMath.add(devFeePrize, refundPrize)));\r\n        updateCrystal(msg.sender);\r\n        updateCrystal(beneficiary);\r\n        uint256 level   = getCurrentLevel(b.startingLevel, b.startingTime, b.halfLife);\r\n        b.startingLevel = SafeMath.add(level, 1);\r\n        b.startingTime = now;\r\n        // transfer ownership    \r\n        b.owner = msg.sender;\r\n\r\n        emit BuyBooster(msg.sender, roundNumber, idx, msg.value, beneficiary, refundPrize);\r\n    }\r\n    function getBoosterData(uint256 idx) public view returns (address owner,uint256 boostRate, uint256 startingLevel, \r\n        uint256 startingTime, uint256 currentPrice, uint256 halfLife)\r\n    {\r\n        require(idx < numberOfBoosts);\r\n        owner            = boostData[idx].owner;\r\n        boostRate        = boostData[idx].boostRate; \r\n        startingLevel    = boostData[idx].startingLevel;\r\n        startingTime     = boostData[idx].startingTime;\r\n        currentPrice     = getBoosterPrice(idx);\r\n        halfLife         = boostData[idx].halfLife;\r\n    }\r\n    function getBoosterPrice(uint256 index) public view returns (uint256)\r\n    {\r\n        BoostData storage booster = boostData[index];\r\n        return getCurrentPrice(getCurrentLevel(booster.startingLevel, booster.startingTime, booster.halfLife));\r\n    }\r\n    function hasBooster(address addr) public view returns (uint256 boostIdx)\r\n    {         \r\n        boostIdx = 999;\r\n        for(uint256 i = 0; i < numberOfBoosts; i++){\r\n            uint256 revert_i = numberOfBoosts - i - 1;\r\n            if(boostData[revert_i].owner == addr){\r\n                boostIdx = revert_i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Other \r\n    //--------------------------------------------------------------------------\r\n    function devFee(uint256 amount) public pure returns(uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(amount, 5), 100);\r\n    }\r\n    function getBalance() public view returns(uint256)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n\t//@dev use this function in case of bug\r\n    function upgrade(address addr) public isAdministrator\r\n    {\r\n        selfdestruct(addr);\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Private \r\n    //--------------------------------------------------------------------------\r\n    /**\r\n    * @param addr is player address you want add hash rate\r\n    * @param _hashrate is no hashrate you want add for this player\r\n    */\r\n    function updateHashrate(address addr, uint256 _hashrate) private\r\n    {\r\n        Player storage p = players[addr];\r\n       \r\n        p.hashrate = SafeMath.add(p.hashrate, _hashrate);\r\n       \r\n        if(p.hashrate > RANK_LIST_LIMIT) updateRankList(addr);\r\n        \r\n        emit ChangeHasrate(addr, p.hashrate, roundNumber);\r\n    }\r\n    function updateCrystal(address _addr) private\r\n    {\r\n        require(now > players[_addr].lastUpdateTime);\r\n\r\n        Player storage p = players[_addr]; \r\n        p.crystals = calCurrentCrystals(_addr);\r\n        p.lastUpdateTime = now;\r\n    }\r\n     /**\r\n    * @dev calculate current crystals of player\r\n    * @param _addr player address\r\n    */\r\n    function calCurrentCrystals(address _addr) public view returns(uint256 _currentCrystals)\r\n    {\r\n        Player memory p = players[_addr];\r\n\r\n        if(p.roundNumber != roundNumber) p = players[0x0];\r\n\r\n        uint256 hashratePerDay = getHashratePerDay(_addr);     \r\n        uint256 secondsPassed = SafeMath.sub(now, p.lastUpdateTime);      \r\n        \r\n        if (hashratePerDay > 0) _currentCrystals = SafeMath.add(p.crystals, SafeMath.mul(hashratePerDay, secondsPassed));\r\n    }\r\n    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) private view returns(uint256) \r\n    {\r\n        uint256 timePassed=SafeMath.sub(now, startingTime);\r\n        uint256 levelsPassed=SafeMath.div(timePassed, halfLife);\r\n        if (startingLevel < levelsPassed) {\r\n            return 0;\r\n        }\r\n        return SafeMath.sub(startingLevel, levelsPassed);\r\n    }\r\n    function getCurrentPrice(uint256 currentLevel) private view returns(uint256) \r\n    {\r\n        return SafeMath.mul(BASE_PRICE, 2**currentLevel);\r\n    }\r\n    function updateRankList(address addr) private returns(bool)\r\n    {\r\n        uint256 idx = 0;\r\n        Player storage insert = players[addr];\r\n        Player storage lastOne = players[rankList[19]];\r\n        if(insert.hashrate < lastOne.hashrate) {\r\n            return false;\r\n        }\r\n        address[21] memory tempList = rankList;\r\n        if(!inRankList(addr)){\r\n            tempList[20] = addr;\r\n            quickSort(tempList, 0, 20);\r\n        }else{\r\n            quickSort(tempList, 0, 19);\r\n        }\r\n        for(idx = 0;idx < 21; idx++){\r\n            if(tempList[idx] != rankList[idx]){\r\n                rankList[idx] = tempList[idx];\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    function inRankList(address addr) internal view returns(bool)\r\n    {\r\n        for(uint256 idx = 0;idx < 20; idx++){\r\n            if(addr == rankList[idx]){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function quickSort(address[21] list, int left, int right) internal\r\n    {\r\n        int i = left;\r\n        int j = right;\r\n        if(i == j) return;\r\n        address addr = list[uint(left + (right - left) / 2)];\r\n        Player storage p = players[addr];\r\n        while (i <= j) {\r\n            while (players[list[uint(i)]].hashrate > p.hashrate) i++;\r\n            while (p.hashrate > players[list[uint(j)]].hashrate) j--;\r\n            if (i <= j) {\r\n                (list[uint(i)], list[uint(j)]) = (list[uint(j)], list[uint(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(list, left, j);\r\n        if (i < right)\r\n            quickSort(list, i, right);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getFreeMinerForMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getHashratePerDay\",\"outputs\":[{\"name\":\"personalProduction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBoosterPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"crystals\",\"type\":\"uint256\"},{\"name\":\"lastupdate\",\"type\":\"uint256\"},{\"name\":\"hashratePerDay\",\"type\":\"uint256\"},{\"name\":\"miners\",\"type\":\"uint256[8]\"},{\"name\":\"hasBoost\",\"type\":\"uint256\"},{\"name\":\"playerBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getData\",\"outputs\":[{\"name\":\"crystals\",\"type\":\"uint256\"},{\"name\":\"lastupdate\",\"type\":\"uint256\"},{\"name\":\"hashratePerDay\",\"type\":\"uint256\"},{\"name\":\"miners\",\"type\":\"uint256[8]\"},{\"name\":\"hasBoost\",\"type\":\"uint256\"},{\"name\":\"playerBalance\",\"type\":\"uint256\"},{\"name\":\"_miningWarRound\",\"type\":\"uint256\"},{\"name\":\"_miningWarDeadline\",\"type\":\"uint256\"},{\"name\":\"_miningWarPrizePool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getBoosterData\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"boostRate\",\"type\":\"uint256\"},{\"name\":\"startingLevel\",\"type\":\"uint256\"},{\"name\":\"startingTime\",\"type\":\"uint256\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"halfLife\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"devFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subHashrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minerNumbers\",\"type\":\"uint256[8]\"}],\"name\":\"buyMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCurrentReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALF_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMiniGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMiningWarContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROUND_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"boosterReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setContractsMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getFreeMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"miniGameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calCurrentCrystals\",\"outputs\":[{\"name\":\"_currentCrystals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeContractMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRankList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[21]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasBooster\",\"outputs\":[{\"name\":\"boostIdx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subCrystal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"miniGames\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Engineer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CRTSTAL_MINING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"buyBooster\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"name\":\"hashrate\",\"type\":\"uint256\"},{\"name\":\"crystals\",\"type\":\"uint256\"},{\"name\":\"lastUpdateTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addHashrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addCrystal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRoundNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setEngineerInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_miningWarRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"GetFreeMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minerNumbers\",\"type\":\"uint256[8]\"},{\"indexed\":false,\"name\":\"_crystalsPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_hashrateBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_miningWarRound\",\"type\":\"uint256\"}],\"name\":\"BuyMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_hashrate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_miningWarRound\",\"type\":\"uint256\"}],\"name\":\"ChangeHasrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_crystal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_miningWarRound\",\"type\":\"uint256\"}],\"name\":\"ChangeCrystal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_miningWarRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_boosterId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"refundPrize\",\"type\":\"uint256\"}],\"name\":\"BuyBooster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_topAddr\",\"type\":\"address[10]\"},{\"indexed\":false,\"name\":\"_reward\",\"type\":\"uint256[10]\"},{\"indexed\":false,\"name\":\"_miningWarRound\",\"type\":\"uint256\"}],\"name\":\"Lottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"WithdrawReward\",\"type\":\"event\"}]","ContractName":"CryptoMiningWar","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e9d0ba2d295f75989bb602465611f1b859ed7d3b0dae249cc6b64b639e38f4a6"}]}