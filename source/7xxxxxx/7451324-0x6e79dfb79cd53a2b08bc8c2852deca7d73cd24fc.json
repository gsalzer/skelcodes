{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\ninterface IOrbsValidators {\r\n\r\n    event ValidatorApproved(address indexed validator);\r\n    event ValidatorRemoved(address indexed validator);\r\n\r\n    /// @dev Adds a validator to participate in network\r\n    /// @param validator address The address of the validators.\r\n    function approve(address validator) external;\r\n\r\n    /// @dev Remove a validator from the List based on Guardians votes.\r\n    /// @param validator address The address of the validators.\r\n    function remove(address validator) external;\r\n\r\n    /// @dev returns if an address belongs to the approved list & exists in the validators metadata registration database.\r\n    /// @param validator address The address of the validators.\r\n    function isValidator(address validator) external view returns (bool);\r\n\r\n    /// @dev returns if an address belongs to the approved list\r\n    /// @param validator address The address of the validators.\r\n    function isApproved(address validator) external view returns (bool);\r\n\r\n    /// @dev returns a list of all validators that have been approved and exist in the validator registration database.\r\n    function getValidators() external view returns (address[]);\r\n\r\n    /// @dev returns a list of all validators that have been approved and exist in the validator registration\r\n    ///      database. same as getValidators but returns addresses represented as byte20.\r\n    function getValidatorsBytes20() external view returns (bytes20[]);\r\n\r\n    /// @dev returns the block number in which the validator was approved.\r\n    /// @param validator address The address of the validators.\r\n    function getApprovalBlockNumber(address validator)\r\n        external\r\n        view\r\n        returns (uint);\r\n}\r\n\r\n\r\n/// @title Date and Time utilities for Ethereum contracts.\r\nlibrary DateTime {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint16;\r\n    using SafeMath for uint8;\r\n\r\n    struct DT {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint public constant SECONDS_IN_DAY = 86400;\r\n    uint public constant SECONDS_IN_YEAR = 31536000;\r\n    uint public constant SECONDS_IN_LEAP_YEAR = 31622400;\r\n    uint public constant DAYS_IN_WEEK = 7;\r\n    uint public constant HOURS_IN_DAY = 24;\r\n    uint public constant MINUTES_IN_HOUR = 60;\r\n    uint public constant SECONDS_IN_HOUR = 3600;\r\n    uint public constant SECONDS_IN_MINUTE = 60;\r\n\r\n    uint16 public constant ORIGIN_YEAR = 1970;\r\n\r\n    /// @dev Returns whether the specified year is a leap year.\r\n    /// @param _year uint16 The year to check.\r\n    function isLeapYear(uint16 _year) public pure returns (bool) {\r\n        if (_year % 4 != 0) {\r\n            return false;\r\n        }\r\n\r\n        if (_year % 100 != 0) {\r\n            return true;\r\n        }\r\n\r\n        if (_year % 400 != 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns how many leap years were before the specified year.\r\n    /// @param _year uint16 The year to check.\r\n    function leapYearsBefore(uint16 _year) public pure returns (uint16) {\r\n        _year = uint16(_year.sub(1));\r\n        return uint16(_year.div(4).sub(_year.div(100)).add(_year.div(400)));\r\n    }\r\n\r\n    /// @dev Returns how many days are there in a specified month.\r\n    /// @param _year uint16 The year of the month to check.\r\n    /// @param _month uint8 The month to check.\r\n    function getDaysInMonth(uint16 _year, uint8 _month) public pure returns (uint8) {\r\n        if (_month == 1 || _month == 3 || _month == 5 || _month == 7 || _month == 8 || _month == 10 || _month == 12) {\r\n            return 31;\r\n        }\r\n\r\n        if (_month == 4 || _month == 6 || _month == 9 || _month == 11) {\r\n            return 30;\r\n        }\r\n\r\n        if (isLeapYear(_year)) {\r\n            return 29;\r\n        }\r\n\r\n        return 28;\r\n    }\r\n\r\n    /// @dev Returns the year of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getYear(uint256 _timestamp) public pure returns (uint16 year) {\r\n        uint256 secondsAccountedFor;\r\n        uint16 numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR.add(_timestamp.div(SECONDS_IN_YEAR)));\r\n        numLeapYears = uint16(leapYearsBefore(year).sub(leapYearsBefore(ORIGIN_YEAR)));\r\n\r\n        secondsAccountedFor = secondsAccountedFor.add(SECONDS_IN_LEAP_YEAR.mul(numLeapYears));\r\n        secondsAccountedFor = secondsAccountedFor.add(SECONDS_IN_YEAR.mul((year.sub(ORIGIN_YEAR).sub(numLeapYears))));\r\n\r\n        while (secondsAccountedFor > _timestamp) {\r\n            if (isLeapYear(uint16(year.sub(1)))) {\r\n                secondsAccountedFor = secondsAccountedFor.sub(SECONDS_IN_LEAP_YEAR);\r\n            } else {\r\n                secondsAccountedFor = secondsAccountedFor.sub(SECONDS_IN_YEAR);\r\n            }\r\n\r\n            year = uint16(year.sub(1));\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the month of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getMonth(uint256 _timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(_timestamp).month;\r\n    }\r\n\r\n    /// @dev Returns the day of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getDay(uint256 _timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(_timestamp).day;\r\n    }\r\n\r\n    /// @dev Returns the hour of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getHour(uint256 _timestamp) public pure returns (uint8) {\r\n        return uint8((_timestamp.div(SECONDS_IN_HOUR)) % HOURS_IN_DAY);\r\n    }\r\n\r\n    /// @dev Returns the minutes of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getMinute(uint256 _timestamp) public pure returns (uint8) {\r\n        return uint8((_timestamp.div(SECONDS_IN_MINUTE)) % MINUTES_IN_HOUR);\r\n    }\r\n\r\n    /// @dev Returns the seconds of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getSecond(uint256 _timestamp) public pure returns (uint8) {\r\n        return uint8(_timestamp % SECONDS_IN_MINUTE);\r\n    }\r\n\r\n    /// @dev Returns the weekday of the current UNIX timestamp.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function getWeekday(uint256 _timestamp) public pure returns (uint8) {\r\n        return uint8((_timestamp.div(SECONDS_IN_DAY).add(4)) % DAYS_IN_WEEK);\r\n    }\r\n\r\n    /// @dev Returns the timestamp of the beginning of the month.\r\n    /// @param _month uint8 The month to check.\r\n    /// @param _year uint16 The year of the month to check.\r\n    function getBeginningOfMonth(uint16 _year, uint8 _month) public pure returns (uint256) {\r\n        return toTimestamp(_year, _month, 1);\r\n    }\r\n\r\n    /// @dev Returns the timestamp of the beginning of the month.\r\n    /// @param _month uint8 The month to check.\r\n    /// @param _year uint16 The year of the month to check.\r\n    function getNextMonth(uint16 _year, uint8 _month) public pure returns (uint16 year, uint8 month) {\r\n        if (_month == 12) {\r\n            year = uint16(_year.add(1));\r\n            month = 1;\r\n        } else {\r\n            year = _year;\r\n            month = uint8(_month.add(1));\r\n        }\r\n    }\r\n\r\n    /// @dev Converts date to timestamp.\r\n    /// @param _year uint16 The year of the date.\r\n    /// @param _month uint8 The month of the date.\r\n    function toTimestamp(uint16 _year, uint8 _month) public pure returns (uint) {\r\n        return toTimestampFull(_year, _month, 0, 0, 0, 0);\r\n    }\r\n\r\n    /// @dev Converts date to timestamp.\r\n    /// @param _year uint16 The year of the date.\r\n    /// @param _month uint8 The month of the date.\r\n    /// @param _day uint8 The day of the date.\r\n    function toTimestamp(uint16 _year, uint8 _month, uint8 _day) public pure returns (uint) {\r\n        return toTimestampFull(_year, _month, _day, 0, 0, 0);\r\n    }\r\n\r\n    /// @dev Converts date to timestamp.\r\n    /// @param _year uint16 The year of the date.\r\n    /// @param _month uint8 The month of the date.\r\n    /// @param _day uint8 The day of the date.\r\n    /// @param _hour uint8 The hour of the date.\r\n    /// @param _minutes uint8 The minutes of the date.\r\n    /// @param _seconds uint8 The seconds of the date.\r\n    function toTimestampFull(uint16 _year, uint8 _month, uint8 _day, uint8 _hour, uint8 _minutes,\r\n        uint8 _seconds) public pure returns (uint) {\r\n        uint16 i;\r\n        uint timestamp;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < _year; ++i) {\r\n            if (isLeapYear(i)) {\r\n                timestamp = timestamp.add(SECONDS_IN_LEAP_YEAR);\r\n            } else {\r\n                timestamp = timestamp.add(SECONDS_IN_YEAR);\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(_year)) {\r\n            monthDayCounts[1] = 29;\r\n        } else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < _month; ++i) {\r\n            timestamp = timestamp.add(SECONDS_IN_DAY.mul(monthDayCounts[i.sub(1)]));\r\n        }\r\n\r\n        // Day\r\n        timestamp = timestamp.add(SECONDS_IN_DAY.mul(_day == 0 ? 0 : _day.sub(1)));\r\n\r\n        // Hour\r\n        timestamp = timestamp.add(SECONDS_IN_HOUR.mul(_hour));\r\n\r\n        // Minutes\r\n        timestamp = timestamp.add(SECONDS_IN_MINUTE.mul(_minutes));\r\n\r\n        // Seconds\r\n        timestamp = timestamp.add(_seconds);\r\n\r\n        return timestamp;\r\n    }\r\n\r\n    /// @dev Parses a UNIX timestamp to a DT struct.\r\n    /// @param _timestamp uint256 The UNIX timestamp to parse.\r\n    function parseTimestamp(uint256 _timestamp) internal pure returns (DT memory dt) {\r\n        uint256 secondsAccountedFor;\r\n        uint256 buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(_timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor = secondsAccountedFor.add(SECONDS_IN_LEAP_YEAR.mul(buf));\r\n        secondsAccountedFor = secondsAccountedFor.add(SECONDS_IN_YEAR.mul((dt.year.sub(ORIGIN_YEAR).sub(buf))));\r\n\r\n        // Month\r\n        uint256 secondsInMonth;\r\n        for (i = 1; i <= 12; ++i) {\r\n            secondsInMonth = SECONDS_IN_DAY.mul(getDaysInMonth(dt.year, i));\r\n            if (secondsInMonth.add(secondsAccountedFor) > _timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor = secondsAccountedFor.add(secondsInMonth);\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.year, dt.month); ++i) {\r\n            if (SECONDS_IN_DAY.add(secondsAccountedFor) > _timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor = secondsAccountedFor.add(SECONDS_IN_DAY);\r\n        }\r\n\r\n        // Hour\r\n        dt.hour = getHour(_timestamp);\r\n\r\n        // Minute\r\n        dt.minute = getMinute(_timestamp);\r\n\r\n        // Second\r\n        dt.second = getSecond(_timestamp);\r\n\r\n        // Day of week.\r\n        dt.weekday = getWeekday(_timestamp);\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface ISubscriptionChecker {\r\n    /// @param _id the virtual chain id to check subscription for\r\n    /// @return profile - the subscribed plan, e.g. 'gold', 'silver', etc\r\n    function getSubscriptionData(bytes32 _id) external view returns (bytes32 id, string memory profile, uint256 startTime, uint256 tokens);\r\n}\r\n\r\n\r\n/// @title Orbs billing and subscription smart contract.\r\ncontract OrbsSubscriptions is ISubscriptionChecker {\r\n    using SafeMath for uint256;\r\n\r\n    // The version of the current subscription manager smart contract.\r\n    uint public constant VERSION = 2;\r\n\r\n    // The Orbs token smart contract.\r\n    IERC20 public orbs;\r\n\r\n    // The Orbs Validators smart contract.\r\n    IOrbsValidators public validators;\r\n\r\n    // The minimal monthly subscription allocation.\r\n    uint public minimalMonthlySubscription;\r\n\r\n    struct Subscription {\r\n        bytes32 id;\r\n        string profile;\r\n        uint256 startTime;\r\n        uint256 tokens;\r\n    }\r\n\r\n    struct MonthlySubscriptions {\r\n        mapping(bytes32 => Subscription) subscriptions;\r\n        uint256 totalTokens;\r\n    }\r\n\r\n    /// A mapping between time (in a monthly resolution) and subscriptions, in the following format:\r\n    ///     YEAR --> MONTH -->   MONTHLY_SUBSCRIPTION  --> SUBSCRIPTION_ID -->  SUBSCRIPTION\r\n    ///     2017 -->  12   --> {<subscriptions>, 1000} -->     \"User1\"     --> {\"User1\", 100}\r\n    mapping(uint16 => mapping(uint8 => MonthlySubscriptions)) public subscriptions;\r\n\r\n    bytes32 constant public EMPTY = bytes32(0);\r\n\r\n    event Subscribed(address indexed subscriber, bytes32 indexed id, uint256 value, uint256 startFrom);\r\n    event DistributedFees(address indexed validator, uint256 value);\r\n\r\n    /// @dev Constructor that initializes the Subscription Manager.\r\n    /// @param orbs_ IERC20 The address of the OrbsToken contract.\r\n    /// @param validators_ The address of the OrbsValidators contract.\r\n    /// @param minimalMonthlySubscription_ uint256 The minimal monthly subscription allocation.\r\n    constructor(IERC20 orbs_, IOrbsValidators validators_, uint256 minimalMonthlySubscription_) public {\r\n        require(address(orbs_) != address(0), \"Address must not be 0!\");\r\n        require(address(validators_) != address(0), \"OrbsValidators must not be 0!\");\r\n        require(minimalMonthlySubscription_ != 0, \"Minimal subscription value must be greater than 0!\");\r\n\r\n        orbs = orbs_;\r\n        validators = validators_;\r\n        minimalMonthlySubscription = minimalMonthlySubscription_;\r\n    }\r\n\r\n    /// @dev Returns the current month's subscription data.\r\n    /// @param _id bytes32 The ID of the subscription.\r\n    function getSubscriptionData(bytes32 _id) public view returns (bytes32 id, string memory profile, uint256 startTime,\r\n        uint256 tokens) {\r\n        require(_id != EMPTY, \"ID must not be empty!\");\r\n\r\n        // Get the current year and month.\r\n        uint16 currentYear;\r\n        uint8 currentMonth;\r\n        (currentYear, currentMonth) = getCurrentTime();\r\n\r\n        return getSubscriptionDataByTime(_id, currentYear, currentMonth);\r\n    }\r\n\r\n    /// @dev Returns the monthly subscription status.\r\n    /// @param _id bytes32 The ID of the subscription.\r\n    /// @param _year uint16 The year of the subscription.\r\n    /// @param _month uint8 The month of the subscription.\r\n    function getSubscriptionDataByTime(bytes32 _id, uint16 _year, uint8 _month) public view returns (bytes32 id,\r\n        string memory profile, uint256 startTime, uint256 tokens) {\r\n        require(_id != EMPTY, \"ID must not be empty!\");\r\n\r\n        MonthlySubscriptions storage monthlySubscription = subscriptions[_year][_month];\r\n        Subscription memory subscription = monthlySubscription.subscriptions[_id];\r\n\r\n        id = subscription.id;\r\n        profile = subscription.profile;\r\n        startTime = subscription.startTime;\r\n        tokens = subscription.tokens;\r\n    }\r\n\r\n    /// @dev Distributes monthly fees to validators.\r\n    function distributeFees() public {\r\n        // Get the current year and month.\r\n        uint16 currentYear;\r\n        uint8 currentMonth;\r\n        (currentYear, currentMonth) = getCurrentTime();\r\n\r\n        distributeFees(currentYear, currentMonth);\r\n    }\r\n\r\n    /// @dev Distributes monthly fees to validators.\r\n    function distributeFees(uint16 _year, uint8 _month) public {\r\n        uint16 currentYear;\r\n        uint8 currentMonth;\r\n        (currentYear, currentMonth) = getCurrentTime();\r\n\r\n        // Don't allow distribution of any future fees (specifically, next month's subscription fees).\r\n        require(DateTime.toTimestamp(currentYear, currentMonth) >= DateTime.toTimestamp(_year, _month),\r\n            \"Can't distribute future fees!\");\r\n\r\n        address[] memory validatorsAddress = validators.getValidators();\r\n        uint validatorCount = validatorsAddress.length;\r\n\r\n        MonthlySubscriptions storage monthlySubscription = subscriptions[_year][_month];\r\n        uint256 fee = monthlySubscription.totalTokens.div(validatorCount);\r\n        require(fee > 0, \"Fee must be greater than 0!\");\r\n\r\n        for (uint i = 0; i < validatorCount; ++i) {\r\n            address validator = validatorsAddress[i];\r\n            uint256 validatorFee = fee;\r\n\r\n            // Distribute the remainder to the first node.\r\n            if (i == 0) {\r\n                validatorFee = validatorFee.add(monthlySubscription.totalTokens % validatorCount);\r\n            }\r\n\r\n            monthlySubscription.totalTokens = monthlySubscription.totalTokens.sub(validatorFee);\r\n\r\n            require(orbs.transfer(validator, validatorFee));\r\n            emit DistributedFees(validator, validatorFee);\r\n        }\r\n    }\r\n\r\n    /// @dev Receives subscription payment for the current month. This method needs to be called after the caller\r\n    /// approves the smart contract to transfer _value ORBS tokens on its behalf.\r\n    /// @param _id bytes32 The ID of the subscription.\r\n    /// @param _profile string The name of the subscription profile. This parameter is ignored for subsequent\r\n    /// subscriptions.\r\n    /// @param _value uint256 The amount of tokens to fund the subscription.\r\n    function subscribeForCurrentMonth(bytes32 _id, string memory _profile, uint256 _value) public {\r\n        subscribe(_id, _profile, _value, now);\r\n    }\r\n\r\n    /// @dev Receives subscription payment for the next month. This method needs to be called after the caller approves\r\n    /// the smart contract to transfer _value ORBS tokens on its behalf.\r\n    /// @param _id bytes32 The ID of the subscription.\r\n    /// @param _profile string The name of the subscription profile. This parameter is ignored for subsequent\r\n    /// subscriptions.\r\n    /// @param _value uint256 The amount of tokens to fund the subscription.\r\n    function subscribeForNextMonth(bytes32 _id, string memory _profile, uint256 _value) public {\r\n        // Get the current year and month.\r\n        uint16 currentYear;\r\n        uint8 currentMonth;\r\n        (currentYear, currentMonth) = getCurrentTime();\r\n\r\n        // Get the next month.\r\n        uint16 nextYear;\r\n        uint8 nextMonth;\r\n        (nextYear, nextMonth) = DateTime.getNextMonth(currentYear, currentMonth);\r\n\r\n        subscribe(_id, _profile, _value, DateTime.getBeginningOfMonth(nextYear, nextMonth));\r\n    }\r\n\r\n    /// @dev Receives subscription payment. This method needs to be called after the caller approves\r\n    /// the smart contract to transfer _value ORBS tokens on its behalf.\r\n    /// @param _id bytes32 The ID of the subscription.\r\n    /// @param _profile string The name of the subscription profile. This parameter is ignored for subsequent\r\n    /// subscriptions.\r\n    /// @param _value uint256 The amount of tokens to fund the subscription.\r\n    /// @param _startTime uint256 The start time of the subscription.\r\n    function subscribe(bytes32 _id, string memory _profile, uint256 _value, uint256 _startTime) internal {\r\n        require(_id != EMPTY, \"ID must not be empty!\");\r\n        require(bytes(_profile).length > 0, \"Profile must not be empty!\");\r\n        require(_value > 0, \"Value must be greater than 0!\");\r\n        require(_startTime >= now, \"Starting time must be in the future\");\r\n\r\n        // Verify that the subscriber approved enough tokens to pay for the subscription.\r\n        require(orbs.transferFrom(msg.sender, address(this), _value), \"Insufficient allowance!\");\r\n\r\n        uint16 year;\r\n        uint8 month;\r\n        (year, month) = getTime(_startTime);\r\n\r\n        // Get the subscription.\r\n        MonthlySubscriptions storage monthlySubscription = subscriptions[year][month];\r\n        Subscription storage subscription = monthlySubscription.subscriptions[_id];\r\n\r\n        // New subscription?\r\n        if (subscription.id == EMPTY) {\r\n            subscription.id = _id;\r\n            subscription.profile = _profile;\r\n            subscription.startTime = _startTime;\r\n        }\r\n\r\n        // Aggregate this month's subscription allocations.\r\n        subscription.tokens = subscription.tokens.add(_value);\r\n\r\n        // Make sure that the total monthly subscription allocation is above the minimal requirement.\r\n        require(subscription.tokens >= minimalMonthlySubscription, \"Subscription value is too low!\");\r\n\r\n        // Update selected month's total subscription allocations.\r\n        monthlySubscription.totalTokens = monthlySubscription.totalTokens.add(_value);\r\n\r\n        emit Subscribed(msg.sender, _id, _value, _startTime);\r\n    }\r\n\r\n    /// @dev Returns the current year and month.\r\n    /// @return year uint16 The current year.\r\n    /// @return month uint8 The current month.\r\n    function getCurrentTime() private view returns (uint16 year, uint8 month) {\r\n        return getTime(now);\r\n    }\r\n\r\n    /// @dev Returns the current year and month.\r\n    /// @param _time uint256 The timestamp of the time to query.\r\n    /// @return year uint16 The current year.\r\n    /// @return month uint8 The current month.\r\n    function getTime(uint256 _time) private pure returns (uint16 year, uint8 month) {\r\n        year = DateTime.getYear(_time);\r\n        month = DateTime.getMonth(_time);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"EMPTY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalMonthlySubscription\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_profile\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subscribeForCurrentMonth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_year\",\"type\":\"uint16\"},{\"name\":\"_month\",\"type\":\"uint8\"}],\"name\":\"getSubscriptionDataByTime\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"profile\",\"type\":\"string\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"subscriptions\",\"outputs\":[{\"name\":\"totalTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getSubscriptionData\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"profile\",\"type\":\"string\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_profile\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subscribeForNextMonth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_year\",\"type\":\"uint16\"},{\"name\":\"_month\",\"type\":\"uint8\"}],\"name\":\"distributeFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orbs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"orbs_\",\"type\":\"address\"},{\"name\":\"validators_\",\"type\":\"address\"},{\"name\":\"minimalMonthlySubscription_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startFrom\",\"type\":\"uint256\"}],\"name\":\"Subscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DistributedFees\",\"type\":\"event\"}]","ContractName":"OrbsSubscriptions","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ff56cc6b1e6ded347aa0b7676c85ab0b3d08b0fa000000000000000000000000240faa45557c61b6959162660e324bb90984f00f0000000000000000000000000000000000000000000000056bc75e2d63100000","Library":"DateTime:d8DdbBd9C89112bF0a3A4A94F7F666d13cc9014b","SwarmSource":"bzzr://150641f4775cb385c9ae9df10e6b60d22e1d415c7df216e9bc38767b33742d5e"}]}