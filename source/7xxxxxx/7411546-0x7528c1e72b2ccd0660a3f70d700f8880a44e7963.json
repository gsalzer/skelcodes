{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"\");\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n// Developer @gogol\r\n// Design @chechenets\r\n// Architect @tugush\r\n\r\ncontract Manageable is Ownable {\r\n    mapping(address => bool) public listOfManagers;\r\n\r\n    modifier onlyManager() {\r\n        require(listOfManagers[msg.sender], \"\");\r\n        _;\r\n    }\r\n\r\n    function addManager(address _manager) public onlyOwner returns (bool success) {\r\n        if (!listOfManagers[_manager]) {\r\n            require(_manager != address(0), \"\");\r\n            listOfManagers[_manager] = true;\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function removeManager(address _manager) public onlyOwner returns (bool success) {\r\n        if (listOfManagers[_manager]) {\r\n            listOfManagers[_manager] = false;\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function getInfo(address _manager) public view returns (bool) {\r\n        return listOfManagers[_manager];\r\n    }\r\n}\r\n\r\n// Developer @gogol\r\n// Design @chechenets\r\n// Architect @tugush\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// Developer @gogol\r\n// Design @chechenets\r\n// Architect @tugush\r\n\r\ncontract iRNG {\r\n    function update(uint roundNumber, uint additionalNonce, uint period) public payable;\r\n}\r\n\r\n\r\ncontract BaseGame is Manageable {\r\n    using SafeMath for uint;\r\n\r\n    enum RoundState {NOT_STARTED, ACCEPT_FUNDS, WAIT_RESULT, SUCCESS, REFUND}\r\n\r\n    struct Round {\r\n        RoundState state;\r\n        uint ticketsCount;\r\n        uint participantCount;\r\n        TicketsInterval[] tickets;\r\n        address[] participants;\r\n        uint random;\r\n        uint nonce; //xored participants addresses\r\n        uint startRoundTime;\r\n        uint[] winningTickets;\r\n        address[] winners;\r\n        uint roundFunds;\r\n        mapping(address => uint) winnersFunds;\r\n        mapping(address => uint) participantFunds;\r\n        mapping(address => bool) sendGain;\r\n    }\r\n\r\n    struct TicketsInterval {\r\n        address participant;\r\n        uint firstTicket;\r\n        uint lastTicket;\r\n    }\r\n\r\n    uint constant public NUMBER_OF_WINNERS = 10;\r\n    uint constant public SHARE_DENOMINATOR = 10000;\r\n    uint constant public ORACLIZE_TIMEOUT = 86400;  // one day\r\n    uint[] public shareOfWinners = [5000, 2500, 1250, 620, 320, 160, 80, 40, 20, 10];\r\n    address payable public organiser;\r\n    uint constant public ORGANISER_PERCENT = 20;\r\n    uint constant public ROUND_FUND_PERCENT = 80;\r\n\r\n    uint public period;\r\n    address public hourlyGame;\r\n    address public management;\r\n    address payable public rng;\r\n\r\n    mapping (uint => Round) public rounds;\r\n\r\n    uint public ticketPrice;\r\n    uint public currentRound;\r\n\r\n    event GameStarted(uint start);\r\n    event RoundStateChanged(uint currentRound, RoundState state);\r\n    event ParticipantAdded(uint round, address participant, uint ticketsCount, uint funds);\r\n    event RoundProcecced(uint round, address[] winners, uint[] winningTickets, uint roundFunds);\r\n    event RefundIsSuccess(uint round, address participant, uint funds);\r\n    event RefundIsFailed(uint round, address participant);\r\n    event Withdraw(address participant, uint funds, uint fromRound, uint toRound);\r\n    event TicketPriceChanged(uint price);\r\n\r\n    modifier onlyRng {\r\n        require(msg.sender == address(rng), \"\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGameContract {\r\n        require(msg.sender == address(hourlyGame) || msg.sender == management, \"\");\r\n        _;\r\n    }\r\n\r\n    constructor (address payable _rng, uint _period) public {\r\n        require(_rng != address(0), \"\");\r\n        require(_period >= 60, \"\");\r\n\r\n        rng = _rng;\r\n        period = _period;\r\n    }\r\n\r\n    function setContracts(address payable _rng, address _hourlyGame, address _management) public onlyOwner {\r\n        require(_rng != address(0), \"\");\r\n        require(_hourlyGame != address(0), \"\");\r\n        require(_management != address(0), \"\");\r\n\r\n        rng = _rng;\r\n        hourlyGame = _hourlyGame;\r\n        management = _management;\r\n    }\r\n\r\n    function startGame(uint _startPeriod) public payable onlyGameContract {\r\n        currentRound = 1;\r\n        uint time = getCurrentTime().add(_startPeriod).sub(period);\r\n        rounds[currentRound].startRoundTime = time;\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n\r\n        iRNG(rng).update.value(msg.value)(currentRound, 0, _startPeriod);\r\n\r\n        emit GameStarted(time);\r\n    }\r\n\r\n    function buyTickets(address _participant) public payable onlyGameContract {\r\n        uint funds = msg.value;\r\n\r\n        updateRoundTimeAndState();\r\n        addParticipant(_participant, funds.div(ticketPrice));\r\n        updateRoundFundsAndParticipants(_participant, funds);\r\n\r\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period) &&\r\n            rounds[currentRound].participantCount >= 10\r\n        ) {\r\n            _restartGame();\r\n        }\r\n    }\r\n\r\n    function buyBonusTickets(address _participant, uint _ticketsCount) public payable onlyGameContract {\r\n        updateRoundTimeAndState();\r\n        addParticipant(_participant, _ticketsCount);\r\n        updateRoundFundsAndParticipants(_participant, uint(0));\r\n\r\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period) &&\r\n            rounds[currentRound].participantCount >= 10\r\n        ) {\r\n            _restartGame();\r\n        }\r\n    }\r\n\r\n    function processRound(uint _round, uint _randomNumber) public payable onlyRng returns (bool) {\r\n        if (rounds[_round].winners.length != 0) {\r\n            return true;\r\n        }\r\n\r\n        if (checkRoundState(_round) == RoundState.REFUND) {\r\n            return true;\r\n        }\r\n\r\n        if (rounds[_round].participantCount < 10) {\r\n            rounds[_round].state = RoundState.ACCEPT_FUNDS;\r\n            emit RoundStateChanged(_round, rounds[_round].state);\r\n            return true;\r\n        }\r\n\r\n        rounds[_round].random = _randomNumber;\r\n        findWinTickets(_round);\r\n        findWinners(_round);\r\n        rounds[_round].state = RoundState.SUCCESS;\r\n        emit RoundStateChanged(_round, rounds[_round].state);\r\n\r\n        if (rounds[_round.add(1)].state == RoundState.NOT_STARTED) {\r\n            currentRound = _round.add(1);\r\n            rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        }\r\n\r\n        emit RoundProcecced(_round, rounds[_round].winners, rounds[_round].winningTickets, rounds[_round].roundFunds);\r\n        getRandomNumber(_round + 1, rounds[_round].nonce);\r\n        return true;\r\n    }\r\n\r\n    function restartGame() public payable onlyOwner {\r\n        _restartGame();\r\n    }\r\n\r\n    function getRandomNumber(uint _round, uint _nonce) public payable onlyRng {\r\n        iRNG(rng).update(_round, _nonce, period);\r\n    }\r\n\r\n    function setTicketPrice(uint _ticketPrice) public onlyGameContract {\r\n        require(_ticketPrice > 0, \"\");\r\n\r\n        emit TicketPriceChanged(_ticketPrice);\r\n        ticketPrice = _ticketPrice;\r\n    }\r\n\r\n    function findWinTickets(uint _round) public {\r\n        uint[10] memory winners = _findWinTickets(rounds[_round].random, rounds[_round].ticketsCount);\r\n\r\n        for (uint i = 0; i < 10; i++) {\r\n            rounds[_round].winningTickets.push(winners[i]);\r\n        }\r\n    }\r\n\r\n    function _findWinTickets(uint _random, uint _ticketsNum) public pure returns (uint[10] memory) {\r\n        uint random = _random;//uint(keccak256(abi.encodePacked(_random)));\r\n        uint winnersNum = 10;\r\n\r\n        uint[10] memory winTickets;\r\n        uint shift = uint(256).div(winnersNum);\r\n\r\n        for (uint i = 0; i < 10; i++) {\r\n            winTickets[i] =\r\n            uint(keccak256(abi.encodePacked(((random << (i.mul(shift))) >> (shift.mul(winnersNum.sub(1)).add(6)))))).mod(_ticketsNum);\r\n        }\r\n\r\n        return winTickets;\r\n    }\r\n\r\n    function refund(uint _round) public {\r\n        if (checkRoundState(_round) == RoundState.REFUND\r\n        && rounds[_round].participantFunds[msg.sender] > 0\r\n        ) {\r\n            uint amount = rounds[_round].participantFunds[msg.sender];\r\n            rounds[_round].participantFunds[msg.sender] = 0;\r\n            address(msg.sender).transfer(amount);\r\n            emit RefundIsSuccess(_round, msg.sender, amount);\r\n        } else {\r\n            emit RefundIsFailed(_round, msg.sender);\r\n        }\r\n    }\r\n\r\n    function checkRoundState(uint _round) public returns (RoundState) {\r\n        if (rounds[_round].state == RoundState.WAIT_RESULT\r\n        && getCurrentTime() > rounds[_round].startRoundTime.add(ORACLIZE_TIMEOUT)\r\n        ) {\r\n            rounds[_round].state = RoundState.REFUND;\r\n            emit RoundStateChanged(_round, rounds[_round].state);\r\n        }\r\n        return rounds[_round].state;\r\n    }\r\n\r\n    function setOrganiser(address payable _organiser) public onlyOwner {\r\n        require(_organiser != address(0), \"\");\r\n\r\n        organiser = _organiser;\r\n    }\r\n\r\n   function getGain(uint _fromRound, uint _toRound) public {\r\n        _transferGain(msg.sender, _fromRound, _toRound);\r\n    }\r\n\r\n    function sendGain(address payable _participant, uint _fromRound, uint _toRound) public onlyManager {\r\n        _transferGain(_participant, _fromRound, _toRound);\r\n    }\r\n\r\n    function getTicketsCount(uint _round) public view returns (uint) {\r\n        return rounds[_round].ticketsCount;\r\n    }\r\n\r\n    function getTicketPrice() public view returns (uint) {\r\n        return ticketPrice;\r\n    }\r\n\r\n    function getCurrentTime() public view returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    function getPeriod() public view returns (uint) {\r\n        return period;\r\n    }\r\n\r\n    function getRoundWinners(uint _round) public view returns (address[] memory) {\r\n        return rounds[_round].winners;\r\n    }\r\n\r\n    function getRoundWinningTickets(uint _round) public view returns (uint[] memory) {\r\n        return rounds[_round].winningTickets;\r\n    }\r\n\r\n    function getRoundParticipants(uint _round) public view returns (address[] memory) {\r\n        return rounds[_round].participants;\r\n    }\r\n\r\n    function getWinningFunds(uint _round, address _winner) public view returns  (uint) {\r\n        return rounds[_round].winnersFunds[_winner];\r\n    }\r\n\r\n    function getRoundFunds(uint _round) public view returns (uint) {\r\n        return rounds[_round].roundFunds;\r\n    }\r\n\r\n    function getParticipantFunds(uint _round, address _participant) public view returns (uint) {\r\n        return rounds[_round].participantFunds[_participant];\r\n    }\r\n\r\n    function getCurrentRound() public view returns (uint) {\r\n        return currentRound;\r\n    }\r\n\r\n    function getRoundStartTime(uint _round) public view returns (uint) {\r\n        return rounds[_round].startRoundTime;\r\n    }\r\n\r\n    function _restartGame() internal {\r\n        uint _now = getCurrentTime().sub(rounds[1].startRoundTime);\r\n        rounds[currentRound].startRoundTime = getCurrentTime().sub(_now.mod(period));\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        iRNG(rng).update(currentRound, 0, period.sub(_now.mod(period)));\r\n    }\r\n\r\n    function _transferGain(address payable _participant, uint _fromRound, uint _toRound) internal {\r\n        require(_fromRound <= _toRound, \"\");\r\n        require(_participant != address(0), \"\");\r\n\r\n        uint funds;\r\n\r\n        for (uint i = _fromRound; i <= _toRound; i++) {\r\n\r\n            if (rounds[i].state == RoundState.SUCCESS\r\n            && rounds[i].sendGain[_participant] == false) {\r\n\r\n                rounds[i].sendGain[_participant] = true;\r\n                funds = funds.add(getWinningFunds(i, _participant));\r\n            }\r\n        }\r\n\r\n        require(funds > 0, \"\");\r\n        _participant.transfer(funds);\r\n        emit Withdraw(_participant, funds, _fromRound, _toRound);\r\n\r\n    }\r\n\r\n    // find participant who has winning ticket\r\n    // to start: _begin is 0, _end is last index in ticketsInterval array\r\n    function getWinner(\r\n        uint _round,\r\n        uint _beginInterval,\r\n        uint _endInterval,\r\n        uint _winningTicket\r\n    )\r\n        internal\r\n        returns (address)\r\n    {\r\n        if (_beginInterval == _endInterval) {\r\n            return rounds[_round].tickets[_beginInterval].participant;\r\n        }\r\n\r\n        uint len = _endInterval.add(1).sub(_beginInterval);\r\n        uint mid = _beginInterval.add((len.div(2))).sub(1);\r\n        TicketsInterval memory interval = rounds[_round].tickets[mid];\r\n\r\n        if (_winningTicket < interval.firstTicket) {\r\n            return getWinner(_round, _beginInterval, mid, _winningTicket);\r\n        } else if (_winningTicket > interval.lastTicket) {\r\n            return getWinner(_round, mid.add(1), _endInterval, _winningTicket);\r\n        } else {\r\n            return interval.participant;\r\n        }\r\n    }\r\n\r\n    function addParticipant(address _participant, uint _ticketsCount) internal {\r\n        rounds[currentRound].participants.push(_participant);\r\n        uint currTicketsCount = rounds[currentRound].ticketsCount;\r\n        rounds[currentRound].ticketsCount = currTicketsCount.add(_ticketsCount);\r\n        rounds[currentRound].tickets.push(TicketsInterval(\r\n                _participant,\r\n                currTicketsCount,\r\n                rounds[currentRound].ticketsCount.sub(1))\r\n        );\r\n        rounds[currentRound].nonce = rounds[currentRound].nonce + uint(keccak256(abi.encodePacked(_participant)));\r\n        emit ParticipantAdded(currentRound, _participant, _ticketsCount, _ticketsCount.mul(ticketPrice));\r\n    }\r\n\r\n    function updateRoundTimeAndState() internal {\r\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period)\r\n            && rounds[currentRound].participantCount >= 10\r\n        ) {\r\n            rounds[currentRound].state = RoundState.WAIT_RESULT;\r\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n            currentRound = currentRound.add(1);\r\n            rounds[currentRound].startRoundTime = rounds[currentRound-1].startRoundTime.add(period);\r\n            rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        }\r\n    }\r\n\r\n    function updateRoundFundsAndParticipants(address _participant, uint _funds) internal {\r\n\r\n        if (rounds[currentRound].participantFunds[_participant] == 0) {\r\n            rounds[currentRound].participantCount = rounds[currentRound].participantCount.add(1);\r\n        }\r\n\r\n        rounds[currentRound].participantFunds[_participant] =\r\n        rounds[currentRound].participantFunds[_participant].add(_funds);\r\n\r\n        rounds[currentRound].roundFunds =\r\n        rounds[currentRound].roundFunds.add(_funds);\r\n    }\r\n\r\n    function findWinners(uint _round) internal {\r\n        address winner;\r\n        uint fundsToWinner;\r\n        for (uint i = 0; i < NUMBER_OF_WINNERS; i++) {\r\n            winner = getWinner(\r\n                _round,\r\n                0,\r\n                (rounds[_round].tickets.length).sub(1),\r\n                rounds[_round].winningTickets[i]\r\n            );\r\n\r\n            rounds[_round].winners.push(winner);\r\n            fundsToWinner = rounds[_round].roundFunds.mul(shareOfWinners[i]).div(SHARE_DENOMINATOR);\r\n            rounds[_round].winnersFunds[winner] = rounds[_round].winnersFunds[winner].add(fundsToWinner);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// Developer @gogol\r\n// Design @chechenets\r\n// Architect @tugush\r\n\r\n\r\ncontract IChecker {\r\n    function update() public payable;\r\n}\r\n\r\n\r\ncontract JackPot is BaseGame {\r\n\r\n    IChecker public checker;\r\n\r\n    modifier onlyChecker {\r\n        require(msg.sender == address(checker), \"\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable _rng,\r\n        uint _period,\r\n        address _checker\r\n    )\r\n        public\r\n        BaseGame(_rng, _period) {\r\n            require(_checker != address(0), \"\");\r\n\r\n            checker = IChecker(_checker);\r\n    }\r\n\r\n    function () external payable {\r\n\r\n    }\r\n\r\n    function processGame() public payable onlyChecker {\r\n        rounds[currentRound].state = RoundState.WAIT_RESULT;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        iRNG(rng).update.value(msg.value)(currentRound, rounds[currentRound].nonce, 0);\r\n        currentRound = currentRound.add(1);\r\n        rounds[currentRound].startRoundTime = getCurrentTime();\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n    }\r\n\r\n    function startGame(uint _startPeriod) public payable onlyGameContract {\r\n        _startPeriod;\r\n        currentRound = 1;\r\n        uint time = getCurrentTime();\r\n        rounds[currentRound].startRoundTime = time;\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        emit GameStarted(time);\r\n        checker.update.value(msg.value)();\r\n    }\r\n\r\n    function setChecker(address _checker) public onlyOwner {\r\n        require(_checker != address(0), \"\");\r\n\r\n        checker = IChecker(_checker);\r\n    }\r\n\r\n    function processRound(uint _round, uint _randomNumber) public payable onlyRng returns (bool) {\r\n        rounds[_round].random = _randomNumber;\r\n        rounds[_round].winningTickets.push(_randomNumber.mod(rounds[_round].ticketsCount));\r\n\r\n        address winner = getWinner(\r\n            _round,\r\n            0,\r\n            (rounds[_round].tickets.length).sub(1),\r\n            rounds[_round].winningTickets[0]\r\n        );\r\n\r\n        rounds[_round].winners.push(winner);\r\n        rounds[_round].winnersFunds[winner] = rounds[_round].roundFunds;\r\n        rounds[_round].state = RoundState.SUCCESS;\r\n\r\n        emit RoundStateChanged(_round, rounds[_round].state);\r\n        emit RoundProcecced(_round, rounds[_round].winners, rounds[_round].winningTickets, rounds[_round].roundFunds);\r\n\r\n        return true;\r\n    }\r\n\r\n    function buyTickets(address _participant) public payable onlyGameContract {\r\n        require(msg.value > 0, \"\");\r\n\r\n        uint ticketsCount = msg.value.div(ticketPrice);\r\n        addParticipant(_participant, ticketsCount);\r\n\r\n        updateRoundFundsAndParticipants(_participant, msg.value);\r\n    }\r\n}\r\n\r\n\r\n// Developer @gogol\r\n// Design @chechenets\r\n// Architect @tugush","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getTicketsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundWinningTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hourlyGame\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_ticketsCount\",\"type\":\"uint256\"}],\"name\":\"buyBonusTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ticketPrice\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromRound\",\"type\":\"uint256\"},{\"name\":\"_toRound\",\"type\":\"uint256\"}],\"name\":\"getGain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"getParticipantFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareOfWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORACLIZE_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"buyTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"findWinTickets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_fromRound\",\"type\":\"uint256\"},{\"name\":\"_toRound\",\"type\":\"uint256\"}],\"name\":\"sendGain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NUMBER_OF_WINNERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"getWinningFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getRandomNumber\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"checkRoundState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORGANISER_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"organiser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SHARE_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"listOfManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_randomNumber\",\"type\":\"uint256\"}],\"name\":\"processRound\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTicketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_organiser\",\"type\":\"address\"}],\"name\":\"setOrganiser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"ticketsCount\",\"type\":\"uint256\"},{\"name\":\"participantCount\",\"type\":\"uint256\"},{\"name\":\"random\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"startRoundTime\",\"type\":\"uint256\"},{\"name\":\"roundFunds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rng\",\"type\":\"address\"},{\"name\":\"_hourlyGame\",\"type\":\"address\"},{\"name\":\"_management\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_random\",\"type\":\"uint256\"},{\"name\":\"_ticketsNum\",\"type\":\"uint256\"}],\"name\":\"_findWinTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_checker\",\"type\":\"address\"}],\"name\":\"setChecker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rng\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startPeriod\",\"type\":\"uint256\"}],\"name\":\"startGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROUND_FUND_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rng\",\"type\":\"address\"},{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_checker\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"RoundStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketsCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"}],\"name\":\"ParticipantAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"winningTickets\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"roundFunds\",\"type\":\"uint256\"}],\"name\":\"RoundProcecced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"}],\"name\":\"RefundIsSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"RefundIsFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toRound\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"TicketPriceChanged\",\"type\":\"event\"}]","ContractName":"JackPot","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bf43a3f0777bf04f9820380b6e4df6e692f7ddb7000000000000000000000000000000000000000000000000000000000000003d0000000000000000000000005943a67e4375b556df0856fdf08f972d02677b78","Library":"","SwarmSource":"bzzr://737f7d1fca3e0055e4df6d8d601c6ea2702d43fa35a55765a7768032598ac781"}]}