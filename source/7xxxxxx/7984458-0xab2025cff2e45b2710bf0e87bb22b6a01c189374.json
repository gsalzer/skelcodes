{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.1;\r\n\r\n// This token latch uses buy and sell orders to operate\r\n\r\n// Follows the Tr100c protocol\r\n\r\ncontract ERC20 {\r\n\tfunction totalSupply() public view returns (uint);\r\n\tfunction balanceOf(address tokenOwner) public view returns (uint balance);\r\n\tfunction allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n\tfunction transfer(address to, uint tokens) public returns (bool success);\r\n\tfunction approve(address spender, uint tokens) public returns (bool success);\r\n\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint tokens);\r\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ERC20TokenLatch {\r\n    \r\n    uint64 trade_increment = 1;\r\n\t\r\n\tuint public fee;\t    \t\t// fee for trades\r\n\t\r\n\taddress payable public owner;\r\n    \r\n    address payable public latched_contract;\r\n    \r\n    mapping(uint32 => address payable) public buy_order_owners;\r\n    mapping(uint32 => uint256)   public  buy_order_qty;\r\n    mapping(uint32 => uint64)   public  buy_order_price;\r\n    uint32 public num_buy_orders = 0;\r\n    uint32 public max_buy_price_idx;\r\n    \r\n    mapping(uint32 => address payable) public sell_order_owners;\r\n    mapping(uint32 => uint256)   public  sell_order_qty;\r\n    mapping(uint32 => uint64)   public  sell_order_price;\r\n    uint32 public num_sell_orders = 0;\r\n    uint32 public min_sell_price_idx;\r\n    \r\n    function rmBuyOrder(uint32 idx) private {\r\n        buy_order_owners[idx]=buy_order_owners[num_buy_orders];\r\n        buy_order_qty[idx]=buy_order_qty[num_buy_orders];\r\n        buy_order_price[idx]=buy_order_price[num_buy_orders];\r\n        num_buy_orders--;\r\n        if(max_buy_price_idx==idx){\r\n            max_buy_price_idx=0;\r\n            for(uint32 i=1;i<num_buy_orders;i++){\r\n                if(buy_order_price[max_buy_price_idx]<buy_order_price[i])max_buy_price_idx=i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function rmSellOrder(uint32 idx) private {\r\n        sell_order_owners[idx]=sell_order_owners[num_sell_orders];\r\n        sell_order_qty[idx]=sell_order_qty[num_sell_orders];\r\n        sell_order_price[idx]=sell_order_price[num_sell_orders];\r\n        num_sell_orders--;\r\n        if(min_sell_price_idx==idx){\r\n            min_sell_price_idx=0;\r\n            for(uint32 i=1;i<num_sell_orders;i++){\r\n                if(sell_order_price[min_sell_price_idx]>sell_order_price[i])min_sell_price_idx=i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function addBuyOrder(address payable adr, uint256 qty, uint64 price) private {\r\n        buy_order_owners[num_buy_orders] = adr;\r\n        buy_order_qty[num_buy_orders] = qty;\r\n        buy_order_price[num_buy_orders] = price;\r\n        if(price>buy_order_price[max_buy_price_idx])max_buy_price_idx = num_buy_orders;\r\n        if(num_buy_orders==0)max_buy_price_idx = 0;\r\n        num_buy_orders++;\r\n    }\r\n    \r\n    function addSellOrder(address payable adr, uint256 qty, uint64 price) private {\r\n        sell_order_owners[num_sell_orders] = adr;\r\n        sell_order_qty[num_sell_orders] = qty;\r\n        sell_order_price[num_sell_orders] = price;\r\n        if(price<sell_order_price[min_sell_price_idx])min_sell_price_idx = num_sell_orders;\r\n        if(num_sell_orders==0)min_sell_price_idx = 0;\r\n        num_sell_orders++;\r\n    }\r\n    \r\n    function maxBuyPrice() public view returns (uint64 price){\r\n        return buy_order_price[max_buy_price_idx];\r\n    }\r\n    \r\n    function minSellPrice() public view returns (uint64 price){\r\n        return sell_order_price[min_sell_price_idx];\r\n    }\r\n    \r\n    function getPrice() public view returns (uint64){\r\n        if(num_sell_orders==0){\r\n            if(num_buy_orders==0)return 1000;\r\n            else return maxBuyPrice();\r\n        }else if(num_buy_orders==0) return minSellPrice();\r\n        return (minSellPrice()+maxBuyPrice())/2;\r\n    }\r\n    \r\n    constructor(address payable latch) public {\r\n        latched_contract=latch;\r\n        owner = msg.sender;\r\n\t\tfee = .0001 ether;\r\n    }\r\n    \r\n    function balanceOf(address tokenOwner) public view returns (uint balance){\r\n        return ERC20(latched_contract).balanceOf(tokenOwner);\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint){\r\n        return ERC20(latched_contract).totalSupply();\r\n    }\r\n    \r\n    function transfer(address target, uint qty) private{\r\n        ERC20(latched_contract).transfer(target, qty);\r\n    }\r\n    \r\n\tfunction getFee() public view returns (uint){\r\n\t\treturn fee;\r\n\t}\r\n\t\r\n\tfunction getBuyPrice() public view returns (uint64){\r\n\t    if(num_buy_orders>0)return maxBuyPrice()+trade_increment;\r\n\t    else return getPrice();\r\n\t}\r\n\t\r\n\tfunction getSellPrice() public view returns (uint64){\r\n\t    if(num_sell_orders>0)return minSellPrice()-trade_increment;\r\n\t    else return getPrice();\r\n\t}\r\n\t\r\n\tfunction getSellReturn(uint amount) public view returns (uint){\t// ether for selling amount tokens\r\n\t    // computing fees for selling is difficult and expensive, so I'm not doing it.  Not worth it.\r\n\t\treturn (getSellPrice()*amount)/10000;\r\n\t}\r\n\t\r\n\tfunction getBuyCost(uint amount) public view returns (uint){\t\t// ether cost for buying amount tokens\r\n\t    return ((amount*getBuyPrice())/10000) + fee;\r\n\t}\r\n\t\r\n\tfunction buy(uint tokens)public payable{\r\n\t\tplaceBuyOrder(tokens, getBuyPrice());\r\n\t}\r\n\t\r\n\tfunction placeBuyOrder(uint tokens, uint64 price10000) public payable{\r\n\t    uint cost = fee + ((tokens*price10000)/10000);\r\n\t    require(msg.value>=cost);\r\n\t\t\r\n\t\t// handle fee and any extra funds\r\n\t\tmsg.sender.transfer(msg.value-cost);\r\n\t\towner.transfer(fee);\r\n\t\t\r\n\t    uint left = tokens;\r\n\t    \r\n\t\t// now try to fulfill the order\r\n\t\tfor(uint32 i=0;i<num_sell_orders;i++){\r\n\t\t    if(price10000<minSellPrice())\r\n\t\t        break; // cannot fulfill order because there is not a sell order that would satisfy\r\n\t\t    \r\n\t\t    if(sell_order_price[i]<=price10000){\r\n\t\t        // we can trade some!\r\n\t\t        if(sell_order_qty[i]>left){\r\n\t\t            // we can trade all!\r\n\t\t            sell_order_qty[i]-=left;\r\n\t\t            sell_order_owners[i].transfer((sell_order_price[i]*left)/10000);\r\n\t\t            transfer(msg.sender, left);\r\n\t\t            \r\n\t\t            // send the owner any extra funds\r\n\t\t            owner.transfer(((price10000-sell_order_price[i])*left)/10000);\r\n\t\t            \r\n\t\t            // order fully fulfilled\r\n\t\t            return;\r\n\t\t        }else{\r\n    \t\t        // will complete a single sell order, but buy order will have some left over\r\n    \t\t        uint qty = sell_order_qty[i];\r\n    \t\t        left-=qty;\r\n    \t            sell_order_owners[i].transfer((sell_order_price[i]*qty)/10000);\r\n    \t            transfer(msg.sender, qty);\r\n    \t            \r\n    \t            // send the owner any extra funds\r\n    \t            owner.transfer(((price10000-sell_order_price[i])*qty)/10000);\r\n    \t            \r\n    \t            // delete the order that was completed\r\n    \t            rmSellOrder(i);\r\n    \t\t    }\r\n\t\t    }\r\n\t\t}\r\n\t\t\r\n\t\t// if we are here then some of the order is left.  Place the order in the queue.\r\n\t\taddBuyOrder(msg.sender, left, price10000);\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction sell(uint tokens)public{\r\n\t    placeSellOrder(tokens, getSellPrice());\r\n\t}\r\n\t    \r\n\tfunction placeSellOrder(uint tokens, uint64 price10000) public payable{\r\n\t    require(ERC20(latched_contract).allowance(msg.sender, address(this))>=tokens);\r\n\t\t\r\n\t\t// handle fee and any extra funds\r\n\t\tERC20(latched_contract).transferFrom(msg.sender,address(this),tokens);\r\n\t\t\r\n\t\t// get info needed for trading\r\n\t    uint64 sell_price = price10000;\r\n\t    uint left = tokens;\r\n\t    \r\n\t\t// now try to fulfill the order\r\n\t\tfor(uint32 i=0;i<num_buy_orders;i++){\r\n\t\t    if(sell_price>maxBuyPrice())\r\n\t\t        break; // cannot fulfill order because there is not a buy order that would satisfy\r\n\t\t    \r\n\t\t    if(buy_order_price[i]>=sell_price){\r\n\t\t        // we can trade some!\r\n\t\t        if(buy_order_qty[i]>left){\r\n\t\t            // we can trade all!\r\n\t\t            buy_order_qty[i]-=left;\r\n\t\t            transfer(buy_order_owners[i],left);\r\n\t\t            msg.sender.transfer((sell_price*left)/10000);\r\n\t\t            \r\n\t\t            // send the owner any extra funds\r\n\t\t            owner.transfer(((buy_order_price[i]-sell_price)*left)/10000);\r\n\t\t            \r\n\t\t            // order fully fulfilled\r\n\t\t            return;\r\n\t\t        }else{\r\n    \t\t        // will complete a single sell order, but buy order will have some left over\r\n    \t\t        uint qty = buy_order_qty[i];\r\n    \t\t        left-=qty;\r\n    \t            \r\n\t\t            transfer(buy_order_owners[i],qty);\r\n    \t            msg.sender.transfer((sell_price*qty)/10000);\r\n    \t            \r\n    \t            // send the owner any extra funds\r\n    \t            owner.transfer(((buy_order_price[i]-sell_price)*qty)/10000);\r\n    \t            \r\n    \t            // delete the order that was completed\r\n    \t            rmBuyOrder(i);\r\n    \t\t    }\r\n\t\t    }\r\n\t\t}\r\n\t\t\r\n\t\t// if we are here then some of the order is left.  Place the order in the queue.\r\n\t\taddSellOrder(msg.sender, left, sell_price);\r\n\t}\r\n    \r\n    function canBuy(uint amount) public pure returns (bool possible){\t\t\t// returns true if this amount of token can be bought - does not account for Ethereum account balance\r\n        return true;\r\n    }\r\n    \r\n    function canSell(uint amount) public pure returns (bool possible){\t\t\t// returns true if this amount of token can be sold - does not account for token account balance\r\n\t    return true;\r\n    }\r\n\t\r\n\tfunction get_tradable() public view returns (uint){\r\n        return ERC20(latched_contract).totalSupply();\r\n    }\r\n\t\r\n\tfunction setFee(uint new_fee) public{\r\n\t    require(msg.sender==owner);\r\n\t    fee=new_fee;\r\n\t}\r\n\t\r\n\tfunction destroy() public {\r\n\t    require(msg.sender==owner);\r\n\t    require(address(this).balance<0.1 ether);\r\n\t    require(ERC20(latched_contract).balanceOf(address(this))==0);\r\n\t    selfdestruct(msg.sender);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latched_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_tradable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_buy_price_idx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"sell_order_owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canBuy\",\"outputs\":[{\"name\":\"possible\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"price10000\",\"type\":\"uint64\"}],\"name\":\"placeSellOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBuyPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"sell_order_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"buy_order_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"price10000\",\"type\":\"uint64\"}],\"name\":\"placeBuyOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"num_buy_orders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSellPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canSell\",\"outputs\":[{\"name\":\"possible\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"buy_order_qty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"buy_order_owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"sell_order_qty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_sell_price_idx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"num_sell_orders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"latch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ERC20TokenLatch","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d26114cd6ee289accf82350c8d8487fedb8a0c07","Library":"","SwarmSource":"bzzr://133381acafcf83df6d2852601cba9a1b8d7801aa7eb12cb60c540867c07b3320"}]}