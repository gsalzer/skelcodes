{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/SignedSafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must equal true).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC1594Capped.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\ninterface IERC1594Capped {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function cap() external view returns (uint256);\r\n    function totalRedeemed() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IRewards.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\ninterface IRewards {\r\n    event Deposited(address indexed from, uint amount);\r\n    event Withdrawn(address indexed from, uint amount);\r\n    event Reclaimed(uint amount);\r\n\r\n    function deposit(uint amount) external;\r\n    function withdraw() external;\r\n    function reclaimRewards() external;\r\n    function claimedRewards(address payee) external view returns (uint);\r\n    function unclaimedRewards(address payee) external view returns (uint);\r\n    function supply() external view returns (uint);\r\n    function isRunning() external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IRewardsUpdatable.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\ninterface IRewardsUpdatable {\r\n    event NotifierUpdated(address implementation);\r\n\r\n    function updateOnTransfer(address from, address to, uint amount) external returns (bool);\r\n    function updateOnBurn(address account, uint amount) external returns (bool);\r\n    function setRewardsNotifier(address notifier) external;\r\n}\r\n\r\n// File: contracts/interfaces/IRewardable.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\ninterface IRewardable {\r\n    event RewardsUpdated(address implementation);\r\n\r\n    function setRewards(IRewardsUpdatable rewards) external;\r\n}\r\n\r\n// File: contracts/roles/RewarderRole.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n// @notice Rewarders are capable of managing the Rewards contract and depositing PAY rewards.\r\ncontract RewarderRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event RewarderAdded(address indexed account);\r\n    event RewarderRemoved(address indexed account);\r\n\r\n    Roles.Role internal _rewarders;\r\n\r\n    modifier onlyRewarder() {\r\n        require(isRewarder(msg.sender), \"Only Rewarders can execute this function.\");\r\n        _;\r\n    }\r\n\r\n    constructor() internal {\r\n        _addRewarder(msg.sender);\r\n    }    \r\n\r\n    function isRewarder(address account) public view returns (bool) {\r\n        return _rewarders.has(account);\r\n    }\r\n\r\n    function addRewarder(address account) public onlyRewarder {\r\n        _addRewarder(account);\r\n    }\r\n\r\n    function renounceRewarder() public {\r\n        _removeRewarder(msg.sender);\r\n    }\r\n  \r\n    function _addRewarder(address account) internal {\r\n        _rewarders.add(account);\r\n        emit RewarderAdded(account);\r\n    }\r\n\r\n    function _removeRewarder(address account) internal {\r\n        _rewarders.remove(account);\r\n        emit RewarderRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/roles/ModeratorRole.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n// @notice Moderators are able to modify whitelists and transfer permissions in Moderator contracts.\r\ncontract ModeratorRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event ModeratorAdded(address indexed account);\r\n    event ModeratorRemoved(address indexed account);\r\n\r\n    Roles.Role internal _moderators;\r\n\r\n    modifier onlyModerator() {\r\n        require(isModerator(msg.sender), \"Only Moderators can execute this function.\");\r\n        _;\r\n    }\r\n\r\n    constructor() internal {\r\n        _addModerator(msg.sender);\r\n    }\r\n\r\n    function isModerator(address account) public view returns (bool) {\r\n        return _moderators.has(account);\r\n    }\r\n\r\n    function addModerator(address account) public onlyModerator {\r\n        _addModerator(account);\r\n    }\r\n\r\n    function renounceModerator() public {\r\n        _removeModerator(msg.sender);\r\n    }    \r\n\r\n    function _addModerator(address account) internal {\r\n        _moderators.add(account);\r\n        emit ModeratorAdded(account);\r\n    }    \r\n\r\n    function _removeModerator(address account) internal {\r\n        _moderators.remove(account);\r\n        emit ModeratorRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Whitelistable.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\ncontract Whitelistable is ModeratorRole {\r\n    event Whitelisted(address account);\r\n    event Unwhitelisted(address account);\r\n\r\n    mapping (address => bool) public isWhitelisted;\r\n\r\n    modifier onlyWhitelisted(address account) {\r\n        require(isWhitelisted[account], \"Account is not whitelisted.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotWhitelisted(address account) {\r\n        require(!isWhitelisted[account], \"Account is whitelisted.\");\r\n        _;\r\n    }\r\n\r\n    function whitelist(address account) external onlyModerator {\r\n        require(account != address(0), \"Cannot whitelist zero address.\");\r\n        require(account != msg.sender, \"Cannot whitelist self.\");\r\n        require(!isWhitelisted[account], \"Address already whitelisted.\");\r\n        isWhitelisted[account] = true;\r\n        emit Whitelisted(account);\r\n    }\r\n\r\n    function unwhitelist(address account) external onlyModerator {\r\n        require(account != address(0), \"Cannot unwhitelist zero address.\");\r\n        require(account != msg.sender, \"Cannot unwhitelist self.\");\r\n        require(isWhitelisted[account], \"Address not whitelisted.\");\r\n        isWhitelisted[account] = false;\r\n        emit Unwhitelisted(account);\r\n    }\r\n}\r\n\r\n// File: contracts/rewards/Rewards.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @notice This contract determines the amount of rewards each user is entitled to and allows users to withdraw their rewards.\r\n* @dev The rewards (in the form of a 'rewardsToken') are calculated based on a percentage ownership of a 'rewardableToken'.\r\n* The rewards calculation takes into account token movements using a 'damping' factor.\r\n* This contract makes use of pull payments over push payments to avoid DoS vulnerabilities.\r\n*/\r\ncontract Rewards is IRewards, IRewardsUpdatable, RewarderRole, Pausable, Ownable, ReentrancyGuard, Whitelistable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n    using SignedSafeMath for int;\r\n\r\n    IERC1594Capped private rewardableToken; // Rewardable tokens gives rewards when held.\r\n    IERC20 private rewardsToken; // Rewards tokens are given out as rewards.\r\n    address private rewardsNotifier; // Contract address where token movements are broadcast from.\r\n\r\n    bool public isRunning = true;\r\n    uint public maxShares; // Total TENX cap. Constant amount.\r\n    uint public totalRewards; // The current size of the global pool of PAY rewards. Can decrease because of TENX burning.\r\n    uint public totalDepositedRewards; // Total PAY rewards deposited for users so far. Monotonically increasing.\r\n    uint public totalClaimedRewards; // Amount of rewards claimed by users so far. Monotonically increasing.\r\n    mapping(address => int) private _dampings; // Balancing factor to account for rewardable token movements.\r\n    mapping(address => uint) public claimedRewards; // Claimed PAY rewards per user.\r\n\r\n    event Deposited(address indexed from, uint amount);\r\n    event Withdrawn(address indexed from, uint amount);\r\n    event Reclaimed(uint amount);\r\n    event NotifierUpdated(address implementation);\r\n\r\n    constructor(IERC1594Capped _rewardableToken, IERC20 _rewardsToken) public {\r\n        uint _cap = _rewardableToken.cap();\r\n        require(_cap != 0, \"Shares token cap must be non-zero.\");\r\n        maxShares = _cap;\r\n        rewardableToken = _rewardableToken;\r\n        rewardsToken = _rewardsToken;\r\n        rewardsNotifier = address(_rewardableToken);\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to check that functions are only callable by a predefined address.\r\n    */   \r\n    modifier onlyRewardsNotifier() {\r\n        require(msg.sender == rewardsNotifier, \"Can only be called by the rewards notifier contract.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to check that the Rewards contract is currently running.\r\n    */\r\n    modifier whenRunning() {\r\n        require(isRunning, \"Rewards contract has stopped running.\");\r\n        _;\r\n    }\r\n\r\n    function () external payable { // Ether fallback function\r\n        require(msg.value == 0, \"Received non-zero msg.value.\");\r\n        withdraw(); // solhint-disable-line\r\n    }\r\n\r\n    /**\r\n    * Releases a specified amount of rewards to all shares token holders.\r\n    * @dev The rewards each user is allocated to receive is calculated dynamically.\r\n    * Note that the contract needs to hold sufficient rewards token balance to disburse rewards.\r\n    * @param _amount Amount of reward tokens to allocate to token holders.\r\n    */\r\n    function deposit(uint _amount) external onlyRewarder whenRunning whenNotPaused {\r\n        require(_amount != 0, \"Deposit amount must non-zero.\");\r\n        totalDepositedRewards = totalDepositedRewards.add(_amount);\r\n        totalRewards = totalRewards.add(_amount);\r\n        address from = msg.sender;\r\n        emit Deposited(from, _amount);\r\n\r\n        rewardsToken.safeTransferFrom(msg.sender, address(this), _amount); // [External contract call to PAYToken]\r\n    }\r\n\r\n    /**\r\n    * @notice Links a RewardsNotifier contract to update this contract on token movements.\r\n    * @param _notifier Contract address.\r\n    */\r\n    function setRewardsNotifier(address _notifier) external onlyOwner {\r\n        require(address(_notifier) != address(0), \"Rewards address must not be a zero address.\");\r\n        require(Address.isContract(address(_notifier)), \"Address must point to a contract.\");\r\n        rewardsNotifier = _notifier;\r\n        emit NotifierUpdated(_notifier);\r\n    }\r\n\r\n    /**\r\n    * @notice Updates a damping factor to account for token transfers in the dynamic rewards calculation.\r\n    * @dev This function adds +X damping to senders and -X damping to recipients, where X is _dampingChange().\r\n    * This function is called in TENXToken `transfer()` and `transferFrom()`.\r\n    * @param _from Sender address\r\n    * @param _to Recipient address\r\n    * @param _value Token movement amount\r\n    */\r\n    function updateOnTransfer(address _from, address _to, uint _value) external onlyRewardsNotifier nonReentrant returns (bool) {\r\n        int fromUserShareChange = int(_value); // <_from> sends their _value to <_to>, change is positive\r\n        int fromDampingChange = _dampingChange(totalShares(), totalRewards, fromUserShareChange);\r\n\r\n        int toUserShareChange = int(_value).mul(-1); // <_to> receives _value from <_from>, change is negative\r\n        int toDampingChange = _dampingChange(totalShares(), totalRewards, toUserShareChange);\r\n\r\n        assert((fromDampingChange.add(toDampingChange)) == 0);\r\n\r\n        _dampings[_from] = damping(_from).add(fromDampingChange);\r\n        _dampings[_to] = damping(_to).add(toDampingChange);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates a damping factor to account for token butning in the dynamic rewards calculation.\r\n    * @param _account address\r\n    * @param _value Token burn amount\r\n    */\r\n    function updateOnBurn(address _account, uint _value) external onlyRewardsNotifier nonReentrant returns (bool) { \r\n        uint totalSharesBeforeBurn = totalShares().add(_value); // In Rewardable.sol, this is executed after the burn has deducted totalShares()\r\n        uint redeemableRewards = _value.mul(totalRewards).div(totalSharesBeforeBurn); // Calculate amount of rewards the burned amount is entitled to\r\n        totalRewards = totalRewards.sub(redeemableRewards); // Remove redeemable rewards from the global pool\r\n        _dampings[_account] = damping(_account).add(int(redeemableRewards)); // Only _account is able to withdraw the unclaimed redeemed rewards\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Emergency fallback to drain the contract's balance of PAY tokens.\r\n    */\r\n    function reclaimRewards() external onlyOwner {\r\n        uint256 balance = rewardsToken.balanceOf(address(this));\r\n        isRunning = false;\r\n        rewardsToken.safeTransfer(owner(), balance);\r\n        emit Reclaimed(balance);\r\n    }\r\n\r\n   /**\r\n    * @notice Withdraw your balance of PAY rewards.\r\n    * @dev Only the unclaimed rewards amount can be withdrawn by a user.\r\n    */\r\n    function withdraw() public whenRunning whenNotPaused onlyWhitelisted(msg.sender) nonReentrant {\r\n        address payee = msg.sender;\r\n        uint unclaimedReward = unclaimedRewards(payee);\r\n        require(unclaimedReward > 0, \"Unclaimed reward must be non-zero to withdraw.\");\r\n        require(supply() >= unclaimedReward, \"Rewards contract must have sufficient PAY to disburse.\");\r\n\r\n        claimedRewards[payee] = claimedRewards[payee].add(unclaimedReward); // Add amount to claimed rewards balance\r\n        totalClaimedRewards = totalClaimedRewards.add(unclaimedReward);\r\n        emit Withdrawn(payee, unclaimedReward);\r\n\r\n        // Send PAY reward to payee\r\n        rewardsToken.safeTransfer(payee, unclaimedReward); // [External contract call]\r\n    }\r\n\r\n    /**\r\n    * @notice Returns this contract's current reward token supply.\r\n    * @dev The contract must have sufficient PAY allowance to deposit() rewards.\r\n    * @return Total PAY balance of this contract\r\n    */\r\n    function supply() public view returns (uint) {\r\n        return rewardsToken.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n    * @notice Returns the reward model's denominator. Used to calculate user rewards.\r\n    * @dev The denominator is = INITIAL TOKEN CAP - TOTAL REWARDABLE TOKENS REDEEMED.\r\n    * @return denominator\r\n    */\r\n    function totalShares() public view returns (uint) {\r\n        uint totalRedeemed = rewardableToken.totalRedeemed();\r\n        return maxShares.sub(totalRedeemed);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns the amount of a user's unclaimed (= total allocated - claimed) rewards. \r\n    * @param _payee User address.\r\n    * @return total unclaimed rewards for user\r\n    */\r\n    function unclaimedRewards(address _payee) public view returns(uint) {\r\n        require(_payee != address(0), \"Payee must not be a zero address.\");\r\n        uint totalUserReward = totalUserRewards(_payee);\r\n        if (totalUserReward == uint(0)) {\r\n            return 0;\r\n        }\r\n\r\n        uint unclaimedReward = totalUserReward.sub(claimedRewards[_payee]);\r\n        return unclaimedReward;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns a user's total PAY rewards.\r\n    * @param _payee User address.\r\n    * @return total claimed + unclaimed rewards for user\r\n    */\r\n    function totalUserRewards(address _payee) internal view returns (uint) {\r\n        require(_payee != address(0), \"Payee must not be a zero address.\");\r\n        uint userShares = rewardableToken.balanceOf(_payee); // [External contract call]\r\n        int userDamping = damping(_payee);\r\n        uint result = _totalUserRewards(totalShares(), totalRewards, userShares, userDamping);\r\n        return result;\r\n    }    \r\n\r\n    /**\r\n    * @notice Calculate a user's damping factor change. \r\n    * @dev The damping factor is used to take into account token movements in the rewards calculation.\r\n    * dampingChange = total PAY rewards * percentage change in a user's TENX shares\r\n    * @param _totalShares Total TENX cap (constant ~200M.)\r\n    * @param _totalRewards The current size of the global pool of PAY rewards.\r\n    * @param _sharesChange The user's change in TENX balance. Can be positive or negative.\r\n    * @return damping change for a given change in tokens\r\n    */\r\n    function _dampingChange(\r\n        uint _totalShares,\r\n        uint _totalRewards,\r\n        int _sharesChange\r\n    ) internal pure returns (int) {\r\n        return int(_totalRewards).mul(_sharesChange).div(int(_totalShares));\r\n    }\r\n\r\n    /**\r\n    * @notice Calculates a user's total allocated (claimed + unclaimed) rewards.    \r\n    * @dev The user's total allocated rewards = (percentage of user's TENX shares * total PAY rewards) + user's damping factor\r\n    * @param _totalShares Total TENX cap (constant.)\r\n    * @param _totalRewards Total PAY rewards deposited so far.\r\n    * @param _userShares The user's TENX balance.\r\n    * @param _userDamping The user's damping factor.\r\n    * @return total claimed + unclaimed rewards for user\r\n    */\r\n    function _totalUserRewards(\r\n        uint _totalShares,\r\n        uint _totalRewards,\r\n        uint _userShares,\r\n        int _userDamping\r\n    ) internal pure returns (uint) {\r\n        uint maxUserReward = _userShares.mul(_totalRewards).div(_totalShares);\r\n        int userReward = int(maxUserReward).add(_userDamping);\r\n        uint result = (userReward > 0 ? uint(userReward) : 0);\r\n        return result;\r\n    }\r\n\r\n    function damping(address account) internal view returns (int) {\r\n        return _dampings[account];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"renounceModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_notifier\",\"type\":\"address\"}],\"name\":\"setRewardsNotifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceRewarder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateOnTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addRewarder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDepositedRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateOnBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isRewarder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"unclaimedRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unwhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaimedRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isModerator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rewardableToken\",\"type\":\"address\"},{\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"NotifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unwhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ModeratorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ModeratorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RewarderAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RewarderRemoved\",\"type\":\"event\"}]","ContractName":"Rewards","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000515ba0a2e286af10115284f151cf398688a69170000000000000000000000000b97048628db6b661d4c2aa833e95dbe1a905b280","Library":"","SwarmSource":"bzzr://b84c6b13272b04c34d9f14becc1ad8a82f2d4e9dbcc397a414a853d738dda5ff"}]}