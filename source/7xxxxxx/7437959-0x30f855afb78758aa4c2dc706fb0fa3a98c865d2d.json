{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\ninterface IOrbsVoting {\r\n\r\n    event VoteOut(address indexed voter, address[] validators, uint voteCounter);\r\n    event Delegate(\r\n        address indexed delegator,\r\n        address indexed to,\r\n        uint delegationCounter\r\n    );\r\n    event Undelegate(address indexed delegator, uint delegationCounter);\r\n\r\n    /// @dev Voting method to select which validators you want to vote out in this election period.\r\n    /// @param validators address[] an array of validators addresses you want to vote out. In case you want to vote, but not vote out anyone, send an empty array.\r\n    function voteOut(address[] validators) external;\r\n\r\n    /// @dev Delegation method to select who you would like to delegate your stake to.\r\n    /// @param to address the address, you want to delegate your stake to. If you want to cancel a delegation - delegate to yourself to yourself.\r\n    function delegate(address to) external;\r\n\r\n    /// @dev Delegation method to select who you would like to delegate your stake to.\r\n    function undelegate() external;\r\n\r\n    /// @dev returns vote pair - validators list and the block number the vote was set.\r\n    /// @param guardian address the address of the guardian\r\n    function getCurrentVote(address guardian)\r\n        external\r\n        view\r\n        returns (address[] validators, uint blockNumber);\r\n\r\n    /// @dev returns vote pair - validators list and the block number the vote was set.\r\n    ///      same as getCurrentVote but returns addresses represented as byte20.\r\n    function getCurrentVoteBytes20(address guardian)\r\n        external\r\n        view\r\n        returns (bytes20[] validatorsBytes20, uint blockNumber);\r\n\r\n    /// @dev returns the address to which the delegator has delegated the stake\r\n    /// @param delegator address the address of the delegator\r\n    function getCurrentDelegation(address delegator)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n\r\ncontract OrbsVoting is IOrbsVoting {\r\n\r\n    // A vote is a pair of block number and list of validators. The vote's block\r\n    // number is used to determine the vote qualification for an election event.\r\n    struct VotingRecord {\r\n        uint blockNumber;\r\n        address[] validators;\r\n    }\r\n\r\n    // The version of the current Voting smart contract.\r\n    uint public constant VERSION = 1;\r\n\r\n    // Vars to see that voting and delegating is moving forward. Is used to emit\r\n    // events to test for completeness.\r\n    uint internal voteCounter;\r\n    uint internal delegationCounter;\r\n\r\n    // The amount of validators you can vote out in each election round. This will be set to 3 in the construction.\r\n    uint public maxVoteOutCount;\r\n\r\n    // Internal mappings to keep track of the votes and delegations.\r\n    mapping(address => VotingRecord) internal votes;\r\n    mapping(address => address) internal delegations;\r\n\r\n    /// @dev Constructor that initializes the Voting contract. maxVoteOutCount will be set to 3.\r\n    constructor(uint maxVoteOutCount_) public {\r\n        require(maxVoteOutCount_ > 0, \"maxVoteOutCount_ must be positive\");\r\n        maxVoteOutCount = maxVoteOutCount_;\r\n    }\r\n\r\n    /// @dev Voting method to select which validators you want to vote out in this election period.\r\n    /// @param validators address[] an array of validators addresses you want to vote out. In case you want to vote, but not vote out anyone, send an empty array.\r\n    function voteOut(address[] validators) external {\r\n        address sender = msg.sender;\r\n        require(validators.length <= maxVoteOutCount, \"Validators list is over the allowed length\");\r\n        sanitizeValidators(validators);\r\n\r\n        voteCounter++;\r\n\r\n        votes[sender] = VotingRecord({\r\n            blockNumber: block.number,\r\n            validators: validators\r\n        });\r\n\r\n        emit VoteOut(sender, validators, voteCounter);\r\n    }\r\n\r\n    /// @dev Delegation method to select who you would like to delegate your stake to.\r\n    /// @param to address the address, you want to delegate your stake to. If you want to cancel a delegation - delegate to yourself to yourself.\r\n    function delegate(address to) external {\r\n        address sender = msg.sender;\r\n        require(to != address(0), \"must delegate to non 0\");\r\n        require(sender != to , \"cant delegate to yourself\");\r\n\r\n        delegationCounter++;\r\n\r\n        delegations[sender] = to;\r\n\r\n        emit Delegate(sender, to, delegationCounter);\r\n    }\r\n\r\n    /// @dev Delegation method to select who you would like to delegate your stake to.\r\n    function undelegate() external {\r\n        address sender = msg.sender;\r\n        delegationCounter++;\r\n\r\n        delete delegations[sender];\r\n\r\n        emit Delegate(sender, sender, delegationCounter);\r\n        emit Undelegate(sender, delegationCounter);\r\n    }\r\n\r\n    /// @dev returns vote pair - validators list and the block number the vote was set.\r\n    ///      same as getCurrentVote but returns addresses represented as byte20.\r\n    function getCurrentVoteBytes20(address guardian)\r\n        public\r\n        view\r\n        returns (bytes20[] memory validatorsBytes20, uint blockNumber)\r\n    {\r\n        address[] memory validatorAddresses;\r\n        (validatorAddresses, blockNumber) = getCurrentVote(guardian);\r\n\r\n        uint validatorAddressesLength = validatorAddresses.length;\r\n\r\n        validatorsBytes20 = new bytes20[](validatorAddressesLength);\r\n\r\n        for (uint i = 0; i < validatorAddressesLength; i++) {\r\n            validatorsBytes20[i] = bytes20(validatorAddresses[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev returns the address to which the delegator has delegated the stake\r\n    /// @param delegator address the address of the delegator\r\n    function getCurrentDelegation(address delegator)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return delegations[delegator];\r\n    }\r\n\r\n    /// @dev returns vote pair - validators list and the block number the vote was set.\r\n    /// @param guardian address the address of the guardian\r\n    function getCurrentVote(address guardian)\r\n        public\r\n        view\r\n        returns (address[] memory validators, uint blockNumber)\r\n    {\r\n        VotingRecord storage lastVote = votes[guardian];\r\n\r\n        blockNumber = lastVote.blockNumber;\r\n        validators = lastVote.validators;\r\n    }\r\n\r\n    /// @dev check that the validators array is unique and non zero.\r\n    /// @param validators address[]\r\n    function sanitizeValidators(address[] validators)\r\n        private\r\n        pure\r\n    {\r\n        uint validatorsLength = validators.length;\r\n        for (uint i = 0; i < validatorsLength; i++) {\r\n            require(validators[i] != address(0), \"All validator addresses must be non 0\");\r\n            for (uint j = i + 1; j < validatorsLength; j++) {\r\n                require(validators[j] != validators[i], \"Duplicate Validators\");\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"getCurrentDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"undelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"getCurrentVote\",\"outputs\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxVoteOutCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"getCurrentVoteBytes20\",\"outputs\":[{\"name\":\"validatorsBytes20\",\"type\":\"bytes20[]\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validators\",\"type\":\"address[]\"}],\"name\":\"voteOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"maxVoteOutCount_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"validators\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"voteCounter\",\"type\":\"uint256\"}],\"name\":\"VoteOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegationCounter\",\"type\":\"uint256\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegationCounter\",\"type\":\"uint256\"}],\"name\":\"Undelegate\",\"type\":\"event\"}]","ContractName":"OrbsVoting","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000003","Library":"","SwarmSource":"bzzr://3401dc80c14277da0efb385b202efc13d277040b473d9f9273cd7d8f2f7c66ba"}]}