{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.4;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title MultiOwnable\r\n *\r\n * @dev Require majority approval of multiple owners to use and access to features\r\n *      when restrictions on access to critical functions are required.\r\n *\r\n */\r\n\r\ncontract MultiOwnable {\r\n    using SafeMath for uint8;\r\n\r\n    struct CommitteeStatusPack{\r\n      /**\r\n       * Key informations for decisions.\r\n       * To save some gas, choosing the struct.\r\n       */\r\n        uint8 numOfOwners;\r\n        uint8 numOfVotes;\r\n        uint8 numOfMinOwners;\r\n        bytes proposedFuncData;\r\n    }\r\n    CommitteeStatusPack public committeeStatus;\r\n\r\n    address[] public ballot; // To make sure if it already was voted\r\n    mapping(address => bool) public owner;\r\n\r\n    event Vote(address indexed proposer, bytes indexed proposedFuncData);\r\n    event Propose(address indexed proposer, bytes indexed proposedFuncData);\r\n    event Dismiss(address indexed proposer, bytes indexed proposedFuncData);\r\n    event AddedOwner(address newOwner);\r\n    event RemovedOwner(address removedOwner);\r\n    event TransferOwnership(address from, address to);\r\n\r\n\r\n    /**\r\n     * Organize initial committee.\r\n     *\r\n     * @notice committee must be 3 at least.\r\n     *         you have to use this contract to be inherited because it is internal.\r\n     *\r\n     * @param _coOwner1 _coOwner2 _coOwner3 _coOwner4 _coOwner5 committee members\r\n     */\r\n    constructor(address _coOwner1, address _coOwner2, address _coOwner3, address _coOwner4, address _coOwner5) internal {\r\n        require(_coOwner1 != address(0x0) &&\r\n                _coOwner2 != address(0x0) &&\r\n                _coOwner3 != address(0x0) &&\r\n                _coOwner4 != address(0x0) &&\r\n                _coOwner5 != address(0x0));\r\n        require(_coOwner1 != _coOwner2 &&\r\n                _coOwner1 != _coOwner3 &&\r\n                _coOwner1 != _coOwner4 &&\r\n                _coOwner1 != _coOwner5 &&\r\n                _coOwner2 != _coOwner3 &&\r\n                _coOwner2 != _coOwner4 &&\r\n                _coOwner2 != _coOwner5 &&\r\n                _coOwner3 != _coOwner4 &&\r\n                _coOwner3 != _coOwner5 &&\r\n                _coOwner4 != _coOwner5); // SmartDec Recommendations\r\n        owner[_coOwner1] = true;\r\n        owner[_coOwner2] = true;\r\n        owner[_coOwner3] = true;\r\n        owner[_coOwner4] = true;\r\n        owner[_coOwner5] = true;\r\n        committeeStatus.numOfOwners = 5;\r\n        committeeStatus.numOfMinOwners = 5;\r\n        emit AddedOwner(_coOwner1);\r\n        emit AddedOwner(_coOwner2);\r\n        emit AddedOwner(_coOwner3);\r\n        emit AddedOwner(_coOwner4);\r\n        emit AddedOwner(_coOwner5);\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(owner[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Pre-check if it's decided by committee\r\n     *\r\n     * @notice If there is a majority approval,\r\n     *         the function with this modifier will not be executed.\r\n     */\r\n    modifier committeeApproved() {\r\n      /* check if proposed Function Name and real function Name are correct */\r\n      require( keccak256(committeeStatus.proposedFuncData) == keccak256(msg.data) ); // SmartDec Recommendations\r\n\r\n      /* To check majority */\r\n      require(committeeStatus.numOfVotes > committeeStatus.numOfOwners.div(2));\r\n      _;\r\n      _dismiss(); //Once a commission-approved proposal is made, the proposal is initialized.\r\n    }\r\n\r\n\r\n    /**\r\n     * Suggest the functions you want to use.\r\n     *\r\n     * @notice To use some importan functions, propose function must be done first and voted.\r\n     */\r\n    function propose(bytes memory _targetFuncData) onlyOwner public {\r\n      /* Check if there're any ongoing proposals */\r\n      require(committeeStatus.numOfVotes == 0);\r\n      require(committeeStatus.proposedFuncData.length == 0);\r\n\r\n      /* regist function informations that proposer want to run */\r\n      committeeStatus.proposedFuncData = _targetFuncData;\r\n      emit Propose(msg.sender, _targetFuncData);\r\n    }\r\n\r\n    /**\r\n     * Proposal is withdrawn\r\n     *\r\n     * @notice When the proposed function is no longer used or deprecated,\r\n     *         proposal is discarded\r\n     */\r\n    function dismiss() onlyOwner public {\r\n      _dismiss();\r\n    }\r\n\r\n    /**\r\n     * Suggest the functions you want to use.\r\n     *\r\n     * @notice 'dismiss' is executed even after successfully executing the proposed function.\r\n     *          If 'msg.sender' want to pass permission, he can't pass the 'committeeApproved' modifier.\r\n     *          internal functions are required to enable this.\r\n     */\r\n\r\n    function _dismiss() internal {\r\n      emit Dismiss(msg.sender, committeeStatus.proposedFuncData);\r\n      committeeStatus.numOfVotes = 0;\r\n      committeeStatus.proposedFuncData = \"\";\r\n      delete ballot;\r\n    }\r\n\r\n\r\n    /**\r\n     * Owners vote for proposed item\r\n     *\r\n     * @notice if only there're proposals, 'vote' is processed.\r\n     *         the result must be majority.\r\n     *         one ticket for each owner.\r\n     */\r\n\r\n    function vote() onlyOwner public {\r\n      // Check duplicated voting list.\r\n      uint length = ballot.length; // SmartDec Recommendations\r\n      for(uint i=0; i<length; i++) // SmartDec Recommendations\r\n        require(ballot[i] != msg.sender);\r\n\r\n      //onlyOnwers can vote, if there's ongoing proposal.\r\n      require( committeeStatus.proposedFuncData.length != 0 );\r\n\r\n      //Check, if everyone voted.\r\n      //require(committeeStatus.numOfOwners > committeeStatus.numOfVotes); // SmartDec Recommendations\r\n      committeeStatus.numOfVotes++;\r\n      ballot.push(msg.sender);\r\n      emit Vote(msg.sender, committeeStatus.proposedFuncData);\r\n    }\r\n\r\n\r\n    /**\r\n     * Existing owner transfers permissions to new owner.\r\n     *\r\n     * @notice It transfers authority to the person who was not the owner.\r\n     *           Approval from the committee is required.\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner committeeApproved public {\r\n        require( _newOwner != address(0x0) ); // callisto recommendation\r\n        require( owner[_newOwner] == false );\r\n        owner[msg.sender] = false;\r\n        owner[_newOwner] = true;\r\n        emit TransferOwnership(msg.sender, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * Add new Owner to committee\r\n     *\r\n     * @notice Approval from the committee is required.\r\n     *\r\n     */\r\n    function addOwner(address _newOwner) onlyOwner committeeApproved public {\r\n        require( _newOwner != address(0x0) );\r\n        require( owner[_newOwner] != true );\r\n        owner[_newOwner] = true;\r\n        committeeStatus.numOfOwners++;\r\n        emit AddedOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * Remove the Owner from committee\r\n     *\r\n     * @notice Approval from the committee is required.\r\n     *\r\n     */\r\n    function removeOwner(address _toRemove) onlyOwner committeeApproved public {\r\n        require( _toRemove != address(0x0) );\r\n        require( owner[_toRemove] == true );\r\n        require( committeeStatus.numOfOwners > committeeStatus.numOfMinOwners ); // must keep Number of Minimum Owners at least.\r\n        owner[_toRemove] = false;\r\n        committeeStatus.numOfOwners--;\r\n        emit RemovedOwner(_toRemove);\r\n    }\r\n}\r\n\r\ncontract Pausable is MultiOwnable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool internal paused;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    modifier noReentrancy() {\r\n        require(!paused);\r\n        paused = true;\r\n        _;\r\n        paused = false;\r\n    }\r\n\r\n    /* When you discover your smart contract is under attack, you can buy time to upgrade the contract by\r\n       immediately pausing the contract.\r\n     */\r\n    function pause() public onlyOwner committeeApproved whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner committeeApproved whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n * Contract Managing TokenExchanger's address used by ProxyNemodax\r\n */\r\ncontract RunningContractManager is Pausable {\r\n    address public implementation; //SmartDec Recommendations\r\n\r\n    event Upgraded(address indexed newContract);\r\n\r\n    function upgrade(address _newAddr) onlyOwner committeeApproved external {\r\n        require(implementation != _newAddr);\r\n        implementation = _newAddr;\r\n        emit Upgraded(_newAddr); // SmartDec Recommendations\r\n    }\r\n\r\n    /* SmartDec Recommendations\r\n    function runningAddress() onlyOwner external view returns (address){\r\n        return implementation;\r\n    }\r\n    */\r\n}\r\n\r\n\r\n\r\n/**\r\n * NemoLab ERC20 Token\r\n * Written by Shin HyunJae\r\n * version 12\r\n */\r\ncontract TokenERC20 is RunningContractManager {\r\n    using SafeMath for uint256;\r\n\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    //mapping (address => bool) public frozenAccount; // SmartDec Recommendations\r\n    mapping (address => uint256) public frozenExpired;\r\n\r\n    //bool private initialized = false;\r\n    bool private initialized; // SmartDec Recommendations\r\n\r\n    /**\r\n     * This is area for some variables to add.\r\n     * Please add variables from the end of pre-declared variables\r\n     * if you would have added some variables and re-deployed the contract,\r\n     * tokenPerEth would get garbage value. so please reset tokenPerEth variable\r\n     *\r\n     * uint256 something..;\r\n     */\r\n\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event LastBalance(address indexed account, uint256 value);\r\n\r\n    // This notifies clients about the allowance of balance\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    // event Burn(address indexed from, uint256 value); // callisto recommendation\r\n\r\n    // This notifies clients about the freezing address\r\n    //event FrozenFunds(address target, bool frozen); // callisto recommendation\r\n    event FrozenFunds(address target, uint256 expirationDate); // SmartDec Recommendations\r\n\r\n    /**\r\n     * Initialize Token Function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n\r\n    function initToken(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint256 _initialSupply,\r\n        address _marketSaleManager,\r\n        address _serviceOperationManager,\r\n        address _dividendManager,\r\n        address _incentiveManager,\r\n        address _reserveFundManager\r\n    ) internal onlyOwner committeeApproved {\r\n        require( initialized == false );\r\n        require(_initialSupply > 0 && _initialSupply <= 2**uint256(184)); // [2019.03.05] Fixed for Mythril Vulerablity SWC ID:101 => _initialSupply <= 2^184 <= (2^256 / 10^18)\r\n\r\n        name = _tokenName;                                       // Set the name for display purposes\r\n        symbol = _tokenSymbol;                                   // Set the symbol for display purposes\r\n        //totalSupply = convertToDecimalUnits(_initialSupply);     // Update total supply with the decimal amount\r\n\r\n        /*balances[msg.sender] = totalSupply;                     // Give the creator all initial tokens\r\n        emit Transfer(address(this), address(0), totalSupply);\r\n        emit LastBalance(address(this), 0);\r\n        emit LastBalance(msg.sender, totalSupply);*/\r\n\r\n        // SmartDec Recommendations\r\n        uint256 tempSupply = convertToDecimalUnits(_initialSupply);\r\n\r\n        uint256 dividendBalance = tempSupply.div(10);               // dividendBalance = 10%\r\n        uint256 reserveFundBalance = dividendBalance;               // reserveFundBalance = 10%\r\n        uint256 marketSaleBalance = tempSupply.div(5);              // marketSaleBalance = 20%\r\n        uint256 serviceOperationBalance = marketSaleBalance.mul(2); // serviceOperationBalance = 40%\r\n        uint256 incentiveBalance = marketSaleBalance;               // incentiveBalance = 20%\r\n\r\n        balances[_marketSaleManager] = marketSaleBalance;\r\n        balances[_serviceOperationManager] = serviceOperationBalance;\r\n        balances[_dividendManager] = dividendBalance;\r\n        balances[_incentiveManager] = incentiveBalance;\r\n        balances[_reserveFundManager] = reserveFundBalance;\r\n\r\n        totalSupply = tempSupply;\r\n\r\n        emit Transfer(address(0), _marketSaleManager, marketSaleBalance);\r\n        emit Transfer(address(0), _serviceOperationManager, serviceOperationBalance);\r\n        emit Transfer(address(0), _dividendManager, dividendBalance);\r\n        emit Transfer(address(0), _incentiveManager, incentiveBalance);\r\n        emit Transfer(address(0), _reserveFundManager, reserveFundBalance);\r\n\r\n        emit LastBalance(address(this), 0);\r\n        emit LastBalance(_marketSaleManager, marketSaleBalance);\r\n        emit LastBalance(_serviceOperationManager, serviceOperationBalance);\r\n        emit LastBalance(_dividendManager, dividendBalance);\r\n        emit LastBalance(_incentiveManager, incentiveBalance);\r\n        emit LastBalance(_reserveFundManager, reserveFundBalance);\r\n\r\n        assert( tempSupply ==\r\n          marketSaleBalance.add(serviceOperationBalance).\r\n                            add(dividendBalance).\r\n                            add(incentiveBalance).\r\n                            add(reserveFundBalance)\r\n        );\r\n\r\n\r\n        initialized = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Convert tokens units to token decimal units\r\n     *\r\n     * @param _value Tokens units without decimal units\r\n     */\r\n    function convertToDecimalUnits(uint256 _value) internal view returns (uint256 value) {\r\n        value = _value.mul(10 ** uint256(decimals));\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Get tokens balance\r\n     *\r\n     * @notice Query tokens balance of the _account\r\n     *\r\n     * @param _account Account address to query tokens balance\r\n     */\r\n    function balanceOf(address _account) public view returns (uint256 balance) {\r\n        balance = balances[_account];\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * Get allowed tokens balance\r\n     *\r\n     * @notice Query tokens balance allowed to _spender\r\n     *\r\n     * @param _owner Owner address to query tokens balance\r\n     * @param _spender The address allowed tokens balance\r\n     */\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\r\n        remaining = allowed[_owner][_spender];\r\n        return remaining;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n        require(_to != address(0x0));                                            // Prevent transfer to 0x0 address.\r\n        require(balances[_from] >= _value);                             // Check if the sender has enough\r\n        if(frozenExpired[_from] != 0 ){                                 // Check if sender is frozen\r\n            require(block.timestamp > frozenExpired[_from]);\r\n            _unfreezeAccount(_from);\r\n        }\r\n        if(frozenExpired[_to] != 0 ){                                   // Check if recipient is frozen\r\n            require(block.timestamp > frozenExpired[_to]);\r\n            _unfreezeAccount(_to);\r\n        }\r\n\r\n        uint256 previousBalances = balances[_from].add(balances[_to]);  // Save this for an assertion in the future\r\n\r\n        balances[_from] = balances[_from].sub(_value);                  // Subtract from the sender\r\n        balances[_to] = balances[_to].add(_value);                      // Add the same to the recipient\r\n        emit Transfer(_from, _to, _value);\r\n        emit LastBalance(_from, balances[_from]);\r\n        emit LastBalance(_to, balances[_to]);\r\n\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * @notice Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public noReentrancy returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        success = true;\r\n        return success;\r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public noReentrancy returns (bool success) {\r\n        require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        success = true;\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * Internal approve, only can be called by this contract\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function _approve(address _spender, uint256 _value) internal returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        success = true;\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public noReentrancy returns (bool success) {\r\n        success = _approve(_spender, _value);\r\n        return success;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n      allowed[msg.sender][_spender] = (\r\n        allowed[msg.sender][_spender].add(_addedValue));\r\n      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n      uint256 oldValue = allowed[msg.sender][_spender];\r\n      if (_subtractedValue >= oldValue) {\r\n        allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n      }\r\n      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n\r\n    /// @notice `freeze? Prevent` `target` from sending & receiving tokens\r\n    /// @param target Address to be frozen\r\n    function freezeAccount(address target, uint256 freezeExpiration) onlyOwner committeeApproved public {\r\n        frozenExpired[target] = freezeExpiration;\r\n        //emit FrozenFunds(target, true);\r\n        emit FrozenFunds(target, freezeExpiration); // SmartDec Recommendations\r\n    }\r\n\r\n    /// @notice  `freeze? Allow` `target` from sending & receiving tokens\r\n    /// @notice if expiration date was over, when this is called with transfer transaction, auto-unfreeze is occurred without committeeApproved\r\n    ///         the reason why it's separated from wrapper function.\r\n    /// @param target Address to be unfrozen\r\n    function _unfreezeAccount(address target) internal returns (bool success) {\r\n        frozenExpired[target] = 0;\r\n        //emit FrozenFunds(target, false);\r\n        emit FrozenFunds(target, 0); // SmartDec Recommendations\r\n        success = true;\r\n        return success;\r\n    }\r\n\r\n    /// @notice _unfreezeAccount wrapper function.\r\n    /// @param target Address to be unfrozen\r\n    function unfreezeAccount(address target) onlyOwner committeeApproved public returns(bool success) {\r\n        success = _unfreezeAccount(target);\r\n        return success;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title TokenExchanger\r\n * @notice This is for exchange between Ether and 'Nemo' token\r\n *          It won't be needed after being listed on the exchange.\r\n */\r\n\r\ncontract TokenExchanger is TokenERC20{\r\n  using SafeMath for uint256;\r\n\r\n    uint256 internal tokenPerEth;\r\n    bool public opened;\r\n\r\n    event ExchangeEtherToToken(address indexed from, uint256 etherValue, uint256 tokenPerEth);\r\n    event ExchangeTokenToEther(address indexed from, uint256 etherValue, uint256 tokenPerEth);\r\n    event WithdrawToken(address indexed to, uint256 value);\r\n    event WithdrawEther(address indexed to, uint256 value);\r\n    event SetExchangeRate(address indexed from, uint256 tokenPerEth);\r\n\r\n\r\n    constructor(address _coOwner1,\r\n                address _coOwner2,\r\n                address _coOwner3,\r\n                address _coOwner4,\r\n                address _coOwner5)\r\n        MultiOwnable( _coOwner1, _coOwner2, _coOwner3, _coOwner4, _coOwner5) public { opened = true; }\r\n\r\n    /**\r\n     * Initialize Exchanger Function\r\n     *\r\n     * Initialize Exchanger contract with tokenPerEth\r\n     * and Initialize NemoCoin by calling initToken\r\n     * It would call initToken in TokenERC20 with _tokenName, _tokenSymbol, _initalSupply\r\n     * Last five arguments are manager account to supply currency (_marketSaleManager, _serviceOperationManager, _dividendManager, _incentiveManager, _reserveFundManager)\r\n     *\r\n     */\r\n    function initExchanger(\r\n        string calldata _tokenName,\r\n        string calldata _tokenSymbol,\r\n        uint256 _initialSupply,\r\n        uint256 _tokenPerEth,\r\n        address _marketSaleManager,\r\n        address _serviceOperationManager,\r\n        address _dividendManager,\r\n        address _incentiveManager,\r\n        address _reserveFundManager\r\n    ) external onlyOwner committeeApproved {\r\n        require(opened);\r\n        //require(_tokenPerEth > 0 && _initialSupply > 0);  // [2019.03.05] Fixed for Mythril Vulerablity SWC ID:101\r\n        require(_tokenPerEth > 0); // SmartDec Recommendations\r\n        require(_marketSaleManager != address(0) &&\r\n                _serviceOperationManager != address(0) &&\r\n                _dividendManager != address(0) &&\r\n                _incentiveManager != address(0) &&\r\n                _reserveFundManager != address(0));\r\n        require(_marketSaleManager != _serviceOperationManager &&\r\n                _marketSaleManager != _dividendManager &&\r\n                _marketSaleManager != _incentiveManager &&\r\n                _marketSaleManager != _reserveFundManager &&\r\n                _serviceOperationManager != _dividendManager &&\r\n                _serviceOperationManager != _incentiveManager &&\r\n                _serviceOperationManager != _reserveFundManager &&\r\n                _dividendManager != _incentiveManager &&\r\n                _dividendManager != _reserveFundManager &&\r\n                _incentiveManager != _reserveFundManager); // SmartDec Recommendations\r\n\r\n        super.initToken(_tokenName, _tokenSymbol, _initialSupply,\r\n          // SmartDec Recommendations\r\n          _marketSaleManager,\r\n          _serviceOperationManager,\r\n          _dividendManager,\r\n          _incentiveManager,\r\n          _reserveFundManager\r\n        );\r\n        tokenPerEth = _tokenPerEth;\r\n        emit SetExchangeRate(msg.sender, tokenPerEth);\r\n    }\r\n\r\n\r\n    /**\r\n     * Change tokenPerEth variable only by owner\r\n     *\r\n     * Because \"TokenExchaner\" is only used until be listed on the exchange,\r\n     * tokenPerEth is needed by then and it would be managed by manager.\r\n     */\r\n    function setExchangeRate(uint256 _tokenPerEth) onlyOwner committeeApproved external returns (bool success){\r\n        require(opened);\r\n        require( _tokenPerEth > 0);\r\n        tokenPerEth = _tokenPerEth;\r\n        emit SetExchangeRate(msg.sender, tokenPerEth);\r\n\r\n        success = true;\r\n        return success;\r\n    }\r\n\r\n    function getExchangerRate() external view returns(uint256){\r\n        return tokenPerEth;\r\n    }\r\n\r\n    /**\r\n     * Exchange Ether To Token\r\n     *\r\n     * @notice Send `Nemo` tokens to msg sender as much as amount of ether received considering exchangeRate.\r\n     */\r\n    function exchangeEtherToToken() payable external noReentrancy returns (bool success){\r\n        require(opened);\r\n        uint256 tokenPayment;\r\n        uint256 ethAmount = msg.value;\r\n\r\n        require(ethAmount > 0);\r\n        require(tokenPerEth != 0);\r\n        tokenPayment = ethAmount.mul(tokenPerEth);\r\n\r\n        super._transfer(address(this), msg.sender, tokenPayment);\r\n\r\n        emit ExchangeEtherToToken(msg.sender, msg.value, tokenPerEth);\r\n\r\n        success = true;\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * Exchange Token To Ether\r\n     *\r\n     * @notice Send Ether to msg sender as much as amount of 'Nemo' Token received considering exchangeRate.\r\n     *\r\n     * @param _value Amount of 'Nemo' token\r\n     */\r\n    function exchangeTokenToEther(uint256 _value) external noReentrancy returns (bool success){\r\n      require(opened);\r\n      require(tokenPerEth != 0);\r\n\r\n      uint256 remainingEthBalance = address(this).balance;\r\n      uint256 etherPayment = _value.div(tokenPerEth);\r\n      uint256 remainder = _value % tokenPerEth; // [2019.03.06 Fixing Securify vulnerabilities-Division influences Transfer Amount]\r\n      require(remainingEthBalance >= etherPayment);\r\n\r\n      uint256 tokenAmount = _value.sub(remainder); // [2019.03.06 Fixing Securify vulnerabilities-Division influences Transfer Amount]\r\n      super._transfer(msg.sender, address(this), tokenAmount); // [2019.03.06 Fixing Securify vulnerabilities-Division influences Transfer Amount]\r\n      //require(address(msg.sender).send(etherPayment));\r\n      address(msg.sender).transfer(etherPayment); // SmartDec Recommendations\r\n\r\n      emit ExchangeTokenToEther(address(this), etherPayment, tokenPerEth);\r\n      success = true;\r\n      return success;\r\n    }\r\n\r\n    /**\r\n     * Withdraw token from TokenExchanger contract\r\n     *\r\n     * @notice Withdraw charged Token to _recipient.\r\n     *\r\n     * @param _recipient The address to which the token was issued.\r\n     * @param _value Amount of token to withdraw.\r\n     */\r\n    function withdrawToken(address _recipient, uint256 _value) onlyOwner committeeApproved noReentrancy public {\r\n      //require(opened);\r\n      super._transfer(address(this) ,_recipient, _value);\r\n      emit WithdrawToken(_recipient, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw Ether from TokenExchanger contract\r\n     *\r\n     * @notice Withdraw charged Ether to _recipient.\r\n     *\r\n     * @param _recipient The address to which the Ether was issued.\r\n     * @param _value Amount of Ether to withdraw.\r\n     */\r\n    function withdrawEther(address payable _recipient, uint256 _value) onlyOwner committeeApproved noReentrancy public {\r\n        //require(opened);\r\n        //require(_recipient.send(_value));\r\n        _recipient.transfer(_value); // SmartDec Recommendations\r\n        emit WithdrawEther(_recipient, _value);\r\n    }\r\n\r\n    /**\r\n     * close the TokenExchanger functions permanently\r\n     *\r\n     * @notice This contract would be closed when the coin is actively traded and judged that its TokenExchanger function is not needed.\r\n     */\r\n    function closeExchanger() onlyOwner committeeApproved external {\r\n        opened = false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title NemodaxStorage\r\n *\r\n * @dev This is contract for proxyNemodax data order list.\r\n *      Contract shouldn't be changed as possible.\r\n *      If it should be edited, please add from the end of the contract .\r\n */\r\n\r\ncontract NemodaxStorage is RunningContractManager {\r\n\r\n    // Never ever change the order of variables below!!!!\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    mapping (address => uint256) public frozenExpired; // SmartDec Recommendations\r\n\r\n    bool private initialized;\r\n\r\n    uint256 internal tokenPerEth;\r\n    bool public opened = true;\r\n}\r\n\r\n/**\r\n * @title ProxyNemodax\r\n *\r\n * @dev The only fallback function will forward transaction to TokenExchanger Contract.\r\n *      and the result of calculation would be stored in ProxyNemodax\r\n *\r\n */\r\n\r\ncontract ProxyNemodax is NemodaxStorage {\r\n\r\n    /* Initialize new committee. this will be real committee accounts, not from TokenExchanger contract */\r\n    constructor(address _coOwner1,\r\n                address _coOwner2,\r\n                address _coOwner3,\r\n                address _coOwner4,\r\n                address _coOwner5)\r\n        MultiOwnable( _coOwner1, _coOwner2, _coOwner3, _coOwner4, _coOwner5) public {}\r\n\r\n    function () payable external {\r\n        address localImpl = implementation;\r\n        require(localImpl != address(0x0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n\r\n            switch calldatasize\r\n            case 0 {  } // just to receive ethereum\r\n\r\n            default{\r\n                calldatacopy(ptr, 0, calldatasize)\r\n\r\n                let result := delegatecall(gas, localImpl, ptr, calldatasize, 0, 0)\r\n                let size := returndatasize\r\n                returndatacopy(ptr, 0, size)\r\n                switch result\r\n\r\n                case 0 { revert(ptr, size) }\r\n                default { return(ptr, size) }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dismiss\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toRemove\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freezeExpiration\",\"type\":\"uint256\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"committeeStatus\",\"outputs\":[{\"name\":\"numOfOwners\",\"type\":\"uint8\"},{\"name\":\"numOfVotes\",\"type\":\"uint8\"},{\"name\":\"numOfMinOwners\",\"type\":\"uint8\"},{\"name\":\"proposedFuncData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetFuncData\",\"type\":\"bytes\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opened\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeEtherToToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"exchangeTokenToEther\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeExchanger\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"unfreezeAccount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_tokenPerEth\",\"type\":\"uint256\"},{\"name\":\"_marketSaleManager\",\"type\":\"address\"},{\"name\":\"_serviceOperationManager\",\"type\":\"address\"},{\"name\":\"_dividendManager\",\"type\":\"address\"},{\"name\":\"_incentiveManager\",\"type\":\"address\"},{\"name\":\"_reserveFundManager\",\"type\":\"address\"}],\"name\":\"initExchanger\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenPerEth\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ballot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangerRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_coOwner1\",\"type\":\"address\"},{\"name\":\"_coOwner2\",\"type\":\"address\"},{\"name\":\"_coOwner3\",\"type\":\"address\"},{\"name\":\"_coOwner4\",\"type\":\"address\"},{\"name\":\"_coOwner5\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenPerEth\",\"type\":\"uint256\"}],\"name\":\"ExchangeEtherToToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenPerEth\",\"type\":\"uint256\"}],\"name\":\"ExchangeTokenToEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenPerEth\",\"type\":\"uint256\"}],\"name\":\"SetExchangeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LastBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"expirationDate\",\"type\":\"uint256\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposedFuncData\",\"type\":\"bytes\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposedFuncData\",\"type\":\"bytes\"}],\"name\":\"Propose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposedFuncData\",\"type\":\"bytes\"}],\"name\":\"Dismiss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"removedOwner\",\"type\":\"address\"}],\"name\":\"RemovedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"}]","ContractName":"TokenExchanger","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b5e2d980bb3c9a0300d824fa0db47a92fec5fccf00000000000000000000000096f3e8c4c11fcd0aa7cce9b7c5221ebc26b4ada80000000000000000000000008323b1a64cc2579a5f899bb3277c7b616bde6276000000000000000000000000e2d57239c6785ee9586e94dc5eaa33b6978a6785000000000000000000000000f91ed17cd1f7849f2ff8617b2a38a67e4bfd0791","Library":"","SwarmSource":"bzzr://c4901fc490c5a187c41968e267ee44893317f033cea9ab7a6ce3e84ef5581a51"}]}