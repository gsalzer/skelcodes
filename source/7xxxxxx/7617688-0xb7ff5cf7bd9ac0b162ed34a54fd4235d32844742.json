{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\ncontract RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n\r\n    function encodeBytes(bytes memory self) internal  returns (bytes memory) {\r\n        bytes memory encoded;\r\n        if(self.length == 1 && uint8(self[0]) < 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal  returns (bytes memory) {\r\n        bytes memory list = flatten(self);\r\n        bytes memory encoded = encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n        return encoded;\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private  returns (bytes memory) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        bytes memory encoded;\r\n        uint encodedPtr;\r\n\r\n        uint len = self.length;\r\n        uint lenLen;\r\n        uint i = 0x1;\r\n        while(len/i != 0) {\r\n            lenLen++;\r\n            i *= 0x100;\r\n        }\r\n\r\n        if(len <= 55) {\r\n            encoded = new bytes(len+1);\r\n\r\n            // length encoding byte\r\n            encoded[0] = byte(uint8(prefix1+len));\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        } else {\r\n            // 1 is the length of the length of the length\r\n            encoded = new bytes(1+lenLen+len);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(uint8(prefix2+lenLen));\r\n\r\n            // length bytes\r\n            for(i=1; i<=lenLen; i++) {\r\n                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));\r\n            }\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    function flatten(bytes[] memory self) private  returns (bytes memory) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i<self.length; i++) {\r\n            len += self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(uint i=0; i<self.length; i++) {\r\n            bytes memory item = self[i];\r\n\r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr += self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson's string utils library\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function strToBytes(string memory data)internal pure returns (bytes memory){\r\n        uint _ascii_0 = 48;\r\n        uint _ascii_A = 65;\r\n        uint _ascii_a = 97;\r\n\r\n        bytes memory a = bytes(data);\r\n        uint[] memory b = new uint[](a.length);\r\n\r\n        for (uint i = 0; i < a.length; i++) {\r\n            uint _a = uint8(a[i]);\r\n\r\n            if (_a > 96) {\r\n                b[i] = _a - 97 + 10;\r\n            }\r\n            else if (_a > 66) {\r\n                b[i] = _a - 65 + 10;\r\n            }\r\n            else {\r\n                b[i] = _a - 48;\r\n            }\r\n        }\r\n\r\n        bytes memory c = new bytes(b.length / 2);\r\n        for (uint _i = 0; _i < b.length; _i += 2) {\r\n            c[_i / 2] = byte(uint8(b[_i] * 16 + b[_i + 1]));\r\n        }\r\n\r\n        return c;\r\n    }\r\n\r\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint8(b[i])*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes memory b){\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function stringToUint(string memory s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint i = 0; i < b.length; i++) {\r\n           if (uint8(b[i]) >= 48 && uint8(b[i]) <= 57){\r\n                result = result * 16 + (uint8(b[i]) - 48); // bytes and int are not compatible with the operator -.\r\n            }\r\n            else if(uint8(b[i]) >= 97 && uint8(b[i]) <= 122)\r\n            {\r\n                result = result * 16 + (uint8(b[i]) - 87);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function subString(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for(uint i = startIndex; i < endIndex; i++) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n            for (uint i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n                return string(bab);\r\n        }\r\n\r\n    function stringToAddr(string memory _input) internal pure returns (address){\r\n        string memory _a = strConcat(\"0x\",_input);\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint8(tmp[i]);\r\n            b2 = uint8(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n            return address(iaddr);\r\n    }\r\n\r\n    function addressToString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(40);\r\n\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[i*2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[1+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    function toHexDigit(uint8 d) pure internal returns (byte) {                                                                                      \r\n        if (0 <= d && d <= 9) {                                                                                                                      \r\n            return byte(uint8(byte('0')) + d);                                                                                                       \r\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {                                                                                               \r\n            return byte(uint8(byte('a')) + d - 10);                                                                                                  \r\n        }                                                                                                                                            \r\n    }   \r\n    \r\n    function fromCode(bytes4 code) public pure returns (string memory) {                                                                                    \r\n        bytes memory result = new bytes(8);                                                                                                         \r\n        //result[0] = byte('0');\r\n        //result[1] = byte('x');\r\n        for (uint i=0; i<4; ++i) {\r\n            result[2*i+0] = toHexDigit(uint8(code[i])/16);\r\n            result[2*i+1] = toHexDigit(uint8(code[i])%16);\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    \r\n    function getMsgHash(address _destination, string memory _value, string memory _strTransactionData)  internal returns (bytes32){\r\n\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        bytes[] memory bytesArray = new bytes[](9);\r\n\r\n        rawTx[0] = hex\"09\";\r\n        rawTx[1] = hex\"09502f9000\";\r\n        rawTx[2] = hex\"5208\";\r\n        rawTx[3] = addressToBytes(_destination);\r\n        rawTx[4] = strToBytes(_value);\r\n        rawTx[5] = strToBytes(_strTransactionData);\r\n        rawTx[6] = hex\"01\"; //03=testnet,01=mainnet\r\n\r\n        for(uint8 i = 0; i < 9; i++){\r\n            bytesArray[i] = encodeBytes(rawTx[i]);\r\n        }\r\n\r\n        bytes memory bytesList = encodeList(bytesArray);\r\n\r\n        return keccak256(bytesList);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IVTPermission\r\n * @dev Contract for Permission applications.\r\n */\r\ncontract IVTPermission is RLPEncode {\r\n\r\n    /// @dev  (签名地址==》标志位)\r\n    mapping (address => bool) public signers;\r\n    /// @dev  （交易历史==》标志位）\r\n    mapping (uint256 => bool) public transactions;\r\n    /// @dev  签名所需最少签名\r\n    uint8 public required;\r\n\r\n/// @dev  Emitted by successful `upgrade` calls.\r\n    event Completed(\r\n        bytes4 _callbackSelector,\r\n        address _newAddress,\r\n        address _sender\r\n    );\r\n\r\n    constructor(address[] memory _signers, uint8 _required) public {\r\n        require(_required <= _signers.length && _required > 0 && _signers.length > 0);\r\n\r\n        for (uint8 i = 0; i < _signers.length; i++){\r\n            require(_signers[i] != address(0));\r\n            signers[_signers[i]] = true;\r\n        }\r\n        required = _required;\r\n    }\r\n\r\n/**\r\n * @dev    外部函数，升级确认\r\n * @param  _callbackSelector 回调函数选择器\r\n * @param  _newAddress 新的地址\r\n * @param  _strTransactionData v4版本数据结构 [proxy地址]+[时间戳]\r\n * @param  _v v数组，如[27,28,28]\r\n * @param  _r r数组，如[\"\",\"\",\"\"]\r\n * @param  _s s数组，如[\"\",\"\",\"\"]\r\n * @return \r\n */\r\n    function confirmChange(bytes4 _callbackSelector, address _newAddress, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s) public {\r\n        processAndCheckParam(_newAddress, _strTransactionData, _v, _r, _s);\r\n        _strTransactionData = RLPEncode.strConcat(_strTransactionData, RLPEncode.fromCode(_callbackSelector));\r\n        //value 使用固定值03e8\r\n        bytes32 _msgHash = getMsgHash(_newAddress, \"03e8\", _strTransactionData);\r\n        \r\n        verifySignatures(_msgHash, _v, _r, _s);\r\n\r\n        msg.sender.call(abi.encodeWithSelector(_callbackSelector, _newAddress));\r\n        emit Completed(_callbackSelector, _newAddress, msg.sender);\r\n    }\r\n\r\n\r\n/**\r\n * @dev    校验参数，内部函数\r\n * @param  _destination 升级新地址\r\n * @param  _strTransactionData 签名数据，v4版本数据结构为 [proxy地址]+[时间戳]\r\n * @param  _v 如上\r\n * @param  _r 如上\r\n * @param  _s 如上\r\n * @return \r\n */\r\n    function processAndCheckParam(address _destination, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s)  internal {\r\n        require(_destination != address(0)  && _v.length == _r.length && _v.length == _s.length && _v.length > 0);\r\n\r\n        string memory strTransactionTime = RLPEncode.subString(_strTransactionData, 40, 48);\r\n        uint256 transactionTime = RLPEncode.stringToUint(strTransactionTime);\r\n        require(!transactions[transactionTime]);\r\n\r\n        string memory strTransactionAddress = RLPEncode.subString(_strTransactionData, 0, 40);\r\n        address contractAddress = RLPEncode.stringToAddr(strTransactionAddress);\r\n        //多签地址 == proxy地址\r\n        require(contractAddress == address(msg.sender));\r\n\r\n        transactions[transactionTime] = true;\r\n    }\r\n\r\n\r\n/**\r\n * @dev   内部函数，校验签名\r\n * @param _msgHash 签名消息Hash\r\n * @param  _v  如上\r\n * @param  _r  如上\r\n * @param  _s  如上\r\n * @return \r\n */\r\n    function verifySignatures(bytes32 _msgHash, uint8[] memory _v, bytes32[] memory _r,bytes32[] memory _s) view internal {\r\n        uint8 hasConfirmed = 0;\r\n        address[] memory  tempAddresses = new address[](_v.length);\r\n\r\n        for (uint8 i = 0; i < _v.length; i++){\r\n            tempAddresses[i]  = ecrecover(_msgHash, _v[i], _r[i], _s[i]);\r\n       \r\n            require(signers[tempAddresses[i]]);\r\n            hasConfirmed++;\r\n        }\r\n\r\n        for (uint8 m = 0; m < _v.length; m++){\r\n            for (uint8 n = m + 1; n< _v.length; n++){\r\n                require(tempAddresses[m] != tempAddresses[n]);\r\n            }\r\n        }\r\n\r\n        require(hasConfirmed >= required);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_callbackSelector\",\"type\":\"bytes4\"},{\"name\":\"_newAddress\",\"type\":\"address\"},{\"name\":\"_strTransactionData\",\"type\":\"string\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"confirmChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes4\"}],\"name\":\"fromCode\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_signers\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_callbackSelector\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_newAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"Completed\",\"type\":\"event\"}]","ContractName":"IVTPermission","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000004f5626836da5e26b08ebb5dcf289b7abab35e237000000000000000000000000120a601ad7f892a52e330a20d20db23c87dd8526000000000000000000000000b2ba8ab4712f15fb75cda3e821a13ee677990dfa","Library":"","SwarmSource":"bzzr://d5cde17c1342f06d56ef4157af86355454464d714deadee30170d3004e57b589"}]}