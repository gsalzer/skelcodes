{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface ERC725 {\r\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) public view returns (bool result);\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ninterface ERC20Basic {\r\n\tfunction balanceOf(address who) public constant returns (uint256);\r\n}\r\n\r\n\r\ninterface ProfileStorage {\r\n\tfunction getStake(address identity) public view returns(uint256);\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only contract owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Voting is Ownable {\r\n\tmapping(address => bool) public walletApproved;\r\n\tmapping(address => bool) public walletVoted;\r\n\r\n\tERC20Basic public tokenContract;\r\n\tProfileStorage public profileStorageContract;\r\n\r\n\tuint256 public votingClosingTime;\r\n\r\n\tstruct Candidate{\r\n\t\tstring name;\r\n\t\tuint256 votes;\r\n\t}\r\n\r\n\tCandidate[34] public candidates;\r\n\r\n\tconstructor (address tokenContractAddress, address profileStorageContractAddress) public {\r\n\t\ttokenContract = ERC20Basic(tokenContractAddress);\r\n\t\tprofileStorageContract = ProfileStorage(profileStorageContractAddress);\r\n\r\n\t\tvotingClosingTime = 0;\r\n\r\n\t\t candidates[0].name = \"Air Sourcing\";\r\n\t\t candidates[1].name = \"Ametlab\";\r\n\t\t candidates[2].name = \"B2B Section of Slovenian Blockchain Association (SBCA)\";\r\n\t\t candidates[3].name = \"Beleaf & Co\";\r\n\t\t candidates[4].name = \"BioGenom 2.0\";\r\n\t\t candidates[5].name = \"CAM Engineering\";\r\n\t\t candidates[6].name = \"Dispensa Dei Tipici\";\r\n\t\t candidates[7].name = \"Fuzzy Factory\";\r\n\t\t candidates[8].name = \"GSC Platform\";\r\n\t\t candidates[9].name = \"HydraWarehouse\";\r\n\t\tcandidates[10].name = \"Ibis Eteh\";\r\n\t\tcandidates[11].name = \"Infotrans\";\r\n\t\tcandidates[12].name = \"Intelisale\";\r\n\t\tcandidates[13].name = \"Istmos\";\r\n\t\tcandidates[14].name = \"Ivy Food Tech\";\r\n\t\tcandidates[15].name = \"Journey Foods\";\r\n\t\tcandidates[16].name = \"Kakaxi\";\r\n\t\tcandidates[17].name = \"L.Co\";\r\n\t\tcandidates[18].name = \"LynqWallet\";\r\n\t\tcandidates[19].name = \"MedicoHealth AG\";\r\n\t\tcandidates[20].name = \"Moku Menehune\";\r\n\t\tcandidates[21].name = \"NetSDL\";\r\n\t\tcandidates[22].name = \"Orchit\";\r\n\t\tcandidates[23].name = \"Phy2Trace\";\r\n\t\tcandidates[24].name = \"Procurean\";\r\n\t\tcandidates[25].name = \"PsyChain\";\r\n\t\tcandidates[26].name = \"RealMeal\";\r\n\t\tcandidates[27].name = \"Reterms\";\r\n\t\tcandidates[28].name = \"Sensefinity\";\r\n\t\tcandidates[29].name = \"Solomon Ears\";\r\n\t\tcandidates[30].name = \"Space Invoices\";\r\n\t\tcandidates[31].name = \"Step Online\";\r\n\t\tcandidates[32].name = \"TMA\";\r\n\t\tcandidates[33].name = \"Zemlja&Morje\";\r\n\t}\r\n\r\n\t// Enabling and disabling the voting process\r\n\tfunction startVoting() public onlyOwner {\r\n\t\trequire(votingClosingTime == 0, \"Voting already started once!\");\r\n\t\tvotingClosingTime = block.timestamp + 7 days;\r\n\t}\r\n\r\n\tevent WalletApproved(address wallet, address ERC725Address);\r\n\tevent WalletRejected(address wallet, address ERC725Address, string reason);\r\n\tevent WalletVoted(address wallet, string firstChoice, string secondChoice, string thirdChoice);\r\n\r\n\t// Setting and getting voting approval for wallets\r\n\tfunction approveMultipleWallets(address[] wallets, address[] ERC725Addresses) public onlyOwner {\r\n\t\trequire(votingClosingTime == 0, \"Voting already started!\");\r\n\t\trequire(wallets.length <= 50, \"Cannot approve more than 50 wallets at a time!\");\r\n\t\trequire(wallets.length == ERC725Addresses.length, \"Arrays are not the same length!\");\r\n\t\tuint256 i = 0;\r\n\t\tfor(i = 0; i < wallets.length && i < 50; i = i + 1) {\r\n\t\t\twalletApproved[wallets[i]] = false;\r\n\r\n\t\t\tif (wallets[i] == address(0) && ERC725Addresses[i] == address(0)) {\r\n\t\t\t\temit WalletRejected(wallets[i], ERC725Addresses[i], \r\n\t\t\t\t\t\t\"Cannot verify an empty application!\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif(ERC725Addresses[i] != address(0)) {\r\n\t\t\t\t\tif(profileStorageContract.getStake(ERC725Addresses[i]) >= 10^21) {\r\n\t\t\t\t\t\twalletApproved[ERC725Addresses[i]] = true;\r\n\t\t\t\t\t\temit WalletApproved(address(0), ERC725Addresses[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\temit WalletRejected(wallets[i], ERC725Addresses[i], \r\n\t\t\t\t\t\t\t\"Profile does not have at least 1000 trac at the time of approval!\");\r\n\t\t\t\t\t}\t\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Only wallet was submitted \r\n\t\t\t\t\t\t// -> Verify wallet balance and approve wallet\r\n\t\t\t\t\tif(tokenContract.balanceOf(wallets[i]) >= 10^21) {\r\n\t\t\t\t\t\twalletApproved[wallets[i]] = true;\r\n\t\t\t\t\t\temit WalletApproved(wallets[i], address(0));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\temit WalletRejected(wallets[i], address(0), \r\n\t\t\t\t\t\t\t\"Wallet does not have at least 1000 trac at the time of approval!\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction disapproveMultipleWallets(address[] wallets) public onlyOwner {\r\n\t\trequire(wallets.length <= 50, \"Cannot approve more than 50 wallets at a time!\");\r\n\t\tuint256 i = 0;\r\n\t\tfor(i = 0; i < wallets.length && i < 50; i = i + 1) {\r\n\t\t\twalletApproved[wallets[i]] = false;\r\n\t\t\temit WalletRejected(wallets[i], address(0), \"Wallet approval removed!\");\r\n\t\t}\r\n\t}\r\n\tfunction isWalletApproved(address wallet) public view returns (bool) {\r\n\t\treturn walletApproved[wallet];\r\n\t}\r\n\r\n\r\n\tfunction vote(uint256[] candidateIndexes) public {\r\n\t\trequire(votingClosingTime != 0, \"Voting has not yet started!\");\r\n\t\trequire(votingClosingTime >= block.timestamp, \"Voting period has expired!\");\r\n\r\n\t\trequire(walletApproved[msg.sender] == true, \"Sender is not approved and thus cannot vote!\");\r\n\t\t\r\n\t\trequire(walletVoted[msg.sender] == false, \"Sender already voted!\");\r\n\r\n\t\trequire(candidateIndexes.length == 3, \"Must vote for 3 candidates!\");\r\n\r\n\t\trequire(candidateIndexes[0] != candidateIndexes[1], \"Cannot cast multiple votes for the same person!\");\r\n\t\trequire(candidateIndexes[1] != candidateIndexes[2], \"Cannot cast multiple votes for the same person!\");\r\n\t\trequire(candidateIndexes[2] != candidateIndexes[0], \"Cannot cast multiple votes for the same person!\");\r\n\r\n\t\trequire(candidateIndexes[0] >= 0 && candidateIndexes[0] < candidates.length, \"The selected candidate does not exist!\");\r\n\t\trequire(candidateIndexes[1] >= 0 && candidateIndexes[1] < candidates.length, \"The selected candidate does not exist!\");\r\n\t\trequire(candidateIndexes[2] >= 0 && candidateIndexes[2] < candidates.length, \"The selected candidate does not exist!\");\r\n\r\n\t\twalletVoted[msg.sender] = true;\r\n\t\temit WalletVoted(msg.sender, candidates[candidateIndexes[0]].name, candidates[candidateIndexes[1]].name, candidates[candidateIndexes[2]].name);\r\n\r\n\t\tassert(candidates[candidateIndexes[0]].votes + 3 > candidates[candidateIndexes[0]].votes);\r\n\t\tcandidates[candidateIndexes[0]].votes = candidates[candidateIndexes[0]].votes + 3;\t\t\r\n\r\n\t\tassert(candidates[candidateIndexes[1]].votes + 2 > candidates[candidateIndexes[1]].votes);\r\n\t\tcandidates[candidateIndexes[1]].votes = candidates[candidateIndexes[1]].votes + 2;\t\t\r\n\t\r\n\t\tassert(candidates[candidateIndexes[2]].votes + 1 > candidates[candidateIndexes[2]].votes);\r\n\t\tcandidates[candidateIndexes[2]].votes = candidates[candidateIndexes[2]].votes + 1;\t\t\r\n\t\r\n\t\trequire(tokenContract.balanceOf(msg.sender) >= 10^21, \"Sender does not have at least 1000 TRAC and thus cannot vote!\");\r\n\t}\r\n\r\n\tfunction voteWithProfile(uint256[] candidateIndexes, address ERC725Address) public {\r\n\t\trequire(votingClosingTime != 0, \"Voting has not yet started!\");\r\n\t\trequire(votingClosingTime >= block.timestamp, \"Voting period has expired!\");\r\n\t\t\r\n\t\trequire(walletApproved[msg.sender] == true || walletApproved[ERC725Address] == true, \"Sender is not approved and thus cannot vote!\");\r\n\r\n\t\trequire(walletVoted[msg.sender] == false, \"Sender already voted!\");\r\n\t\trequire(walletVoted[ERC725Address] == false, \"Profile was already used for voting!\");\r\n\r\n\t\trequire(candidateIndexes.length == 3, \"Must vote for 3 candidates!\");\r\n\r\n\t\trequire(candidateIndexes[0] != candidateIndexes[1], \"Cannot cast multiple votes for the same person!\");\r\n\t\trequire(candidateIndexes[1] != candidateIndexes[2], \"Cannot cast multiple votes for the same person!\");\r\n\t\trequire(candidateIndexes[2] != candidateIndexes[0], \"Cannot cast multiple votes for the same person!\");\r\n\r\n\t\trequire(candidateIndexes[0] >= 0 && candidateIndexes[0] < candidates.length, \"The selected candidate does not exist!\");\r\n\t\trequire(candidateIndexes[1] >= 0 && candidateIndexes[1] < candidates.length, \"The selected candidate does not exist!\");\r\n\t\trequire(candidateIndexes[2] >= 0 && candidateIndexes[2] < candidates.length, \"The selected candidate does not exist!\");\r\n\r\n\t\twalletVoted[msg.sender] = true;\r\n\t\twalletVoted[ERC725Address] = true;\r\n\t\temit WalletVoted(msg.sender, candidates[candidateIndexes[0]].name, candidates[candidateIndexes[1]].name, candidates[candidateIndexes[2]].name);\r\n\t\t\r\n\t\tassert(candidates[candidateIndexes[0]].votes + 3 > candidates[candidateIndexes[0]].votes);\r\n\t\tcandidates[candidateIndexes[0]].votes = candidates[candidateIndexes[0]].votes + 3;\t\t\r\n\r\n\t\tassert(candidates[candidateIndexes[1]].votes + 2 > candidates[candidateIndexes[1]].votes);\r\n\t\tcandidates[candidateIndexes[1]].votes = candidates[candidateIndexes[1]].votes + 2;\t\t\r\n\t\r\n\t\tassert(candidates[candidateIndexes[2]].votes + 1 > candidates[candidateIndexes[2]].votes);\r\n\t\tcandidates[candidateIndexes[2]].votes = candidates[candidateIndexes[2]].votes + 1;\t\t\r\n\r\n\t\trequire(ERC725(ERC725Address).keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2), \r\n\t\t\t\"Sender is not the management wallet for this ERC725 identity!\");\r\n\t\t\t\r\n\t\trequire(tokenContract.balanceOf(msg.sender) >= 10^21 || profileStorageContract.getStake(ERC725Address) >= 10^21,\r\n\t\t    \"Neither the sender nor the submitted profile have at least 1000 TRAC and thus cannot vote!\");\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"startVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"candidates\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"votes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isWalletApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingClosingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletVoted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidateIndexes\",\"type\":\"uint256[]\"},{\"name\":\"ERC725Address\",\"type\":\"address\"}],\"name\":\"voteWithProfile\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidateIndexes\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"disapproveMultipleWallets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profileStorageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallets\",\"type\":\"address[]\"},{\"name\":\"ERC725Addresses\",\"type\":\"address[]\"}],\"name\":\"approveMultipleWallets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"name\":\"profileStorageContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ERC725Address\",\"type\":\"address\"}],\"name\":\"WalletApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ERC725Address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"WalletRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"firstChoice\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"secondChoice\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"thirdChoice\",\"type\":\"string\"}],\"name\":\"WalletVoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Voting","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa7a9ca87d3694b5755f213b5d04094b8d0f0a6f000000000000000000000000306d5e8af6aeb73359dcc5e22c894e2588f76ffb","Library":"","SwarmSource":"bzzr://eb97026b5e7a969beaff6d503381841f91522ab2ec4c5f8615243aa9881c4343"}]}