{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\n\ncontract ConnectCapacity {\n\n    address private controllerSystem;\n\n    // struct AdaptionOrder\n    struct AdaptionOrder {\n        address vglNb;\n        int256 cot;\n        int256 pct;\n        int256 tct;\n        int256 ict;\n    }\n\n    // map address -> tokenclassId -> balance\n    mapping(address => mapping(string => int256)) private capacityBalance;\n\n    // map rc -> timestamp -> struct(AdaptionOrder)\n    mapping(address => mapping( uint256 => AdaptionOrder)) private adaptionMap;\n\n    event Transfer (address indexed from, address indexed to, string classId, int256 value, int256 balanceAfterTx);\n\n    event Changed (address indexed rc, int256 tctValue, int256 ictValue,\n    int256 balanceOfTCTGiveAfterTx, int256 balanceOfICTGiveAfterTx, int256 balanceOfCOTAfterTx);\n \n    event AdaptionRequest (address indexed from, uint256 indexed time, int256 value);\n\n    event AdaptionRelease (address indexed vglNbAddress, address indexed rcAddress, uint256 time);\n\n    modifier onlySystem() {\n        require(msg.sender == controllerSystem, \"only System can invoke\");\n        _;\n    }\n\n    constructor() public {\n        controllerSystem = msg.sender;\n    }\n\n    function transfer(address _from, address _to, string memory _classId, int256 _value) public onlySystem() {\n        require(_value >= 0, \"Negative amount\");\n        if (_value != 0) {\n            capacityBalance[_to][_classId] = capacityBalance[_to][_classId] + _value;\n            capacityBalance[_from][_classId] = capacityBalance[_from][_classId] - _value;\n        }\n        int256 balanceAfterTx = capacityBalance[_from][_classId];\n        emit Transfer(_from, _to, _classId, _value, balanceAfterTx);\n    }\n\n    function interchange(address _from, address _to, int256 _valueTCT, int256 _valueICT) public onlySystem() {\n\n        require(_valueTCT >= 0, \"TCT can only be reduced\");\n        require(capacityBalance[_from][\"TCT\"] >= _valueTCT, \"the TCT value is bigger than the current Balance\");\n        require(_valueICT >= 0 || _valueTCT >= -1 * _valueICT, \"the increased ICT value is bigger than the given TCT\");\n        capacityBalance[_from][\"TCT\"] = capacityBalance[_from][\"TCT\"] - _valueTCT;\n        capacityBalance[_from][\"ICT\"] = capacityBalance[_from][\"ICT\"] - _valueICT;\n        capacityBalance[_from][\"COT\"] = capacityBalance[_from][\"COT\"] + _valueTCT + _valueICT;\n\n        capacityBalance[_to][\"TCT\"] = capacityBalance[_to][\"TCT\"] + _valueTCT;\n        capacityBalance[_to][\"ICT\"] = capacityBalance[_to][\"ICT\"] + _valueICT;\n        capacityBalance[_to][\"COT\"] = capacityBalance[_to][\"COT\"] - _valueTCT - _valueICT;\n\n        int256 balanceOfTCTGiveAfterTx = capacityBalance[_from][\"TCT\"];\n        int256 balanceOfICTGiveAfterTx = capacityBalance[_from][\"ICT\"];\n        int256 balanceOfCOTAfterTx = capacityBalance[_from][\"COT\"];\n        emit Changed(_from, _valueTCT, _valueICT, balanceOfTCTGiveAfterTx, balanceOfICTGiveAfterTx, balanceOfCOTAfterTx);\n    }\n\n    function createAdaptionRequest(address _rc, address _vglNb, int256 _value, uint256 _timeOfChange) public onlySystem() {\n        AdaptionOrder memory adaption = adaptionMap[_rc][_timeOfChange];\n        // if Adaption already exist the value of COT will be replaced with the new one to allow Update.\n        adaptionMap[_rc][_timeOfChange] = AdaptionOrder(_vglNb, _value, adaption.pct, adaption.tct, adaption.ict);\n        emit AdaptionRequest(_rc, _timeOfChange, _value);\n    }\n\n    function changeAdaptionRequest(address _rc, address _vglNb, int256 _value, uint256 _timeOfChange,\n        uint256 _oldTimeOfChange) public onlySystem() {\n        delete adaptionMap[_rc][_oldTimeOfChange];\n        createAdaptionRequest(_rc, _vglNb, _value, _timeOfChange);\n\n    }\n\n    function confirmAdaptionRequest(address _rc, int256 _valueOfPCT, int256 _valueOfTCT, int256 _valueOfICT, uint256 timeOfChange)\n      public onlySystem() {\n        AdaptionOrder storage adaption = adaptionMap[_rc][timeOfChange];\n        require(adaption.vglNb != address(0), \"there is no Adaption\");\n        adaption.pct = _valueOfPCT;\n        adaption.tct = _valueOfTCT;\n        adaption.ict = _valueOfICT;\n    }\n\n    function releaseAdaption(address _rc, uint256 timeOfChange) public onlySystem() {\n        AdaptionOrder storage adaption = adaptionMap[_rc][timeOfChange];\n        require(adaption.vglNb != address(0), \"there is no Adaption\");\n        if (adaption.cot >= 0) {\n            transfer(_rc, adaption.vglNb, \"COT\", adaption.cot);\n        } else {\n            transfer(adaption.vglNb, _rc, \"COT\", -1 * adaption.cot);\n        }\n        if (adaption.pct >= 0) {\n            transfer(adaption.vglNb, _rc, \"PCT\", adaption.pct);\n        } else {\n            transfer(_rc, adaption.vglNb, \"PCT\", -1 * adaption.pct);\n        }\n        if (adaption.tct >= 0) {\n            transfer(adaption.vglNb, _rc, \"TCT\", adaption.tct);\n        } else {\n            transfer(_rc, adaption.vglNb, \"TCT\", -1 * adaption.tct);\n        }\n        if (adaption.ict >= 0) {\n            transfer(adaption.vglNb, _rc, \"ICT\", adaption.ict);\n        } else {\n            transfer(_rc, adaption.vglNb, \"ICT\", -1 * adaption.ict);\n        }\n\n        emit AdaptionRelease(adaption.vglNb, _rc, timeOfChange);\n        delete adaptionMap[_rc][timeOfChange];\n    }\n\n    function balanceOf(address _address, string memory _classId) public view returns (int256) {\n        return capacityBalance[_address][_classId];\n    }\n\n    function getAdaptionValues(address _rc, uint256 timeOfChange) public view returns (int256, int256, int256, int256) {\n        AdaptionOrder storage adaption = adaptionMap[_rc][timeOfChange];\n        return (adaption.cot, adaption.pct, adaption.tct, adaption.ict);\n    }\n\n    function getTotalBalance(address _address) public view returns(int256 currentBalance) {\n        int256 balanceForCOT = balanceOf(_address, \"COT\");\n        int256 balanceForPCT = balanceOf(_address, \"PCT\");\n        int256 balanceForTCT = balanceOf(_address, \"TCT\");\n        int256 balanceForICT = balanceOf(_address, \"ICT\");\n        currentBalance = balanceForCOT + balanceForPCT + balanceForTCT + balanceForICT;\n    }\n\n    function () external payable {\n        revert(\"not allowed function\");\n    }\n\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_valueTCT\",\"type\":\"int256\"},{\"name\":\"_valueICT\",\"type\":\"int256\"}],\"name\":\"interchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_classId\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"int256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rc\",\"type\":\"address\"},{\"name\":\"_vglNb\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"int256\"},{\"name\":\"_timeOfChange\",\"type\":\"uint256\"},{\"name\":\"_oldTimeOfChange\",\"type\":\"uint256\"}],\"name\":\"changeAdaptionRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rc\",\"type\":\"address\"},{\"name\":\"timeOfChange\",\"type\":\"uint256\"}],\"name\":\"releaseAdaption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_classId\",\"type\":\"string\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rc\",\"type\":\"address\"},{\"name\":\"_vglNb\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"int256\"},{\"name\":\"_timeOfChange\",\"type\":\"uint256\"}],\"name\":\"createAdaptionRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rc\",\"type\":\"address\"},{\"name\":\"_valueOfPCT\",\"type\":\"int256\"},{\"name\":\"_valueOfTCT\",\"type\":\"int256\"},{\"name\":\"_valueOfICT\",\"type\":\"int256\"},{\"name\":\"timeOfChange\",\"type\":\"uint256\"}],\"name\":\"confirmAdaptionRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTotalBalance\",\"outputs\":[{\"name\":\"currentBalance\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rc\",\"type\":\"address\"},{\"name\":\"timeOfChange\",\"type\":\"uint256\"}],\"name\":\"getAdaptionValues\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"classId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balanceAfterTx\",\"type\":\"int256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rc\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tctValue\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"ictValue\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balanceOfTCTGiveAfterTx\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balanceOfICTGiveAfterTx\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"balanceOfCOTAfterTx\",\"type\":\"int256\"}],\"name\":\"Changed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"AdaptionRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vglNbAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"rcAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AdaptionRelease\",\"type\":\"event\"}]","ContractName":"ConnectCapacity","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e45cf0060ab635b6bc7a5141645282f299864ea046375912f52b6046a0014014"}]}