{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/gateway/ERC20Receiver.sol\r\n\r\n/**\r\n * @title ERC20 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC20 asset contracts.\r\n */\r\ncontract ERC20Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC20Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC20Receiver(0).onERC20Received.selector`\r\n   */\r\n  bytes4 constant ERC20_RECEIVED = 0xbc04f0af;\r\n\r\n  function onERC20Received(address _from, uint256 amount) public returns(bytes4);\r\n}\r\n\r\n// File: contracts/gateway/ERC721Receiver.sol\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/gateway/ECVerify.sol\r\n\r\nlibrary ECVerify {\r\n\r\n  enum SignatureMode {\r\n    EIP712,\r\n    GETH,\r\n    TREZOR\r\n  }\r\n\r\n  function recover(bytes32 hash, bytes signature) internal pure returns (address) {\r\n    require(signature.length == 66);\r\n    SignatureMode mode = SignatureMode(uint8(signature[0]));\r\n\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    assembly {\r\n      r := mload(add(signature, 33))\r\n      s := mload(add(signature, 65))\r\n      v := and(mload(add(signature, 66)), 255)\r\n    }\r\n\r\n    if (mode == SignatureMode.GETH) {\r\n      hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    } else if (mode == SignatureMode.TREZOR) {\r\n      hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", hash));\r\n    }\r\n\r\n    return ecrecover(hash, v, r, s);\r\n  }\r\n\r\n  function ecverify(bytes32 hash, bytes sig, address signer) internal pure returns (bool) {\r\n    return signer == recover(hash, sig);\r\n  }\r\n}\r\n\r\n// File: contracts/gateway/ValidatorManagerContract.sol\r\n\r\ncontract ValidatorManagerContract is Ownable {\r\n  using ECVerify for bytes32;\r\n\r\n  mapping (address => bool) public allowedTokens;\r\n  mapping (address => uint256) public nonces;\r\n  mapping (address => bool) validators;\r\n\r\n  uint8 threshold_num;\r\n  uint8 threshold_denom;\r\n  uint256 public numValidators;\r\n  uint256 public nonce; // used for replay protection when adding/removing validators\r\n\r\n  event AddedValidator(address validator);\r\n  event RemovedValidator(address validator);\r\n\r\n  modifier onlyValidator() { require(checkValidator(msg.sender)); _; }\r\n\r\n  constructor (address[] _validators, uint8 _threshold_num, uint8 _threshold_denom) public {\r\n    uint256 length = _validators.length;\r\n    require(length > 0);\r\n\r\n    threshold_num = _threshold_num;\r\n    threshold_denom = _threshold_denom;\r\n    for (uint256 i = 0; i < length ; i++) {\r\n      require(_validators[i] != address(0));\r\n      validators[_validators[i]] = true;\r\n      emit AddedValidator(_validators[i]);\r\n    }\r\n    numValidators = _validators.length;\r\n  }\r\n\r\n  modifier isVerifiedByValidator(uint256 num, address contractAddress, bytes sig) {\r\n    // prevent replay attacks by adding the nonce in the sig\r\n    // if a validator signs an invalid nonce,\r\n    // it won't pass the signature verification\r\n    // since the nonce in the hash is stored in the contract\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sender, contractAddress, nonces[msg.sender], num));\r\n    address sender = hash.recover(sig);\r\n    require(validators[sender], \"Message not signed by a validator\");\r\n    _;\r\n    nonces[msg.sender]++; // increment nonce after execution\r\n  }\r\n\r\n  function checkValidator(address _address) public view returns (bool) {\r\n    // owner is a permanent validator\r\n    if (_address == owner) {\r\n      return true;\r\n    }\r\n    return validators[_address];\r\n  }\r\n\r\n  function addValidator(address validator, uint8[] v, bytes32[] r, bytes32[] s)\r\n    external\r\n  {\r\n    require(!validators[validator], \"Already a validator\");\r\n\r\n    // Check that we have enough signatures\r\n    bytes32 message = keccak256(abi.encodePacked(\"add\", validator, nonce));\r\n    checkThreshold(message, v, r, s);\r\n\r\n    // Add validator and increment nonce\r\n    validators[validator] = true;\r\n    numValidators++;\r\n    nonce++;\r\n    emit AddedValidator(validator);\r\n  }\r\n\r\n  function removeValidator(address validator, uint8[] v, bytes32[] r, bytes32[] s)\r\n    external\r\n  {\r\n    require(validators[validator], \"Not a validator\");\r\n    // The last validator may not remove himself\r\n    require(numValidators > 1);\r\n\r\n    // Check that we have enough signatures\r\n    bytes32 message = keccak256(abi.encodePacked(\"remove\", validator, nonce));\r\n    checkThreshold(message, v, r, s);\r\n\r\n    delete validators[validator];\r\n    numValidators--;\r\n    nonce++;\r\n    emit RemovedValidator(validator);\r\n  }\r\n\r\n  // Can't pass bytes[] to use the whole sig due to ABI enc\r\n  //, so we need to send v,r,s params\r\n  function checkThreshold(bytes32 message, uint8[] v, bytes32[] r, bytes32[] s) private view {\r\n    require(v.length > 0 && v.length == r.length && r.length == s.length,\r\n      \"Incorrect number of params\");\r\n    require(v.length >= (threshold_num * numValidators / threshold_denom ),\r\n      \"Not enough votes\");\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\r\n    uint256 sig_length = v.length;\r\n\r\n    // Check that all addresess were from validators\r\n    // Prevent duplicates by requiring that the sender sigs\r\n    // get submitted in increasing order\r\n    // influenced by\r\n    // https://github.com/christianlundkvist/simple-multisig\r\n    address lastAdd = address(0);\r\n    for (uint256 i = 0; i < sig_length; i++) {\r\n      address signer = ecrecover(hash, v[i], r[i], s[i]);\r\n      require(signer > lastAdd && validators[signer], \"Not signed by a validator\");\r\n      lastAdd = signer;\r\n    }\r\n  }\r\n\r\n  function toggleToken(address _token) public onlyValidator {\r\n    allowedTokens[_token] = !allowedTokens[_token];\r\n  }\r\n}\r\n\r\n// File: contracts/gateway/Gateway.sol\r\n\r\ncontract Gateway is ERC20Receiver, ERC721Receiver, ValidatorManagerContract {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  struct Balance {\r\n    uint256 eth;\r\n    mapping(address => uint256) erc20;\r\n    mapping(address => mapping(uint256 => bool)) erc721;\r\n  }\r\n\r\n  mapping (address => Balance) balances;\r\n\r\n  event ETHReceived(address from, uint256 amount);\r\n  event ERC20Received(address from, uint256 amount, address contractAddress);\r\n  event ERC721Received(address from, uint256 uid, address contractAddress);\r\n\r\n  enum TokenKind {\r\n    ETH,\r\n    ERC20,\r\n    ERC721\r\n  }\r\n\r\n  /**\r\n   * Event to log the withdrawal of a token from the Gateway.\r\n   * @param owner Address of the entity that made the withdrawal.\r\n   * @param kind The type of token withdrawn (ERC20/ERC721/ETH).\r\n   * @param contractAddress Address of token contract the token belong to.\r\n   * @param value For ERC721 this is the uid of the token, for ETH/ERC20 this is the amount.\r\n   */\r\n  event TokenWithdrawn(address indexed owner, TokenKind kind, address contractAddress, uint256 value);\r\n\r\n  constructor (address[] _validators, uint8 _threshold_num, uint8 _threshold_denom)\r\n    public ValidatorManagerContract(_validators, _threshold_num, _threshold_denom) {\r\n  }\r\n\r\n  // Deposit functions\r\n  function depositETH() private {\r\n    balances[msg.sender].eth = balances[msg.sender].eth.add(msg.value);\r\n  }\r\n\r\n  function depositERC721(address from, uint256 uid) private {\r\n    balances[from].erc721[msg.sender][uid] = true;\r\n  }\r\n\r\n  function depositERC20(address from, uint256 amount) private {\r\n    balances[from].erc20[msg.sender] = balances[from].erc20[msg.sender].add(amount);\r\n  }\r\n\r\n  // Withdrawal functions\r\n  function withdrawERC20(uint256 amount, bytes sig, address contractAddress)\r\n    external\r\n    isVerifiedByValidator(amount, contractAddress, sig)\r\n  {\r\n    balances[msg.sender].erc20[contractAddress] = balances[msg.sender].erc20[contractAddress].sub(amount);\r\n    ERC20(contractAddress).transfer(msg.sender, amount);\r\n    emit TokenWithdrawn(msg.sender, TokenKind.ERC20, contractAddress, amount);\r\n  }\r\n\r\n  function withdrawERC721(uint256 uid, bytes sig, address contractAddress)\r\n    external\r\n    isVerifiedByValidator(uid, contractAddress, sig)\r\n  {\r\n    require(balances[msg.sender].erc721[contractAddress][uid], \"Does not own token\");\r\n    ERC721(contractAddress).safeTransferFrom(address(this),  msg.sender, uid);\r\n    delete balances[msg.sender].erc721[contractAddress][uid];\r\n    emit TokenWithdrawn(msg.sender, TokenKind.ERC721, contractAddress, uid);\r\n  }\r\n\r\n  function withdrawETH(uint256 amount, bytes sig)\r\n    external\r\n    isVerifiedByValidator(amount, address(this), sig)\r\n  {\r\n    balances[msg.sender].eth = balances[msg.sender].eth.sub(amount);\r\n    msg.sender.transfer(amount); // ensure it's not reentrant\r\n    emit TokenWithdrawn(msg.sender, TokenKind.ETH, address(0), amount);\r\n  }\r\n\r\n  // Approve and Deposit function for 2-step deposits\r\n  // Requires first to have called `approve` on the specified ERC20 contract\r\n  function depositERC20(uint256 amount, address contractAddress) external {\r\n    ERC20(contractAddress).transferFrom(msg.sender, address(this), amount);\r\n    balances[msg.sender].erc20[contractAddress] = balances[msg.sender].erc20[contractAddress].add(amount);\r\n    emit ERC20Received(msg.sender, amount, contractAddress);\r\n  }\r\n\r\n  // Receiver functions for 1-step deposits to the gateway\r\n\r\n  function onERC20Received(address _from, uint256 amount)\r\n    public\r\n    returns (bytes4)\r\n  {\r\n    require(allowedTokens[msg.sender], \"Not a valid token\");\r\n    depositERC20(_from, amount);\r\n    emit ERC20Received(_from, amount, msg.sender);\r\n    return ERC20_RECEIVED;\r\n  }\r\n\r\n  function onERC721Received(address _from, uint256 _uid, bytes)\r\n    public\r\n    returns (bytes4)\r\n  {\r\n    require(allowedTokens[msg.sender], \"Not a valid token\");\r\n    depositERC721(_from, _uid);\r\n    emit ERC721Received(_from, _uid, msg.sender);\r\n    return ERC721_RECEIVED;\r\n  }\r\n\r\n  function () external payable {\r\n    depositETH();\r\n    emit ETHReceived(msg.sender, msg.value);\r\n  }\r\n\r\n  // Returns all the ETH you own\r\n  function getETH(address owner) external view returns (uint256) {\r\n    return balances[owner].eth;\r\n  }\r\n\r\n  // Returns all the ETH you own\r\n  function getERC20(address owner, address contractAddress) external view returns (uint256) {\r\n    return balances[owner].erc20[contractAddress];\r\n  }\r\n\r\n  // Returns ERC721 token by uid\r\n  function getNFT(address owner, uint256 uid, address contractAddress) external view returns (bool) {\r\n    return balances[owner].erc721[contractAddress][uid];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"toggleToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"depositERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"addValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"uid\",\"type\":\"uint256\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getNFT\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onERC20Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"removeValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uid\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_uid\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_validators\",\"type\":\"address[]\"},{\"name\":\"_threshold_num\",\"type\":\"uint8\"},{\"name\":\"_threshold_denom\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ERC20Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ERC721Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"AddedValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"RemovedValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Gateway","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000100000000000000000000000052fce231de2e94bbc5f0f7e4e75e916b27939fc3","Library":"","SwarmSource":"bzzr://38dec259d29be8b30511ad3454954d529e3c0a1bd85e19cadca32347f607da1e"}]}