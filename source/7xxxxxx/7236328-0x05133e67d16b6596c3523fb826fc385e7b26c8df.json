{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\ncontract Sweepstake {\r\n    uint constant MAX_CANDIDATES = 100;\r\n\r\n    struct Candidate {\r\n        uint votes;\r\n        uint balance;\r\n        address[] entrants;\r\n    }\r\n    \r\n    struct Entrant {\r\n        uint[] candidateVotes;\r\n        address sender;\r\n        bool paid;\r\n    }\r\n\r\n    address internal owner;\r\n    bool internal ownerCanTerminate;\r\n    uint internal ticketValue;\r\n    uint internal feePerTicket;\r\n    uint internal withdrawalAfterClosureWindowInDays;\r\n\r\n    Candidate[] internal candidates;\r\n    mapping(address => Entrant) internal entrants;\r\n    uint internal totalVotes;\r\n    uint internal totalBalance;\r\n\r\n    bool internal closed;\r\n    uint internal closedTime;\r\n\r\n    uint internal winningCandidateIndex;\r\n    uint internal winningVotes;\r\n    uint internal winningsPerVote;\r\n\r\n    modifier onlyOwner { \r\n        require (msg.sender == owner, 'Must be owner');\r\n        _; \r\n    }\r\n             \r\n    modifier onlyWhenOpen { \r\n        require (closed == false, 'Cannot execute whilst open');\r\n        _; \r\n    }\r\n            \r\n    modifier onlyWhenClosed { \r\n        require (closed == true, 'Cannot execute whilst closed');\r\n        _; \r\n    }\r\n\r\n    modifier onlyWithValidCandidate(uint candidateIndex) { \r\n        require (candidateIndex >= 0, 'Index must be valid');\r\n        require (candidateIndex < candidates.length, 'Index must be valid');\r\n        _; \r\n    }\r\n                \r\n    constructor(\r\n        uint _ticketValue,\r\n        uint _feePerTicket,\r\n        uint candidateCount,\r\n        uint _withdrawalAfterClosureWindowInDays\r\n    ) public {\r\n        require (candidateCount > 0, 'Candidate count must be more than 1');\r\n        require (candidateCount <= MAX_CANDIDATES, 'Candidate count must be less than max');\r\n\r\n        owner = msg.sender;\r\n        ownerCanTerminate = true;\r\n        ticketValue = _ticketValue;\r\n        feePerTicket = _feePerTicket;\r\n        withdrawalAfterClosureWindowInDays = _withdrawalAfterClosureWindowInDays;\r\n\r\n        for (uint index = 0; index < candidateCount; index++) {\r\n            candidates.push(Candidate({\r\n                votes: 0,\r\n                balance: 0,\r\n                entrants: new address[](0)\r\n            }));\r\n        }\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function getOwnerCanTerminate() external view returns (bool) {\r\n        return ownerCanTerminate;\r\n    }\r\n\r\n    function getClosed() external view returns (bool) {\r\n        return closed;\r\n    }\r\n\r\n    function getClosedTime() external view returns (uint) {\r\n        return closedTime;\r\n    }\r\n\r\n    function getWithdrawalAfterClosureWindowInDays() external view returns (uint) {\r\n        return withdrawalAfterClosureWindowInDays;\r\n    }\r\n\r\n    function getFeePerTicket() external view returns (uint) {\r\n        return feePerTicket;\r\n    }\r\n\r\n    function getTicketValue() external view returns (uint) {\r\n        return ticketValue;\r\n    }\r\n\r\n    function getAllCandidateBalances() external view returns (uint[]) {\r\n        uint candidateLength = candidates.length;\r\n        uint[] memory balances = new uint[](candidateLength);\r\n        \r\n        for (uint index = 0; index < candidateLength; index++) {\r\n            balances[index] = candidates[index].balance;\r\n        }\r\n\r\n        return balances;\r\n    }\r\n\r\n    function getAllCandidateVotes() external view returns (uint[]) {\r\n        uint candidateLength = candidates.length;\r\n        uint[] memory votes = new uint[](candidateLength);\r\n        \r\n        for (uint index = 0; index < candidateLength; index++) {\r\n            votes[index] = candidates[index].votes;\r\n        }\r\n\r\n        return votes;\r\n    }\r\n\r\n    function getCandidateEntrants(uint candidateIndex) external view onlyWithValidCandidate(candidateIndex) returns (address[]) {\r\n        return candidates[candidateIndex].entrants;\r\n    }\r\n\r\n    function getTotalVotes() external view returns (uint) {\r\n        return totalVotes;\r\n    }\r\n\r\n    function getTotalBalance() external view returns (uint) {\r\n        return totalBalance;\r\n    }\r\n\r\n    function getWinningCandidateIndex() external view onlyWhenClosed returns (uint) {\r\n        return winningCandidateIndex;\r\n    }\r\n\r\n    function getWinningVotes() external view onlyWhenClosed returns (uint) {\r\n        return winningVotes;\r\n    }\r\n\r\n    function getWinningsPerVote() external view onlyWhenClosed returns (uint) {\r\n        return winningsPerVote;\r\n    }\r\n\r\n    function hasCurrentUserEntered() external view returns (bool) {\r\n        return entrants[msg.sender].sender != 0x0;\r\n    }\r\n\r\n    function getCurrentEntrantVotes() external view returns (uint[]) {\r\n        require (entrants[msg.sender].sender != 0x0, 'Current user has not entered');\r\n\r\n        return entrants[msg.sender].candidateVotes;\r\n    }\r\n\r\n    function getCurrentEntrantPaidState() external view returns (bool) {\r\n        require (entrants[msg.sender].sender != 0x0, 'Current user has not entered');\r\n\r\n        return entrants[msg.sender].paid;\r\n    }\r\n\r\n    function getCurrentEntrantWinnings() external view onlyWhenClosed returns (uint) {\r\n        require (entrants[msg.sender].sender != 0x0, 'Current user has not entered');\r\n        require (entrants[msg.sender].candidateVotes[winningCandidateIndex] > 0, 'Current user did not vote for the winner');\r\n\r\n        return SafeMath.mul(winningsPerVote, entrants[msg.sender].candidateVotes[winningCandidateIndex]);\r\n    }\r\n\r\n    function enter(uint candidateIndex) external payable onlyWhenOpen onlyWithValidCandidate(candidateIndex) {\r\n        require (msg.value == ticketValue, 'Ticket value is incorrect');\r\n\r\n        if (entrants[msg.sender].sender == 0x0) {\r\n            entrants[msg.sender] = Entrant({\r\n                candidateVotes: new uint[](candidates.length),\r\n                sender: msg.sender,\r\n                paid: false\r\n            });\r\n\r\n            candidates[candidateIndex].entrants.push(msg.sender);\r\n        }\r\n\r\n        entrants[msg.sender].candidateVotes[candidateIndex]++;\r\n\r\n        totalVotes++;\r\n        candidates[candidateIndex].votes++;\r\n        \r\n        uint valueAfterFee = SafeMath.sub(msg.value, feePerTicket);\r\n        candidates[candidateIndex].balance = SafeMath.add(candidates[candidateIndex].balance, valueAfterFee);\r\n\r\n        totalBalance = SafeMath.add(totalBalance, valueAfterFee);\r\n\r\n        owner.transfer(feePerTicket);\r\n    }\r\n\r\n    function close(uint _winningCandidateIndex) external onlyOwner onlyWhenOpen onlyWithValidCandidate(_winningCandidateIndex) {\r\n        closed = true;\r\n        closedTime = now;\r\n\r\n        winningCandidateIndex = _winningCandidateIndex;\r\n\r\n        uint balance = address(this).balance;\r\n        winningVotes = candidates[winningCandidateIndex].votes;\r\n        if (winningVotes > 0) {    \r\n            winningsPerVote = SafeMath.div(balance, winningVotes);\r\n            uint totalWinnings = SafeMath.mul(winningsPerVote, winningVotes);\r\n\r\n            if (totalWinnings < balance) {\r\n                owner.transfer(SafeMath.sub(balance, totalWinnings));\r\n            }\r\n        } else {\r\n            owner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    function withdraw() external onlyWhenClosed {\r\n        require (entrants[msg.sender].sender != 0x0, 'Current user has not entered');\r\n        require (entrants[msg.sender].candidateVotes[winningCandidateIndex] > 0, 'Current user did not vote for the winner');\r\n        require (entrants[msg.sender].paid == false, 'User has already been paid');\r\n        require (now < (closedTime + (withdrawalAfterClosureWindowInDays * 1 days)));\r\n        \r\n        entrants[msg.sender].paid = true;\r\n\r\n        uint totalWinnings = SafeMath.mul(winningsPerVote, entrants[msg.sender].candidateVotes[winningCandidateIndex]);\r\n\r\n        msg.sender.transfer(totalWinnings);\r\n    }\r\n\r\n    function preventOwnerTerminating() external onlyOwner {\r\n        ownerCanTerminate = false;\r\n    }\r\n\r\n    function terminate() external onlyOwner {\r\n        require (ownerCanTerminate == true, 'Owner cannot terminate');\r\n\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getWinningsPerVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningCandidateIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_winningCandidateIndex\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTicketValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCandidateBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeePerTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEntrantWinnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEntrantVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwnerCanTerminate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"preventOwnerTerminating\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalAfterClosureWindowInDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasCurrentUserEntered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getClosedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidateIndex\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"candidateIndex\",\"type\":\"uint256\"}],\"name\":\"getCandidateEntrants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEntrantPaidState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCandidateVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ticketValue\",\"type\":\"uint256\"},{\"name\":\"_feePerTicket\",\"type\":\"uint256\"},{\"name\":\"candidateCount\",\"type\":\"uint256\"},{\"name\":\"_withdrawalAfterClosureWindowInDays\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Sweepstake","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000000001c6bf526340000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000005a","Library":"","SwarmSource":"bzzr://c45525064a16869d78b5ea66ea46218649063e1104882a492a5a24e8ddb4a163"}]}