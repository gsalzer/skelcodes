{"status":"1","message":"OK","result":[{"SourceCode":"{\"AddressUtils.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary AddressUtils {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   *  as the code is not actually created until after the constructor finishes.\\n   * @param addr address to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address addr) internal view returns (bool) {\\n    uint256 size;\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\\n    return size \\u003e 0;\\n  }\\n\\n}\\n\"},\"Controlled.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract Controlled {\\n\\n  event ControllerChangedEvent(address newController);\\n\\n  /// @notice The address of the controller is the only address that can call\\n  ///  a function with this modifier\\n  modifier onlyController { require(msg.sender == controller); _; }\\n\\n  address public controller;\\n\\n  function Controlled() public { controller = msg.sender;}\\n\\n  /// @notice Changes the controller of the contract\\n  /// @param _newController The new controller of the contract\\n  function changeController(address _newController) public onlyController {\\n    controller = _newController;\\n    emit ControllerChangedEvent(_newController);\\n  }\\n}\\n\"},\"DankFaucet.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./oraclizeAPI.sol\\\";\\nimport \\\"./DankToken.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/***\\n * A Faucet for getting initial DANK tokens. Provide a phone number,\\n * reveive a one-time allotment of DANK.\\n ***/\\ncontract DankFaucet is usingOraclize, DSAuth {\\n\\n  DankToken public constant dankToken = DankToken(0x0cb8d0b37c7487b11d57f1f33defa2b1d3cfccfe);\\n\\n  // A request to allocate dank to a phone number.\\n  struct PhoneNumberRequest {\\n    address sender;\\n    bytes32 hashedPhoneNumber;\\n  }\\n\\n  // Tracks the DANK allocated to a hashed phone number.\\n  mapping(bytes32 =\\u003e uint) public allocatedDank;\\n\\n  // A mapping between the Oraclize query id and a combination of the\\n  // hashed phone number and the sender so the callback from Oraclize\\n  // can track who\\u0027s been allocated what DANK.\\n  mapping(bytes32 =\\u003e PhoneNumberRequest) public phoneNumberRequests;\\n\\n  // The number of DANK tokens a person gets when they initially sing up.\\n  uint public allotment;\\n\\n  // An event for letting the caller know that they didn\\u0027t supply enough\\n  // ETH to complete the transaction.\\n  event NotEnoughETH(string description, uint ethRequired);\\n\\n  // An event for communicating success/failure of the steps of the\\n  // verification process, including calls to the Oraclize service.\\n  event DankEvent(bytes32 hashedPhoneNumber, bool successful, string description);\\n\\n  // An event for communicating the id from Oraclize and a message.\\n  event OraclizeCall(bytes32 id, string msg);\\n\\n  // An event fired when a person\\u0027s allotment is reset by the faucet.\\n  event DankReset(bytes32 hashedPhoneNumber);\\n\\n  /**\\n   * Sets the initial allotment of DANK tokens, the number of tokens\\n   * a person gets for initially singing up. Expects DANK values in wei.\\n   */\\n  constructor(uint initialDank) public {\\n    allotment = initialDank;\\n\\n    // Comment out this line when deploying to production\\n    // See: https://github.com/oraclize/ethereum-bridge\\n    //OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\\n  }\\n\\n  /**\\n   * If this person doesn\\u0027t already have an initial allotment of Dank this function calls the\\n   * second half of the phone number verification API. If their phone number checks out it\\n   * transfers them an allotment of Dank that was set by the constructor.\\n   */\\n  function verifyAndAcquireDank(bytes32 hashedPhoneNumber, string oraclizeQuery) public {\\n    if (oraclize_getPrice(\\\"URL\\\") \\u003e address(this).balance) {\\n      emit NotEnoughETH(\\\"Oraclize query for phone number verification was NOT sent, add more ETH.\\\", oraclize_getPrice(\\\"URL\\\"));\\n    } else {\\n      bytes32 queryId = oraclize_query(\\\"nested\\\", oraclizeQuery);\\n      phoneNumberRequests[queryId] = PhoneNumberRequest(msg.sender, hashedPhoneNumber);\\n    }\\n  }\\n\\n  /**\\n   * Callback fuction for reqeusts to Oraclize. The name and signature are\\n   * required by Oraclize.\\n   */\\n  function __callback(bytes32 queryId, string result) public {\\n    emit OraclizeCall(queryId, result);\\n\\n    if (msg.sender != oraclize_cbAddress()) {\\n        revert(\\\"The sender\\u0027s address does not match Oraclize\\u0027s address.\\\");\\n    }\\n    else {\\n        PhoneNumberRequest storage phoneNumberRequest = phoneNumberRequests[queryId];\\n        uint previouslyAllocatedDank = allocatedDank[phoneNumberRequest.hashedPhoneNumber];\\n\\n        if ((previouslyAllocatedDank \\u003c= 0) \\u0026\\u0026 (dankToken.balanceOf(address(this)) \\u003e= allotment)) {\\n          bool dankTransfered = dankToken.transfer(phoneNumberRequest.sender, allotment);\\n          if (dankTransfered) {\\n            allocatedDank[phoneNumberRequest.hashedPhoneNumber] = allotment;\\n            emit DankEvent(phoneNumberRequest.hashedPhoneNumber, dankTransfered, \\\"DANK transfered\\\");\\n          }\\n        }\\n        else {\\n          emit DankEvent(phoneNumberRequest.hashedPhoneNumber, false, \\\"DANK already allocated.\\\");\\n        }\\n    }\\n  }\\n\\n  /**\\n   * Returns the amount of ETH this contract has available. ETH is used to pay for\\n   * having Oraclize call the external API for validating phone numbers.\\n   */\\n  function getBalance() public view returns (uint256) {\\n      return address(this).balance;\\n  }\\n\\n  /**\\n   * Simple function to allow for adding ETH to the contract.\\n   */\\n  function sendEth() public payable { }\\n\\n  /**\\n   * Allow the owner to reset the DANK we\\u0027ve allocated to a phone number.\\n   */\\n  function resetAllocatedDankForPhoneNumber(bytes32 hashedPhoneNumber) auth {\\n    delete allocatedDank[hashedPhoneNumber];\\n    emit DankReset(hashedPhoneNumber);\\n  }\\n\\n  /**\\n   * Allow the owner to reset the limits on the amount distributed by the faucet.\\n   */\\n  function resetAllotment(uint initialDank) auth {\\n    allotment = initialDank;\\n  }\\n}\\n\"},\"DankToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./MiniMeToken.sol\\\";\\n\\n/**\\n * @title Token used for curation of MemeFactory TCR\\n *\\n * @dev Standard MiniMe Token with pre-minted supply and with dead controller.\\n */\\n\\ncontract DankToken is MiniMeToken {\\n  function DankToken(address _tokenFactory, uint _mintedAmount)\\n  MiniMeToken(\\n    _tokenFactory,\\n    0x0,\\n    0,\\n    \\\"Dank Token\\\",\\n    18,\\n    \\\"DANK\\\",\\n    true\\n  )\\n  {\\n    generateTokens(msg.sender, _mintedAmount);\\n    changeController(0x0);\\n  }\\n}\"},\"DelegateProxy.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract DelegateProxy {\\n  /**\\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\\n  * @param _dst Destination address to perform the delegatecall\\n  * @param _calldata Calldata for the delegatecall\\n  */\\n  function delegatedFwd(address _dst, bytes _calldata) internal {\\n    require(isContract(_dst));\\n    assembly {\\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n      let size := returndatasize\\n\\n      let ptr := mload(0x40)\\n      returndatacopy(ptr, 0, size)\\n\\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n    // if the call returned error data, forward it\\n      switch result case 0 {revert(ptr, size)}\\n      default {return (ptr, size)}\\n    }\\n  }\\n\\n  function isContract(address _target) internal view returns (bool) {\\n    uint256 size;\\n    assembly {size := extcodesize(_target)}\\n    return size \\u003e 0;\\n  }\\n}\"},\"DistrictConfig.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DistrictConfig is DSAuth {\\n  address public depositCollector;\\n  address public memeAuctionCutCollector;\\n  uint public memeAuctionCut; // Values 0-10,000 map to 0%-100%\\n\\n  function DistrictConfig(address _depositCollector, address _memeAuctionCutCollector, uint _memeAuctionCut) {\\n    require(_depositCollector != 0x0, \\\"District Config deposit collector isn\\u0027t 0x0\\\");\\n    require(_memeAuctionCutCollector != 0x0, \\\"District Config meme auction cut collector isn\\u0027t 0x0\\\");\\n    require(_memeAuctionCut \\u003c 10000, \\\"District Config meme auction cut should be \\u003c 1000\\\");\\n    depositCollector = _depositCollector;\\n    memeAuctionCutCollector = _memeAuctionCutCollector;\\n    memeAuctionCut = _memeAuctionCut;\\n  }\\n\\n  function setDepositCollector(address _depositCollector) public auth {\\n    require(_depositCollector != 0x0, \\\"District Config deposit collector isn\\u0027t 0x0\\\");\\n    depositCollector = _depositCollector;\\n  }\\n\\n  function setMemeAuctionCutCollector(address _memeAuctionCutCollector) public auth {\\n    require(_memeAuctionCutCollector != 0x0, \\\"District Config meme auction cut collector isn\\u0027t 0x0\\\");\\n    memeAuctionCutCollector = _memeAuctionCutCollector;\\n  }\\n\\n  function setCollectors(address _collector) public auth {\\n    setDepositCollector(_collector);\\n    setMemeAuctionCutCollector(_collector);\\n  }\\n\\n  function setMemeAuctionCut(uint _memeAuctionCut) public auth {\\n    require(_memeAuctionCut \\u003c 10000, \\\"District Config meme auction cut should be \\u003c 1000\\\");\\n    memeAuctionCut = _memeAuctionCut;\\n  }\\n}\\n\"},\"DSAuth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\ncontract DSAuthority {\\n  function canCall(\\n    address src, address dst, bytes4 sig\\n  ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n  event LogSetAuthority (address indexed authority);\\n  event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n  DSAuthority  public  authority;\\n  address      public  owner;\\n\\n  function DSAuth() public {\\n    owner = msg.sender;\\n    LogSetOwner(msg.sender);\\n  }\\n\\n  function setOwner(address owner_)\\n  public\\n  auth\\n  {\\n    owner = owner_;\\n    LogSetOwner(owner);\\n  }\\n\\n  function setAuthority(DSAuthority authority_)\\n  public\\n  auth\\n  {\\n    authority = authority_;\\n    LogSetAuthority(authority);\\n  }\\n\\n  modifier auth {\\n    require(isAuthorized(msg.sender, msg.sig));\\n    _;\\n  }\\n\\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n    if (src == address(this)) {\\n      return true;\\n    } else if (src == owner) {\\n      return true;\\n    } else if (authority == DSAuthority(0)) {\\n      return false;\\n    } else {\\n      return authority.canCall(src, this, sig);\\n    }\\n  }\\n}\\n\"},\"DSGuard.sol\":{\"content\":\"// guard.sol -- simple whitelist implementation of DSAuthority\\n\\n// Copyright (C) 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DSGuardEvents {\\n  event LogPermit(\\n    bytes32 indexed src,\\n    bytes32 indexed dst,\\n    bytes32 indexed sig\\n  );\\n  event LogForbid(\\n    bytes32 indexed src,\\n    bytes32 indexed dst,\\n    bytes32 indexed sig\\n  );\\n}\\n\\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\\n  bytes32 constant public ANY = bytes32(uint(- 1));\\n  mapping(bytes32 =\\u003e mapping(bytes32 =\\u003e mapping(bytes32 =\\u003e bool))) acl;\\n\\n  function canCall(\\n    address src_, address dst_, bytes4 sig\\n  ) public view returns (bool) {\\n    bytes32 src = bytes32(src_);\\n    bytes32 dst = bytes32(dst_);\\n\\n    return acl[src][dst][sig]\\n    || acl[src][dst][ANY]\\n    || acl[src][ANY][sig]\\n    || acl[src][ANY][ANY]\\n    || acl[ANY][dst][sig]\\n    || acl[ANY][dst][ANY]\\n    || acl[ANY][ANY][sig]\\n    || acl[ANY][ANY][ANY];\\n  }\\n\\n  function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n    acl[src][dst][sig] = true;\\n    LogPermit(src, dst, sig);\\n  }\\n\\n  function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n    acl[src][dst][sig] = false;\\n    LogForbid(src, dst, sig);\\n  }\\n\\n  function permit(address src, address dst, bytes32 sig) public {\\n    permit(bytes32(src), bytes32(dst), sig);\\n  }\\n\\n  function forbid(address src, address dst, bytes32 sig) public {\\n    forbid(bytes32(src), bytes32(dst), sig);\\n  }\\n}\\n\\ncontract DSGuardFactory {\\n  mapping(address =\\u003e bool)  public  isGuard;\\n\\n  function newGuard() public returns (DSGuard guard) {\\n    guard = new DSGuard();\\n    guard.setOwner(msg.sender);\\n    isGuard[guard] = true;\\n  }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Enumerable is ERC721Basic {\\n  function totalSupply() public view returns (uint256);\\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\\n  function tokenByIndex(uint256 _index) public view returns (uint256);\\n}\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Metadata is ERC721Basic {\\n  function name() public view returns (string _name);\\n  function symbol() public view returns (string _symbol);\\n  function tokenURI(uint256 _tokenId) public view returns (address);\\n}\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\\n}\\n\"},\"ERC721Basic.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Basic {\\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _timestamp);\\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n  function balanceOf(address _owner) public view returns (uint256 _balance);\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\\n  function exists(uint256 _tokenId) public view returns (bool _exists);\\n\\n  function approve(address _to, uint256 _tokenId) public;\\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\\n\\n  function setApprovalForAll(address _operator, bool _approved) public;\\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n  public;\\n}\\n\"},\"ERC721BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\nimport \\\"./ERC721Receiver.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./AddressUtils.sol\\\";\\n\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721BasicToken is ERC721Basic {\\n  using SafeMath for uint256;\\n  using AddressUtils for address;\\n\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\\n\\n  // Mapping from token ID to owner\\n  mapping (uint256 =\\u003e address) internal tokenOwner;\\n\\n  // Mapping from token ID to approved address\\n  mapping (uint256 =\\u003e address) internal tokenApprovals;\\n\\n  // Mapping from owner to number of owned token\\n  mapping (address =\\u003e uint256) internal ownedTokensCount;\\n\\n  // Mapping from owner to operator approvals\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal operatorApprovals;\\n\\n  /**\\n  * @dev Guarantees msg.sender is owner of the given token\\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\\n  */\\n  modifier onlyOwnerOf(uint256 _tokenId) {\\n    require(ownerOf(_tokenId) == msg.sender);\\n    _;\\n  }\\n\\n  /**\\n  * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\\n  * @param _tokenId uint256 ID of the token to validate\\n  */\\n  modifier canTransfer(uint256 _tokenId) {\\n    require(isApprovedOrOwner(msg.sender, _tokenId));\\n    _;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address\\n  * @param _owner address to query the balance of\\n  * @return uint256 representing the amount owned by the passed address\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    require(_owner != address(0));\\n    return ownedTokensCount[_owner];\\n  }\\n\\n  /**\\n  * @dev Gets the owner of the specified token ID\\n  * @param _tokenId uint256 ID of the token to query the owner of\\n  * @return owner address currently marked as the owner of the given token ID\\n  */\\n  function ownerOf(uint256 _tokenId) public view returns (address) {\\n    address owner = tokenOwner[_tokenId];\\n    require(owner != address(0));\\n    return owner;\\n  }\\n\\n  /**\\n  * @dev Returns whether the specified token exists\\n  * @param _tokenId uint256 ID of the token to query the existance of\\n  * @return whether the token exists\\n  */\\n  function exists(uint256 _tokenId) public view returns (bool) {\\n    address owner = tokenOwner[_tokenId];\\n    return owner != address(0);\\n  }\\n\\n  /**\\n  * @dev Approves another address to transfer the given token ID\\n  * @dev The zero address indicates there is no approved address.\\n  * @dev There can only be one approved address per token at a given time.\\n  * @dev Can only be called by the token owner or an approved operator.\\n  * @param _to address to be approved for the given token ID\\n  * @param _tokenId uint256 ID of the token to be approved\\n  */\\n  function approve(address _to, uint256 _tokenId) public {\\n    address owner = ownerOf(_tokenId);\\n    require(_to != owner);\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n\\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\\n      tokenApprovals[_tokenId] = _to;\\n      Approval(owner, _to, _tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\n   * @param _tokenId uint256 ID of the token to query the approval of\\n   * @return address currently approved for a the given token ID\\n   */\\n  function getApproved(uint256 _tokenId) public view returns (address) {\\n    return tokenApprovals[_tokenId];\\n  }\\n\\n  /**\\n  * @dev Sets or unsets the approval of a given operator\\n  * @dev An operator is allowed to transfer all tokens of the sender on their behalf\\n  * @param _to operator address to set the approval\\n  * @param _approved representing the status of the approval to be set\\n  */\\n  function setApprovalForAll(address _to, bool _approved) public {\\n    require(_to != msg.sender);\\n    operatorApprovals[msg.sender][_to] = _approved;\\n    ApprovalForAll(msg.sender, _to, _approved);\\n  }\\n\\n  /**\\n   * @dev Tells whether an operator is approved by a given owner\\n   * @param _owner owner address which you want to query the approval of\\n   * @param _operator operator address which you want to query the approval of\\n   * @return bool whether the given operator is approved by the given owner\\n   */\\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\n    return operatorApprovals[_owner][_operator];\\n  }\\n\\n  /**\\n  * @dev Transfers the ownership of a given token ID to another address\\n  * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\n  * @dev Requires the msg sender to be the owner, approved, or operator\\n  * @param _from current owner of the token\\n  * @param _to address to receive the ownership of the given token ID\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\\n    require(_from != address(0));\\n    require(_to != address(0));\\n\\n    clearApproval(_from, _tokenId);\\n    removeTokenFrom(_from, _tokenId);\\n    addTokenTo(_to, _tokenId);\\n\\n    Transfer(_from, _to, _tokenId, now);\\n  }\\n\\n  /**\\n  * @dev Safely transfers the ownership of a given token ID to another address\\n  * @dev If the target address is a contract, it must implement `onERC721Received`,\\n  *  which is called upon a safe transfer, and return the magic value\\n  *  `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\n  *  the transfer is reverted.\\n  * @dev Requires the msg sender to be the owner, approved, or operator\\n  * @param _from current owner of the token\\n  * @param _to address to receive the ownership of the given token ID\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n  public\\n  canTransfer(_tokenId)\\n  {\\n    safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n  * @dev Safely transfers the ownership of a given token ID to another address\\n  * @dev If the target address is a contract, it must implement `onERC721Received`,\\n  *  which is called upon a safe transfer, and return the magic value\\n  *  `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\n  *  the transfer is reverted.\\n  * @dev Requires the msg sender to be the owner, approved, or operator\\n  * @param _from current owner of the token\\n  * @param _to address to receive the ownership of the given token ID\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  * @param _data bytes data to send along with a safe transfer check\\n  */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n  public\\n  canTransfer(_tokenId)\\n  {\\n    transferFrom(_from, _to, _tokenId);\\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\\n  }\\n\\n  /**\\n   * @dev Returns whether the given spender can transfer a given token ID\\n   * @param _spender address of the spender to query\\n   * @param _tokenId uint256 ID of the token to be transferred\\n   * @return bool whether the msg.sender is approved for the given token ID,\\n   *  is an operator of the owner, or is the owner of the token\\n   */\\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\\n    address owner = ownerOf(_tokenId);\\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\\n  }\\n\\n  /**\\n  * @dev Internal function to mint a new token\\n  * @dev Reverts if the given token ID already exists\\n  * @param _to The address that will own the minted token\\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\n  */\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    require(_to != address(0));\\n    addTokenTo(_to, _tokenId);\\n    Transfer(address(0), _to, _tokenId, now);\\n  }\\n\\n  /**\\n  * @dev Internal function to burn a specific token\\n  * @dev Reverts if the token does not exist\\n  * @param _tokenId uint256 ID of the token being burned by the msg.sender\\n  */\\n  function _burn(address _owner, uint256 _tokenId) internal {\\n    clearApproval(_owner, _tokenId);\\n    removeTokenFrom(_owner, _tokenId);\\n    Transfer(_owner, address(0), _tokenId, now);\\n  }\\n\\n  /**\\n  * @dev Internal function to clear current approval of a given token ID\\n  * @dev Reverts if the given address is not indeed the owner of the token\\n  * @param _owner owner of the token\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function clearApproval(address _owner, uint256 _tokenId) internal {\\n    require(ownerOf(_tokenId) == _owner);\\n    if (tokenApprovals[_tokenId] != address(0)) {\\n      tokenApprovals[_tokenId] = address(0);\\n      Approval(_owner, address(0), _tokenId);\\n    }\\n  }\\n\\n  /**\\n  * @dev Internal function to add a token ID to the list of a given address\\n  * @param _to address representing the new owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\n  */\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\n    require(tokenOwner[_tokenId] == address(0));\\n    tokenOwner[_tokenId] = _to;\\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\\n  }\\n\\n  /**\\n  * @dev Internal function to remove a token ID from the list of a given address\\n  * @param _from address representing the previous owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n  */\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\n    require(ownerOf(_tokenId) == _from);\\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\\n    tokenOwner[_tokenId] = address(0);\\n  }\\n\\n  /**\\n  * @dev Internal function to invoke `onERC721Received` on a target address\\n  * @dev The call is not executed if the target address is not a contract\\n  * @param _from address representing the previous owner of the given token ID\\n  * @param _to target address that will receive the tokens\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  * @param _data bytes optional data to send along with the call\\n  * @return whether the call correctly returned the expected magic value\\n  */\\n  function checkAndCallSafeTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n  internal\\n  returns (bool)\\n  {\\n    if (!_to.isContract()) {\\n      return true;\\n    }\\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\\n    return (retval == ERC721_RECEIVED);\\n  }\\n}\\n\"},\"ERC721Holder.sol\":{\"content\":\"pragma solidity ^0.4.21;\\n\\nimport \\\"./ERC721Receiver.sol\\\";\\n\\n\\ncontract ERC721Holder is ERC721Receiver {\\n  function onERC721Received(address, uint256, bytes) public returns(bytes4) {\\n    return ERC721_RECEIVED;\\n  }\\n}\\n\"},\"ERC721Receiver.sol\":{\"content\":\"pragma solidity ^0.4.21;\\n\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n *  from ERC721 asset contracts.\\n */\\ncontract ERC721Receiver {\\n  /**\\n   * @dev Magic value to be returned upon successful reception of an NFT\\n   *  Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`,\\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\n   */\\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\\n\\n  /**\\n   * @notice Handle the receipt of an NFT\\n   * @dev The ERC721 smart contract calls this function on the recipient\\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\\n   *  than the magic value MUST result in the transaction being reverted.\\n   *  Note: the contract address is always the message sender.\\n   * @param _from The sending address\\n   * @param _tokenId The NFT identifier which is being transfered\\n   * @param _data Additional data with no specified format\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n   */\\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\\n}\\n\"},\"ERC721Token.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./ERC721BasicToken.sol\\\";\\n\\n\\n/**\\n * @title Full ERC721 Token\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Token is ERC721, ERC721BasicToken {\\n  // Token name\\n  string internal name_;\\n\\n  // Token symbol\\n  string internal symbol_;\\n\\n  // Mapping from owner to list of owned token IDs\\n  mapping(address =\\u003e uint256[]) internal ownedTokens;\\n\\n  // Mapping from token ID to index of the owner tokens list\\n  mapping(uint256 =\\u003e uint256) internal ownedTokensIndex;\\n\\n  // Array with all token ids, used for enumeration\\n  uint256[] internal allTokens;\\n\\n  // Mapping from token id to position in the allTokens array\\n  mapping(uint256 =\\u003e uint256) internal allTokensIndex;\\n\\n  // Optional mapping for token URIs\\n  mapping(uint256 =\\u003e address) internal tokenURIs;\\n\\n  /**\\n  * @dev Constructor function\\n  */\\n  function ERC721Token(string _name, string _symbol) public {\\n    name_ = _name;\\n    symbol_ = _symbol;\\n  }\\n\\n  /**\\n  * @dev Gets the token name\\n  * @return string representing the token name\\n  */\\n  function name() public view returns (string) {\\n    return name_;\\n  }\\n\\n  /**\\n  * @dev Gets the token symbol\\n  * @return string representing the token symbol\\n  */\\n  function symbol() public view returns (string) {\\n    return symbol_;\\n  }\\n\\n  /**\\n  * @dev Returns an URI for a given token ID\\n  * @dev Throws if the token ID does not exist. May return an empty string.\\n  * @param _tokenId uint256 ID of the token to query\\n  */\\n  function tokenURI(uint256 _tokenId) public view returns (address) {\\n    require(exists(_tokenId));\\n    return tokenURIs[_tokenId];\\n  }\\n\\n  /**\\n  * @dev Gets the token ID at a given index of the tokens list of the requested owner\\n  * @param _owner address owning the tokens list to be accessed\\n  * @param _index uint256 representing the index to be accessed of the requested tokens list\\n  * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n  */\\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\\n    require(_index \\u003c balanceOf(_owner));\\n    return ownedTokens[_owner][_index];\\n  }\\n\\n  /**\\n  * @dev Gets the total amount of tokens stored by the contract\\n  * @return uint256 representing the total amount of tokens\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return allTokens.length;\\n  }\\n\\n  /**\\n  * @dev Gets the token ID at a given index of all the tokens in this contract\\n  * @dev Reverts if the index is greater or equal to the total number of tokens\\n  * @param _index uint256 representing the index to be accessed of the tokens list\\n  * @return uint256 token ID at the given index of the tokens list\\n  */\\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\\n    require(_index \\u003c totalSupply());\\n    return allTokens[_index];\\n  }\\n\\n  /**\\n  * @dev Internal function to set the token URI for a given token\\n  * @dev Reverts if the token ID does not exist\\n  * @param _tokenId uint256 ID of the token to set its URI\\n  * @param _uri string URI to assign\\n  */\\n  function _setTokenURI(uint256 _tokenId, address _uri) internal {\\n    require(exists(_tokenId));\\n    tokenURIs[_tokenId] = _uri;\\n  }\\n\\n  /**\\n  * @dev Internal function to add a token ID to the list of a given address\\n  * @param _to address representing the new owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\n  */\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\n    super.addTokenTo(_to, _tokenId);\\n    uint256 length = ownedTokens[_to].length;\\n    ownedTokens[_to].push(_tokenId);\\n    ownedTokensIndex[_tokenId] = length;\\n  }\\n\\n  /**\\n  * @dev Internal function to remove a token ID from the list of a given address\\n  * @param _from address representing the previous owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n  */\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\n    super.removeTokenFrom(_from, _tokenId);\\n\\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\\n\\n    ownedTokens[_from][tokenIndex] = lastToken;\\n    ownedTokens[_from][lastTokenIndex] = 0;\\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\\n\\n    ownedTokens[_from].length--;\\n    ownedTokensIndex[_tokenId] = 0;\\n    ownedTokensIndex[lastToken] = tokenIndex;\\n  }\\n\\n  /**\\n  * @dev Internal function to mint a new token\\n  * @dev Reverts if the given token ID already exists\\n  * @param _to address the beneficiary that will own the minted token\\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\n  */\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    super._mint(_to, _tokenId);\\n\\n    allTokensIndex[_tokenId] = allTokens.length;\\n    allTokens.push(_tokenId);\\n  }\\n}\\n\"},\"EternalDb.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Contract to store arbitrary state data, decoupled from any logic related to it\\n *\\n * @dev Original implementation: https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88\\n * In addition to original implementation, this contract uses DSAuth for more advanced authentication options\\n * It also provides way set/get multiple values in single transaction\\n */\\n\\ncontract EternalDb is DSAuth {\\n\\n  enum Types {UInt, String, Address, Bytes, Bytes32, Boolean, Int}\\n\\n  event EternalDbEvent(bytes32[] records, uint[] values, uint timestamp);\\n\\n  function EternalDb(){\\n  }\\n\\n  ////////////\\n  //UInt\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e uint) UIntStorage;\\n\\n  function getUIntValue(bytes32 record) constant returns (uint){\\n    return UIntStorage[record];\\n  }\\n\\n  function getUIntValues(bytes32[] records) constant returns (uint[] results){\\n    results = new uint[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = UIntStorage[records[i]];\\n    }\\n  }\\n\\n  function setUIntValue(bytes32 record, uint value)\\n  auth\\n  {\\n    UIntStorage[record] = value;\\n    bytes32[] memory records = new bytes32[](1);\\n    records[0] = record;\\n    uint[] memory values = new uint[](1);\\n    values[0] = value;\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function setUIntValues(bytes32[] records, uint[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      UIntStorage[records[i]] = values[i];\\n    }\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function deleteUIntValue(bytes32 record)\\n  auth\\n  {\\n    delete UIntStorage[record];\\n  }\\n\\n  ////////////\\n  //Strings\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e string) StringStorage;\\n\\n  function getStringValue(bytes32 record) constant returns (string){\\n    return StringStorage[record];\\n  }\\n\\n  function setStringValue(bytes32 record, string value)\\n  auth\\n  {\\n    StringStorage[record] = value;\\n  }\\n\\n  function deleteStringValue(bytes32 record)\\n  auth\\n  {\\n    delete StringStorage[record];\\n  }\\n\\n  ////////////\\n  //Address\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e address) AddressStorage;\\n\\n  function getAddressValue(bytes32 record) constant returns (address){\\n    return AddressStorage[record];\\n  }\\n\\n  function setAddressValues(bytes32[] records, address[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      AddressStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function setAddressValue(bytes32 record, address value)\\n  auth\\n  {\\n    AddressStorage[record] = value;\\n  }\\n\\n  function deleteAddressValue(bytes32 record)\\n  auth\\n  {\\n    delete AddressStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes) BytesStorage;\\n\\n  function getBytesValue(bytes32 record) constant returns (bytes){\\n    return BytesStorage[record];\\n  }\\n\\n  function setBytesValue(bytes32 record, bytes value)\\n  auth\\n  {\\n    BytesStorage[record] = value;\\n  }\\n\\n  function deleteBytesValue(bytes32 record)\\n  auth\\n  {\\n    delete BytesStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes32\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes32) Bytes32Storage;\\n\\n  function getBytes32Value(bytes32 record) constant returns (bytes32){\\n    return Bytes32Storage[record];\\n  }\\n\\n  function getBytes32Values(bytes32[] records) constant returns (bytes32[] results){\\n    results = new bytes32[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = Bytes32Storage[records[i]];\\n    }\\n  }\\n\\n  function setBytes32Value(bytes32 record, bytes32 value)\\n  auth\\n  {\\n    Bytes32Storage[record] = value;\\n  }\\n\\n  function setBytes32Values(bytes32[] records, bytes32[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      Bytes32Storage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBytes32Value(bytes32 record)\\n  auth\\n  {\\n    delete Bytes32Storage[record];\\n  }\\n\\n  ////////////\\n  //Boolean\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bool) BooleanStorage;\\n\\n  function getBooleanValue(bytes32 record) constant returns (bool){\\n    return BooleanStorage[record];\\n  }\\n\\n  function getBooleanValues(bytes32[] records) constant returns (bool[] results){\\n    results = new bool[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = BooleanStorage[records[i]];\\n    }\\n  }\\n\\n  function setBooleanValue(bytes32 record, bool value)\\n  auth\\n  {\\n    BooleanStorage[record] = value;\\n  }\\n\\n  function setBooleanValues(bytes32[] records, bool[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      BooleanStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBooleanValue(bytes32 record)\\n  auth\\n  {\\n    delete BooleanStorage[record];\\n  }\\n\\n  ////////////\\n  //Int\\n  ////////////\\n  mapping(bytes32 =\\u003e int) IntStorage;\\n\\n  function getIntValue(bytes32 record) constant returns (int){\\n    return IntStorage[record];\\n  }\\n\\n  function getIntValues(bytes32[] records) constant returns (int[] results){\\n    results = new int[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = IntStorage[records[i]];\\n    }\\n  }\\n\\n  function setIntValue(bytes32 record, int value)\\n  auth\\n  {\\n    IntStorage[record] = value;\\n  }\\n\\n  function setIntValues(bytes32[] records, int[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      IntStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteIntValue(bytes32 record)\\n  auth\\n  {\\n    delete IntStorage[record];\\n  }\\n\\n}\\n\"},\"Forwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\n\\ncontract Forwarder is DelegateProxy {\\n  // After compiling contract, `beefbeef...` is replaced in the bytecode by the real target address\\n  address public constant target = 0x1ed7fc52ac5a37aa3ff6d9b94c894724e2f992b1; // checksumed to silence warning\\n\\n  /*\\n  * @dev Forwards all calls to target\\n  */\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n}\"},\"Meme.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntry.sol\\\";\\nimport \\\"./MemeToken.sol\\\";\\nimport \\\"./DistrictConfig.sol\\\";\\n\\n/**\\n * @title Contract created for each submitted Meme into the MemeFactory TCR.\\n *\\n * @dev It extends base RegistryEntry with additional state for storing IPFS hashes for a meme image and meta data.\\n * It also contains state and logic for handling initial meme offering.\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single intance of it.\\n */\\n\\ncontract Meme is RegistryEntry {\\n\\n  DistrictConfig private constant districtConfig = DistrictConfig(0xc3f953d1d9c0117f0988a16f2eda8641467e0b6d);\\n  MemeToken private constant memeToken = MemeToken(0xd23043ce917ac39309f49dba82f264994d3ade76);\\n  bytes private metaHash;\\n  uint private tokenIdStart;\\n  uint private totalSupply;\\n  uint private totalMinted;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders pointing into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   * @param _metaHash IPFS hash of meta data related to a meme\\n   * @param _totalSupply This meme\\u0027s token total supply\\n   */\\n  function construct(\\n                     address _creator,\\n                     uint _version,\\n                     bytes _metaHash,\\n                     uint _totalSupply\\n                     )\\n    external\\n  {\\n    super.construct(_creator, _version);\\n\\n    require(_totalSupply \\u003e 0);\\n    require(_totalSupply \\u003c= registry.db().getUIntValue(registry.maxTotalSupplyKey()));\\n\\n    totalSupply = _totalSupply;\\n    metaHash = _metaHash;\\n\\n    registry.fireMemeConstructedEvent(version,\\n                                      _creator,\\n                                      metaHash,\\n                                      totalSupply,\\n                                      deposit,\\n                                      challenge.challengePeriodEnd);\\n  }\\n\\n  /**\\n   * @dev Transfers deposit to deposit collector\\n   * Must be callable only for whitelisted registry entries\\n   */\\n  function transferDeposit()\\n    external\\n    notEmergency\\n    onlyWhitelisted\\n  {\\n    require(registryToken.transfer(districtConfig.depositCollector(), deposit));\\n\\n  }\\n\\n  function mint(uint _amount)\\n    public\\n    notEmergency\\n    onlyWhitelisted\\n  {\\n    uint restSupply = totalSupply.sub(totalMinted);\\n    if (_amount == 0 || _amount \\u003e restSupply) {\\n      _amount = restSupply;\\n    }\\n\\n    require(_amount \\u003e 0);\\n\\n    tokenIdStart = memeToken.totalSupply().add(1);\\n    uint tokenIdEnd = tokenIdStart.add(_amount);\\n    for (uint i = tokenIdStart; i \\u003c tokenIdEnd; i++) {\\n      memeToken.mint(creator, i);\\n      totalMinted = totalMinted + 1;\\n    }\\n\\n    registry.fireMemeMintedEvent(version,\\n                                 creator,\\n                                 tokenIdStart,\\n                                 tokenIdEnd-1,\\n                                 totalMinted);\\n  }\\n\\n  function loadMeme() external constant returns (bytes,\\n                                                 uint,\\n                                                 uint,\\n                                                 uint){\\n    return(metaHash,\\n           totalSupply,\\n           totalMinted,\\n           tokenIdStart);\\n  }\\n\\n}\\n\"},\"MemeAuction.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721Receiver.sol\\\";\\nimport \\\"./MemeToken.sol\\\";\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./Meme.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MemeAuctionFactory.sol\\\";\\nimport \\\"./DistrictConfig.sol\\\";\\n\\ncontract MemeAuction is ERC721Receiver {\\n  using SafeMath for uint;\\n\\n  DistrictConfig public constant districtConfig = DistrictConfig(0xABCDabcdABcDabcDaBCDAbcdABcdAbCdABcDABCd);\\n  Registry public constant registry = Registry(0xfEEDFEEDfeEDFEedFEEdFEEDFeEdfEEdFeEdFEEd);\\n  MemeToken public constant memeToken = MemeToken(0xdaBBdABbDABbDabbDaBbDabbDaBbdaBbdaBbDAbB);\\n  MemeAuctionFactory public constant memeAuctionFactory = MemeAuctionFactory(0xdAFfDaFfDAfFDAFFDafFdAfFdAffdAffDAFFdAFF);\\n  address public seller;\\n  uint public tokenId;\\n  uint public startPrice;\\n  uint public endPrice;\\n  uint public duration;\\n  uint public startedOn;\\n  string public description;\\n\\n  modifier notEmergency() {\\n    require(!registry.isEmergency(),\\\"MemeAuction: Emergency mode enabled\\\");\\n    _;\\n  }\\n\\n  function construct(address _seller, uint _tokenId)\\n  external\\n  notEmergency\\n  {\\n    require(_seller != 0x0,\\\"MemeAuction: _seller is 0x0\\\");\\n    require(seller == 0x0, \\\"MemeAcution: seller is 0x0\\\");\\n    seller = _seller;\\n    tokenId = _tokenId;\\n  }\\n\\n  function startAuction(uint _startPrice, uint _endPrice, uint _duration, string _description)\\n  external\\n  notEmergency\\n  {\\n    require(memeToken.ownerOf(tokenId) == address(this), \\\"MemeAuction: Not the owner of the token\\\");\\n    require(startedOn == 0, \\\"MemeAuction: Already started\\\");\\n    require(_duration \\u003c= registry.db().getUIntValue(registry.maxAuctionDurationKey()),\\\"MemeAuction: duration \\u003e maxDurationKey\\\");\\n    // Require that all auctions have a duration of\\n    // at least one minute. (Keeps our math from getting hairy!)\\n    require(_duration \\u003e= 1 minutes, \\\"MemeAuction: duration \\u003c 1 minute\\\");\\n\\n    startPrice = _startPrice;\\n    description = _description;\\n    endPrice = _endPrice;\\n    duration = _duration;\\n    startedOn = now;\\n    memeAuctionFactory.fireMemeAuctionStartedEvent(tokenId,\\n                                                   seller,\\n                                                   startPrice,\\n                                                   endPrice,\\n                                                   duration,\\n                                                   description,\\n                                                   startedOn);\\n  }\\n\\n  /**\\n   * @dev Buys meme from auction\\n   * Seller gets ETH paid for a meme token\\n   * If buyer sends more than is current price, extra ETH is sent back to the buyer\\n\\n   */\\n  function buy()\\n  payable\\n  public\\n  notEmergency\\n  {\\n    require(startedOn \\u003e 0, \\\"MemeAuction: Can\\u0027t buy because not started\\\");\\n    var price = currentPrice();\\n    require(msg.value \\u003e= price, \\\"MemeAuction: Can\\u0027t buy because money sent is lower than price\\\");\\n    uint auctioneerCut = 0;\\n    uint sellerProceeds = 0;\\n    if (price \\u003e 0) {\\n      auctioneerCut = computeCut(price);\\n      sellerProceeds = price.sub(auctioneerCut);\\n\\n      seller.transfer(sellerProceeds);\\n      if (msg.value \\u003e price) {\\n        msg.sender.transfer(msg.value.sub(price));\\n      }\\n      if (auctioneerCut \\u003e 0) {\\n        districtConfig.memeAuctionCutCollector().transfer(auctioneerCut);\\n      }\\n    }\\n    memeToken.safeTransferFrom(this, msg.sender, tokenId);\\n\\n    memeAuctionFactory.fireMemeAuctionBuyEvent(msg.sender,\\n                                               price,\\n                                               auctioneerCut,\\n                                               sellerProceeds);\\n  }\\n\\n  function cancel()\\n  external\\n  {\\n    require(startedOn \\u003e 0, \\\"MemeAuction: Can\\u0027t cancel because not started\\\");\\n    require(msg.sender == seller, \\\"MemeAuction: Can\\u0027t cancel because sender is not seller\\\");\\n\\n    memeToken.safeTransferFrom(this, seller, tokenId);\\n    memeAuctionFactory.fireMemeAuctionCanceledEvent();\\n  }\\n\\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data)\\n  public\\n  notEmergency\\n  returns (bytes4)\\n  {\\n    require(_tokenId == tokenId, \\\"MemeAuction: _tokenId is not tokenId\\\");\\n    require(startedOn == 0, \\\"MemeAuction: Already started\\\");\\n    require(this.call(_data), \\\"MemeAuction: No data to call\\\");\\n    return ERC721_RECEIVED;\\n  }\\n\\n  /// @dev Returns current price of an NFT on auction. Broken into two\\n  ///  functions (this one, that computes the duration from the auction\\n  ///  structure, and the other that does the price computation) so we\\n  ///  can easily test that the price computation works correctly.\\n  function currentPrice()\\n  public\\n  constant\\n  returns (uint256)\\n  {\\n    uint256 secondsPassed = 0;\\n\\n    // A bit of insurance against negative values (or wraparound).\\n    // Probably not necessary (since Ethereum guarnatees that the\\n    // now variable doesn\\u0027t ever go backwards).\\n    if (now \\u003e startedOn) {\\n      secondsPassed = now - startedOn;\\n    }\\n\\n    return _computeCurrentPrice(\\n      startPrice,\\n      endPrice,\\n      duration,\\n      secondsPassed\\n    );\\n  }\\n\\n  /// @dev Computes the current price of an auction. Factored out\\n  ///  from _currentPrice so we can run extensive unit tests.\\n  ///  When testing, make this function public and turn on\\n  ///  `Current price computation` test suite.\\n  function _computeCurrentPrice(\\n    uint256 _startingPrice,\\n    uint256 _endingPrice,\\n    uint256 _duration,\\n    uint256 _secondsPassed\\n  )\\n  internal\\n  pure\\n  returns (uint256)\\n  {\\n    // NOTE: We don\\u0027t use SafeMath (or similar) in this function because\\n    //  all of our public functions carefully cap the maximum values for\\n    //  time (at 64-bits) and currency (at 128-bits). _duration is\\n    //  also known to be non-zero (see the require() statement in\\n    //  _addAuction())\\n    if (_secondsPassed \\u003e= _duration) {\\n      // We\\u0027ve reached the end of the dynamic pricing portion\\n      // of the auction, just return the end price.\\n      return _endingPrice;\\n    } else {\\n      // Starting price can be higher than ending price (and often is!), so\\n      // this delta can be negative.\\n      int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\\n\\n      // This multiplication can\\u0027t overflow, _secondsPassed will easily fit within\\n      // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\\n      // will always fit within 256-bits.\\n      int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\\n\\n      // currentPriceChange can be negative, but if so, will have a magnitude\\n      // less that _startingPrice. Thus, this result will always end up positive.\\n      int256 currentPrice = int256(_startingPrice) + currentPriceChange;\\n\\n      return uint256(currentPrice);\\n    }\\n  }\\n\\n  /// @dev Computes owner\\u0027s cut of a sale.\\n  /// @param _price - Sale price of NFT.\\n  function computeCut(uint256 _price)\\n    public\\n    constant\\n    returns (uint256) {\\n    return _price.mul(districtConfig.memeAuctionCut()).div(10000);\\n  }\\n\\n  function() public payable {\\n    buy();\\n  }\\n\\n  function load() external constant returns (address,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             string){\\n    return(seller,\\n           tokenId,\\n           startPrice,\\n           endPrice,\\n           duration,\\n           startedOn,\\n           description);\\n  }\\n}\\n\"},\"MemeAuctionFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721Receiver.sol\\\";\\nimport \\\"./MemeToken.sol\\\";\\nimport \\\"./Forwarder.sol\\\";\\nimport \\\"./MemeAuction.sol\\\";\\n\\ncontract MemeAuctionFactory is ERC721Receiver {\\n  address private dummyTarget; // Keep it here, because this contract is deployed as MutableForwarder\\n\\n  event MemeAuctionStartedEvent(address indexed memeAuction,\\n                                uint tokenId,\\n                                address seller,\\n                                uint startPrice,\\n                                uint endPrice,\\n                                uint duration,\\n                                string description,\\n                                uint startedOn);\\n\\n  event MemeAuctionBuyEvent(address indexed memeAuction,\\n                            address buyer,\\n                            uint price,\\n                            uint auctioneerCut,\\n                            uint sellerProceeds);\\n\\n  event MemeAuctionCanceledEvent(address indexed memeAuction);\\n\\n\\n  MemeToken public memeToken;\\n  bool public wasConstructed;\\n  mapping(address =\\u003e bool) public isMemeAuction;\\n\\n  modifier onlyMemeAuction() {\\n    require(isMemeAuction[msg.sender], \\\"MemeAuctionFactory: onlyMemeAuction falied\\\");\\n    _;\\n  }\\n\\n  function construct(MemeToken _memeToken) public {\\n    require(address(_memeToken) != 0x0, \\\"MemeAuctionFactory: _memeToken address is 0x0\\\");\\n    require(!wasConstructed, \\\"MemeAuctionFactory: Was already constructed\\\");\\n\\n    memeToken = _memeToken;\\n    wasConstructed = true;\\n  }\\n\\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns (bytes4) {\\n    address memeAuction = new Forwarder();\\n    isMemeAuction[memeAuction] = true;\\n    MemeAuction(memeAuction).construct(_from, _tokenId);\\n    memeToken.safeTransferFrom(address(this), memeAuction, _tokenId, _data);\\n    return ERC721_RECEIVED;\\n  }\\n\\n  function fireMemeAuctionStartedEvent(uint tokenId, address seller, uint startPrice, uint endPrice, uint duration, string description, uint startedOn)\\n    onlyMemeAuction\\n  {\\n    emit MemeAuctionStartedEvent(msg.sender,\\n                                 tokenId,\\n                                 seller,\\n                                 startPrice,\\n                                 endPrice,\\n                                 duration,\\n                                 description,\\n                                 startedOn);\\n  }\\n\\n  function fireMemeAuctionBuyEvent(address buyer, uint price, uint auctioneerCut, uint sellerProceeds)\\n    onlyMemeAuction\\n  {\\n    emit MemeAuctionBuyEvent(msg.sender, buyer, price, auctioneerCut, sellerProceeds);\\n  }\\n\\n  function fireMemeAuctionCanceledEvent()\\n    onlyMemeAuction\\n  {\\n    emit MemeAuctionCanceledEvent(msg.sender);\\n  }\\n\\n}\\n\"},\"MemeFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntryFactory.sol\\\";\\nimport \\\"./Meme.sol\\\";\\nimport \\\"./MemeToken.sol\\\";\\n\\n/**\\n * @title Factory contract for creating Meme contracts\\n *\\n * @dev Users submit new memes into this contract.\\n */\\n\\ncontract MemeFactory is RegistryEntryFactory {\\n  uint public constant version = 1;\\n  MemeToken public memeToken;\\n\\n  function MemeFactory(Registry _registry, MiniMeToken _registryToken, MemeToken _memeToken)\\n  RegistryEntryFactory(_registry, _registryToken)\\n  {\\n    memeToken = _memeToken;\\n  }\\n\\n  /**\\n   * @dev Creates new Meme forwarder contract and add it into the registry\\n   * It initializes forwarder contract with initial state. For comments on each param, see Meme::construct\\n   */\\n  function createMeme(\\n    address _creator,\\n    bytes _metaHash,\\n    uint _totalSupply\\n  )\\n  public\\n  {\\n    Meme meme = Meme(createRegistryEntry(_creator));\\n\\n    meme.construct(\\n      _creator,\\n      version,\\n      _metaHash,\\n      _totalSupply\\n    );\\n  }\\n}\\n\"},\"MemeToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721Token.sol\\\";\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Token of a Meme. Single ERC721 instance represents all memes/cards\\n */\\n\\ncontract MemeToken is ERC721Token {\\n  Registry public registry;\\n\\n  modifier onlyRegistryEntry() {\\n    require(registry.isRegistryEntry(msg.sender),\\\"MemeToken: onlyRegistryEntry failed\\\");\\n    _;\\n  }\\n\\n  function MemeToken(Registry _registry)\\n  ERC721Token(\\\"MemeToken\\\", \\\"MEME\\\")\\n  {\\n    registry = _registry;\\n  }\\n\\n  function mint(address _to, uint256 _tokenId)\\n  onlyRegistryEntry\\n  public\\n  {\\n    super._mint(_to, _tokenId);\\n    tokenURIs[_tokenId] = msg.sender;\\n  }\\n\\n  function safeTransferFromMulti(\\n    address _from,\\n    address _to,\\n    uint256[] _tokenIds,\\n    bytes _data\\n  ) {\\n    for (uint i = 0; i \\u003c _tokenIds.length; i++) {\\n      safeTransferFrom(_from, _to, _tokenIds[i], _data);\\n    }\\n  }\\n}\\n\"},\"MiniMeToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/*\\n    Copyright 2016, Jordi Baylina\\n\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n */\\n\\n/// @title MiniMeToken Contract\\n/// @author Jordi Baylina\\n/// @dev This token contract\\u0027s goal is to make it easy for anyone to clone this\\n///  token using the token distribution at a given block, this will allow DAO\\u0027s\\n///  and DApps to upgrade their features in a decentralized manner without\\n///  affecting the original token\\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\\n\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\n\\ncontract ApproveAndCallFallBack {\\n  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\\n}\\n\\n/// @dev The actual token contract, the default controller is the msg.sender\\n///  that deploys the contract, so usually this token will be deployed by a\\n///  token controller contract, which Giveth will call a \\\"Campaign\\\"\\ncontract MiniMeToken is Controlled {\\n\\n  string public name;                //The Token\\u0027s name: e.g. DigixDAO Tokens\\n  uint8 public decimals;             //Number of decimals of the smallest unit\\n  string public symbol;              //An identifier: e.g. REP\\n  string public version = \\u0027MMT_0.2\\u0027; //An arbitrary versioning scheme\\n\\n\\n  /// @dev `Checkpoint` is the structure that attaches a block number to a\\n  ///  given value, the block number attached is the one that last changed the\\n  ///  value\\n  struct  Checkpoint {\\n\\n    // `fromBlock` is the block number that the value was generated from\\n    uint128 fromBlock;\\n\\n    // `value` is the amount of tokens at a specific block number\\n    uint128 value;\\n  }\\n\\n  // `parentToken` is the Token address that was cloned to produce this token;\\n  //  it will be 0x0 for a token that was not cloned\\n  MiniMeToken public parentToken;\\n\\n  // `parentSnapShotBlock` is the block number from the Parent Token that was\\n  //  used to determine the initial distribution of the Clone Token\\n  uint public parentSnapShotBlock;\\n\\n  // `creationBlock` is the block number that the Clone Token was created\\n  uint public creationBlock;\\n\\n  // `balances` is the map that tracks the balance of each address, in this\\n  //  contract when the balance changes the block number that the change\\n  //  occurred is also included in the map\\n  mapping (address =\\u003e Checkpoint[]) balances;\\n\\n  // `allowed` tracks any extra transfer rights as in all ERC20 tokens\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n  // Tracks the history of the `totalSupply` of the token\\n  Checkpoint[] totalSupplyHistory;\\n\\n  // Flag that determines if the token is transferable or not.\\n  bool public transfersEnabled;\\n\\n  // The factory used to create new clone tokens\\n  MiniMeTokenFactory public tokenFactory;\\n\\n  ////////////////\\n  // Constructor\\n  ////////////////\\n\\n  /// @notice Constructor to create a MiniMeToken\\n  /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\\n  ///  will create the Clone token contracts, the token factory needs to be\\n  ///  deployed first\\n  /// @param _parentToken Address of the parent token, set to 0x0 if it is a\\n  ///  new token\\n  /// @param _parentSnapShotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token, set to 0 if it\\n  ///  is a new token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  function MiniMeToken(\\n    address _tokenFactory,\\n    address _parentToken,\\n    uint _parentSnapShotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public {\\n    tokenFactory = MiniMeTokenFactory(_tokenFactory);\\n    name = _tokenName;                                 // Set the name\\n    decimals = _decimalUnits;                          // Set the decimals\\n    symbol = _tokenSymbol;                             // Set the symbol\\n    parentToken = MiniMeToken(_parentToken);\\n    parentSnapShotBlock = _parentSnapShotBlock;\\n    transfersEnabled = _transfersEnabled;\\n    creationBlock = block.number;\\n  }\\n\\n\\n  ///////////////////\\n  // ERC20 Methods\\n  ///////////////////\\n\\n  /// @notice Send `_amount` tokens to `_to` from `msg.sender`\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return Whether the transfer was successful or not\\n  function transfer(address _to, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n    doTransfer(msg.sender, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\\n  ///  is approved by `_from`\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function transferFrom(address _from, address _to, uint256 _amount\\n  ) public returns (bool success) {\\n\\n    // The controller of this contract can move tokens around at will,\\n    //  this is important to recognize! Confirm that you trust the\\n    //  controller of this contract, which in most situations should be\\n    //  another open source smart contract or 0x0\\n    if (msg.sender != controller) {\\n      require(transfersEnabled);\\n\\n      // The standard ERC 20 transferFrom functionality\\n      require(allowed[_from][msg.sender] \\u003e= _amount);\\n      allowed[_from][msg.sender] -= _amount;\\n    }\\n    doTransfer(_from, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This is the actual transfer function in the token contract, it can\\n  ///  only be called by other functions in this contract.\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function doTransfer(address _from, address _to, uint _amount\\n  ) internal {\\n\\n    if (_amount == 0) {\\n      Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0\\n      return;\\n    }\\n\\n    require(parentSnapShotBlock \\u003c block.number);\\n\\n    // Do not allow transfer to 0x0 or the token contract itself\\n    require((_to != 0) \\u0026\\u0026 (_to != address(this)));\\n\\n    // If the amount being transfered is more than the balance of the\\n    //  account the transfer throws\\n    var previousBalanceFrom = balanceOfAt(_from, block.number);\\n\\n    require(previousBalanceFrom \\u003e= _amount);\\n\\n    // Alerts the token controller of the transfer\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onTransfer(_from, _to, _amount));\\n    }\\n\\n    // First update the balance array with the new value for the address\\n    //  sending the tokens\\n    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\\n\\n    // Then update the balance array with the new value for the address\\n    //  receiving the tokens\\n    var previousBalanceTo = balanceOfAt(_to, block.number);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\\n\\n    // An event to make the transfer easy to find on the blockchain\\n    Transfer(_from, _to, _amount);\\n\\n  }\\n\\n  /// @param _owner The address that\\u0027s balance is being requested\\n  /// @return The balance of `_owner` at the current block\\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\\n    return balanceOfAt(_owner, block.number);\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\\n  ///  its behalf. This is a modified version of the ERC20 approve function\\n  ///  to be a little bit safer\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the approval was successful\\n  function approve(address _spender, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(_spender,0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    // Alerts the token controller of the approve function call\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\\n    }\\n\\n    allowed[msg.sender][_spender] = _amount;\\n    Approval(msg.sender, _spender, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to read the `allowed[]` map\\n  /// @param _owner The address of the account that owns the token\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\\n  ///  to spend\\n  function allowance(address _owner, address _spender\\n  ) public constant returns (uint256 remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\\n  ///  its behalf, and then a function is triggered in the contract that is\\n  ///  being approved, `_spender`. This allows users to use their tokens to\\n  ///  interact with contracts in one function call instead of two\\n  /// @param _spender The address of the contract able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the function call was successful\\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData\\n  ) public returns (bool success) {\\n    require(approve(_spender, _amount));\\n\\n    ApproveAndCallFallBack(_spender).receiveApproval(\\n      msg.sender,\\n      _amount,\\n      this,\\n      _extraData\\n    );\\n\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to get the total number of tokens\\n  /// @return The total number of tokens\\n  function totalSupply() public constant returns (uint) {\\n    return totalSupplyAt(block.number);\\n  }\\n\\n\\n  ////////////////\\n  // Query balance and totalSupply in History\\n  ////////////////\\n\\n  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\\n  /// @param _owner The address from which the balance will be retrieved\\n  /// @param _blockNumber The block number when the balance is queried\\n  /// @return The balance at `_blockNumber`\\n  function balanceOfAt(address _owner, uint _blockNumber) public constant\\n  returns (uint) {\\n\\n    // These next few lines are used when the balance of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.balanceOfAt` be queried at the\\n    //  genesis block for that token as this contains initial balance of\\n    //  this token\\n    if ((balances[_owner].length == 0)\\n      || (balances[_owner][0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        // Has no parent\\n        return 0;\\n      }\\n\\n      // This will return the expected balance during normal situations\\n    } else {\\n      return getValueAt(balances[_owner], _blockNumber);\\n    }\\n  }\\n\\n  /// @notice Total amount of tokens at a specific `_blockNumber`.\\n  /// @param _blockNumber The block number when the totalSupply is queried\\n  /// @return The total amount of tokens at `_blockNumber`\\n  function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\\n\\n    // These next few lines are used when the totalSupply of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.totalSupplyAt` be queried at the\\n    //  genesis block for this token as that contains totalSupply of this\\n    //  token at this block number.\\n    if ((totalSupplyHistory.length == 0)\\n      || (totalSupplyHistory[0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        return 0;\\n      }\\n\\n      // This will return the expected totalSupply during normal situations\\n    } else {\\n      return getValueAt(totalSupplyHistory, _blockNumber);\\n    }\\n  }\\n\\n  ////////////////\\n  // Clone Token Method\\n  ////////////////\\n\\n  /// @notice Creates a new clone token with the initial distribution being\\n  ///  this token at `_snapshotBlock`\\n  /// @param _cloneTokenName Name of the clone token\\n  /// @param _cloneDecimalUnits Number of decimals of the smallest unit\\n  /// @param _cloneTokenSymbol Symbol of the clone token\\n  /// @param _snapshotBlock Block when the distribution of the parent token is\\n  ///  copied to set the initial distribution of the new clone token;\\n  ///  if the block is zero than the actual block, the current block is used\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  /// @return The address of the new MiniMeToken Contract\\n  function createCloneToken(\\n    string _cloneTokenName,\\n    uint8 _cloneDecimalUnits,\\n    string _cloneTokenSymbol,\\n    uint _snapshotBlock,\\n    bool _transfersEnabled\\n  ) public returns(address) {\\n    if (_snapshotBlock == 0) _snapshotBlock = block.number;\\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\\n      this,\\n      _snapshotBlock,\\n      _cloneTokenName,\\n      _cloneDecimalUnits,\\n      _cloneTokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    cloneToken.changeController(msg.sender);\\n\\n    // An event to make the token easy to find on the blockchain\\n    NewCloneToken(address(cloneToken), _snapshotBlock);\\n    return address(cloneToken);\\n  }\\n\\n  ////////////////\\n  // Generate and destroy tokens\\n  ////////////////\\n\\n  /// @notice Generates `_amount` tokens that are assigned to `_owner`\\n  /// @param _owner The address that will be assigned the new tokens\\n  /// @param _amount The quantity of tokens generated\\n  /// @return True if the tokens are generated correctly\\n  function generateTokens(address _owner, uint _amount\\n  ) public onlyController returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply + _amount \\u003e= curTotalSupply); // Check for overflow\\n    uint previousBalanceTo = balanceOf(_owner);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\\n    Transfer(0, _owner, _amount);\\n    return true;\\n  }\\n\\n\\n  /// @notice Burns `_amount` tokens from `_owner`\\n  /// @param _owner The address that will lose the tokens\\n  /// @param _amount The quantity of tokens to burn\\n  /// @return True if the tokens are burned correctly\\n  function destroyTokens(address _owner, uint _amount\\n  ) onlyController public returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply \\u003e= _amount);\\n    uint previousBalanceFrom = balanceOf(_owner);\\n    require(previousBalanceFrom \\u003e= _amount);\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\\n    Transfer(_owner, 0, _amount);\\n    return true;\\n  }\\n\\n  ////////////////\\n  // Enable tokens transfers\\n  ////////////////\\n\\n\\n  /// @notice Enables token holders to transfer their tokens freely if true\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  function enableTransfers(bool _transfersEnabled) public onlyController {\\n    transfersEnabled = _transfersEnabled;\\n  }\\n\\n  ////////////////\\n  // Internal helper functions to query and set a value in a snapshot array\\n  ////////////////\\n\\n  /// @dev `getValueAt` retrieves the number of tokens at a given block number\\n  /// @param checkpoints The history of values being queried\\n  /// @param _block The block number to retrieve the value at\\n  /// @return The number of tokens being queried\\n  function getValueAt(Checkpoint[] storage checkpoints, uint _block\\n  ) constant internal returns (uint) {\\n    if (checkpoints.length == 0) return 0;\\n\\n    // Shortcut for the actual value\\n    if (_block \\u003e= checkpoints[checkpoints.length-1].fromBlock)\\n      return checkpoints[checkpoints.length-1].value;\\n    if (_block \\u003c checkpoints[0].fromBlock) return 0;\\n\\n    // Binary search of the value in the array\\n    uint min = 0;\\n    uint max = checkpoints.length-1;\\n    while (max \\u003e min) {\\n      uint mid = (max + min + 1)/ 2;\\n      if (checkpoints[mid].fromBlock\\u003c=_block) {\\n        min = mid;\\n      } else {\\n        max = mid-1;\\n      }\\n    }\\n    return checkpoints[min].value;\\n  }\\n\\n  /// @dev `updateValueAtNow` used to update the `balances` map and the\\n  ///  `totalSupplyHistory`\\n  /// @param checkpoints The history of data being updated\\n  /// @param _value The new number of tokens\\n  function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\\n  ) internal  {\\n    if ((checkpoints.length == 0)\\n      || (checkpoints[checkpoints.length -1].fromBlock \\u003c block.number)) {\\n      Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\\n      newCheckPoint.fromBlock =  uint128(block.number);\\n      newCheckPoint.value = uint128(_value);\\n    } else {\\n      Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\\n      oldCheckPoint.value = uint128(_value);\\n    }\\n  }\\n\\n  /// @dev Internal function to determine if an address is a contract\\n  /// @param _addr The address being queried\\n  /// @return True if `_addr` is a contract\\n  function isContract(address _addr) constant internal returns(bool) {\\n    uint size;\\n    if (_addr == 0) return false;\\n    assembly {\\n      size := extcodesize(_addr)\\n    }\\n    return size\\u003e0;\\n  }\\n\\n  /// @dev Helper function to return a min betwen the two uints\\n  function min(uint a, uint b) pure internal returns (uint) {\\n    return a \\u003c b ? a : b;\\n  }\\n\\n  /// @notice The fallback function: If the contract\\u0027s controller has not been\\n  ///  set to 0, then the `proxyPayment` method is called which relays the\\n  ///  ether and creates tokens as described in the token controller contract\\n  function () public payable {\\n    require(isContract(controller));\\n    require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\\n  }\\n\\n  //////////\\n  // Safety Methods\\n  //////////\\n\\n  /// @notice This method can be used by the controller to extract mistakenly\\n  ///  sent tokens to this contract.\\n  /// @param _token The address of the token contract that you want to recover\\n  ///  set to 0 in case you want to extract ether.\\n  function claimTokens(address _token) public onlyController {\\n    if (_token == 0x0) {\\n      controller.transfer(this.balance);\\n      return;\\n    }\\n\\n    MiniMeToken token = MiniMeToken(_token);\\n    uint balance = token.balanceOf(this);\\n    token.transfer(controller, balance);\\n    ClaimedTokens(_token, controller, balance);\\n  }\\n\\n  ////////////////\\n  // Events\\n  ////////////////\\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\\n  event Transfer(address indexed _from, address indexed _to, uint256 _amount);\\n  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _amount\\n  );\\n\\n}\\n\\n\\n////////////////\\n// MiniMeTokenFactory\\n////////////////\\n\\n/// @dev This contract is used to generate clone contracts from a contract.\\n///  In solidity this is the way to create a contract from a contract of the\\n///  same class\\ncontract MiniMeTokenFactory {\\n\\n  /// @notice Update the DApp by creating a new token with new functionalities\\n  ///  the msg.sender becomes the controller of this clone token\\n  /// @param _parentToken Address of the token being cloned\\n  /// @param _snapshotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  /// @return The address of the new token contract\\n  function createCloneToken(\\n    address _parentToken,\\n    uint _snapshotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public returns (MiniMeToken) {\\n    MiniMeToken newToken = new MiniMeToken(\\n      this,\\n      _parentToken,\\n      _snapshotBlock,\\n      _tokenName,\\n      _decimalUnits,\\n      _tokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    newToken.changeController(msg.sender);\\n    return newToken;\\n  }\\n}\\n\"},\"MutableForwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Forwarder proxy contract with editable target\\n *\\n * @dev For TCR Registry contracts (Registry.sol, ParamChangeRegistry.sol) we use mutable forwarders instead of using\\n * contracts directly. This is for better upgradeability. Since registry contracts fire all events related to registry\\n * entries, we want to be able to access whole history of events always on the same address. Which would be address of\\n * a MutableForwarder. When a registry contract is replaced with updated one, mutable forwarder just replaces target\\n * and all events stay still accessible on the same address.\\n */\\n\\ncontract MutableForwarder is DelegateProxy, DSAuth {\\n\\n  address public target = 0xBEeFbeefbEefbeEFbeEfbEEfBEeFbeEfBeEfBeef; // checksumed to silence warning\\n\\n  /**\\n   * @dev Replaces targer forwarder contract is pointing to\\n   * Only authenticated user can replace target\\n\\n   * @param _target New target to proxy into\\n  */\\n  function setTarget(address _target) public auth {\\n    target = _target;\\n  }\\n\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n\\n}\"},\"oraclizeAPI.sol\":{\"content\":\"// \\u003cORACLIZE_API\\u003e\\r\\n/*\\r\\nCopyright (c) 2015-2016 Oraclize SRL\\r\\nCopyright (c) 2016 Oraclize LTD\\r\\n\\r\\n\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\r\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\nin the Software without restriction, including without limitation the rights\\r\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\ncopies of the Software, and to permit persons to whom the Software is\\r\\nfurnished to do so, subject to the following conditions:\\r\\n\\r\\n\\r\\n\\r\\nThe above copyright notice and this permission notice shall be included in\\r\\nall copies or substantial portions of the Software.\\r\\n\\r\\n\\r\\n\\r\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\\r\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\r\\nTHE SOFTWARE.\\r\\n*/\\r\\n\\r\\n// This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\\r\\n\\r\\npragma solidity \\u003e=0.4.18;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\\r\\n\\r\\ncontract OraclizeI {\\r\\n    address public cbAddress;\\r\\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\\r\\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\\r\\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\\r\\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\\r\\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\\r\\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\\r\\n    function getPrice(string _datasource) public returns (uint _dsprice);\\r\\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\\r\\n    function setProofType(byte _proofType) external;\\r\\n    function setCustomGasPrice(uint _gasPrice) external;\\r\\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\\r\\n}\\r\\n\\r\\ncontract OraclizeAddrResolverI {\\r\\n    function getAddress() public returns (address _addr);\\r\\n}\\r\\n\\r\\n/*\\r\\nBegin solidity-cborutils\\r\\n\\r\\nhttps://github.com/smartcontractkit/solidity-cborutils\\r\\n\\r\\nMIT License\\r\\n\\r\\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\r\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\nin the Software without restriction, including without limitation the rights\\r\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\ncopies of the Software, and to permit persons to whom the Software is\\r\\nfurnished to do so, subject to the following conditions:\\r\\n\\r\\nThe above copyright notice and this permission notice shall be included in all\\r\\ncopies or substantial portions of the Software.\\r\\n\\r\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\nSOFTWARE.\\r\\n */\\r\\n\\r\\nlibrary Buffer {\\r\\n    struct buffer {\\r\\n        bytes buf;\\r\\n        uint capacity;\\r\\n    }\\r\\n\\r\\n    function init(buffer memory buf, uint _capacity) internal pure {\\r\\n        uint capacity = _capacity;\\r\\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\\r\\n        // Allocate space for the buffer data\\r\\n        buf.capacity = capacity;\\r\\n        assembly {\\r\\n            let ptr := mload(0x40)\\r\\n            mstore(buf, ptr)\\r\\n            mstore(ptr, 0)\\r\\n            mstore(0x40, add(ptr, capacity))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function resize(buffer memory buf, uint capacity) private pure {\\r\\n        bytes memory oldbuf = buf.buf;\\r\\n        init(buf, capacity);\\r\\n        append(buf, oldbuf);\\r\\n    }\\r\\n\\r\\n    function max(uint a, uint b) private pure returns(uint) {\\r\\n        if(a \\u003e b) {\\r\\n            return a;\\r\\n        }\\r\\n        return b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Appends a byte array to the end of the buffer. Resizes if doing so\\r\\n     *      would exceed the capacity of the buffer.\\r\\n     * @param buf The buffer to append to.\\r\\n     * @param data The data to append.\\r\\n     * @return The original buffer.\\r\\n     */\\r\\n    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\\r\\n        if(data.length + buf.buf.length \\u003e buf.capacity) {\\r\\n            resize(buf, max(buf.capacity, data.length) * 2);\\r\\n        }\\r\\n\\r\\n        uint dest;\\r\\n        uint src;\\r\\n        uint len = data.length;\\r\\n        assembly {\\r\\n            // Memory address of the buffer data\\r\\n            let bufptr := mload(buf)\\r\\n            // Length of existing buffer data\\r\\n            let buflen := mload(bufptr)\\r\\n            // Start address = buffer address + buffer length + sizeof(buffer length)\\r\\n            dest := add(add(bufptr, buflen), 32)\\r\\n            // Update buffer length\\r\\n            mstore(bufptr, add(buflen, mload(data)))\\r\\n            src := add(data, 32)\\r\\n        }\\r\\n\\r\\n        // Copy word-length chunks while possible\\r\\n        for(; len \\u003e= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        uint mask = 256 ** (32 - len) - 1;\\r\\n        assembly {\\r\\n            let srcpart := and(mload(src), not(mask))\\r\\n            let destpart := and(mload(dest), mask)\\r\\n            mstore(dest, or(destpart, srcpart))\\r\\n        }\\r\\n\\r\\n        return buf;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\r\\n     * exceed the capacity of the buffer.\\r\\n     * @param buf The buffer to append to.\\r\\n     * @param data The data to append.\\r\\n     * @return The original buffer.\\r\\n     */\\r\\n    function append(buffer memory buf, uint8 data) internal pure {\\r\\n        if(buf.buf.length + 1 \\u003e buf.capacity) {\\r\\n            resize(buf, buf.capacity * 2);\\r\\n        }\\r\\n\\r\\n        assembly {\\r\\n            // Memory address of the buffer data\\r\\n            let bufptr := mload(buf)\\r\\n            // Length of existing buffer data\\r\\n            let buflen := mload(bufptr)\\r\\n            // Address = buffer address + buffer length + sizeof(buffer length)\\r\\n            let dest := add(add(bufptr, buflen), 32)\\r\\n            mstore8(dest, data)\\r\\n            // Update buffer length\\r\\n            mstore(bufptr, add(buflen, 1))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\r\\n     * exceed the capacity of the buffer.\\r\\n     * @param buf The buffer to append to.\\r\\n     * @param data The data to append.\\r\\n     * @return The original buffer.\\r\\n     */\\r\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\r\\n        if(len + buf.buf.length \\u003e buf.capacity) {\\r\\n            resize(buf, max(buf.capacity, len) * 2);\\r\\n        }\\r\\n\\r\\n        uint mask = 256 ** len - 1;\\r\\n        assembly {\\r\\n            // Memory address of the buffer data\\r\\n            let bufptr := mload(buf)\\r\\n            // Length of existing buffer data\\r\\n            let buflen := mload(bufptr)\\r\\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\\r\\n            let dest := add(add(bufptr, buflen), len)\\r\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\r\\n            // Update buffer length\\r\\n            mstore(bufptr, add(buflen, len))\\r\\n        }\\r\\n        return buf;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary CBOR {\\r\\n    using Buffer for Buffer.buffer;\\r\\n\\r\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\r\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\r\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\r\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\r\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\r\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\r\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\r\\n\\r\\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\\r\\n        if(value \\u003c= 23) {\\r\\n            buf.append(uint8((major \\u003c\\u003c 5) | value));\\r\\n        } else if(value \\u003c= 0xFF) {\\r\\n            buf.append(uint8((major \\u003c\\u003c 5) | 24));\\r\\n            buf.appendInt(value, 1);\\r\\n        } else if(value \\u003c= 0xFFFF) {\\r\\n            buf.append(uint8((major \\u003c\\u003c 5) | 25));\\r\\n            buf.appendInt(value, 2);\\r\\n        } else if(value \\u003c= 0xFFFFFFFF) {\\r\\n            buf.append(uint8((major \\u003c\\u003c 5) | 26));\\r\\n            buf.appendInt(value, 4);\\r\\n        } else if(value \\u003c= 0xFFFFFFFFFFFFFFFF) {\\r\\n            buf.append(uint8((major \\u003c\\u003c 5) | 27));\\r\\n            buf.appendInt(value, 8);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\\r\\n        buf.append(uint8((major \\u003c\\u003c 5) | 31));\\r\\n    }\\r\\n\\r\\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\\r\\n        encodeType(buf, MAJOR_TYPE_INT, value);\\r\\n    }\\r\\n\\r\\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\\r\\n        if(value \\u003e= 0) {\\r\\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\\r\\n        } else {\\r\\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\\r\\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\\r\\n        buf.append(value);\\r\\n    }\\r\\n\\r\\n    function encodeString(Buffer.buffer memory buf, string value) internal pure {\\r\\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\\r\\n        buf.append(bytes(value));\\r\\n    }\\r\\n\\r\\n    function startArray(Buffer.buffer memory buf) internal pure {\\r\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\r\\n    }\\r\\n\\r\\n    function startMap(Buffer.buffer memory buf) internal pure {\\r\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\r\\n    }\\r\\n\\r\\n    function endSequence(Buffer.buffer memory buf) internal pure {\\r\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\r\\n    }\\r\\n}\\r\\n\\r\\n/*\\r\\nEnd solidity-cborutils\\r\\n */\\r\\n\\r\\ncontract usingOraclize {\\r\\n    uint constant day = 60*60*24;\\r\\n    uint constant week = 60*60*24*7;\\r\\n    uint constant month = 60*60*24*30;\\r\\n    byte constant proofType_NONE = 0x00;\\r\\n    byte constant proofType_TLSNotary = 0x10;\\r\\n    byte constant proofType_Ledger = 0x30;\\r\\n    byte constant proofType_Android = 0x40;\\r\\n    byte constant proofType_Native = 0xF0;\\r\\n    byte constant proofStorage_IPFS = 0x01;\\r\\n    uint8 constant networkID_auto = 0;\\r\\n    uint8 constant networkID_mainnet = 1;\\r\\n    uint8 constant networkID_testnet = 2;\\r\\n    uint8 constant networkID_morden = 2;\\r\\n    uint8 constant networkID_consensys = 161;\\r\\n\\r\\n    OraclizeAddrResolverI OAR;\\r\\n\\r\\n    OraclizeI oraclize;\\r\\n    modifier oraclizeAPI {\\r\\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\\r\\n            oraclize_setNetwork(networkID_auto);\\r\\n\\r\\n        if(address(oraclize) != OAR.getAddress())\\r\\n            oraclize = OraclizeI(OAR.getAddress());\\r\\n\\r\\n        _;\\r\\n    }\\r\\n    modifier coupon(string code){\\r\\n        oraclize = OraclizeI(OAR.getAddress());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\\r\\n      return oraclize_setNetwork();\\r\\n      networkID; // silence the warning and remain backwards compatible\\r\\n    }\\r\\n    function oraclize_setNetwork() internal returns(bool){\\r\\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)\\u003e0){ //mainnet\\r\\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\\r\\n            oraclize_setNetworkName(\\\"eth_mainnet\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)\\u003e0){ //ropsten testnet\\r\\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\\r\\n            oraclize_setNetworkName(\\\"eth_ropsten3\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)\\u003e0){ //kovan testnet\\r\\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\\r\\n            oraclize_setNetworkName(\\\"eth_kovan\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)\\u003e0){ //rinkeby testnet\\r\\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\\r\\n            oraclize_setNetworkName(\\\"eth_rinkeby\\\");\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)\\u003e0){ //ethereum-bridge\\r\\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)\\u003e0){ //ether.camp ide\\r\\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\\r\\n            return true;\\r\\n        }\\r\\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)\\u003e0){ //browser-solidity\\r\\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function __callback(bytes32 myid, string result) public {\\r\\n        __callback(myid, result, new bytes(0));\\r\\n    }\\r\\n    function __callback(bytes32 myid, string result, bytes proof) public {\\r\\n      return;\\r\\n      myid; result; proof; // Silence compiler warnings\\r\\n    }\\r\\n\\r\\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\\r\\n        return oraclize.getPrice(datasource);\\r\\n    }\\r\\n\\r\\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\\r\\n        return oraclize.getPrice(datasource, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query.value(price)(0, datasource, arg);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query.value(price)(timestamp, datasource, arg);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(0, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = stra2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        string[] memory dynargs = new string[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(0, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\\r\\n        uint price = oraclize.getPrice(datasource, gaslimit);\\r\\n        if (price \\u003e 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\\r\\n        bytes memory args = ba2cbor(argN);\\r\\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](1);\\r\\n        dynargs[0] = args[0];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](2);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](3);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](4);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs);\\r\\n    }\\r\\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\\r\\n    }\\r\\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\\r\\n        bytes[] memory dynargs = new bytes[](5);\\r\\n        dynargs[0] = args[0];\\r\\n        dynargs[1] = args[1];\\r\\n        dynargs[2] = args[2];\\r\\n        dynargs[3] = args[3];\\r\\n        dynargs[4] = args[4];\\r\\n        return oraclize_query(datasource, dynargs, gaslimit);\\r\\n    }\\r\\n\\r\\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\\r\\n        return oraclize.cbAddress();\\r\\n    }\\r\\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\\r\\n        return oraclize.setProofType(proofP);\\r\\n    }\\r\\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\\r\\n        return oraclize.setCustomGasPrice(gasPrice);\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\\r\\n        return oraclize.randomDS_getSessionPubKeyHash();\\r\\n    }\\r\\n\\r\\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\\r\\n        assembly {\\r\\n            _size := extcodesize(_addr)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function parseAddr(string _a) internal pure returns (address){\\r\\n        bytes memory tmp = bytes(_a);\\r\\n        uint160 iaddr = 0;\\r\\n        uint160 b1;\\r\\n        uint160 b2;\\r\\n        for (uint i=2; i\\u003c2+2*20; i+=2){\\r\\n            iaddr *= 256;\\r\\n            b1 = uint160(tmp[i]);\\r\\n            b2 = uint160(tmp[i+1]);\\r\\n            if ((b1 \\u003e= 97)\\u0026\\u0026(b1 \\u003c= 102)) b1 -= 87;\\r\\n            else if ((b1 \\u003e= 65)\\u0026\\u0026(b1 \\u003c= 70)) b1 -= 55;\\r\\n            else if ((b1 \\u003e= 48)\\u0026\\u0026(b1 \\u003c= 57)) b1 -= 48;\\r\\n            if ((b2 \\u003e= 97)\\u0026\\u0026(b2 \\u003c= 102)) b2 -= 87;\\r\\n            else if ((b2 \\u003e= 65)\\u0026\\u0026(b2 \\u003c= 70)) b2 -= 55;\\r\\n            else if ((b2 \\u003e= 48)\\u0026\\u0026(b2 \\u003c= 57)) b2 -= 48;\\r\\n            iaddr += (b1*16+b2);\\r\\n        }\\r\\n        return address(iaddr);\\r\\n    }\\r\\n\\r\\n    function strCompare(string _a, string _b) internal pure returns (int) {\\r\\n        bytes memory a = bytes(_a);\\r\\n        bytes memory b = bytes(_b);\\r\\n        uint minLength = a.length;\\r\\n        if (b.length \\u003c minLength) minLength = b.length;\\r\\n        for (uint i = 0; i \\u003c minLength; i ++)\\r\\n            if (a[i] \\u003c b[i])\\r\\n                return -1;\\r\\n            else if (a[i] \\u003e b[i])\\r\\n                return 1;\\r\\n        if (a.length \\u003c b.length)\\r\\n            return -1;\\r\\n        else if (a.length \\u003e b.length)\\r\\n            return 1;\\r\\n        else\\r\\n            return 0;\\r\\n    }\\r\\n\\r\\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\\r\\n        bytes memory h = bytes(_haystack);\\r\\n        bytes memory n = bytes(_needle);\\r\\n        if(h.length \\u003c 1 || n.length \\u003c 1 || (n.length \\u003e h.length))\\r\\n            return -1;\\r\\n        else if(h.length \\u003e (2**128 -1))\\r\\n            return -1;\\r\\n        else\\r\\n        {\\r\\n            uint subindex = 0;\\r\\n            for (uint i = 0; i \\u003c h.length; i ++)\\r\\n            {\\r\\n                if (h[i] == n[0])\\r\\n                {\\r\\n                    subindex = 1;\\r\\n                    while(subindex \\u003c n.length \\u0026\\u0026 (i + subindex) \\u003c h.length \\u0026\\u0026 h[i + subindex] == n[subindex])\\r\\n                    {\\r\\n                        subindex++;\\r\\n                    }\\r\\n                    if(subindex == n.length)\\r\\n                        return int(i);\\r\\n                }\\r\\n            }\\r\\n            return -1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\\r\\n        bytes memory _ba = bytes(_a);\\r\\n        bytes memory _bb = bytes(_b);\\r\\n        bytes memory _bc = bytes(_c);\\r\\n        bytes memory _bd = bytes(_d);\\r\\n        bytes memory _be = bytes(_e);\\r\\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\\r\\n        bytes memory babcde = bytes(abcde);\\r\\n        uint k = 0;\\r\\n        for (uint i = 0; i \\u003c _ba.length; i++) babcde[k++] = _ba[i];\\r\\n        for (i = 0; i \\u003c _bb.length; i++) babcde[k++] = _bb[i];\\r\\n        for (i = 0; i \\u003c _bc.length; i++) babcde[k++] = _bc[i];\\r\\n        for (i = 0; i \\u003c _bd.length; i++) babcde[k++] = _bd[i];\\r\\n        for (i = 0; i \\u003c _be.length; i++) babcde[k++] = _be[i];\\r\\n        return string(babcde);\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string _a, string _b) internal pure returns (string) {\\r\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    // parseInt\\r\\n    function parseInt(string _a) internal pure returns (uint) {\\r\\n        return parseInt(_a, 0);\\r\\n    }\\r\\n\\r\\n    // parseInt(parseFloat*10^_b)\\r\\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\\r\\n        bytes memory bresult = bytes(_a);\\r\\n        uint mint = 0;\\r\\n        bool decimals = false;\\r\\n        for (uint i=0; i\\u003cbresult.length; i++){\\r\\n            if ((bresult[i] \\u003e= 48)\\u0026\\u0026(bresult[i] \\u003c= 57)){\\r\\n                if (decimals){\\r\\n                   if (_b == 0) break;\\r\\n                    else _b--;\\r\\n                }\\r\\n                mint *= 10;\\r\\n                mint += uint(bresult[i]) - 48;\\r\\n            } else if (bresult[i] == 46) decimals = true;\\r\\n        }\\r\\n        if (_b \\u003e 0) mint *= 10**_b;\\r\\n        return mint;\\r\\n    }\\r\\n\\r\\n    function uint2str(uint i) internal pure returns (string){\\r\\n        if (i == 0) return \\\"0\\\";\\r\\n        uint j = i;\\r\\n        uint len;\\r\\n        while (j != 0){\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len - 1;\\r\\n        while (i != 0){\\r\\n            bstr[k--] = byte(48 + i % 10);\\r\\n            i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n\\r\\n    using CBOR for Buffer.buffer;\\r\\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\\r\\n        safeMemoryCleaner();\\r\\n        Buffer.buffer memory buf;\\r\\n        Buffer.init(buf, 1024);\\r\\n        buf.startArray();\\r\\n        for (uint i = 0; i \\u003c arr.length; i++) {\\r\\n            buf.encodeString(arr[i]);\\r\\n        }\\r\\n        buf.endSequence();\\r\\n        return buf.buf;\\r\\n    }\\r\\n\\r\\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\\r\\n        safeMemoryCleaner();\\r\\n        Buffer.buffer memory buf;\\r\\n        Buffer.init(buf, 1024);\\r\\n        buf.startArray();\\r\\n        for (uint i = 0; i \\u003c arr.length; i++) {\\r\\n            buf.encodeBytes(arr[i]);\\r\\n        }\\r\\n        buf.endSequence();\\r\\n        return buf.buf;\\r\\n    }\\r\\n\\r\\n    string oraclize_network_name;\\r\\n    function oraclize_setNetworkName(string _network_name) internal {\\r\\n        oraclize_network_name = _network_name;\\r\\n    }\\r\\n\\r\\n    function oraclize_getNetworkName() internal view returns (string) {\\r\\n        return oraclize_network_name;\\r\\n    }\\r\\n\\r\\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\\r\\n        require((_nbytes \\u003e 0) \\u0026\\u0026 (_nbytes \\u003c= 32));\\r\\n        // Convert from seconds to ledger timer ticks\\r\\n        _delay *= 10;\\r\\n        bytes memory nbytes = new bytes(1);\\r\\n        nbytes[0] = byte(_nbytes);\\r\\n        bytes memory unonce = new bytes(32);\\r\\n        bytes memory sessionKeyHash = new bytes(32);\\r\\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\\r\\n        assembly {\\r\\n            mstore(unonce, 0x20)\\r\\n            // the following variables can be relaxed\\r\\n            // check relaxed random contract under ethereum-examples repo\\r\\n            // for an idea on how to override and replace comit hash vars\\r\\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\\r\\n            mstore(sessionKeyHash, 0x20)\\r\\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\\r\\n        }\\r\\n        bytes memory delay = new bytes(32);\\r\\n        assembly {\\r\\n            mstore(add(delay, 0x20), _delay)\\r\\n        }\\r\\n\\r\\n        bytes memory delay_bytes8 = new bytes(8);\\r\\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\\r\\n\\r\\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\\r\\n        bytes32 queryId = oraclize_query(\\\"random\\\", args, _customGasLimit);\\r\\n\\r\\n        bytes memory delay_bytes8_left = new bytes(8);\\r\\n\\r\\n        assembly {\\r\\n            let x := mload(add(delay_bytes8, 0x20))\\r\\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\\r\\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\\r\\n\\r\\n        }\\r\\n\\r\\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\\r\\n        return queryId;\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\\r\\n        oraclize_randomDS_args[queryId] = commitment;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32=\\u003ebytes32) oraclize_randomDS_args;\\r\\n    mapping(bytes32=\\u003ebool) oraclize_randomDS_sessionKeysHashVerified;\\r\\n\\r\\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\\r\\n        bool sigok;\\r\\n        address signer;\\r\\n\\r\\n        bytes32 sigr;\\r\\n        bytes32 sigs;\\r\\n\\r\\n        bytes memory sigr_ = new bytes(32);\\r\\n        uint offset = 4+(uint(dersig[3]) - 0x20);\\r\\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\\r\\n        bytes memory sigs_ = new bytes(32);\\r\\n        offset += 32 + 2;\\r\\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\\r\\n\\r\\n        assembly {\\r\\n            sigr := mload(add(sigr_, 32))\\r\\n            sigs := mload(add(sigs_, 32))\\r\\n        }\\r\\n\\r\\n\\r\\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\\r\\n        if (address(keccak256(pubkey)) == signer) return true;\\r\\n        else {\\r\\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\\r\\n            return (address(keccak256(pubkey)) == signer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\\r\\n        bool sigok;\\r\\n\\r\\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\\r\\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\\r\\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\\r\\n\\r\\n        bytes memory appkey1_pubkey = new bytes(64);\\r\\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\\r\\n\\r\\n        bytes memory tosign2 = new bytes(1+65+32);\\r\\n        tosign2[0] = byte(1); //role\\r\\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\\r\\n        bytes memory CODEHASH = hex\\\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\\\";\\r\\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\\r\\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\\r\\n\\r\\n        if (sigok == false) return false;\\r\\n\\r\\n\\r\\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\\r\\n        bytes memory LEDGERKEY = hex\\\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\\\";\\r\\n\\r\\n        bytes memory tosign3 = new bytes(1+65);\\r\\n        tosign3[0] = 0xFE;\\r\\n        copyBytes(proof, 3, 65, tosign3, 1);\\r\\n\\r\\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\\r\\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\\r\\n\\r\\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\\r\\n\\r\\n        return sigok;\\r\\n    }\\r\\n\\r\\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\\r\\n        // Step 1: the prefix has to match \\u0027LP\\\\x01\\u0027 (Ledger Proof version 1)\\r\\n        require((_proof[0] == \\\"L\\\") \\u0026\\u0026 (_proof[1] == \\\"P\\\") \\u0026\\u0026 (_proof[2] == 1));\\r\\n\\r\\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\\r\\n        require(proofVerified);\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\\r\\n        // Step 1: the prefix has to match \\u0027LP\\\\x01\\u0027 (Ledger Proof version 1)\\r\\n        if ((_proof[0] != \\\"L\\\")||(_proof[1] != \\\"P\\\")||(_proof[2] != 1)) return 1;\\r\\n\\r\\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\\r\\n        if (proofVerified == false) return 2;\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\\r\\n        bool match_ = true;\\r\\n\\r\\n        require(prefix.length == n_random_bytes);\\r\\n\\r\\n        for (uint256 i=0; i\\u003c n_random_bytes; i++) {\\r\\n            if (content[i] != prefix[i]) match_ = false;\\r\\n        }\\r\\n\\r\\n        return match_;\\r\\n    }\\r\\n\\r\\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\\r\\n\\r\\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\\r\\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\\r\\n        bytes memory keyhash = new bytes(32);\\r\\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\\r\\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\\r\\n\\r\\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\\r\\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\\r\\n\\r\\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if \\u0027result\\u0027 is the prefix of sha256(sig1)\\r\\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\\r\\n\\r\\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\\r\\n        // This is to verify that the computed args match with the ones specified in the query.\\r\\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\\r\\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\\r\\n\\r\\n        bytes memory sessionPubkey = new bytes(64);\\r\\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\\r\\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\\r\\n\\r\\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\\r\\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\\r\\n            delete oraclize_randomDS_args[queryId];\\r\\n        } else return false;\\r\\n\\r\\n\\r\\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\\r\\n        bytes memory tosign1 = new bytes(32+8+1+32);\\r\\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\\r\\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\\r\\n\\r\\n        // verify if sessionPubkeyHash was verified already, if not.. let\\u0027s do it!\\r\\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\\r\\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\\r\\n        }\\r\\n\\r\\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\\r\\n    }\\r\\n\\r\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\r\\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\\r\\n        uint minLength = length + toOffset;\\r\\n\\r\\n        // Buffer too small\\r\\n        require(to.length \\u003e= minLength); // Should be a better way?\\r\\n\\r\\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\\r\\n        uint i = 32 + fromOffset;\\r\\n        uint j = 32 + toOffset;\\r\\n\\r\\n        while (i \\u003c (32 + fromOffset + length)) {\\r\\n            assembly {\\r\\n                let tmp := mload(add(from, i))\\r\\n                mstore(add(to, j), tmp)\\r\\n            }\\r\\n            i += 32;\\r\\n            j += 32;\\r\\n        }\\r\\n\\r\\n        return to;\\r\\n    }\\r\\n\\r\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\r\\n    // Duplicate Solidity\\u0027s ecrecover, but catching the CALL return value\\r\\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\\r\\n        // We do our own memory management here. Solidity uses memory offset\\r\\n        // 0x40 to store the current end of memory. We write past it (as\\r\\n        // writes are memory extensions), but don\\u0027t update the offset so\\r\\n        // Solidity will reuse it. The memory used here is only needed for\\r\\n        // this context.\\r\\n\\r\\n        // FIXME: inline assembly can\\u0027t access return values\\r\\n        bool ret;\\r\\n        address addr;\\r\\n\\r\\n        assembly {\\r\\n            let size := mload(0x40)\\r\\n            mstore(size, hash)\\r\\n            mstore(add(size, 32), v)\\r\\n            mstore(add(size, 64), r)\\r\\n            mstore(add(size, 96), s)\\r\\n\\r\\n            // NOTE: we can reuse the request memory because we deal with\\r\\n            //       the return code\\r\\n            ret := call(3000, 1, 0, size, 128, size, 32)\\r\\n            addr := mload(size)\\r\\n        }\\r\\n\\r\\n        return (ret, addr);\\r\\n    }\\r\\n\\r\\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\\r\\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        if (sig.length != 65)\\r\\n          return (false, 0);\\r\\n\\r\\n        // The signature format is a compact form of:\\r\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\r\\n        // Compact means, uint8 is not padded to 32 bytes.\\r\\n        assembly {\\r\\n            r := mload(add(sig, 32))\\r\\n            s := mload(add(sig, 64))\\r\\n\\r\\n            // Here we are loading the last 32 bytes. We exploit the fact that\\r\\n            // \\u0027mload\\u0027 will pad with zeroes if we overread.\\r\\n            // There is no \\u0027mload8\\u0027 to do this, but that would be nicer.\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n\\r\\n            // Alternative solution:\\r\\n            // \\u0027byte\\u0027 is not working due to the Solidity parser, so lets\\r\\n            // use the second best option, \\u0027and\\u0027\\r\\n            // v := and(mload(add(sig, 65)), 255)\\r\\n        }\\r\\n\\r\\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\\r\\n        // to match the YP range of [27, 28]\\r\\n        //\\r\\n        // geth uses [0, 1] and some clients have followed. This might change, see:\\r\\n        //  https://github.com/ethereum/go-ethereum/issues/2053\\r\\n        if (v \\u003c 27)\\r\\n          v += 27;\\r\\n\\r\\n        if (v != 27 \\u0026\\u0026 v != 28)\\r\\n            return (false, 0);\\r\\n\\r\\n        return safer_ecrecover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    function safeMemoryCleaner() internal pure {\\r\\n        assembly {\\r\\n            let fmem := mload(0x40)\\r\\n            codecopy(fmem, codesize, sub(msize, fmem))\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\\r\\n// \\u003c/ORACLIZE_API\\u003e\\r\\n\"},\"ParamChange.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntry.sol\\\";\\nimport \\\"./EternalDb.sol\\\";\\n\\n/**\\n * @title Contract created for each submitted TCR parameter change.\\n *\\n * @dev It extends base RegistryEntry with additional state for storing information related to the change.\\n * It also contains logic for applying accepted changes.\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single intance of it.\\n */\\n\\ncontract ParamChange is RegistryEntry {\\n\\n  EternalDb public db;\\n  string private key;\\n  EternalDb.Types private valueType;\\n  uint private value;\\n  uint private originalValue;\\n  uint private appliedOn;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n   * Can only be called if the parameter value is within its allowed domain.\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   * @param _db EternalDb change will be applied to\\n   * @param _key Key of a changed parameter\\n   * @param _value New value of a parameter\\n   */\\n  function construct(\\n    address _creator,\\n    uint _version,\\n    address _db,\\n    string _key,\\n    uint _value\\n  )\\n  external\\n  {\\n    bytes32 record = sha3(_key);\\n    require(RegistryEntryLib.isChangeAllowed(registry, record, _value));\\n\\n    super.construct(_creator, _version);\\n\\n    db = EternalDb(_db);\\n    key = _key;\\n    value = _value;\\n    valueType = EternalDb.Types.UInt;\\n    originalValue = db.getUIntValue(record);\\n\\n    registry.fireParamChangeConstructedEvent(version,\\n                                             _creator,\\n                                             db,\\n                                             _key,\\n                                             value,\\n                                             deposit,\\n                                             challenge.challengePeriodEnd);\\n  }\\n\\n  /**\\n   * @dev Applies the parameter change into EternalDb\\n   * To be able to make change into a EternalDb, this contract must be given temporary permission to make the change\\n   * This permission is given by ParamChangeRegistry, which holds permanent permission to make changes into the db\\n   * Cannot be called when change was already applied\\n   * Can be called only for whitelisted registry entries\\n   * Can be called only when original value is still current value\\n   * Creator gets deposit back\\n   */\\n  function applyChange()\\n  external\\n  notEmergency\\n  {\\n    require(db.getUIntValue(sha3(key)) == originalValue);\\n    require(appliedOn \\u003c 0);\\n    require(challenge.isWhitelisted());\\n    require(registryToken.transfer(creator, deposit));\\n\\n    db.setUIntValue(sha3(key), value);\\n    appliedOn = now;\\n\\n    registry.fireParamChangeAppliedEvent(version);\\n  }\\n\\n}\\n\"},\"ParamChangeFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntryFactory.sol\\\";\\nimport \\\"./ParamChange.sol\\\";\\n\\n/**\\n * @title Factory contract for creating ParamChange contracts\\n *\\n * @dev Users submit new TCR parameter changes into this contract.\\n */\\n\\ncontract ParamChangeFactory is RegistryEntryFactory {\\n  uint public constant version = 1;\\n\\n  function ParamChangeFactory(Registry _registry, MiniMeToken _registryToken)\\n  RegistryEntryFactory(_registry, _registryToken)\\n  {}\\n\\n  /**\\n   * @dev Creates new ParamChange forwarder contract and add it into the registry\\n   * It initializes forwarder contract with initial state. For comments on each param, see ParamChange::construct\\n   */\\n  function createParamChange(\\n    address _creator,\\n    address _db,\\n    string _key,\\n    uint _value\\n  )\\n  public\\n  {\\n    ParamChange paramChange = ParamChange(createRegistryEntry(_creator));\\n\\n    paramChange.construct(\\n      _creator,\\n      version,\\n      _db,\\n      _key,\\n      _value\\n    );\\n  }\\n}\\n\"},\"ParamChangeRegistry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./ParamChange.sol\\\";\\nimport \\\"./DSGuard.sol\\\";\\n\\n/**\\n * @title Central contract for TCR parameter change registry\\n *\\n * @dev Extends Registry contract with additional logic for applying parameter change into a registry EternalDb.\\n */\\n\\ncontract ParamChangeRegistry is Registry {\\n\\n  /**\\n   * @dev Gives ParamChange contract temporary permission to apply its parameter changes into EthernalDb\\n   * Only address of valid ParamChange contract can be passed\\n   * Permission must be taken back right after applying the change\\n\\n   * @param _paramChange Address of ParamChange contract\\n   */\\n\\n  function applyParamChange(ParamChange _paramChange) {\\n    require(isRegistryEntry(_paramChange), \\\"ParamChangeRegistry: not a registry entry\\\");\\n    DSGuard guard = DSGuard(_paramChange.db().authority());\\n    guard.permit(_paramChange, _paramChange.db(), guard.ANY());\\n    _paramChange.applyChange();\\n    guard.forbid(_paramChange, _paramChange.db(), guard.ANY());\\n  }\\n}\\n\\n\"},\"Registry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./DSAuth.sol\\\";\\nimport \\\"./EternalDb.sol\\\";\\nimport \\\"./MutableForwarder.sol\\\"; // Keep it included despite not being used (for compiler)\\n\\n/**\\n * @title Central contract for TCR registry\\n *\\n * @dev Manages state about deployed registry entries and factories\\n * Serves as a central point for firing all registry entry events\\n * This contract is not accessed directly, but through MutableForwarder. See MutableForwarder.sol for more comments.\\n */\\n\\ncontract Registry is DSAuth {\\n  address private dummyTarget; // Keep it here, because this contract is deployed as MutableForwarder\\n\\n  bytes32 public constant challengePeriodDurationKey = sha3(\\\"challengePeriodDuration\\\");\\n  bytes32 public constant commitPeriodDurationKey = sha3(\\\"commitPeriodDuration\\\");\\n  bytes32 public constant revealPeriodDurationKey = sha3(\\\"revealPeriodDuration\\\");\\n  bytes32 public constant depositKey = sha3(\\\"deposit\\\");\\n  bytes32 public constant challengeDispensationKey = sha3(\\\"challengeDispensation\\\");\\n  bytes32 public constant voteQuorumKey = sha3(\\\"voteQuorum\\\");\\n  bytes32 public constant maxTotalSupplyKey = sha3(\\\"maxTotalSupply\\\");\\n  bytes32 public constant maxAuctionDurationKey = sha3(\\\"maxAuctionDuration\\\");\\n\\n  event MemeConstructedEvent(address registryEntry, uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd);\\n  event MemeMintedEvent(address registryEntry, uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted);\\n\\n  event ChallengeCreatedEvent(address registryEntry, uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash);\\n  event VoteCommittedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event VoteRevealedEvent(address registryEntry, uint version, address voter, uint option);\\n  event VoteAmountClaimedEvent(address registryEntry, uint version, address voter);\\n  event VoteRewardClaimedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event ChallengeRewardClaimedEvent(address registryEntry, uint version, address challenger, uint amount);\\n\\n  event ParamChangeConstructedEvent(address registryEntry, uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd);\\n  event ParamChangeAppliedEvent(address registryEntry, uint version);\\n\\n  EternalDb public db;\\n  bool private wasConstructed;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because we use a forwarder pointing to single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n\\n   * @param _db Address of EternalDb related to this registry\\n   */\\n  function construct(EternalDb _db)\\n  external\\n  {\\n    require(address(_db) != 0x0, \\\"Registry: Address can\\u0027t be 0x0\\\");\\n\\n    db = _db;\\n    wasConstructed = true;\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyFactory() {\\n    require(isFactory(msg.sender), \\\"Registry: Sender should be factory\\\");\\n    _;\\n  }\\n\\n  modifier onlyRegistryEntry() {\\n    require(isRegistryEntry(msg.sender), \\\"Registry: Sender should registry entry\\\");\\n    _;\\n  }\\n\\n  modifier notEmergency() {\\n    require(!isEmergency(),\\\"Registry: Emergency mode is enable\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Sets whether address is factory allowed to add registry entries into registry\\n   * Must be callable only by authenticated user\\n\\n   * @param _factory Address of a factory contract\\n   * @param _isFactory Whether the address is allowed factory\\n   */\\n  function setFactory(address _factory, bool _isFactory)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(sha3(\\\"isFactory\\\", _factory), _isFactory);\\n  }\\n\\n  /**\\n   * @dev Adds address as valid registry entry into the Registry\\n   * Must be callable only by allowed factory contract\\n\\n   * @param _registryEntry Address of new registry entry\\n   */\\n  function addRegistryEntry(address _registryEntry)\\n  external\\n  onlyFactory\\n  notEmergency\\n  {\\n    db.setBooleanValue(sha3(\\\"isRegistryEntry\\\", _registryEntry), true);\\n  }\\n\\n  /**\\n   * @dev Sets emergency state to pause all trading operations\\n   * Must be callable only by authenticated user\\n\\n   * @param _isEmergency True if emergency is happening\\n   */\\n  function setEmergency(bool _isEmergency)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(\\\"isEmergency\\\", _isEmergency);\\n  }\\n\\n  function fireMemeConstructedEvent(uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeConstructedEvent(msg.sender, version, creator, metaHash, totalSupply, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireMemeMintedEvent(uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeMintedEvent(msg.sender, version, creator, tokenStartId, tokenEndId, totalMinted);\\n  }\\n\\n  function fireChallengeCreatedEvent(uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeCreatedEvent(msg.sender, version,  challenger, commitPeriodEnd, revealPeriodEnd, rewardPool, metahash);\\n  }\\n\\n  function fireVoteCommittedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteCommittedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireVoteRevealedEvent(uint version, address voter, uint option)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRevealedEvent(msg.sender, version, voter, option);\\n  }\\n\\n  function fireVoteAmountClaimedEvent(uint version, address voter)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteAmountClaimedEvent(msg.sender, version, voter);\\n  }\\n\\n  function fireVoteRewardClaimedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRewardClaimedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireChallengeRewardClaimedEvent(uint version, address challenger, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeRewardClaimedEvent(msg.sender, version, challenger, amount);\\n  }\\n\\n  function fireParamChangeConstructedEvent(uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeConstructedEvent(msg.sender, version, creator, db, key, value, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireParamChangeAppliedEvent(uint version)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeAppliedEvent(msg.sender, version);\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry factory\\n\\n   * @return True if address is factory\\n   */\\n  function isFactory(address factory) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isFactory\\\", factory));\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry\\n\\n   * @return True if address is registry entry\\n   */\\n  function isRegistryEntry(address registryEntry) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isRegistryEntry\\\", registryEntry));\\n  }\\n\\n  /**\\n   * @dev Returns whether emergency stop is happening\\n\\n   * @return True if emergency is happening\\n   */\\n  function isEmergency() public constant returns (bool) {\\n    return db.getBooleanValue(\\\"isEmergency\\\");\\n  }\\n}\\n\"},\"RegistryEntry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./MiniMeToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./RegistryEntryLib.sol\\\";\\n\\n/**\\n * @title Contract created with each submission to a TCR\\n *\\n * @dev It contains all state and logic related to TCR challenging and voting\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single instance of it.\\n * This contract is meant to be extended by domain specific registry entry contracts (Meme, ParamChange)\\n */\\n\\ncontract RegistryEntry is ApproveAndCallFallBack {\\n  using SafeMath for uint;\\n  using RegistryEntryLib for RegistryEntryLib.Challenge;\\n\\n  Registry internal constant registry = Registry(0xe278b85a36f6b370347d69fb4744947e2965c058);\\n  MiniMeToken internal constant registryToken = MiniMeToken(0x0cb8d0b37c7487b11d57f1f33defa2b1d3cfccfe);\\n\\n  address internal creator;\\n  uint internal version;\\n  uint internal deposit;\\n  RegistryEntryLib.Challenge internal challenge;\\n\\n  /**\\n   * @dev Modifier that disables function if registry is in emergency state\\n   */\\n  modifier notEmergency() {\\n    require(!registry.isEmergency());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier that disables function if challenge is not whitelisted\\n   */\\n  modifier onlyWhitelisted() {\\n    require(challenge.isWhitelisted());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n   * Must NOT be callable multiple times\\n   * Transfers TCR entry token deposit from sender into this contract\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   */\\n  function construct(\\n                     address _creator,\\n                     uint _version\\n                     )\\n    public\\n  {\\n    require(challenge.challengePeriodEnd == 0);\\n    deposit = registry.db().getUIntValue(registry.depositKey());\\n    require(registryToken.transferFrom(msg.sender, this, deposit));\\n\\n    challenge.challengePeriodEnd = now.add(registry.db().getUIntValue(registry.challengePeriodDurationKey()));\\n\\n    creator = _creator;\\n    version = _version;\\n  }\\n\\n  /**\\n   * @dev Creates a challenge for this TCR entry\\n   * Must be within challenge period\\n   * Entry can be challenged only once\\n   * Transfers token deposit from challenger into this contract\\n   * Forks registry token (DankToken) in order to create single purpose voting token to vote about this challenge\\n\\n   * @param _challenger Address of a challenger\\n   * @param _challengeMetaHash IPFS hash of meta data related to this challenge\\n   */\\n  function createChallenge(\\n                           address _challenger,\\n                           bytes _challengeMetaHash\\n                           )\\n    external\\n    notEmergency\\n  {\\n    require(challenge.isChallengePeriodActive());\\n    require(!challenge.wasChallenged());\\n    require(registryToken.transferFrom(_challenger, this, deposit));\\n\\n    challenge.challenger = _challenger;\\n    challenge.voteQuorum = registry.db().getUIntValue(registry.voteQuorumKey());\\n    uint commitDuration = registry.db().getUIntValue(registry.commitPeriodDurationKey());\\n    uint revealDuration = registry.db().getUIntValue(registry.revealPeriodDurationKey());\\n\\n    challenge.commitPeriodEnd = now.add(commitDuration);\\n    challenge.revealPeriodEnd = challenge.commitPeriodEnd.add(revealDuration);\\n    challenge.rewardPool = uint(100).sub(registry.db().getUIntValue(registry.challengeDispensationKey())).mul(deposit).div(uint(100));\\n    challenge.metaHash = _challengeMetaHash;\\n\\n    registry.fireChallengeCreatedEvent(version,\\n                                       challenge.challenger,\\n                                       challenge.commitPeriodEnd,\\n                                       challenge.revealPeriodEnd,\\n                                       challenge.rewardPool,\\n                                       challenge.metaHash);\\n  }\\n\\n  /**\\n   * @dev Commits encrypted vote to challenged entry\\n   * Locks voter\\u0027s tokens in this contract. Returns when vote is revealed\\n   * Must be within commit period\\n   * Same address can\\u0027t make a second vote for the same challenge\\n\\n   * @param _voter Address of a voter\\n   * @param _amount Amount of tokens to vote with\\n   * @param _secretHash Encrypted vote option with salt. sha3(voteOption, salt)\\n   */\\n  function commitVote(\\n                      address _voter,\\n                      uint _amount,\\n                      bytes32 _secretHash\\n                      )\\n    external\\n    notEmergency\\n  {\\n    require(challenge.isVoteCommitPeriodActive());\\n    require(_amount \\u003e 0);\\n    require(!challenge.hasVoted(_voter));\\n    require(registryToken.transferFrom(_voter, this, _amount));\\n\\n    challenge.vote[_voter].secretHash = _secretHash;\\n    challenge.vote[_voter].amount += _amount;\\n\\n    registry.fireVoteCommittedEvent(version,\\n                                    _voter,\\n                                    challenge.vote[_voter].amount);\\n  }\\n\\n  /**\\n   * @dev Reveals previously committed vote\\n   * Returns registryToken back to the voter\\n   * Must be within reveal period\\n\\n   * @param _voteOption Vote option voter previously voted with\\n   * @param _salt Salt with which user previously encrypted his vote option\\n   */\\n  function revealVote(\\n                      RegistryEntryLib.VoteOption _voteOption,\\n                      string _salt\\n                      )\\n    external\\n    notEmergency\\n  {\\n    address _voter=msg.sender;\\n    require(challenge.isVoteRevealPeriodActive());\\n    require(keccak256(abi.encodePacked(uint(_voteOption), _salt)) == challenge.vote[_voter].secretHash);\\n    require(!challenge.isVoteRevealed(_voter));\\n\\n    challenge.vote[_voter].revealedOn = now;\\n    uint amount = challenge.vote[_voter].amount;\\n    require(registryToken.transfer(_voter, amount));\\n    challenge.vote[_voter].option = _voteOption;\\n\\n    if (_voteOption == RegistryEntryLib.VoteOption.VoteFor) {\\n      challenge.votesFor = challenge.votesFor.add(amount);\\n    } else if (_voteOption == RegistryEntryLib.VoteOption.VoteAgainst) {\\n      challenge.votesAgainst = challenge.votesAgainst.add(amount);\\n    } else {\\n      revert();\\n    }\\n\\n    registry.fireVoteRevealedEvent(version,\\n                                   _voter,\\n                                   uint(challenge.vote[_voter].option));\\n  }\\n\\n   /**\\n   * @dev Refunds vote deposit after reveal period\\n   * Can be called by anybody, to claim voter\\u0027s reward to him\\n   * Can\\u0027t be called if vote was revealed\\n   * Can\\u0027t be called twice for the same vote\\n   * @param _voter Address of a voter\\n   */\\n  function reclaimVoteAmount(address _voter)\\n    public\\n    notEmergency {\\n\\n    require(challenge.isVoteRevealPeriodOver());\\n    require(!challenge.isVoteRevealed(_voter));\\n    require(!challenge.isVoteAmountReclaimed(_voter));\\n\\n    uint amount = challenge.vote[_voter].amount;\\n    require(registryToken.transfer(_voter, amount));\\n\\n    challenge.vote[_voter].reclaimedVoteAmountOn = now;\\n\\n    registry.fireVoteAmountClaimedEvent(version, _voter);\\n  }\\n\\n\\n  /**\\n   * @dev Claims vote reward after reveal period\\n   * Voter has reward only if voted for winning option\\n   * Voter has reward only when revealed the vote\\n   *\\n   * Claims challenger\\u0027s reward after reveal period\\n   * Challenger has reward only if winning option is VoteAgainst\\n\\n   */\\n  function claimRewards(address _user)\\n    external\\n    notEmergency\\n  {\\n    // Challenge reward\\n    if(challenge.isVoteRevealPeriodOver() \\u0026\\u0026\\n       !challenge.isChallengeRewardClaimed() \\u0026\\u0026\\n       !challenge.isWinningOptionVoteFor() \\u0026\\u0026\\n       challenge.challenger == _user){\\n\\n      registryToken.transfer(challenge.challenger, challenge.challengeReward(deposit));\\n\\n      registry.fireChallengeRewardClaimedEvent(version,\\n                                               challenge.challenger,\\n                                               challenge.challengeReward(deposit));\\n    }\\n\\n    // Votes reward\\n    if(challenge.isVoteRevealPeriodOver() \\u0026\\u0026\\n       !challenge.isVoteRewardClaimed(_user) \\u0026\\u0026\\n       challenge.isVoteRevealed(_user) \\u0026\\u0026\\n       challenge.votedWinningVoteOption(_user)){\\n\\n      uint reward = challenge.voteReward(_user);\\n\\n      if(reward \\u003e 0){\\n        registryToken.transfer(_user, reward);\\n        challenge.vote[_user].claimedRewardOn = now;\\n\\n        registry.fireVoteRewardClaimedEvent(version,\\n                                            _user,\\n                                            reward);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function returns the current status of this registry entry\\n   */\\n  function status()\\n    external\\n    constant\\n    returns (uint)\\n  {\\n    return uint(challenge.status());\\n  }\\n\\n  /**\\n   * @dev Function called by MiniMeToken when somebody calls approveAndCall on it.\\n   * This way token can be transferred to a recipient in a single transaction together with execution\\n   * of additional logic\\n\\n   * @param _from Sender of transaction approval\\n   * @param _amount Amount of approved tokens to transfer\\n   * @param _token Token that received the approval\\n   * @param _data Bytecode of a function and passed parameters, that should be called after token approval\\n   */\\n  function receiveApproval(\\n                           address _from,\\n                           uint256 _amount,\\n                           address _token,\\n                           bytes _data)\\n    public\\n  {\\n    require(address(this).call(_data));\\n  }\\n\\n  function load() external constant returns (uint,\\n                                             address,\\n                                             uint,\\n                                             address,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             bytes,\\n                                             uint){\\n    return (deposit,\\n            creator,\\n            version,\\n            challenge.challenger,\\n            challenge.voteQuorum,\\n            challenge.commitPeriodEnd,\\n            challenge.revealPeriodEnd,\\n            challenge.rewardPool,\\n            challenge.metaHash,\\n            challenge.claimedRewardOn);\\n  }\\n\\n  function loadVote(address voter) external constant returns (bytes32,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint){\\n    return(challenge.vote[voter].secretHash,\\n           uint(challenge.vote[voter].option),\\n           challenge.vote[voter].amount,\\n           challenge.vote[voter].revealedOn,\\n           challenge.vote[voter].claimedRewardOn,\\n           challenge.vote[voter].reclaimedVoteAmountOn);\\n  }\\n}\\n\"},\"RegistryEntryFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./Forwarder.sol\\\";\\nimport \\\"./MiniMeToken.sol\\\";\\n\\n/**\\n * @title Base Factory contract for creating RegistryEntry contracts\\n *\\n * @dev This contract is meant to be extended by other factory contracts\\n */\\n\\ncontract RegistryEntryFactory is ApproveAndCallFallBack {\\n  Registry public registry;\\n  MiniMeToken public registryToken;\\n\\n  function RegistryEntryFactory(Registry _registry, MiniMeToken _registryToken) {\\n    registry = _registry;\\n    registryToken = _registryToken;\\n  }\\n\\n  /**\\n   * @dev Creates new forwarder contract as registry entry\\n   * Transfers required deposit from creator into this contract\\n   * Approves new registry entry address to transfer deposit to itself\\n   * Adds new registry entry address into the registry\\n\\n   * @param _creator Creator of registry entry\\n   * @return Address of a new registry entry forwarder contract\\n   */\\n  function createRegistryEntry(address _creator) internal returns (address) {\\n    uint deposit = registry.db().getUIntValue(registry.depositKey());\\n    address regEntry = new Forwarder();\\n    require(registryToken.transferFrom(_creator, this, deposit), \\\"RegistryEntryFactory: couldn\\u0027t transfer deposit\\\");\\n    require(registryToken.approve(regEntry, deposit), \\\"RegistryEntryFactory: Deposit not approved\\\");\\n    registry.addRegistryEntry(regEntry);\\n    return regEntry;\\n  }\\n\\n  /**\\n   * @dev Function called by MiniMeToken when somebody calls approveAndCall on it.\\n   * This way token can be transferred to a recipient in a single transaction together with execution\\n   * of additional logic\\n\\n   * @param _from Sender of transaction approval\\n   * @param _amount Amount of approved tokens to transfer\\n   * @param _token Token that received the approval\\n   * @param _data Bytecode of a function and passed parameters, that should be called after token approval\\n   */\\n  function receiveApproval(\\n    address _from,\\n    uint256 _amount,\\n    address _token,\\n    bytes _data)\\n  public\\n  {\\n    require(this.call(_data), \\\"RegistryEntryFactory: couldn\\u0027t call data\\\");\\n  }\\n}\\n\"},\"RegistryEntryLib.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary RegistryEntryLib {\\n\\n  using SafeMath for uint;\\n\\n  enum VoteOption {NoVote, VoteFor, VoteAgainst}\\n\\n  enum Status {ChallengePeriod, CommitPeriod, RevealPeriod, Blacklisted, Whitelisted}\\n\\n  struct Vote {\\n    bytes32 secretHash;\\n    VoteOption option;\\n    uint amount;\\n    uint revealedOn;\\n    uint claimedRewardOn;\\n    uint reclaimedVoteAmountOn;\\n  }\\n\\n  struct Challenge {\\n    address challenger;\\n    uint voteQuorum;\\n    uint rewardPool;\\n    bytes metaHash;\\n    uint commitPeriodEnd;\\n    uint revealPeriodEnd;\\n    uint challengePeriodEnd;\\n    uint votesFor;\\n    uint votesAgainst;\\n    uint claimedRewardOn;\\n    mapping(address =\\u003e Vote) vote;\\n  }\\n\\n  // External functions\\n\\n  /**\\n   * @dev Returns date when registry entry was whitelisted\\n   * Since this doesn\\u0027t happen with any transaction, it\\u0027s either reveal or challenge period end\\n\\n   * @return UNIX time of whitelisting\\n   */\\n  /* function whitelistedOn(Challenge storage self) */\\n  /*   external */\\n  /*   constant */\\n  /*   returns (uint) { */\\n  /*   if (!isWhitelisted()) { */\\n  /*     return 0; */\\n  /*   } */\\n  /*   if (self.wasChallenged()) { */\\n  /*     return self.revealPeriodEnd; */\\n  /*   } else { */\\n  /*     return challengePeriodEnd; */\\n  /*   } */\\n  /* } */\\n\\n  // Internal functions\\n\\n  function isVoteRevealPeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return !isVoteCommitPeriodActive(self) \\u0026\\u0026 now \\u003c= self.revealPeriodEnd;\\n  }\\n\\n  function isVoteRevealed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].revealedOn \\u003e 0;\\n  }\\n\\n  function isVoteRewardClaimed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].claimedRewardOn \\u003e 0;\\n  }\\n\\n  function isVoteAmountReclaimed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].reclaimedVoteAmountOn \\u003e 0;\\n  }\\n\\n  function isChallengeRewardClaimed(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.claimedRewardOn \\u003e 0;\\n  }\\n\\n  function isChallengePeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return now \\u003c= self.challengePeriodEnd;\\n  }\\n\\n  function isWhitelisted(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return status(self) == Status.Whitelisted;\\n  }\\n\\n  function isVoteCommitPeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return now \\u003c= self.commitPeriodEnd;\\n  }\\n\\n  function isVoteRevealPeriodOver(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.revealPeriodEnd \\u003e 0 \\u0026\\u0026 now \\u003e self.revealPeriodEnd;\\n  }\\n\\n  /**\\n   * @dev Returns whether VoteFor is winning vote option\\n   *\\n   * @return True if VoteFor is winning option\\n   */\\n  function isWinningOptionVoteFor(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return winningVoteOption(self) == VoteOption.VoteFor;\\n  }\\n\\n  function hasVoted(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].amount != 0;\\n  }\\n\\n  function wasChallenged(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.challenger != 0x0;\\n  }\\n\\n  /**\\n   * @dev Returns whether voter voted for winning vote option\\n   * @param _voter Address of a voter\\n   *\\n   * @return True if voter voted for a winning vote option\\n   */\\n  function votedWinningVoteOption(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].option == winningVoteOption(self);\\n  }\\n\\n  /**\\n   * @dev Returns current status of a registry entry\\n\\n   * @return Status\\n   */\\n  function status(Challenge storage self)\\n    internal\\n    constant\\n    returns (Status) {\\n    if (isChallengePeriodActive(self) \\u0026\\u0026 !wasChallenged(self)) {\\n      return Status.ChallengePeriod;\\n    } else if (isVoteCommitPeriodActive(self)) {\\n      return Status.CommitPeriod;\\n    } else if (isVoteRevealPeriodActive(self)) {\\n      return Status.RevealPeriod;\\n    } else if (isVoteRevealPeriodOver(self)) {\\n      if (isWinningOptionVoteFor(self)) {\\n        return Status.Whitelisted;\\n      } else {\\n        return Status.Blacklisted;\\n      }\\n    } else {\\n      return Status.Whitelisted;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns token reward amount belonging to a challenger\\n   *\\n   * @return Amount of token\\n   */\\n  function challengeReward(Challenge storage self, uint deposit)\\n    internal\\n    constant\\n    returns (uint) {\\n    return deposit.sub(self.rewardPool);\\n  }\\n\\n  /**\\n   * @dev Returns token reward amount belonging to a voter for voting for a winning option\\n   * @param _voter Address of a voter\\n   *\\n   * @return Amount of tokens\\n   */\\n  function voteReward(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (uint) {\\n    uint winningAmount = winningVotesAmount(self);\\n    uint voterAmount = 0;\\n\\n    if (!votedWinningVoteOption(self, _voter)) {\\n      return voterAmount;\\n    }\\n\\n    voterAmount = self.vote[_voter].amount;\\n    return (voterAmount.mul(self.rewardPool)) / winningAmount;\\n  }\\n\\n  /**\\n   * @dev Returns true when parameter key is in a whitelisted set and the parameter\\n   * value is within the allowed set of values.\\n   */\\n  function isChangeAllowed(Registry registry, bytes32 record, uint _value)\\n    internal\\n    constant\\n    returns (bool) {\\n\\n      if(record == registry.challengePeriodDurationKey() || record == registry.commitPeriodDurationKey() ||\\n         record == registry.revealPeriodDurationKey() || record == registry.depositKey()) {\\n        if(_value \\u003e 0) {\\n          return true;\\n        }\\n      }\\n\\n      if(record == registry.challengeDispensationKey() || record == registry.voteQuorumKey() ||\\n         record == registry.maxTotalSupplyKey()) {\\n        if (_value \\u003e= 0 \\u0026\\u0026 _value \\u003c= 100) {\\n          return true;\\n        }\\n      }\\n\\n      // see MemeAuction.sol startAuction\\n      if(record == registry.maxAuctionDurationKey()) {\\n        if(_value \\u003e= 1 minutes) {\\n          return true;\\n        }\\n      }\\n\\n    return false;\\n  }\\n\\n\\n  function bytesToUint(bytes b)\\n    internal\\n    returns (uint256) {\\n    uint256 number;\\n    for(uint i = 0; i \\u003c b.length; i++){\\n      number = number + uint(b[i]) * (2 ** (8 * (b.length - (i + 1))));\\n    }\\n    return number;\\n  }\\n\\n  function stringToUint(string s)\\n    internal\\n    constant\\n    returns (uint result) {\\n    bytes memory b = bytes(s);\\n    uint i;\\n    result = 0;\\n    for (i = 0; i \\u003c b.length; i++) {\\n      uint c = uint(b[i]);\\n      if (c \\u003e= 48 \\u0026\\u0026 c \\u003c= 57) {\\n        result = result * 10 + (c - 48);\\n      }\\n    }\\n  }\\n\\n  // Private functions\\n\\n  function isBlacklisted(Challenge storage self)\\n    private\\n    constant\\n    returns (bool) {\\n    return status(self) == Status.Blacklisted;\\n  }\\n\\n  /**\\n   * @dev Returns winning vote option in held voting according to vote quorum\\n   * If voteQuorum is 50, any majority of votes will win\\n   * If voteQuorum is 24, only 25 votes out of 100 is enough to VoteFor be winning option\\n   *\\n   * @return Winning vote option\\n   */\\n  function winningVoteOption(Challenge storage self)\\n    private\\n    constant\\n    returns (VoteOption) {\\n    if (!isVoteRevealPeriodOver(self)) {\\n      return VoteOption.NoVote;\\n    }\\n\\n    if (self.votesFor.mul(100) \\u003e self.voteQuorum.mul(self.votesFor.add(self.votesAgainst))) {\\n      return VoteOption.VoteFor;\\n    } else {\\n      return VoteOption.VoteAgainst;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns amount of votes for winning vote option\\n   *\\n   * @return Amount of votes\\n   */\\n  function winningVotesAmount(Challenge storage self)\\n    private\\n    constant\\n    returns (uint) {\\n    VoteOption voteOption = winningVoteOption(self);\\n\\n    if (voteOption == VoteOption.VoteFor) {\\n      return self.votesFor;\\n    } else if (voteOption == VoteOption.VoteAgainst) {\\n      return self.votesAgainst;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"TokenController.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/// @dev The token controller contract must implement these functions\\ncontract TokenController {\\n  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\\n  /// @param _owner The address that sent the ether to create tokens\\n  /// @return True if the ether is accepted, false if it throws\\n  function proxyPayment(address _owner) public payable returns(bool);\\n\\n  /// @notice Notifies the controller about a token transfer allowing the\\n  ///  controller to react if desired\\n  /// @param _from The origin of the transfer\\n  /// @param _to The destination of the transfer\\n  /// @param _amount The amount of the transfer\\n  /// @return False if the controller does not authorize the transfer\\n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\\n\\n  /// @notice Notifies the controller about an approval allowing the\\n  ///  controller to react if desired\\n  /// @param _owner The address that calls `approve()`\\n  /// @param _spender The spender in the `approve()` call\\n  /// @param _amount The amount in the `approve()` call\\n  /// @return False if the controller does not authorize the approval\\n  function onApprove(address _owner, address _spender, uint _amount) public\\n  returns(bool);\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_secretHash\",\"type\":\"bytes32\"}],\"name\":\"commitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"reclaimVoteAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"loadVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"load\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_challenger\",\"type\":\"address\"},{\"name\":\"_challengeMetaHash\",\"type\":\"bytes\"}],\"name\":\"createChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"construct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voteOption\",\"type\":\"uint8\"},{\"name\":\"_salt\",\"type\":\"string\"}],\"name\":\"revealVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_metaHash\",\"type\":\"bytes\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"construct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loadMeme\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Meme","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://65161df30bb26f134231ba5cdd5e2c0f01230b3d3d95b32b52f492aebd45b2bb"}]}