{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract SyscoinDepositsManager {\r\n\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) public deposits;\r\n\r\n    event DepositMade(address who, uint amount);\r\n    event DepositWithdrawn(address who, uint amount);\r\n\r\n    // @dev – fallback to calling makeDeposit when ether is sent directly to contract.\r\n    function() public payable {\r\n        makeDeposit();\r\n    }\r\n\r\n    // @dev – returns an account's deposit\r\n    // @param who – the account's address.\r\n    // @return – the account's deposit.\r\n    function getDeposit(address who) constant public returns (uint) {\r\n        return deposits[who];\r\n    }\r\n\r\n    // @dev – allows a user to deposit eth.\r\n    // @return – sender's updated deposit amount.\r\n    function makeDeposit() public payable returns (uint) {\r\n        increaseDeposit(msg.sender, msg.value);\r\n        return deposits[msg.sender];\r\n    }\r\n\r\n    // @dev – increases an account's deposit.\r\n    // @return – the given user's updated deposit amount.\r\n    function increaseDeposit(address who, uint amount) internal {\r\n        deposits[who] = deposits[who].add(amount);\r\n        require(deposits[who] <= address(this).balance);\r\n\r\n        emit DepositMade(who, amount);\r\n    }\r\n\r\n    // @dev – allows a user to withdraw eth from their deposit.\r\n    // @param amount – how much eth to withdraw\r\n    // @return – sender's updated deposit amount.\r\n    function withdrawDeposit(uint amount) public returns (uint) {\r\n        require(deposits[msg.sender] >= amount);\r\n\r\n        deposits[msg.sender] = deposits[msg.sender].sub(amount);\r\n        msg.sender.transfer(amount);\r\n\r\n        emit DepositWithdrawn(msg.sender, amount);\r\n        return deposits[msg.sender];\r\n    }\r\n}\r\n\r\n// Interface contract to be implemented by SyscoinToken\r\ncontract SyscoinTransactionProcessor {\r\n    function processTransaction(uint txHash, uint value, address destinationAddress, uint32 _assetGUID, address superblockSubmitterAddress) public returns (uint);\r\n    function burn(uint _value, uint32 _assetGUID, bytes syscoinWitnessProgram) payable public returns (bool success);\r\n}\r\n\r\n// Bitcoin transaction parsing library - modified for SYSCOIN\r\n\r\n// Copyright 2016 rain <https://keybase.io/rain>\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\r\n//\r\n// Raw Bitcoin transaction structure:\r\n//\r\n// field     | size | type     | description\r\n// version   | 4    | int32    | transaction version number\r\n// n_tx_in   | 1-9  | var_int  | number of transaction inputs\r\n// tx_in     | 41+  | tx_in[]  | list of transaction inputs\r\n// n_tx_out  | 1-9  | var_int  | number of transaction outputs\r\n// tx_out    | 9+   | tx_out[] | list of transaction outputs\r\n// lock_time | 4    | uint32   | block number / timestamp at which tx locked\r\n//\r\n// Transaction input (tx_in) structure:\r\n//\r\n// field      | size | type     | description\r\n// previous   | 36   | outpoint | Previous output transaction reference\r\n// script_len | 1-9  | var_int  | Length of the signature script\r\n// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\r\n// sequence   | 4    | uint32   | Sender transaction version\r\n//\r\n// OutPoint structure:\r\n//\r\n// field      | size | type     | description\r\n// hash       | 32   | char[32] | The hash of the referenced transaction\r\n// index      | 4    | uint32   | The index of this output in the referenced transaction\r\n//\r\n// Transaction output (tx_out) structure:\r\n//\r\n// field         | size | type     | description\r\n// value         | 8    | int64    | Transaction value (Satoshis)\r\n// pk_script_len | 1-9  | var_int  | Length of the public key script\r\n// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\r\n//\r\n// Variable integers (var_int) can be encoded differently depending\r\n// on the represented value, to save space. Variable integers always\r\n// precede an array of a variable length data type (e.g. tx_in).\r\n//\r\n// Variable integer encodings as a function of represented value:\r\n//\r\n// value           | bytes  | format\r\n// <0xFD (253)     | 1      | uint8\r\n// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\r\n// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\r\n// -               | 9      | 0xFF followed by length as uint64\r\n//\r\n// Public key scripts `pk_script` are set on the output and can\r\n// take a number of forms. The regular transaction script is\r\n// called 'pay-to-pubkey-hash' (P2PKH):\r\n//\r\n// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\r\n//\r\n// OP_x are Bitcoin script opcodes. The bytes representation (including\r\n// the 0x14 20-byte stack push) is:\r\n//\r\n// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\r\n//\r\n// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\r\n// the public key, preceded by a network version byte. (21 bytes total)\r\n//\r\n// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\r\n//\r\n// The Bitcoin address is derived from the pubKeyHash. The binary form is the\r\n// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\r\n// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\r\n// This is converted to base58 to form the publicly used Bitcoin address.\r\n// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\r\n//\r\n// P2SH ('pay to script hash') scripts only supply a script hash. The spender\r\n// must then provide the script that would allow them to redeem this output.\r\n// This allows for arbitrarily complex scripts to be funded using only a\r\n// hash of the script, and moves the onus on providing the script from\r\n// the spender to the redeemer.\r\n//\r\n// The P2SH script format is simple:\r\n//\r\n// OP_HASH160 <scriptHash> OP_EQUAL\r\n//\r\n// 0xA9 0x14 <scriptHash> 0x87\r\n//\r\n// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\r\n// redeem script. The P2SH address is derived from the scriptHash.\r\n// Addresses are the scriptHash with a version prefix of 5, encoded as\r\n// Base58check. These addresses begin with a '3'.\r\n\r\n\r\n\r\n// parse a raw Syscoin transaction byte array\r\nlibrary SyscoinMessageLibrary {\r\n\r\n    uint constant p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;  // secp256k1\r\n    uint constant q = (p + 1) / 4;\r\n\r\n    // Error codes\r\n    uint constant ERR_INVALID_HEADER = 10050;\r\n    uint constant ERR_COINBASE_INDEX = 10060; // coinbase tx index within Litecoin merkle isn't 0\r\n    uint constant ERR_NOT_MERGE_MINED = 10070; // trying to check AuxPoW on a block that wasn't merge mined\r\n    uint constant ERR_FOUND_TWICE = 10080; // 0xfabe6d6d found twice\r\n    uint constant ERR_NO_MERGE_HEADER = 10090; // 0xfabe6d6d not found\r\n    uint constant ERR_NOT_IN_FIRST_20 = 10100; // chain Merkle root isn't in the first 20 bytes of coinbase tx\r\n    uint constant ERR_CHAIN_MERKLE = 10110;\r\n    uint constant ERR_PARENT_MERKLE = 10120;\r\n    uint constant ERR_PROOF_OF_WORK = 10130;\r\n    uint constant ERR_INVALID_HEADER_HASH = 10140;\r\n    uint constant ERR_PROOF_OF_WORK_AUXPOW = 10150;\r\n    uint constant ERR_PARSE_TX_OUTPUT_LENGTH = 10160;\r\n    uint constant ERR_PARSE_TX_SYS = 10170;\r\n    enum Network { MAINNET, TESTNET, REGTEST }\r\n    uint32 constant SYSCOIN_TX_VERSION_ASSET_ALLOCATION_BURN = 0x7407;\r\n    uint32 constant SYSCOIN_TX_VERSION_BURN = 0x7401;\r\n    // AuxPoW block fields\r\n    struct AuxPoW {\r\n        uint blockHash;\r\n\r\n        uint txHash;\r\n\r\n        uint coinbaseMerkleRoot; // Merkle root of auxiliary block hash tree; stored in coinbase tx field\r\n        uint[] chainMerkleProof; // proves that a given Syscoin block hash belongs to a tree with the above root\r\n        uint syscoinHashIndex; // index of Syscoin block hash within block hash tree\r\n        uint coinbaseMerkleRootCode; // encodes whether or not the root was found properly\r\n\r\n        uint parentMerkleRoot; // Merkle root of transaction tree from parent Litecoin block header\r\n        uint[] parentMerkleProof; // proves that coinbase tx belongs to a tree with the above root\r\n        uint coinbaseTxIndex; // index of coinbase tx within Litecoin tx tree\r\n\r\n        uint parentNonce;\r\n    }\r\n\r\n    // Syscoin block header stored as a struct, mostly for readability purposes.\r\n    // BlockHeader structs can be obtained by parsing a block header's first 80 bytes\r\n    // with parseHeaderBytes.\r\n    struct BlockHeader {\r\n        uint32 bits;\r\n        uint blockHash;\r\n    }\r\n    // Convert a variable integer into something useful and return it and\r\n    // the index to after it.\r\n    function parseVarInt(bytes memory txBytes, uint pos) private pure returns (uint, uint) {\r\n        // the first byte tells us how big the integer is\r\n        uint8 ibit = uint8(txBytes[pos]);\r\n        pos += 1;  // skip ibit\r\n\r\n        if (ibit < 0xfd) {\r\n            return (ibit, pos);\r\n        } else if (ibit == 0xfd) {\r\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\r\n        } else if (ibit == 0xfe) {\r\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\r\n        } else if (ibit == 0xff) {\r\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\r\n        }\r\n    }\r\n    // convert little endian bytes to uint\r\n    function getBytesLE(bytes memory data, uint pos, uint bits) internal pure returns (uint) {\r\n        if (bits == 8) {\r\n            return uint8(data[pos]);\r\n        } else if (bits == 16) {\r\n            return uint16(data[pos])\r\n                 + uint16(data[pos + 1]) * 2 ** 8;\r\n        } else if (bits == 32) {\r\n            return uint32(data[pos])\r\n                 + uint32(data[pos + 1]) * 2 ** 8\r\n                 + uint32(data[pos + 2]) * 2 ** 16\r\n                 + uint32(data[pos + 3]) * 2 ** 24;\r\n        } else if (bits == 64) {\r\n            return uint64(data[pos])\r\n                 + uint64(data[pos + 1]) * 2 ** 8\r\n                 + uint64(data[pos + 2]) * 2 ** 16\r\n                 + uint64(data[pos + 3]) * 2 ** 24\r\n                 + uint64(data[pos + 4]) * 2 ** 32\r\n                 + uint64(data[pos + 5]) * 2 ** 40\r\n                 + uint64(data[pos + 6]) * 2 ** 48\r\n                 + uint64(data[pos + 7]) * 2 ** 56;\r\n        }\r\n    }\r\n    \r\n\r\n    // @dev - Parses a syscoin tx\r\n    //\r\n    // @param txBytes - tx byte array\r\n    // Outputs\r\n    // @return output_value - amount sent to the lock address in satoshis\r\n    // @return destinationAddress - ethereum destination address\r\n\r\n\r\n    function parseTransaction(bytes memory txBytes) internal pure\r\n             returns (uint, uint, address, uint32)\r\n    {\r\n        \r\n        uint output_value;\r\n        uint32 assetGUID;\r\n        address destinationAddress;\r\n        uint32 version;\r\n        uint pos = 0;\r\n        version = bytesToUint32Flipped(txBytes, pos);\r\n        if(version != SYSCOIN_TX_VERSION_ASSET_ALLOCATION_BURN && version != SYSCOIN_TX_VERSION_BURN){\r\n            return (ERR_PARSE_TX_SYS, output_value, destinationAddress, assetGUID);\r\n        }\r\n        pos = skipInputs(txBytes, 4);\r\n            \r\n        (output_value, destinationAddress, assetGUID) = scanBurns(txBytes, version, pos);\r\n        return (0, output_value, destinationAddress, assetGUID);\r\n    }\r\n\r\n\r\n  \r\n    // skips witnesses and saves first script position/script length to extract pubkey of first witness scriptSig\r\n    function skipWitnesses(bytes memory txBytes, uint pos, uint n_inputs) private pure\r\n             returns (uint)\r\n    {\r\n        uint n_stack;\r\n        (n_stack, pos) = parseVarInt(txBytes, pos);\r\n        \r\n        uint script_len;\r\n        for (uint i = 0; i < n_inputs; i++) {\r\n            for (uint j = 0; j < n_stack; j++) {\r\n                (script_len, pos) = parseVarInt(txBytes, pos);\r\n                pos += script_len;\r\n            }\r\n        }\r\n\r\n        return n_stack;\r\n    }    \r\n\r\n    function skipInputs(bytes memory txBytes, uint pos) private pure\r\n             returns (uint)\r\n    {\r\n        uint n_inputs;\r\n        uint script_len;\r\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\r\n        // if dummy 0x00 is present this is a witness transaction\r\n        if(n_inputs == 0x00){\r\n            (n_inputs, pos) = parseVarInt(txBytes, pos); // flag\r\n            assert(n_inputs != 0x00);\r\n            // after dummy/flag the real var int comes for txins\r\n            (n_inputs, pos) = parseVarInt(txBytes, pos);\r\n        }\r\n        require(n_inputs < 100);\r\n\r\n        for (uint i = 0; i < n_inputs; i++) {\r\n            pos += 36;  // skip outpoint\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            pos += script_len + 4;  // skip sig_script, seq\r\n        }\r\n\r\n        return pos;\r\n    }\r\n             \r\n    // scan the burn outputs and return the value and script data of first burned output.\r\n    function scanBurns(bytes memory txBytes, uint32 version, uint pos) private pure\r\n             returns (uint, address, uint32)\r\n    {\r\n        uint script_len;\r\n        uint output_value;\r\n        uint32 assetGUID = 0;\r\n        address destinationAddress;\r\n        uint n_outputs;\r\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\r\n        require(n_outputs < 10);\r\n        for (uint i = 0; i < n_outputs; i++) {\r\n            // output\r\n            if(version == SYSCOIN_TX_VERSION_BURN){\r\n                output_value = getBytesLE(txBytes, pos, 64);\r\n            }\r\n            pos += 8;\r\n            // varint\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            if(!isOpReturn(txBytes, pos)){\r\n                // output script\r\n                pos += script_len;\r\n                output_value = 0;\r\n                continue;\r\n            }\r\n            // skip opreturn marker\r\n            pos += 1;\r\n            if(version == SYSCOIN_TX_VERSION_ASSET_ALLOCATION_BURN){\r\n                (output_value, destinationAddress, assetGUID) = scanAssetDetails(txBytes, pos);\r\n            }\r\n            else if(version == SYSCOIN_TX_VERSION_BURN){                \r\n                destinationAddress = scanSyscoinDetails(txBytes, pos);   \r\n            }\r\n            // only one opreturn data allowed per transaction\r\n            break;\r\n        }\r\n\r\n        return (output_value, destinationAddress, assetGUID);\r\n    }\r\n\r\n    function skipOutputs(bytes memory txBytes, uint pos) private pure\r\n             returns (uint)\r\n    {\r\n        uint n_outputs;\r\n        uint script_len;\r\n\r\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        require(n_outputs < 10);\r\n\r\n        for (uint i = 0; i < n_outputs; i++) {\r\n            pos += 8;\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            pos += script_len;\r\n        }\r\n\r\n        return pos;\r\n    }\r\n    // get final position of inputs, outputs and lock time\r\n    // this is a helper function to slice a byte array and hash the inputs, outputs and lock time\r\n    function getSlicePos(bytes memory txBytes, uint pos) private pure\r\n             returns (uint slicePos)\r\n    {\r\n        slicePos = skipInputs(txBytes, pos + 4);\r\n        slicePos = skipOutputs(txBytes, slicePos);\r\n        slicePos += 4; // skip lock time\r\n    }\r\n    // scan a Merkle branch.\r\n    // return array of values and the end position of the sibling hashes.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // siblings to scan through. stop=0 => scan all.\r\n    function scanMerkleBranch(bytes memory txBytes, uint pos, uint stop) private pure\r\n             returns (uint[], uint)\r\n    {\r\n        uint n_siblings;\r\n        uint halt;\r\n\r\n        (n_siblings, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_siblings) {\r\n            halt = n_siblings;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory sibling_values = new uint[](halt);\r\n\r\n        for (uint i = 0; i < halt; i++) {\r\n            sibling_values[i] = flip32Bytes(sliceBytes32Int(txBytes, pos));\r\n            pos += 32;\r\n        }\r\n\r\n        return (sibling_values, pos);\r\n    }   \r\n    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\r\n    function sliceBytes20(bytes memory data, uint start) private pure returns (bytes20) {\r\n        uint160 slice = 0;\r\n        // FIXME: With solc v0.4.24 and optimizations enabled\r\n        // using uint160 for index i will generate an error\r\n        // \"Error: VM Exception while processing transaction: Error: redPow(normalNum)\"\r\n        for (uint i = 0; i < 20; i++) {\r\n            slice += uint160(data[i + start]) << (8 * (19 - i));\r\n        }\r\n        return bytes20(slice);\r\n    }\r\n    // Slice 32 contiguous bytes from bytes `data`, starting at `start`\r\n    function sliceBytes32Int(bytes memory data, uint start) private pure returns (uint slice) {\r\n        for (uint i = 0; i < 32; i++) {\r\n            if (i + start < data.length) {\r\n                slice += uint(data[i + start]) << (8 * (31 - i));\r\n            }\r\n        }\r\n    }\r\n\r\n    // @dev returns a portion of a given byte array specified by its starting and ending points\r\n    // Should be private, made internal for testing\r\n    // Breaks underscore naming convention for parameters because it raises a compiler error\r\n    // if `offset` is changed to `_offset`.\r\n    //\r\n    // @param _rawBytes - array to be sliced\r\n    // @param offset - first byte of sliced array\r\n    // @param _endIndex - last byte of sliced array\r\n    function sliceArray(bytes memory _rawBytes, uint offset, uint _endIndex) internal view returns (bytes) {\r\n        uint len = _endIndex - offset;\r\n        bytes memory result = new bytes(len);\r\n        assembly {\r\n            // Call precompiled contract to copy data\r\n            if iszero(staticcall(gas, 0x04, add(add(_rawBytes, 0x20), offset), len, add(result, 0x20), len)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    \r\n    // Returns true if the tx output is an OP_RETURN output\r\n    function isOpReturn(bytes memory txBytes, uint pos) private pure\r\n             returns (bool) {\r\n        // scriptPub format is\r\n        // 0x6a OP_RETURN\r\n        return \r\n            txBytes[pos] == byte(0x6a);\r\n    }\r\n    // Returns syscoin data parsed from the op_return data output from syscoin burn transaction\r\n    function scanSyscoinDetails(bytes memory txBytes, uint pos) private pure\r\n             returns (address) {      \r\n        uint8 op;\r\n        (op, pos) = getOpcode(txBytes, pos);\r\n        // ethereum addresses are 20 bytes (without the 0x)\r\n        require(op == 0x14);\r\n        return readEthereumAddress(txBytes, pos);\r\n    }    \r\n    // Returns asset data parsed from the op_return data output from syscoin asset burn transaction\r\n    function scanAssetDetails(bytes memory txBytes, uint pos) private pure\r\n             returns (uint, address, uint32) {\r\n                 \r\n        uint32 assetGUID;\r\n        address destinationAddress;\r\n        uint output_value;\r\n        uint8 op;\r\n        // vchAsset\r\n        (op, pos) = getOpcode(txBytes, pos);\r\n        // guid length should be 4 bytes\r\n        require(op == 0x04);\r\n        assetGUID = bytesToUint32(txBytes, pos);\r\n        pos += op;\r\n        // amount\r\n        (op, pos) = getOpcode(txBytes, pos);\r\n        require(op == 0x08);\r\n        output_value = bytesToUint64(txBytes, pos);\r\n        pos += op;\r\n         // destination address\r\n        (op, pos) = getOpcode(txBytes, pos);\r\n        // ethereum contracts are 20 bytes (without the 0x)\r\n        require(op == 0x14);\r\n        destinationAddress = readEthereumAddress(txBytes, pos);       \r\n        return (output_value, destinationAddress, assetGUID);\r\n    }         \r\n    // Read the ethereum address embedded in the tx output\r\n    function readEthereumAddress(bytes memory txBytes, uint pos) private pure\r\n             returns (address) {\r\n        uint256 data;\r\n        assembly {\r\n            data := mload(add(add(txBytes, 20), pos))\r\n        }\r\n        return address(uint160(data));\r\n    }\r\n\r\n    // Read next opcode from script\r\n    function getOpcode(bytes memory txBytes, uint pos) private pure\r\n             returns (uint8, uint)\r\n    {\r\n        require(pos < txBytes.length);\r\n        return (uint8(txBytes[pos]), pos + 1);\r\n    }\r\n\r\n    // @dev - convert an unsigned integer from little-endian to big-endian representation\r\n    //\r\n    // @param _input - little-endian value\r\n    // @return - input value in big-endian format\r\n    function flip32Bytes(uint _input) internal pure returns (uint result) {\r\n        assembly {\r\n            let pos := mload(0x40)\r\n            for { let i := 0 } lt(i, 32) { i := add(i, 1) } {\r\n                mstore8(add(pos, i), byte(sub(31, i), _input))\r\n            }\r\n            result := mload(pos)\r\n        }\r\n    }\r\n    // helpers for flip32Bytes\r\n    struct UintWrapper {\r\n        uint value;\r\n    }\r\n\r\n    function ptr(UintWrapper memory uw) private pure returns (uint addr) {\r\n        assembly {\r\n            addr := uw\r\n        }\r\n    }\r\n\r\n    function parseAuxPoW(bytes memory rawBytes, uint pos) internal view\r\n             returns (AuxPoW memory auxpow)\r\n    {\r\n        // we need to traverse the bytes with a pointer because some fields are of variable length\r\n        pos += 80; // skip non-AuxPoW header\r\n        uint slicePos;\r\n        (slicePos) = getSlicePos(rawBytes, pos);\r\n        auxpow.txHash = dblShaFlipMem(rawBytes, pos, slicePos - pos);\r\n        pos = slicePos;\r\n        // parent block hash, skip and manually hash below\r\n        pos += 32;\r\n        (auxpow.parentMerkleProof, pos) = scanMerkleBranch(rawBytes, pos, 0);\r\n        auxpow.coinbaseTxIndex = getBytesLE(rawBytes, pos, 32);\r\n        pos += 4;\r\n        (auxpow.chainMerkleProof, pos) = scanMerkleBranch(rawBytes, pos, 0);\r\n        auxpow.syscoinHashIndex = getBytesLE(rawBytes, pos, 32);\r\n        pos += 4;\r\n        // calculate block hash instead of reading it above, as some are LE and some are BE, we cannot know endianness and have to calculate from parent block header\r\n        auxpow.blockHash = dblShaFlipMem(rawBytes, pos, 80);\r\n        pos += 36; // skip parent version and prev block\r\n        auxpow.parentMerkleRoot = sliceBytes32Int(rawBytes, pos);\r\n        pos += 40; // skip root that was just read, parent block timestamp and bits\r\n        auxpow.parentNonce = getBytesLE(rawBytes, pos, 32);\r\n        uint coinbaseMerkleRootPosition;\r\n        (auxpow.coinbaseMerkleRoot, coinbaseMerkleRootPosition, auxpow.coinbaseMerkleRootCode) = findCoinbaseMerkleRoot(rawBytes);\r\n    }\r\n\r\n    // @dev - looks for {0xfa, 0xbe, 'm', 'm'} byte sequence\r\n    // returns the following 32 bytes if it appears once and only once,\r\n    // 0 otherwise\r\n    // also returns the position where the bytes first appear\r\n    function findCoinbaseMerkleRoot(bytes memory rawBytes) private pure\r\n             returns (uint, uint, uint)\r\n    {\r\n        uint position;\r\n        bool found = false;\r\n\r\n        for (uint i = 0; i < rawBytes.length; ++i) {\r\n            if (rawBytes[i] == 0xfa && rawBytes[i+1] == 0xbe && rawBytes[i+2] == 0x6d && rawBytes[i+3] == 0x6d) {\r\n                if (found) { // found twice\r\n                    return (0, position - 4, ERR_FOUND_TWICE);\r\n                } else {\r\n                    found = true;\r\n                    position = i + 4;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!found) { // no merge mining header\r\n            return (0, position - 4, ERR_NO_MERGE_HEADER);\r\n        } else {\r\n            return (sliceBytes32Int(rawBytes, position), position - 4, 1);\r\n        }\r\n    }\r\n\r\n    // @dev - Evaluate the merkle root\r\n    //\r\n    // Given an array of hashes it calculates the\r\n    // root of the merkle tree.\r\n    //\r\n    // @return root of merkle tree\r\n    function makeMerkle(bytes32[] hashes2) external pure returns (bytes32) {\r\n        bytes32[] memory hashes = hashes2;\r\n        uint length = hashes.length;\r\n        if (length == 1) return hashes[0];\r\n        require(length > 0);\r\n        uint i;\r\n        uint j;\r\n        uint k;\r\n        k = 0;\r\n        while (length > 1) {\r\n            k = 0;\r\n            for (i = 0; i < length; i += 2) {\r\n                j = i+1<length ? i+1 : length-1;\r\n                hashes[k] = bytes32(concatHash(uint(hashes[i]), uint(hashes[j])));\r\n                k += 1;\r\n            }\r\n            length = k;\r\n        }\r\n        return hashes[0];\r\n    }\r\n\r\n    // @dev - For a valid proof, returns the root of the Merkle tree.\r\n    //\r\n    // @param _txHash - transaction hash\r\n    // @param _txIndex - transaction's index within the block it's assumed to be in\r\n    // @param _siblings - transaction's Merkle siblings\r\n    // @return - Merkle tree root of the block the transaction belongs to if the proof is valid,\r\n    // garbage if it's invalid\r\n    function computeMerkle(uint _txHash, uint _txIndex, uint[] memory _siblings) internal pure returns (uint) {\r\n        uint resultHash = _txHash;\r\n        uint i = 0;\r\n        while (i < _siblings.length) {\r\n            uint proofHex = _siblings[i];\r\n\r\n            uint sideOfSiblings = _txIndex % 2;  // 0 means _siblings is on the right; 1 means left\r\n\r\n            uint left;\r\n            uint right;\r\n            if (sideOfSiblings == 1) {\r\n                left = proofHex;\r\n                right = resultHash;\r\n            } else if (sideOfSiblings == 0) {\r\n                left = resultHash;\r\n                right = proofHex;\r\n            }\r\n\r\n            resultHash = concatHash(left, right);\r\n\r\n            _txIndex /= 2;\r\n            i += 1;\r\n        }\r\n\r\n        return resultHash;\r\n    }\r\n\r\n    // @dev - calculates the Merkle root of a tree containing Litecoin transactions\r\n    // in order to prove that `ap`'s coinbase tx is in that Litecoin block.\r\n    //\r\n    // @param _ap - AuxPoW information\r\n    // @return - Merkle root of Litecoin block that the Syscoin block\r\n    // with this info was mined in if AuxPoW Merkle proof is correct,\r\n    // garbage otherwise\r\n    function computeParentMerkle(AuxPoW memory _ap) internal pure returns (uint) {\r\n        return flip32Bytes(computeMerkle(_ap.txHash,\r\n                                         _ap.coinbaseTxIndex,\r\n                                         _ap.parentMerkleProof));\r\n    }\r\n\r\n    // @dev - calculates the Merkle root of a tree containing auxiliary block hashes\r\n    // in order to prove that the Syscoin block identified by _blockHash\r\n    // was merge-mined in a Litecoin block.\r\n    //\r\n    // @param _blockHash - SHA-256 hash of a certain Syscoin block\r\n    // @param _ap - AuxPoW information corresponding to said block\r\n    // @return - Merkle root of auxiliary chain tree\r\n    // if AuxPoW Merkle proof is correct, garbage otherwise\r\n    function computeChainMerkle(uint _blockHash, AuxPoW memory _ap) internal pure returns (uint) {\r\n        return computeMerkle(_blockHash,\r\n                             _ap.syscoinHashIndex,\r\n                             _ap.chainMerkleProof);\r\n    }\r\n\r\n    // @dev - Helper function for Merkle root calculation.\r\n    // Given two sibling nodes in a Merkle tree, calculate their parent.\r\n    // Concatenates hashes `_tx1` and `_tx2`, then hashes the result.\r\n    //\r\n    // @param _tx1 - Merkle node (either root or internal node)\r\n    // @param _tx2 - Merkle node (either root or internal node), has to be `_tx1`'s sibling\r\n    // @return - `_tx1` and `_tx2`'s parent, i.e. the result of concatenating them,\r\n    // hashing that twice and flipping the bytes.\r\n    function concatHash(uint _tx1, uint _tx2) internal pure returns (uint) {\r\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256(abi.encodePacked(flip32Bytes(_tx1), flip32Bytes(_tx2)))))));\r\n    }\r\n\r\n    // @dev - checks if a merge-mined block's Merkle proofs are correct,\r\n    // i.e. Syscoin block hash is in coinbase Merkle tree\r\n    // and coinbase transaction is in parent Merkle tree.\r\n    //\r\n    // @param _blockHash - SHA-256 hash of the block whose Merkle proofs are being checked\r\n    // @param _ap - AuxPoW struct corresponding to the block\r\n    // @return 1 if block was merge-mined and coinbase index, chain Merkle root and Merkle proofs are correct,\r\n    // respective error code otherwise\r\n    function checkAuxPoW(uint _blockHash, AuxPoW memory _ap) internal pure returns (uint) {\r\n        if (_ap.coinbaseTxIndex != 0) {\r\n            return ERR_COINBASE_INDEX;\r\n        }\r\n\r\n        if (_ap.coinbaseMerkleRootCode != 1) {\r\n            return _ap.coinbaseMerkleRootCode;\r\n        }\r\n\r\n        if (computeChainMerkle(_blockHash, _ap) != _ap.coinbaseMerkleRoot) {\r\n            return ERR_CHAIN_MERKLE;\r\n        }\r\n\r\n        if (computeParentMerkle(_ap) != _ap.parentMerkleRoot) {\r\n            return ERR_PARENT_MERKLE;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    function sha256mem(bytes memory _rawBytes, uint offset, uint len) internal view returns (bytes32 result) {\r\n        assembly {\r\n            // Call sha256 precompiled contract (located in address 0x02) to copy data.\r\n            // Assign to ptr the next available memory position (stored in memory position 0x40).\r\n            let ptr := mload(0x40)\r\n            if iszero(staticcall(gas, 0x02, add(add(_rawBytes, 0x20), offset), len, ptr, 0x20)) {\r\n                revert(0, 0)\r\n            }\r\n            result := mload(ptr)\r\n        }\r\n    }\r\n\r\n    // @dev - Bitcoin-way of hashing\r\n    // @param _dataBytes - raw data to be hashed\r\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\r\n    function dblShaFlip(bytes _dataBytes) internal pure returns (uint) {\r\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256(abi.encodePacked(_dataBytes))))));\r\n    }\r\n\r\n    // @dev - Bitcoin-way of hashing\r\n    // @param _dataBytes - raw data to be hashed\r\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\r\n    function dblShaFlipMem(bytes memory _rawBytes, uint offset, uint len) internal view returns (uint) {\r\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256mem(_rawBytes, offset, len)))));\r\n    }\r\n\r\n    // @dev – Read a bytes32 from an offset in the byte array\r\n    function readBytes32(bytes memory data, uint offset) internal pure returns (bytes32) {\r\n        bytes32 result;\r\n        assembly {\r\n            result := mload(add(add(data, 0x20), offset))\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // @dev – Read an uint32 from an offset in the byte array\r\n    function readUint32(bytes memory data, uint offset) internal pure returns (uint32) {\r\n        uint32 result;\r\n        assembly {\r\n            result := mload(add(add(data, 0x20), offset))\r\n            \r\n        }\r\n        return result;\r\n    }\r\n\r\n    // @dev - Bitcoin-way of computing the target from the 'bits' field of a block header\r\n    // based on http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html//ref3\r\n    //\r\n    // @param _bits - difficulty in bits format\r\n    // @return - difficulty in target format\r\n    function targetFromBits(uint32 _bits) internal pure returns (uint) {\r\n        uint exp = _bits / 0x1000000;  // 2**24\r\n        uint mant = _bits & 0xffffff;\r\n        return mant * 256**(exp - 3);\r\n    }\r\n\r\n    uint constant SYSCOIN_DIFFICULTY_ONE = 0xFFFFF * 256**(0x1e - 3);\r\n\r\n    // @dev - Calculate syscoin difficulty from target\r\n    // https://en.bitcoin.it/wiki/Difficulty\r\n    // Min difficulty for bitcoin is 0x1d00ffff\r\n    // Min difficulty for syscoin is 0x1e0fffff\r\n    function targetToDiff(uint target) internal pure returns (uint) {\r\n        return SYSCOIN_DIFFICULTY_ONE / target;\r\n    }\r\n    \r\n\r\n    // 0x00 version\r\n    // 0x04 prev block hash\r\n    // 0x24 merkle root\r\n    // 0x44 timestamp\r\n    // 0x48 bits\r\n    // 0x4c nonce\r\n\r\n    // @dev - extract previous block field from a raw Syscoin block header\r\n    //\r\n    // @param _blockHeader - Syscoin block header bytes\r\n    // @param pos - where to start reading hash from\r\n    // @return - hash of block's parent in big endian format\r\n    function getHashPrevBlock(bytes memory _blockHeader) internal pure returns (uint) {\r\n        uint hashPrevBlock;\r\n        assembly {\r\n            hashPrevBlock := mload(add(add(_blockHeader, 32), 0x04))\r\n        }\r\n        return flip32Bytes(hashPrevBlock);\r\n    }\r\n\r\n    // @dev - extract Merkle root field from a raw Syscoin block header\r\n    //\r\n    // @param _blockHeader - Syscoin block header bytes\r\n    // @param pos - where to start reading root from\r\n    // @return - block's Merkle root in big endian format\r\n    function getHeaderMerkleRoot(bytes memory _blockHeader) public pure returns (uint) {\r\n        uint merkle;\r\n        assembly {\r\n            merkle := mload(add(add(_blockHeader, 32), 0x24))\r\n        }\r\n        return flip32Bytes(merkle);\r\n    }\r\n\r\n    // @dev - extract timestamp field from a raw Syscoin block header\r\n    //\r\n    // @param _blockHeader - Syscoin block header bytes\r\n    // @param pos - where to start reading bits from\r\n    // @return - block's timestamp in big-endian format\r\n    function getTimestamp(bytes memory _blockHeader) internal pure returns (uint32 time) {\r\n        return bytesToUint32Flipped(_blockHeader, 0x44);\r\n    }\r\n\r\n    // @dev - extract bits field from a raw Syscoin block header\r\n    //\r\n    // @param _blockHeader - Syscoin block header bytes\r\n    // @param pos - where to start reading bits from\r\n    // @return - block's difficulty in bits format, also big-endian\r\n    function getBits(bytes memory _blockHeader) internal pure returns (uint32 bits) {\r\n        return bytesToUint32Flipped(_blockHeader, 0x48);\r\n    }\r\n\r\n\r\n    // @dev - converts raw bytes representation of a Syscoin block header to struct representation\r\n    //\r\n    // @param _rawBytes - first 80 bytes of a block header\r\n    // @return - exact same header information in BlockHeader struct form\r\n    function parseHeaderBytes(bytes memory _rawBytes, uint pos) internal view returns (BlockHeader bh) {\r\n        bh.bits = getBits(_rawBytes);\r\n        bh.blockHash = dblShaFlipMem(_rawBytes, pos, 80);\r\n    }\r\n\r\n    uint32 constant VERSION_AUXPOW = (1 << 8);\r\n\r\n    // @dev - Converts a bytes of size 4 to uint32,\r\n    // e.g. for input [0x01, 0x02, 0x03 0x04] returns 0x01020304\r\n    function bytesToUint32Flipped(bytes memory input, uint pos) internal pure returns (uint32 result) {\r\n        result = uint32(input[pos]) + uint32(input[pos + 1])*(2**8) + uint32(input[pos + 2])*(2**16) + uint32(input[pos + 3])*(2**24);\r\n    }\r\n    function bytesToUint64(bytes memory input, uint pos) internal pure returns (uint64 result) {\r\n        result = uint64(input[pos+7]) + uint64(input[pos + 6])*(2**8) + uint64(input[pos + 5])*(2**16) + uint64(input[pos + 4])*(2**24) + uint64(input[pos + 3])*(2**32) + uint64(input[pos + 2])*(2**40) + uint64(input[pos + 1])*(2**48) + uint64(input[pos])*(2**56);\r\n    }\r\n     function bytesToUint32(bytes memory input, uint pos) internal pure returns (uint32 result) {\r\n        result = uint32(input[pos+3]) + uint32(input[pos + 2])*(2**8) + uint32(input[pos + 1])*(2**16) + uint32(input[pos])*(2**24);\r\n    }  \r\n    // @dev - checks version to determine if a block has merge mining information\r\n    function isMergeMined(bytes memory _rawBytes, uint pos) internal pure returns (bool) {\r\n        return bytesToUint32Flipped(_rawBytes, pos) & VERSION_AUXPOW != 0;\r\n    }\r\n\r\n    // @dev - Verify block header\r\n    // @param _blockHeaderBytes - array of bytes with the block header\r\n    // @param _pos - starting position of the block header\r\n\t// @param _proposedBlockHash - proposed block hash computing from block header bytes\r\n    // @return - [ErrorCode, IsMergeMined]\r\n    function verifyBlockHeader(bytes _blockHeaderBytes, uint _pos, uint _proposedBlockHash) external view returns (uint, bool) {\r\n        BlockHeader memory blockHeader = parseHeaderBytes(_blockHeaderBytes, _pos);\r\n        uint blockSha256Hash = blockHeader.blockHash;\r\n\t\t// must confirm that the header hash passed in and computing hash matches\r\n\t\tif(blockSha256Hash != _proposedBlockHash){\r\n\t\t\treturn (ERR_INVALID_HEADER_HASH, true);\r\n\t\t}\r\n        uint target = targetFromBits(blockHeader.bits);\r\n        if (_blockHeaderBytes.length > 80 && isMergeMined(_blockHeaderBytes, 0)) {\r\n            AuxPoW memory ap = parseAuxPoW(_blockHeaderBytes, _pos);\r\n            if (ap.blockHash > target) {\r\n\r\n                return (ERR_PROOF_OF_WORK_AUXPOW, true);\r\n            }\r\n            uint auxPoWCode = checkAuxPoW(blockSha256Hash, ap);\r\n            if (auxPoWCode != 1) {\r\n                return (auxPoWCode, true);\r\n            }\r\n            return (0, true);\r\n        } else {\r\n            if (_proposedBlockHash > target) {\r\n                return (ERR_PROOF_OF_WORK, false);\r\n            }\r\n            return (0, false);\r\n        }\r\n    }\r\n\r\n    // For verifying Syscoin difficulty\r\n    int64 constant TARGET_TIMESPAN =  int64(21600); \r\n    int64 constant TARGET_TIMESPAN_DIV_4 = TARGET_TIMESPAN / int64(4);\r\n    int64 constant TARGET_TIMESPAN_MUL_4 = TARGET_TIMESPAN * int64(4);\r\n    int64 constant TARGET_TIMESPAN_ADJUSTMENT =  int64(360);  // 6 hour\r\n    uint constant INITIAL_CHAIN_WORK =  0x100001; \r\n    uint constant POW_LIMIT = 0x00000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    // @dev - Calculate difficulty from compact representation (bits) found in block\r\n    function diffFromBits(uint32 bits) external pure returns (uint) {\r\n        return targetToDiff(targetFromBits(bits))*INITIAL_CHAIN_WORK;\r\n    }\r\n    \r\n    function difficultyAdjustmentInterval() external pure returns (int64) {\r\n        return TARGET_TIMESPAN_ADJUSTMENT;\r\n    }\r\n    // @param _actualTimespan - time elapsed from previous block creation til current block creation;\r\n    // i.e., how much time it took to mine the current block\r\n    // @param _bits - previous block header difficulty (in bits)\r\n    // @return - expected difficulty for the next block\r\n    function calculateDifficulty(int64 _actualTimespan, uint32 _bits) external pure returns (uint32 result) {\r\n       int64 actualTimespan = _actualTimespan;\r\n        // Limit adjustment step\r\n        if (_actualTimespan < TARGET_TIMESPAN_DIV_4) {\r\n            actualTimespan = TARGET_TIMESPAN_DIV_4;\r\n        } else if (_actualTimespan > TARGET_TIMESPAN_MUL_4) {\r\n            actualTimespan = TARGET_TIMESPAN_MUL_4;\r\n        }\r\n\r\n        // Retarget\r\n        uint bnNew = targetFromBits(_bits);\r\n        bnNew = bnNew * uint(actualTimespan);\r\n        bnNew = uint(bnNew) / uint(TARGET_TIMESPAN);\r\n\r\n        if (bnNew > POW_LIMIT) {\r\n            bnNew = POW_LIMIT;\r\n        }\r\n\r\n        return toCompactBits(bnNew);\r\n    }\r\n\r\n    // @dev - shift information to the right by a specified number of bits\r\n    //\r\n    // @param _val - value to be shifted\r\n    // @param _shift - number of bits to shift\r\n    // @return - `_val` shifted `_shift` bits to the right, i.e. divided by 2**`_shift`\r\n    function shiftRight(uint _val, uint _shift) private pure returns (uint) {\r\n        return _val / uint(2)**_shift;\r\n    }\r\n\r\n    // @dev - shift information to the left by a specified number of bits\r\n    //\r\n    // @param _val - value to be shifted\r\n    // @param _shift - number of bits to shift\r\n    // @return - `_val` shifted `_shift` bits to the left, i.e. multiplied by 2**`_shift`\r\n    function shiftLeft(uint _val, uint _shift) private pure returns (uint) {\r\n        return _val * uint(2)**_shift;\r\n    }\r\n\r\n    // @dev - get the number of bits required to represent a given integer value without losing information\r\n    //\r\n    // @param _val - unsigned integer value\r\n    // @return - given value's bit length\r\n    function bitLen(uint _val) private pure returns (uint length) {\r\n        uint int_type = _val;\r\n        while (int_type > 0) {\r\n            int_type = shiftRight(int_type, 1);\r\n            length += 1;\r\n        }\r\n    }\r\n\r\n    // @dev - Convert uint256 to compact encoding\r\n    // based on https://github.com/petertodd/python-bitcoinlib/blob/2a5dda45b557515fb12a0a18e5dd48d2f5cd13c2/bitcoin/core/serialize.py\r\n    // Analogous to arith_uint256::GetCompact from C++ implementation\r\n    //\r\n    // @param _val - difficulty in target format\r\n    // @return - difficulty in bits format\r\n    function toCompactBits(uint _val) private pure returns (uint32) {\r\n        uint nbytes = uint (shiftRight((bitLen(_val) + 7), 3));\r\n        uint32 compact = 0;\r\n        if (nbytes <= 3) {\r\n            compact = uint32 (shiftLeft((_val & 0xFFFFFF), 8 * (3 - nbytes)));\r\n        } else {\r\n            compact = uint32 (shiftRight(_val, 8 * (nbytes - 3)));\r\n            compact = uint32 (compact & 0xFFFFFF);\r\n        }\r\n\r\n        // If the sign bit (0x00800000) is set, divide the mantissa by 256 and\r\n        // increase the exponent to get an encoding without it set.\r\n        if ((compact & 0x00800000) > 0) {\r\n            compact = uint32(shiftRight(compact, 8));\r\n            nbytes += 1;\r\n        }\r\n\r\n        return compact | uint32(shiftLeft(nbytes, 24));\r\n    }\r\n}\r\n\r\n// @dev - SyscoinSuperblocks error codes\r\ncontract SyscoinErrorCodes {\r\n    // Error codes\r\n    uint constant ERR_SUPERBLOCK_OK = 0;\r\n    uint constant ERR_SUPERBLOCK_BAD_STATUS = 50020;\r\n    uint constant ERR_SUPERBLOCK_BAD_SYSCOIN_STATUS = 50025;\r\n    uint constant ERR_SUPERBLOCK_NO_TIMEOUT = 50030;\r\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP = 50035;\r\n    uint constant ERR_SUPERBLOCK_INVALID_MERKLE = 50040;\r\n    uint constant ERR_SUPERBLOCK_BAD_PARENT = 50050;\r\n    uint constant ERR_SUPERBLOCK_OWN_CHALLENGE = 50055;\r\n\r\n    uint constant ERR_SUPERBLOCK_MIN_DEPOSIT = 50060;\r\n\r\n    uint constant ERR_SUPERBLOCK_NOT_CLAIMMANAGER = 50070;\r\n\r\n    uint constant ERR_SUPERBLOCK_BAD_CLAIM = 50080;\r\n    uint constant ERR_SUPERBLOCK_VERIFICATION_PENDING = 50090;\r\n    uint constant ERR_SUPERBLOCK_CLAIM_DECIDED = 50100;\r\n    uint constant ERR_SUPERBLOCK_BAD_CHALLENGER = 50110;\r\n\r\n    uint constant ERR_SUPERBLOCK_BAD_ACCUMULATED_WORK = 50120;\r\n    uint constant ERR_SUPERBLOCK_BAD_BITS = 50130;\r\n    uint constant ERR_SUPERBLOCK_MISSING_CONFIRMATIONS = 50140;\r\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK = 50150;\r\n    uint constant ERR_SUPERBLOCK_BAD_BLOCKHEIGHT = 50160;\r\n\r\n    // error codes for verifyTx\r\n    uint constant ERR_BAD_FEE = 20010;\r\n    uint constant ERR_CONFIRMATIONS = 20020;\r\n    uint constant ERR_CHAIN = 20030;\r\n    uint constant ERR_SUPERBLOCK = 20040;\r\n    uint constant ERR_MERKLE_ROOT = 20050;\r\n    uint constant ERR_TX_64BYTE = 20060;\r\n    // error codes for relayTx\r\n    uint constant ERR_RELAY_VERIFY = 30010;\r\n\r\n    // Minimum gas requirements\r\n    uint constant public minReward = 1000000000000000000;\r\n    uint constant public superblockCost = 440000;\r\n    uint constant public challengeCost = 34000;\r\n    uint constant public minProposalDeposit = challengeCost + minReward;\r\n    uint constant public minChallengeDeposit = superblockCost + minReward;\r\n    uint constant public respondMerkleRootHashesCost = 378000; // TODO: measure this with 60 hashes\r\n    uint constant public respondBlockHeaderCost = 40000;\r\n    uint constant public verifySuperblockCost = 220000;\r\n}\r\n\r\n// @dev - Manages superblocks\r\n//\r\n// Management of superblocks and status transitions\r\ncontract SyscoinSuperblocks is SyscoinErrorCodes {\r\n\r\n    // @dev - Superblock status\r\n    enum Status { Unitialized, New, InBattle, SemiApproved, Approved, Invalid }\r\n\r\n    struct SuperblockInfo {\r\n        bytes32 blocksMerkleRoot;\r\n        uint accumulatedWork;\r\n        uint timestamp;\r\n        uint prevTimestamp;\r\n        bytes32 lastHash;\r\n        bytes32 parentId;\r\n        address submitter;\r\n        bytes32 ancestors;\r\n        uint32 lastBits;\r\n        uint32 index;\r\n        uint32 height;\r\n        uint32 blockHeight;\r\n        Status status;\r\n    }\r\n\r\n    // Mapping superblock id => superblock data\r\n    mapping (bytes32 => SuperblockInfo) superblocks;\r\n\r\n    // Index to superblock id\r\n    mapping (uint32 => bytes32) private indexSuperblock;\r\n\r\n    struct ProcessTransactionParams {\r\n        uint value;\r\n        address destinationAddress;\r\n        uint32 assetGUID;\r\n        address superblockSubmitterAddress;\r\n        SyscoinTransactionProcessor untrustedTargetContract;\r\n    }\r\n\r\n    mapping (uint => ProcessTransactionParams) private txParams;\r\n\r\n    uint32 indexNextSuperblock;\r\n\r\n    bytes32 public bestSuperblock;\r\n    uint public bestSuperblockAccumulatedWork;\r\n\r\n    event NewSuperblock(bytes32 superblockHash, address who);\r\n    event ApprovedSuperblock(bytes32 superblockHash, address who);\r\n    event ChallengeSuperblock(bytes32 superblockHash, address who);\r\n    event SemiApprovedSuperblock(bytes32 superblockHash, address who);\r\n    event InvalidSuperblock(bytes32 superblockHash, address who);\r\n\r\n    event ErrorSuperblock(bytes32 superblockHash, uint err);\r\n\r\n    event VerifyTransaction(bytes32 txHash, uint returnCode);\r\n    event RelayTransaction(bytes32 txHash, uint returnCode);\r\n\r\n    // SyscoinClaimManager\r\n    address public trustedClaimManager;\r\n\r\n    modifier onlyClaimManager() {\r\n        require(msg.sender == trustedClaimManager);\r\n        _;\r\n    }\r\n\r\n    // @dev – the constructor\r\n    constructor() public {}\r\n\r\n    // @dev - sets ClaimManager instance associated with managing superblocks.\r\n    // Once trustedClaimManager has been set, it cannot be changed.\r\n    // @param _claimManager - address of the ClaimManager contract to be associated with\r\n    function setClaimManager(address _claimManager) public {\r\n        require(address(trustedClaimManager) == 0x0 && _claimManager != 0x0);\r\n        trustedClaimManager = _claimManager;\r\n    }\r\n\r\n    // @dev - Initializes superblocks contract\r\n    //\r\n    // Initializes the superblock contract. It can only be called once.\r\n    //\r\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\r\n    // @param _accumulatedWork Accumulated proof of work of the last block in the superblock\r\n    // @param _timestamp Timestamp of the last block in the superblock\r\n    // @param _prevTimestamp Timestamp of the block when the last difficulty adjustment happened (every 360 blocks)\r\n    // @param _lastHash Hash of the last block in the superblock\r\n    // @param _lastBits Difficulty bits of the last block in the superblock\r\n    // @param _parentId Id of the parent superblock\r\n    // @param _blockHeight Block height of last block in superblock   \r\n    // @return Error code and superblockHash\r\n    function initialize(\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentId,\r\n        uint32 _blockHeight\r\n    ) public returns (uint, bytes32) {\r\n        require(bestSuperblock == 0);\r\n        require(_parentId == 0);\r\n\r\n        bytes32 superblockHash = calcSuperblockHash(_blocksMerkleRoot, _accumulatedWork, _timestamp, _prevTimestamp, _lastHash, _lastBits, _parentId, _blockHeight);\r\n        SuperblockInfo storage superblock = superblocks[superblockHash];\r\n\r\n        require(superblock.status == Status.Unitialized);\r\n\r\n        indexSuperblock[indexNextSuperblock] = superblockHash;\r\n\r\n        superblock.blocksMerkleRoot = _blocksMerkleRoot;\r\n        superblock.accumulatedWork = _accumulatedWork;\r\n        superblock.timestamp = _timestamp;\r\n        superblock.prevTimestamp = _prevTimestamp;\r\n        superblock.lastHash = _lastHash;\r\n        superblock.parentId = _parentId;\r\n        superblock.submitter = msg.sender;\r\n        superblock.index = indexNextSuperblock;\r\n        superblock.height = 1;\r\n        superblock.lastBits = _lastBits;\r\n        superblock.status = Status.Approved;\r\n        superblock.ancestors = 0x0;\r\n        superblock.blockHeight = _blockHeight;\r\n        indexNextSuperblock++;\r\n\r\n        emit NewSuperblock(superblockHash, msg.sender);\r\n\r\n        bestSuperblock = superblockHash;\r\n        bestSuperblockAccumulatedWork = _accumulatedWork;\r\n\r\n        emit ApprovedSuperblock(superblockHash, msg.sender);\r\n\r\n        return (ERR_SUPERBLOCK_OK, superblockHash);\r\n    }\r\n\r\n    // @dev - Proposes a new superblock\r\n    //\r\n    // To be accepted, a new superblock needs to have its parent\r\n    // either approved or semi-approved.\r\n    //\r\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\r\n    // @param _accumulatedWork Accumulated proof of work of the last block in the superblock\r\n    // @param _timestamp Timestamp of the last block in the superblock\r\n    // @param _prevTimestamp Timestamp of the block when the last difficulty adjustment happened (every 360 blocks)\r\n    // @param _lastHash Hash of the last block in the superblock\r\n    // @param _lastBits Difficulty bits of the last block in the superblock\r\n    // @param _parentId Id of the parent superblock\r\n    // @param _blockHeight Block height of last block in superblock\r\n    // @return Error code and superblockHash\r\n    function propose(\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentId,\r\n        uint32 _blockHeight,\r\n        address submitter\r\n    ) public returns (uint, bytes32) {\r\n        if (msg.sender != trustedClaimManager) {\r\n            emit ErrorSuperblock(0, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\r\n            return (ERR_SUPERBLOCK_NOT_CLAIMMANAGER, 0);\r\n        }\r\n\r\n        SuperblockInfo storage parent = superblocks[_parentId];\r\n        if (parent.status != Status.SemiApproved && parent.status != Status.Approved) {\r\n            emit ErrorSuperblock(superblockHash, ERR_SUPERBLOCK_BAD_PARENT);\r\n            return (ERR_SUPERBLOCK_BAD_PARENT, 0);\r\n        }\r\n\r\n        bytes32 superblockHash = calcSuperblockHash(_blocksMerkleRoot, _accumulatedWork, _timestamp, _prevTimestamp, _lastHash, _lastBits, _parentId, _blockHeight);\r\n        SuperblockInfo storage superblock = superblocks[superblockHash];\r\n        if (superblock.status == Status.Unitialized) {\r\n            indexSuperblock[indexNextSuperblock] = superblockHash;\r\n            superblock.blocksMerkleRoot = _blocksMerkleRoot;\r\n            superblock.accumulatedWork = _accumulatedWork;\r\n            superblock.timestamp = _timestamp;\r\n            superblock.prevTimestamp = _prevTimestamp;\r\n            superblock.lastHash = _lastHash;\r\n            superblock.parentId = _parentId;\r\n            superblock.submitter = submitter;\r\n            superblock.index = indexNextSuperblock;\r\n            superblock.height = parent.height + 1;\r\n            superblock.lastBits = _lastBits;\r\n            superblock.status = Status.New;\r\n            superblock.blockHeight = _blockHeight;\r\n            superblock.ancestors = updateAncestors(parent.ancestors, parent.index, parent.height);\r\n            indexNextSuperblock++;\r\n            emit NewSuperblock(superblockHash, submitter);\r\n        }\r\n        \r\n\r\n        return (ERR_SUPERBLOCK_OK, superblockHash);\r\n    }\r\n\r\n    // @dev - Confirm a proposed superblock\r\n    //\r\n    // An unchallenged superblock can be confirmed after a timeout.\r\n    // A challenged superblock is confirmed if it has enough descendants\r\n    // in the main chain.\r\n    //\r\n    // @param _superblockHash Id of the superblock to confirm\r\n    // @param _validator Address requesting superblock confirmation\r\n    // @return Error code and superblockHash\r\n    function confirm(bytes32 _superblockHash, address _validator) public returns (uint, bytes32) {\r\n        if (msg.sender != trustedClaimManager) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\r\n            return (ERR_SUPERBLOCK_NOT_CLAIMMANAGER, 0);\r\n        }\r\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\r\n        if (superblock.status != Status.New && superblock.status != Status.SemiApproved) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\r\n        }\r\n        SuperblockInfo storage parent = superblocks[superblock.parentId];\r\n        if (parent.status != Status.Approved) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_PARENT);\r\n            return (ERR_SUPERBLOCK_BAD_PARENT, 0);\r\n        }\r\n        superblock.status = Status.Approved;\r\n        if (superblock.accumulatedWork > bestSuperblockAccumulatedWork) {\r\n            bestSuperblock = _superblockHash;\r\n            bestSuperblockAccumulatedWork = superblock.accumulatedWork;\r\n        }\r\n        emit ApprovedSuperblock(_superblockHash, _validator);\r\n        return (ERR_SUPERBLOCK_OK, _superblockHash);\r\n    }\r\n\r\n    // @dev - Challenge a proposed superblock\r\n    //\r\n    // A new superblock can be challenged to start a battle\r\n    // to verify the correctness of the data submitted.\r\n    //\r\n    // @param _superblockHash Id of the superblock to challenge\r\n    // @param _challenger Address requesting a challenge\r\n    // @return Error code and superblockHash\r\n    function challenge(bytes32 _superblockHash, address _challenger) public returns (uint, bytes32) {\r\n        if (msg.sender != trustedClaimManager) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\r\n            return (ERR_SUPERBLOCK_NOT_CLAIMMANAGER, 0);\r\n        }\r\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\r\n        if (superblock.status != Status.New && superblock.status != Status.InBattle) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\r\n        }\r\n        if(superblock.submitter == _challenger){\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_OWN_CHALLENGE);\r\n            return (ERR_SUPERBLOCK_OWN_CHALLENGE, 0);        \r\n        }\r\n        superblock.status = Status.InBattle;\r\n        emit ChallengeSuperblock(_superblockHash, _challenger);\r\n        return (ERR_SUPERBLOCK_OK, _superblockHash);\r\n    }\r\n\r\n    // @dev - Semi-approve a challenged superblock\r\n    //\r\n    // A challenged superblock can be marked as semi-approved\r\n    // if it satisfies all the queries or when all challengers have\r\n    // stopped participating.\r\n    //\r\n    // @param _superblockHash Id of the superblock to semi-approve\r\n    // @param _validator Address requesting semi approval\r\n    // @return Error code and superblockHash\r\n    function semiApprove(bytes32 _superblockHash, address _validator) public returns (uint, bytes32) {\r\n        if (msg.sender != trustedClaimManager) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\r\n            return (ERR_SUPERBLOCK_NOT_CLAIMMANAGER, 0);\r\n        }\r\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\r\n\r\n        if (superblock.status != Status.InBattle && superblock.status != Status.New) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\r\n        }\r\n        superblock.status = Status.SemiApproved;\r\n        emit SemiApprovedSuperblock(_superblockHash, _validator);\r\n        return (ERR_SUPERBLOCK_OK, _superblockHash);\r\n    }\r\n\r\n    // @dev - Invalidates a superblock\r\n    //\r\n    // A superblock with incorrect data can be invalidated immediately.\r\n    // Superblocks that are not in the main chain can be invalidated\r\n    // if not enough superblocks follow them, i.e. they don't have\r\n    // enough descendants.\r\n    //\r\n    // @param _superblockHash Id of the superblock to invalidate\r\n    // @param _validator Address requesting superblock invalidation\r\n    // @return Error code and superblockHash\r\n    function invalidate(bytes32 _superblockHash, address _validator) public returns (uint, bytes32) {\r\n        if (msg.sender != trustedClaimManager) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_NOT_CLAIMMANAGER);\r\n            return (ERR_SUPERBLOCK_NOT_CLAIMMANAGER, 0);\r\n        }\r\n        SuperblockInfo storage superblock = superblocks[_superblockHash];\r\n        if (superblock.status != Status.InBattle && superblock.status != Status.SemiApproved) {\r\n            emit ErrorSuperblock(_superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\r\n        }\r\n        superblock.status = Status.Invalid;\r\n        emit InvalidSuperblock(_superblockHash, _validator);\r\n        return (ERR_SUPERBLOCK_OK, _superblockHash);\r\n    }\r\n\r\n    // @dev - relays transaction `_txBytes` to `_untrustedTargetContract`'s processTransaction() method.\r\n    // Also logs the value of processTransaction.\r\n    // Note: callers cannot be 100% certain when an ERR_RELAY_VERIFY occurs because\r\n    // it may also have been returned by processTransaction(). Callers should be\r\n    // aware of the contract that they are relaying transactions to and\r\n    // understand what that contract's processTransaction method returns.\r\n    //\r\n    // @param _txBytes - transaction bytes\r\n    // @param _txIndex - transaction's index within the block\r\n    // @param _txSiblings - transaction's Merkle siblings\r\n    // @param _syscoinBlockHeader - block header containing transaction\r\n    // @param _syscoinBlockIndex - block's index withing superblock\r\n    // @param _syscoinBlockSiblings - block's merkle siblings\r\n    // @param _superblockHash - superblock containing block header\r\n    // @param _untrustedTargetContract - the contract that is going to process the transaction\r\n    function relayTx(\r\n        bytes memory _txBytes,\r\n        uint _txIndex,\r\n        uint[] _txSiblings,\r\n        bytes memory _syscoinBlockHeader,\r\n        uint _syscoinBlockIndex,\r\n        uint[] memory _syscoinBlockSiblings,\r\n        bytes32 _superblockHash,\r\n        SyscoinTransactionProcessor _untrustedTargetContract\r\n    ) public returns (uint) {\r\n\r\n        // Check if Syscoin block belongs to given superblock\r\n        if (bytes32(SyscoinMessageLibrary.computeMerkle(SyscoinMessageLibrary.dblShaFlip(_syscoinBlockHeader), _syscoinBlockIndex, _syscoinBlockSiblings))\r\n            != getSuperblockMerkleRoot(_superblockHash)) {\r\n            // Syscoin block is not in superblock\r\n            emit RelayTransaction(bytes32(0), ERR_SUPERBLOCK);\r\n            return ERR_SUPERBLOCK;\r\n        }\r\n        uint txHash = verifyTx(_txBytes, _txIndex, _txSiblings, _syscoinBlockHeader, _superblockHash);\r\n        if (txHash != 0) {\r\n            uint ret = parseTxHelper(_txBytes, txHash, _untrustedTargetContract);\r\n            if(ret != 0){\r\n                emit RelayTransaction(bytes32(0), ret);\r\n                return ret;\r\n            }\r\n            ProcessTransactionParams memory params = txParams[txHash];\r\n            params.superblockSubmitterAddress = superblocks[_superblockHash].submitter;\r\n            txParams[txHash] = params;\r\n            return verifyTxHelper(txHash);\r\n        }\r\n        emit RelayTransaction(bytes32(0), ERR_RELAY_VERIFY);\r\n        return(ERR_RELAY_VERIFY);        \r\n    }\r\n    function parseTxHelper(bytes memory _txBytes, uint txHash, SyscoinTransactionProcessor _untrustedTargetContract) private returns (uint) {\r\n        uint value;\r\n        address destinationAddress;\r\n        uint32 _assetGUID;\r\n        uint ret;\r\n        (ret, value, destinationAddress, _assetGUID) = SyscoinMessageLibrary.parseTransaction(_txBytes);\r\n        if(ret != 0){\r\n            return ret;\r\n        }\r\n\r\n        ProcessTransactionParams memory params;\r\n        params.value = value;\r\n        params.destinationAddress = destinationAddress;\r\n        params.assetGUID = _assetGUID;\r\n        params.untrustedTargetContract = _untrustedTargetContract;\r\n        txParams[txHash] = params;        \r\n        return 0;\r\n    }\r\n    function verifyTxHelper(uint txHash) private returns (uint) {\r\n        ProcessTransactionParams memory params = txParams[txHash];        \r\n        uint returnCode = params.untrustedTargetContract.processTransaction(txHash, params.value, params.destinationAddress, params.assetGUID, params.superblockSubmitterAddress);\r\n        emit RelayTransaction(bytes32(txHash), returnCode);\r\n        return (returnCode);\r\n    }\r\n    // @dev - Checks whether the transaction given by `_txBytes` is in the block identified by `_txBlockHeaderBytes`.\r\n    // First it guards against a Merkle tree collision attack by raising an error if the transaction is exactly 64 bytes long,\r\n    // then it calls helperVerifyHash to do the actual check.\r\n    //\r\n    // @param _txBytes - transaction bytes\r\n    // @param _txIndex - transaction's index within the block\r\n    // @param _siblings - transaction's Merkle siblings\r\n    // @param _txBlockHeaderBytes - block header containing transaction\r\n    // @param _txsuperblockHash - superblock containing block header\r\n    // @return - SHA-256 hash of _txBytes if the transaction is in the block, 0 otherwise\r\n    // TODO: this can probably be made private\r\n    function verifyTx(\r\n        bytes memory _txBytes,\r\n        uint _txIndex,\r\n        uint[] memory _siblings,\r\n        bytes memory _txBlockHeaderBytes,\r\n        bytes32 _txsuperblockHash\r\n    ) public returns (uint) {\r\n        uint txHash = SyscoinMessageLibrary.dblShaFlip(_txBytes);\r\n\r\n        if (_txBytes.length == 64) {  // todo: is check 32 also needed?\r\n            emit VerifyTransaction(bytes32(txHash), ERR_TX_64BYTE);\r\n            return 0;\r\n        }\r\n\r\n        if (helperVerifyHash(txHash, _txIndex, _siblings, _txBlockHeaderBytes, _txsuperblockHash) == 1) {\r\n            return txHash;\r\n        } else {\r\n            // log is done via helperVerifyHash\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // @dev - Checks whether the transaction identified by `_txHash` is in the block identified by `_blockHeaderBytes`\r\n    // and whether the block is in the Syscoin main chain. Transaction check is done via Merkle proof.\r\n    // Note: no verification is performed to prevent txHash from just being an\r\n    // internal hash in the Merkle tree. Thus this helper method should NOT be used\r\n    // directly and is intended to be private.\r\n    //\r\n    // @param _txHash - transaction hash\r\n    // @param _txIndex - transaction's index within the block\r\n    // @param _siblings - transaction's Merkle siblings\r\n    // @param _blockHeaderBytes - block header containing transaction\r\n    // @param _txsuperblockHash - superblock containing block header\r\n    // @return - 1 if the transaction is in the block and the block is in the main chain,\r\n    // 20020 (ERR_CONFIRMATIONS) if the block is not in the main chain,\r\n    // 20050 (ERR_MERKLE_ROOT) if the block is in the main chain but the Merkle proof fails.\r\n    function helperVerifyHash(\r\n        uint256 _txHash,\r\n        uint _txIndex,\r\n        uint[] memory _siblings,\r\n        bytes memory _blockHeaderBytes,\r\n        bytes32 _txsuperblockHash\r\n    ) private returns (uint) {\r\n\r\n        //TODO: Verify superblock is in superblock's main chain\r\n        if (!isApproved(_txsuperblockHash) || !inMainChain(_txsuperblockHash)) {\r\n            emit VerifyTransaction(bytes32(_txHash), ERR_CHAIN);\r\n            return (ERR_CHAIN);\r\n        }\r\n\r\n        // Verify tx Merkle root\r\n        uint merkle = SyscoinMessageLibrary.getHeaderMerkleRoot(_blockHeaderBytes);\r\n        if (SyscoinMessageLibrary.computeMerkle(_txHash, _txIndex, _siblings) != merkle) {\r\n            emit VerifyTransaction(bytes32(_txHash), ERR_MERKLE_ROOT);\r\n            return (ERR_MERKLE_ROOT);\r\n        }\r\n\r\n        emit VerifyTransaction(bytes32(_txHash), 1);\r\n        return (1);\r\n    }\r\n\r\n    // @dev - Calculate superblock hash from superblock data\r\n    //\r\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\r\n    // @param _accumulatedWork Accumulated proof of work of the last block in the superblock\r\n    // @param _timestamp Timestamp of the last block in the superblock\r\n    // @param _prevTimestamp Timestamp of the block when the last difficulty adjustment happened (every 360 blocks)\r\n    // @param _lastHash Hash of the last block in the superblock\r\n    // @param _lastBits Difficulty bits of the last block in the superblock\r\n    // @param _parentId Id of the parent superblock\r\n    // @param _blockHeight Block height of last block in superblock   \r\n    // @return Superblock id\r\n    function calcSuperblockHash(\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentId,\r\n        uint32 _blockHeight\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            _blocksMerkleRoot,\r\n            _accumulatedWork,\r\n            _timestamp,\r\n            _prevTimestamp,\r\n            _lastHash,\r\n            _lastBits,\r\n            _parentId,\r\n            _blockHeight\r\n        ));\r\n    }\r\n\r\n    // @dev - Returns the confirmed superblock with the most accumulated work\r\n    //\r\n    // @return Best superblock hash\r\n    function getBestSuperblock() public view returns (bytes32) {\r\n        return bestSuperblock;\r\n    }\r\n\r\n    // @dev - Returns the superblock data for the supplied superblock hash\r\n    //\r\n    // @return {\r\n    //   bytes32 _blocksMerkleRoot,\r\n    //   uint _accumulatedWork,\r\n    //   uint _timestamp,\r\n    //   uint _prevTimestamp,\r\n    //   bytes32 _lastHash,\r\n    //   uint32 _lastBits,\r\n    //   bytes32 _parentId,\r\n    //   address _submitter,\r\n    //   Status _status,\r\n    //   uint32 _blockHeight,\r\n    // }  Superblock data\r\n    function getSuperblock(bytes32 superblockHash) public view returns (\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentId,\r\n        address _submitter,\r\n        Status _status,\r\n        uint32 _blockHeight\r\n    ) {\r\n        SuperblockInfo storage superblock = superblocks[superblockHash];\r\n        return (\r\n            superblock.blocksMerkleRoot,\r\n            superblock.accumulatedWork,\r\n            superblock.timestamp,\r\n            superblock.prevTimestamp,\r\n            superblock.lastHash,\r\n            superblock.lastBits,\r\n            superblock.parentId,\r\n            superblock.submitter,\r\n            superblock.status,\r\n            superblock.blockHeight\r\n        );\r\n    }\r\n\r\n    // @dev - Returns superblock height\r\n    function getSuperblockHeight(bytes32 superblockHash) public view returns (uint32) {\r\n        return superblocks[superblockHash].height;\r\n    }\r\n\r\n    // @dev - Returns superblock internal index\r\n    function getSuperblockIndex(bytes32 superblockHash) public view returns (uint32) {\r\n        return superblocks[superblockHash].index;\r\n    }\r\n\r\n    // @dev - Return superblock ancestors' indexes\r\n    function getSuperblockAncestors(bytes32 superblockHash) public view returns (bytes32) {\r\n        return superblocks[superblockHash].ancestors;\r\n    }\r\n\r\n    // @dev - Return superblock blocks' Merkle root\r\n    function getSuperblockMerkleRoot(bytes32 _superblockHash) public view returns (bytes32) {\r\n        return superblocks[_superblockHash].blocksMerkleRoot;\r\n    }\r\n\r\n    // @dev - Return superblock timestamp\r\n    function getSuperblockTimestamp(bytes32 _superblockHash) public view returns (uint) {\r\n        return superblocks[_superblockHash].timestamp;\r\n    }\r\n\r\n    // @dev - Return superblock prevTimestamp\r\n    function getSuperblockPrevTimestamp(bytes32 _superblockHash) public view returns (uint) {\r\n        return superblocks[_superblockHash].prevTimestamp;\r\n    }\r\n\r\n    // @dev - Return superblock last block hash\r\n    function getSuperblockLastHash(bytes32 _superblockHash) public view returns (bytes32) {\r\n        return superblocks[_superblockHash].lastHash;\r\n    }\r\n\r\n    // @dev - Return superblock parent\r\n    function getSuperblockParentId(bytes32 _superblockHash) public view returns (bytes32) {\r\n        return superblocks[_superblockHash].parentId;\r\n    }\r\n\r\n    // @dev - Return superblock accumulated work\r\n    function getSuperblockAccumulatedWork(bytes32 _superblockHash) public view returns (uint) {\r\n        return superblocks[_superblockHash].accumulatedWork;\r\n    }\r\n\r\n    // @dev - Return superblock status\r\n    function getSuperblockStatus(bytes32 _superblockHash) public view returns (Status) {\r\n        return superblocks[_superblockHash].status;\r\n    }\r\n\r\n    // @dev - Return indexNextSuperblock\r\n    function getIndexNextSuperblock() public view returns (uint32) {\r\n        return indexNextSuperblock;\r\n    }\r\n\r\n    // @dev - Calculate Merkle root from Syscoin block hashes\r\n    function makeMerkle(bytes32[] hashes) public pure returns (bytes32) {\r\n        return SyscoinMessageLibrary.makeMerkle(hashes);\r\n    }\r\n\r\n    function isApproved(bytes32 _superblockHash) public view returns (bool) {\r\n        return (getSuperblockStatus(_superblockHash) == Status.Approved);\r\n    }\r\n\r\n    function getChainHeight() public view returns (uint) {\r\n        return superblocks[bestSuperblock].height;\r\n    }\r\n\r\n    // @dev - write `_fourBytes` into `_word` starting from `_position`\r\n    // This is useful for writing 32bit ints inside one 32 byte word\r\n    //\r\n    // @param _word - information to be partially overwritten\r\n    // @param _position - position to start writing from\r\n    // @param _eightBytes - information to be written\r\n    function writeUint32(bytes32 _word, uint _position, uint32 _fourBytes) private pure returns (bytes32) {\r\n        bytes32 result;\r\n        assembly {\r\n            let pointer := mload(0x40)\r\n            mstore(pointer, _word)\r\n            mstore8(add(pointer, _position), byte(28, _fourBytes))\r\n            mstore8(add(pointer, add(_position,1)), byte(29, _fourBytes))\r\n            mstore8(add(pointer, add(_position,2)), byte(30, _fourBytes))\r\n            mstore8(add(pointer, add(_position,3)), byte(31, _fourBytes))\r\n            result := mload(pointer)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    uint constant ANCESTOR_STEP = 5;\r\n    uint constant NUM_ANCESTOR_DEPTHS = 8;\r\n\r\n    // @dev - Update ancestor to the new height\r\n    function updateAncestors(bytes32 ancestors, uint32 index, uint height) internal pure returns (bytes32) {\r\n        uint step = ANCESTOR_STEP;\r\n        ancestors = writeUint32(ancestors, 0, index);\r\n        uint i = 1;\r\n        while (i<NUM_ANCESTOR_DEPTHS && (height % step == 1)) {\r\n            ancestors = writeUint32(ancestors, 4*i, index);\r\n            step *= ANCESTOR_STEP;\r\n            ++i;\r\n        }\r\n        return ancestors;\r\n    }\r\n\r\n    // @dev - Returns a list of superblock hashes (9 hashes maximum) that helps an agent find out what\r\n    // superblocks are missing.\r\n    // The first position contains bestSuperblock, then\r\n    // bestSuperblock - 1,\r\n    // (bestSuperblock-1) - ((bestSuperblock-1) % 5), then\r\n    // (bestSuperblock-1) - ((bestSuperblock-1) % 25), ... until\r\n    // (bestSuperblock-1) - ((bestSuperblock-1) % 78125)\r\n    //\r\n    // @return - list of up to 9 ancestor supeerblock id\r\n    function getSuperblockLocator() public view returns (bytes32[9]) {\r\n        bytes32[9] memory locator;\r\n        locator[0] = bestSuperblock;\r\n        bytes32 ancestors = getSuperblockAncestors(bestSuperblock);\r\n        uint i = NUM_ANCESTOR_DEPTHS;\r\n        while (i > 0) {\r\n            locator[i] = indexSuperblock[uint32(ancestors & 0xFFFFFFFF)];\r\n            ancestors >>= 32;\r\n            --i;\r\n        }\r\n        return locator;\r\n    }\r\n\r\n    // @dev - Return ancestor at given index\r\n    function getSuperblockAncestor(bytes32 superblockHash, uint index) internal view returns (bytes32) {\r\n        bytes32 ancestors = superblocks[superblockHash].ancestors;\r\n        uint32 ancestorsIndex =\r\n            uint32(ancestors[4*index + 0]) * 0x1000000 +\r\n            uint32(ancestors[4*index + 1]) * 0x10000 +\r\n            uint32(ancestors[4*index + 2]) * 0x100 +\r\n            uint32(ancestors[4*index + 3]) * 0x1;\r\n        return indexSuperblock[ancestorsIndex];\r\n    }\r\n\r\n    // dev - returns depth associated with an ancestor index; applies to any superblock\r\n    //\r\n    // @param _index - index of ancestor to be looked up; an integer between 0 and 7\r\n    // @return - depth corresponding to said index, i.e. 5**index\r\n    function getAncDepth(uint _index) private pure returns (uint) {\r\n        return ANCESTOR_STEP**(uint(_index));\r\n    }\r\n\r\n    // @dev - return superblock hash at a given height in superblock main chain\r\n    //\r\n    // @param _height - superblock height\r\n    // @return - hash corresponding to block of height _blockHeight\r\n    function getSuperblockAt(uint _height) public view returns (bytes32) {\r\n        bytes32 superblockHash = bestSuperblock;\r\n        uint index = NUM_ANCESTOR_DEPTHS - 1;\r\n\r\n        while (getSuperblockHeight(superblockHash) > _height) {\r\n            while (getSuperblockHeight(superblockHash) - _height < getAncDepth(index) && index > 0) {\r\n                index -= 1;\r\n            }\r\n            superblockHash = getSuperblockAncestor(superblockHash, index);\r\n        }\r\n\r\n        return superblockHash;\r\n    }\r\n\r\n    // @dev - Checks if a superblock is in superblock main chain\r\n    //\r\n    // @param _blockHash - hash of the block being searched for in the main chain\r\n    // @return - true if the block identified by _blockHash is in the main chain,\r\n    // false otherwise\r\n    function inMainChain(bytes32 _superblockHash) internal view returns (bool) {\r\n        uint height = getSuperblockHeight(_superblockHash);\r\n        if (height == 0) return false;\r\n        return (getSuperblockAt(height) == _superblockHash);\r\n    }\r\n}\r\n\r\n// @dev - Manager of superblock claims\r\n//\r\n// Manages superblocks proposal and challenges\r\ncontract SyscoinClaimManager is SyscoinDepositsManager, SyscoinErrorCodes {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct SuperblockClaim {\r\n        bytes32 superblockHash;                       // Superblock Id\r\n        address submitter;                           // Superblock submitter\r\n        uint createdAt;                             // Superblock creation time\r\n\r\n        address[] challengers;                      // List of challengers\r\n        mapping (address => uint) bondedDeposits;   // Deposit associated to challengers\r\n\r\n        uint currentChallenger;                     // Index of challenger in current session\r\n        mapping (address => bytes32) sessions;      // Challenge sessions\r\n\r\n        uint challengeTimeout;                      // Claim timeout\r\n\r\n        bool verificationOngoing;                   // Challenge session has started\r\n\r\n        bool decided;                               // If the claim was decided\r\n        bool invalid;                               // If superblock is invalid\r\n    }\r\n\r\n    // Active superblock claims\r\n    mapping (bytes32 => SuperblockClaim) public claims;\r\n\r\n    // Superblocks contract\r\n    SyscoinSuperblocks public trustedSuperblocks;\r\n\r\n    // Battle manager contract\r\n    SyscoinBattleManager public trustedSyscoinBattleManager;\r\n\r\n    // Confirmations required to confirm semi approved superblocks\r\n    uint public superblockConfirmations;\r\n\r\n    // Monetary reward for opponent in case battle is lost\r\n    uint public battleReward;\r\n\r\n    uint public superblockDelay;    // Delay required to submit superblocks (in seconds)\r\n    uint public superblockTimeout;  // Timeout for action (in seconds)\r\n\r\n    event DepositBonded(bytes32 superblockHash, address account, uint amount);\r\n    event DepositUnbonded(bytes32 superblockHash, address account, uint amount);\r\n    event SuperblockClaimCreated(bytes32 superblockHash, address submitter);\r\n    event SuperblockClaimChallenged(bytes32 superblockHash, address challenger);\r\n    event SuperblockBattleDecided(bytes32 sessionId, address winner, address loser);\r\n    event SuperblockClaimSuccessful(bytes32 superblockHash, address submitter);\r\n    event SuperblockClaimPending(bytes32 superblockHash, address submitter);\r\n    event SuperblockClaimFailed(bytes32 superblockHash, address submitter);\r\n    event VerificationGameStarted(bytes32 superblockHash, address submitter, address challenger, bytes32 sessionId);\r\n\r\n    event ErrorClaim(bytes32 superblockHash, uint err);\r\n\r\n    modifier onlyBattleManager() {\r\n        require(msg.sender == address(trustedSyscoinBattleManager));\r\n        _;\r\n    }\r\n\r\n    modifier onlyMeOrBattleManager() {\r\n        require(msg.sender == address(trustedSyscoinBattleManager) || msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    // @dev – Sets up the contract managing superblock challenges\r\n    // @param _superblocks Contract that manages superblocks\r\n    // @param _battleManager Contract that manages battles\r\n    // @param _superblockDelay Delay to accept a superblock submission (in seconds)\r\n    // @param _superblockTimeout Time to wait for challenges (in seconds)\r\n    // @param _superblockConfirmations Confirmations required to confirm semi approved superblocks\r\n    constructor(\r\n        SyscoinSuperblocks _superblocks,\r\n        SyscoinBattleManager _syscoinBattleManager,\r\n        uint _superblockDelay,\r\n        uint _superblockTimeout,\r\n        uint _superblockConfirmations,\r\n        uint _battleReward\r\n    ) public {\r\n        trustedSuperblocks = _superblocks;\r\n        trustedSyscoinBattleManager = _syscoinBattleManager;\r\n        superblockDelay = _superblockDelay;\r\n        superblockTimeout = _superblockTimeout;\r\n        superblockConfirmations = _superblockConfirmations;\r\n        battleReward = _battleReward;\r\n    }\r\n\r\n    // @dev – locks up part of a user's deposit into a claim.\r\n    // @param superblockHash – claim id.\r\n    // @param account – user's address.\r\n    // @param amount – amount of deposit to lock up.\r\n    // @return – user's deposit bonded for the claim.\r\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) onlyMeOrBattleManager external returns (uint, uint) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n\r\n        if (!claimExists(claim)) {\r\n            return (ERR_SUPERBLOCK_BAD_CLAIM, 0);\r\n        }\r\n\r\n        if (deposits[account] < amount) {\r\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, deposits[account]);\r\n        }\r\n\r\n        deposits[account] = deposits[account].sub(amount);\r\n        claim.bondedDeposits[account] = claim.bondedDeposits[account].add(amount);\r\n        emit DepositBonded(superblockHash, account, amount);\r\n\r\n        return (ERR_SUPERBLOCK_OK, claim.bondedDeposits[account]);\r\n    }\r\n\r\n    // @dev – accessor for a claim's bonded deposits.\r\n    // @param superblockHash – claim id.\r\n    // @param account – user's address.\r\n    // @return – user's deposit bonded for the claim.\r\n    function getBondedDeposit(bytes32 superblockHash, address account) public view returns (uint) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        require(claimExists(claim));\r\n        return claim.bondedDeposits[account];\r\n    }\r\n\r\n    function getDeposit(address account) public view returns (uint) {\r\n        return deposits[account];\r\n    }\r\n\r\n    // @dev – unlocks a user's bonded deposits from a claim.\r\n    // @param superblockHash – claim id.\r\n    // @param account – user's address.\r\n    // @return – user's deposit which was unbonded from the claim.\r\n    function unbondDeposit(bytes32 superblockHash, address account) internal returns (uint, uint) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        if (!claimExists(claim)) {\r\n            return (ERR_SUPERBLOCK_BAD_CLAIM, 0);\r\n        }\r\n        if (!claim.decided) {\r\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\r\n        }\r\n\r\n        uint bondedDeposit = claim.bondedDeposits[account];\r\n\r\n        delete claim.bondedDeposits[account];\r\n        deposits[account] = deposits[account].add(bondedDeposit);\r\n\r\n        emit DepositUnbonded(superblockHash, account, bondedDeposit);\r\n\r\n        return (ERR_SUPERBLOCK_OK, bondedDeposit);\r\n    }\r\n\r\n    // @dev – Propose a new superblock.\r\n    //\r\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\r\n    // @param _accumulatedWork Accumulated proof of work of the last block in the superblock\r\n    // @param _timestamp Timestamp of the last block in the superblock\r\n    // @param _prevTimestamp Timestamp of the block when the last difficulty adjustment happened\r\n    // @param _lastHash Hash of the last block in the superblock\r\n    // @param _lastBits Difficulty bits of the last block in the superblock\r\n    // @param _parentHash Id of the parent superblock\r\n    // @return Error code and superblockHash\r\n    function proposeSuperblock(\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentHash,\r\n        uint32 _blockHeight\r\n    ) public returns (uint, bytes32) {\r\n        require(address(trustedSuperblocks) != 0);\r\n\r\n        if (deposits[msg.sender] < minProposalDeposit) {\r\n            emit ErrorClaim(0, ERR_SUPERBLOCK_MIN_DEPOSIT);\r\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, 0);\r\n        }\r\n\r\n        if (_timestamp + superblockDelay > block.timestamp) {\r\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP);\r\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP, 0);\r\n        }\r\n\r\n        uint err;\r\n        bytes32 superblockHash;\r\n        (err, superblockHash) = trustedSuperblocks.propose(_blocksMerkleRoot, _accumulatedWork,\r\n            _timestamp, _prevTimestamp, _lastHash, _lastBits, _parentHash, _blockHeight,msg.sender);\r\n        if (err != 0) {\r\n            emit ErrorClaim(superblockHash, err);\r\n            return (err, superblockHash);\r\n        }\r\n\r\n\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        // allow to propose an existing claim only if its invalid and decided and its a different submitter or not on the tip\r\n        // those are the ones that may actually be stuck and need to be proposed again, \r\n        // but we want to ensure its not the same submitter submitting the same thing\r\n        if (claimExists(claim)) {\r\n            bool allowed = claim.invalid == true && claim.decided == true && claim.submitter != msg.sender;\r\n            if(allowed){\r\n                // we also want to ensure that if parent is approved we are building on the tip and not anywhere else\r\n                if(trustedSuperblocks.getSuperblockStatus(_parentHash) == SyscoinSuperblocks.Status.Approved){\r\n                    allowed = trustedSuperblocks.getBestSuperblock() == _parentHash;\r\n                }\r\n                // or if its semi approved allow to build on top as well\r\n                else if(trustedSuperblocks.getSuperblockStatus(_parentHash) == SyscoinSuperblocks.Status.SemiApproved){\r\n                    allowed = true;\r\n                }\r\n                else{\r\n                    allowed = false;\r\n                }\r\n            }\r\n            if(!allowed){\r\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\r\n                return (ERR_SUPERBLOCK_BAD_CLAIM, superblockHash);  \r\n            }\r\n        }\r\n\r\n\r\n        claim.superblockHash = superblockHash;\r\n        claim.submitter = msg.sender;\r\n        claim.currentChallenger = 0;\r\n        claim.decided = false;\r\n        claim.invalid = false;\r\n        claim.verificationOngoing = false;\r\n        claim.createdAt = block.timestamp;\r\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\r\n        claim.challengers.length = 0;\r\n\r\n        (err, ) = this.bondDeposit(superblockHash, msg.sender, battleReward);\r\n        assert(err == ERR_SUPERBLOCK_OK);\r\n\r\n        emit SuperblockClaimCreated(superblockHash, msg.sender);\r\n\r\n        return (ERR_SUPERBLOCK_OK, superblockHash);\r\n    }\r\n\r\n    // @dev – challenge a superblock claim.\r\n    // @param superblockHash – Id of the superblock to challenge.\r\n    // @return - Error code and claim Id\r\n    function challengeSuperblock(bytes32 superblockHash) public returns (uint, bytes32) {\r\n        require(address(trustedSuperblocks) != 0);\r\n\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n\r\n        if (!claimExists(claim)) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\r\n            return (ERR_SUPERBLOCK_BAD_CLAIM, superblockHash);\r\n        }\r\n        if (claim.decided) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\r\n            return (ERR_SUPERBLOCK_CLAIM_DECIDED, superblockHash);\r\n        }\r\n        if (deposits[msg.sender] < minChallengeDeposit) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MIN_DEPOSIT);\r\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, superblockHash);\r\n        }\r\n\r\n        uint err;\r\n        (err, ) = trustedSuperblocks.challenge(superblockHash, msg.sender);\r\n        if (err != 0) {\r\n            emit ErrorClaim(superblockHash, err);\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, ) = this.bondDeposit(superblockHash, msg.sender, battleReward);\r\n        assert(err == ERR_SUPERBLOCK_OK);\r\n\r\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\r\n        claim.challengers.push(msg.sender);\r\n        emit SuperblockClaimChallenged(superblockHash, msg.sender);\r\n\r\n        if (!claim.verificationOngoing) {\r\n            runNextBattleSession(superblockHash);\r\n        }\r\n\r\n        return (ERR_SUPERBLOCK_OK, superblockHash);\r\n    }\r\n\r\n    // @dev – runs a battle session to verify a superblock for the next challenger\r\n    // @param superblockHash – claim id.\r\n    function runNextBattleSession(bytes32 superblockHash) internal returns (bool) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n\r\n        if (!claimExists(claim)) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\r\n            return false;\r\n        }\r\n\r\n        // superblocks marked as invalid do not have to run remaining challengers\r\n        if (claim.decided || claim.invalid) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\r\n            return false;\r\n        }\r\n\r\n        if (claim.verificationOngoing) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_VERIFICATION_PENDING);\r\n            return false;\r\n        }\r\n\r\n        if (claim.currentChallenger < claim.challengers.length) {\r\n\r\n            bytes32 sessionId = trustedSyscoinBattleManager.beginBattleSession(superblockHash, claim.submitter,\r\n                claim.challengers[claim.currentChallenger]);\r\n\r\n            claim.sessions[claim.challengers[claim.currentChallenger]] = sessionId;\r\n            emit VerificationGameStarted(superblockHash, claim.submitter,\r\n                claim.challengers[claim.currentChallenger], sessionId);\r\n\r\n            claim.verificationOngoing = true;\r\n            claim.currentChallenger += 1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // @dev – check whether a claim has successfully withstood all challenges.\r\n    // If successful without challenges, it will mark the superblock as confirmed.\r\n    // If successful with at least one challenge, it will mark the superblock as semi-approved.\r\n    // If verification failed, it will mark the superblock as invalid.\r\n    //\r\n    // @param superblockHash – claim ID.\r\n    function checkClaimFinished(bytes32 superblockHash) public returns (bool) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n\r\n        if (!claimExists(claim)) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\r\n            return false;\r\n        }\r\n\r\n        // check that there is no ongoing verification game.\r\n        if (claim.verificationOngoing) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_VERIFICATION_PENDING);\r\n            return false;\r\n        }\r\n\r\n        // an invalid superblock can be rejected immediately\r\n        if (claim.invalid) {\r\n            // The superblock is invalid, submitter abandoned\r\n            // or superblock data is inconsistent\r\n            claim.decided = true;\r\n            trustedSuperblocks.invalidate(claim.superblockHash, msg.sender);\r\n            emit SuperblockClaimFailed(superblockHash, claim.submitter);\r\n            doPayChallengers(superblockHash, claim);\r\n            return false;\r\n        }\r\n\r\n        // check that the claim has exceeded the claim's specific challenge timeout.\r\n        if (block.timestamp <= claim.challengeTimeout) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_NO_TIMEOUT);\r\n            return false;\r\n        }\r\n\r\n        // check that all verification games have been played.\r\n        if (claim.currentChallenger < claim.challengers.length) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_VERIFICATION_PENDING);\r\n            return false;\r\n        }\r\n\r\n        claim.decided = true;\r\n\r\n        bool confirmImmediately = false;\r\n        // No challengers and parent approved; confirm immediately\r\n        if (claim.challengers.length == 0) {\r\n            bytes32 parentId = trustedSuperblocks.getSuperblockParentId(claim.superblockHash);\r\n            SyscoinSuperblocks.Status status = trustedSuperblocks.getSuperblockStatus(parentId);\r\n            if (status == SyscoinSuperblocks.Status.Approved) {\r\n                confirmImmediately = true;\r\n            }\r\n        }\r\n\r\n        if (confirmImmediately) {\r\n            trustedSuperblocks.confirm(claim.superblockHash, msg.sender);\r\n            unbondDeposit(superblockHash, claim.submitter);\r\n            emit SuperblockClaimSuccessful(superblockHash, claim.submitter);\r\n        } else {\r\n            trustedSuperblocks.semiApprove(claim.superblockHash, msg.sender);\r\n            emit SuperblockClaimPending(superblockHash, claim.submitter);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // @dev – confirm semi approved superblock.\r\n    //\r\n    // A semi approved superblock can be confirmed if it has several descendant\r\n    // superblocks that are also semi-approved.\r\n    // If none of the descendants were challenged they will also be confirmed.\r\n    //\r\n    // @param superblockHash – the claim ID.\r\n    // @param descendantId - claim ID descendants\r\n    function confirmClaim(bytes32 superblockHash, bytes32 descendantId) public returns (bool) {\r\n        uint numSuperblocks = 0;\r\n        bool confirmDescendants = true;\r\n        bytes32 id = descendantId;\r\n        SuperblockClaim storage claim = claims[id];\r\n        while (id != superblockHash) {\r\n            if (!claimExists(claim)) {\r\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\r\n                return false;\r\n            }\r\n            if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocks.Status.SemiApproved) {\r\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n                return false;\r\n            }\r\n            if (confirmDescendants && claim.challengers.length > 0) {\r\n                confirmDescendants = false;\r\n            }\r\n            id = trustedSuperblocks.getSuperblockParentId(id);\r\n            claim = claims[id];\r\n            numSuperblocks += 1;\r\n        }\r\n\r\n        if (numSuperblocks < superblockConfirmations) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MISSING_CONFIRMATIONS);\r\n            return false;\r\n        }\r\n        if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocks.Status.SemiApproved) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n            return false;\r\n        }\r\n\r\n        bytes32 parentId = trustedSuperblocks.getSuperblockParentId(superblockHash);\r\n        if (trustedSuperblocks.getSuperblockStatus(parentId) != SyscoinSuperblocks.Status.Approved) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n            return false;\r\n        }\r\n\r\n        (uint err, ) = trustedSuperblocks.confirm(superblockHash, msg.sender);\r\n        if (err != ERR_SUPERBLOCK_OK) {\r\n            emit ErrorClaim(superblockHash, err);\r\n            return false;\r\n        }\r\n        emit SuperblockClaimSuccessful(superblockHash, claim.submitter);\r\n        doPaySubmitter(superblockHash, claim);\r\n        unbondDeposit(superblockHash, claim.submitter);\r\n\r\n        if (confirmDescendants) {\r\n            bytes32[] memory descendants = new bytes32[](numSuperblocks);\r\n            id = descendantId;\r\n            uint idx = 0;\r\n            while (id != superblockHash) {\r\n                descendants[idx] = id;\r\n                id = trustedSuperblocks.getSuperblockParentId(id);\r\n                idx += 1;\r\n            }\r\n            while (idx > 0) {\r\n                idx -= 1;\r\n                id = descendants[idx];\r\n                claim = claims[id];\r\n                (err, ) = trustedSuperblocks.confirm(id, msg.sender);\r\n                require(err == ERR_SUPERBLOCK_OK);\r\n                emit SuperblockClaimSuccessful(id, claim.submitter);\r\n                doPaySubmitter(id, claim);\r\n                unbondDeposit(id, claim.submitter);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // @dev – Reject a semi approved superblock.\r\n    //\r\n    // Superblocks that are not in the main chain can be marked as\r\n    // invalid.\r\n    //\r\n    // @param superblockHash – the claim ID.\r\n    function rejectClaim(bytes32 superblockHash) public returns (bool) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        if (!claimExists(claim)) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\r\n            return false;\r\n        }\r\n\r\n        uint height = trustedSuperblocks.getSuperblockHeight(superblockHash);\r\n        bytes32 id = trustedSuperblocks.getBestSuperblock();\r\n        if (trustedSuperblocks.getSuperblockHeight(id) < height + superblockConfirmations) {\r\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MISSING_CONFIRMATIONS);\r\n            return false;\r\n        }\r\n\r\n        id = trustedSuperblocks.getSuperblockAt(height);\r\n\r\n        if (id != superblockHash) {\r\n            SyscoinSuperblocks.Status status = trustedSuperblocks.getSuperblockStatus(superblockHash);\r\n\r\n            if (status != SyscoinSuperblocks.Status.SemiApproved) {\r\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\r\n                return false;\r\n            }\r\n\r\n            if (!claim.decided) {\r\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\r\n                return false;\r\n            }\r\n\r\n            trustedSuperblocks.invalidate(superblockHash, msg.sender);\r\n            emit SuperblockClaimFailed(superblockHash, claim.submitter);\r\n            doPayChallengers(superblockHash, claim);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // @dev – called when a battle session has ended.\r\n    //\r\n    // @param sessionId – session Id.\r\n    // @param superblockHash - claim Id\r\n    // @param winner – winner of verification game.\r\n    // @param loser – loser of verification game.\r\n    function sessionDecided(bytes32 sessionId, bytes32 superblockHash, address winner, address loser) public onlyBattleManager {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n\r\n        require(claimExists(claim));\r\n\r\n        claim.verificationOngoing = false;\r\n\r\n        if (claim.submitter == loser) {\r\n            // the claim is over.\r\n            // Trigger end of verification game\r\n            claim.invalid = true;\r\n        } else if (claim.submitter == winner) {\r\n            // the claim continues.\r\n            // It should not fail when called from sessionDecided\r\n            runNextBattleSession(superblockHash);\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        emit SuperblockBattleDecided(sessionId, winner, loser);\r\n    }\r\n\r\n    // @dev - Pay challengers than ran their battles with submitter deposits\r\n    // Challengers that did not run will be returned their deposits\r\n    function doPayChallengers(bytes32 superblockHash, SuperblockClaim storage claim) internal {\r\n        uint rewards = claim.bondedDeposits[claim.submitter];\r\n        claim.bondedDeposits[claim.submitter] = 0;\r\n        uint totalDeposits = 0;\r\n        uint idx = 0;\r\n        for (idx = 0; idx < claim.currentChallenger; ++idx) {\r\n            totalDeposits = totalDeposits.add(claim.bondedDeposits[claim.challengers[idx]]);\r\n        }\r\n        \r\n        address challenger;\r\n        uint reward = 0;\r\n        if(totalDeposits == 0 && claim.currentChallenger > 0){\r\n            reward = rewards.div(claim.currentChallenger);\r\n        }\r\n        for (idx = 0; idx < claim.currentChallenger; ++idx) {\r\n            reward = 0;\r\n            challenger = claim.challengers[idx];\r\n            if(totalDeposits > 0){\r\n                reward = rewards.mul(claim.bondedDeposits[challenger]).div(totalDeposits);\r\n            }\r\n            claim.bondedDeposits[challenger] = claim.bondedDeposits[challenger].add(reward);\r\n        }\r\n        uint bondedDeposit;\r\n        for (idx = 0; idx < claim.challengers.length; ++idx) {\r\n            challenger = claim.challengers[idx];\r\n            bondedDeposit = claim.bondedDeposits[challenger];\r\n            deposits[challenger] = deposits[challenger].add(bondedDeposit);\r\n            claim.bondedDeposits[challenger] = 0;\r\n            emit DepositUnbonded(superblockHash, challenger, bondedDeposit);\r\n        }\r\n    }\r\n\r\n    // @dev - Pay submitter with challenger deposits\r\n    function doPaySubmitter(bytes32 superblockHash, SuperblockClaim storage claim) internal {\r\n        address challenger;\r\n        uint bondedDeposit;\r\n        for (uint idx=0; idx < claim.challengers.length; ++idx) {\r\n            challenger = claim.challengers[idx];\r\n            bondedDeposit = claim.bondedDeposits[challenger];\r\n            claim.bondedDeposits[challenger] = 0;\r\n            claim.bondedDeposits[claim.submitter] = claim.bondedDeposits[claim.submitter].add(bondedDeposit);\r\n        }\r\n        unbondDeposit(superblockHash, claim.submitter);\r\n    }\r\n\r\n    // @dev - Check if a superblock can be semi approved by calling checkClaimFinished\r\n    function getInBattleAndSemiApprovable(bytes32 superblockHash) public view returns (bool) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        return (trustedSuperblocks.getSuperblockStatus(superblockHash) == SyscoinSuperblocks.Status.InBattle &&\r\n            !claim.invalid && !claim.verificationOngoing && block.timestamp > claim.challengeTimeout\r\n            && claim.currentChallenger >= claim.challengers.length);\r\n    }\r\n\r\n    // @dev – Check if a claim exists\r\n    function claimExists(SuperblockClaim claim) private pure returns (bool) {\r\n        return (claim.submitter != 0x0);\r\n    }\r\n\r\n    // @dev - Return a given superblock's submitter\r\n    function getClaimSubmitter(bytes32 superblockHash) public view returns (address) {\r\n        return claims[superblockHash].submitter;\r\n    }\r\n\r\n    // @dev - Return superblock submission timestamp\r\n    function getNewSuperblockEventTimestamp(bytes32 superblockHash) public view returns (uint) {\r\n        return claims[superblockHash].createdAt;\r\n    }\r\n\r\n    // @dev - Return whether or not a claim has already been made\r\n    function getClaimExists(bytes32 superblockHash) public view returns (bool) {\r\n        return claimExists(claims[superblockHash]);\r\n    }\r\n\r\n    // @dev - Return claim status\r\n    function getClaimDecided(bytes32 superblockHash) public view returns (bool) {\r\n        return claims[superblockHash].decided;\r\n    }\r\n\r\n    // @dev - Check if a claim is invalid\r\n    function getClaimInvalid(bytes32 superblockHash) public view returns (bool) {\r\n        // TODO: see if this is redundant with superblock status\r\n        return claims[superblockHash].invalid;\r\n    }\r\n\r\n    // @dev - Check if a claim has a verification game in progress\r\n    function getClaimVerificationOngoing(bytes32 superblockHash) public view returns (bool) {\r\n        return claims[superblockHash].verificationOngoing;\r\n    }\r\n\r\n    // @dev - Returns timestamp of challenge timeout\r\n    function getClaimChallengeTimeout(bytes32 superblockHash) public view returns (uint) {\r\n        return claims[superblockHash].challengeTimeout;\r\n    }\r\n\r\n    // @dev - Return the number of challengers whose battles haven't been decided yet\r\n    function getClaimRemainingChallengers(bytes32 superblockHash) public view returns (uint) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        return claim.challengers.length - (claim.currentChallenger);\r\n    }\r\n\r\n    // @dev – Return session by challenger\r\n    function getSession(bytes32 superblockHash, address challenger) public view returns(bytes32) {\r\n        return claims[superblockHash].sessions[challenger];\r\n    }\r\n\r\n    function getClaimChallengers(bytes32 superblockHash) public view returns (address[]) {\r\n        SuperblockClaim storage claim = claims[superblockHash];\r\n        return claim.challengers;\r\n    }\r\n\r\n    function getSuperblockInfo(bytes32 superblockHash) internal view returns (\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentId,\r\n        address _submitter,\r\n        SyscoinSuperblocks.Status _status,\r\n        uint32 _height\r\n    ) {\r\n        return trustedSuperblocks.getSuperblock(superblockHash);\r\n    }\r\n}\r\n\r\n// @dev - Manages a battle session between superblock submitter and challenger\r\ncontract SyscoinBattleManager is SyscoinErrorCodes {\r\n\r\n    enum ChallengeState {\r\n        Unchallenged,             // Unchallenged submission\r\n        Challenged,               // Claims was challenged\r\n        QueryMerkleRootHashes,    // Challenger expecting block hashes\r\n        RespondMerkleRootHashes,  // Blcok hashes were received and verified\r\n        QueryBlockHeader,         // Challenger is requesting block headers\r\n        RespondBlockHeader,       // All block headers were received\r\n        PendingVerification,      // Pending superblock verification\r\n        SuperblockVerified,       // Superblock verified\r\n        SuperblockFailed          // Superblock not valid\r\n    }\r\n\r\n    enum BlockInfoStatus {\r\n        Uninitialized,\r\n        Requested,\r\n\t\tVerified\r\n    }\r\n\r\n    struct BlockInfo {\r\n        bytes32 prevBlock;\r\n        uint64 timestamp;\r\n        uint32 bits;\r\n        BlockInfoStatus status;\r\n        bytes powBlockHeader;\r\n        bytes32 blockHash;\r\n    }\r\n\r\n    struct BattleSession {\r\n        bytes32 id;\r\n        bytes32 superblockHash;\r\n        address submitter;\r\n        address challenger;\r\n        uint lastActionTimestamp;         // Last action timestamp\r\n        uint lastActionClaimant;          // Number last action submitter\r\n        uint lastActionChallenger;        // Number last action challenger\r\n        uint actionsCounter;              // Counter session actions\r\n\r\n        bytes32[] blockHashes;            // Block hashes\r\n        uint countBlockHeaderQueries;     // Number of block header queries\r\n        uint countBlockHeaderResponses;   // Number of block header responses\r\n\r\n        mapping (bytes32 => BlockInfo) blocksInfo;\r\n\r\n        ChallengeState challengeState;    // Claim state\r\n    }\r\n\r\n\r\n    mapping (bytes32 => BattleSession) public sessions;\r\n\r\n    uint public sessionsCount = 0;\r\n\r\n    uint public superblockDuration;         // Superblock duration (in seconds)\r\n    uint public superblockTimeout;          // Timeout action (in seconds)\r\n\r\n\r\n    // network that the stored blocks belong to\r\n    SyscoinMessageLibrary.Network private net;\r\n\r\n\r\n    // Syscoin claim manager\r\n    SyscoinClaimManager trustedSyscoinClaimManager;\r\n\r\n    // Superblocks contract\r\n    SyscoinSuperblocks trustedSuperblocks;\r\n\r\n    event NewBattle(bytes32 superblockHash, bytes32 sessionId, address submitter, address challenger);\r\n    event ChallengerConvicted(bytes32 superblockHash, bytes32 sessionId, address challenger);\r\n    event SubmitterConvicted(bytes32 superblockHash, bytes32 sessionId, address submitter);\r\n\r\n    event QueryMerkleRootHashes(bytes32 superblockHash, bytes32 sessionId, address submitter);\r\n    event RespondMerkleRootHashes(bytes32 superblockHash, bytes32 sessionId, address challenger, bytes32[] blockHashes);\r\n    event QueryBlockHeader(bytes32 superblockHash, bytes32 sessionId, address submitter, bytes32 blockSha256Hash);\r\n    event RespondBlockHeader(bytes32 superblockHash, bytes32 sessionId, address challenger, bytes blockHeader, bytes powBlockHeader);\r\n\r\n    event ErrorBattle(bytes32 sessionId, uint err);\r\n    modifier onlyFrom(address sender) {\r\n        require(msg.sender == sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyClaimant(bytes32 sessionId) {\r\n        require(msg.sender == sessions[sessionId].submitter);\r\n        _;\r\n    }\r\n\r\n    modifier onlyChallenger(bytes32 sessionId) {\r\n        require(msg.sender == sessions[sessionId].challenger);\r\n        _;\r\n    }\r\n\r\n    // @dev – Configures the contract managing superblocks battles\r\n    // @param _network Network type to use for block difficulty validation\r\n    // @param _superblocks Contract that manages superblocks\r\n    // @param _superblockDuration Superblock duration (in seconds)\r\n    // @param _superblockTimeout Time to wait for challenges (in seconds)\r\n    constructor(\r\n        SyscoinMessageLibrary.Network _network,\r\n        SyscoinSuperblocks _superblocks,\r\n        uint _superblockDuration,\r\n        uint _superblockTimeout\r\n    ) public {\r\n        net = _network;\r\n        trustedSuperblocks = _superblocks;\r\n        superblockDuration = _superblockDuration;\r\n        superblockTimeout = _superblockTimeout;\r\n    }\r\n\r\n    function setSyscoinClaimManager(SyscoinClaimManager _syscoinClaimManager) public {\r\n        require(address(trustedSyscoinClaimManager) == 0x0 && address(_syscoinClaimManager) != 0x0);\r\n        trustedSyscoinClaimManager = _syscoinClaimManager;\r\n    }\r\n\r\n    // @dev - Start a battle session\r\n    function beginBattleSession(bytes32 superblockHash, address submitter, address challenger)\r\n        onlyFrom(trustedSyscoinClaimManager) public returns (bytes32) {\r\n        bytes32 sessionId = keccak256(abi.encode(superblockHash, msg.sender, sessionsCount));\r\n        BattleSession storage session = sessions[sessionId];\r\n        session.id = sessionId;\r\n        session.superblockHash = superblockHash;\r\n        session.submitter = submitter;\r\n        session.challenger = challenger;\r\n        session.lastActionTimestamp = block.timestamp;\r\n        session.lastActionChallenger = 0;\r\n        session.lastActionClaimant = 1;     // Force challenger to start\r\n        session.actionsCounter = 1;\r\n        session.challengeState = ChallengeState.Challenged;\r\n\r\n        sessionsCount += 1;\r\n\r\n        emit NewBattle(superblockHash, sessionId, submitter, challenger);\r\n        return sessionId;\r\n    }\r\n\r\n    // @dev - Challenger makes a query for superblock hashes\r\n    function doQueryMerkleRootHashes(BattleSession storage session) internal returns (uint) {\r\n        if (!hasDeposit(msg.sender, respondMerkleRootHashesCost)) {\r\n            return ERR_SUPERBLOCK_MIN_DEPOSIT;\r\n        }\r\n        if (session.challengeState == ChallengeState.Challenged) {\r\n            session.challengeState = ChallengeState.QueryMerkleRootHashes;\r\n            assert(msg.sender == session.challenger);\r\n            (uint err, ) = bondDeposit(session.superblockHash, msg.sender, respondMerkleRootHashesCost);\r\n            if (err != ERR_SUPERBLOCK_OK) {\r\n                return err;\r\n            }\r\n            return ERR_SUPERBLOCK_OK;\r\n        }\r\n        return ERR_SUPERBLOCK_BAD_STATUS;\r\n    }\r\n\r\n    // @dev - Challenger makes a query for superblock hashes\r\n    function queryMerkleRootHashes(bytes32 superblockHash, bytes32 sessionId) onlyChallenger(sessionId) public {\r\n        BattleSession storage session = sessions[sessionId];\r\n        uint err = doQueryMerkleRootHashes(session);\r\n        if (err != ERR_SUPERBLOCK_OK) {\r\n            emit ErrorBattle(sessionId, err);\r\n        } else {\r\n            session.actionsCounter += 1;\r\n            session.lastActionTimestamp = block.timestamp;\r\n            session.lastActionChallenger = session.actionsCounter;\r\n            emit QueryMerkleRootHashes(superblockHash, sessionId, session.submitter);\r\n        }\r\n    }\r\n\r\n    // @dev - Submitter sends hashes to verify superblock merkle root\r\n    function doVerifyMerkleRootHashes(BattleSession storage session, bytes32[] blockHashes) internal returns (uint) {\r\n        if (!hasDeposit(msg.sender, verifySuperblockCost)) {\r\n            return ERR_SUPERBLOCK_MIN_DEPOSIT;\r\n        }\r\n        require(session.blockHashes.length == 0);\r\n        if (session.challengeState == ChallengeState.QueryMerkleRootHashes) {\r\n            (bytes32 merkleRoot, , , , bytes32 lastHash, , , ,,) = getSuperblockInfo(session.superblockHash);\r\n            if (lastHash != blockHashes[blockHashes.length - 1]){\r\n                return ERR_SUPERBLOCK_BAD_LASTBLOCK;\r\n            }\r\n            if (merkleRoot != SyscoinMessageLibrary.makeMerkle(blockHashes)) {\r\n                return ERR_SUPERBLOCK_INVALID_MERKLE;\r\n            }\r\n            (uint err, ) = bondDeposit(session.superblockHash, msg.sender, verifySuperblockCost);\r\n            if (err != ERR_SUPERBLOCK_OK) {\r\n                return err;\r\n            }\r\n            session.blockHashes = blockHashes;\r\n            session.challengeState = ChallengeState.RespondMerkleRootHashes;\r\n            return ERR_SUPERBLOCK_OK;\r\n        }\r\n        return ERR_SUPERBLOCK_BAD_STATUS;\r\n    }\r\n\r\n    // @dev - For the submitter to respond to challenger queries\r\n    function respondMerkleRootHashes(bytes32 superblockHash, bytes32 sessionId, bytes32[] blockHashes) onlyClaimant(sessionId) public {\r\n        BattleSession storage session = sessions[sessionId];\r\n        uint err = doVerifyMerkleRootHashes(session, blockHashes);\r\n        if (err != 0) {\r\n            emit ErrorBattle(sessionId, err);\r\n        } else {\r\n            session.actionsCounter += 1;\r\n            session.lastActionTimestamp = block.timestamp;\r\n            session.lastActionClaimant = session.actionsCounter;\r\n            emit RespondMerkleRootHashes(superblockHash, sessionId, session.challenger, blockHashes);\r\n        }\r\n    }\r\n\r\n    // @dev - Challenger makes a query for block header data for a hash\r\n    function doQueryBlockHeader(BattleSession storage session, bytes32 blockHash) internal returns (uint) {\r\n        if (!hasDeposit(msg.sender, respondBlockHeaderCost)) {\r\n            return ERR_SUPERBLOCK_MIN_DEPOSIT;\r\n        }\r\n        if ((session.countBlockHeaderQueries == 0 && session.challengeState == ChallengeState.RespondMerkleRootHashes) ||\r\n            (session.countBlockHeaderQueries > 0 && session.challengeState == ChallengeState.RespondBlockHeader)) {\r\n            require(session.countBlockHeaderQueries < session.blockHashes.length);\r\n            require(session.blocksInfo[blockHash].status == BlockInfoStatus.Uninitialized);\r\n            (uint err, ) = bondDeposit(session.superblockHash, msg.sender, respondBlockHeaderCost);\r\n            if (err != ERR_SUPERBLOCK_OK) {\r\n                return err;\r\n            }\r\n            session.countBlockHeaderQueries += 1;\r\n            session.blocksInfo[blockHash].status = BlockInfoStatus.Requested;\r\n            session.challengeState = ChallengeState.QueryBlockHeader;\r\n            return ERR_SUPERBLOCK_OK;\r\n        }\r\n        return ERR_SUPERBLOCK_BAD_STATUS;\r\n    }\r\n\r\n    // @dev - For the challenger to start a query\r\n    function queryBlockHeader(bytes32 superblockHash, bytes32 sessionId, bytes32 blockHash) onlyChallenger(sessionId) public {\r\n        BattleSession storage session = sessions[sessionId];\r\n        uint err = doQueryBlockHeader(session, blockHash);\r\n        if (err != ERR_SUPERBLOCK_OK) {\r\n            emit ErrorBattle(sessionId, err);\r\n        } else {\r\n            session.actionsCounter += 1;\r\n            session.lastActionTimestamp = block.timestamp;\r\n            session.lastActionChallenger = session.actionsCounter;\r\n            emit QueryBlockHeader(superblockHash, sessionId, session.submitter, blockHash);\r\n        }\r\n    }\r\n\r\n    // @dev - Verify that block timestamp is in the superblock timestamp interval\r\n    function verifyTimestamp(bytes32 superblockHash, bytes blockHeader) internal view returns (bool) {\r\n        uint blockTimestamp = SyscoinMessageLibrary.getTimestamp(blockHeader);\r\n        uint superblockTimestamp;\r\n\r\n        (, , superblockTimestamp, , , , , ,,) = getSuperblockInfo(superblockHash);\r\n\r\n        // Block timestamp to be within the expected timestamp of the superblock\r\n        return (blockTimestamp <= superblockTimestamp)\r\n            && (blockTimestamp / superblockDuration >= superblockTimestamp / superblockDuration - 1);\r\n    }\r\n\r\n    // @dev - Verify Syscoin block AuxPoW\r\n    function verifyBlockAuxPoW(\r\n        BlockInfo storage blockInfo,\r\n        bytes32 blockHash,\r\n        bytes blockHeader\r\n    ) internal returns (uint, bytes) {\r\n        (uint err, bool isMergeMined) =\r\n            SyscoinMessageLibrary.verifyBlockHeader(blockHeader, 0, uint(blockHash));\r\n        if (err != 0) {\r\n            return (err, new bytes(0));\r\n        }\r\n        bytes memory powBlockHeader = (isMergeMined) ?\r\n            SyscoinMessageLibrary.sliceArray(blockHeader, blockHeader.length - 80, blockHeader.length) :\r\n            SyscoinMessageLibrary.sliceArray(blockHeader, 0, 80);\r\n\r\n        blockInfo.timestamp = SyscoinMessageLibrary.getTimestamp(blockHeader);\r\n        blockInfo.bits = SyscoinMessageLibrary.getBits(blockHeader);\r\n        blockInfo.prevBlock = bytes32(SyscoinMessageLibrary.getHashPrevBlock(blockHeader));\r\n        blockInfo.blockHash = blockHash;\r\n        blockInfo.powBlockHeader = powBlockHeader;\r\n        return (ERR_SUPERBLOCK_OK, powBlockHeader);\r\n    }\r\n\r\n    // @dev - Verify block header sent by challenger\r\n    function doVerifyBlockHeader(\r\n        BattleSession storage session,\r\n        bytes memory blockHeader\r\n    ) internal returns (uint, bytes) {\r\n        if (!hasDeposit(msg.sender, respondBlockHeaderCost)) {\r\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, new bytes(0));\r\n        }\r\n        if (session.challengeState == ChallengeState.QueryBlockHeader) {\r\n            bytes32 blockSha256Hash = bytes32(SyscoinMessageLibrary.dblShaFlipMem(blockHeader, 0, 80));\r\n            BlockInfo storage blockInfo = session.blocksInfo[blockSha256Hash];\r\n            if (blockInfo.status != BlockInfoStatus.Requested) {\r\n                return (ERR_SUPERBLOCK_BAD_SYSCOIN_STATUS, new bytes(0));\r\n            }\r\n\r\n            if (!verifyTimestamp(session.superblockHash, blockHeader)) {\r\n                return (ERR_SUPERBLOCK_BAD_TIMESTAMP, new bytes(0));\r\n            }\r\n\t\t\t// pass in blockSha256Hash here instead of proposedScryptHash because we\r\n            // don't need a proposed hash (we already calculated it here, syscoin uses \r\n            // sha256 just like bitcoin)\r\n            (uint err, bytes memory powBlockHeader) =\r\n                verifyBlockAuxPoW(blockInfo, blockSha256Hash, blockHeader);\r\n            if (err != ERR_SUPERBLOCK_OK) {\r\n                return (err, new bytes(0));\r\n            }\r\n\t\t\t// set to verify block header status\r\n            blockInfo.status = BlockInfoStatus.Verified;\r\n\r\n            (err, ) = bondDeposit(session.superblockHash, msg.sender, respondBlockHeaderCost);\r\n            if (err != ERR_SUPERBLOCK_OK) {\r\n                return (err, new bytes(0));\r\n            }\r\n\r\n            session.countBlockHeaderResponses += 1;\r\n\t\t\t// if header responses matches num block hashes we skip to respond block header instead of pending verification\r\n            if (session.countBlockHeaderResponses == session.blockHashes.length) {\r\n                session.challengeState = ChallengeState.PendingVerification;\r\n            } else {\r\n                session.challengeState = ChallengeState.RespondBlockHeader;\r\n            }\r\n\r\n            return (ERR_SUPERBLOCK_OK, powBlockHeader);\r\n        }\r\n        return (ERR_SUPERBLOCK_BAD_STATUS, new bytes(0));\r\n    }\r\n\r\n    // @dev - For the submitter to respond to challenger queries\r\n    function respondBlockHeader(\r\n        bytes32 superblockHash,\r\n        bytes32 sessionId,\r\n        bytes memory blockHeader\r\n    ) onlyClaimant(sessionId) public {\r\n        BattleSession storage session = sessions[sessionId];\r\n        (uint err, bytes memory powBlockHeader) = doVerifyBlockHeader(session, blockHeader);\r\n        if (err != 0) {\r\n            emit ErrorBattle(sessionId, err);\r\n        } else {\r\n            session.actionsCounter += 1;\r\n            session.lastActionTimestamp = block.timestamp;\r\n            session.lastActionClaimant = session.actionsCounter;\r\n            emit RespondBlockHeader(superblockHash, sessionId, session.challenger, blockHeader, powBlockHeader);\r\n        }\r\n    }\r\n\r\n    // @dev - Validate superblock information from last blocks\r\n    function validateLastBlocks(BattleSession storage session) internal view returns (uint) {\r\n        if (session.blockHashes.length <= 0) {\r\n            return ERR_SUPERBLOCK_BAD_LASTBLOCK;\r\n        }\r\n        uint lastTimestamp;\r\n        uint prevTimestamp;\r\n        uint32 lastBits;\r\n        bytes32 parentId;\r\n        (, , lastTimestamp, prevTimestamp, , lastBits, parentId,,,) = getSuperblockInfo(session.superblockHash);\r\n        bytes32 blockSha256Hash = session.blockHashes[session.blockHashes.length - 1];\r\n        if (session.blocksInfo[blockSha256Hash].timestamp != lastTimestamp) {\r\n            return ERR_SUPERBLOCK_BAD_TIMESTAMP;\r\n        }\r\n        if (session.blocksInfo[blockSha256Hash].bits != lastBits) {\r\n            return ERR_SUPERBLOCK_BAD_BITS;\r\n        }\r\n        if (prevTimestamp > lastTimestamp) {\r\n            return ERR_SUPERBLOCK_BAD_TIMESTAMP;\r\n        }\r\n        \r\n        return ERR_SUPERBLOCK_OK;\r\n    }\r\n\r\n    // @dev - Validate superblock accumulated work\r\n    function validateProofOfWork(BattleSession storage session) internal view returns (uint) {\r\n        uint accWork;\r\n        bytes32 prevBlock;\r\n        uint32 prevHeight;  \r\n        uint32 proposedHeight;  \r\n        uint prevTimestamp;\r\n        (, accWork, , prevTimestamp, , , prevBlock, ,,proposedHeight) = getSuperblockInfo(session.superblockHash);\r\n        uint parentTimestamp;\r\n        \r\n        uint32 prevBits;\r\n       \r\n        uint work;    \r\n        (, work, parentTimestamp, , prevBlock, prevBits, , , ,prevHeight) = getSuperblockInfo(prevBlock);\r\n        \r\n        if (proposedHeight != (prevHeight+uint32(session.blockHashes.length))) {\r\n            return ERR_SUPERBLOCK_BAD_BLOCKHEIGHT;\r\n        }      \r\n        uint ret = validateSuperblockProofOfWork(session, parentTimestamp, prevHeight, work, accWork, prevTimestamp, prevBits, prevBlock);\r\n        if(ret != 0){\r\n            return ret;\r\n        }\r\n        return ERR_SUPERBLOCK_OK;\r\n    }\r\n    function validateSuperblockProofOfWork(BattleSession storage session, uint parentTimestamp, uint32 prevHeight, uint work, uint accWork, uint prevTimestamp, uint32 prevBits, bytes32 prevBlock) internal view returns (uint){\r\n         uint32 idx = 0;\r\n         while (idx < session.blockHashes.length) {\r\n            bytes32 blockSha256Hash = session.blockHashes[idx];\r\n            uint32 bits = session.blocksInfo[blockSha256Hash].bits;\r\n            if (session.blocksInfo[blockSha256Hash].prevBlock != prevBlock) {\r\n                return ERR_SUPERBLOCK_BAD_PARENT;\r\n            }\r\n            if (net != SyscoinMessageLibrary.Network.REGTEST) {\r\n                uint32 newBits;\r\n                if (net == SyscoinMessageLibrary.Network.TESTNET && session.blocksInfo[blockSha256Hash].timestamp - parentTimestamp > 120) {\r\n                    newBits = 0x1e0fffff;\r\n                }\r\n                else if((prevHeight+idx+1) % SyscoinMessageLibrary.difficultyAdjustmentInterval() != 0){\r\n                    newBits = prevBits;\r\n                }\r\n                else{\r\n                    newBits = SyscoinMessageLibrary.calculateDifficulty(int64(parentTimestamp) - int64(prevTimestamp), prevBits);\r\n                    prevTimestamp = parentTimestamp;\r\n                    prevBits = bits;\r\n                }\r\n                if (bits != newBits) {\r\n                   return ERR_SUPERBLOCK_BAD_BITS;\r\n                }\r\n            }\r\n            work += SyscoinMessageLibrary.diffFromBits(bits);\r\n            prevBlock = blockSha256Hash;\r\n            parentTimestamp = session.blocksInfo[blockSha256Hash].timestamp;\r\n            idx += 1;\r\n        }\r\n        if (net != SyscoinMessageLibrary.Network.REGTEST &&  work != accWork) {\r\n            return ERR_SUPERBLOCK_BAD_ACCUMULATED_WORK;\r\n        }       \r\n        return 0;\r\n    }\r\n    // @dev - Verify whether a superblock's data is consistent\r\n    // Only should be called when all blocks header were submitted\r\n    function doVerifySuperblock(BattleSession storage session, bytes32 sessionId) internal returns (uint) {\r\n        if (session.challengeState == ChallengeState.PendingVerification) {\r\n            uint err;\r\n            err = validateLastBlocks(session);\r\n            if (err != 0) {\r\n                emit ErrorBattle(sessionId, err);\r\n                return 2;\r\n            }\r\n            err = validateProofOfWork(session);\r\n            if (err != 0) {\r\n                emit ErrorBattle(sessionId, err);\r\n                return 2;\r\n            }\r\n            return 1;\r\n        } else if (session.challengeState == ChallengeState.SuperblockFailed) {\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // @dev - Perform final verification once all blocks were submitted\r\n    function verifySuperblock(bytes32 sessionId) public {\r\n        BattleSession storage session = sessions[sessionId];\r\n        uint status = doVerifySuperblock(session, sessionId);\r\n        if (status == 1) {\r\n            convictChallenger(sessionId, session.challenger, session.superblockHash);\r\n        } else if (status == 2) {\r\n            convictSubmitter(sessionId, session.submitter, session.superblockHash);\r\n        }\r\n    }\r\n\r\n    // @dev - Trigger conviction if response is not received in time\r\n    function timeout(bytes32 sessionId) public returns (uint) {\r\n        BattleSession storage session = sessions[sessionId];\r\n        if (session.challengeState == ChallengeState.SuperblockFailed ||\r\n            (session.lastActionChallenger > session.lastActionClaimant &&\r\n            block.timestamp > session.lastActionTimestamp + superblockTimeout)) {\r\n            convictSubmitter(sessionId, session.submitter, session.superblockHash);\r\n            return ERR_SUPERBLOCK_OK;\r\n        } else if (session.lastActionClaimant > session.lastActionChallenger &&\r\n            block.timestamp > session.lastActionTimestamp + superblockTimeout) {\r\n            convictChallenger(sessionId, session.challenger, session.superblockHash);\r\n            return ERR_SUPERBLOCK_OK;\r\n        }\r\n        emit ErrorBattle(sessionId, ERR_SUPERBLOCK_NO_TIMEOUT);\r\n        return ERR_SUPERBLOCK_NO_TIMEOUT;\r\n    }\r\n\r\n    // @dev - To be called when a challenger is convicted\r\n    function convictChallenger(bytes32 sessionId, address challenger, bytes32 superblockHash) internal {\r\n        BattleSession storage session = sessions[sessionId];\r\n        sessionDecided(sessionId, superblockHash, session.submitter, session.challenger);\r\n        disable(sessionId);\r\n        emit ChallengerConvicted(superblockHash, sessionId, challenger);\r\n    }\r\n\r\n    // @dev - To be called when a submitter is convicted\r\n    function convictSubmitter(bytes32 sessionId, address submitter, bytes32 superblockHash) internal {\r\n        BattleSession storage session = sessions[sessionId];\r\n        sessionDecided(sessionId, superblockHash, session.challenger, session.submitter);\r\n        disable(sessionId);\r\n        emit SubmitterConvicted(superblockHash, sessionId, submitter);\r\n    }\r\n\r\n    // @dev - Disable session\r\n    // It should be called only when either the submitter or the challenger were convicted.\r\n    function disable(bytes32 sessionId) internal {\r\n        delete sessions[sessionId];\r\n    }\r\n\r\n    // @dev - Check if a session's challenger did not respond before timeout\r\n    function getChallengerHitTimeout(bytes32 sessionId) public view returns (bool) {\r\n        BattleSession storage session = sessions[sessionId];\r\n        return (session.lastActionClaimant > session.lastActionChallenger &&\r\n            block.timestamp > session.lastActionTimestamp + superblockTimeout);\r\n    }\r\n\r\n    // @dev - Check if a session's submitter did not respond before timeout\r\n    function getSubmitterHitTimeout(bytes32 sessionId) public view returns (bool) {\r\n        BattleSession storage session = sessions[sessionId];\r\n        return (session.lastActionChallenger > session.lastActionClaimant &&\r\n            block.timestamp > session.lastActionTimestamp + superblockTimeout);\r\n    }\r\n\r\n    // @dev - Return Syscoin block hashes associated with a certain battle session\r\n    function getSyscoinBlockHashes(bytes32 sessionId) public view returns (bytes32[]) {\r\n        return sessions[sessionId].blockHashes;\r\n    }\r\n\r\n    // @dev - To be called when a battle sessions  was decided\r\n    function sessionDecided(bytes32 sessionId, bytes32 superblockHash, address winner, address loser) internal {\r\n        trustedSyscoinClaimManager.sessionDecided(sessionId, superblockHash, winner, loser);\r\n    }\r\n\r\n    // @dev - Retrieve superblock information\r\n    function getSuperblockInfo(bytes32 superblockHash) internal view returns (\r\n        bytes32 _blocksMerkleRoot,\r\n        uint _accumulatedWork,\r\n        uint _timestamp,\r\n        uint _prevTimestamp,\r\n        bytes32 _lastHash,\r\n        uint32 _lastBits,\r\n        bytes32 _parentId,\r\n        address _submitter,\r\n        SyscoinSuperblocks.Status _status,\r\n        uint32 _height\r\n    ) {\r\n        return trustedSuperblocks.getSuperblock(superblockHash);\r\n    }\r\n\r\n    // @dev - Verify whether a user has a certain amount of deposits or more\r\n    function hasDeposit(address who, uint amount) internal view returns (bool) {\r\n        return trustedSyscoinClaimManager.getDeposit(who) >= amount;\r\n    }\r\n\r\n    // @dev – locks up part of a user's deposit into a claim.\r\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) internal returns (uint, uint) {\r\n        return trustedSyscoinClaimManager.bondDeposit(superblockHash, account, amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"queryBlockHeader\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"name\":\"blockHashes\",\"type\":\"bytes32[]\"}],\"name\":\"respondMerkleRootHashes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"name\":\"sessionId\",\"type\":\"bytes32\"}],\"name\":\"queryMerkleRootHashes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"name\":\"blockHeader\",\"type\":\"bytes\"}],\"name\":\"respondBlockHeader\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sessionsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_syscoinClaimManager\",\"type\":\"address\"}],\"name\":\"setSyscoinClaimManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minProposalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"respondBlockHeaderCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sessionId\",\"type\":\"bytes32\"}],\"name\":\"getSyscoinBlockHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minChallengeDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sessionId\",\"type\":\"bytes32\"}],\"name\":\"getSubmitterHitTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sessionId\",\"type\":\"bytes32\"}],\"name\":\"timeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sessions\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"name\":\"submitter\",\"type\":\"address\"},{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"lastActionTimestamp\",\"type\":\"uint256\"},{\"name\":\"lastActionClaimant\",\"type\":\"uint256\"},{\"name\":\"lastActionChallenger\",\"type\":\"uint256\"},{\"name\":\"actionsCounter\",\"type\":\"uint256\"},{\"name\":\"countBlockHeaderQueries\",\"type\":\"uint256\"},{\"name\":\"countBlockHeaderResponses\",\"type\":\"uint256\"},{\"name\":\"challengeState\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"respondMerkleRootHashesCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sessionId\",\"type\":\"bytes32\"}],\"name\":\"getChallengerHitTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sessionId\",\"type\":\"bytes32\"}],\"name\":\"verifySuperblock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifySuperblockCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"name\":\"submitter\",\"type\":\"address\"},{\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"beginBattleSession\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_network\",\"type\":\"uint8\"},{\"name\":\"_superblocks\",\"type\":\"address\"},{\"name\":\"_superblockDuration\",\"type\":\"uint256\"},{\"name\":\"_superblockTimeout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"NewBattle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"ChallengerConvicted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SubmitterConvicted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"QueryMerkleRootHashes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blockHashes\",\"type\":\"bytes32[]\"}],\"name\":\"RespondMerkleRootHashes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blockSha256Hash\",\"type\":\"bytes32\"}],\"name\":\"QueryBlockHeader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"powBlockHeader\",\"type\":\"bytes\"}],\"name\":\"RespondBlockHeader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sessionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"err\",\"type\":\"uint256\"}],\"name\":\"ErrorBattle\",\"type\":\"event\"}]","ContractName":"SyscoinBattleManager","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ced7ce5c336bb31f35bc5bdc86c651c7136b38250000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000000258","Library":"SyscoinMessageLibrary:1b081401c98ed6e62b01bc5379d52abee85ae1e9","SwarmSource":"bzzr://78ae56caa61ab5a159cd6e599579729e9a35d6cf6b7d201eb5dbf83410232336"}]}