{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ninterface IERC20 {\r\n  function transfer(address _to, uint256 _amount) external returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n  function balanceOf(address _owner) constant external returns (uint256 balance);\r\n  function approve(address _spender, uint256 _amount) external returns (bool success);\r\n  function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\r\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) external returns (bool success);\r\n  function totalSupply() external constant returns (uint);\r\n}\r\n\r\ninterface IPrizeCalculator {\r\n    function calculatePrizeAmount(uint _predictionTotalTokens, uint _winOutputTotalTokens, uint _forecastTokens)\r\n        pure\r\n        external\r\n        returns (uint);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public executor;\r\n    address public superOwner;\r\n  \r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        superOwner = msg.sender;\r\n        owner = msg.sender;\r\n        executor = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"User is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySuperOwner {\r\n        require(msg.sender == superOwner, \"User is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrSuperOwner {\r\n        require(msg.sender == owner || msg.sender == superOwner, \"User is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowed {\r\n        require(msg.sender == owner || msg.sender == executor || msg.sender == superOwner, \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwnerOrSuperOwner {\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function transferSuperOwnership(address _newOwner) public onlySuperOwner {\r\n        emit OwnershipTransferred(superOwner, _newOwner);\r\n        superOwner = _newOwner;\r\n    }\r\n\r\n    function transferExecutorOwnership(address _newExecutor) public onlyOwnerOrSuperOwner {\r\n        emit OwnershipTransferred(executor, _newExecutor);\r\n        executor = _newExecutor;\r\n    }\r\n}\r\n\r\ncontract Pools is Owned {\r\n    using SafeMath for uint;  \r\n\r\n    event Initialize(address _token);\r\n    event PoolAdded(bytes32 _id);\r\n    event PoolDestinationUpdated(bytes32 _id);\r\n    event ContributionAdded(bytes32 _poolId, bytes32 _contributionId);\r\n    event PoolStatusChange(bytes32 _poolId, PoolStatus _oldStatus, PoolStatus _newStatus);\r\n    event Paidout(bytes32 _poolId, bytes32 _contributionId);\r\n    event Withdraw(uint _amount);\r\n    \r\n    struct Pool {  \r\n        uint contributionStartUtc;\r\n        uint contributionEndUtc;\r\n        address destination;\r\n        PoolStatus status;\r\n        uint amountLimit;\r\n        uint amountCollected;\r\n        uint amountDistributing;\r\n        uint paidout;\r\n        address prizeCalculator;\r\n        mapping(bytes32 => Contribution) contributions;\r\n    }\r\n    \r\n    struct Contribution {  \r\n        address owner;\r\n        uint amount;\r\n        uint paidout;\r\n    }\r\n\r\n    struct ContributionIndex {    \r\n        bytes32 poolId;\r\n        bytes32 contributionId;\r\n    }\r\n    \r\n    enum PoolStatus {\r\n        NotSet,       // 0\r\n        Active,       // 1\r\n        Distributing, // 2\r\n        Funding,       // 3Â \r\n        Paused,       // 4\r\n        Canceled      // 5 \r\n    }  \r\n\r\n    uint8 public constant version = 1;\r\n    bool public paused = true;\r\n    address public token;\r\n    uint public totalPools;\r\n    \r\n    mapping(bytes32 => Pool) public pools;\r\n    mapping(address => ContributionIndex[]) public walletPools;\r\n\r\n    modifier contractNotPaused() {\r\n        require(paused == false, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier senderIsToken() {\r\n        require(msg.sender == address(token));\r\n        _;\r\n    }\r\n\r\n    function initialize(address _token) external onlyOwnerOrSuperOwner {\r\n        token = _token;\r\n        paused = false;\r\n        emit Initialize(_token);\r\n    }\r\n\r\n    function addPool(bytes32 _id, \r\n            address _destination, \r\n            uint _contributionStartUtc, \r\n            uint _contributionEndUtc, \r\n            uint _amountLimit, \r\n            address _prizeCalculator) \r\n        external \r\n        onlyOwnerOrSuperOwner \r\n        contractNotPaused {\r\n        \r\n        if (pools[_id].status == PoolStatus.NotSet) { // do not increase if update\r\n            totalPools++;\r\n        } \r\n        \r\n        pools[_id].contributionStartUtc = _contributionStartUtc;\r\n        pools[_id].contributionEndUtc = _contributionEndUtc;\r\n        pools[_id].destination = _destination;\r\n        pools[_id].status = PoolStatus.Active;\r\n        pools[_id].amountLimit = _amountLimit;\r\n        pools[_id].prizeCalculator = _prizeCalculator;\r\n        \r\n        emit PoolAdded(_id);\r\n    }\r\n\r\n    function updateDestination(bytes32 _id, \r\n            address _destination) \r\n        external \r\n        onlyOwnerOrSuperOwner \r\n        contractNotPaused {\r\n\r\n        pools[_id].destination = _destination;\r\n\r\n        emit PoolDestinationUpdated(_id);\r\n    }\r\n    \r\n    function setPoolStatus(bytes32 _poolId, PoolStatus _status) public onlyOwnerOrSuperOwner {\r\n        require(pools[_poolId].status != PoolStatus.NotSet, \"pool should be initialized\");\r\n        emit PoolStatusChange(_poolId,pools[_poolId].status, _status);\r\n        pools[_poolId].status = _status;\r\n    }\r\n    \r\n    // This method will be called for returning money when canceled or set everyone to take rewards by formula\r\n    function setPoolAmountDistributing(bytes32 _poolId, PoolStatus _poolStatus, uint _amountDistributing) external onlyOwnerOrSuperOwner {\r\n        setPoolStatus(_poolId, _poolStatus);\r\n        pools[_poolId].amountDistributing = _amountDistributing;\r\n    }\r\n\r\n    /// Called by token contract after Approval: this.TokenInstance.methods.approveAndCall()\r\n    // _data = poolId(32),contributionId(32)\r\n    function receiveApproval(address _from, uint _amountOfTokens, address _token, bytes _data) \r\n            external \r\n            senderIsToken\r\n            contractNotPaused {    \r\n        require(_amountOfTokens > 0, \"amount should be > 0\");\r\n        require(_from != address(0), \"not valid from\");\r\n        require(_data.length == 64, \"not valid _data length\");\r\n      \r\n        bytes32 poolIdString = bytesToFixedBytes32(_data,0);\r\n        bytes32 contributionIdString = bytesToFixedBytes32(_data,32);\r\n        \r\n        // Validate pool and Contribution\r\n        require(pools[poolIdString].status == PoolStatus.Active, \"Status should be active\");\r\n        require(pools[poolIdString].contributionStartUtc < now, \"Contribution is not started\");    \r\n        require(pools[poolIdString].contributionEndUtc > now, \"Contribution is ended\"); \r\n        require(pools[poolIdString].contributions[contributionIdString].amount == 0, 'Contribution duplicated');\r\n        require(pools[poolIdString].amountLimit == 0 ||\r\n                pools[poolIdString].amountLimit >= pools[poolIdString].amountCollected.add(_amountOfTokens), \"Contribution limit reached\"); \r\n        \r\n        // Transfer tokens from sender to this contract\r\n        require(IERC20(_token).transferFrom(_from, address(this), _amountOfTokens), \"Tokens transfer failed.\");\r\n\r\n        walletPools[_from].push(ContributionIndex(poolIdString, contributionIdString));\r\n        pools[poolIdString].amountCollected = pools[poolIdString].amountCollected.add(_amountOfTokens); \r\n        pools[poolIdString].contributions[contributionIdString].owner = _from;\r\n        pools[poolIdString].contributions[contributionIdString].amount = _amountOfTokens;\r\n\r\n        emit ContributionAdded(poolIdString, contributionIdString);\r\n    }\r\n    \r\n    function transferToDestination(bytes32 _poolId) external onlyOwnerOrSuperOwner {\r\n        assert(IERC20(token).transfer(pools[_poolId].destination, pools[_poolId].amountCollected));\r\n        setPoolStatus(_poolId,PoolStatus.Funding);\r\n    }\r\n    \r\n    function payout(bytes32 _poolId, bytes32 _contributionId) public contractNotPaused {\r\n        require(pools[_poolId].status == PoolStatus.Distributing, \"Pool should be Distributing\");\r\n        require(pools[_poolId].amountDistributing > pools[_poolId].paidout, \"Pool should be not empty\");\r\n        \r\n        Contribution storage con = pools[_poolId].contributions[_contributionId];\r\n        require(con.paidout == 0, \"Contribution already paidout\");\r\n        \r\n        IPrizeCalculator calculator = IPrizeCalculator(pools[_poolId].prizeCalculator);\r\n    \r\n        uint winAmount = calculator.calculatePrizeAmount(\r\n            pools[_poolId].amountDistributing,\r\n            pools[_poolId].amountCollected,  \r\n            con.amount\r\n        );\r\n      \r\n        assert(winAmount > 0);\r\n        con.paidout = winAmount;\r\n        pools[_poolId].paidout = pools[_poolId].paidout.add(winAmount);\r\n        assert(IERC20(token).transfer(con.owner, winAmount));\r\n        emit Paidout(_poolId, _contributionId);\r\n    }\r\n\r\n    function refund(bytes32 _poolId, bytes32 _contributionId) public contractNotPaused {\r\n        require(pools[_poolId].status == PoolStatus.Canceled, \"Pool should be canceled\");\r\n        require(pools[_poolId].amountDistributing > pools[_poolId].paidout, \"Pool should be not empty\");\r\n        \r\n        Contribution storage con = pools[_poolId].contributions[_contributionId];\r\n        require(con.paidout == 0, \"Contribution already paidout\");        \r\n        require(con.amount > 0, \"Contribution not valid\");   \r\n        require(con.owner != address(0), \"Owner not valid\"); \r\n\r\n        con.paidout = con.amount;\r\n        pools[_poolId].paidout = pools[_poolId].paidout.add(con.amount);\r\n        assert(IERC20(token).transfer(con.owner, con.amount));\r\n\r\n        emit Paidout(_poolId, _contributionId);\r\n    }\r\n\r\n    //////////\r\n    // Views\r\n    //////////\r\n    function getContribution(bytes32 _poolId, bytes32 _contributionId) public view returns(address, uint, uint) {\r\n        return (pools[_poolId].contributions[_contributionId].owner,\r\n            pools[_poolId].contributions[_contributionId].amount,\r\n            pools[_poolId].contributions[_contributionId].paidout);\r\n    }\r\n\r\n    // ////////\r\n    // Safety Methods\r\n    // ////////\r\n    function () public payable {\r\n        require(false);\r\n    }\r\n\r\n    function withdrawETH() external onlyOwnerOrSuperOwner {\r\n        uint balance = address(this).balance;\r\n        owner.transfer(balance);\r\n        emit Withdraw(balance);\r\n    }\r\n\r\n    function withdrawTokens(uint _amount, address _token) external onlyOwnerOrSuperOwner {\r\n        assert(IERC20(_token).transfer(owner, _amount));\r\n        emit Withdraw(_amount);\r\n    }\r\n\r\n    function pause(bool _paused) external onlyOwnerOrSuperOwner {\r\n        paused = _paused;\r\n    }\r\n\r\n    function bytesToFixedBytes32(bytes memory b, uint offset) internal pure returns (bytes32) {\r\n        bytes32 out;\r\n\r\n        for (uint i = 0; i < 32; i++) {\r\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"name\":\"transferToDestination\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletPools\",\"outputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\"},{\"name\":\"contributionId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExecutor\",\"type\":\"address\"}],\"name\":\"transferExecutorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"name\":\"_poolStatus\",\"type\":\"uint8\"},{\"name\":\"_amountDistributing\",\"type\":\"uint256\"}],\"name\":\"setPoolAmountDistributing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferSuperOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"name\":\"_contributionId\",\"type\":\"bytes32\"}],\"name\":\"getContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"setPoolStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"name\":\"_contributionId\",\"type\":\"bytes32\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPools\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"updateDestination\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_contributionStartUtc\",\"type\":\"uint256\"},{\"name\":\"_contributionEndUtc\",\"type\":\"uint256\"},{\"name\":\"_amountLimit\",\"type\":\"uint256\"},{\"name\":\"_prizeCalculator\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"contributionStartUtc\",\"type\":\"uint256\"},{\"name\":\"contributionEndUtc\",\"type\":\"uint256\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"amountLimit\",\"type\":\"uint256\"},{\"name\":\"amountCollected\",\"type\":\"uint256\"},{\"name\":\"amountDistributing\",\"type\":\"uint256\"},{\"name\":\"paidout\",\"type\":\"uint256\"},{\"name\":\"prizeCalculator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"name\":\"_contributionId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"PoolDestinationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_contributionId\",\"type\":\"bytes32\"}],\"name\":\"ContributionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_oldStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_newStatus\",\"type\":\"uint8\"}],\"name\":\"PoolStatusChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_contributionId\",\"type\":\"bytes32\"}],\"name\":\"Paidout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Pools","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c32155b17b9f5bf55891062eee7c9d88b79512782fade78df9df653c5efa9b7e"}]}