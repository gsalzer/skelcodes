{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n\r\n/**\r\n * @title Metamorphic Contract Factory\r\n * @author 0age\r\n * @notice This contract creates metamorphic contracts, or contracts that can be\r\n * redeployed with new code to the same address. It does so by deploying a\r\n * contract with fixed, non-deterministic initialization code via the CREATE2\r\n * opcode. This contract clones the implementation contract in its constructor.\r\n * Once a contract undergoes metamorphosis, all existing storage will be deleted\r\n * and any existing contract code will be replaced with the deployed contract\r\n * code of the new implementation contract.\r\n * @dev CREATE2 will not be available on mainnet until (at least) block\r\n * 7,280,000. This contract has not yet been fully tested or audited - proceed\r\n * with caution and please share any exploits or optimizations you discover.\r\n */\r\ncontract MetamorphicContractFactory {\r\n  // fires when a metamorphic contract is deployed by cloning another contract.\r\n  event Metamorphosed(address metamorphicContract, address newImplementation);\r\n  \r\n  // fires when a metamorphic contract is deployed through a transient contract.\r\n  event MetamorphosedWithConstructor(\r\n    address metamorphicContract,\r\n    address transientContract\r\n  );\r\n\r\n  // store the initialization code for metamorphic contracts.\r\n  bytes private _metamorphicContractInitializationCode;\r\n\r\n  // store hash of the initialization code for metamorphic contracts as well.\r\n  bytes32 private _metamorphicContractInitializationCodeHash;\r\n\r\n  // store init code for transient contracts that deploy metamorphic contracts.\r\n  bytes private _transientContractInitializationCode;\r\n\r\n  // store the hash of the initialization code for transient contracts as well.\r\n  bytes32 private _transientContractInitializationCodeHash;\r\n\r\n  // maintain a mapping of metamorphic contracts to metamorphic implementations.\r\n  mapping(address => address) private _implementations;\r\n\r\n  // maintain a mapping of transient contracts to metamorphic init codes.\r\n  mapping(address => bytes) private _initCodes;\r\n\r\n  /**\r\n   * @dev In the constructor, set up the initialization code for metamorphic\r\n   * contracts as well as the keccak256 hash of the given initialization code.\r\n   * @param transientContractInitializationCode bytes The initialization code\r\n   * that will be used to deploy any transient contracts, which will deploy any\r\n   * metamorphic contracts that require the use of a constructor.\r\n   * \r\n   * Metamorphic contract initialization code (29 bytes): \r\n   *\r\n   *       0x5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\r\n   *\r\n   * Description:\r\n   *\r\n   * pc|op|name         | [stack]                                | <memory>\r\n   *\r\n   * ** set the first stack item to zero - used later **\r\n   * 00 58 getpc          [0]                                       <>\r\n   *\r\n   * ** set second stack item to 32, length of word returned from staticcall **\r\n   * 01 60 push1\r\n   * 02 20 outsize        [0, 32]                                   <>\r\n   *\r\n   * ** set third stack item to 0, position of word returned from staticcall **\r\n   * 03 81 dup2           [0, 32, 0]                                <>\r\n   *\r\n   * ** set fourth stack item to 4, length of selector given to staticcall **\r\n   * 04 58 getpc          [0, 32, 0, 4]                             <>\r\n   *\r\n   * ** set fifth stack item to 28, position of selector given to staticcall **\r\n   * 05 60 push1\r\n   * 06 1c inpos          [0, 32, 0, 4, 28]                         <>\r\n   *\r\n   * ** set the sixth stack item to msg.sender, target address for staticcall **\r\n   * 07 33 caller         [0, 32, 0, 4, 28, caller]                 <>\r\n   *\r\n   * ** set the seventh stack item to msg.gas, gas to forward for staticcall **\r\n   * 08 5a gas            [0, 32, 0, 4, 28, caller, gas]            <>\r\n   *\r\n   * ** set the eighth stack item to selector, \"what\" to store via mstore **\r\n   * 09 63 push4\r\n   * 10 aaf10f42 selector [0, 32, 0, 4, 28, caller, gas, 0xaaf10f42]    <>\r\n   *\r\n   * ** set the ninth stack item to 0, \"where\" to store via mstore ***\r\n   * 11 87 dup8           [0, 32, 0, 4, 28, caller, gas, 0xaaf10f42, 0] <>\r\n   *\r\n   * ** call mstore, consume 8 and 9 from the stack, place selector in memory **\r\n   * 12 52 mstore         [0, 32, 0, 4, 0, caller, gas]             <0xaaf10f42>\r\n   *\r\n   * ** call staticcall, consume items 2 through 7, place address in memory **\r\n   * 13 fa staticcall     [0, 1 (if successful)]                    <address>\r\n   *\r\n   * ** flip success bit in second stack item to set to 0 **\r\n   * 14 15 iszero         [0, 0]                                    <address>\r\n   *\r\n   * ** push a third 0 to the stack, position of address in memory **\r\n   * 15 81 dup2           [0, 0, 0]                                 <address>\r\n   *\r\n   * ** place address from position in memory onto third stack item **\r\n   * 16 51 mload          [0, 0, address]                           <>\r\n   *\r\n   * ** place address to fourth stack item for extcodesize to consume **\r\n   * 17 80 dup1           [0, 0, address, address]                  <>\r\n   *\r\n   * ** get extcodesize on fourth stack item for extcodecopy **\r\n   * 18 3b extcodesize    [0, 0, address, size]                     <>\r\n   *\r\n   * ** dup and swap size for use by return at end of init code **\r\n   * 19 80 dup1           [0, 0, address, size, size]               <> \r\n   * 20 93 swap4          [size, 0, address, size, 0]               <>\r\n   *\r\n   * ** push code position 0 to stack and reorder stack items for extcodecopy **\r\n   * 21 80 dup1           [size, 0, address, size, 0, 0]            <>\r\n   * 22 91 swap2          [size, 0, address, 0, 0, size]            <>\r\n   * 23 92 swap3          [size, 0, size, 0, 0, address]            <>\r\n   *\r\n   * ** call extcodecopy, consume four items, clone runtime code to memory **\r\n   * 24 3c extcodecopy    [size, 0]                                 <code>\r\n   *\r\n   * ** return to deploy final code in memory **\r\n   * 25 f3 return         []                                        *deployed!*\r\n   *\r\n   *\r\n   * Transient contract initialization code derived from TransientContract.sol.\r\n   */\r\n  constructor(bytes memory transientContractInitializationCode) public {\r\n    // assign the initialization code for the metamorphic contract.\r\n    _metamorphicContractInitializationCode = (\r\n      hex\"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\"\r\n    );\r\n\r\n    // calculate and assign keccak256 hash of metamorphic initialization code.\r\n    _metamorphicContractInitializationCodeHash = keccak256(\r\n      abi.encodePacked(\r\n        _metamorphicContractInitializationCode\r\n      )\r\n    );\r\n\r\n    // store the initialization code for the transient contract.\r\n    _transientContractInitializationCode = transientContractInitializationCode;\r\n\r\n    // calculate and assign keccak256 hash of transient initialization code.\r\n    _transientContractInitializationCodeHash = keccak256(\r\n      abi.encodePacked(\r\n        _transientContractInitializationCode\r\n      )\r\n    );\r\n  }\r\n\r\n  /* solhint-disable function-max-lines */\r\n  /**\r\n   * @dev Deploy a metamorphic contract by submitting a given salt or nonce\r\n   * along with the initialization code for the metamorphic contract, and\r\n   * optionally provide calldata for initializing the new metamorphic contract.\r\n   * To replace the contract, first selfdestruct the current contract, then call\r\n   * with the same salt value and new initialization code (be aware that all\r\n   * existing state will be wiped from the existing contract). Also note that\r\n   * the first 20 bytes of the salt must match the calling address, which\r\n   * prevents contracts from being created by unintended parties.\r\n   * @param salt bytes32 The nonce that will be passed into the CREATE2 call and\r\n   * thus will determine the resulant address of the metamorphic contract.\r\n   * @param implementationContractInitializationCode bytes The initialization\r\n   * code for the implementation contract for the metamorphic contract. It will\r\n   * be used to deploy a new contract that the metamorphic contract will then\r\n   * clone in its constructor.\r\n   * @param metamorphicContractInitializationCalldata bytes An optional data\r\n   * parameter that can be used to atomically initialize the metamorphic\r\n   * contract.\r\n   * @return Address of the metamorphic contract that will be created.\r\n   */\r\n  function deployMetamorphicContract(\r\n    bytes32 salt,\r\n    bytes calldata implementationContractInitializationCode,\r\n    bytes calldata metamorphicContractInitializationCalldata\r\n  ) external payable containsCaller(salt) returns (\r\n    address metamorphicContractAddress\r\n  ) {\r\n    // move implementation init code and initialization calldata to memory.\r\n    bytes memory implInitCode = implementationContractInitializationCode;\r\n    bytes memory data = metamorphicContractInitializationCalldata;\r\n\r\n    // move the initialization code from storage to memory.\r\n    bytes memory initCode = _metamorphicContractInitializationCode;\r\n\r\n    // declare variable to verify successful metamorphic contract deployment.\r\n    address deployedMetamorphicContract;\r\n\r\n    // determine the address of the metamorphic contract.\r\n    metamorphicContractAddress = _getMetamorphicContractAddress(salt);\r\n\r\n    // declare a variable for the address of the implementation contract.\r\n    address implementationContract;\r\n\r\n    // load implementation init code and length, then deploy via CREATE.\r\n    /* solhint-disable no-inline-assembly */\r\n    assembly {\r\n      let encoded_data := add(0x20, implInitCode) // load initialization code.\r\n      let encoded_size := mload(implInitCode)     // load init code's length.\r\n      implementationContract := create(       // call CREATE with 3 arguments.\r\n        0,                                    // do not forward any endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size                          // pass in init code's length.\r\n      )\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    require(\r\n      implementationContract != address(0),\r\n      \"Could not deploy implementation.\"\r\n    );\r\n\r\n    // store the implementation to be retrieved by the metamorphic contract.\r\n    _implementations[metamorphicContractAddress] = implementationContract;\r\n\r\n    // load metamorphic contract data and length of data and deploy via CREATE2.\r\n    /* solhint-disable no-inline-assembly */\r\n    assembly {\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      deployedMetamorphicContract := create2( // call CREATE2 with 4 arguments.\r\n        0,                                    // do not forward any endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    // ensure that the contracts were successfully deployed.\r\n    require(\r\n      deployedMetamorphicContract == metamorphicContractAddress,\r\n      \"Failed to deploy the new metamorphic contract.\"\r\n    );\r\n\r\n    // initialize the new metamorphic contract if any data or value is provided.\r\n    if (data.length > 0 || msg.value > 0) {\r\n      /* solhint-disable avoid-call-value */\r\n      (bool success,) = deployedMetamorphicContract.call.value(msg.value)(data);\r\n      /* solhint-enable avoid-call-value */\r\n\r\n      require(success, \"Failed to initialize the new metamorphic contract.\");\r\n    }\r\n\r\n    emit Metamorphosed(deployedMetamorphicContract, implementationContract);\r\n  } /* solhint-enable function-max-lines */\r\n\r\n  /**\r\n   * @dev Deploy a metamorphic contract by submitting a given salt or nonce\r\n   * along with the address of an existing implementation contract to clone, and\r\n   * optionally provide calldata for initializing the new metamorphic contract.\r\n   * To replace the contract, first selfdestruct the current contract, then call\r\n   * with the same salt value and a new implementation address (be aware that\r\n   * all existing state will be wiped from the existing contract). Also note\r\n   * that the first 20 bytes of the salt must match the calling address, which\r\n   * prevents contracts from being created by unintended parties.\r\n   * @param salt bytes32 The nonce that will be passed into the CREATE2 call and\r\n   * thus will determine the resulant address of the metamorphic contract.\r\n   * @param implementationContract address The address of the existing\r\n   * implementation contract to clone.\r\n   * @param metamorphicContractInitializationCalldata bytes An optional data\r\n   * parameter that can be used to atomically initialize the metamorphic\r\n   * contract.\r\n   * @return Address of the metamorphic contract that will be created.\r\n   */\r\n  function deployMetamorphicContractFromExistingImplementation(\r\n    bytes32 salt,\r\n    address implementationContract,\r\n    bytes calldata metamorphicContractInitializationCalldata\r\n  ) external payable containsCaller(salt) returns (\r\n    address metamorphicContractAddress\r\n  ) {\r\n    // move initialization calldata to memory.\r\n    bytes memory data = metamorphicContractInitializationCalldata;\r\n\r\n    // move the initialization code from storage to memory.\r\n    bytes memory initCode = _metamorphicContractInitializationCode;\r\n\r\n    // declare variable to verify successful metamorphic contract deployment.\r\n    address deployedMetamorphicContract;\r\n\r\n    // determine the address of the metamorphic contract.\r\n    metamorphicContractAddress = _getMetamorphicContractAddress(salt);\r\n\r\n    // store the implementation to be retrieved by the metamorphic contract.\r\n    _implementations[metamorphicContractAddress] = implementationContract;\r\n\r\n    // using inline assembly: load data and length of data, then call CREATE2.\r\n    /* solhint-disable no-inline-assembly */\r\n    assembly {\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      deployedMetamorphicContract := create2( // call CREATE2 with 4 arguments.\r\n        0,                                    // do not forward any endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    // ensure that the contracts were successfully deployed.\r\n    require(\r\n      deployedMetamorphicContract == metamorphicContractAddress,\r\n      \"Failed to deploy the new metamorphic contract.\"\r\n    );\r\n\r\n    // initialize the new metamorphic contract if any data or value is provided.\r\n    if (data.length > 0 || msg.value > 0) {\r\n      /* solhint-disable avoid-call-value */\r\n      (bool success,) = metamorphicContractAddress.call.value(msg.value)(data);\r\n      /* solhint-enable avoid-call-value */\r\n\r\n      require(success, \"Failed to initialize the new metamorphic contract.\");\r\n    }\r\n\r\n    emit Metamorphosed(deployedMetamorphicContract, implementationContract);\r\n  }\r\n\r\n  /* solhint-disable function-max-lines */\r\n  /**\r\n   * @dev Deploy a metamorphic contract by submitting a given salt or nonce\r\n   * along with the initialization code to a transient contract which will then\r\n   * deploy the metamorphic contract before immediately selfdestructing. To\r\n   * replace the metamorphic contract, first selfdestruct the current contract,\r\n   * then call with the same salt value and new initialization code (be aware\r\n   * that all existing state will be wiped from the existing contract). Also\r\n   * note that the first 20 bytes of the salt must match the calling address,\r\n   * which prevents contracts from being created by unintended parties.\r\n   * @param salt bytes32 The nonce that will be passed into the CREATE2 call and\r\n   * thus will determine the resulant address of the metamorphic contract.\r\n   * @param initializationCode bytes The initialization code for the metamorphic\r\n   * contract that will be deployed by the transient contract.\r\n   * @return Address of the metamorphic contract that will be created.\r\n   */\r\n  function deployMetamorphicContractWithConstructor(\r\n    bytes32 salt,\r\n    bytes calldata initializationCode\r\n  ) external payable containsCaller(salt) returns (\r\n    address metamorphicContractAddress\r\n  ) {\r\n    // move transient contract initialization code from storage to memory.\r\n    bytes memory initCode = _transientContractInitializationCode;\r\n\r\n    // declare variable to verify successful transient contract deployment.\r\n    address deployedTransientContract;\r\n\r\n    // determine the address of the transient contract.\r\n    address transientContractAddress = _getTransientContractAddress(salt);\r\n\r\n    // store the initialization code to be retrieved by the transient contract.\r\n    _initCodes[transientContractAddress] = initializationCode;\r\n\r\n    // load transient contract data and length of data, then deploy via CREATE2.\r\n    /* solhint-disable no-inline-assembly */\r\n    assembly {\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      deployedTransientContract := create2(   // call CREATE2 with 4 arguments.\r\n        callvalue,                            // forward any supplied endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    // ensure that the contracts were successfully deployed.\r\n    require(\r\n      deployedTransientContract == transientContractAddress,\r\n      \"Failed to deploy metamorphic contract using given salt and init code.\"\r\n    );\r\n\r\n    metamorphicContractAddress = _getMetamorphicContractAddressWithConstructor(\r\n      transientContractAddress\r\n    );\r\n\r\n    emit MetamorphosedWithConstructor(\r\n      metamorphicContractAddress,\r\n      transientContractAddress\r\n    );\r\n  } /* solhint-enable function-max-lines */\r\n\r\n  /**\r\n   * @dev View function for retrieving the address of the implementation\r\n   * contract to clone. Called by the constructor of each metamorphic contract.\r\n   */\r\n  function getImplementation() external view returns (address implementation) {\r\n    return _implementations[msg.sender];\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the initialization code for a given\r\n   * metamorphic contract to deploy via a transient contract. Called by the\r\n   * constructor of each transient contract.\r\n   * @return The initialization code to use to deploy the metamorphic contract.\r\n   */\r\n  function getInitializationCode() external view returns (\r\n    bytes memory initializationCode\r\n  ) {\r\n    return _initCodes[msg.sender];\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the address of the current implementation\r\n   * contract of a given metamorphic contract, where the address of the contract\r\n   * is supplied as an argument. Be aware that the implementation contract has\r\n   * an independent state and may have been altered or selfdestructed from when\r\n   * it was last cloned by the metamorphic contract.\r\n   * @param metamorphicContractAddress address The address of the metamorphic\r\n   * contract.\r\n   * @return Address of the corresponding implementation contract.\r\n   */\r\n  function getImplementationContractAddress(\r\n    address metamorphicContractAddress\r\n  ) external view returns (address implementationContractAddress) {\r\n    return _implementations[metamorphicContractAddress];\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the initialization code for a given\r\n   * metamorphic contract instance deployed via a transient contract, where the address\r\n   * of the transient contract is supplied as an argument.\r\n   * @param transientContractAddress address The address of the transient\r\n   * contract that deployed the metamorphic contract.\r\n   * @return The initialization code used to deploy the metamorphic contract.\r\n   */\r\n  function getMetamorphicContractInstanceInitializationCode(\r\n    address transientContractAddress\r\n  ) external view returns (bytes memory initializationCode) {\r\n    return _initCodes[transientContractAddress];\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the metamorphic contract that will be created\r\n   * upon submitting a given salt to the contract.\r\n   * @param salt bytes32 The nonce passed into CREATE2 by metamorphic contract.\r\n   * @return Address of the corresponding metamorphic contract.\r\n   */\r\n  function findMetamorphicContractAddress(\r\n    bytes32 salt\r\n  ) external view returns (address metamorphicContractAddress) {\r\n    // determine the address where the metamorphic contract will be deployed.\r\n    metamorphicContractAddress = _getMetamorphicContractAddress(salt);\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the transient contract that will be created\r\n   * upon submitting a given salt to the contract.\r\n   * @param salt bytes32 The nonce passed into CREATE2 when deploying the\r\n   * transient contract.\r\n   * @return Address of the corresponding transient contract.\r\n   */\r\n  function findTransientContractAddress(\r\n    bytes32 salt\r\n  ) external view returns (address transientContractAddress) {\r\n    // determine the address where the transient contract will be deployed.\r\n    transientContractAddress = _getTransientContractAddress(salt);\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the metamorphic contract that will be created\r\n   * by the transient contract upon submitting a given salt to the contract.\r\n   * @param salt bytes32 The nonce passed into CREATE2 when deploying the\r\n   * transient contract.\r\n   * @return Address of the corresponding metamorphic contract.\r\n   */\r\n  function findMetamorphicContractAddressWithConstructor(\r\n    bytes32 salt\r\n  ) external view returns (address metamorphicContractAddress) {\r\n    // determine the address of the metamorphic contract.\r\n    metamorphicContractAddress = _getMetamorphicContractAddressWithConstructor(\r\n      _getTransientContractAddress(salt)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the initialization code of metamorphic\r\n   * contracts for purposes of verification.\r\n   */\r\n  function getMetamorphicContractInitializationCode() external view returns (\r\n    bytes memory metamorphicContractInitializationCode\r\n  ) {\r\n    return _metamorphicContractInitializationCode;\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the keccak256 hash of the initialization\r\n   * code of metamorphic contracts for purposes of verification.\r\n   */\r\n  function getMetamorphicContractInitializationCodeHash() external view returns (\r\n    bytes32 metamorphicContractInitializationCodeHash\r\n  ) {\r\n    return _metamorphicContractInitializationCodeHash;\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the initialization code of transient\r\n   * contracts for purposes of verification.\r\n   */\r\n  function getTransientContractInitializationCode() external view returns (\r\n    bytes memory transientContractInitializationCode\r\n  ) {\r\n    return _transientContractInitializationCode;\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the keccak256 hash of the initialization\r\n   * code of transient contracts for purposes of verification.\r\n   */\r\n  function getTransientContractInitializationCodeHash() external view returns (\r\n    bytes32 transientContractInitializationCodeHash\r\n  ) {\r\n    return _transientContractInitializationCodeHash;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a metamorphic contract address\r\n   * given a particular salt.\r\n   */\r\n  function _getMetamorphicContractAddress(\r\n    bytes32 salt\r\n  ) internal view returns (address) {\r\n    // determine the address of the metamorphic contract.\r\n    return address(\r\n      uint160(                      // downcast to match the address type.\r\n        uint256(                    // convert to uint to truncate upper digits.\r\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // pack all inputs to the hash together.\r\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\r\n              address(this),        // this contract will be the caller.\r\n              salt,                 // pass in the supplied salt value.\r\n              _metamorphicContractInitializationCodeHash // the init code hash.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a transient contract address\r\n   * given a particular salt.\r\n   */\r\n  function _getTransientContractAddress(\r\n    bytes32 salt\r\n  ) internal view returns (address) {\r\n    // determine the address of the transient contract.\r\n    return address(\r\n      uint160(                      // downcast to match the address type.\r\n        uint256(                    // convert to uint to truncate upper digits.\r\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // pack all inputs to the hash together.\r\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\r\n              address(this),        // this contract will be the caller.\r\n              salt,                 // pass in the supplied salt value.\r\n              _transientContractInitializationCodeHash // supply init code hash.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a metamorphic contract address\r\n   * that has been deployed via a transient contract given the address of the\r\n   * transient contract.\r\n   */\r\n  function _getMetamorphicContractAddressWithConstructor(\r\n    address transientContractAddress\r\n  ) internal pure returns (address) { \r\n    // determine the address of the metamorphic contract.\r\n    return address(\r\n      uint160(                          // downcast to match the address type.\r\n        uint256(                        // set to uint to truncate upper digits.\r\n          keccak256(                    // compute CREATE hash via RLP encoding.\r\n            abi.encodePacked(           // pack all inputs to the hash together.\r\n              byte(0xd6),               // first RLP byte.\r\n              byte(0x94),               // second RLP byte.\r\n              transientContractAddress, // called by the transient contract.\r\n              byte(0x01)                // nonce begins at 1 for contracts.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\r\n   * those of the calling account. This provides protection against the salt\r\n   * being stolen by frontrunners or other attackers.\r\n   * @param salt bytes32 The salt value to check against the calling address.\r\n   */\r\n  modifier containsCaller(bytes32 salt) {\r\n    // prevent contract submissions from being stolen from tx.pool by requiring\r\n    // that the first 20 bytes of the submitted salt match msg.sender.\r\n    require(\r\n      address(bytes20(salt)) == msg.sender,\r\n      \"Invalid salt - first 20 bytes of the salt must match calling address.\"\r\n    );\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTransientContractInitializationCodeHash\",\"outputs\":[{\"name\":\"transientContractInitializationCodeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransientContractInitializationCode\",\"outputs\":[{\"name\":\"transientContractInitializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"deployMetamorphicContractWithConstructor\",\"outputs\":[{\"name\":\"metamorphicContractAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationCode\",\"outputs\":[{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transientContractAddress\",\"type\":\"address\"}],\"name\":\"getMetamorphicContractInstanceInitializationCode\",\"outputs\":[{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMetamorphicContractInitializationCodeHash\",\"outputs\":[{\"name\":\"metamorphicContractInitializationCodeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findMetamorphicContractAddressWithConstructor\",\"outputs\":[{\"name\":\"metamorphicContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"implementationContractInitializationCode\",\"type\":\"bytes\"},{\"name\":\"metamorphicContractInitializationCalldata\",\"type\":\"bytes\"}],\"name\":\"deployMetamorphicContract\",\"outputs\":[{\"name\":\"metamorphicContractAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"implementationContract\",\"type\":\"address\"},{\"name\":\"metamorphicContractInitializationCalldata\",\"type\":\"bytes\"}],\"name\":\"deployMetamorphicContractFromExistingImplementation\",\"outputs\":[{\"name\":\"metamorphicContractAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findTransientContractAddress\",\"outputs\":[{\"name\":\"transientContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"name\":\"implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findMetamorphicContractAddress\",\"outputs\":[{\"name\":\"metamorphicContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"metamorphicContractAddress\",\"type\":\"address\"}],\"name\":\"getImplementationContractAddress\",\"outputs\":[{\"name\":\"implementationContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMetamorphicContractInitializationCode\",\"outputs\":[{\"name\":\"metamorphicContractInitializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"transientContractInitializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metamorphicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"Metamorphosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metamorphicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transientContract\",\"type\":\"address\"}],\"name\":\"MetamorphosedWithConstructor\",\"type\":\"event\"}]","ContractName":"MetamorphicContractFactory","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000108608060408190527f57b9f52300000000000000000000000000000000000000000000000000000000815260609033906357b9f5239060849060009060048186803b15801561004c57600080fd5b505afa158015610060573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561008957600080fd5b8101908080516401000000008111156100a157600080fd5b820160208101848111156100b457600080fd5b81516401000000008111828201871017156100ce57600080fd5b505092919050505090506000816020018251808234f0925050506001600160a01b0381166100fb57600080fd5b806001600160a01b0316fffe000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://40a2612c311743060c0acf5302091f118547c549d97d08e7c02535e3a4e3fc42"}]}