{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n/// @author The Calystral Team\r\n/// @title A subscriber contract\r\ncontract Whitelist {\r\n    /// This mapping contains the index and subscriber addresses.\r\n    mapping (uint => address) subscriberIndexToAddress;\r\n\r\n    /// This mapping contains the addresses and subscriber status.\r\n    mapping (address => uint) subscriberAddressToSubscribed;\r\n\r\n    /// The current subscriber index.\r\n    /// Caution: This wiil be likely unequal to the actual subscriber amount.\r\n    /// This will be used as the index of a new subscriber.\r\n    /// We start at 1 because 0 will be the indicator that an address is not a subscriber.\r\n    uint subscriberIndex = 1;\r\n\r\n    /// This event will be triggered when a subscription was done.\r\n    event OnSubscribed(address subscriberAddress);\r\n\r\n    /// This event will be triggered when a subscription was revoked.\r\n    event OnUnsubscribed(address subscriberAddress);\r\n\r\n    /// This modifier prevents other smart contracts from subscribing.\r\n    modifier isNotAContract(){\r\n        require (msg.sender == tx.origin, \"Contracts are not allowed to interact.\");\r\n        _;\r\n    }\r\n    \r\n    /// Fall back to the subscribe function if no specific function was called.\r\n    function() external {\r\n        subscribe();\r\n    }\r\n    \r\n    /// Gets the subscriber list.\r\n    function getSubscriberList() external view returns (address[] memory) {\r\n        uint subscriberListAmount = getSubscriberAmount();\r\n        \r\n        address[] memory subscriberList = new address[](subscriberListAmount);\r\n        uint subscriberListCounter = 0;\r\n        \r\n        /// Iterate over all subscriber addresses, to fill the subscriberList.\r\n        for (uint i = 1; i < subscriberIndex; i++) {\r\n            address subscriberAddress = subscriberIndexToAddress[i];\r\n\r\n            /// Add the addresses which are actual subscribers only.\r\n            if (isSubscriber(subscriberAddress) == true) {\r\n                subscriberList[subscriberListCounter] = subscriberAddress;\r\n                subscriberListCounter++;\r\n            }\r\n        }\r\n\r\n        return subscriberList;\r\n    }\r\n\r\n    /// Gets the amount of subscriber.\r\n    function getSubscriberAmount() public view returns (uint) {\r\n        uint subscriberListAmount = 0;\r\n\r\n        /// Iterate over all subscriber addresses, to get the actual subscriber amount.\r\n        for (uint i = 1; i < subscriberIndex; i++) {\r\n            address subscriberAddress = subscriberIndexToAddress[i];\r\n            \r\n            /// Count the addresses which are actual subscribers only.\r\n            if (isSubscriber(subscriberAddress) == true) {\r\n                subscriberListAmount++;\r\n            }\r\n        }\r\n\r\n        return subscriberListAmount;\r\n    }\r\n\r\n    /// The sender's address will be added to the subscriber list\r\n    function subscribe() public isNotAContract {\r\n        require(isSubscriber(msg.sender) == false, \"You already subscribed.\");\r\n        \r\n        // New subscriber\r\n        subscriberAddressToSubscribed[msg.sender] = subscriberIndex;\r\n        subscriberIndexToAddress[subscriberIndex] = msg.sender;\r\n        subscriberIndex++;\r\n\r\n        emit OnSubscribed(msg.sender);\r\n    }\r\n\r\n    /// The sender's subscribtion will be revoked.\r\n    function unsubscribe() external isNotAContract {\r\n        require(isSubscriber(msg.sender) == true, \"You have not subscribed yet.\");\r\n\r\n        uint index = subscriberAddressToSubscribed[msg.sender];\r\n        delete subscriberIndexToAddress[index];\r\n\r\n        emit OnUnsubscribed(msg.sender);\r\n    }\r\n    \r\n    /// Checks wheter the transaction origin address is in the subscriber list\r\n    function isSubscriber() external view returns (bool) {\r\n        return isSubscriber(tx.origin);\r\n    }\r\n\r\n    /// Checks wheter the given address is in the subscriber list\r\n    function isSubscriber(address subscriberAddress) public view returns (bool) {\r\n        return subscriberIndexToAddress[subscriberAddressToSubscribed[subscriberAddress]] != address(0);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getSubscriberAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSubscriber\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSubscriberList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"subscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriberAddress\",\"type\":\"address\"}],\"name\":\"isSubscriber\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unsubscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"subscriberAddress\",\"type\":\"address\"}],\"name\":\"OnSubscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"subscriberAddress\",\"type\":\"address\"}],\"name\":\"OnUnsubscribed\",\"type\":\"event\"}]","ContractName":"Whitelist","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3041e3c29dabd5cb2867a06109783ea68e825983169f91b10904647ef4330653"}]}