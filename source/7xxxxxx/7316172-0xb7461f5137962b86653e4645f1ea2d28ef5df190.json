{"status":"1","message":"OK","result":[{"SourceCode":"{\"Adbank.sol\":{\"content\":\"pragma solidity 0.5.0;\\r\\n\\r\\ncontract Adbank {\\r\\n\\r\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\r\\n    function transfer(address _to, uint _amount) public returns (bool ok);\\r\\n}\\r\\n\"},\"AdbankRewardClaimContract.sol\":{\"content\":\"pragma solidity 0.5.0;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./RewardContract.sol\\\";\\r\\nimport \\\"./Adbank.sol\\\";\\r\\n\\r\\ncontract AdbankRewardClaimContract is RewardContract {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // Stop contract from executing it\\u0027s main logic\\r\\n    bool public suspended;\\r\\n\\r\\n    // Limit the size of incoming requests (assignRewards and claimRewards functions)\\r\\n    uint8 public batchLimit;\\r\\n\\r\\n    address public owner;\\r\\n    mapping(bytes32 =\\u003e uint256) public balances;\\r\\n    uint256 public totalReward;\\r\\n\\r\\n    // AdBank contract that is used for the actual transfers\\r\\n    Adbank public adbankContract;\\r\\n\\r\\n    // Functions with this modifier can only be executed by the owner\\r\\n    modifier onlyOwner() {\\r\\n        require (msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Functions with this modifier can only be executed if execution is not suspended\\r\\n    modifier notSuspended() {\\r\\n        require (suspended == false);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _adbankContract, uint8 _batchLimit) public {\\r\\n        owner = msg.sender;\\r\\n        suspended = false;\\r\\n        totalReward = 0;\\r\\n        adbankContract = Adbank(_adbankContract);\\r\\n        batchLimit = _batchLimit;\\r\\n    }\\r\\n\\r\\n    // Suspend / resume the execution of contract methods\\r\\n    function suspend(bool _suspended) external onlyOwner {\\r\\n        suspended = _suspended;\\r\\n    }\\r\\n\\r\\n    // Change owner\\r\\n    function changeOwner(address _newOwner) external onlyOwner {\\r\\n        require(_newOwner != address(0x0));\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    // Drain all funds. Returns tokens to the contract owner\\r\\n    function drain() external onlyOwner {\\r\\n        uint256 contractBalance = adbankContract.balanceOf(address(this));\\r\\n        require(contractBalance \\u003e 0);\\r\\n\\r\\n        require(transferReward(owner, contractBalance));\\r\\n        suspended = true;\\r\\n    }\\r\\n\\r\\n    // Change the requests limit\\r\\n    function setBatchLimit(uint8 newLimit) onlyOwner external {\\r\\n        require(newLimit \\u003e 0);\\r\\n        batchLimit = newLimit;\\r\\n    }\\r\\n\\r\\n    // Change the Adbank contract\\r\\n    function setAdbankContract(address _adbankContract) onlyOwner external {\\r\\n        require(_adbankContract != address(0x0));\\r\\n        adbankContract = Adbank(_adbankContract);\\r\\n    }\\r\\n\\r\\n    // Get user balance according to user\\u0027s blade id\\r\\n    function balanceOf(bytes32 _bladeId) public view returns (uint256 balance) {\\r\\n        return balances[_bladeId];\\r\\n    }\\r\\n\\r\\n    // Assign rewards according to user\\u0027s blade ids.\\r\\n    // The size of incoming data is limited to be in (0;batchLimit] range\\r\\n    // Requires this contract to have token balance to cover the incoming rewards\\r\\n    function assignRewards(bytes32[] calldata _bladeIds, uint256[] calldata _rewards) notSuspended onlyOwner external {\\r\\n        require(_bladeIds.length \\u003e 0 \\u0026\\u0026 _bladeIds.length \\u003c= batchLimit);\\r\\n        require(_bladeIds.length == _rewards.length);\\r\\n\\r\\n        for (uint8 i = 0; i \\u003c _bladeIds.length; i++) {\\r\\n            balances[_bladeIds[i]] = (balances[_bladeIds[i]]).add(_rewards[i]);\\r\\n            totalReward = (totalReward).add(_rewards[i]);\\r\\n            emit RewardAssigned(_bladeIds[i], _rewards[i]);\\r\\n        }\\r\\n\\r\\n        require(hasEnoughBalance());\\r\\n    }\\r\\n\\r\\n    // Claim rewards according to user\\u0027s blade ids.\\r\\n    // The size of incoming data is limited to be in (0;batchLimit] range\\r\\n    // Requires this contract to have token balance to cover the rewards\\r\\n    function claimRewards(bytes32[] calldata _bladeIds, address[] calldata _wallets) notSuspended onlyOwner external {\\r\\n        require(_bladeIds.length \\u003e 0 \\u0026\\u0026 _bladeIds.length \\u003c= batchLimit);\\r\\n        require(_bladeIds.length == _wallets.length);\\r\\n\\r\\n        require(hasEnoughBalance());\\r\\n\\r\\n        for (uint8 i = 0; i \\u003c _bladeIds.length; i++) {\\r\\n            processReward(_bladeIds[i], _wallets[i], false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Claim reward for the specified user\\r\\n    function claimReward(bytes32 _bladeId, address _to) notSuspended onlyOwner external returns (bool ok) {\\r\\n        return processReward(_bladeId, _to, true);\\r\\n    }\\r\\n\\r\\n    // Send the reward and return result.\\r\\n    // Will throw exception or skip the execution depending on the _requireValid param\\r\\n    function processReward(bytes32 _bladeId, address _to, bool _requireValid) notSuspended onlyOwner internal returns (bool ok) {\\r\\n        bool valid = validAddressAndBalance(_to, _bladeId);\\r\\n\\r\\n        if (_requireValid) {\\r\\n            require(valid);\\r\\n        } else if (!valid) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        uint256 rewardToSend = balances[_bladeId];\\r\\n\\r\\n        balances[_bladeId] = 0;\\r\\n        totalReward = (totalReward).sub(rewardToSend);\\r\\n\\r\\n        bool transferStatus = transferReward(_to, rewardToSend);\\r\\n        emit RewardClaimed(_bladeId, _to, rewardToSend);\\r\\n        return transferStatus;\\r\\n    }\\r\\n\\r\\n    // Do the actual transfer of the reward to the specified address\\r\\n    function transferReward(address _to, uint256 _amount) onlyOwner internal returns (bool ok) {\\r\\n        bool result = adbankContract.transfer(_to, _amount);\\r\\n        require(result);\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    // Check that address is valid, user has balance and contract has enough balance\\r\\n    function validAddressAndBalance(address _address, bytes32 _bladeId) internal view returns (bool valid) {\\r\\n        if (_address != address(0x0) \\u0026\\u0026 balances[_bladeId] \\u003e 0) {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // Check that contract has enough tokens to cover transactions with rewards\\r\\n    function hasEnoughBalance() public view returns (bool enoughBalance) {\\r\\n        return adbankContract.balanceOf(address(this)) \\u003e= totalReward;\\r\\n    }\\r\\n}\\r\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\ncontract Migrations {\\r\\n  address public owner;\\r\\n  uint public last_completed_migration;\\r\\n\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  modifier restricted() {\\r\\n    if (msg.sender == owner) _;\\r\\n  }\\r\\n\\r\\n  function setCompleted(uint completed) public restricted {\\r\\n    last_completed_migration = completed;\\r\\n  }\\r\\n\\r\\n  function upgrade(address new_address) public restricted {\\r\\n    Migrations upgraded = Migrations(new_address);\\r\\n    upgraded.setCompleted(last_completed_migration);\\r\\n  }\\r\\n}\\r\\n\"},\"RewardContract.sol\":{\"content\":\"pragma solidity 0.5.0;\\r\\n\\r\\ncontract RewardContract {\\r\\n    function balanceOf(bytes32 _bladeId) public view returns (uint256 balance);\\r\\n    function assignRewards(bytes32[] calldata _bladeIds, uint256[] calldata _rewards) external;\\r\\n    function claimRewards(bytes32[] calldata _bladeIds, address[] calldata _wallets) external;\\r\\n    function claimReward(bytes32 _bladeId, address _to) external returns (bool ok);\\r\\n\\r\\n    event RewardClaimed(bytes32 _bladeId, address _wallet, uint256 _amount);\\r\\n    event RewardAssigned(bytes32 _bladeId, uint256 _amount);\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_bladeIds\",\"type\":\"bytes32[]\"},{\"name\":\"_rewards\",\"type\":\"uint256[]\"}],\"name\":\"assignRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bladeIds\",\"type\":\"bytes32[]\"},{\"name\":\"_wallets\",\"type\":\"address[]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnoughBalance\",\"outputs\":[{\"name\":\"enoughBalance\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bladeId\",\"type\":\"bytes32\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"suspended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adbankContract\",\"type\":\"address\"}],\"name\":\"setAdbankContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_suspended\",\"type\":\"bool\"}],\"name\":\"suspend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLimit\",\"type\":\"uint8\"}],\"name\":\"setBatchLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adbankContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bladeId\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_adbankContract\",\"type\":\"address\"},{\"name\":\"_batchLimit\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_bladeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_bladeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"RewardAssigned\",\"type\":\"event\"}]","ContractName":"AdbankRewardClaimContract","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002baac9330cf9ac479d819195794d79ad0c7616e30000000000000000000000000000000000000000000000000000000000000064","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8af8f747c187931e8c33540ceafeb50c52d60ff179cf6e932de50147b0117860"}]}