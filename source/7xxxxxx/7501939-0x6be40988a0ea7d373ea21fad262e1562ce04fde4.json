{"status":"1","message":"OK","result":[{"SourceCode":"// File: soltsice/contracts/MultiOwnable.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/*\r\n * A minimum multisig wallet interface. Compatible with MultiSigWallet by Gnosis.\r\n */\r\ncontract WalletBasic {\r\n    function isOwner(address owner) public returns (bool);\r\n}\r\n\r\n/**\r\n * @dev MultiOwnable contract.\r\n */\r\ncontract MultiOwnable {\r\n    \r\n    WalletBasic public wallet;\r\n    \r\n    event MultiOwnableWalletSet(address indexed _contract, address indexed _wallet);\r\n\r\n    function MultiOwnable \r\n        (address _wallet)\r\n        public\r\n    {\r\n        wallet = WalletBasic(_wallet);\r\n        MultiOwnableWalletSet(this, wallet);\r\n    }\r\n\r\n    /** Check if a caller is the MultiSig wallet. */\r\n    modifier onlyWallet() {\r\n        require(wallet == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /** Check if a caller is one of the current owners of the MultiSig wallet or the wallet itself. */\r\n    modifier onlyOwner() {\r\n        require (isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isOwner(address _address) \r\n        public\r\n        constant\r\n        returns(bool)\r\n    {\r\n        // NB due to lazy eval wallet could be a normal address and isOwner won't be called if the first condition is met\r\n        return wallet == _address || wallet.isOwner(_address);\r\n    }\r\n\r\n\r\n    /* PAUSABLE with upause callable only by wallet */ \r\n\r\n    bool public paused = false;\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by any MSW owner to pause, triggers stopped state\r\n    */\r\n    function pause() \r\n        onlyOwner\r\n        whenNotPaused \r\n        public \r\n    {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the MSW (all owners) to unpause, returns to normal state\r\n    */\r\n    function unpause() \r\n        onlyWallet\r\n        whenPaused\r\n        public\r\n    {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// File: soltsice/contracts/BotManageable.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @dev BotManaged contract provides a modifier isBot and methods to enable/disable bots.\r\n */\r\ncontract BotManageable is MultiOwnable {\r\n    uint256 constant MASK64 = 18446744073709551615;\r\n\r\n    // NB packing saves gas even in memory due to stack size\r\n    // struct StartEndTimeLayout {\r\n    //     uint64 startTime;\r\n    //     uint64 endTime;\r\n    // }\r\n\r\n    /**\r\n     * Bot addresses and their start/end times (two uint64 timestamps)\r\n     */\r\n    mapping (address => uint128) internal botsStartEndTime;\r\n\r\n    event BotsStartEndTimeChange(address indexed _botAddress, uint64 _startTime, uint64 _endTime);\r\n\r\n    function BotManageable \r\n        (address _wallet)\r\n        public\r\n        MultiOwnable(_wallet)\r\n    { }\r\n\r\n    /** Check if a caller is an active bot. */\r\n    modifier onlyBot() {\r\n        require (isBot(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /** Check if a caller is an active bot or an owner or the wallet. */\r\n    modifier onlyBotOrOwner() {\r\n        require (isBot(msg.sender) || isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /** Enable bot address. */\r\n    function enableBot(address _botAddress)\r\n        onlyWallet()\r\n        public \r\n    {\r\n        uint128 botLifetime = botsStartEndTime[_botAddress];\r\n        // cannot re-enable existing bot\r\n        require((botLifetime >> 64) == 0 && (botLifetime & MASK64) == 0);\r\n        botLifetime |= uint128(now) << 64;\r\n        botsStartEndTime[_botAddress] = botLifetime;\r\n        BotsStartEndTimeChange(_botAddress, uint64(botLifetime >> 64), uint64(botLifetime & MASK64));\r\n    }\r\n\r\n    /** Disable bot address. */\r\n    function disableBot(address _botAddress, uint64 _fromTimeStampSeconds)\r\n        onlyOwner()\r\n        public \r\n    {\r\n        uint128 botLifetime = botsStartEndTime[_botAddress];\r\n        // bot must have been enabled previously and not disabled before\r\n        require((botLifetime >> 64) > 0 && (botLifetime & MASK64) == 0);\r\n        botLifetime |= uint128(_fromTimeStampSeconds);\r\n        botsStartEndTime[_botAddress] = botLifetime;\r\n        BotsStartEndTimeChange(_botAddress, uint64(botLifetime >> 64), uint64(botLifetime & MASK64));\r\n    }\r\n\r\n    /** Operational contracts call this method to check if a caller is an approved bot. */\r\n    function isBot(address _botAddress) \r\n        public\r\n        constant\r\n        returns(bool)\r\n    {\r\n        return isBotAt(_botAddress, uint64(now));\r\n    }\r\n\r\n    // truffle-contract doesn't like method overloading, use a different name\r\n\r\n    function isBotAt(address _botAddress, uint64 _atTimeStampSeconds) \r\n        public\r\n        constant \r\n        returns(bool)\r\n    {\r\n        uint128 botLifetime = botsStartEndTime[_botAddress];\r\n        if ((botLifetime >> 64) == 0 || (botLifetime >> 64) > _atTimeStampSeconds) {\r\n            return false;\r\n        }\r\n        if ((botLifetime & MASK64) == 0) {\r\n            return true;\r\n        }\r\n        if (_atTimeStampSeconds < (botLifetime & MASK64)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/Auction.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract AuctionHub is BotManageable {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     *  Data structures\r\n     */\r\n    \r\n    struct TokenBalance {\r\n        address token;\r\n        uint256 value;\r\n    }\r\n\r\n    struct TokenRate {\r\n        uint256 value;\r\n        uint256 decimals;\r\n    }\r\n\r\n    struct BidderState {\r\n        uint256 etherBalance;\r\n        uint256 tokensBalanceInEther;\r\n        //uint256 managedBid;\r\n        TokenBalance[] tokenBalances;        \r\n        uint256 etherBalanceInUsd; // (decimals = 2)\r\n        uint256 tokensBalanceInUsd; // (decimals = 2)\r\n        //uint256 managedBidInUsd;\r\n    }\r\n\r\n    struct ActionState {\r\n        uint256 endSeconds; // end time in Unix seconds, 1514160000 for Dec 25, 2017 (need to double check!)\r\n        uint256 maxTokenBidInEther; // максимальная ставка токенов в эфире. Думаю убрать это ограничение.\r\n        uint256 minPrice; // минимальная цена лота в WEI\r\n        \r\n        uint256 highestBid; \r\n        \r\n        // next 5 fields should be packed into one 32-bytes slot\r\n        address highestBidder;\r\n        //uint64 highestManagedBidder;\r\n        //bool allowManagedBids;\r\n        bool cancelled;\r\n        bool finalized;        \r\n\r\n        uint256 maxTokenBidInUsd; // max token bid in usd (decimals = 2)\r\n        uint256 highestBidInUsd; // highest bid in usd (decimals = 2)\r\n        address highestBidderInUsd; // highest bidder address in usd (decimals = 2)\r\n        //uint64 highestManagedBidderInUsd; // highest manage bid in usd\r\n\r\n        mapping(address => BidderState) bidderStates;\r\n\r\n        bytes32 item;       \r\n    }\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(address => ActionState) public auctionStates;\r\n    mapping(address => TokenRate) public tokenRates;    \r\n    // ether rate in usd\r\n    uint256 public etherRate;\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n\r\n    event NewAction(address indexed auction, string item);\r\n    event Bid(address indexed auction, address bidder, uint256 totalBidInEther, uint256 indexed tokensBidInEther, uint256 totalBidInUsd, uint256 indexed tokensBidInUsd);\r\n    event TokenBid(address indexed auction, address bidder, address token, uint256 numberOfTokens);\r\n    //event ManagedBid(address indexed auction, uint64 bidder, uint256 bid, address knownManagedBidder);\r\n    //event NewHighestBidder(address indexed auction, address bidder, uint64 managedBidder, uint256 totalBid);\r\n    event NewHighestBidder(address indexed auction, address bidder, uint256 totalBid);\r\n    //event NewHighestBidderInUsd(address indexed auction, address bidder, uint64 managedBidderInUsd, uint256 totalBidInUsd);\r\n    event NewHighestBidderInUsd(address indexed auction, address bidder, uint256 totalBidInUsd);\r\n    event TokenRateUpdate(address indexed token, uint256 rate);\r\n    event EtherRateUpdate(uint256 rate); // in usdt\r\n    event Withdrawal(address indexed auction, address bidder, uint256 etherAmount, uint256 tokensBidInEther);\r\n    event Charity(address indexed auction, address bidder, uint256 etherAmount, uint256 tokensAmount); // not used\r\n    //event Finalized(address indexed auction, address highestBidder, uint64 highestManagedBidder, uint256 amount);\r\n    event Finalized(address indexed auction, address highestBidder, uint256 amount);\r\n    event FinalizedInUsd(address indexed auction, address highestBidderInUsd, uint256 amount);\r\n    event FinalizedTokenTransfer(address indexed auction, address token, uint256 tokensBidInEther);\r\n    event FinalizedEtherTransfer(address indexed auction, uint256 etherAmount);\r\n    event ExtendedEndTime(address indexed auction, uint256 newEndtime);\r\n    event Cancelled(address indexed auction);\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n\r\n    modifier onlyActive {\r\n        // NB this modifier also serves as check that an auction exists (otherwise endSeconds == 0)\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        require (now < auctionState.endSeconds && !auctionState.cancelled);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeEnd {\r\n        // NB this modifier also serves as check that an auction exists (otherwise endSeconds == 0)\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        require (now < auctionState.endSeconds);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterEnd {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        require (now > auctionState.endSeconds && auctionState.endSeconds > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotCancelled {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        require (!auctionState.cancelled);\r\n        _;\r\n    }\r\n\r\n    /*modifier onlyAllowedManagedBids {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        require (auctionState.allowManagedBids);\r\n        _;\r\n    }*/\r\n\r\n    /*\r\n     * _rates are per big token (e.g. Ether vs. wei), i.e. number of wei per [number of tokens]*[10 ** decimals]\r\n     */\r\n    function AuctionHub \r\n        (address _wallet, address[] _tokens, uint256[] _rates, uint256[] _decimals, uint256 _etherRate)\r\n        public\r\n        BotManageable(_wallet)\r\n    {\r\n        // make sender a bot to avoid an additional step\r\n        botsStartEndTime[msg.sender] = uint128(now) << 64;\r\n\r\n        require(_tokens.length == _rates.length);\r\n        require(_tokens.length == _decimals.length);\r\n\r\n        // save initial token list\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            require(_tokens[i] != 0x0);\r\n            require(_rates[i] > 0);\r\n            ERC20Basic token = ERC20Basic(_tokens[i]);\r\n            tokenRates[token] = TokenRate(_rates[i], _decimals[i]);\r\n            emit TokenRateUpdate(token, _rates[i]);\r\n        }\r\n\r\n        // save ether rate in usd\r\n        require(_etherRate > 0);\r\n        etherRate = _etherRate;\r\n        emit EtherRateUpdate(_etherRate);\r\n    }\r\n\r\n    function stringToBytes32(string memory source) returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function createAuction(\r\n        uint _endSeconds, \r\n        uint256 _maxTokenBidInEther,\r\n        uint256 _minPrice,\r\n        string _item\r\n        //bool _allowManagedBids\r\n    )\r\n        onlyBot\r\n        public\r\n        returns (address)\r\n    {\r\n        require (_endSeconds > now);\r\n        require(_maxTokenBidInEther <= 1000 ether);\r\n        require(_minPrice > 0);\r\n\r\n        Auction auction = new Auction(this);\r\n\r\n        ActionState storage auctionState = auctionStates[auction];\r\n\r\n        auctionState.endSeconds = _endSeconds;\r\n        auctionState.maxTokenBidInEther = _maxTokenBidInEther;\r\n        // пока не используется в коде\r\n        auctionState.maxTokenBidInUsd = _maxTokenBidInEther.mul(etherRate).div(10 ** 2);\r\n        auctionState.minPrice = _minPrice;\r\n        //auctionState.allowManagedBids = _allowManagedBids;\r\n        string memory item = _item;\r\n        auctionState.item = stringToBytes32(item);\r\n\r\n        emit NewAction(auction, _item);\r\n        return address(auction);\r\n    }\r\n\r\n    function () \r\n        payable\r\n        public\r\n    {\r\n        throw;\r\n        // It's charity!\r\n        // require(wallet.send(msg.value));\r\n        // Charity(0x0, msg.sender, msg.value, 0);\r\n    }\r\n\r\n    function bid(address _bidder, uint256 _value, address _token, uint256 _tokensNumber)\r\n        // onlyActive - inline check to reuse auctionState variable\r\n        public\r\n        returns (bool isHighest, bool isHighestInUsd)\r\n    {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        // same as onlyActive modifier, but we already have a variable here\r\n        require (now < auctionState.endSeconds && !auctionState.cancelled);\r\n\r\n        BidderState storage bidderState = auctionState.bidderStates[_bidder];\r\n        \r\n        uint256 totalBid;\r\n        uint256 totalBidInUsd;\r\n\r\n        if (_tokensNumber > 0) {\r\n            (totalBid, totalBidInUsd) = tokenBid(msg.sender, _bidder,  _token, _tokensNumber);\r\n        }else {\r\n            require(_value > 0);\r\n\r\n            // NB if current token bid == 0 we still could have previous token bids\r\n            (totalBid, totalBidInUsd) = (bidderState.tokensBalanceInEther, bidderState.tokensBalanceInUsd);\r\n        }\r\n\r\n        uint256 etherBid = bidderState.etherBalance + _value;\r\n        // error \"CompilerError: Stack too deep, try removing local variables\"\r\n        \r\n        bidderState.etherBalance = etherBid;      \r\n\r\n        //totalBid = totalBid + etherBid + bidderState.managedBid;\r\n        totalBid = totalBid + etherBid;\r\n        //totalBidInUsd = totalBidInUsd + etherBidInUsd + bidderState.managedBidInUsd;\r\n        \r\n\r\n        if (totalBid > auctionState.highestBid && totalBid >= auctionState.minPrice) {\r\n            auctionState.highestBid = totalBid;\r\n            auctionState.highestBidder = _bidder;\r\n            //auctionState.highestManagedBidder = 0;\r\n            emit NewHighestBidder(msg.sender, _bidder, totalBid);\r\n            if ((auctionState.endSeconds - now) < 1800) {\r\n                /*uint256 newEnd = now + 1800;\r\n                auctionState.endSeconds = newEnd;\r\n                ExtendedEndTime(msg.sender, newEnd);*/\r\n                //uint256 newEnd = now + 1800;\r\n                // убираем увеличение времени аукциона на 30 мин. при высокой ставки в Ether\r\n                /*auctionState.endSeconds = now + 1800;\r\n                ExtendedEndTime(msg.sender, auctionState.endSeconds);*/\r\n            }\r\n            isHighest = true;\r\n        }\r\n\r\n        /*    \r\n        uint256 etherBidInUsd = bidderState.etherBalanceInUsd + _value.mul(etherRate);\r\n        bidderState.etherBalanceInUsd = etherBidInUsd;\r\n        totalBidInUsd = totalBidInUsd + etherBidInUsd;*/\r\n        uint256 etherBidInUsd = bidderState.etherBalanceInUsd + _value.mul(etherRate).div(10 ** 2);\r\n        bidderState.etherBalanceInUsd = etherBidInUsd;\r\n        totalBidInUsd = totalBidInUsd + etherBidInUsd;\r\n\r\n        if (totalBidInUsd > auctionState.highestBidInUsd && totalBidInUsd >= auctionState.minPrice.mul(etherRate).div(10 ** 2)) {\r\n            auctionState.highestBidInUsd = totalBidInUsd;\r\n            auctionState.highestBidderInUsd = _bidder;\r\n            //auctionState.highestManagedBidderInUsd = 0;\r\n            emit NewHighestBidderInUsd(msg.sender, _bidder, totalBidInUsd);\r\n            if ((auctionState.endSeconds - now) < 1800) {\r\n                //uint256 newEndUsd = now + 1800;\r\n                //auctionState.endSeconds = newEndUsd;\r\n                //ExtendedEndTime(msg.sender, newEndUsd);\r\n                //uint256 newEndUsd = now + 1800;\r\n                auctionState.endSeconds = now + 1800;\r\n                emit ExtendedEndTime(msg.sender, auctionState.endSeconds);\r\n            }\r\n            isHighestInUsd = true;\r\n        }\r\n\r\n        emit Bid(msg.sender, _bidder, totalBid, totalBid - etherBid, totalBidInUsd, totalBidInUsd - etherBidInUsd);        \r\n\r\n        return (isHighest, isHighestInUsd);\r\n    }\r\n\r\n    function tokenBid(address _auction, address _bidder, address _token, uint256 _tokensNumber)\r\n        internal\r\n        returns (uint256 tokenBid, uint256 tokenBidInUsd)\r\n    {\r\n        // NB actual token transfer happens in auction contracts, which owns both ether and tokens\r\n        // This Hub contract is for accounting\r\n\r\n        ActionState storage auctionState = auctionStates[_auction];\r\n        BidderState storage bidderState = auctionState.bidderStates[_bidder];\r\n        \r\n        uint256 totalBid = bidderState.tokensBalanceInEther;\r\n        uint256 totalBidInUsd = bidderState.tokensBalanceInUsd;\r\n\r\n        TokenRate storage tokenRate = tokenRates[_token];\r\n        require(tokenRate.value > 0);\r\n\r\n        // find token index\r\n        uint256 index = bidderState.tokenBalances.length;\r\n        for (uint i = 0; i < index; i++) {\r\n            if (bidderState.tokenBalances[i].token == _token) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // array was empty/token not found - push empty to the end\r\n        if (index == bidderState.tokenBalances.length) {\r\n            bidderState.tokenBalances.push(TokenBalance(_token, _tokensNumber));\r\n        } else {\r\n            // safe math is already in transferFrom\r\n            bidderState.tokenBalances[index].value += _tokensNumber;\r\n        }\r\n        \r\n        //totalBid = totalBid + _tokensNumber.mul(tokenRate.value).div(10 ** tokenRate.decimals);\r\n        \r\n        totalBid = calcTokenTotalBid(totalBid, _token, _tokensNumber);\r\n        //totalBidInUsd = totalBidInUsd + _tokensNumber.mul(tokenRate.value).mul(etherRate).div(10 ** 2).div(10 ** tokenRate.decimals);\r\n        \r\n        totalBidInUsd = calcTokenTotalBidInUsd(totalBidInUsd, _token, _tokensNumber);\r\n\r\n        // !Note! зачем тут ограничивать макс ставку токена эфиром\r\n        //require(totalBid <= auctionState.maxTokenBidInEther);\r\n\r\n        bidderState.tokensBalanceInEther = totalBid;\r\n        bidderState.tokensBalanceInUsd = totalBidInUsd;\r\n\r\n        //TokenBid(_auction, _bidder, _token, _tokensNumber);\r\n        //emit TokenBid(_auction, _bidder, _token, _tokensNumber, _tokensNumber.mul(tokenRate.value).div(10 ** tokenRate.decimals), _tokensNumber.mul(tokenRate.value).mul(etherRate).div(10 ** 2).div(10 ** tokenRate.decimals));\r\n        emit TokenBid(_auction, _bidder, _token, _tokensNumber);\r\n        return (totalBid, totalBidInUsd);\r\n    }\r\n\r\n    function calcTokenTotalBid(uint256 totalBid, address _token, uint256 _tokensNumber)\r\n        internal\r\n        //returns(uint256 _totalBid, uint256 _bidInEther){\r\n        returns(uint256 _totalBid){\r\n            TokenRate storage tokenRate = tokenRates[_token];\r\n            // tokenRate.value is for a whole/big token (e.g. ether vs. wei) but _tokensNumber is in small/wei tokens, need to divide by decimals\r\n            uint256 bidInEther = _tokensNumber.mul(tokenRate.value).div(10 ** tokenRate.decimals);\r\n            //totalBid = totalBid + _tokensNumber.mul(tokenRate.value).div(10 ** tokenRate.decimals);\r\n            totalBid += bidInEther;\r\n            //return (totalBid, bidInEther);\r\n            return totalBid;\r\n        }\r\n    \r\n    function calcTokenTotalBidInUsd(uint256 totalBidInUsd, address _token, uint256 _tokensNumber)\r\n        internal\r\n        returns(uint256 _totalBidInUsd){\r\n            TokenRate storage tokenRate = tokenRates[_token];\r\n            uint256 bidInUsd = _tokensNumber.mul(tokenRate.value).mul(etherRate).div(10 ** 2).div(10 ** tokenRate.decimals);\r\n            //totalBidInUsd = totalBidInUsd + _tokensNumber.mul(tokenRate.value).mul(etherRate).div(10 ** 2).div(10 ** tokenRate.decimals);\r\n            totalBidInUsd += bidInUsd;\r\n            return totalBidInUsd;\r\n        }\r\n   \r\n    function totalDirectBid(address _auction, address _bidder)\r\n        view\r\n        public\r\n        returns (uint256 _totalBid)\r\n    {\r\n        ActionState storage auctionState = auctionStates[_auction];\r\n        BidderState storage bidderState = auctionState.bidderStates[_bidder];\r\n        return bidderState.tokensBalanceInEther + bidderState.etherBalance;\r\n    }\r\n\r\n    function totalDirectBidInUsd(address _auction, address _bidder)\r\n        view\r\n        public\r\n        returns (uint256 _totalBidInUsd)\r\n    {\r\n        ActionState storage auctionState = auctionStates[_auction];\r\n        BidderState storage bidderState = auctionState.bidderStates[_bidder];\r\n        return bidderState.tokensBalanceInUsd + bidderState.etherBalanceInUsd;\r\n    }\r\n\r\n    function setTokenRate(address _token, uint256 _tokenRate)\r\n        onlyBot\r\n        public\r\n    {\r\n        TokenRate storage tokenRate = tokenRates[_token];\r\n        require(tokenRate.value > 0);\r\n        tokenRate.value = _tokenRate;\r\n        emit TokenRateUpdate(_token, _tokenRate);\r\n    }\r\n\r\n    function setEtherRate(uint256 _etherRate)\r\n        onlyBot\r\n        public\r\n    {        \r\n        require(_etherRate > 0);\r\n        etherRate = _etherRate;\r\n        emit EtherRateUpdate(_etherRate);\r\n    }\r\n\r\n    function withdraw(address _bidder)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        BidderState storage bidderState = auctionState.bidderStates[_bidder];\r\n\r\n        bool sent; \r\n\r\n        // anyone could withdraw at any time except the highest bidder\r\n        // if cancelled, the highest bidder could withdraw as well\r\n        //require((_bidder != auctionState.highestBidder) || auctionState.cancelled);\r\n        require((_bidder != auctionState.highestBidderInUsd) || auctionState.cancelled);\r\n        uint256 tokensBalanceInEther = bidderState.tokensBalanceInEther;\r\n        uint256 tokensBalanceInUsd = bidderState.tokensBalanceInUsd;\r\n        if (bidderState.tokenBalances.length > 0) {\r\n            for (uint i = 0; i < bidderState.tokenBalances.length; i++) {\r\n                uint256 tokenBidValue = bidderState.tokenBalances[i].value;\r\n                if (tokenBidValue > 0) {\r\n                    bidderState.tokenBalances[i].value = 0;\r\n                    sent = Auction(msg.sender).sendTokens(bidderState.tokenBalances[i].token, _bidder, tokenBidValue);\r\n                    require(sent);\r\n                }\r\n            }\r\n            bidderState.tokensBalanceInEther = 0;\r\n            bidderState.tokensBalanceInUsd = 0;\r\n        } else {\r\n            require(tokensBalanceInEther == 0);\r\n        }\r\n\r\n        uint256 etherBid = bidderState.etherBalance;\r\n        if (etherBid > 0) {\r\n            bidderState.etherBalance = 0;\r\n            bidderState.etherBalanceInUsd = 0;\r\n            sent = Auction(msg.sender).sendEther(_bidder, etherBid);\r\n            require(sent);\r\n        }\r\n\r\n        emit Withdrawal(msg.sender, _bidder, etherBid, tokensBalanceInEther);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function finalize()\r\n        // onlyNotCancelled - inline check to reuse auctionState variable\r\n        // onlyAfterEnd - inline check to reuse auctionState variable\r\n        public\r\n        returns (bool)\r\n    {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        // same as onlyNotCancelled+onlyAfterEnd modifiers, but we already have a variable here\r\n        require (!auctionState.finalized && now > auctionState.endSeconds && auctionState.endSeconds > 0 && !auctionState.cancelled);\r\n\r\n        // если есть хоть одна ставка\r\n        if (auctionState.highestBidder != address(0)) {\r\n            bool sent; \r\n            BidderState storage bidderState = auctionState.bidderStates[auctionState.highestBidder];\r\n            uint256 tokensBalanceInEther = bidderState.tokensBalanceInEther;\r\n            uint256 tokensBalanceInUsd = bidderState.tokensBalanceInUsd;\r\n            if (bidderState.tokenBalances.length > 0) {\r\n                for (uint i = 0; i < bidderState.tokenBalances.length; i++) {\r\n                    uint256 tokenBid = bidderState.tokenBalances[i].value;\r\n                    if (tokenBid > 0) {\r\n                        bidderState.tokenBalances[i].value = 0;\r\n                        sent = Auction(msg.sender).sendTokens(bidderState.tokenBalances[i].token, wallet, tokenBid);\r\n                        require(sent);\r\n                        emit FinalizedTokenTransfer(msg.sender, bidderState.tokenBalances[i].token, tokenBid);\r\n                    }\r\n                }\r\n                bidderState.tokensBalanceInEther = 0;\r\n                bidderState.tokensBalanceInUsd = 0;\r\n            } else {\r\n                require(tokensBalanceInEther == 0);\r\n            }\r\n            \r\n            uint256 etherBid = bidderState.etherBalance;\r\n            if (etherBid > 0) {\r\n                bidderState.etherBalance = 0;\r\n                bidderState.etherBalanceInUsd = 0;\r\n                sent = Auction(msg.sender).sendEther(wallet, etherBid);\r\n                require(sent);\r\n                emit FinalizedEtherTransfer(msg.sender, etherBid);\r\n            }\r\n        }\r\n\r\n        auctionState.finalized = true;\r\n        emit Finalized(msg.sender, auctionState.highestBidder, auctionState.highestBid);\r\n        emit FinalizedInUsd(msg.sender, auctionState.highestBidderInUsd, auctionState.highestBidInUsd);\r\n\r\n        return true;\r\n    }\r\n\r\n    function cancel()\r\n        // onlyActive - inline check to reuse auctionState variable\r\n        public\r\n        returns (bool success)\r\n    {\r\n        ActionState storage auctionState = auctionStates[msg.sender];\r\n        // same as onlyActive modifier, but we already have a variable here\r\n        require (now < auctionState.endSeconds && !auctionState.cancelled);\r\n\r\n        auctionState.cancelled = true;\r\n        emit Cancelled(msg.sender);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Auction {\r\n\r\n    AuctionHub public owner;\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBot {\r\n        require(owner.isBot(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotBot {\r\n        require(!owner.isBot(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function Auction(\r\n        address _owner\r\n    ) \r\n        public \r\n    {\r\n        require(_owner != address(0x0));\r\n        owner = AuctionHub(_owner);\r\n    }\r\n\r\n    function () \r\n        payable\r\n        public\r\n    {\r\n        owner.bid(msg.sender, msg.value, 0x0, 0);\r\n    }\r\n\r\n    function bid(address _token, uint256 _tokensNumber)\r\n        payable\r\n        public\r\n        returns (bool isHighest, bool isHighestInUsd)\r\n    {\r\n        if (_token != 0x0 && _tokensNumber > 0) {\r\n            require(ERC20Basic(_token).transferFrom(msg.sender, this, _tokensNumber));\r\n        }\r\n        return owner.bid(msg.sender, msg.value, _token, _tokensNumber);\r\n    }   \r\n\r\n    function sendTokens(address _token, address _to, uint256 _amount)\r\n        onlyOwner\r\n        public\r\n        returns (bool)\r\n    {\r\n        return ERC20Basic(_token).transfer(_to, _amount);\r\n    }\r\n\r\n    function sendEther(address _to, uint256 _amount)\r\n        onlyOwner\r\n        public\r\n        returns (bool)\r\n    {\r\n        return _to.send(_amount);\r\n    }\r\n\r\n    function withdraw()\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return owner.withdraw(msg.sender);\r\n    }\r\n\r\n    function finalize()\r\n        onlyBot\r\n        public\r\n        returns (bool)\r\n    {\r\n        return owner.finalize();\r\n    }\r\n\r\n    function cancel()\r\n        onlyBot\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return  owner.cancel();\r\n    }\r\n\r\n    function totalDirectBid(address _bidder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return owner.totalDirectBid(this, _bidder);\r\n    }\r\n\r\n    function totalDirectBidInUsd(address _bidder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return owner.totalDirectBidInUsd(this, _bidder);\r\n    }\r\n\r\n    function maxTokenBidInEther()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //var (,maxTokenBidInEther,,,,,,,,,,,) = owner.auctionStates(this);\r\n        //var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,allowManagedBids,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,bidderStates) = owner.auctionStates(this);\r\n        //(endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        var (,maxTokenBidInEther,,,,,,,,,) = owner.auctionStates(this);\r\n        return maxTokenBidInEther;\r\n    }\r\n\r\n    function maxTokenBidInUsd()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //var (,,,,,,,,,,maxTokenBidInUsd,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        return maxTokenBidInUsd;\r\n    }\r\n\r\n    function endSeconds()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //var (endSeconds,,,,,,,,,) = owner.auctionStates(this);\r\n        //(endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        var (endSeconds,,,,,,,,,,) = owner.auctionStates(this);\r\n        return endSeconds;\r\n    }\r\n\r\n    function item()\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        //var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,allowManagedBids,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,bidderStates,item) = owner.auctionStates(this);\r\n        bytes memory bytesArray = new bytes(32);\r\n        for (uint256 i; i < 32; i++) {\r\n            bytesArray[i] = item[i];\r\n            }\r\n        return string(bytesArray);\r\n    }\r\n\r\n    function minPrice()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //var (,,minPrice,,,,,,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        return minPrice;\r\n    }\r\n\r\n    function cancelled()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        //var (,,,,,,cancelled,,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        return cancelled;\r\n    }\r\n\r\n    function finalized()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        //var (,,,,,,,finalized,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        return finalized;\r\n    }\r\n\r\n    function highestBid()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //var (,,,highestBid,,,,,,,,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        // ,,,,,,,,,,,,\r\n        // ,,,highestBid,,,,,,,,,\r\n        return highestBid;\r\n    }\r\n\r\n    function highestBidInUsd()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //var (,,,,,,,,,,,highestBidInUsd,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        // ,,,,,,,,,,,,\r\n        return highestBidInUsd;\r\n    }\r\n\r\n    function highestBidder()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        //var (,,,,highestBidder,,,,,) = owner.auctionStates(this);\r\n        //var (,,,,highestBidder,,,,,,,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        // ,,,,highestBidder,,,,,,,,\r\n        return highestBidder;\r\n    }\r\n\r\n    \r\n    function highestBidderInUsd()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        //var (,,,,highestBidder,,,,,) = owner.auctionStates(this);\r\n        //var (,,,,,,,,,,,,highestBidderInUsd) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,item) = owner.auctionStates(this);\r\n        // ,,,,,,,,,,,,\r\n        return highestBidderInUsd;\r\n    }\r\n\r\n    /*function highestManagedBidder()\r\n        public\r\n        view\r\n        returns (uint64)\r\n    {\r\n        //var (,,,,,highestManagedBidder,,,,) = owner.auctionStates(this);\r\n        var (,,,,,highestManagedBidder,,,,,,,) = owner.auctionStates(this);\r\n        // ,,,,,highestManagedBidder,,,,,,,\r\n        return highestManagedBidder;\r\n    }*/\r\n\r\n\r\n    /*function allowManagedBids()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        //var (,,,,,,allowManagedBids,,,) = owner.auctionStates(this);\r\n        var (endSeconds,maxTokenBidInEther,minPrice,highestBid,highestBidder,allowManagedBids,cancelled,finalized,maxTokenBidInUsd,highestBidInUsd,highestBidderInUsd,bidderStates) = owner.auctionStates(this);\r\n        return allowManagedBids;\r\n    }*/\r\n\r\n\r\n    // mapping(address => uint256) public etherBalances;\r\n    // mapping(address => uint256) public tokenBalances;\r\n    // mapping(address => uint256) public tokenBalancesInEther;\r\n    // mapping(address => uint256) public managedBids;\r\n    \r\n    // bool allowManagedBids;\r\n}\r\n\r\n// File: contracts/TokenStarsAuction.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\ncontract TokenStarsAuctionHub is AuctionHub {\r\n    //real\r\n    address public ACE = 0x06147110022B768BA8F99A8f385df11a151A9cc8;\r\n    //renkeby\r\n    //address public ACE = 0xa0813ad2e1124e0779dc04b385f5229776dcbba8;\r\n    //real\r\n    address public TEAM = 0x1c79ab32C66aCAa1e9E81952B8AAa581B43e54E7;\r\n    // rinkeby\r\n    //address public TEAM = 0x10b882e7da9ef31ef6e0e9c4c5457dfaf8dd9a24;\r\n    //address public wallet = 0x963dF7904cF180aB2C033CEAD0be8687289f05EC;\r\n    address public wallet = 0x0C9b07209750BbcD1d1716DA52B591f371eeBe77;//\r\n    address[] public tokens = [ACE, TEAM];\r\n    // ACE = 0.01 ETH; \r\n    // TEAM = 0,002 ETH\r\n    uint256[] public rates = [10000000000000000, 2000000000000000];\r\n    uint256[] public decimals = [0, 4];\r\n    // ETH = $138.55\r\n    uint256 public etherRate = 13855;\r\n\r\n    function TokenStarsAuctionHub()\r\n        public\r\n        AuctionHub(wallet, tokens, rates, decimals, etherRate)\r\n    {\r\n    }\r\n\r\n    function createAuction(\r\n        address _wallet,\r\n        uint _endSeconds, \r\n        uint256 _maxTokenBidInEther,\r\n        uint256 _minPrice,\r\n        string _item\r\n        //bool _allowManagedBids\r\n    )\r\n        onlyBot\r\n        public\r\n        returns (address)\r\n    {\r\n        require (_endSeconds > now);\r\n        require(_maxTokenBidInEther <= 1000 ether);\r\n        require(_minPrice > 0);\r\n\r\n        Auction auction = new TokenStarsAuction(this);\r\n\r\n        ActionState storage auctionState = auctionStates[auction];\r\n\r\n        auctionState.endSeconds = _endSeconds;\r\n        auctionState.maxTokenBidInEther = _maxTokenBidInEther;\r\n        auctionState.minPrice = _minPrice;\r\n        //auctionState.allowManagedBids = _allowManagedBids;\r\n        string memory item = _item;\r\n        auctionState.item = stringToBytes32(item);\r\n\r\n        NewAction(auction, _item);\r\n        return address(auction);\r\n    }\r\n}\r\n\r\ncontract TokenStarsAuctionHubMock is AuctionHub {\r\n    uint256[] public rates = [2400000000000000, 2400000000000000];\r\n    uint256[] public decimals = [0, 4];\r\n    uint256 public etherRate = 13855;\r\n\r\n    function TokenStarsAuctionHubMock(address _wallet, address[] _tokens)\r\n        public\r\n        AuctionHub(_wallet, _tokens, rates, decimals, etherRate)\r\n    {\r\n    }\r\n\r\n    function createAuction(\r\n        uint _endSeconds, \r\n        uint256 _maxTokenBidInEther,\r\n        uint256 _minPrice,\r\n        string _item\r\n        //bool _allowManagedBids\r\n    )\r\n        onlyBot\r\n        public\r\n        returns (address)\r\n    {\r\n        require (_endSeconds > now);\r\n        require(_maxTokenBidInEther <= 1000 ether);\r\n        require(_minPrice > 0);\r\n\r\n        Auction auction = new TokenStarsAuction(this);\r\n\r\n        ActionState storage auctionState = auctionStates[auction];\r\n\r\n        auctionState.endSeconds = _endSeconds;\r\n        auctionState.maxTokenBidInEther = _maxTokenBidInEther;\r\n        auctionState.maxTokenBidInUsd = _maxTokenBidInEther.mul(etherRate).div(10 ** 2);\r\n        auctionState.minPrice = _minPrice;\r\n        //auctionState.allowManagedBids = _allowManagedBids;\r\n        string memory item = _item;\r\n        auctionState.item = stringToBytes32(item);\r\n\r\n        NewAction(auction, _item);\r\n        return address(auction);\r\n    }\r\n}\r\n\r\ncontract TokenStarsAuction is Auction {\r\n        \r\n    function TokenStarsAuction(\r\n        address _owner) \r\n        public\r\n        Auction(_owner)\r\n    {\r\n        \r\n    }\r\n\r\n    function bidAce(uint256 _tokensNumber)\r\n        payable\r\n        public\r\n        returns (bool isHighest, bool isHighestInUsd)\r\n    {\r\n        return super.bid(TokenStarsAuctionHub(owner).ACE(), _tokensNumber);\r\n    }\r\n\r\n    function bidTeam(uint256 _tokensNumber)\r\n        payable\r\n        public\r\n        returns (bool isHighest, bool isHighestInUsd)\r\n    {\r\n        return super.bid(TokenStarsAuctionHub(owner).TEAM(), _tokensNumber);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_endSeconds\",\"type\":\"uint256\"},{\"name\":\"_maxTokenBidInEther\",\"type\":\"uint256\"},{\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"name\":\"_item\",\"type\":\"string\"}],\"name\":\"createAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_auction\",\"type\":\"address\"},{\"name\":\"_bidder\",\"type\":\"address\"}],\"name\":\"totalDirectBid\",\"outputs\":[{\"name\":\"_totalBid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"auctionStates\",\"outputs\":[{\"name\":\"endSeconds\",\"type\":\"uint256\"},{\"name\":\"maxTokenBidInEther\",\"type\":\"uint256\"},{\"name\":\"minPrice\",\"type\":\"uint256\"},{\"name\":\"highestBid\",\"type\":\"uint256\"},{\"name\":\"highestBidder\",\"type\":\"address\"},{\"name\":\"cancelled\",\"type\":\"bool\"},{\"name\":\"finalized\",\"type\":\"bool\"},{\"name\":\"maxTokenBidInUsd\",\"type\":\"uint256\"},{\"name\":\"highestBidInUsd\",\"type\":\"uint256\"},{\"name\":\"highestBidderInUsd\",\"type\":\"address\"},{\"name\":\"item\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_botAddress\",\"type\":\"address\"}],\"name\":\"enableBot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_botAddress\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidder\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_botAddress\",\"type\":\"address\"},{\"name\":\"_atTimeStampSeconds\",\"type\":\"uint64\"}],\"name\":\"isBotAt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_endSeconds\",\"type\":\"uint256\"},{\"name\":\"_maxTokenBidInEther\",\"type\":\"uint256\"},{\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"name\":\"_item\",\"type\":\"string\"}],\"name\":\"createAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_botAddress\",\"type\":\"address\"},{\"name\":\"_fromTimeStampSeconds\",\"type\":\"uint64\"}],\"name\":\"disableBot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenRates\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherRate\",\"type\":\"uint256\"}],\"name\":\"setEtherRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ACE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidder\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokensNumber\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[{\"name\":\"isHighest\",\"type\":\"bool\"},{\"name\":\"isHighestInUsd\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_auction\",\"type\":\"address\"},{\"name\":\"_bidder\",\"type\":\"address\"}],\"name\":\"totalDirectBidInUsd\",\"outputs\":[{\"name\":\"_totalBidInUsd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenRate\",\"type\":\"uint256\"}],\"name\":\"setTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"item\",\"type\":\"string\"}],\"name\":\"NewAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBidInEther\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokensBidInEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalBidInUsd\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokensBidInUsd\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"TokenBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBid\",\"type\":\"uint256\"}],\"name\":\"NewHighestBidder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBidInUsd\",\"type\":\"uint256\"}],\"name\":\"NewHighestBidderInUsd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"TokenRateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"EtherRateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBidInEther\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"Charity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"highestBidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"highestBidderInUsd\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FinalizedInUsd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBidInEther\",\"type\":\"uint256\"}],\"name\":\"FinalizedTokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"FinalizedEtherTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newEndtime\",\"type\":\"uint256\"}],\"name\":\"ExtendedEndTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auction\",\"type\":\"address\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_botAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint64\"}],\"name\":\"BotsStartEndTimeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"MultiOwnableWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"TokenStarsAuctionHub","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6e57887d5c1fa8d4ead97aeaaa2b513f6082629cc8be4cd7d258ba798d83ac5a"}]}