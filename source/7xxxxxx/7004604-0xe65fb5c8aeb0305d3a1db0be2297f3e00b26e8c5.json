{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/// @title Provides helper functions to determine the validity of passed signatures.\r\n/// @author Noah Zinsmeister\r\n/// @dev Supports both prefixed and un-prefixed signatures.\r\ncontract SignatureVerifier {\r\n    /// @notice Determines whether the passed signature of `messageHash` was made by the private key of `_address`.\r\n    /// @param _address The address that may or may not have signed the passed messageHash.\r\n    /// @param messageHash The messageHash that may or may not have been signed.\r\n    /// @param v The v component of the signature.\r\n    /// @param r The r component of the signature.\r\n    /// @param s The s component of the signature.\r\n    /// @return true if the signature can be verified, false otherwise.\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\r\n        return _isSigned(_address, messageHash, v, r, s) || _isSignedPrefixed(_address, messageHash, v, r, s);\r\n    }\r\n\r\n    /// @dev Checks unprefixed signatures.\r\n    function _isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        internal pure returns (bool)\r\n    {\r\n        return ecrecover(messageHash, v, r, s) == _address;\r\n    }\r\n\r\n    /// @dev Checks prefixed signatures.\r\n    function _isSignedPrefixed(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        internal pure returns (bool)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        return _isSigned(_address, keccak256(abi.encodePacked(prefix, messageHash)), v, r, s);\r\n    }\r\n}\r\n\r\n/// @title An implementation of the set data structure for addresses.\r\n/// @author Noah Zinsmeister\r\n/// @dev O(1) insertion, removal, contains, and length functions.\r\nlibrary AddressSet {\r\n    struct Set {\r\n        address[] members;\r\n        mapping(address => uint) memberIndices;\r\n    }\r\n\r\n    /// @dev Inserts an element into a set. If the element already exists in the set, the function is a no-op.\r\n    /// @param self The set to insert into.\r\n    /// @param other The element to insert.\r\n    function insert(Set storage self, address other) internal {\r\n        if (!contains(self, other)) {\r\n            self.memberIndices[other] = self.members.push(other);\r\n        }\r\n    }\r\n\r\n    /// @dev Removes an element from a set. If the element does not exist in the set, the function is a no-op.\r\n    /// @param self The set to remove from.\r\n    /// @param other The element to remove.\r\n    function remove(Set storage self, address other) internal {\r\n        if (contains(self, other)) {\r\n            // replace other with the last element\r\n            self.members[self.memberIndices[other] - 1] = self.members[length(self) - 1];\r\n            // reflect this change in the indices\r\n            self.memberIndices[self.members[self.memberIndices[other] - 1]] = self.memberIndices[other];\r\n            delete self.memberIndices[other];\r\n            // remove the last element\r\n            self.members.pop();\r\n        }\r\n    }\r\n\r\n    /// @dev Checks set membership.\r\n    /// @param self The set to check membership in.\r\n    /// @param other The element to check membership of.\r\n    /// @return true if the element is in the set, false otherwise.\r\n    function contains(Set storage self, address other) internal view returns (bool) {\r\n        return ( // solium-disable-line operator-whitespace\r\n            self.memberIndices[other] > 0 && \r\n            self.members.length >= self.memberIndices[other] && \r\n            self.members[self.memberIndices[other] - 1] == other\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the number of elements in a set.\r\n    /// @param self The set to check the length of.\r\n    /// @return The number of elements in the set.\r\n    function length(Set storage self) internal view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n}\r\n\r\n/// @title The ERC-1484 Identity Registry.\r\n/// @author Noah Zinsmeister\r\n/// @author Andy Chorlian\r\ncontract IdentityRegistry is SignatureVerifier {\r\n    using AddressSet for AddressSet.Set;\r\n\r\n\r\n    // Identity Data Structure and Parameters //////////////////////////////////////////////////////////////////////////\r\n\r\n    struct Identity {\r\n        address recoveryAddress;\r\n        AddressSet.Set associatedAddresses;\r\n        AddressSet.Set providers;\r\n        AddressSet.Set resolvers;\r\n    }\r\n\r\n    mapping (uint => Identity) private identityDirectory;\r\n    mapping (address => uint) private associatedAddressDirectory;\r\n\r\n    uint public nextEIN = 1;\r\n    uint public maxAssociatedAddresses = 50;\r\n\r\n\r\n    // Signature Timeout ///////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    uint public signatureTimeout = 1 days;\r\n\r\n    /// @dev Enforces that the passed timestamp is within signatureTimeout seconds of now.\r\n    /// @param timestamp The timestamp to check the validity of.\r\n    modifier ensureSignatureTimeValid(uint timestamp) {\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            block.timestamp >= timestamp && block.timestamp < timestamp + signatureTimeout, \"Timestamp is not valid.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    // Recovery Address Change Logging /////////////////////////////////////////////////////////////////////////////////\r\n\r\n    struct RecoveryAddressChange {\r\n        uint timestamp;\r\n        address oldRecoveryAddress;\r\n    }\r\n\r\n    mapping (uint => RecoveryAddressChange) private recoveryAddressChangeLogs;\r\n\r\n\r\n    // Recovery Logging ////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    struct Recovery {\r\n        uint timestamp;\r\n        bytes32 hashedOldAssociatedAddresses;\r\n    }\r\n\r\n    mapping (uint => Recovery) private recoveryLogs;\r\n\r\n\r\n    // Recovery Timeout ////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    uint public recoveryTimeout = 2 weeks;\r\n\r\n    /// @dev Checks if the passed EIN has changed their recovery address within recoveryTimeout seconds of now.\r\n    function canChangeRecoveryAddress(uint ein) private view returns (bool) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp > recoveryAddressChangeLogs[ein].timestamp + recoveryTimeout;\r\n    }\r\n\r\n    /// @dev Checks if the passed EIN has recovered within recoveryTimeout seconds of now.\r\n    function canRecover(uint ein) private view returns (bool) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp > recoveryLogs[ein].timestamp + recoveryTimeout;\r\n    }\r\n\r\n\r\n    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Checks if the passed EIN exists.\r\n    /// @dev Does not throw.\r\n    /// @param ein The EIN to check the existence of.\r\n    /// @return true if the passed EIN exists, false otherwise.\r\n    function identityExists(uint ein) public view returns (bool) {\r\n        return ein < nextEIN && ein > 0;\r\n    }\r\n\r\n    /// @dev Ensures that the passed EIN exists.\r\n    /// @param ein The EIN to check the existence of.\r\n    modifier _identityExists(uint ein) {\r\n        require(identityExists(ein), \"The identity does not exist.\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if the passed address is associated with an Identity.\r\n    /// @dev Does not throw.\r\n    /// @param _address The address to check.\r\n    /// @return true if the passed address is associated with an Identity, false otherwise.\r\n    function hasIdentity(address _address) public view returns (bool) {\r\n        return identityExists(associatedAddressDirectory[_address]);\r\n    }\r\n\r\n    /// @dev Ensures that the passed address is or is not associated with an Identity.\r\n    /// @param _address The address to check.\r\n    /// @param check If true, ensures that the address has an Identity, if false, vice versa.\r\n    /// @return true if the associated status is equal to check, false otherwise.\r\n    modifier _hasIdentity(address _address, bool check) {\r\n        require(\r\n            hasIdentity(_address) == check,\r\n            check ?\r\n                \"The passed address does not have an identity but should.\" :\r\n                \"The passed address has an identity but should not.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @notice Gets the EIN associated with the passed address.\r\n    /// @dev Throws if the address is not associated with an Identity.\r\n    /// @param _address The address to check.\r\n    /// @return The associated EIN.\r\n    function getEIN(address _address) public view _hasIdentity(_address, true) returns (uint ein) {\r\n        return associatedAddressDirectory[_address];\r\n    }\r\n\r\n    /// @notice Checks whether the passed EIN is associated with the passed address.\r\n    /// @dev Does not throw.\r\n    /// @param ein The EIN to check.\r\n    /// @param _address The address to check.\r\n    /// @return true if the passed address is associated with the passed EIN, false otherwise.\r\n    function isAssociatedAddressFor(uint ein, address _address) public view returns (bool) {\r\n        return identityDirectory[ein].associatedAddresses.contains(_address);\r\n    }\r\n\r\n    /// @notice Checks whether the passed provider is set for the passed EIN.\r\n    /// @dev Does not throw.\r\n    /// @param ein The EIN to check.\r\n    /// @param provider The provider to check.\r\n    /// @return true if the provider is set for the passed EIN, false otherwise.\r\n    function isProviderFor(uint ein, address provider) public view returns (bool) {\r\n        return identityDirectory[ein].providers.contains(provider);\r\n    }\r\n\r\n    /// @dev Ensures that the msg.sender is a provider for the passed EIN.\r\n    /// @param ein The EIN to check.\r\n    modifier _isProviderFor(uint ein) {\r\n        require(isProviderFor(ein, msg.sender), \"The identity has not set the passed provider.\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks whether the passed resolver is set for the passed EIN.\r\n    /// @dev Does not throw.\r\n    /// @param ein The EIN to check.\r\n    /// @param resolver The resolver to check.\r\n    /// @return true if the resolver is set for the passed EIN, false otherwise.\r\n    function isResolverFor(uint ein, address resolver) public view returns (bool) {\r\n        return identityDirectory[ein].resolvers.contains(resolver);\r\n    }\r\n\r\n    /// @notice Gets all identity-related information for the passed EIN.\r\n    /// @dev Throws if the passed EIN does not exist.\r\n    /// @param ein The EIN to get information for.\r\n    /// @return All the information for the Identity denominated by the passed EIN.\r\n    function getIdentity(uint ein) public view _identityExists(ein)\r\n        returns (\r\n            address recoveryAddress,\r\n            address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n        )\r\n    {\r\n        Identity storage _identity = identityDirectory[ein];\r\n\r\n        return (\r\n            _identity.recoveryAddress,\r\n            _identity.associatedAddresses.members,\r\n            _identity.providers.members,\r\n            _identity.resolvers.members\r\n        );\r\n    }\r\n\r\n\r\n    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Create an new Identity for the transaction sender.\r\n    /// @dev Sets the msg.sender as the only associatedAddress.\r\n    /// @param recoveryAddress A recovery address to set for the new Identity.\r\n    /// @param providers A list of providers to set for the new Identity.\r\n    /// @param resolvers A list of resolvers to set for the new Identity.\r\n    /// @return The EIN of the new Identity.\r\n    function createIdentity(address recoveryAddress, address[] memory providers, address[] memory resolvers)\r\n        public returns (uint ein)\r\n    {\r\n        return createIdentity(recoveryAddress, msg.sender, providers, resolvers, false);\r\n    }\r\n\r\n    /// @notice Allows creation of a new Identity for the passed associatedAddress.\r\n    /// @param recoveryAddress A recovery address to set for the new Identity.\r\n    /// @param associatedAddress An associated address to set for the new Identity (must have produced the signature).\r\n    /// @param providers A list of providers to set for the new Identity.\r\n    /// @param resolvers A list of resolvers to set for the new Identity.\r\n    /// @param v The v component of the signature.\r\n    /// @param r The r component of the signature.\r\n    /// @param s The s component of the signature.\r\n    /// @param timestamp The timestamp of the signature.\r\n    /// @return The EIN of the new Identity.\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] memory providers, address[] memory resolvers,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public ensureSignatureTimeValid(timestamp) returns (uint ein)\r\n    {\r\n        require(\r\n            isSigned(\r\n                associatedAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize the creation of an Identity on my behalf.\",\r\n                        recoveryAddress, associatedAddress, providers, resolvers, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        return createIdentity(recoveryAddress, associatedAddress, providers, resolvers, true);\r\n    }\r\n\r\n    /// @dev Common logic for all identity creation.\r\n    function createIdentity(\r\n        address recoveryAddress,\r\n        address associatedAddress, address[] memory providers, address[] memory resolvers, bool delegated\r\n    )\r\n        private _hasIdentity(associatedAddress, false) returns (uint)\r\n    {\r\n        uint ein = nextEIN++;\r\n        Identity storage _identity = identityDirectory[ein];\r\n\r\n        _identity.recoveryAddress = recoveryAddress;\r\n        addAssociatedAddress(ein, associatedAddress);\r\n        addProviders(ein, providers, delegated);\r\n        addResolvers(ein, resolvers, delegated);\r\n\r\n        emit IdentityCreated(msg.sender, ein, recoveryAddress, associatedAddress, providers, resolvers, delegated);\r\n\r\n        return ein;\r\n    }\r\n\r\n\r\n    /// @notice Allows an associated address to add another associated address to its Identity.\r\n    /// @param approvingAddress An associated address for an Identity.\r\n    /// @param addressToAdd A new address to set for the Identity of the sender.\r\n    /// @param v The v component of the signature.\r\n    /// @param r The r component of the signature.\r\n    /// @param s The s component of the signature.\r\n    /// @param timestamp The timestamp of the signature.\r\n    function addAssociatedAddress(\r\n        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public ensureSignatureTimeValid(timestamp)\r\n    {\r\n        bool fromApprovingAddress = msg.sender == approvingAddress;\r\n        require(\r\n            fromApprovingAddress || msg.sender == addressToAdd, \"One or both of the passed addresses are malformed.\"\r\n        );\r\n\r\n        uint ein = getEIN(approvingAddress);\r\n\r\n        require(\r\n            isSigned(\r\n                fromApprovingAddress ? addressToAdd : approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        fromApprovingAddress ?\r\n                            \"I authorize being added to this Identity.\" :\r\n                            \"I authorize adding this address to my Identity.\",\r\n                        ein, addressToAdd, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        addAssociatedAddress(ein, addressToAdd);\r\n\r\n        emit AssociatedAddressAdded(msg.sender, ein, approvingAddress, addressToAdd, false);\r\n    }\r\n\r\n    /// @notice Allows addition of an associated address to an Identity.\r\n    /// @dev The first signature must be that of the approvingAddress.\r\n    /// @param approvingAddress An associated address for an Identity.\r\n    /// @param addressToAdd A new address to set for the Identity of approvingAddress.\r\n    /// @param v The v component of the signatures.\r\n    /// @param r The r component of the signatures.\r\n    /// @param s The s component of the signatures.\r\n    /// @param timestamp The timestamp of the signatures.\r\n    function addAssociatedAddressDelegated(\r\n        address approvingAddress, address addressToAdd,\r\n        uint8[2] memory v, bytes32[2] memory r, bytes32[2] memory s, uint[2] memory timestamp\r\n    )\r\n        public ensureSignatureTimeValid(timestamp[0]) ensureSignatureTimeValid(timestamp[1])\r\n    {\r\n        uint ein = getEIN(approvingAddress);\r\n\r\n        require(\r\n            isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize adding this address to my Identity.\",\r\n                        ein, addressToAdd, timestamp[0]\r\n                    )\r\n                ),\r\n                v[0], r[0], s[0]\r\n            ),\r\n            \"Permission denied from approving address.\"\r\n        );\r\n        require(\r\n            isSigned(\r\n                addressToAdd,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize being added to this Identity.\",\r\n                        ein, addressToAdd, timestamp[1]\r\n                    )\r\n                ),\r\n                v[1], r[1], s[1]\r\n            ),\r\n            \"Permission denied from address to add.\"\r\n        );\r\n\r\n        addAssociatedAddress(ein, addressToAdd);\r\n\r\n        emit AssociatedAddressAdded(msg.sender, ein, approvingAddress, addressToAdd, true);\r\n    }\r\n\r\n    /// @dev Common logic for all address addition.\r\n    function addAssociatedAddress(uint ein, address addressToAdd) private _hasIdentity(addressToAdd, false) {\r\n        require(\r\n            identityDirectory[ein].associatedAddresses.length() < maxAssociatedAddresses, \"Too many addresses.\"\r\n        );\r\n\r\n        identityDirectory[ein].associatedAddresses.insert(addressToAdd);\r\n        associatedAddressDirectory[addressToAdd] = ein;\r\n    }\r\n\r\n    /// @notice Allows an associated address to remove itself from its Identity.\r\n    function removeAssociatedAddress() public {\r\n        uint ein = getEIN(msg.sender);\r\n\r\n        removeAssociatedAddress(ein, msg.sender);\r\n\r\n        emit AssociatedAddressRemoved(msg.sender, ein, msg.sender, false);\r\n    }\r\n\r\n    /// @notice Allows removal of an associated address from an Identity.\r\n    /// @param addressToRemove An associated address to remove from its Identity.\r\n    /// @param v The v component of the signature.\r\n    /// @param r The r component of the signature.\r\n    /// @param s The s component of the signature.\r\n    /// @param timestamp The timestamp of the signature.\r\n    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        public ensureSignatureTimeValid(timestamp)\r\n    {\r\n        uint ein = getEIN(addressToRemove);\r\n\r\n        require(\r\n            isSigned(\r\n                addressToRemove,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize removing this address from my Identity.\",\r\n                        ein, addressToRemove, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        removeAssociatedAddress(ein, addressToRemove);\r\n\r\n        emit AssociatedAddressRemoved(msg.sender, ein, addressToRemove, true);\r\n    }\r\n\r\n    /// @dev Common logic for all address removal.\r\n    function removeAssociatedAddress(uint ein, address addressToRemove) private {\r\n        identityDirectory[ein].associatedAddresses.remove(addressToRemove);\r\n        delete associatedAddressDirectory[addressToRemove];\r\n    }\r\n\r\n\r\n    /// @notice Allows an associated address to add providers to its Identity.\r\n    /// @param providers A list of providers.\r\n    function addProviders(address[] memory providers) public {\r\n        addProviders(getEIN(msg.sender), providers, false);\r\n    }\r\n\r\n    /// @notice Allows providers to add providers to an Identity.\r\n    /// @param ein The EIN to add providers to.\r\n    /// @param providers A list of providers.\r\n    function addProvidersFor(uint ein, address[] memory providers) public _isProviderFor(ein) {\r\n        addProviders(ein, providers, true);\r\n    }\r\n\r\n    /// @dev Common logic for all provider adding.\r\n    function addProviders(uint ein, address[] memory providers, bool delegated) private {\r\n        Identity storage _identity = identityDirectory[ein];\r\n        for (uint i; i < providers.length; i++) {\r\n            _identity.providers.insert(providers[i]);\r\n            emit ProviderAdded(msg.sender, ein, providers[i], delegated);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows an associated address to remove providers from its Identity.\r\n    /// @param providers A list of providers.\r\n    function removeProviders(address[] memory providers) public {\r\n        removeProviders(getEIN(msg.sender), providers, false);\r\n    }\r\n\r\n    /// @notice Allows providers to remove providers to an Identity.\r\n    /// @param ein The EIN to remove providers from.\r\n    /// @param providers A list of providers.\r\n    function removeProvidersFor(uint ein, address[] memory providers) public _isProviderFor(ein) {\r\n        removeProviders(ein, providers, true);\r\n    }\r\n\r\n    /// @dev Common logic for all provider removal.\r\n    function removeProviders(uint ein, address[] memory providers, bool delegated) private {\r\n        Identity storage _identity = identityDirectory[ein];\r\n        for (uint i; i < providers.length; i++) {\r\n            _identity.providers.remove(providers[i]);\r\n            emit ProviderRemoved(msg.sender, ein, providers[i], delegated);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows an associated address to add resolvers to its Identity.\r\n    /// @param resolvers A list of resolvers.\r\n    function addResolvers(address[] memory resolvers) public {\r\n        addResolvers(getEIN(msg.sender), resolvers, false);\r\n    }\r\n\r\n    /// @notice Allows providers to add resolvers to an Identity.\r\n    /// @param ein The EIN to add resolvers to.\r\n    /// @param resolvers A list of resolvers.\r\n    function addResolversFor(uint ein, address[] memory resolvers) public _isProviderFor(ein) {\r\n        addResolvers(ein, resolvers, true);\r\n    }\r\n\r\n    /// @dev Common logic for all resolver adding.\r\n    function addResolvers(uint ein, address[] memory resolvers, bool delegated) private {\r\n        Identity storage _identity = identityDirectory[ein];\r\n        for (uint i; i < resolvers.length; i++) {\r\n            _identity.resolvers.insert(resolvers[i]);\r\n            emit ResolverAdded(msg.sender, ein, resolvers[i], delegated);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows an associated address to remove resolvers from its Identity.\r\n    /// @param resolvers A list of resolvers.\r\n    function removeResolvers(address[] memory resolvers) public {\r\n        removeResolvers(getEIN(msg.sender), resolvers, true);\r\n    }\r\n\r\n    /// @notice Allows providers to remove resolvers from an Identity.\r\n    /// @param ein The EIN to remove resolvers from.\r\n    /// @param resolvers A list of resolvers.\r\n    function removeResolversFor(uint ein, address[] memory resolvers) public _isProviderFor(ein) {\r\n        removeResolvers(ein, resolvers, true);\r\n    }\r\n\r\n    /// @dev Common logic for all resolver removal.\r\n    function removeResolvers(uint ein, address[] memory resolvers, bool delegated) private {\r\n        Identity storage _identity = identityDirectory[ein];\r\n        for (uint i; i < resolvers.length; i++) {\r\n            _identity.resolvers.remove(resolvers[i]);\r\n            emit ResolverRemoved(msg.sender, ein, resolvers[i], delegated);\r\n        }\r\n    }\r\n\r\n\r\n    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Allows an associated address to change the recovery address for its Identity.\r\n    /// @dev Recovery addresses can be changed at most once every recoveryTimeout seconds.\r\n    /// @param newRecoveryAddress A recovery address to set for the sender's EIN.\r\n    function triggerRecoveryAddressChange(address newRecoveryAddress) public {\r\n        triggerRecoveryAddressChange(getEIN(msg.sender), newRecoveryAddress, false);\r\n    }\r\n\r\n    /// @notice Allows providers to change the recovery address for an Identity.\r\n    /// @dev Recovery addresses can be changed at most once every recoveryTimeout seconds.\r\n    /// @param ein The EIN to set the recovery address of.\r\n    /// @param newRecoveryAddress A recovery address to set for the passed EIN.\r\n    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) public _isProviderFor(ein) {\r\n        triggerRecoveryAddressChange(ein, newRecoveryAddress, true);\r\n    }\r\n\r\n    /// @dev Common logic for all recovery address changes.\r\n    function triggerRecoveryAddressChange(uint ein, address newRecoveryAddress, bool delegated) private {\r\n        Identity storage _identity = identityDirectory[ein];\r\n\r\n        require(canChangeRecoveryAddress(ein), \"Cannot trigger a change in recovery address yet.\");\r\n\r\n         // solium-disable-next-line security/no-block-members\r\n        recoveryAddressChangeLogs[ein] = RecoveryAddressChange(block.timestamp, _identity.recoveryAddress);\r\n\r\n        emit RecoveryAddressChangeTriggered(msg.sender, ein, _identity.recoveryAddress, newRecoveryAddress, delegated);\r\n\r\n        _identity.recoveryAddress = newRecoveryAddress;\r\n    }\r\n\r\n    /// @notice Allows recovery addresses to trigger the recovery process for an Identity.\r\n    /// @dev msg.sender must be current recovery address, or the old one if it was changed recently.\r\n    /// @param ein The EIN to trigger recovery for.\r\n    /// @param newAssociatedAddress A recovery address to set for the passed EIN.\r\n    /// @param v The v component of the signature.\r\n    /// @param r The r component of the signature.\r\n    /// @param s The s component of the signature.\r\n    /// @param timestamp The timestamp of the signature.\r\n    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        public _identityExists(ein) _hasIdentity(newAssociatedAddress, false) ensureSignatureTimeValid(timestamp)\r\n    {\r\n        require(canRecover(ein), \"Cannot trigger recovery yet.\");\r\n        Identity storage _identity = identityDirectory[ein];\r\n\r\n        // ensure the sender is the recovery address/old recovery address if there's been a recent change\r\n        if (canChangeRecoveryAddress(ein)) {\r\n            require(\r\n                msg.sender == _identity.recoveryAddress, \"Only the current recovery address can trigger recovery.\"\r\n            );\r\n        } else {\r\n            require(\r\n                msg.sender == recoveryAddressChangeLogs[ein].oldRecoveryAddress,\r\n                \"Only the recently removed recovery address can trigger recovery.\"\r\n            );\r\n        }\r\n\r\n        require(\r\n            isSigned(\r\n                newAssociatedAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize being added to this Identity via recovery.\",\r\n                        ein, newAssociatedAddress, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        // log the old associated addresses to facilitate destruction if necessary\r\n        recoveryLogs[ein] = Recovery(\r\n            block.timestamp, // solium-disable-line security/no-block-members\r\n            keccak256(abi.encodePacked(_identity.associatedAddresses.members))\r\n        );\r\n\r\n        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);\r\n\r\n        // remove identity data, and add the new address as the sole associated address\r\n        resetIdentityData(_identity, msg.sender, false);\r\n        addAssociatedAddress(ein, newAssociatedAddress);\r\n    }\r\n\r\n    /// @notice Allows associated addresses recently removed via recovery to permanently disable their old Identity.\r\n    /// @param ein The EIN to trigger destruction of.\r\n    /// @param firstChunk The array of addresses before the msg.sender in the pre-recovery associated addresses array.\r\n    /// @param lastChunk The array of addresses after the msg.sender in the pre-recovery associated addresses array.\r\n    /// @param resetResolvers true if the destroyer wants resolvers to be removed, false otherwise.\r\n    function triggerDestruction(uint ein, address[] memory firstChunk, address[] memory lastChunk, bool resetResolvers)\r\n        public _identityExists(ein)\r\n    {\r\n        require(!canRecover(ein), \"Recovery has not recently been triggered.\");\r\n        Identity storage _identity = identityDirectory[ein];\r\n\r\n        // ensure that the msg.sender was an old associated address for the referenced identity\r\n        address payable[1] memory middleChunk = [msg.sender];\r\n        require(\r\n            keccak256(\r\n                abi.encodePacked(firstChunk, middleChunk, lastChunk)\r\n            ) == recoveryLogs[ein].hashedOldAssociatedAddresses,\r\n            \"Cannot destroy an EIN from an address that was not recently removed from said EIN via recovery.\"\r\n        );\r\n\r\n        emit IdentityDestroyed(msg.sender, ein, _identity.recoveryAddress, resetResolvers);\r\n\r\n        resetIdentityData(_identity, address(0), resetResolvers);\r\n    }\r\n\r\n    /// @dev Common logic for clearing the data of an Identity.\r\n    function resetIdentityData(Identity storage identity, address newRecoveryAddress, bool resetResolvers) private {\r\n        for (uint i; i < identity.associatedAddresses.members.length; i++) {\r\n            delete associatedAddressDirectory[identity.associatedAddresses.members[i]];\r\n        }\r\n        delete identity.associatedAddresses;\r\n        delete identity.providers;\r\n        if (resetResolvers) delete identity.resolvers;\r\n        identity.recoveryAddress = newRecoveryAddress;\r\n    }\r\n\r\n\r\n    // Events //////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    event IdentityCreated(\r\n        address indexed initiator, uint indexed ein,\r\n        address recoveryAddress, address associatedAddress, address[] providers, address[] resolvers, bool delegated\r\n    );\r\n    event AssociatedAddressAdded(\r\n        address indexed initiator, uint indexed ein, address approvingAddress, address addedAddress, bool delegated\r\n    );\r\n    event AssociatedAddressRemoved(address indexed initiator, uint indexed ein, address removedAddress, bool delegated);\r\n    event ProviderAdded(address indexed initiator, uint indexed ein, address provider, bool delegated);\r\n    event ProviderRemoved(address indexed initiator, uint indexed ein, address provider, bool delegated);\r\n    event ResolverAdded(address indexed initiator, uint indexed ein, address resolvers, bool delegated);\r\n    event ResolverRemoved(address indexed initiator, uint indexed ein, address resolvers, bool delegated);\r\n    event RecoveryAddressChangeTriggered(\r\n        address indexed initiator, uint indexed ein,\r\n        address oldRecoveryAddress, address newRecoveryAddress, bool delegated\r\n    );\r\n    event RecoveryTriggered(\r\n        address indexed initiator, uint indexed ein, address[] oldAssociatedAddresses, address newAssociatedAddress\r\n    );\r\n    event IdentityDestroyed(address indexed initiator, uint indexed ein, address recoveryAddress, bool resolversReset);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"resolvers\",\"type\":\"address[]\"}],\"name\":\"addResolversFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getEIN\",\"outputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"providers\",\"type\":\"address[]\"}],\"name\":\"removeProvidersFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recoveryTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"name\":\"associatedAddress\",\"type\":\"address\"},{\"name\":\"providers\",\"type\":\"address[]\"},{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"createIdentityDelegated\",\"outputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRecoveryAddress\",\"type\":\"address\"}],\"name\":\"triggerRecoveryAddressChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"providers\",\"type\":\"address[]\"}],\"name\":\"removeProviders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasIdentity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"newRecoveryAddress\",\"type\":\"address\"}],\"name\":\"triggerRecoveryAddressChangeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"name\":\"providers\",\"type\":\"address[]\"},{\"name\":\"resolvers\",\"type\":\"address[]\"}],\"name\":\"createIdentity\",\"outputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"addressToAdd\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"addAssociatedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAssociatedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"isProviderFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signatureTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"resolvers\",\"type\":\"address[]\"}],\"name\":\"removeResolversFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"name\":\"identityExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"providers\",\"type\":\"address[]\"}],\"name\":\"addProviders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"name\":\"getIdentity\",\"outputs\":[{\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"name\":\"associatedAddresses\",\"type\":\"address[]\"},{\"name\":\"providers\",\"type\":\"address[]\"},{\"name\":\"resolvers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"isSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"newAssociatedAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"triggerRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"providers\",\"type\":\"address[]\"}],\"name\":\"addProvidersFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextEIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAssociatedAddressFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"addressToAdd\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"r\",\"type\":\"bytes32[2]\"},{\"name\":\"s\",\"type\":\"bytes32[2]\"},{\"name\":\"timestamp\",\"type\":\"uint256[2]\"}],\"name\":\"addAssociatedAddressDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAssociatedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolvers\",\"type\":\"address[]\"}],\"name\":\"removeResolvers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"isResolverFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addressToRemove\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"removeAssociatedAddressDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolvers\",\"type\":\"address[]\"}],\"name\":\"addResolvers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"firstChunk\",\"type\":\"address[]\"},{\"name\":\"lastChunk\",\"type\":\"address[]\"},{\"name\":\"resetResolvers\",\"type\":\"bool\"}],\"name\":\"triggerDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"associatedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"providers\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"resolvers\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"IdentityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"approvingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"addedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"AssociatedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"removedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"AssociatedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"ProviderAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"ProviderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolvers\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"ResolverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolvers\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"ResolverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldRecoveryAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newRecoveryAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"RecoveryAddressChangeTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldAssociatedAddresses\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"newAssociatedAddress\",\"type\":\"address\"}],\"name\":\"RecoveryTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"resolversReset\",\"type\":\"bool\"}],\"name\":\"IdentityDestroyed\",\"type\":\"event\"}]","ContractName":"IdentityRegistry","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5ac62bf39b6c8d4c7a2786deab282e24d15ff9d0c2c81f3f5c15f9d63a0e6401"}]}