{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// ---------------------------------------------------------------------------\r\n//  Pirate Lottery\r\n//\r\n// players purchase numbered tickets while a round is open; all the player's addresses are hashed together.\r\n//\r\n// after the round closes, the winner of the *previous* round can claim his prize, by signing a message:\r\n//  message = \"Pirate Lottery\" + hash(previous-round-player-addresses)\r\n//\r\n// the signature is hashed with hash(current-round-player-addresses) to produce a number X; and the\r\n// winner of the current round is selected as the holder of ticket number X modulo N, where N is the number\r\n// of tickets sold in the current round. the next round is then opened.\r\n//\r\n// there are only 2 possible lottery states:\r\n//  1) current round is open\r\n//     in this state players can purchase tickets.\r\n//     the previous round winner has been selected, but he cannot claim his prize yet.\r\n//     the round closes when all tickets have been sold or the maximum round duration elapses\r\n//\r\n//  2) current round closed\r\n//     in this state players cannot purchase tickets.\r\n//     the winner of the previous round can claim his prize.\r\n//     if the prize is not claimed within a certain time, then the prize is considered abandoned. in\r\n//     that case any participant in the round can claim half the prize.\r\n//     when the prize is claimed:\r\n//       a) the winner of the current round is selected\r\n//       b) a new round is opened\r\n//       c) what was the current round becomes the previous round\r\n//\r\n// ---------------------------------------------------------------------------\r\n\r\n//import './iPlpPointsRedeemer.sol';\r\n// interface for redeeming PLP Points\r\ncontract iPlpPointsRedeemer {\r\n  function reserveTokens() public view returns (uint remaining);\r\n  function transferFromReserve(address _to, uint _value) public;\r\n}\r\n\r\ncontract PirateLottery {\r\n\r\n  //\r\n  // events\r\n  //\r\n  event WinnerEvent(uint256 round, uint256 ticket, uint256 prize);\r\n  event PayoutEvent(uint256 round, address payee, uint256 prize, uint256 payout);\r\n\r\n\r\n  //\r\n  // defines\r\n  //\r\n  uint constant MIN_TICKETS = 10;\r\n  uint constant MAX_TICKETS = 50000000;\r\n  uint constant LONG_DURATION = 5 days;\r\n  uint constant SHORT_DURATION = 12 hours;\r\n  uint constant MAX_CLAIM_DURATION = 5 days;\r\n  uint constant TOKEN_HOLDOVER_THRESHOLD = 20 finney;\r\n\r\n\r\n  //\r\n  // Round structure\r\n  // all data pertinent to a single round of the lottery\r\n  //\r\n  struct Round {\r\n    uint256 maxTickets;\r\n    uint256 ticketPrice;\r\n    uint256 ticketCount;\r\n    bytes32 playersHash;\r\n    uint256 begDate;\r\n    uint256 endDate;\r\n    uint256 winner;\r\n    uint256 prize;\r\n    bool isOpen;\r\n    mapping (uint256 => address) ticketOwners;\r\n    mapping (address => uint256) playerTicketCounts;\r\n    mapping (address => mapping (uint256 => uint256)) playerTickets;\r\n  }\r\n\r\n  //\r\n  // Claim structure\r\n  // this struture must be signed, ala EIP 712, in order to claim the lottery prize\r\n  //\r\n  struct Claim {\r\n    uint256 ticket;\r\n    uint256 playerHash;\r\n  }\r\n  bytes32 private DOMAIN_SEPARATOR;\r\n  bytes32 private constant CLAIM_TYPEHASH = keccak256(\"Claim(string lottery,uint256 round,uint256 ticket,uint256 playerHash)\");\r\n  bytes32 private constant EIP712DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n\r\n\r\n  // -------------------------------------------------------------------------\r\n  // data storage\r\n  // -------------------------------------------------------------------------\r\n  bool    public isLocked;\r\n  string  public name;\r\n  address payable public owner;\r\n  bytes32 nameHash;\r\n  uint256 public min_ticket_price;\r\n  uint256 public max_ticket_price;\r\n  uint256 public roundCount;\r\n  mapping (uint256 => Round) public rounds;\r\n  mapping (address => uint256) public balances;\r\n  mapping (address => uint256) public plpPoints;\r\n  iPlpPointsRedeemer plpToken;\r\n  uint256 public tokenHoldoverBalance;\r\n\r\n  // -------------------------------------------------------------------------\r\n  // modifiers\r\n  // -------------------------------------------------------------------------\r\n  modifier ownerOnly {\r\n    require(msg.sender == owner, \"owner only\");\r\n    _;\r\n  }\r\n  modifier unlockedOnly {\r\n    require(!isLocked, \"unlocked only\");\r\n    _;\r\n  }\r\n\r\n\r\n  //\r\n  //  constructor\r\n  //\r\n  constructor(address _plpToken, uint256 _chainId, string memory _name, uint256 _min_ticket_price, uint256 _max_ticket_price) public {\r\n    owner = msg.sender;\r\n    name = _name;\r\n    min_ticket_price = _min_ticket_price;\r\n    max_ticket_price = _max_ticket_price;\r\n    plpToken = iPlpPointsRedeemer(_plpToken);\r\n    Round storage _currentRound = rounds[1];\r\n    Round storage _previousRound = rounds[0];\r\n    _previousRound.maxTickets = 1;\r\n    //_previousRound.ticketPrice = 0;\r\n    _previousRound.ticketCount = 1;\r\n    _previousRound.playersHash = keccak256(abi.encodePacked(bytes32(0), owner));\r\n    _previousRound.begDate = now;\r\n    _previousRound.endDate = now;\r\n    _previousRound.winner = 1;\r\n    _previousRound.ticketOwners[1] = msg.sender;\r\n    _previousRound.playerTickets[msg.sender][0] = 1;\r\n    _previousRound.playerTicketCounts[msg.sender]++;\r\n    //_previousRound.prize = 0;\r\n    _currentRound.maxTickets = 2;\r\n    _currentRound.ticketPrice = (min_ticket_price + max_ticket_price) / 2;\r\n    //_currentRound.ticketCount = 0;\r\n    //_currentRound.playersHash = 0;\r\n    //_currentRound.begDate = 0;\r\n    //_currentRound.endDate = 0;\r\n    //_currentRound.winner = 0;\r\n    //_currentRound.prize = 0;\r\n    _currentRound.isOpen = true;\r\n    roundCount = 1;\r\n    //eip 712\r\n    DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAIN_TYPEHASH,\r\n                                            keccak256(\"Pirate Lottery\"),\r\n                                            keccak256(\"1.0\"),\r\n                                            _chainId,\r\n                                            address(this)));\r\n    nameHash = keccak256(abi.encodePacked(name));\r\n  }\r\n  //for debug only...\r\n  function setToken(address _plpToken) public unlockedOnly ownerOnly {\r\n    plpToken = iPlpPointsRedeemer(_plpToken);\r\n  }\r\n  function lock() public ownerOnly {\r\n    isLocked = true;\r\n  }\r\n\r\n\r\n  //\r\n  // buy a ticket for the current round\r\n  //\r\n  function buyTicket() public payable {\r\n    Round storage _currentRound = rounds[roundCount];\r\n    require(_currentRound.isOpen == true, \"current round is closed\");\r\n    require(msg.value == _currentRound.ticketPrice, \"incorrect ticket price\");\r\n    if (_currentRound.ticketCount == 0)\r\n      _currentRound.begDate = now;\r\n    _currentRound.ticketCount++;\r\n    _currentRound.prize += msg.value;\r\n    plpPoints[msg.sender]++;\r\n    uint256 _ticket = _currentRound.ticketCount;\r\n    _currentRound.ticketOwners[_ticket] = msg.sender;\r\n    uint256 _playerTicketCount = _currentRound.playerTicketCounts[msg.sender];\r\n    _currentRound.playerTickets[msg.sender][_playerTicketCount] = _ticket;\r\n    _currentRound.playerTicketCounts[msg.sender]++;\r\n    _currentRound.playersHash = keccak256(abi.encodePacked(_currentRound.playersHash, msg.sender));\r\n    uint256 _currentDuration = now - _currentRound.begDate;\r\n    if (_currentRound.ticketCount == _currentRound.maxTickets || _currentDuration > LONG_DURATION) {\r\n      _currentRound.playersHash = keccak256(abi.encodePacked(_currentRound.playersHash, block.coinbase));\r\n      _currentRound.isOpen = false;\r\n      _currentRound.endDate = now;\r\n    }\r\n  }\r\n\r\n\r\n  //\r\n  // get info for the current round\r\n  // if the round is closed, then we are waiting for the winner of the previous round to claim his prize\r\n  //\r\n  function getCurrentInfo(address _addr) public view returns(uint256 _round, uint256 _playerTicketCount, uint256 _ticketPrice,\r\n                                                             uint256 _ticketCount, uint256 _begDate, uint256 _endDate, uint256 _prize,\r\n                                                             bool _isOpen, uint256 _maxTickets) {\r\n    Round storage _currentRound = rounds[roundCount];\r\n    _round = roundCount;\r\n    _playerTicketCount = _currentRound.playerTicketCounts[_addr];\r\n    _ticketPrice = _currentRound.ticketPrice;\r\n    _ticketCount = _currentRound.ticketCount;\r\n    _begDate = _currentRound.begDate;\r\n    _endDate = _currentRound.isOpen ? (_currentRound.begDate + LONG_DURATION) : _currentRound.endDate;\r\n    _prize = _currentRound.prize;\r\n    _isOpen = _currentRound.isOpen;\r\n    _maxTickets = _currentRound.maxTickets;\r\n  }\r\n\r\n\r\n  //\r\n  // get the winner of the previous round\r\n  //\r\n  function getPreviousInfo(address _addr) public view returns(uint256 _round, uint256 _playerTicketCount, uint256 _ticketPrice, uint256 _ticketCount,\r\n                                                              uint256 _begDate, uint256 _endDate, uint256 _prize,\r\n                                                              uint256 _winningTicket, address _winner, uint256 _claimDeadline, bytes32 _playersHash) {\r\n    Round storage _currentRound = rounds[roundCount];\r\n    Round storage _previousRound = rounds[roundCount - 1];\r\n    _round = roundCount - 1;\r\n    _playerTicketCount = _previousRound.playerTicketCounts[_addr];\r\n    _ticketPrice = _previousRound.ticketPrice;\r\n    _ticketCount = _previousRound.ticketCount;\r\n    _begDate = _previousRound.begDate;\r\n    _endDate = _previousRound.endDate;\r\n    _prize = _previousRound.prize;\r\n    _winningTicket = _previousRound.winner;\r\n    _winner = _previousRound.ticketOwners[_previousRound.winner];\r\n    if (_currentRound.isOpen == true) {\r\n      _playersHash = bytes32(0);\r\n      _claimDeadline = 0;\r\n    } else {\r\n      _playersHash = _currentRound.playersHash;\r\n      _claimDeadline = _currentRound.endDate + MAX_CLAIM_DURATION;\r\n    }\r\n  }\r\n\r\n\r\n  // get array of tickets owned by address\r\n  //\r\n  // note that array will always have _maxResults entries. ignore messageID = 0\r\n  //\r\n  function getTickets(address _addr, uint256 _round, uint256 _startIdx, uint256 _maxResults) public view returns(uint256 _idx, uint256[] memory _tickets) {\r\n    uint _count = 0;\r\n    Round storage _subjectRound = rounds[_round];\r\n    _tickets = new uint256[](_maxResults);\r\n    uint256 _playerTicketCount = _subjectRound.playerTicketCounts[_addr];\r\n    mapping(uint256 => uint256) storage _playerTickets = _subjectRound.playerTickets[_addr];\r\n    for (_idx = _startIdx; _idx < _playerTicketCount; ++_idx) {\r\n      _tickets[_count] = _playerTickets[_idx];\r\n      if (++_count >= _maxResults)\r\n        break;\r\n    }\r\n  }\r\n\r\n  // get owner of passed ticket\r\n  //\r\n  function getTicketOwner(uint256 _round, uint256 _ticket) public view returns(address _owner) {\r\n    Round storage _subjectRound = rounds[_round];\r\n    _owner = _subjectRound.ticketOwners[_ticket];\r\n  }\r\n\r\n\r\n  //\r\n  // winner of previous round claims his prize here\r\n  // note: you can only claim your prize while the current round is closed\r\n  // when the winner of the previous round claims his prize, we are then able to determine\r\n  // the winner of the current round, and then immediately start a new round\r\n  //\r\n  function claimPrize(uint8 _sigV, bytes32 _sigR, bytes32 _sigS, uint256 _ticket) public {\r\n    Round storage _currentRound = rounds[roundCount];\r\n    Round storage _previousRound = rounds[roundCount - 1];\r\n    require(_currentRound.isOpen == false, \"wait until current round is closed\");\r\n    require(_previousRound.winner == _ticket, \"not the winning ticket\");\r\n    claimPrizeForTicket(_sigV, _sigR, _sigS, _ticket, 2);\r\n    newRound();\r\n  }\r\n\r\n\r\n  //\r\n  // any participant of previous round claims an abandoned prize here\r\n  // only after MAX_CLAIM_DURATION\r\n  //\r\n  function claimAbondonedPrize(uint8 _sigV, bytes32 _sigR, bytes32 _sigS, uint256 _ticket) public {\r\n    Round storage _currentRound = rounds[roundCount];\r\n    require(_currentRound.isOpen == false, \"wait until current round is closed\");\r\n    require(now >= _currentRound.endDate + MAX_CLAIM_DURATION, \"prize is not abondoned yet\");\r\n    claimPrizeForTicket(_sigV, _sigR, _sigS, _ticket, 50);\r\n    newRound();\r\n  }\r\n\r\n\r\n  //\r\n  // verifies signature against claimed ticket; sends prize to claimer\r\n  // computes winner of current round\r\n  //\r\n  function claimPrizeForTicket(uint8 _sigV, bytes32 _sigR, bytes32 _sigS, uint256 _ticket, uint256 _ownerCutPct) internal {\r\n    Round storage _currentRound = rounds[roundCount];\r\n    Round storage _previousRound = rounds[roundCount - 1];\r\n    bytes32 _claimHash = keccak256(abi.encode(CLAIM_TYPEHASH, nameHash, roundCount - 1, _ticket, _currentRound.playersHash));\r\n    bytes32 _domainClaimHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, _claimHash));\r\n    address _recovered = ecrecover(_domainClaimHash, _sigV, _sigR, _sigS);\r\n    require(_previousRound.ticketOwners[_ticket] == _recovered, \"claim is not valid\");\r\n    uint256 _tokenCut = _ownerCutPct * _previousRound.prize / 100;\r\n    tokenHoldoverBalance += _tokenCut;\r\n    uint256 _payout = _previousRound.prize - _tokenCut;\r\n    balances[msg.sender] += _payout;\r\n    bytes32 _winningHash = keccak256(abi.encodePacked(_currentRound.playersHash, _sigV, _sigR, _sigS));\r\n    _currentRound.winner = uint256(_winningHash) % _currentRound.ticketCount + 1;\r\n    emit PayoutEvent(roundCount - 1, msg.sender, _previousRound.prize, _payout);\r\n    emit WinnerEvent(roundCount, _currentRound.winner, _currentRound.prize);\r\n    //\r\n    if (tokenHoldoverBalance > TOKEN_HOLDOVER_THRESHOLD) {\r\n      uint _amount = tokenHoldoverBalance;\r\n      tokenHoldoverBalance = 0;\r\n      (bool paySuccess, ) = address(plpToken).call.value(_amount)(\"\");\r\n      if (!paySuccess)\r\n        revert();\r\n    }\r\n  }\r\n\r\n\r\n  //\r\n  // open a new round - adjust lottery parameters\r\n  // goal is that duration should be between SHORT_DURATION and LONG_DURATION\r\n  // first we adjust ticket price, but if price is already at the corresponding limit, then we adjust maxTickets\r\n  //\r\n  function newRound() internal {\r\n    ++roundCount;\r\n    Round storage _nextRound = rounds[roundCount];\r\n    Round storage _currentRound = rounds[roundCount - 1];\r\n    uint256 _currentDuration = _currentRound.endDate - _currentRound.begDate;\r\n    //\r\n    if (_currentDuration < SHORT_DURATION) {\r\n      if (_currentRound.ticketPrice < max_ticket_price && _currentRound.maxTickets > MIN_TICKETS * 10) {\r\n         _nextRound.ticketPrice = max_ticket_price;\r\n         _nextRound.maxTickets = _currentRound.maxTickets;\r\n       } else {\r\n         _nextRound.ticketPrice = _currentRound.ticketPrice;\r\n         _nextRound.maxTickets = 2 * _currentRound.maxTickets;\r\n         if (_nextRound.maxTickets > MAX_TICKETS)\r\n           _nextRound.maxTickets = MAX_TICKETS;\r\n       }\r\n    } else if (_currentDuration > LONG_DURATION) {\r\n       if (_currentRound.ticketPrice > min_ticket_price) {\r\n         _nextRound.ticketPrice = min_ticket_price;\r\n         _nextRound.maxTickets = _currentRound.maxTickets;\r\n       } else {\r\n         _nextRound.ticketPrice = min_ticket_price;\r\n         _nextRound.maxTickets = _currentRound.maxTickets / 2;\r\n         if (_nextRound.maxTickets < MIN_TICKETS)\r\n           _nextRound.maxTickets = MIN_TICKETS;\r\n       }\r\n    } else {\r\n      _nextRound.maxTickets = _currentRound.maxTickets;\r\n      _nextRound.ticketPrice = (min_ticket_price + max_ticket_price) / 2;\r\n    }\r\n    //_nextRound.ticketCount = 0;\r\n    //_nextRound.endDate = 0;\r\n    //_nextRound.begDate = 0;\r\n    _nextRound.isOpen = true;\r\n  }\r\n\r\n\r\n  //\r\n  // redeem caller's transfer-points for PLP Tokens\r\n  // make sure the reserve account has sufficient tokens before calling\r\n  //\r\n  function redeemPlpPoints() public {\r\n    uint256 noTokens = plpPoints[msg.sender];\r\n    plpPoints[msg.sender] = 0;\r\n    plpToken.transferFromReserve(msg.sender, noTokens);\r\n  }\r\n\r\n\r\n  //\r\n  // withdraw accumulated prize\r\n  //\r\n  function withdraw() public {\r\n    uint256 _amount = balances[msg.sender];\r\n    balances[msg.sender] = 0;\r\n    msg.sender.transfer(_amount);\r\n  }\r\n\r\n\r\n  //\r\n  // for debug\r\n  // only available before the contract is locked\r\n  //\r\n  function killContract() public ownerOnly unlockedOnly {\r\n    selfdestruct(owner);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_sigV\",\"type\":\"uint8\"},{\"name\":\"_sigR\",\"type\":\"bytes32\"},{\"name\":\"_sigS\",\"type\":\"bytes32\"},{\"name\":\"_ticket\",\"type\":\"uint256\"}],\"name\":\"claimPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHoldoverBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemPlpPoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_ticket_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_plpToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_startIdx\",\"type\":\"uint256\"},{\"name\":\"_maxResults\",\"type\":\"uint256\"}],\"name\":\"getTickets\",\"outputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"},{\"name\":\"_tickets\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_ticket\",\"type\":\"uint256\"}],\"name\":\"getTicketOwner\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCurrentInfo\",\"outputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_playerTicketCount\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"name\":\"_ticketCount\",\"type\":\"uint256\"},{\"name\":\"_begDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_prize\",\"type\":\"uint256\"},{\"name\":\"_isOpen\",\"type\":\"bool\"},{\"name\":\"_maxTickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"maxTickets\",\"type\":\"uint256\"},{\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"name\":\"ticketCount\",\"type\":\"uint256\"},{\"name\":\"playersHash\",\"type\":\"bytes32\"},{\"name\":\"begDate\",\"type\":\"uint256\"},{\"name\":\"endDate\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"isOpen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sigV\",\"type\":\"uint8\"},{\"name\":\"_sigR\",\"type\":\"bytes32\"},{\"name\":\"_sigS\",\"type\":\"bytes32\"},{\"name\":\"_ticket\",\"type\":\"uint256\"}],\"name\":\"claimAbondonedPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"plpPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_ticket_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPreviousInfo\",\"outputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_playerTicketCount\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"name\":\"_ticketCount\",\"type\":\"uint256\"},{\"name\":\"_begDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_prize\",\"type\":\"uint256\"},{\"name\":\"_winningTicket\",\"type\":\"uint256\"},{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_claimDeadline\",\"type\":\"uint256\"},{\"name\":\"_playersHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_plpToken\",\"type\":\"address\"},{\"name\":\"_chainId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_min_ticket_price\",\"type\":\"uint256\"},{\"name\":\"_max_ticket_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticket\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"WinnerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"PayoutEvent\",\"type\":\"event\"}]","ContractName":"PirateLottery","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000135e60231111835ebaa24710b2fbb332fd9e5dc9000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000000000b1a2bc2ec50000000000000000000000000000000000000000000000000000000000000000000e506972617465277320426f6f7479000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://80ca882231245d6b5a47bfa4afae70a59c85b98e0b796f6b98b2b982e40f8a56"}]}