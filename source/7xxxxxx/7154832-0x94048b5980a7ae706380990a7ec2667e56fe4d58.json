{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n// File: @gnosis.pm/dx-contracts/contracts/base/AuctioneerManaged.sol\r\n\r\ncontract AuctioneerManaged {\r\n    // auctioneer has the power to manage some variables\r\n    address public auctioneer;\r\n\r\n    function updateAuctioneer(address _auctioneer) public onlyAuctioneer {\r\n        require(_auctioneer != address(0), \"The auctioneer must be a valid address\");\r\n        auctioneer = _auctioneer;\r\n    }\r\n\r\n    // > Modifiers\r\n    modifier onlyAuctioneer() {\r\n        // Only allows auctioneer to proceed\r\n        // R1\r\n        // require(msg.sender == auctioneer, \"Only auctioneer can perform this operation\");\r\n        require(msg.sender == auctioneer, \"Only the auctioneer can nominate a new one\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/dx-contracts/contracts/base/TokenWhitelist.sol\r\n\r\ncontract TokenWhitelist is AuctioneerManaged {\r\n    // Mapping that stores the tokens, which are approved\r\n    // Only tokens approved by auctioneer generate frtToken tokens\r\n    // addressToken => boolApproved\r\n    mapping(address => bool) public approvedTokens;\r\n\r\n    event Approval(address indexed token, bool approved);\r\n\r\n    /// @dev for quick overview of approved Tokens\r\n    /// @param addressesToCheck are the ERC-20 token addresses to be checked whether they are approved\r\n    function getApprovedAddressesOfList(address[] calldata addressesToCheck) external view returns (bool[] memory) {\r\n        uint length = addressesToCheck.length;\r\n\r\n        bool[] memory isApproved = new bool[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            isApproved[i] = approvedTokens[addressesToCheck[i]];\r\n        }\r\n\r\n        return isApproved;\r\n    }\r\n    \r\n    function updateApprovalOfToken(address[] memory token, bool approved) public onlyAuctioneer {\r\n        for (uint i = 0; i < token.length; i++) {\r\n            approvedTokens[token[i]] = approved;\r\n            emit Approval(token[i], approved);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/whitelisting/FixedPriceOracle.sol\r\n\r\n/**\r\n * @title An Ether-ERC20 token price oracle with an unmutable price\r\n * \r\n * @dev The prices are initialized when configuring the contract, then you \r\n *  freeze the contract disallowing any further modification.\r\n */\r\n\r\ncontract FixedPriceOracle {\r\n    mapping(address => Price) public prices;\r\n    bool public frozen;\r\n    address public owner;\r\n    TokenWhitelist public whitelist;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can do the operation\");\r\n        _;\r\n    }\r\n\r\n    modifier notFrozen() {\r\n        require(!frozen, \"The contract is frozen, not changes are allowed\");\r\n        _;\r\n    }\r\n\r\n    struct Price {\r\n        uint numerator;\r\n        uint denominator;\r\n    }\r\n\r\n    event PriceSet(address indexed token, uint numerator, uint denominator);\r\n\r\n    event Freeze();\r\n\r\n    constructor(address whitelistAddress) public {\r\n        owner = msg.sender;\r\n        whitelist = TokenWhitelist(whitelistAddress);\r\n    }\r\n\r\n    function hasReliablePrice(address token) public view returns (bool) {\r\n        return prices[token].denominator != 0;\r\n    }\r\n\r\n    function getPrice(address token) public view returns (uint, uint) {\r\n        bool approvedToken = whitelist.approvedTokens(token);\r\n\r\n        if (approvedToken) {\r\n            return getPriceValue(token);\r\n        } else {\r\n            return (0, 0);\r\n        }\r\n\r\n    }\r\n\r\n    function getPriceValue(address token) public view returns (uint, uint) {\r\n        Price memory price = prices[token];\r\n        return (price.numerator, price.denominator);\r\n    }\r\n\r\n    function setPrices(address[] memory tokens, uint[] memory numerators, uint[] memory denominators)\r\n        public\r\n        onlyOwner\r\n        notFrozen\r\n    {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            uint numerator = numerators[i];\r\n            uint denominator = denominators[i];\r\n\r\n            prices[token] = Price(numerator, denominator);\r\n            emit PriceSet(token, numerator, denominator);\r\n        }\r\n    }\r\n\r\n    function setPrice(address token, uint numerator, uint denominator) public onlyOwner notFrozen {\r\n        prices[token] = Price(numerator, denominator);\r\n        emit PriceSet(token, numerator, denominator);\r\n    }\r\n\r\n    function freeze() public onlyOwner {\r\n        frozen = true;\r\n        emit Freeze();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"numerators\",\"type\":\"uint256[]\"},{\"name\":\"denominators\",\"type\":\"uint256[]\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPriceValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"hasReliablePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"prices\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"whitelistAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Freeze\",\"type\":\"event\"}]","ContractName":"FixedPriceOracle","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009b455700c8540d350a58008a8ac650e75649fb6e","Library":"","SwarmSource":"bzzr://62163ae58e1bdd2ee8a9015f19353193c626ef9bbfc159b83fe668ab4586dbc8"}]}