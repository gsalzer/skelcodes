{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Source Code first verified at https://etherscan.io\r\n * WorldTrade asset Smart Contract v4.1\r\n*/\r\n\r\npragma solidity ^0.4.16;\r\n\r\n\r\n/*\r\n * @title Standard Token Contract\r\n *\r\n * ERC20-compliant tokens => https://github.com/ethereum/EIPs/issues/20\r\n * A token is a fungible virtual good that can be traded.\r\n * ERC-20 Tokens comply to the standard described in the Ethereum ERC-20 proposal.\r\n * Basic, standardized Token contract. Defines the functions to check token balances\r\n * send tokens, send tokens on behalf of a 3rd party and the corresponding approval process.\r\n *\r\n */\r\ncontract Token {\r\n\r\n\t// **** BASE FUNCTIONALITY\r\n\t// @notice For debugging purposes when using solidity online browser\r\n\tfunction whoAmI()  constant returns (address) {\r\n\t    return msg.sender;\r\n\t}\r\n\r\n\t// SC owners:\r\n\t\r\n\taddress owner;\r\n\t\r\n\tfunction isOwner() returns (bool) {\r\n\t\tif (msg.sender == owner) return true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// **** EVENTS\r\n\r\n\t// @notice A generic error log\r\n\tevent Error(string error);\r\n\r\n\r\n\t// **** DATA\r\n\tmapping (address => uint256) balances;\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\tuint256 public initialSupply; // Initial and total token supply\r\n\tuint256 public totalSupply;\r\n\t// bool allocated = false; // True after defining token parameters and initial mint\r\n\t\r\n\t// Public variables of the token, all used for display\r\n\t// HumanStandardToken is a specialisation of ERC20 defining these parameters\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tstring public standard = 'H0.1';\r\n\r\n\t// **** METHODS\r\n\t\r\n\t// Get total amount of tokens, totalSupply is a public var actually\r\n\t// function totalSupply() constant returns (uint256 totalSupply) {}\r\n\t\r\n\t// Get the account balance of another account with address _owner\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n \r\n \t// Send _amount amount of tokens to address _to\r\n\tfunction transfer(address _to, uint256 _amount) returns (bool success) {\r\n\t\tif (balances[msg.sender] < _amount) {\r\n\t\t\tError('transfer: the amount to transfer is higher than your token balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tbalances[msg.sender] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t\tTransfer(msg.sender, _to, _amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n \r\n \t// Send _amount amount of tokens from address _from to address _to\r\n \t// The transferFrom method is used for a withdraw workflow, allowing contracts to send \r\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge \r\n \t// fees in sub-currencies; the command should fail unless the _from account has \r\n \t// deliberately authorized the sender of the message via some mechanism\r\n\tfunction transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n\t\tif (balances[_from] < _amount) {\r\n\t\t\tError('transfer: the amount to transfer is higher than the token balance of the source');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (allowed[_from][msg.sender] < _amount) {\r\n\t\t\tError('transfer: the amount to transfer is higher than the maximum token transfer allowed by the source');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tbalances[_from] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t\tallowed[_from][msg.sender] -= _amount;\r\n\t\tTransfer(_from, _to, _amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n \r\n \t// Allow _spender to withdraw from your account, multiple times, up to the _amount amount. \r\n \t// If this function is called again it overwrites the current allowance with _amount.\r\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\r\n\t\tallowed[msg.sender][_spender] = _amount;\r\n\t\tApproval(msg.sender, _spender, _amount);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n \r\n \t// Returns the amount which _spender is still allowed to withdraw from _owner\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\t\r\n\t// Constructor: set up token properties and owner token balance\r\n\tfunction Token() {\r\n\t\t// This is the constructor, so owner should be equal to msg.sender, and this method should be called just once\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t\t// make sure owner address is configured\r\n\t\t// if(owner == 0x0) throw;\r\n\r\n\t\t// owner address can call this function\r\n\t\t// if (msg.sender != owner ) throw;\r\n\r\n\t\t// call this function just once\r\n\t\t// if (allocated) throw;\r\n\r\n\t\tinitialSupply = 50000000 * 1000000; // 50M tokens, 6 decimals\r\n\t\ttotalSupply = initialSupply;\r\n\t\t\r\n\t\tname = \"WorldTrade\";\r\n\t\tsymbol = \"WTE\";\r\n\t\tdecimals = 6;\r\n\r\n\t\tbalances[owner] = totalSupply;\r\n\t\tTransfer(this, owner, totalSupply);\r\n\r\n\t\t// allocated = true;\r\n\t}\r\n\r\n\t// **** EVENTS\r\n\t\r\n\t// Triggered when tokens are transferred\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n\t\r\n\t// Triggered whenever approve(address _spender, uint256 _amount) is called\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n}\r\n\r\n\r\n// Interface of issuer contract, just to cast the contract address and make it callable from the asset contract\r\ncontract IFIssuers {\r\n\t\r\n\t// **** DATA\r\n\t\r\n\t// **** FUNCTIONS\r\n\tfunction isIssuer(address _issuer) constant returns (bool);\r\n}\r\n\r\n\r\ncontract Asset is Token {\r\n\t// **** DATA\r\n\t\r\n\t/** Asset states\r\n\t*\r\n\t* - Released: Once issued the asset stays as released until sent for free to someone specified by issuer\r\n\t* - ForSale: The asset belongs to a user and is open to be sold\r\n\t* - Unfungible: The asset cannot be sold, remaining to the user it belongs to.\r\n\t*/\r\n\tenum assetStatus { Released, ForSale, Unfungible }\r\n\t// https://ethereum.stackexchange.com/questions/1807/enums-in-solidity\r\n\t\r\n\tstruct asst {\r\n\t\tuint256 assetId;\r\n\t\taddress assetOwner;\r\n\t\taddress issuer;\r\n\t\tstring content; // a JSON object containing the image data of the asset and its title\r\n\t\tuint256 sellPrice; // in WorldTrade tokens, how many of them for this asset\r\n\t\tassetStatus status; // behaviour (tradability) of the asset depends upon its status\r\n\t}\r\n\r\n\tmapping (uint256 => asst) assetsById;\r\n\tuint256 lastAssetId; // Last assetId\r\n\taddress public SCIssuers; // Contract that defines who is an issuer and who is not\r\n\tuint256 assetFeeIssuer; // Fee percentage for Issuer on every asset sale transaction\r\n\tuint256 assetFeeWorldTrade; // Fee percentage for WorldTrade on every asset sale transaction\r\n\t\r\n\r\n\t// **** METHODS\r\n\t\r\n\t// Constructor\r\n\tfunction Asset(address _SCIssuers) {\r\n\t\tSCIssuers = _SCIssuers;\r\n\t}\r\n\t\r\n\t// Queries the asset, knowing the id\r\n\tfunction getAssetById(uint256 assetId) constant returns (uint256 _assetId, address _assetOwner, address _issuer, string _content, uint256 _sellPrice, uint256 _status) {\r\n\t\treturn (assetsById[assetId].assetId, assetsById[assetId].assetOwner, assetsById[assetId].issuer, assetsById[assetId].content, assetsById[assetId].sellPrice, uint256(assetsById[assetId].status));\r\n\t}\r\n\r\n\t// Seller sends an owned asset to a buyer, providing its allowance matches token price and transfer the tokens from buyer\r\n\tfunction sendAssetTo(uint256 assetId, address assetBuyer) returns (bool) {\r\n\t\t// assetId must not be zero\r\n\t\tif (assetId == 0) {\r\n\t\t\tError('sendAssetTo: assetId must not be zero');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Check whether the asset belongs to the seller\r\n\t\tif (assetsById[assetId].assetOwner != msg.sender) {\r\n\t\t\tError('sendAssetTo: the asset does not belong to you, the seller');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tif (assetsById[assetId].sellPrice > 0) { // for non-null token paid transactions\r\n\t\t\t// Check whether there is balance enough from the buyer to get its tokens\r\n\t\t\tif (balances[assetBuyer] < assetsById[assetId].sellPrice) {\r\n\t\t\t\tError('sendAssetTo: there is not enough balance from the buyer to get its tokens');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Check whether there is allowance enough from the buyer to get its tokens\r\n\t\t\tif (allowance(assetBuyer, msg.sender) < assetsById[assetId].sellPrice) {\r\n\t\t\t\tError('sendAssetTo: there is not enough allowance from the buyer to get its tokens');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Get the buyer tokens\r\n\t\t\tif (!transferFrom(assetBuyer, msg.sender, assetsById[assetId].sellPrice)) {\r\n\t\t\t\tError('sendAssetTo: transferFrom failed'); // This shouldn't happen ever, but just in case...\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Set the asset status to Unfungible\r\n\t\tassetsById[assetId].status = assetStatus.Unfungible;\r\n\t\t\r\n\t\t// Transfer the asset to the buyer\r\n\t\tassetsById[assetId].assetOwner = assetBuyer;\r\n\t\t\r\n\t\t// Event log\r\n\t\tSendAssetTo(assetId, assetBuyer);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t// Buyer gets an asset providing it is in ForSale status, and pays the corresponding tokens to the seller/owner. amount must match assetPrice to have a deal.\r\n\tfunction buyAsset(uint256 assetId, uint256 amount) returns (bool) {\r\n\t\t// assetId must not be zero\r\n\t\tif (assetId == 0) {\r\n\t\t\tError('buyAsset: assetId must not be zero');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Check whether the asset is in ForSale status\r\n\t\tif (assetsById[assetId].status != assetStatus.ForSale) {\r\n\t\t\tError('buyAsset: the asset is not for sale');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Check whether the asset price is the same as amount\r\n\t\tif (assetsById[assetId].sellPrice != amount) {\r\n\t\t\tError('buyAsset: the asset price does not match the specified amount');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tif (assetsById[assetId].sellPrice > 0) { // for non-null token paid transactions\r\n\t\t\t// Check whether there is balance enough from the buyer to pay the asset\r\n\t\t\tif (balances[msg.sender] < assetsById[assetId].sellPrice) {\r\n\t\t\t\tError('buyAsset: there is not enough token balance to buy this asset');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Calculate the seller income\r\n\t\t\tuint256 sellerIncome = assetsById[assetId].sellPrice * (1000 - assetFeeIssuer - assetFeeWorldTrade) / 1000;\r\n\r\n\t\t\t// Send the buyer's tokens to the seller\r\n\t\t\tif (!transfer(assetsById[assetId].assetOwner, sellerIncome)) {\r\n\t\t\t\tError('buyAsset: seller token transfer failed'); // This shouldn't happen ever, but just in case...\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Send the issuer's fee\r\n\t\t\tuint256 issuerIncome = assetsById[assetId].sellPrice * assetFeeIssuer / 1000;\r\n\t\t\tif (!transfer(assetsById[assetId].issuer, issuerIncome)) {\r\n\t\t\t\tError('buyAsset: issuer token transfer failed'); // This shouldn't happen ever, but just in case...\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Send the WorldTrade's fee\r\n\t\t\tuint256 WorldTradeIncome = assetsById[assetId].sellPrice * assetFeeWorldTrade / 1000;\r\n\t\t\tif (!transfer(owner, WorldTradeIncome)) {\r\n\t\t\t\tError('buyAsset: WorldTrade token transfer failed'); // This shouldn't happen ever, but just in case...\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n\t\t// Set the asset status to Unfungible\r\n\t\tassetsById[assetId].status = assetStatus.Unfungible;\r\n\t\t\r\n\t\t// Transfer the asset to the buyer\r\n\t\tassetsById[assetId].assetOwner = msg.sender;\r\n\t\t\r\n\t\t// Event log\r\n\t\tBuyAsset(assetId, amount);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t// To limit issue functions just to authorized issuers\r\n\tmodifier onlyIssuer() {\r\n\t    if (!IFIssuers(SCIssuers).isIssuer(msg.sender)) {\r\n\t    \tError('onlyIssuer function called by user that is not an authorized issuer');\r\n\t    } else {\r\n\t    \t_;\r\n\t    }\r\n\t}\r\n\r\n\t\r\n\t// To be called by issueAssetTo() and properly authorized issuers\r\n\tfunction issueAsset(string content, uint256 sellPrice) onlyIssuer internal returns (uint256 nextAssetId) {\r\n\t\t// Find out next asset Id\r\n\t\tnextAssetId = lastAssetId + 1;\r\n\t\t\r\n\t\tassetsById[nextAssetId].assetId = nextAssetId;\r\n\t\tassetsById[nextAssetId].assetOwner = msg.sender;\r\n\t\tassetsById[nextAssetId].issuer = msg.sender;\r\n\t\tassetsById[nextAssetId].content = content;\r\n\t\tassetsById[nextAssetId].sellPrice = sellPrice;\r\n\t\tassetsById[nextAssetId].status = assetStatus.Released;\r\n\t\t\r\n\t\t// Update lastAssetId\r\n\t\tlastAssetId++;\r\n\r\n\t\t// Event log\r\n\t\tIssueAsset(nextAssetId, msg.sender, sellPrice);\r\n\t\t\r\n\t\treturn nextAssetId;\r\n\t}\r\n\t\r\n\t// Issuer sends a new free asset to a given user as a gift\r\n\tfunction issueAssetTo(string content, address to) returns (bool) {\r\n\t\tuint256 assetId = issueAsset(content, 0); // 0 tokens, as a gift\r\n\t\tif (assetId == 0) {\r\n\t\t\tError('issueAssetTo: asset has not been properly issued');\r\n\t\t\treturn (false);\r\n\t\t}\r\n\t\t\r\n\t\t// The brand new asset is inmediatly sent to the recipient\r\n\t\treturn(sendAssetTo(assetId, to));\r\n\t}\r\n\t\r\n\t// Seller can block tradability of its assets\r\n\tfunction setAssetUnfungible(uint256 assetId) returns (bool) {\r\n\t\t// assetId must not be zero\r\n\t\tif (assetId == 0) {\r\n\t\t\tError('setAssetUnfungible: assetId must not be zero');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Check whether the asset belongs to the caller\r\n\t\tif (assetsById[assetId].assetOwner != msg.sender) {\r\n\t\t\tError('setAssetUnfungible: only owners of the asset are allowed to update its status');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tassetsById[assetId].status = assetStatus.Unfungible;\r\n\r\n\t\t// Event log\r\n\t\tSetAssetUnfungible(assetId, msg.sender);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Seller updates the price of its assets and its status to ForSale\r\n\tfunction setAssetPrice(uint256 assetId, uint256 sellPrice) returns (bool) {\r\n\t\t// assetId must not be zero\r\n\t\tif (assetId == 0) {\r\n\t\t\tError('setAssetPrice: assetId must not be zero');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Check whether the asset belongs to the caller\r\n\t\tif (assetsById[assetId].assetOwner != msg.sender) {\r\n\t\t\tError('setAssetPrice: only owners of the asset are allowed to set its price and update its status');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tassetsById[assetId].sellPrice = sellPrice;\r\n\t\tassetsById[assetId].status = assetStatus.ForSale;\r\n\r\n\t\t// Event log\r\n\t\tSetAssetPrice(assetId, msg.sender, sellPrice);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Owner updates the fees for assets sale transactions\r\n\tfunction setAssetSaleFees(uint256 feeIssuer, uint256 feeWorldTrade) returns (bool) {\r\n\t\t// Check this is called by owner\r\n\t\tif (!isOwner()) {\r\n\t\t\tError('setAssetSaleFees: only Owner is authorized to update asset sale fees.');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Check new fees are consistent\r\n\t\tif (feeIssuer + feeWorldTrade > 1000) {\r\n\t\t\tError('setAssetSaleFees: added fees exceed 100.0%. Not updated.');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tassetFeeIssuer = feeIssuer;\r\n\t\tassetFeeWorldTrade = feeWorldTrade;\r\n\r\n\t\t// Event log\r\n\t\tSetAssetSaleFees(feeIssuer, feeWorldTrade);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when a seller sends its asset to a buyer and receives the corresponding tokens\r\n\tevent SendAssetTo(uint256 assetId, address assetBuyer);\r\n\t\r\n\t// Triggered when a buyer sends its tokens to a seller and receives the specified asset\r\n\tevent BuyAsset(uint256 assetId, uint256 amount);\r\n\r\n\t// Triggered when the admin issues a new asset\r\n\tevent IssueAsset(uint256 nextAssetId, address assetOwner, uint256 sellPrice);\r\n\t\r\n\t// Triggered when the user updates its asset status to Unfungible\r\n\tevent SetAssetUnfungible(uint256 assetId, address assetOwner);\r\n\r\n\t// Triggered when the user updates its asset price and status to ForSale\r\n\tevent SetAssetPrice(uint256 assetId, address assetOwner, uint256 sellPrice);\r\n\t\r\n\t// Triggered when the owner updates the asset sale fees\r\n\tevent SetAssetSaleFees(uint256 feeIssuer, uint256 feeWorldTrade);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"assetBuyer\",\"type\":\"address\"}],\"name\":\"sendAssetTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"setAssetUnfungible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"setAssetPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"content\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"issueAssetTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetById\",\"outputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"},{\"name\":\"_assetOwner\",\"type\":\"address\"},{\"name\":\"_issuer\",\"type\":\"address\"},{\"name\":\"_content\",\"type\":\"string\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeIssuer\",\"type\":\"uint256\"},{\"name\":\"feeWorldTrade\",\"type\":\"uint256\"}],\"name\":\"setAssetSaleFees\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whoAmI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCIssuers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_SCIssuers\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetBuyer\",\"type\":\"address\"}],\"name\":\"SendAssetTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextAssetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"IssueAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetOwner\",\"type\":\"address\"}],\"name\":\"SetAssetUnfungible\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"SetAssetPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"feeIssuer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeWorldTrade\",\"type\":\"uint256\"}],\"name\":\"SetAssetSaleFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"error\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Asset","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000007c50d92c242fb846a6c3606265a4c51bb7602eb","Library":"","SwarmSource":"bzzr://c5ee539be752377e8fb5bb770cbee118f4c8fad7b56650be988bf1ad06cd2719"}]}