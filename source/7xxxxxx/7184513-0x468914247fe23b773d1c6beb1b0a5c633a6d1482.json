{"status":"1","message":"OK","result":[{"SourceCode":"/*  \r\n    Subscrypto\r\n    Copyright (C) 2019 Subscrypto Team\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity 0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract DAI {\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n    mapping(address => uint) public balanceOf;\r\n\r\n    function transferFrom(address src, address dst, uint wad) public returns (bool);\r\n}\r\n\r\n\r\n/// @author The Subscrypto Team\r\n/// @title Subscrypto recurring payments in DAI\r\ncontract SubscryptoDAI {\r\n    using SafeMath for uint;\r\n    DAI public daiContract;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param daiContractAddress address\r\n     */\r\n    constructor(address daiContractAddress) public {\r\n        daiContract = DAI(daiContractAddress);\r\n    }\r\n\r\n    event NewSubscription(\r\n        address indexed subscriber,\r\n        address indexed receiver,\r\n        uint daiWad,\r\n        uint32 interval\r\n    );\r\n\r\n    event Unsubscribe(\r\n        address indexed subscriber, \r\n        address indexed receiver\r\n    );\r\n\r\n    event ReceiverPaymentsCollected(\r\n        address indexed receiver,\r\n        uint daiWad,\r\n        uint startIndex,\r\n        uint endIndex\r\n    );\r\n\r\n    event SubscriptionPaid(\r\n        address indexed subscriber,\r\n        address indexed receiver,\r\n        uint daiWad,\r\n        uint48 effectiveTimestamp\r\n    );\r\n\r\n    event UnfundedPayment(\r\n        address indexed subscriber,\r\n        address indexed receiver,\r\n        uint daiWad\r\n    );\r\n\r\n    event StaleSubscription(\r\n        address indexed subscriber,\r\n        address indexed receiver\r\n    );\r\n\r\n    event SubscriptionDeactivated(\r\n        address indexed subscriber,\r\n        address indexed receiver\r\n    );\r\n\r\n    event SubscriptionReactivated(\r\n        address indexed subscriber,\r\n        address indexed receiver\r\n    );\r\n\r\n    // Conservative amount of gas used per loop in executeDebits()\r\n    uint constant MIN_GAS_PER_EXECUTE_DEBIT = 45000;\r\n    // Force subscribers to use multiple accounts when this limit is reached.\r\n    uint constant MAX_SUBSCRIPTION_PER_SUBSCRIBER = 10000;\r\n    // Minimum payment of 1 DAI\r\n    uint constant MIN_SUBSCRIPTION_DAI_WAD = 1**18;\r\n\r\n    struct Subscription {\r\n        bool    isActive;        //  1 byte\r\n        uint48  nextPaymentTime; //  6 bytes\r\n        uint32  interval;        //  4 bytes\r\n        address subscriber;      // 20 bytes\r\n        address receiver;        // 20 bytes\r\n        uint    daiWad;          // 32 bytes\r\n    }\r\n\r\n    // global counter for suscriptions\r\n    uint64 nextIndex = 1;\r\n\r\n    // source of truth for subscriptions\r\n    mapping(uint64 => Subscription) public subscriptions;\r\n\r\n    // subscriber => receiver => subsciptionIndex\r\n    mapping(address => mapping(address => uint64)) public subscriberReceiver;\r\n\r\n    // receiver => subs array\r\n    mapping(address => uint64[]) public receiverSubs;\r\n\r\n    // subscriber => subs array\r\n    mapping(address => uint64[]) public subscriberSubs;\r\n\r\n    /**\r\n     * Create a new subscription. Must be called by the subscriber's account.\r\n     * First payment of `daiWad` is paid on creation.\r\n     * @param receiver address\r\n     * @param daiWad subscription amount in wad format\r\n     * @param interval seconds between payments\r\n     */\r\n    function subscribe(address receiver, uint daiWad, uint32 interval) external {\r\n        uint64 existingIndex = subscriberReceiver[msg.sender][receiver];\r\n        require(subscriptions[existingIndex].daiWad == 0, \"Subscription exists\");\r\n        require(daiWad >= MIN_SUBSCRIPTION_DAI_WAD, \"Subsciption amount too low\");\r\n        require(interval >= 86400, \"Interval must be at least 1 day\");\r\n        require(interval <= 31557600, \"Interval must be at most 1 year\");\r\n        require(subscriberSubs[msg.sender].length < MAX_SUBSCRIPTION_PER_SUBSCRIBER,\"Subscription count limit reached\");\r\n\r\n        // first payment\r\n        require(daiContract.transferFrom(msg.sender, receiver, daiWad), \"DAI transferFrom() failed\");\r\n\r\n        // add to subscription mappings\r\n        subscriptions[nextIndex] = Subscription(\r\n            true,\r\n            uint48(now.add(interval)),\r\n            interval,\r\n            msg.sender,\r\n            receiver,\r\n            daiWad\r\n        );\r\n        subscriberReceiver[msg.sender][receiver] = nextIndex;\r\n        receiverSubs[receiver].push(nextIndex);\r\n        subscriberSubs[msg.sender].push(nextIndex);\r\n\r\n        emit NewSubscription(msg.sender, receiver, daiWad, interval);\r\n        emit SubscriptionPaid(msg.sender, receiver, daiWad, uint48(now));\r\n\r\n        nextIndex++;\r\n    }\r\n    \r\n    /**\r\n     * Deactivate a subscription. Must be called by the subscriber's account.\r\n     * Payments cannot be collected from deactivated subscriptons.\r\n     * @param receiver address used to identify the unique subscriber-receiver pair.\r\n     * @return success\r\n     */\r\n    function deactivateSubscription(address receiver) external returns (bool) {\r\n        uint64 index = subscriberReceiver[msg.sender][receiver];\r\n        require(index != 0, \"Subscription does not exist\");\r\n\r\n        Subscription storage sub = subscriptions[index];\r\n        require(sub.isActive, \"Subscription is already disabled\");\r\n        require(sub.daiWad > 0, \"Subscription does not exist\");\r\n\r\n        sub.isActive = false;\r\n        emit SubscriptionDeactivated(msg.sender, receiver);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Reactivate a subscription. Must be called by the subscriber's account.\r\n     * If less than one interval has passed since the last payment, no payment is collected now.\r\n     * Otherwise it is treated as a new subscription starting now, and the first payment is collected.\r\n     * No back-payments are collected.\r\n     * @param receiver addres used to identify the unique subscriber-receiver pair.\r\n     * @return success\r\n     */\r\n    function reactivateSubscription(address receiver) external returns (bool) {\r\n        uint64 index = subscriberReceiver[msg.sender][receiver];\r\n        require(index != 0, \"Subscription does not exist\");\r\n\r\n        Subscription storage sub = subscriptions[index];\r\n        require(!sub.isActive, \"Subscription is already active\");\r\n\r\n        sub.isActive = true;\r\n        emit SubscriptionReactivated(msg.sender, receiver);\r\n\r\n        if (calculateUnpaidIntervalsUntil(sub, now) > 0) {\r\n            // only make a payment if at least one interval has lapsed since the last payment\r\n            require(daiContract.transferFrom(msg.sender, receiver, sub.daiWad), \"Insufficient funds to reactivate subscription\");\r\n            emit SubscriptionPaid(msg.sender, receiver, sub.daiWad, uint48(now));\r\n        }\r\n\r\n        sub.nextPaymentTime = uint48(now.add(sub.interval));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Delete a subscription. Must be called by the subscriber's account.\r\n     * @param receiver address used to identify the unique subscriber-receiver pair.\r\n     */\r\n    function unsubscribe(address receiver) external {\r\n        uint64 index = subscriberReceiver[msg.sender][receiver];\r\n        require(index != 0, \"Subscription does not exist\");\r\n        delete subscriptions[index];\r\n        delete subscriberReceiver[msg.sender][receiver];\r\n        deleteElement(subscriberSubs[msg.sender], index);\r\n        emit Unsubscribe(msg.sender, receiver);\r\n    }\r\n\r\n    /**\r\n     * Delete a subscription. Must be called by the receiver's account.\r\n     * @param subscriber address used to identify the unique subscriber-receiver pair.\r\n     */\r\n    function unsubscribeByReceiver(address subscriber) external {\r\n        uint64 index = subscriberReceiver[subscriber][msg.sender];\r\n        require(index != 0, \"Subscription does not exist\");\r\n        delete subscriptions[index];\r\n        delete subscriberReceiver[subscriber][msg.sender];\r\n        deleteElement(subscriberSubs[subscriber], index);\r\n        emit Unsubscribe(subscriber, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Collect all available *funded* payments for a receiver's account.\r\n     * Helper function that calls executeDebitsRange() with the full range.\r\n     * Will process as many payments as possible with the gas provided and exit gracefully.\r\n     * \r\n     * @param receiver address\r\n     */\r\n    function executeDebits(address receiver) external {\r\n        executeDebitsRange(receiver, 0, receiverSubs[receiver].length);\r\n    }\r\n\r\n    /**\r\n     * A read-only version of executeDebits()\r\n     * Calculates uncollected *funded* payments for a receiver.\r\n     * @param receiver address\r\n     * @return total unclaimed value in wad format\r\n     */\r\n    function getTotalUnclaimedPayments(address receiver) external view returns (uint) {\r\n        uint totalPayment = 0;\r\n\r\n        for (uint i = 0; i < receiverSubs[receiver].length; i++) {\r\n            Subscription storage sub = subscriptions[receiverSubs[receiver][i]];\r\n\r\n            if (sub.isActive && sub.daiWad != 0) {\r\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\r\n                if (wholeUnpaidIntervals > 0) {\r\n                    uint authorizedBalance = allowedBalance(sub.subscriber);\r\n\r\n                    do {\r\n                        if (authorizedBalance >= sub.daiWad) {\r\n                            totalPayment = totalPayment.add(sub.daiWad);\r\n                            authorizedBalance = authorizedBalance.sub(sub.daiWad);\r\n                        }\r\n                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\r\n                    } while (wholeUnpaidIntervals > 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        return totalPayment;\r\n    }\r\n\r\n    /**\r\n     * Calculates a subscriber's total outstanding payments in dai (wad format)\r\n     * @param subscriber address\r\n     * @param time in seconds. If `time` < `now`, then we simply use `now`\r\n     * @return total amount owed at `time` in dai (wad format)\r\n     */\r\n    function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) {\r\n        uint until = time <= now ? now : time;\r\n\r\n        uint64[] memory subs = subscriberSubs[subscriber];\r\n\r\n        uint totalDaiWad = 0;\r\n        for (uint64 i = 0; i < subs.length; i++) {\r\n            Subscription memory sub = subscriptions[subs[i]];\r\n            if (sub.isActive) {\r\n                totalDaiWad = totalDaiWad.add(sub.daiWad.mul(calculateUnpaidIntervalsUntil(sub, until)));\r\n            }\r\n        }\r\n\r\n        return totalDaiWad;\r\n    }\r\n\r\n    /**\r\n     * Collect available *funded* payments for a receiver's account within a certain range of receiverSubs[receiver].\r\n     * Will process as many payments as possible with the gas provided and exit gracefully.\r\n     * \r\n     * @param receiver address\r\n     * @param start starting index of receiverSubs[receiver]\r\n     * @param end ending index of receiverSubs[receiver]\r\n     * @return last processed index\r\n     */\r\n    function executeDebitsRange(address receiver, uint start, uint end) public returns (uint) {\r\n        uint64[] storage subs = receiverSubs[receiver];\r\n        require(subs.length > 0, \"receiver has no subscriptions\");\r\n        require(start < end && end <= subs.length, \"wrong arguments for range\");\r\n        uint totalPayment = 0;\r\n\r\n        uint last = end;\r\n        uint i = start;\r\n        while (i < last) {\r\n            if (gasleft() < MIN_GAS_PER_EXECUTE_DEBIT) {\r\n                break;\r\n            }\r\n            Subscription storage sub = subscriptions[subs[i]];\r\n\r\n            // delete empty subs\r\n            while (sub.daiWad == 0 && subs.length > 0) {\r\n                uint lastIndex = subs.length.sub(1);\r\n                subs[i] = subs[lastIndex];\r\n                delete(subs[lastIndex]);\r\n                subs.length = lastIndex;\r\n                if (last > lastIndex) {\r\n                    last = lastIndex;\r\n                }\r\n                if (lastIndex > 0) {\r\n                    sub = subscriptions[subs[i]];\r\n                }\r\n            }\r\n\r\n            if (sub.isActive && sub.daiWad != 0) {\r\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\r\n                if (wholeUnpaidIntervals > 0) {\r\n                    uint authorizedBalance = allowedBalance(sub.subscriber);\r\n\r\n                    do {\r\n                        if (authorizedBalance >= sub.daiWad) {\r\n                            assert(daiContract.transferFrom(sub.subscriber, receiver, sub.daiWad));\r\n                            sub.nextPaymentTime = calculateNextPaymentTime(sub);\r\n                            totalPayment = totalPayment.add(sub.daiWad);\r\n                            emit SubscriptionPaid(sub.subscriber, receiver, sub.daiWad, sub.nextPaymentTime);\r\n                        } else {\r\n                            emit UnfundedPayment(sub.subscriber, receiver, sub.daiWad);\r\n\r\n                            if (wholeUnpaidIntervals >= 2) {\r\n                                sub.isActive = false;\r\n                                emit SubscriptionDeactivated(sub.subscriber, receiver);\r\n                                emit StaleSubscription(sub.subscriber, receiver);\r\n                                break;\r\n                            }\r\n                        }\r\n                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\r\n                    } while (wholeUnpaidIntervals > 0);\r\n                }\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        emit ReceiverPaymentsCollected(receiver, totalPayment, start, i);\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * Calculates how much DAI balance Subscrypto is authorized to use on bealf of `payer`.\r\n     * Returns the minimum(payer's DAI balance, amount authorized to Subscrypto).\r\n     * @param payer address\r\n     * @return wad amount of DAI available for Subscrypto payments\r\n     */\r\n    function allowedBalance(address payer) public view returns (uint) {\r\n        uint balance = daiContract.balanceOf(payer);\r\n        uint allowance = daiContract.allowance(payer, address(this));\r\n\r\n        return balance > allowance ? allowance : balance;\r\n    }\r\n\r\n    /**\r\n     * Helper function to search for and delete an array element without leaving a gap.\r\n     * Array size is also decremented.\r\n     * DO NOT USE if ordering is important.\r\n     * @param array array to be modified\r\n     * @param element value to be removed\r\n     */\r\n    function deleteElement(uint64[] storage array, uint64 element) internal {\r\n        uint lastIndex = array.length.sub(1);\r\n        for (uint i = 0; i < array.length; i++) {\r\n            if (array[i] == element) {\r\n                array[i] = array[lastIndex];\r\n                delete(array[lastIndex]);\r\n                array.length = lastIndex;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates how many whole unpaid intervals (will) have elapsed since the last payment at a specific `time`.\r\n     * DOES NOT check if subscriber account is funded.\r\n     * @param sub Subscription object\r\n     * @param time timestamp in seconds\r\n     * @return number of unpaid intervals\r\n     */\r\n    function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) {\r\n        require(time >= now, \"don't use a time before now\");\r\n\r\n        if (time > sub.nextPaymentTime) {\r\n            return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Safely calculate the next payment timestamp for a Subscription\r\n     * @param sub Subscription object\r\n     * @return uint48 timestamp in seconds of the next payment\r\n     */\r\n    function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) {\r\n        uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval;\r\n        assert(nextPaymentTime > sub.nextPaymentTime);\r\n        return nextPaymentTime;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"daiContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deactivateSubscription\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"unsubscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"outstandingBalanceUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"allowedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"executeDebitsRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"unsubscribeByReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"subscriptions\",\"outputs\":[{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"nextPaymentTime\",\"type\":\"uint48\"},{\"name\":\"interval\",\"type\":\"uint32\"},{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"daiWad\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"executeDebits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"receiverSubs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscriberReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subscriberSubs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"daiWad\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"subscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"reactivateSubscription\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getTotalUnclaimedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"daiContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"daiWad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"NewSubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"Unsubscribe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"daiWad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"ReceiverPaymentsCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"daiWad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"effectiveTimestamp\",\"type\":\"uint48\"}],\"name\":\"SubscriptionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"daiWad\",\"type\":\"uint256\"}],\"name\":\"UnfundedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"StaleSubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"SubscriptionDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"SubscriptionReactivated\",\"type\":\"event\"}]","ContractName":"SubscryptoDAI","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359","Library":"","SwarmSource":"bzzr://1d689953dfead55862e2f690d15802f45c8d9871c27ca5831b08f63d919319a6"}]}