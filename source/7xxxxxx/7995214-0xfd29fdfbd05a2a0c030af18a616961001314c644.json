{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n/**\n* @title Multisend contract\n* @dev Provides ability to send multiple ERC20 tokens and ether within one transaction\n**/\ncontract Multisend {\n  using SafeMath for uint256;\n\n  address payable private _owner; // owner of the contract\n  mapping(address => bool) public whitelist; //whitelisted contract address to transfer to\n  uint private _fee; // amount in basis points to take from each deposit\n  mapping(address => mapping(address => uint256)) public balances; // deposited token/ether balances\n\n\n  /**\n  * @param initialFee amount of fees taken per transaction in basis points\n  **/\n  constructor(uint256 initialFee) public {\n    _owner = msg.sender;\n    _fee = initialFee;\n  }\n\n  /**\n  * @dev Deposit token into this contract to use for sending\n  * @param tokenDepositAddress token contract addresses to deposit tokens from\n  * @param tokenDepositAmount amount of tokens to deposit\n  * @dev for ether transactions use address(0) as token contract address\n  **/\n  function deposit(address[] memory tokenDepositAddress, uint256[] memory tokenDepositAmount) public payable {\n    require(tokenDepositAddress.length == tokenDepositAmount.length);\n    // if any ether was sent\n    if(msg.value != 0) {\n      uint256 etherFee = msg.value.div(10000).mul(_fee); //calculate fee\n      balances[msg.sender][address(0)] = balances[msg.sender][address(0)].add(msg.value.sub(etherFee));\n      balances[address(this)][address(0)] = balances[address(this)][address(0)].add(etherFee);\n    }\n    for (uint i=0;i<tokenDepositAddress.length;i++) {\n      require(whitelist[tokenDepositAddress[i]] == true, \"token not whitelisted\");\n      uint256 tokenFee = tokenDepositAmount[i].div(10000).mul(_fee);\n      IERC20(tokenDepositAddress[i]).transferFrom(msg.sender, address(this), tokenDepositAmount[i]);\n      balances[msg.sender][tokenDepositAddress[i]] = balances[msg.sender][tokenDepositAddress[i]].add(tokenDepositAmount[i].sub(tokenFee));\n      balances[address(this)][tokenDepositAddress[i]] = balances[address(this)][tokenDepositAddress[i]].add(tokenFee);\n    }\n  }\n\n  /**\n  * Send payment from the funds initially depositted\n  * @param tokens token contract address to send payment\n  * @param recipients addresses to send tokens to\n  * @param amounts token amount being sent\n  * @dev for ether payments use address(0)\n  **/\n  function sendPayment(address[] memory tokens, address payable[] memory recipients, uint256[] memory amounts) public payable returns (bool) {\n    require(tokens.length == recipients.length);\n    require(tokens.length == amounts.length);\n    uint256 total_ether_amount = 0;\n    for (uint i=0; i < recipients.length; i++) {\n      if(tokens[i] != address(0)) {\n        balances[msg.sender][tokens[i]] = balances[msg.sender][tokens[i]].sub(amounts[i]);\n        IERC20(tokens[i]).transfer(recipients[i], amounts[i]);\n      }\n      else {\n        total_ether_amount = total_ether_amount.add(amounts[i]);\n        balances[msg.sender][address(0)] = balances[msg.sender][address(0)].sub(amounts[i]);\n        recipients[i].transfer(amounts[i]);\n      }\n    }\n  }\n\n  /**\n  * @dev calls deposit and send methods in one transaction\n  **/\n  function depositAndSendPayment(address[] calldata tokenDepositAddress, uint256[] calldata tokenDepositAmount, address[] calldata tokens, address payable[] calldata recipients, uint256[] calldata amounts) external payable returns (bool) {\n      deposit(tokenDepositAddress, tokenDepositAmount);\n      sendPayment(tokens, recipients, amounts);\n  }\n\n  /**\n  * @dev Withdraw method to return tokens to original owner\n  * @param tokenAddresses token contract address to withdraw from\n  **/\n  function withdrawTokens(address payable[] calldata tokenAddresses) external {\n    for(uint i=0; i<tokenAddresses.length;i++) {\n      uint balance = balances[msg.sender][tokenAddresses[i]];\n      balances[msg.sender][tokenAddresses[i]] = 0;\n      IERC20 ERC20 = IERC20(tokenAddresses[i]);\n      ERC20.transfer(msg.sender, balance);\n    }\n  }\n\n  // @dev Withdraw method to return ether to original owner\n  function withdrawEther() external {\n    uint balance = balances[msg.sender][address(0)];\n    balances[msg.sender][address(0)] = 0;\n    msg.sender.transfer(balance);\n  }\n\n  /*** CONSTANT METHODS **/\n\n  /**\n  * @param owner address to query balance of\n  * @param token contract address to query\n  * @return a uint256 balance of the given users token amount\n  **/\n  function getBalance(address owner, address token) external view returns (uint256) {\n    return balances[owner][token];\n  }\n\n  /**\n  * @dev returns the owner of the contract\n  * @return address of this contracts owner\n  **/\n  function owner() external view returns (address) {\n    return _owner;\n  }\n\n  /*** OWNER METHODS **/\n\n  /**\n  * @dev function that returns the token fees collected by the contract to the owner\n  * @param tokenAddresses token contract addresses to withdraw from\n  **/\n  function ownerWithdrawTokens(address payable[] calldata tokenAddresses) external onlyOwner {\n    for(uint i=0; i<tokenAddresses.length;i++) {\n      uint balance = balances[address(this)][tokenAddresses[i]];\n      balances[address(this)][tokenAddresses[i]] = 0;\n      IERC20 ERC20 = IERC20(tokenAddresses[i]);\n      ERC20.transfer(_owner, balance);\n    }\n  }\n\n  // @dev function that returns the ether fees collected by the contract to the owner\n  function ownerWithdrawEther() external onlyOwner {\n    uint balance = balances[address(this)][address(0)];\n    balances[address(this)][address(0)] = 0;\n    _owner.transfer(balance);\n  }\n\n  /**\n  * @dev whitelist a token address\n  * @param contractAddress the address to be whitelisted\n  */\n  function whitelistAddress(address contractAddress) external onlyOwner {\n    whitelist[contractAddress] = true;\n  }\n\n  /**\n  * @dev method to transfer ownership to a new address\n  * @param newOwner address of the new owner\n  **/\n  function transferOwnership(address payable newOwner) external onlyOwner {\n    require(newOwner != address(0), \"Owner address may not be set to zero address\");\n    _owner = newOwner;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == _owner, \"Sender is not owner of the contract\");\n    _;\n  }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"ownerWithdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"whitelistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerWithdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenDepositAddress\",\"type\":\"address[]\"},{\"name\":\"tokenDepositAmount\",\"type\":\"uint256[]\"},{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"recipients\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"depositAndSendPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"recipients\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"sendPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenDepositAddress\",\"type\":\"address[]\"},{\"name\":\"tokenDepositAmount\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Multisend","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://1af018b86fae0c64854d33e7014a495ea66885a49df3ae48e03ea3875617887e"}]}