{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.2;\r\n\r\n/*\r\n\"Crypto Casino 333\" (c) v.1.0\r\nCopyright (c) 2019 by -= 333ETH Team =-\r\n\r\nTHIS IS TEST CONTRACT!!! DO NOT PLACE BET!!!\r\n\r\n* Web - https://333eth.io\r\n* Telegram_channel - https://t.me/Ethereum333\r\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\r\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\r\n*\r\n\r\n... Fortes fortuna juvat ...\r\n\r\nThe innovative totally fair gambling platform -\r\nA unique symbiosis of the classic online casino system and the revolutionary possibilities of the blockchain, using the power of the Ethereum smart contract for 100% transparency.\r\n\r\n\"Crypto Casino 333\" is the quintessence of fair winning opportunities for any participant on equal terms. The system and technologies are transparent due to the blockchain, which is really capable of meeting all your expectations.\r\n\r\n... Alea jacta est ...\r\n\r\nWe start  project without ICO & provide the following guarantees:\r\n\r\n- ABSOLUTE TRANSPARENCY -\r\nThe random number generator is based on an Ethereum Smart Contract which is completely public. This means that everyone can see everything that is occurring inside the servers of the casino.\r\n\r\n- NO HUMAN FACTOR -\r\nAll transactions are processed automatically according to the smart contract algorithms.\r\n\r\n- TOTAL PROTECTION & PRIVACY -\r\nAll transactions are processed anonymously inside smart contract.\r\n\r\n\r\n- TOTALLY FINANCIAL PLEASURE -\r\nOnly 1% casino commission, 99% goes to payout wins. Instant automatic withdrawal of funds directly from the smart contract.\r\n\r\nCopyright (c) 2019 by -= 333ETH Team =-\r\n\"Games People are playing\"\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n*/\r\n\r\n\r\n\r\nlibrary PaymentLib {\r\n  struct Payment {\r\n    address payable beneficiary;\r\n    uint amount;\r\n    bytes32 message;\r\n  }\r\n\r\n  event LogPayment(address indexed beneficiary, uint amount, bytes32 indexed message);\r\n  event LogFailedPayment(address indexed beneficiary, uint amount, bytes32 indexed message);\r\n\r\n  function send(Payment memory p) internal {\r\n    if (p.beneficiary.send(p.amount)) {\r\n      emit LogPayment(p.beneficiary, p.amount, p.message);\r\n    } else {\r\n      emit LogFailedPayment(p.beneficiary, p.amount, p.message);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary BytesLib {\r\n\r\n\r\n  // index returns the index of the first instance of sub in s, or -1 if sub is not present in s. \r\n  function index(bytes memory b, bytes memory subb, uint start) internal pure returns(int) {\r\n    uint lensubb = subb.length;\r\n    \r\n    uint hashsubb;\r\n    uint ptrb;\r\n    assembly {\r\n      hashsubb := keccak256(add(subb, 0x20), lensubb)\r\n      ptrb := add(b, 0x20)\r\n    }\r\n    \r\n    for (uint lenb = b.length; start < lenb; start++) {\r\n      if (start+lensubb > lenb) {\r\n        return -1;\r\n      }\r\n      bool found;\r\n      assembly {\r\n        found := eq(keccak256(add(ptrb, start), lensubb), hashsubb)\r\n      }\r\n      if (found) {\r\n        return int(start);\r\n      }\r\n    }\r\n    return -1;\r\n    \r\n    /* assembly\r\n    require(subb.length < 32,\"unsuppotyed bytes len\");\r\n    \r\n    bool found;\r\n    assembly {\r\n      let lenb := mload(b) \r\n      let lensubb := mload(subb)  \r\n      let subbHash := keccak256(add(subb, 0x20), lensubb)\r\n      let ptrb := add(b, 0x20)\r\n      for \r\n        {} \r\n        and(and(lt(start, lenb), eq(found, 0)), lt(add(start, lensubb), add(lenb,1))) \r\n        { start := add(start, 1) }\r\n      {\r\n        found := eq(keccak256(add(ptrb, start), lensubb), subbHash)\r\n      }\r\n\r\n    }\r\n    if (found) {\r\n      return int(start)-1;\r\n    }\r\n    return -1;\r\n    */\r\n\r\n    \r\n    // brute force solidity\r\n    // for ((uint i, bool found) = (start, true); i < b.length; (i++, found = true)) {\r\n    //   for (uint j = 0; j < sub.length; j++) {\r\n    //     if (i+j > b.length-1) {\r\n    //       found = false;\r\n    //       break;\r\n    //     }\r\n    //     if (b[i+j] != sub[j]) {\r\n    //       found = false;\r\n    //       break;\r\n    //     }\r\n    //   }\r\n    //   if (found) {\r\n    //     return int(i);\r\n    //   }\r\n    // }\r\n    // return -1;\r\n  }  \r\n  \r\n  // index returns the index of the first instance of sub in s, or -1 if sub is not present in s. \r\n  function index(bytes memory b, bytes memory sub) internal pure returns(int) {\r\n    return index(b, sub, 0);\r\n  }\r\n\r\n  function index(bytes memory b, byte sub, uint start) internal pure returns(int) {\r\n    for (uint len = b.length; start < len; start++) {\r\n      if (b[start] == sub) {\r\n        return int(start);\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  function index(bytes memory b, byte sub) internal pure returns(int) {\r\n    return index(b, sub, 0);\r\n  }\r\n\r\n  function count(bytes memory b, bytes memory sub) internal pure returns(uint times) {\r\n    int i = index(b, sub, 0);\r\n    while (i != -1) {\r\n      times++;\r\n      i = index(b, sub, uint(i)+sub.length);\r\n    }\r\n  }\r\n  \r\n  function equals(bytes memory b, bytes memory a) internal pure returns(bool equal) {\r\n    if (b.length != a.length) {\r\n      return false;\r\n    }\r\n    \r\n    uint len = b.length;\r\n    \r\n    assembly {\r\n      equal := eq(keccak256(add(b, 0x20), len), keccak256(add(a, 0x20), len))\r\n    }  \r\n  }\r\n  \r\n  function copy(bytes memory b) internal pure returns(bytes memory) {\r\n    return abi.encodePacked(b);\r\n  }\r\n  \r\n  function slice(bytes memory b, uint start, uint end) internal pure returns(bytes memory r) {\r\n    if (start > end) {\r\n      return r;\r\n    }\r\n    if (end > b.length-1) {\r\n      end = b.length-1;\r\n    }\r\n    r = new bytes(end-start+1);\r\n    \r\n    uint j;\r\n    uint i = start;\r\n    for (; i <= end; (i++, j++)) {\r\n      r[j] = b[i];\r\n    }\r\n  }\r\n  \r\n  function append(bytes memory b, bytes memory a) internal pure returns(bytes memory r) {\r\n    return abi.encodePacked(b, a);\r\n  }\r\n  \r\n  \r\n  function replace(bytes memory b, bytes memory oldb, bytes memory newb) internal pure returns(bytes memory r) {\r\n    if (equals(oldb, newb)) {\r\n      return copy(b);\r\n    }\r\n    \r\n    uint n = count(b, oldb);\r\n    if (n == 0) {\r\n      return copy(b);\r\n    }\r\n    \r\n    uint start;\r\n    for (uint i; i < n; i++) {\r\n      uint j = start;\r\n      j += uint(index(slice(b, start, b.length-1), oldb));  \r\n      if (j!=0) {\r\n        r = append(r, slice(b, start, j-1));\r\n      }\r\n      \r\n      r = append(r, newb);\r\n      start = j + oldb.length;\r\n    }\r\n    if (r.length != b.length+n*(newb.length-oldb.length)) {\r\n      r = append(r, slice(b, start, b.length-1));\r\n    }\r\n  }\r\n\r\n  function fillPattern(bytes memory b, bytes memory pattern, byte newb) internal pure returns (uint n) {\r\n    uint start;\r\n    while (true) {\r\n      int i = index(b, pattern, start);\r\n      if (i < 0) {\r\n        return n;\r\n      }\r\n      uint len = pattern.length;\r\n      for (uint k = 0; k < len; k++) {\r\n        b[uint(i)+k] = newb;\r\n      }\r\n      start = uint(i)+len;\r\n      n++;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary NumberLib {\r\n  struct Number {\r\n    uint num;\r\n    uint den;\r\n  }\r\n\r\n  function muluint(Number memory a, uint b) internal pure returns (uint) {\r\n    return b * a.num / a.den;\r\n  }\r\n\r\n  function mmul(Number memory a, uint b) internal pure returns(Number memory) {\r\n    a.num = a.num * b;\r\n    return a;\r\n  }\r\n\r\n  function maddm(Number memory a, Number memory b) internal pure returns(Number memory) {\r\n    a.num = a.num * b.den + b.num * a.den;\r\n    a.den = a.den * b.den;\r\n    return a;\r\n  }\r\n\r\n  function madds(Number memory a, Number storage b) internal view returns(Number memory) {\r\n    a.num = a.num * b.den + b.num * a.den;\r\n    a.den = a.den * b.den;\r\n    return a;\r\n  }\r\n\r\n  // function mul(Number memory a, uint b) internal pure returns (Number memory c) {\r\n  //   c.num = a.num * b;\r\n  //   c.den = a.den;\r\n  // }\r\n\r\n  // function add(Number memory a, Number memory b) internal pure returns (Number memory c) {\r\n  //   c.num = a.num * b.den + b.num * a.den;\r\n  //   c.den = a.den * b.den;\r\n  // }\r\n\r\n//   function div(Number storage p, uint a) internal view returns (uint) {\r\n//     return a/p.num*p.den;\r\n//   }\r\n\r\n//   function sub(Number storage p, uint a) internal view returns (uint) {\r\n//     uint b = mul(p, a);\r\n//     if (b >= a) return 0;\r\n//     return a - b;\r\n//   }\r\n}\r\n\r\nlibrary Rnd {\r\n  byte internal constant NONCE_SEP = \"\\x3a\"; // ':'\r\n\r\n  function uintn(bytes32 hostSeed, bytes32 clientSeed, uint n) internal pure returns(uint) {\r\n    return uint(keccak256(abi.encodePacked(hostSeed, clientSeed))) % n;\r\n  }\r\n\r\n  function uintn(bytes32 hostSeed, bytes32 clientSeed, uint n, bytes memory nonce) internal pure returns(uint) {\r\n    return uint(keccak256(abi.encodePacked(hostSeed, clientSeed, NONCE_SEP, nonce))) % n;\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary ProtLib {\r\n  function checkBlockHash(uint blockNumber, bytes32 blockHash) internal view {\r\n    require(block.number > blockNumber, \"protection lib: current block must be great then block number\");\r\n    require(blockhash(blockNumber) != bytes32(0), \"protection lib: blockhash can't be queried by EVM\");\r\n    require(blockhash(blockNumber) == blockHash, \"protection lib: invalid block hash\");\r\n  }\r\n\r\n  function checkSigner(address signer, bytes32 message, uint8 v, bytes32 r, bytes32 s) internal pure {\r\n    require(signer == ecrecover(message, v, r, s), \"protection lib: ECDSA signature is not valid\");\r\n  }\r\n\r\n  function checkSigner(address signer, uint expirationBlock, bytes32 message, uint8 v, bytes32 r, bytes32 s) internal view {\r\n    require(block.number <= expirationBlock, \"protection lib: signature has expired\");\r\n    checkSigner(signer, keccak256(abi.encodePacked(message, expirationBlock)), v, r, s);\r\n    // require(\r\n    //   signer == ecrecover(keccak256(abi.encodePacked(message, expirationBlock)), v, r, s), \r\n    //   \"protection lib: ECDSA signature is not valid\"\r\n    // );\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SlotGameLib {\r\n  using BytesLib for bytes;\r\n  using SafeMath for uint;\r\n  using SafeMath for uint128;\r\n  using NumberLib for NumberLib.Number;\r\n\r\n  struct Bet {\r\n    uint amount; \r\n    uint40 blockNumber; // 40\r\n    address payable gambler; // 160\r\n    bool exist; // 1\r\n  }\r\n\r\n  function remove(Bet storage bet) internal {\r\n    delete bet.amount;\r\n    delete bet.blockNumber;\r\n    delete bet.gambler;\r\n  }\r\n\r\n  struct Combination {\r\n    bytes symbols;\r\n    NumberLib.Number multiplier;\r\n  }\r\n\r\n  struct SpecialCombination {\r\n    byte symbol;\r\n    NumberLib.Number multiplier;\r\n    uint[] indexes; // not uint8, optimize spin and hasIn\r\n  }\r\n\r\n  function hasIn(SpecialCombination storage sc, bytes memory symbols) internal view returns (bool) {\r\n    uint len = sc.indexes.length;\r\n    byte symbol = sc.symbol;\r\n    for (uint i = 0; i < len; i++) {\r\n      if (symbols[sc.indexes[i]] != symbol) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // the symbol that don't use in reels\r\n  byte private constant UNUSED_SYMBOL = \"\\xff\"; // 255\r\n  uint internal constant REELS_LEN = 9;\r\n  uint private constant BIG_COMBINATION_MIN_LEN = 8;\r\n  bytes32 private constant PAYMENT_LOG_MSG = \"slot\";\r\n  bytes32 private constant REFUND_LOG_MSG = \"slot.refund\";\r\n  uint private constant HANDLE_BET_COST = 0.001 ether;\r\n  uint private constant HOUSE_EDGE_PERCENT = 1;\r\n  uint private constant JACKPOT_PERCENT = 1;\r\n  uint private constant MIN_WIN_PERCENT = 30;\r\n  uint private constant MIN_BET_AMOUNT = 10 + (HANDLE_BET_COST * 100 / MIN_WIN_PERCENT * 100) / (100 - HOUSE_EDGE_PERCENT - JACKPOT_PERCENT);\r\n  \r\n  function MinBetAmount() internal pure returns(uint) {\r\n    return MIN_BET_AMOUNT;\r\n  }\r\n\r\n  \r\n  struct Game {\r\n    address secretSigner;\r\n    uint128 lockedInBets;\r\n    uint128 jackpot;\r\n    uint maxBetAmount;\r\n    uint minBetAmount;\r\n\r\n    bytes[REELS_LEN] reels;\r\n    // pay table array with prioritet for 0-elem to N-elem, where 0 - MAX prior and N - LOW prior\r\n    Combination[] payTable;\r\n    SpecialCombination[] specialPayTable;\r\n\r\n    mapping(bytes32 => Bet) bets;\r\n  }\r\n\r\n  event LogSlotNewBet(\r\n    bytes32 indexed hostSeedHash,\r\n    address indexed gambler,\r\n    uint amount,\r\n    address indexed referrer\r\n  );\r\n\r\n  event LogSlotHandleBet(\r\n    bytes32 indexed hostSeedHash,\r\n    address indexed gambler,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed,\r\n    bytes symbols,\r\n    uint multiplierNum,\r\n    uint multiplierDen,\r\n    uint amount,\r\n    uint winnings\r\n  );\r\n\r\n  event LogSlotRefundBet(\r\n    bytes32 indexed hostSeedHash,\r\n    address indexed gambler, \r\n    uint amount\r\n  );\r\n\r\n  function setReel(Game storage game, uint n, bytes memory symbols) internal {\r\n    require(REELS_LEN > n, \"slot game: invalid reel number\");\r\n    require(symbols.length > 0, \"slot game: invalid reel`s symbols length\");\r\n    require(symbols.index(UNUSED_SYMBOL) == -1, \"slot game: reel`s symbols contains invalid symbol\");\r\n    game.reels[n] = symbols;\r\n  }\r\n\r\n  function setPayLine(Game storage game, uint n, Combination memory comb) internal {\r\n    require(n <= game.payTable.length, \"slot game: invalid pay line number\");\r\n    require(comb.symbols.index(UNUSED_SYMBOL) == -1, \"slot game: combination symbols contains invalid symbol\");\r\n\r\n    if (n == game.payTable.length && comb.symbols.length > 0) {\r\n      game.payTable.push(comb);\r\n      return;\r\n    } \r\n    \r\n    if (n == game.payTable.length-1 && comb.symbols.length == 0) {\r\n      game.payTable.pop();\r\n      return;\r\n    }\r\n\r\n    require(\r\n      0 < comb.symbols.length && comb.symbols.length <= REELS_LEN, \r\n      \"slot game: invalid combination`s symbols length\"\r\n    );\r\n    game.payTable[n] = comb;\r\n  }\r\n\r\n  function setSpecialPayLine(Game storage game, uint n, SpecialCombination memory scomb) internal {\r\n    require(game.specialPayTable.length >= n, \"slot game: invalid pay line number\");\r\n    require(scomb.symbol != UNUSED_SYMBOL, \"slot game: invalid special combination`s symbol\");\r\n\r\n    if (n == game.specialPayTable.length && scomb.indexes.length > 0) {\r\n      game.specialPayTable.push(scomb);\r\n      return;\r\n    } \r\n    \r\n    if (n == game.specialPayTable.length-1 && scomb.indexes.length == 0) {\r\n      game.specialPayTable.pop();\r\n      return;\r\n    }\r\n\r\n    require(\r\n      0 < scomb.indexes.length && scomb.indexes.length <= REELS_LEN, \r\n      \"slot game: invalid special combination`s indexes length\"\r\n    );\r\n    game.specialPayTable[n] = scomb;\r\n  }\r\n\r\n  function setMinMaxBetAmount(Game storage game, uint minBetAmount, uint maxBetAmount) internal {\r\n    require(minBetAmount >= MIN_BET_AMOUNT, \"slot game: invalid min of bet amount\");\r\n    require(minBetAmount <= maxBetAmount, \"slot game: invalid [min, max] range of bet amount\");\r\n    game.minBetAmount = minBetAmount;\r\n    game.maxBetAmount = maxBetAmount;\r\n  }\r\n\r\n  function placeBet(\r\n    Game storage game,\r\n    address referrer,\r\n    uint sigExpirationBlock,\r\n    bytes32 hostSeedHash,\r\n    uint8 v, \r\n    bytes32 r, \r\n    bytes32 s\r\n  ) \r\n    internal\r\n  {\r\n    ProtLib.checkSigner(game.secretSigner, sigExpirationBlock, hostSeedHash, v, r, s);\r\n\r\n    Bet storage bet = game.bets[hostSeedHash];\r\n    require(!bet.exist, \"slot game: bet already exist\");\r\n    require(game.minBetAmount <= msg.value && msg.value <= game.maxBetAmount, \"slot game: invalid bet amount\");\r\n    \r\n    bet.amount = msg.value;\r\n    bet.blockNumber = uint40(block.number);\r\n    bet.gambler = msg.sender;\r\n    bet.exist = true;\r\n    \r\n    game.lockedInBets += uint128(msg.value);\r\n    game.jackpot += uint128(msg.value * JACKPOT_PERCENT / 100);\r\n\r\n    emit LogSlotNewBet(\r\n      hostSeedHash, \r\n      msg.sender, \r\n      msg.value,\r\n      referrer\r\n    );\r\n  }\r\n\r\n\r\n  // function placeBet(\r\n  //   Game storage game,\r\n  //   address referrer,\r\n  //   bytes32 hostSeedHash,\r\n  //   uint8 v, \r\n  //   bytes32 r, \r\n  //   bytes32 s\r\n  // ) \r\n  //   internal\r\n  // {\r\n  //   ProtLib.checkSigner(game.secretSigner, hostSeedHash, v, r, s);\r\n\r\n  //   Bet storage bet = game.bets[hostSeedHash];\r\n  //   require(!bet.exist, \"slot game: bet already exist\");\r\n  //   require(game.minBetAmount <= msg.value && msg.value <= game.maxBetAmount, \"slot game: invalid bet amount\");\r\n    \r\n  //   bet.amount = msg.value;\r\n  //   bet.blockNumber = uint40(block.number);\r\n  //   bet.gambler = msg.sender;\r\n  //   bet.exist = true;\r\n    \r\n  //   game.lockedInBets += uint128(msg.value);\r\n  //   game.jackpot += uint128(msg.value * JACKPOT_PERCENT / 100);\r\n\r\n  //   emit LogSlotNewBet(\r\n  //     hostSeedHash, \r\n  //     msg.sender, \r\n  //     msg.value,\r\n  //     referrer\r\n  //   );\r\n  // }\r\n\r\n  function handleBet(\r\n    Game storage game,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed\r\n  ) \r\n    internal \r\n    returns(\r\n      PaymentLib.Payment memory p\r\n    ) \r\n  {\r\n    bytes32 hostSeedHash = keccak256(abi.encodePacked(hostSeed));\r\n    Bet storage bet = game.bets[hostSeedHash];\r\n    uint betAmount = bet.amount;\r\n    require(bet.exist, \"slot game: bet does not exist\");\r\n    require(betAmount > 0, \"slot game: bet already handled\");\r\n    ProtLib.checkBlockHash(bet.blockNumber, clientSeed);\r\n    game.lockedInBets -= uint128(betAmount);\r\n\r\n    Combination memory c = spin(game, hostSeed, clientSeed);\r\n    uint winnings = c.multiplier.muluint(betAmount);\r\n\r\n    if (winnings > 0) {\r\n      winnings = winnings * (100 - HOUSE_EDGE_PERCENT - JACKPOT_PERCENT) / 100;\r\n      winnings = winnings.sub(HANDLE_BET_COST);\r\n    }\r\n    p.beneficiary = bet.gambler; \r\n    p.amount = winnings; \r\n    p.message = PAYMENT_LOG_MSG; \r\n\r\n    emit LogSlotHandleBet(\r\n      hostSeedHash,\r\n      p.beneficiary, \r\n      hostSeed, \r\n      clientSeed, \r\n      c.symbols, \r\n      c.multiplier.num, \r\n      c.multiplier.den,\r\n      betAmount,\r\n      winnings\r\n    );\r\n    remove(bet);\r\n  }\r\n  \r\n  function spin(\r\n    Game storage game,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed\r\n  ) \r\n    internal \r\n    view \r\n    returns (\r\n      Combination memory combination\r\n    ) \r\n  {\r\n    bytes memory symbolsTmp = new bytes(REELS_LEN);\r\n    for (uint i; i < REELS_LEN; i++) {\r\n      bytes memory nonce = abi.encodePacked(uint8(i));\r\n      symbolsTmp[i] = game.reels[i][Rnd.uintn(hostSeed, clientSeed, game.reels[i].length, nonce)];\r\n    }\r\n    combination.symbols = symbolsTmp.copy();\r\n    combination.multiplier = NumberLib.Number(0, 1); // 0/1 == 0.0\r\n    \r\n    for ((uint i, uint length) = (0, game.payTable.length); i < length; i++) {\r\n      bytes memory tmp = game.payTable[i].symbols;\r\n      uint times = symbolsTmp.fillPattern(tmp, UNUSED_SYMBOL);\r\n      if (times > 0) {\r\n        combination.multiplier.maddm(game.payTable[i].multiplier.mmul(times));\r\n        if (tmp.length >= BIG_COMBINATION_MIN_LEN) {\r\n          return combination; \r\n\t\t\t  }\r\n      }\r\n    }\r\n    \r\n    for ((uint i, uint length) = (0, game.specialPayTable.length); i < length; i++) {\r\n      if (hasIn(game.specialPayTable[i], combination.symbols)) {\r\n        combination.multiplier.madds(game.specialPayTable[i].multiplier);\r\n      }\r\n    }\r\n  }\r\n\r\n  function refundBet(Game storage game, bytes32 hostSeedHash) internal returns(PaymentLib.Payment memory p) {\r\n    Bet storage bet = game.bets[hostSeedHash];\r\n    uint betAmount = bet.amount;\r\n    require(bet.exist, \"slot game: bet does not exist\");\r\n    require(betAmount > 0, \"slot game: bet already handled\");\r\n    require(blockhash(bet.blockNumber) == bytes32(0), \"slot game: cannot refund bet\");\r\n   \r\n    game.jackpot = uint128(game.jackpot.sub(betAmount * JACKPOT_PERCENT / 100));\r\n    game.lockedInBets -= uint128(betAmount);\r\n    p.beneficiary = bet.gambler; \r\n    p.amount = betAmount; \r\n    p.message = REFUND_LOG_MSG; \r\n\r\n    emit LogSlotRefundBet(hostSeedHash, p.beneficiary, p.amount);\r\n    remove(bet);\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary BitsLib {\r\n\r\n  // popcnt returns the number of one bits (\"population count\") in x.\r\n  // https://en.wikipedia.org/wiki/Hamming_weight \r\n  function popcnt(uint16 x) internal pure returns(uint) {\r\n    x -= (x >> 1) & 0x5555;\r\n    x = (x & 0x3333) + ((x >> 2) & 0x3333);\r\n    x = (x + (x >> 4)) & 0x0f0f;\r\n    return (x * 0x0101) >> 8;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\nlibrary RollGameLib {\r\n  using NumberLib for NumberLib.Number;\r\n  using SafeMath for uint;\r\n  using SafeMath for uint128;\r\n\r\n  // Types\r\n  enum Type {Coin, Square3x3, Roll}\r\n  uint private constant COIN_MOD = 2;\r\n  uint private constant SQUARE_3X3_MOD = 9;\r\n  uint private constant ROLL_MOD = 100;\r\n  bytes32 private constant COIN_PAYMENT_LOG_MSG = \"roll.coin\";\r\n  bytes32 private constant SQUARE_3X3_PAYMENT_LOG_MSG = \"roll.square_3x3\";\r\n  bytes32 private constant ROLL_PAYMENT_LOG_MSG = \"roll.roll\";\r\n  bytes32 private constant REFUND_LOG_MSG = \"roll.refund\";\r\n  uint private constant HOUSE_EDGE_PERCENT = 1;\r\n  uint private constant JACKPOT_PERCENT = 1;\r\n  uint private constant HANDLE_BET_COST = 0.0005 ether;\r\n  uint private constant MIN_BET_AMOUNT = 10 + (HANDLE_BET_COST * 100) / (100 - HOUSE_EDGE_PERCENT - JACKPOT_PERCENT);\r\n\r\n  function MinBetAmount() internal pure returns(uint) {\r\n    return MIN_BET_AMOUNT;\r\n  }\r\n\r\n  // solium-disable lbrace, whitespace\r\n  function module(Type t) internal pure returns(uint) {\r\n    if (t == Type.Coin) { return COIN_MOD; } \r\n    else if (t == Type.Square3x3) { return SQUARE_3X3_MOD; } \r\n    else { return ROLL_MOD; }\r\n  }\r\n\r\n  function logMsg(Type t) internal pure returns(bytes32) {\r\n    if (t == Type.Coin) { return COIN_PAYMENT_LOG_MSG; } \r\n    else if (t == Type.Square3x3) { return SQUARE_3X3_PAYMENT_LOG_MSG; }\r\n    else { return ROLL_PAYMENT_LOG_MSG; }\r\n  }\r\n\r\n  function maskRange(Type t) internal pure returns(uint, uint) {\r\n    if (t == Type.Coin) { return (1, 2 ** COIN_MOD - 2); } \r\n    else if (t == Type.Square3x3) { return (1, 2 ** SQUARE_3X3_MOD - 2); }\r\n  }\r\n\r\n  function rollUnderRange(Type t) internal pure returns(uint, uint) {\r\n    if (t == Type.Roll) { return (1, ROLL_MOD - 1); } // 0..99\r\n  }\r\n  // solium-enable lbrace, whitespace\r\n\r\n\r\n\r\n  struct Bet {\r\n    uint amount;\r\n    Type t; // 8\r\n    uint8 rollUnder; // 8\r\n    uint16 mask;  // 16\r\n    uint40 blockNumber; // 40\r\n    address payable gambler; // 160\r\n    bool exist; // 1\r\n  }\r\n\r\n  function roll(\r\n    Bet storage bet,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed\r\n  ) \r\n    internal \r\n    view \r\n    returns (\r\n      uint rnd,\r\n      NumberLib.Number memory multiplier\r\n    ) \r\n  {\r\n    uint m = module(bet.t);\r\n    rnd = Rnd.uintn(hostSeed, clientSeed, m);\r\n    multiplier.den = 1; // prevent divide to zero\r\n    \r\n    uint mask = bet.mask;\r\n    if (mask != 0) {\r\n      if (((2 ** rnd) & mask) != 0) {\r\n        multiplier.den = BitsLib.popcnt(uint16(mask));\r\n        multiplier.num = m;\r\n      }\r\n    } else {\r\n      uint rollUnder = bet.rollUnder;\r\n      if (rollUnder > rnd) {\r\n        multiplier.den = rollUnder;\r\n        multiplier.num = m;\r\n      }\r\n    }\r\n  }\r\n\r\n  function remove(Bet storage bet) internal {\r\n    delete bet.amount;\r\n    delete bet.t;\r\n    delete bet.mask;\r\n    delete bet.rollUnder;\r\n    delete bet.blockNumber;\r\n    delete bet.gambler;\r\n  }\r\n\r\n\r\n\r\n  struct Game {\r\n    address secretSigner;\r\n    uint128 lockedInBets;\r\n    uint128 jackpot;\r\n    uint maxBetAmount;\r\n    uint minBetAmount;\r\n    \r\n    mapping(bytes32 => Bet) bets;\r\n  }\r\n\r\n  event LogRollNewBet(\r\n    bytes32 indexed hostSeedHash, \r\n    uint8 t,\r\n    address indexed gambler, \r\n    uint amount,\r\n    uint mask, \r\n    uint rollUnder,\r\n    address indexed referrer\r\n  );\r\n\r\n  event LogRollRefundBet(\r\n    bytes32 indexed hostSeedHash, \r\n    uint8 t,\r\n    address indexed gambler, \r\n    uint amount\r\n  );\r\n\r\n  event LogRollHandleBet(\r\n    bytes32 indexed hostSeedHash, \r\n    uint8 t,\r\n    address indexed gambler, \r\n    bytes32 hostSeed, \r\n    bytes32 clientSeed, \r\n    uint roll, \r\n    uint multiplierNum, \r\n    uint multiplierDen,\r\n    uint amount,\r\n    uint winnings\r\n  );\r\n\r\n  function setMinMaxBetAmount(Game storage game, uint minBetAmount, uint maxBetAmount) internal {\r\n    require(minBetAmount >= MIN_BET_AMOUNT, \"roll game: invalid min of bet amount\");\r\n    require(minBetAmount <= maxBetAmount, \"roll game: invalid [min, max] range of bet amount\");\r\n    game.minBetAmount = minBetAmount;\r\n    game.maxBetAmount = maxBetAmount;\r\n  }\r\n\r\n  function placeBet(\r\n    Game storage game, \r\n    Type t, \r\n    uint16 mask, \r\n    uint8 rollUnder,\r\n    address referrer,\r\n    uint sigExpirationBlock,\r\n    bytes32 hostSeedHash, \r\n    uint8 v, \r\n    bytes32 r, \r\n    bytes32 s\r\n  ) \r\n    internal \r\n  {\r\n    ProtLib.checkSigner(game.secretSigner, sigExpirationBlock, hostSeedHash, v, r, s);\r\n    Bet storage bet = game.bets[hostSeedHash];\r\n    require(!bet.exist, \"roll game: bet already exist\");\r\n    require(game.minBetAmount <= msg.value && msg.value <= game.maxBetAmount, \"roll game: invalid bet amount\");\r\n\r\n    {  // solium-disable indentation\r\n      (uint minMask, uint maxMask) = maskRange(t);\r\n      require(minMask <= mask && mask <= maxMask, \"roll game: invalid bet mask\");\r\n      (uint minRollUnder, uint maxRollUnder) = rollUnderRange(t);\r\n      require(minRollUnder <= rollUnder && rollUnder <= maxRollUnder, \"roll game: invalid bet roll under\");\r\n    }  // solium-enable indentation\r\n\r\n    // * do not touch it!\r\n    bet.amount = msg.value;\r\n    bet.blockNumber = uint40(block.number);\r\n    bet.gambler = msg.sender;\r\n    bet.exist = true;\r\n    bet.mask = mask;\r\n    bet.rollUnder = rollUnder;\r\n    bet.t = t;\r\n    // *\r\n\r\n    game.lockedInBets += uint128(msg.value);\r\n    game.jackpot += uint128(msg.value * JACKPOT_PERCENT / 100);\r\n\r\n    emit LogRollNewBet(\r\n      hostSeedHash,\r\n      uint8(t),\r\n      msg.sender,\r\n      msg.value,\r\n      mask,\r\n      rollUnder,\r\n      referrer\r\n    );\r\n  }\r\n\r\n\r\n  function handleBet(\r\n    Game storage game,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed\r\n  ) \r\n    internal \r\n    returns(\r\n      PaymentLib.Payment memory p\r\n    ) \r\n  {\r\n    bytes32 hostSeedHash = keccak256(abi.encodePacked(hostSeed));\r\n    Bet storage bet = game.bets[hostSeedHash];\r\n    uint betAmount = bet.amount;\r\n    require(bet.exist, \"roll game: bet does not exist\");\r\n    require(betAmount > 0, \"roll game: bet already handled\");\r\n    ProtLib.checkBlockHash(bet.blockNumber, clientSeed);\r\n    game.lockedInBets -= uint128(betAmount);\r\n\r\n    (uint rnd, NumberLib.Number memory multiplier) = roll(bet, hostSeed, clientSeed);\r\n    uint winnings = multiplier.muluint(betAmount);\r\n  \r\n    if (winnings > 0) {\r\n      winnings = winnings * (100 - HOUSE_EDGE_PERCENT - JACKPOT_PERCENT) / 100;\r\n      winnings = winnings.sub(HANDLE_BET_COST);\r\n    }\r\n    p.beneficiary = bet.gambler; \r\n    p.amount = winnings; \r\n    p.message = logMsg(bet.t); \r\n\r\n    emit LogRollHandleBet(\r\n      hostSeedHash,\r\n      uint8(bet.t),\r\n      p.beneficiary,\r\n      hostSeed,\r\n      clientSeed,\r\n      rnd,\r\n      multiplier.num,\r\n      multiplier.den,\r\n      betAmount,\r\n      winnings\r\n    );\r\n    remove(bet);\r\n  }\r\n\r\n\r\n  function refundBet(Game storage game, bytes32 hostSeedHash) internal returns(PaymentLib.Payment memory p) {\r\n    Bet storage bet = game.bets[hostSeedHash];\r\n    uint betAmount = bet.amount;\r\n    require(bet.exist, \"roll game: bet does not exist\");\r\n    require(betAmount > 0, \"roll game: bet already handled\");\r\n    require(blockhash(bet.blockNumber) == bytes32(0), \"roll game: cannot refund bet\");\r\n   \r\n    game.jackpot = uint128(game.jackpot.sub(betAmount * JACKPOT_PERCENT / 100));\r\n    game.lockedInBets -= uint128(betAmount);\r\n    p.beneficiary = bet.gambler; \r\n    p.amount = betAmount; \r\n    p.message = REFUND_LOG_MSG; \r\n\r\n    emit LogRollRefundBet(hostSeedHash, uint8(bet.t), p.beneficiary, p.amount);\r\n    remove(bet);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract Accessibility {\r\n  enum AccessRank { None, Croupier, Games, Withdraw, Full }\r\n  mapping(address => AccessRank) public admins;\r\n  modifier onlyAdmin(AccessRank  r) {\r\n    require(\r\n      admins[msg.sender] == r || admins[msg.sender] == AccessRank.Full,\r\n      \"accessibility: access denied\"\r\n    );\r\n    _;\r\n  }\r\n  event LogProvideAccess(address indexed whom, uint when,  AccessRank rank);\r\n\r\n  constructor() public {\r\n    admins[msg.sender] = AccessRank.Full;\r\n    emit LogProvideAccess(msg.sender, now, AccessRank.Full);\r\n  }\r\n  \r\n  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Full) {\r\n    require(admins[addr] != AccessRank.Full, \"accessibility: cannot change full access rank\");\r\n    if (admins[addr] != rank) {\r\n      admins[addr] = rank;\r\n      emit LogProvideAccess(addr, now, rank);\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract Casino is Accessibility {\r\n  using PaymentLib for PaymentLib.Payment;\r\n  using RollGameLib for RollGameLib.Game;\r\n  using SlotGameLib for SlotGameLib.Game;\r\n\r\n  bytes32 private constant JACKPOT_LOG_MSG = \"casino.jackpot\";\r\n  bytes32 private constant WITHDRAW_LOG_MSG = \"casino.withdraw\";\r\n  bytes private constant JACKPOT_NONCE = \"jackpot\";\r\n  uint private constant MIN_JACKPOT_MAGIC = 3333;\r\n  uint private constant MAX_JACKPOT_MAGIC = 333333333;\r\n  \r\n  SlotGameLib.Game public slot;\r\n  RollGameLib.Game public roll;\r\n  enum Game {Slot, Roll}\r\n\r\n  uint public extraJackpot;\r\n  uint public jackpotMagic;\r\n\r\n  modifier slotBetsWasHandled() {\r\n    require(slot.lockedInBets == 0, \"casino.slot: all bets should be handled\");\r\n    _;\r\n  }\r\n\r\n  event LogPayment(address indexed beneficiary, uint amount, bytes32 indexed message);\r\n  event LogFailedPayment(address indexed beneficiary, uint amount, bytes32 indexed message);\r\n\r\n  event LogJactpot(\r\n    address indexed beneficiary, \r\n    uint amount, \r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed,\r\n    uint jackpotMagic\r\n  );\r\n\r\n  event LogSlotNewBet(\r\n    bytes32 indexed hostSeedHash,\r\n    address indexed gambler,\r\n    uint amount,\r\n    address indexed referrer\r\n  );\r\n\r\n  event LogSlotHandleBet(\r\n    bytes32 indexed hostSeedHash,\r\n    address indexed gambler,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed,\r\n    bytes symbols,\r\n    uint multiplierNum,\r\n    uint multiplierDen,\r\n    uint amount,\r\n    uint winnings\r\n  );\r\n\r\n  event LogSlotRefundBet(\r\n    bytes32 indexed hostSeedHash,\r\n    address indexed gambler, \r\n    uint amount\r\n  );\r\n\r\n  event LogRollNewBet(\r\n    bytes32 indexed hostSeedHash, \r\n    uint8 t,\r\n    address indexed gambler, \r\n    uint amount,\r\n    uint mask, \r\n    uint rollUnder,\r\n    address indexed referrer\r\n  );\r\n\r\n  event LogRollRefundBet(\r\n    bytes32 indexed hostSeedHash, \r\n    uint8 t,\r\n    address indexed gambler, \r\n    uint amount\r\n  );\r\n\r\n  event LogRollHandleBet(\r\n    bytes32 indexed hostSeedHash, \r\n    uint8 t,\r\n    address indexed gambler, \r\n    bytes32 hostSeed, \r\n    bytes32 clientSeed, \r\n    uint roll, \r\n    uint multiplierNum, \r\n    uint multiplierDen,\r\n    uint amount,\r\n    uint winnings\r\n  );\r\n\r\n  constructor() public {\r\n    jackpotMagic = MIN_JACKPOT_MAGIC;\r\n    slot.minBetAmount = SlotGameLib.MinBetAmount();\r\n    slot.maxBetAmount = SlotGameLib.MinBetAmount();\r\n    roll.minBetAmount = RollGameLib.MinBetAmount();\r\n    roll.maxBetAmount = RollGameLib.MinBetAmount();\r\n  }\r\n\r\n  function() external payable {}\r\n  \r\n  /**\r\n  * @dev Place bet to roll game.\r\n  * @param t The type of roll game.\r\n  * @param mask Bitmask for special roll game`s type. User choice.\r\n  * @param rollUnder Roll under for special roll game`s type. User choice.\r\n  * @param referrer Address of the gambler`s referrer.\r\n  * @param hostSeedHash keccak256(hostSeed). The roll game`s bet id.\r\n  * @param v V of ECDSA signature from hostSeedHash.\r\n  * @param r R of ECDSA signature from hostSeedHash.\r\n  * @param s S of ECDSA signature from hostSeedHash.\r\n  */\r\n  function rollPlaceBet(\r\n    RollGameLib.Type t, \r\n    uint16 mask, \r\n    uint8 rollUnder, \r\n    address referrer,\r\n    uint sigExpirationBlock, \r\n    bytes32 hostSeedHash, \r\n    uint8 v, \r\n    bytes32 r, \r\n    bytes32 s\r\n  ) \r\n    external payable\r\n  {\r\n    roll.placeBet(t, mask, rollUnder, referrer, sigExpirationBlock, hostSeedHash, v, r, s);\r\n  }\r\n\r\n  function rollBet(bytes32 hostSeedHash) \r\n    external \r\n    view \r\n    returns (\r\n      RollGameLib.Type t,\r\n      uint amount,\r\n      uint mask,\r\n      uint rollUnder,\r\n      uint blockNumber,\r\n      address payable gambler,\r\n      bool exist\r\n    ) \r\n  {\r\n    RollGameLib.Bet storage b = roll.bets[hostSeedHash];\r\n    t = b.t;\r\n    amount = b.amount;\r\n    mask = b.mask;\r\n    rollUnder = b.rollUnder;\r\n    blockNumber = b.blockNumber;\r\n    gambler = b.gambler;\r\n    exist = b.exist;  \r\n  }\r\n\r\n  function slotPlaceBet(\r\n    address referrer,\r\n    uint sigExpirationBlock,\r\n    bytes32 hostSeedHash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) \r\n    external payable\r\n  {\r\n    slot.placeBet(referrer, sigExpirationBlock, hostSeedHash, v, r, s);\r\n  }\r\n\r\n  function slotBet(bytes32 hostSeedHash) \r\n    external \r\n    view \r\n    returns (\r\n      uint amount,\r\n      uint blockNumber,\r\n      address payable gambler,\r\n      bool exist\r\n    ) \r\n  {\r\n    SlotGameLib.Bet storage b = slot.bets[hostSeedHash];\r\n    amount = b.amount;\r\n    blockNumber = b.blockNumber;\r\n    gambler = b.gambler;\r\n    exist = b.exist;  \r\n  }\r\n\r\n  function slotSetReels(uint n, bytes calldata symbols) \r\n    external \r\n    onlyAdmin(AccessRank.Games) \r\n    slotBetsWasHandled \r\n  {\r\n    slot.setReel(n, symbols);\r\n  }\r\n\r\n  function slotReels(uint n) external view returns (bytes memory) {\r\n    return slot.reels[n];\r\n  }\r\n\r\n  function slotPayLine(uint n) external view returns (bytes memory symbols, uint num, uint den) {\r\n    symbols = new bytes(slot.payTable[n].symbols.length);\r\n    symbols = slot.payTable[n].symbols;\r\n    num = slot.payTable[n].multiplier.num;\r\n    den = slot.payTable[n].multiplier.den;\r\n  }\r\n\r\n  function slotSetPayLine(uint n, bytes calldata symbols, uint num, uint den) \r\n    external \r\n    onlyAdmin(AccessRank.Games) \r\n    slotBetsWasHandled \r\n  {\r\n    slot.setPayLine(n, SlotGameLib.Combination(symbols, NumberLib.Number(num, den)));\r\n  }\r\n\r\n  function slotSpecialPayLine(uint n) external view returns (byte symbol, uint num, uint den, uint[] memory indexes) {\r\n    indexes = new uint[](slot.specialPayTable[n].indexes.length);\r\n    indexes = slot.specialPayTable[n].indexes;\r\n    num = slot.specialPayTable[n].multiplier.num;\r\n    den = slot.specialPayTable[n].multiplier.den;\r\n    symbol = slot.specialPayTable[n].symbol;\r\n  }\r\n\r\n  function slotSetSpecialPayLine(\r\n    uint n,\r\n    byte symbol,\r\n    uint num, \r\n    uint den, \r\n    uint[] calldata indexes\r\n  ) \r\n    external \r\n    onlyAdmin(AccessRank.Games) \r\n    slotBetsWasHandled\r\n  {\r\n    SlotGameLib.SpecialCombination memory scomb = SlotGameLib.SpecialCombination(symbol, NumberLib.Number(num, den), indexes);\r\n    slot.setSpecialPayLine(n, scomb);\r\n  }\r\n\r\n  function handleBet(Game game, bytes32 hostSeed, bytes32 clientSeed) external onlyAdmin(AccessRank.Croupier) {\r\n    PaymentLib.Payment memory p; \r\n    p = game == Game.Slot ? slot.handleBet(hostSeed, clientSeed) : roll.handleBet(hostSeed, clientSeed);\r\n    checkEnoughFundsForPay(p.amount);\r\n    p.send();\r\n\r\n    p = rollJackpot(p.beneficiary, hostSeed, clientSeed);\r\n    if (p.amount == 0) {\r\n      return;\r\n    }\r\n    checkEnoughFundsForPay(p.amount);\r\n    p.send();\r\n  }\r\n\r\n  function refundBet(Game game, bytes32 hostSeedHash) external {\r\n    PaymentLib.Payment memory p; \r\n    p = game == Game.Slot ? slot.refundBet(hostSeedHash) : roll.refundBet(hostSeedHash);\r\n    checkEnoughFundsForPay(p.amount);\r\n    p.send();\r\n  }\r\n\r\n  function setSecretSigner(Game game, address secretSigner) external onlyAdmin(AccessRank.Games) {\r\n    address otherSigner = game == Game.Roll ? slot.secretSigner : roll.secretSigner;\r\n    require(secretSigner != otherSigner, \"casino: slot and roll secret signers must be not equal\");\r\n    game == Game.Roll ? roll.secretSigner = secretSigner : slot.secretSigner = secretSigner;\r\n  }\r\n\r\n  function setMinMaxBetAmount(Game game, uint min, uint max) external onlyAdmin(AccessRank.Games) {\r\n    game == Game.Roll ? roll.setMinMaxBetAmount(min, max) : slot.setMinMaxBetAmount(min, max);\r\n  }\r\n\r\n  function kill(address payable beneficiary) \r\n    external \r\n    onlyAdmin(AccessRank.Full) \r\n  {\r\n    require(lockedInBets() == 0, \"casino: all bets should be handled\");\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  function rollJackpot(\r\n    address payable beneficiary,\r\n    bytes32 hostSeed,\r\n    bytes32 clientSeed\r\n  ) \r\n    private returns(PaymentLib.Payment memory p) \r\n  {\r\n    if (Rnd.uintn(hostSeed, clientSeed, jackpotMagic, JACKPOT_NONCE) != 0) {\r\n      return p;\r\n    }\r\n    p.beneficiary = beneficiary;\r\n    p.amount = jackpot();\r\n    p.message = JACKPOT_LOG_MSG;\r\n\r\n    delete slot.jackpot;\r\n    delete roll.jackpot;\r\n    delete extraJackpot;\r\n    emit LogJactpot(p.beneficiary, p.amount, hostSeed, clientSeed, jackpotMagic);\r\n  }\r\n\r\n  function increaseJackpot(uint amount) external onlyAdmin(AccessRank.Games) {\r\n    checkEnoughFundsForPay(amount);\r\n    extraJackpot += amount;\r\n    // todo event?\r\n  }\r\n\r\n  function setJackpotMagic(uint magic) external onlyAdmin(AccessRank.Games) {\r\n    require(MIN_JACKPOT_MAGIC <= magic && magic <= MAX_JACKPOT_MAGIC, \"casino: invalid jackpot magic\");\r\n    jackpotMagic = magic;\r\n    // todo event?\r\n  }\r\n\r\n  function withdraw(address payable beneficiary, uint amount) external onlyAdmin(AccessRank.Withdraw) {\r\n    checkEnoughFundsForPay(amount);\r\n    PaymentLib.Payment(beneficiary, amount, WITHDRAW_LOG_MSG).send();\r\n  }\r\n\r\n  function lockedInBets() public view returns(uint) {\r\n    return slot.lockedInBets + roll.lockedInBets;\r\n  }\r\n\r\n  function jackpot() public view returns(uint) {\r\n    return slot.jackpot + roll.jackpot + extraJackpot;\r\n  }\r\n\r\n  function freeFunds() public view returns(uint) {\r\n    if (lockedInBets() + jackpot() >= address(this).balance ) {\r\n      return 0;\r\n    }\r\n    return address(this).balance - lockedInBets() - jackpot();\r\n  }\r\n\r\n  function checkEnoughFundsForPay(uint amount) private view {\r\n    require(freeFunds() >= amount, \"casino: not enough funds\");\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"slot\",\"outputs\":[{\"name\":\"secretSigner\",\"type\":\"address\"},{\"name\":\"lockedInBets\",\"type\":\"uint128\"},{\"name\":\"jackpot\",\"type\":\"uint128\"},{\"name\":\"maxBetAmount\",\"type\":\"uint256\"},{\"name\":\"minBetAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"hostSeedHash\",\"type\":\"bytes32\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"symbols\",\"type\":\"bytes\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"name\":\"slotSetPayLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"slotReels\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"t\",\"type\":\"uint8\"},{\"name\":\"mask\",\"type\":\"uint16\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"sigExpirationBlock\",\"type\":\"uint256\"},{\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"rollPlaceBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotMagic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"hostSeed\",\"type\":\"bytes32\"},{\"name\":\"clientSeed\",\"type\":\"bytes32\"}],\"name\":\"handleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"symbol\",\"type\":\"bytes1\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"},{\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"slotSetSpecialPayLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"secretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hostSeedHash\",\"type\":\"bytes32\"}],\"name\":\"slotBet\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"gambler\",\"type\":\"address\"},{\"name\":\"exist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"symbols\",\"type\":\"bytes\"}],\"name\":\"slotSetReels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roll\",\"outputs\":[{\"name\":\"secretSigner\",\"type\":\"address\"},{\"name\":\"lockedInBets\",\"type\":\"uint128\"},{\"name\":\"jackpot\",\"type\":\"uint128\"},{\"name\":\"maxBetAmount\",\"type\":\"uint256\"},{\"name\":\"minBetAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"min\",\"type\":\"uint256\"},{\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMinMaxBetAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"sigExpirationBlock\",\"type\":\"uint256\"},{\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"slotPlaceBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"magic\",\"type\":\"uint256\"}],\"name\":\"setJackpotMagic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"provideAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"slotPayLine\",\"outputs\":[{\"name\":\"symbols\",\"type\":\"bytes\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hostSeedHash\",\"type\":\"bytes32\"}],\"name\":\"rollBet\",\"outputs\":[{\"name\":\"t\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"gambler\",\"type\":\"address\"},{\"name\":\"exist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"slotSpecialPayLine\",\"outputs\":[{\"name\":\"symbol\",\"type\":\"bytes1\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"},{\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"message\",\"type\":\"bytes32\"}],\"name\":\"LogPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"message\",\"type\":\"bytes32\"}],\"name\":\"LogFailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hostSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"clientSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"jackpotMagic\",\"type\":\"uint256\"}],\"name\":\"LogJactpot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"LogSlotNewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hostSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"clientSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbols\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"multiplierNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplierDen\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnings\",\"type\":\"uint256\"}],\"name\":\"LogSlotHandleBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSlotRefundBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"t\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mask\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"LogRollNewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"t\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRollRefundBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hostSeedHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"t\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hostSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"clientSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"roll\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplierNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplierDen\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnings\",\"type\":\"uint256\"}],\"name\":\"LogRollHandleBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"LogProvideAccess\",\"type\":\"event\"}]","ContractName":"Casino","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a6782a1e923739b05f9840c8e23c19aa20e609d35d605e84a361780b9ef222bf"}]}