{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract EthMadness is Ownable {\r\n    \r\n    // Represents the submission to the contest.\r\n    struct Entrant {\r\n        // The user who submitted this entry\r\n        address submitter;\r\n        \r\n        // The \"index\" of this entry. Used to break ties incase two submissions are the same. (earlier submission wins)\r\n        uint48 entryIndex;\r\n    }\r\n    \r\n    // Represents a current top score in the contest\r\n    struct TopScore {\r\n        // The index of this entry (used for tie-breakas a de-dups)\r\n        uint48 entryIndex;\r\n\r\n        // This bracket's score\r\n        uint32 score;\r\n\r\n        // The total point differential for this bracket\r\n        uint64 difference;\r\n\r\n        // The account which submitted this bracket\r\n        address submitter;\r\n    }\r\n    \r\n    // Represents the results of the contest. \r\n    struct Result {\r\n        // The encoded results of the tournament\r\n        bytes16 winners;\r\n\r\n        // Team A's score in the final\r\n        uint8 scoreA;\r\n\r\n        // Team B's score in the final\r\n        uint8 scoreB;\r\n\r\n        // Whether or not this is the final Results (used to tell if a vote is real or not)\r\n        bool isFinal;\r\n    }\r\n    \r\n    // Represents the various states that the contest will go through.\r\n    enum ContestState {\r\n        // The contest is open for people to submit entries. Oracles can also be added during this period.\r\n        OPEN_FOR_ENTRIES,\r\n        \r\n        // The tournament is in progress, no more entries can be received and no oracles can vote\r\n        TOURNAMENT_IN_PROGRESS,\r\n        \r\n        // The tournament is over and we're waiting for all the oracles to submit the results\r\n        WAITING_FOR_ORACLES,\r\n        \r\n        // The oracels have submitted the results and we're waiting for winners to claim their prize\r\n        WAITING_FOR_WINNING_CLAIMS,\r\n        \r\n        // The contest has completed and the winners have been paid out\r\n        COMPLETED\r\n    }\r\n    \r\n    // Maximum number of entries that will be allowed\r\n    uint constant MAX_ENTRIES = 2**48;\r\n    \r\n    // The number of entries which have been received.\r\n    uint48 entryCount = 0;\r\n    \r\n    // Map of the encoded entry to the user who crreated it.\r\n    mapping (uint256 => Entrant) public entries;\r\n    \r\n    // The times where we're allowed to transition the contract's state\r\n    mapping (uint => uint) public transitionTimes;\r\n    \r\n    // The current state of the contest\r\n    ContestState public currentState;\r\n    \r\n    // The recorded votes of our oracles\r\n    mapping (address => Result) public oracleVotes;\r\n    \r\n    // The oracles who will submit the results of the tournament\r\n    address[] public oracles;\r\n    \r\n    // The maximum number of oracles we'll allow vote in our contest\r\n    uint constant MAX_ORACLES = 10;\r\n    \r\n    // The final result of the tournament that the oracles agreed on\r\n    Result public finalResult;\r\n    \r\n    // Keeps the current top 3 best scores and who submitted them. When the contest ends, they'll be paid out\r\n    TopScore[3] public topThree;\r\n    \r\n    // The address of the ERC20 token that defines our prize\r\n    address public prizeERC20TokenAddress;\r\n    \r\n    // The amount of the prize to reward\r\n    uint public prizeAmount;\r\n    \r\n    // Event emitted when a new entry gets submitted to the contest\r\n    event EntrySubmitted(\r\n        // The account who submitted this bracket\r\n        address indexed submitter,\r\n\r\n        // A compressed representation of the entry combining the picks and final game scores\r\n        uint256 indexed entryCompressed,\r\n\r\n        // The order this entry was received. Used for tiebreaks\r\n        uint48 indexed entryIndex,\r\n\r\n        // Optional bracket name provided by the submitter\r\n        string bracketName\r\n    );\r\n\r\n    // Constructs a new instance of the EthMadness contract with the given transition times\r\n    constructor(uint[] memory times, address erc20Token, uint erc20Amount) public {\r\n        \r\n        // Initialize the oracles array with the sender's address\r\n        oracles = [msg.sender];\r\n        \r\n        // Set up our prize info\r\n        prizeERC20TokenAddress = erc20Token;\r\n        prizeAmount = erc20Amount;\r\n        \r\n        // Set up our transition times\r\n        require(times.length == 4);\r\n        transitionTimes[uint(ContestState.TOURNAMENT_IN_PROGRESS)] = times[0];\r\n        transitionTimes[uint(ContestState.WAITING_FOR_ORACLES)] = times[1];\r\n        transitionTimes[uint(ContestState.WAITING_FOR_WINNING_CLAIMS)] = times[2];\r\n        transitionTimes[uint(ContestState.COMPLETED)] = times[3];\r\n        \r\n        // The initial state should be allowing people to make entries\r\n        currentState = ContestState.OPEN_FOR_ENTRIES;\r\n    }\r\n\r\n    // Gets the total number of entries we've received\r\n    function getEntryCount() public view returns (uint256) {\r\n        return entryCount;\r\n    }\r\n    \r\n    // Gets the number of Oracles we have registered\r\n    function getOracleCount() public view returns(uint256) {\r\n        return oracles.length;\r\n    }\r\n    \r\n    // Returns the transition times for our contest\r\n    function getTransitionTimes() public view returns (uint256, uint256, uint256, uint256) {\r\n        return (\r\n            transitionTimes[uint(ContestState.TOURNAMENT_IN_PROGRESS)],\r\n            transitionTimes[uint(ContestState.WAITING_FOR_ORACLES)],\r\n            transitionTimes[uint(ContestState.WAITING_FOR_WINNING_CLAIMS)],\r\n            transitionTimes[uint(ContestState.COMPLETED)]\r\n        );\r\n    }\r\n    \r\n    // Internal function for advancing the state of the bracket\r\n    function advanceState(ContestState nextState) private {\r\n        require(uint(nextState) == uint(currentState) + 1, \"Can only advance state by 1\");\r\n        require(now > transitionTimes[uint(nextState)], \"Transition time hasn't happened yet\");\r\n        \r\n        currentState = nextState;\r\n    }\r\n\r\n    // Helper to make sure the picks submitted are legal\r\n    function arePicksOrResultsValid(bytes16 picksOrResults) public pure returns (bool) {\r\n        // Go through and make sure that this entry has 1 pick for each game\r\n        for (uint8 gameId = 0; gameId < 63; gameId++) {\r\n            uint128 currentPick = extractResult(picksOrResults, gameId);\r\n            if (currentPick != 2 && currentPick != 1) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    // Submits a new entry to the tournament\r\n    function submitEntry(bytes16 picks, uint64 scoreA, uint64 scoreB, string memory bracketName) public {\r\n        require(currentState == ContestState.OPEN_FOR_ENTRIES, \"Must be in the open for entries state\");\r\n        require(arePicksOrResultsValid(picks), \"The supplied picks are not valid\");\r\n\r\n        // Do some work to encode the picks and scores into a single uint256 which becomes a key\r\n        uint256 scoreAShifted = uint256(scoreA) * (2 ** (24 * 8));\r\n        uint256 scoreBShifted = uint256(scoreB) * (2 ** (16 * 8));\r\n        uint256 picksAsNumber = uint128(picks);\r\n        uint256 entryCompressed = scoreAShifted | scoreBShifted | picksAsNumber;\r\n\r\n        require(entries[entryCompressed].submitter == address(0), \"This exact bracket & score has already been submitted\");\r\n        \r\n        // Emit the event that this entry was received and save the entry\r\n        emit EntrySubmitted(msg.sender, entryCompressed, entryCount, bracketName);\r\n        Entrant memory entrant = Entrant(msg.sender, entryCount);\r\n        entries[entryCompressed] = entrant;\r\n        entryCount++;\r\n    }\r\n\r\n    // Adds an allowerd oracle who will vote on the results of the contest. Only the contract owner can do this\r\n    // and it can only be done while the tournament is still open for entries\r\n    function addOracle(address oracle) public onlyOwner {\r\n        require(currentState == ContestState.OPEN_FOR_ENTRIES, \"Must be accepting entries\");\r\n        require(oracles.length < MAX_ORACLES - 1, \"Must be less than max number of oracles\");\r\n        oracles.push(oracle);\r\n    }\r\n\r\n    // In case something goes wrong, allow the owner to eject from the contract\r\n    // but only while picks are still being made or after the contest completes\r\n    function refundRemaining(uint256 amount) public onlyOwner {\r\n        require(currentState == ContestState.OPEN_FOR_ENTRIES || currentState == ContestState.COMPLETED, \"Must be accepting entries\");\r\n        \r\n        IERC20 erc20 = IERC20(prizeERC20TokenAddress);\r\n        erc20.transfer(msg.sender, amount);\r\n    }\r\n    \r\n    // Submits a new oracle's vote describing the results of the tournament\r\n    function submitOracleVote(uint oracleIndex, bytes16 winners, uint8 scoreA, uint8 scoreB) public {\r\n        require(currentState == ContestState.WAITING_FOR_ORACLES, \"Must be in waiting for oracles state\");\r\n        require(oracles[oracleIndex] == msg.sender, \"Wrong oracle index\");\r\n        require(arePicksOrResultsValid(winners), \"Results are not valid\");\r\n        oracleVotes[msg.sender] = Result(winners, scoreA, scoreB, true);\r\n    }\r\n    \r\n    // Close the voting and set the final result. Pass in what should be the consensus agreed by the\r\n    // 70% of the oracles\r\n    function closeOracleVoting(bytes16 winners, uint8 scoreA, uint8 scoreB) public {\r\n        require(currentState == ContestState.WAITING_FOR_ORACLES);\r\n\r\n        // Count up how many oracles agree with this result\r\n        uint confirmingOracles = 0;\r\n        for (uint i = 0; i < oracles.length; i++) {\r\n            Result memory oracleVote = oracleVotes[oracles[i]];\r\n            if (oracleVote.isFinal &&\r\n                oracleVote.winners == winners &&\r\n                oracleVote.scoreA == scoreA &&\r\n                oracleVote.scoreB == scoreB) {\r\n\r\n                confirmingOracles++;\r\n            }\r\n        }\r\n        \r\n        // Require 70%+ of Oracles to have voted and agree on the result\r\n        uint percentAggreement = (confirmingOracles * 100) / oracles.length;\r\n        require(percentAggreement > 70, \"To close oracle voting, > 70% of oracles must agree\");\r\n        \r\n        // Change the state and set our final result which will be used to compute scores\r\n        advanceState(ContestState.WAITING_FOR_WINNING_CLAIMS);\r\n        finalResult = Result(winners, scoreA, scoreB, true);\r\n    }\r\n    \r\n    // Closes the entry period and marks that the actual tournament is in progress\r\n    function markTournamentInProgress() public {\r\n        advanceState(ContestState.TOURNAMENT_IN_PROGRESS);\r\n        \r\n        require(oracles.length > 0, \"Must have at least 1 oracle registered\");\r\n        \r\n        // Require that we have the amount of funds locked in the contract we expect\r\n        IERC20 erc20 = IERC20(prizeERC20TokenAddress);\r\n        require(erc20.balanceOf(address(this)) >= prizeAmount, \"Must have a balance in this contract\");\r\n    }\r\n    \r\n    // Mark that the tournament has completed and oracles can start submitting results\r\n    function markTournamentFinished() public {\r\n        advanceState(ContestState.WAITING_FOR_ORACLES);\r\n    }\r\n    \r\n    // After the oracles have voted and winners have claimed their prizes, this closes the contest and\r\n    // pays out the winnings to the 3 winners\r\n    function closeContestAndPayWinners() public {\r\n        advanceState(ContestState.COMPLETED);\r\n        require(topThree[0].submitter != address(0), \"Not enough claims\");\r\n        require(topThree[1].submitter != address(0), \"Not enough claims\");\r\n        require(topThree[2].submitter != address(0), \"Not enough claims\");\r\n        \r\n        uint firstPrize = (prizeAmount * 70) / 100;\r\n        uint secondPrize = (prizeAmount * 20) / 100;\r\n        uint thirdPrize = (prizeAmount * 10) / 100;\r\n        IERC20 erc20 = IERC20(prizeERC20TokenAddress);\r\n        erc20.transfer(topThree[0].submitter, firstPrize);\r\n        erc20.transfer(topThree[1].submitter, secondPrize);\r\n        erc20.transfer(topThree[2].submitter, thirdPrize);\r\n    }\r\n    \r\n    // Scores an entry and places it in the right sort order\r\n    function scoreAndSortEntry(uint256 entryCompressed, bytes16 results, uint64 scoreAActual, uint64 scoreBActual) private returns (uint32) {\r\n        require(currentState == ContestState.WAITING_FOR_WINNING_CLAIMS, \"Must be in the waiting for claims state\");\r\n        require(entries[entryCompressed].submitter != address(0), \"The entry must have actually been submitted\");\r\n\r\n        // Pull out the pick information from the compressed entry\r\n        bytes16 picks = bytes16(uint128((entryCompressed & uint256((2 ** 128) - 1))));\r\n        uint256 shifted = entryCompressed / (2 ** 128); // shift over 128 bits\r\n        uint64 scoreA = uint64((shifted & uint256((2 ** 64) - 1)));\r\n        shifted = entryCompressed / (2 ** 192);\r\n        uint64 scoreB = uint64((shifted & uint256((2 ** 64) - 1)));\r\n\r\n        // Compute the score and the total difference\r\n        uint32 score = scoreEntry(picks, results);\r\n        uint64 difference = computeFinalGameDifference(scoreA, scoreB, scoreAActual, scoreBActual);\r\n\r\n        // Make a score and place it in the right sort order\r\n        TopScore memory scoreResult = TopScore(entries[entryCompressed].entryIndex, score, difference, entries[entryCompressed].submitter);\r\n        if (isScoreBetter(scoreResult, topThree[0])) {\r\n            topThree[2] = topThree[1];\r\n            topThree[1] = topThree[0];\r\n            topThree[0] = scoreResult;\r\n        } else if (isScoreBetter(scoreResult, topThree[1])) {\r\n            topThree[2] = topThree[1];\r\n            topThree[1] = scoreResult;\r\n        } else if (isScoreBetter(scoreResult, topThree[2])) {\r\n            topThree[2] = scoreResult;\r\n        }\r\n        \r\n        return score;\r\n    }\r\n    \r\n    function claimTopEntry(uint256 entryCompressed) public {\r\n        require(currentState == ContestState.WAITING_FOR_WINNING_CLAIMS, \"Must be in the waiting for winners state\");\r\n        require(finalResult.isFinal, \"The final result must be marked as final\");\r\n        scoreAndSortEntry(entryCompressed, finalResult.winners, finalResult.scoreA, finalResult.scoreB);\r\n    }\r\n    \r\n    function computeFinalGameDifference(\r\n        uint64 scoreAGuess, uint64 scoreBGuess, uint64 scoreAActual, uint64 scoreBActual) private pure returns (uint64) {\r\n        \r\n        // Don't worry about overflow here, not much you can really do with it\r\n        uint64 difference = 0;\r\n        difference += ((scoreAActual > scoreAGuess) ? (scoreAActual - scoreAGuess) : (scoreAGuess - scoreAActual));\r\n        difference += ((scoreBActual > scoreBGuess) ? (scoreBActual - scoreBGuess) : (scoreBGuess - scoreBActual));\r\n        return difference;\r\n    }\r\n    \r\n    // Gets the bit at index n in a\r\n    function getBit16(bytes16 a, uint16 n) private pure returns (bool) {\r\n        uint128 mask = uint128(2) ** n;\r\n        return uint128(a) & mask != 0;\r\n    }\r\n    \r\n    // Sets the bit at index n to 1 in a\r\n    function setBit16(bytes16 a, uint16 n) private pure returns (bytes16) {\r\n        uint128 mask = uint128(2) ** n;\r\n        return a | bytes16(mask);\r\n    }\r\n    \r\n    // Sets the bit at index n to 0 in a\r\n    function clearBit16(bytes16 a, uint16 n) private pure returns (bytes16) {\r\n        uint128 mask = uint128(2) ** n;\r\n        mask = mask ^ uint128(-1);\r\n        return a & bytes16(mask);\r\n    }\r\n    \r\n    // Returns either 0 if there is no possible winner, 1 if team B is chosen, or 2 if team A is chosen\r\n    function extractResult(bytes16 a, uint8 n) private pure returns (uint128) {\r\n        uint128 mask = uint128(0x00000000000000000000000000000003) * uint128(2) ** (n * 2);\r\n        uint128 masked = uint128(a) & mask;\r\n        \r\n        // Shift back to get either 0, 1 or 2\r\n        return (masked / (uint128(2) ** (n * 2)));\r\n    }\r\n    \r\n    // Gets which round a game belongs to based on its id\r\n    function getRoundForGame(uint8 gameId) private pure returns (uint8) {\r\n        if (gameId < 32) {\r\n            return 0;\r\n        } else if (gameId < 48) {\r\n            return 1;\r\n        } else if (gameId < 56) {\r\n            return 2;\r\n        } else if (gameId < 60) {\r\n            return 3;\r\n        } else if (gameId < 62) {\r\n            return 4;\r\n        } else {\r\n            return 5;\r\n        }\r\n    }\r\n    \r\n    // Gets the first game in a round given the round number\r\n    function getFirstGameIdOfRound(uint8 round) private pure returns (uint8) {\r\n        if (round == 0) {\r\n            return 0;\r\n        } else if (round == 1) {\r\n            return 32;\r\n        } else if (round == 2) {\r\n            return 48;\r\n        } else if (round == 3) {\r\n            return 56;\r\n        } else if (round == 4) {\r\n            return 60;\r\n        } else {\r\n            return 62;\r\n        }\r\n    }\r\n    \r\n    // Looks at two scores and decided whether newScore is a better score than old score\r\n    function isScoreBetter(TopScore memory newScore, TopScore memory oldScore) private pure returns (bool) {\r\n        if (newScore.score > oldScore.score) {\r\n            return true;\r\n        }\r\n        \r\n        if (newScore.score < oldScore.score) {\r\n            return false;\r\n        }\r\n        \r\n        // Case where we have a tie\r\n        if (newScore.difference < oldScore.difference) {\r\n            return true;\r\n        }\r\n        \r\n        if (newScore.difference < oldScore.difference) {\r\n            return false;\r\n        }\r\n\r\n        require(newScore.entryIndex != oldScore.entryIndex, \"This entry has already claimed a prize\");\r\n        \r\n        // Crazy case where we have the same score and same diference. Return the earlier entry as the winnner\r\n        return newScore.entryIndex < oldScore.entryIndex;\r\n    }\r\n    \r\n    // Scores an entry given the picks and the results\r\n    function scoreEntry(bytes16 picks, bytes16 results) private pure returns (uint32) {\r\n        uint32 score = 0;\r\n        uint8 round = 0;\r\n        bytes16 currentPicks = picks;\r\n        for (uint8 gameId = 0; gameId < 63; gameId++) {\r\n            \r\n            // Update which round we're in when on the transitions\r\n            round = getRoundForGame(gameId);\r\n            \r\n            uint128 currentPick = extractResult(currentPicks, gameId);\r\n            if (currentPick == extractResult(results, gameId)) {\r\n                score += (uint32(2) ** round);\r\n            } else if (currentPick != 0) { // If we actually had a pick, propagate forward\r\n                // Mark all the future currentPicks which required this team winning as null\r\n                uint16 currentPickId = (gameId * 2) + (currentPick == 2 ? 1 : 0);\r\n                for (uint8 futureRound = round + 1; futureRound < 6; futureRound++) {\r\n                    uint16 currentPickOffset = currentPickId - (getFirstGameIdOfRound(futureRound - 1) * 2);\r\n                    currentPickId = (getFirstGameIdOfRound(futureRound) * 2) + (currentPickOffset / 2);\r\n                    \r\n                    bool pickedLoser = getBit16(currentPicks, currentPickId);\r\n                    if (pickedLoser) {\r\n                        currentPicks = clearBit16(currentPicks, currentPickId);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return score;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"markTournamentInProgress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topThree\",\"outputs\":[{\"name\":\"entryIndex\",\"type\":\"uint48\"},{\"name\":\"score\",\"type\":\"uint32\"},{\"name\":\"difference\",\"type\":\"uint64\"},{\"name\":\"submitter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeContestAndPayWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracleVotes\",\"outputs\":[{\"name\":\"winners\",\"type\":\"bytes16\"},{\"name\":\"scoreA\",\"type\":\"uint8\"},{\"name\":\"scoreB\",\"type\":\"uint8\"},{\"name\":\"isFinal\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracles\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"picks\",\"type\":\"bytes16\"},{\"name\":\"scoreA\",\"type\":\"uint64\"},{\"name\":\"scoreB\",\"type\":\"uint64\"},{\"name\":\"bracketName\",\"type\":\"string\"}],\"name\":\"submitEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEntryCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracleIndex\",\"type\":\"uint256\"},{\"name\":\"winners\",\"type\":\"bytes16\"},{\"name\":\"scoreA\",\"type\":\"uint8\"},{\"name\":\"scoreB\",\"type\":\"uint8\"}],\"name\":\"submitOracleVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"picksOrResults\",\"type\":\"bytes16\"}],\"name\":\"arePicksOrResultsValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"refundRemaining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entryCompressed\",\"type\":\"uint256\"}],\"name\":\"claimTopEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entries\",\"outputs\":[{\"name\":\"submitter\",\"type\":\"address\"},{\"name\":\"entryIndex\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransitionTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winners\",\"type\":\"bytes16\"},{\"name\":\"scoreA\",\"type\":\"uint8\"},{\"name\":\"scoreB\",\"type\":\"uint8\"}],\"name\":\"closeOracleVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeERC20TokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"addOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transitionTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"markTournamentFinished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalResult\",\"outputs\":[{\"name\":\"winners\",\"type\":\"bytes16\"},{\"name\":\"scoreA\",\"type\":\"uint8\"},{\"name\":\"scoreB\",\"type\":\"uint8\"},{\"name\":\"isFinal\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"times\",\"type\":\"uint256[]\"},{\"name\":\"erc20Token\",\"type\":\"address\"},{\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"entryCompressed\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"entryIndex\",\"type\":\"uint48\"},{\"indexed\":false,\"name\":\"bracketName\",\"type\":\"string\"}],\"name\":\"EntrySubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthMadness","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a2326035900000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000005c93c310000000000000000000000000000000000000000000000000000000005cac42ef000000000000000000000000000000000000000000000000000000005cad946f000000000000000000000000000000000000000000000000000000005cb6ceef","Library":"","SwarmSource":"bzzr://818a07b206f718b81568c5ef627f12ce11e7c3e47f4cfd2b7fc37ccfcb5a47e6"}]}