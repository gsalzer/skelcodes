{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\ncontract NiftyStaticCalls {\r\n    \r\n    function retAdd() external view returns(address) {\r\n        return(msg.sender);\r\n    }\r\n    \r\n       /**\r\n   * Recovery function for signature - taken from OpenZeppelin\r\n   * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9e1da49f235476290d5433dac6807500e18c7251/contracts/ECRecovery.sol\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n    \r\n        /** Functions to validate signatures so wallet can sign messages\r\n     * @dev Two functions - isValidSignature(bytes,bytes) and isValidSignature(bytes32,bytes)\r\n     * @dev isValidSignature(bytes,bytes) conforms to ERC1271 - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md\r\n     * @dev This means it returns the magic value 0x20c13b0b\r\n     * @dev isValidSignature(bytes32,bytes) conforms to - https://github.com/0xProject/0x-monorepo/blob/development/contracts/exchange/contracts/examples/Wallet.sol#L45\r\n     */ \r\n    \r\n        /// @dev Validates a signature.\r\n    ///      The signer must match the owner of this wallet.\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signature Proof of signing.\r\n    /// @return Validity of signature as bool\r\n    /// @dev To ensure a signature from one Nifty Wallet can't be used for another,\r\n    /// @dev Data signed is concantenated with the wallets address\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        bytes calldata signature\r\n    )\r\n        external\r\n        view\r\n        returns (bool isValid)\r\n    {\r\n        require(\r\n            signature.length == 65,\r\n            \"LENGTH_65_REQUIRED\"\r\n        );\r\n        \r\n        bytes memory newData = abi.encodePacked(msg.sender, hash);\r\n        bytes32 newDataHash = keccak256(newData);\r\n        \r\n        address recoveredAddress = recover(newDataHash, signature);\r\n        NiftyWalletContract NW_instance = NiftyWalletContract(msg.sender);\r\n        address WALLET_OWNER = NW_instance.returnUserAccountAddress();\r\n        isValid = WALLET_OWNER == recoveredAddress;\r\n        return isValid;\r\n    }\r\n    \r\n    bytes4 internal MAGICVALUE = 0x20c13b0b;\r\n    \r\n        /// @dev Validates a signature.\r\n    ///      The signer must match the owner of this wallet.\r\n    /// @param _data Data that is signed.\r\n    /// @param signature Proof of signing.\r\n    /// @return Validity of signature as bytes4\r\n    /// @dev To ensure a signature from one Nifty Wallet can't be used for another,\r\n    /// @dev Data signed is concantenated with the wallets address\r\n    function isValidSignature(\r\n        bytes calldata _data,\r\n        bytes calldata signature\r\n    )\r\n        external\r\n        view\r\n      returns (bytes4 magicValue)\r\n    {\r\n        require(\r\n            signature.length == 65,\r\n            \"LENGTH_65_REQUIRED\"\r\n        );\r\n        \r\n        bytes32 dataHash = keccak256(_data);\r\n        bytes memory newData = abi.encodePacked(msg.sender, dataHash);\r\n        bytes32 newDataHash = keccak256(newData);\r\n        \r\n        address recoveredAddress = recover(newDataHash, signature);\r\n        NiftyWalletContract NW_instance = NiftyWalletContract(msg.sender);\r\n        address WALLET_OWNER = NW_instance.returnUserAccountAddress();\r\n        if (WALLET_OWNER == recoveredAddress) {\r\n            return MAGICVALUE;\r\n        } else {\r\n            return (0xdeadbeef);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Safe receiver functions\r\n    */\r\n    \r\n    /** ERC721 receiver function \r\n     * From OpenZeppelin - https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC721/ERC721Receiver.sol\r\n     * Nifty Wallets will always receive an ERC721\r\n     */\r\n    \r\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n    \r\n    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\r\n        return (ERC721_RECEIVED);\r\n    }\r\n\r\n    /** Safe ERC1155 receiver\r\n    * Nifty Wallets will always receive ERC1155s as well\r\n    * We like all tokens\r\n    * From Horizon Games - https://github.com/horizon-games/multi-token-standard\r\n    */\r\n    bytes4 constant public ERC1155_RECEIVED_SIG = 0xf23a6e61;\r\n      bytes4 constant public ERC1155_BATCH_RECEIVED_SIG = 0xbc197c81;\r\n      bytes4 constant public ERC1155_RECEIVED_INVALID = 0xdeadbeef;\r\n\r\n      bytes public lastData;\r\n      address public lastOperator;\r\n      uint256 public lastId;\r\n      uint256 public lastValue;\r\n\r\n      /**\r\n      * @notice Handle the receipt of a single ERC1155 token type.\r\n      * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\r\n      * This function MAY throw to revert and reject the transfer.\r\n      * Return of other than the magic value MUST result in the transaction being reverted.\r\n      * Note: The contract address is always the message sender.\r\n      * @param _operator  The address which called the `safeTransferFrom` function\r\n      * @param _from      The address which previously owned the token\r\n      * @param _id        The id of the token being transferred\r\n      * @param _value     The amount of tokens being transferred\r\n      * @param _data      Additional data with no specified format\r\n      * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n      */\r\n      function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data )\r\n        external view returns(bytes4)\r\n      {\r\n          return ERC1155_RECEIVED_SIG;\r\n      }\r\n\r\n      /**\r\n      * @notice Handle the receipt of multiple ERC1155 token types.\r\n      * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\r\n      * This function MAY throw to revert and reject the transfer.\r\n      * Return of other than the magic value WILL result in the transaction being reverted.\r\n      * Note: The contract address is always the message sender.\r\n      * @param _operator  The address which called the `safeBatchTransferFrom` function\r\n      * @param _from      The address which previously owned the token\r\n      * @param _ids       An array containing ids of each token being transferred\r\n      * @param _values    An array containing amounts of each token being transferred\r\n      * @param _data      Additional data with no specified format\r\n      * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n      */\r\n      function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data)\r\n        external view returns(bytes4)\r\n      {\r\n          return ERC1155_BATCH_RECEIVED_SIG;\r\n      }\r\n}\r\n\r\ncontract NiftyWalletContract {\r\n    function returnWalletTxCount() public view returns (uint);\r\n    function returnUserAccountAddress() public view returns (address);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC1155_BATCH_RECEIVED_SIG\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"isValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"retAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC1155_RECEIVED_SIG\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC1155_RECEIVED_INVALID\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NiftyStaticCalls","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ffac80791b21fcb807e1b6cb7dfdaaa7e8c57aa44fb071b9843f86d465013d32"}]}