{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract MasterCopy is SelfAuthorized {\r\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n  // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n  /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall,\r\n        Create\r\n    }\r\n}\r\n\r\n\r\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract EtherPaymentFallback {\r\n\r\n    /// @dev Fallback function accepts Ether transactions.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n\r\n    }\r\n}\r\n\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Executor is EtherPaymentFallback {\r\n\r\n    event ContractCreation(address newContract);\r\n\r\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else {\r\n            address newContract = executeCreate(data);\r\n            success = newContract != address(0);\r\n            emit ContractCreation(newContract);\r\n        }\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeCreate(bytes memory data)\r\n        internal\r\n        returns (address newContract)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            newContract := create(0, add(data, 0x20), mload(data))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n\r\n    address public constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n    \r\n    function setupModules(address to, bytes memory data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[address(module)] == address(0), \"Module has already been added\");\r\n        modules[address(module)] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = address(module);\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[address(prevModule)] = modules[address(module)];\r\n        modules[address(module)] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        // Calculate module count\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        address[] memory array = new address[](moduleCount);\r\n\r\n        // populate return array\r\n        moduleCount = 0;\r\n        currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n/// @title Module - Base class for modules.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n/// @title Create and Add Modules - Allows to create and add multiple module in one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract CreateAndAddModules {\r\n\r\n    /// @dev Function required to compile contract. Gnosis Safe function is called instead.\r\n    /// @param module Not used.\r\n    function enableModule(Module module)\r\n    public\r\n    {\r\n        revert();\r\n    }\r\n\r\n    /// @dev Allows to create and add multiple module in one transaction.\r\n    /// @param proxyFactory Module proxy factory contract.\r\n    /// @param data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)\r\n    function createAndAddModules(address proxyFactory, bytes memory data)\r\n    public\r\n    {\r\n        uint256 length = data.length;\r\n        Module module;\r\n        uint256 i = 0;\r\n        while (i < length) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                let createBytesLength := mload(add(0x20, add(data, i)))\r\n                let createBytes := add(0x40, add(data, i))\r\n\r\n                let output := mload(0x40)\r\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) {revert(0, 0)}\r\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\r\n\r\n            // Data is always padded to 32 bytes\r\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\r\n            }\r\n            this.enableModule(module);\r\n        }\r\n    }\r\n    /// @dev Allows to create and add multiple module in one transaction.\r\n    function createNoFactory(address proxy, bytes memory data)\r\n    public\r\n    {\r\n\r\n        require(proxy != address(0), \"createAndAddModules::createNoFactory INVALID_DATA: PROXY_ADDRESS\");\r\n\r\n        if (data.length > 0) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {}\r\n            }\r\n        }\r\n\r\n        Module module = Module(proxy);\r\n        this.enableModule(module);\r\n\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"proxyFactory\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createAndAddModules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"module\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createNoFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CreateAndAddModules","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://59cbed51b73a560319d1007d5b352bc3c0c7ca2dbaef4561eb28a19c4192da57"}]}