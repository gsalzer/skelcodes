{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/*\r\n*\r\n* WELCOME TO THE SUSTAINABLE UPSWEEP NETWORK\r\n*\r\n*                  upsweep.net\r\n*\r\n* Gambling with low gas fees, no edge and no leaks.  \r\n*\r\n*   \r\n*                _19^^^^0^^^^1_\r\n*             .18''           ``2.\r\n*           .17'      \r\n*          .16'   Here's to the   `3.\r\n*         .15'      unfolding      `4.\r\n*         ::         of hope.       ::\r\n*         ::  ...................   ::\r\n*         ::                        ::\r\n*         `14.       @author       .5'\r\n*          `13.  symmetricproof   .6'\r\n*           `12.                .7'\r\n*             `11..          ..8'\r\n*                ^10........9^\r\n*                    ''''     \r\n*\r\n*\r\n/* @title The Upsweep Network; a social and sustainable circle of bets.\r\n*/\r\n\r\ncontract UpsweepV1 {\r\n\r\n    uint public elapsed;\r\n    uint public timeout;\r\n    uint public lastId;\r\n    uint public counter;\r\n    bool public closed;\r\n    \r\n    struct Player {\r\n        bool revealOnce;\r\n        bool claimed;\r\n        bool gotHonour;\r\n        uint8 i;\r\n        bytes32 commit;\r\n    }\r\n\r\n    mapping(uint => mapping (address => Player)) public player;\r\n    mapping(uint => uint8[20]) public balancesById;   \r\n    mapping(uint => uint8[20]) public bottleneckById;\r\n    \r\n    address payable public owner = msg.sender;\r\n    uint public ticketPrice = 100000000000000000;\r\n    \r\n    mapping(uint => uint) public honour;\r\n    \r\n    event FirstBlock(uint);\r\n    event LastBlock(uint);\r\n    event Join(uint);\r\n    event Reveal(uint seat, uint indexed gameId);\r\n    event NewId(uint);\r\n    \r\n    modifier onlyBy(address _account)\r\n    {\r\n        require(\r\n            msg.sender == _account,\r\n            \"Sender not authorized.\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier circleIsPrivate(bool _closed) {\r\n        require(\r\n            _closed == true,\r\n            \"Game is in progress.\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier circleIsPublic(bool _closed) {\r\n        require(\r\n            _closed == false,\r\n            \"Next game has not started.\"\r\n        );\r\n        _;\r\n    } \r\n    \r\n    modifier onlyAfter(uint _time) {\r\n        require(\r\n            block.number > _time,\r\n            \"Function called too early.\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier onlyBefore(uint _time) {\r\n        require(\r\n            block.number <= _time,\r\n            \"Function called too late.\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier ticketIsAffordable(uint _amount) {\r\n        require(\r\n            msg.value >= _amount,\r\n            \"Not enough Ether provided.\"\r\n        );\r\n        _;\r\n        if (msg.value > _amount)\r\n            msg.sender.transfer(msg.value - _amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev pick a number and cast the hash to the network. \r\n    * @param _hash is the keccak256 output for the address of the message sender+\r\n    * the number + a passphrase\r\n    */\r\n    function join(bytes32 _hash)\r\n        public\r\n        payable\r\n        circleIsPublic(closed)\r\n        ticketIsAffordable(ticketPrice)\r\n        returns (uint gameId)\r\n    {\r\n        //the circle is only open to 40 players.\r\n        require(\r\n            counter < 40,       \r\n            \"Game is full.\"\r\n        );            \r\n        \r\n        //timer starts when the first ticket of the game is sold\r\n        if (counter == 0) {\r\n            elapsed = block.number;\r\n            emit FirstBlock(block.number);\r\n        }\r\n\r\n        player[lastId][msg.sender].commit = _hash;\r\n        \r\n        //when the game is full, timer stops and the countdown to reveal begins\r\n        //NO MORE COMMITS ARE RECEIVED.\r\n        if (counter == 39) {       \r\n            closed = true;\r\n            uint temp = sub(block.number,elapsed);\r\n            timeout = add(temp,block.number);\r\n            emit LastBlock(timeout);\r\n        } \r\n        \r\n        counter++;\r\n\r\n        emit Join(counter);\r\n        return lastId;\r\n    }\r\n   \r\n     /**\r\n    * @notice get a refund and exit the game before it begins\r\n    */\r\n    function abandon()\r\n        public\r\n        circleIsPublic(closed)\r\n        returns (bool success)\r\n    {\r\n        bytes32 commit = player[lastId][msg.sender].commit;\r\n        require(\r\n            commit != 0,\r\n            \"Player was not in the game.\"\r\n        );\r\n        \r\n        player[lastId][msg.sender].commit = 0;\r\n        counter --;\r\n        if (counter == 0) {\r\n            elapsed = 0;\r\n            emit FirstBlock(0);\r\n        }    \r\n        emit Join(counter);\r\n        msg.sender.transfer(ticketPrice);\r\n        return true;\r\n    }     \r\n    /**\r\n    * @notice to make your bet legal, you must reveal the corresponding number\r\n    * @dev a new hash is computed to verify authenticity of the bet\r\n    * @param i is the number (between 0 and 19)\r\n    * @param passphrase to prevent brute-force validation\r\n    */\r\n    function reveal(\r\n        uint8 i, \r\n        string memory passphrase \r\n    )\r\n        public \r\n        circleIsPrivate(closed)\r\n        onlyBefore(timeout)\r\n        returns (bool success)\r\n    {\r\n        bool status = player[lastId][msg.sender].revealOnce;\r\n        require(\r\n            status == false,\r\n            \"Player already revealed.\"\r\n        );\r\n        \r\n        bytes32 commit = player[lastId][msg.sender].commit;\r\n \r\n        //hash is recalculated to verify authenticity\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(msg.sender,i,passphrase)\r\n        );\r\n            \r\n        require(\r\n            hash == commit,\r\n            \"Hashes don't match.\"\r\n        );\r\n        \r\n        player[lastId][msg.sender].revealOnce = true;\r\n        player[lastId][msg.sender].i = i;\r\n        \r\n        //contribution is credited to the chosen number\r\n        balancesById[lastId][i] ++;\r\n        //the list of players inside this numbers grows by one\r\n        bottleneckById[lastId][i] ++;\r\n        \r\n        counter--;\r\n        //last player to reveal must pay extra gas fees to update the game \r\n        if (counter == 0) {\r\n            timeout = 0;\r\n            updateBalances();\r\n        }\r\n        \r\n        emit Reveal(i,lastId);\r\n        return true;\r\n    }\r\n  \r\n    /**\r\n    * @notice distributes rewards fairly.\r\n    * @dev the circle has no head or foot, node 19 passes to node 0 only if node 0 is not empty.\r\n    * To successfully distribute contributions, the function loops through all numbers and \r\n    * identifies the first empty number, from there the chain of transfers begins. \r\n    * \r\n    */\r\n    function updateBalances()\r\n        public\r\n        circleIsPrivate(closed)\r\n        onlyAfter(timeout)\r\n        returns (bool success)\r\n    {\r\n        // identify the first empty number.\r\n        for (uint8 i = 0; i < 20; i++) {\r\n            if (balancesById[lastId][i] == 0) { \r\n                // start chain of transfers from the next number.\r\n                uint j = i + 1;\r\n                for (uint8 a = 0; a < 19; a++) {   \r\n                    if (j == 20) j = 0;\r\n                    if (j == 19) {       \r\n                        if (balancesById[lastId][0] > 0) {\r\n                            uint8 temp = balancesById[lastId][19];\r\n                            balancesById[lastId][19] = 0;\r\n                            balancesById[lastId][0] += temp;  \r\n                            j = 0; \r\n                        } else {\r\n                            j = 1;\r\n                        }\r\n                    } else {            \r\n                        if (balancesById[lastId][j + 1] > 0) { \r\n                            uint8 temp = balancesById[lastId][j];\r\n                            balancesById[lastId][j] = 0;\r\n                            balancesById[lastId][j + 1] += temp; \r\n                            j += 1; \r\n                        } else { \r\n                            j += 2; \r\n                        }\r\n                    }\r\n                }\r\n                // will break when all balances are updated.\r\n                break;\r\n            }\r\n        }\r\n        // reset variables and start a new game.\r\n        closed = false;\r\n        if (timeout > 0) timeout = 0;\r\n        elapsed = 0;\r\n        // players that reveal are rewarded the ticket value of those\r\n        // that don't reveal.\r\n        if (counter > 0) {\r\n            uint total = mul(counter, ticketPrice);\r\n            uint among = sub(40,counter);\r\n            honour[lastId] = div(total,among);\r\n            counter = 0;\r\n        } \r\n        lastId ++;\r\n        emit NewId(lastId);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @notice accumulated rewards are already allocated in specific numbers, if players can\r\n    * prove they picked that \"lucky\" number, they are allowed to withdraw the accumulated\r\n    * ether.\r\n    * \r\n    * If there is more than one player in a given number, the reward is split equally. \r\n    * \r\n    * @param gameId only attempt to withdraw rewards from a valid game, otherwise the transaction\r\n    * will fail.\r\n    */\r\n    function withdraw(uint gameId) \r\n        public\r\n        returns (bool success)\r\n    {\r\n        bool status = player[gameId][msg.sender].revealOnce;\r\n        require(\r\n            status == true,\r\n            \"Player has not revealed.\"\r\n        );\r\n        \r\n        bool claim = player[gameId][msg.sender].claimed;\r\n        require(\r\n            claim == false,\r\n            \"Player already claimed.\"\r\n        );\r\n        \r\n        uint8 index = player[gameId][msg.sender].i;\r\n        require(\r\n            balancesById[gameId][index] > 0,\r\n            \"Player didn't won.\"\r\n        );\r\n        \r\n        player[gameId][msg.sender].claimed = true;\r\n        \r\n        uint temp = uint(balancesById[gameId][index]);\r\n        uint among = uint(bottleneckById[gameId][index]);\r\n        uint total = mul(temp, ticketPrice);\r\n        uint payout = div(total, among);\r\n        \r\n        msg.sender.transfer(payout);   \r\n        \r\n        return true;\r\n    }   \r\n    \r\n    function microTip()\r\n        public\r\n        payable\r\n        returns (bool success)\r\n    {\r\n        owner.transfer(msg.value);\r\n        return true;\r\n    }\r\n    \r\n    function changeOwner(address payable _newOwner)\r\n        public\r\n        onlyBy(owner)\r\n        returns (bool success)\r\n    {\r\n        owner = _newOwner;\r\n        return true;\r\n    }\r\n    \r\n    function getHonour(uint _gameId)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        bool status = player[_gameId][msg.sender].gotHonour;\r\n        require(\r\n            status == false,\r\n            \"Player already claimed honour.\"\r\n        );\r\n        bool revealed = player[_gameId][msg.sender].revealOnce;\r\n        require(\r\n            revealed == true,\r\n            \"Player has not revealed.\"\r\n        );\r\n        player[_gameId][msg.sender].gotHonour = true;\r\n        msg.sender.transfer(honour[_gameId]);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getHonour\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"elapsed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"microTip\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateBalances\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"honour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abandon\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"join\",\"outputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint8\"},{\"name\":\"passphrase\",\"type\":\"string\"}],\"name\":\"reveal\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balancesById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bottleneckById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"revealOnce\",\"type\":\"bool\"},{\"name\":\"claimed\",\"type\":\"bool\"},{\"name\":\"gotHonour\",\"type\":\"bool\"},{\"name\":\"i\",\"type\":\"uint8\"},{\"name\":\"commit\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FirstBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LastBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Join\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seat\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"Reveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NewId\",\"type\":\"event\"}]","ContractName":"UpsweepV1","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3f1d8290bd6aa63af5cf0edcd1e0464da200dd819fb2322f4247b78fe303a1bf"}]}