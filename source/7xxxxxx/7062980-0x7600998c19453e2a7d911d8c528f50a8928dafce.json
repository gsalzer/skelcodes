{"status":"1","message":"OK","result":[{"SourceCode":"//\r\npragma solidity ^0.5.0;\r\n\r\ninterface TeamInterface {\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function isAdmin(address _sender) external view returns (bool);\r\n\r\n    function isDev(address _sender) external view returns (bool);\r\n\r\n}\r\n\r\ninterface PlatformInterface {\r\n\r\n    function getAllTurnover() external view returns (uint256);\r\n\r\n    function getTurnover(bytes32 _worksID) external view returns (uint256);\r\n\r\n    function updateAllTurnover(uint256 _amount) external;\r\n\r\n    function updateTurnover(bytes32 _worksID, uint256 _amount) external;\r\n\r\n    function updateFoundAddress(address _foundation) external;\r\n\r\n    function deposit(bytes32 _worksID) external payable;\r\n\r\n    function transferTo(address _receiver, uint256 _amount) external;\r\n\r\n    function getFoundAddress() external view returns (address payable);\r\n\r\n    function balances() external view returns (uint256);\r\n\r\n}\r\n\r\ninterface ArtistInterface {\r\n\r\n    function getAddress(bytes32 _artistID) external view returns (address payable);\r\n\r\n    function add(bytes32 _artistID, address _address) external;\r\n\r\n    function hasArtist(bytes32 _artistID) external view returns (bool);\r\n\r\n    function updateAddress(bytes32 _artistID, address _address) external;\r\n\r\n}\r\n\r\ninterface WorksInterface {\r\n\r\n    function addWorks(\r\n        bytes32 _worksID,\r\n        bytes32 _artistID, \r\n        uint8 _debrisNum, \r\n        uint256 _price, \r\n        uint256 _beginTime\r\n    ) \r\n        external;\r\n\r\n    function configRule(\r\n        bytes32 _worksID,\r\n        uint8 _firstBuyLimit, \r\n        uint256 _freezeGap, \r\n        uint256 _protectGap, \r\n        uint256 _increaseRatio,\r\n        uint256 _discountGap, \r\n        uint256 _discountRatio, \r\n\r\n        uint8[3] calldata _firstAllot, \r\n        uint8[3] calldata _againAllot, \r\n        uint8[3] calldata _lastAllot \r\n    ) \r\n        external;\r\n\r\n    function publish(bytes32 _worksID, uint256 _beginTime) external;\r\n\r\n    function close(bytes32 _worksID) external;\r\n\r\n    function getWorks(bytes32 _worksID) external view returns (uint8, uint256, uint256, uint256, bool);\r\n\r\n    function getDebris(bytes32 _worksID, uint8 _debrisID) external view \r\n        returns (uint256, address, address, bytes32, bytes32, uint256);\r\n\r\n    function getRule(bytes32 _worksID) external view \r\n        returns (uint8, uint256, uint256, uint256, uint256, uint256, uint8[3] memory, uint8[3] memory, uint8[3] memory);\r\n\r\n    function hasWorks(bytes32 _worksID) external view returns (bool);\r\n\r\n    function hasDebris(bytes32 _worksID, uint8 _debrisID) external view returns (bool);\r\n\r\n    function isPublish(bytes32 _worksID) external view returns (bool);\r\n\r\n    function isStart(bytes32 _worksID) external view returns (bool);\r\n\r\n    function isProtect(bytes32 _worksID, uint8 _debrisID) external view returns (bool);\r\n\r\n    function isSecond(bytes32 _worksID, uint8 _debrisID) external view returns (bool);\r\n\r\n    function isGameOver(bytes32 _worksID) external view returns (bool);\r\n    \r\n    function isFinish(bytes32 _worksID, bytes32 _unionID) external view returns (bool);\r\n\r\n    function hasFirstUnionIds(bytes32 _worksID, bytes32 _unionID) external view returns (bool);\r\n\r\n    function hasSecondUnionIds(bytes32 _worksID, bytes32 _unionID) external view returns (bool);\r\n\r\n    function getFirstUnionIds(bytes32 _worksID) external view returns (bytes32[] memory);\r\n\r\n    function getSecondUnionIds(bytes32 _worksID) external view returns (bytes32[] memory);\r\n\r\n    function getPrice(bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getDebrisPrice(bytes32 _worksID, uint8 _debrisID) external view returns (uint256);\r\n\r\n    function getDebrisStatus(bytes32 _worksID, uint8 _debrisID) external view returns (uint256[4] memory, uint256, bytes32);\r\n\r\n    function getInitPrice(bytes32 _worksID, uint8 _debrisID) external view returns (uint256);\r\n\r\n    function getLastPrice(bytes32 _worksID, uint8 _debrisID) external view returns (uint256);\r\n\r\n    function getLastBuyer(bytes32 _worksID, uint8 _debrisID) external view returns (address payable);\r\n\r\n    function getLastUnionId(bytes32 _worksID, uint8 _debrisID) external view returns (bytes32);\r\n\r\n    function getFreezeGap(bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getFirstBuyLimit(bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getArtistId(bytes32 _worksID) external view returns (bytes32);\r\n\r\n    function getDebrisNum(bytes32 _worksID) external view returns (uint8);\r\n\r\n    function getAllot(bytes32 _worksID, uint8 _flag) external view returns (uint8[3] memory);\r\n\r\n    function getAllot(bytes32 _worksID, uint8 _flag, uint8 _element) external view returns (uint8);\r\n\r\n    function getPools(bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getPoolsAllot(bytes32 _worksID) external view returns (uint256, uint256[3] memory, uint8[3] memory);\r\n\r\n    function getStartHourglass(bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getWorksStatus(bytes32 _worksID) external view returns (uint256, uint256, uint256, bytes32);\r\n\r\n    function getProtectHourglass(bytes32 _worksID, uint8 _debrisID) external view returns (uint256);\r\n\r\n    function getDiscountHourglass(bytes32 _worksID, uint8 _debrisID) external view returns (uint256);\r\n\r\n    function updateDebris(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, address _sender) external;\r\n\r\n    function updateFirstBuyer(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, address _sender) external;\r\n\r\n    function updateBuyNum(bytes32 _worksID, uint8 _debrisID) external;\r\n\r\n    function finish(bytes32 _worksID, bytes32 _unionID) external;\r\n\r\n    function updatePools(bytes32 _worksID, uint256 _value) external;\r\n\r\n    function updateFirstUnionIds(bytes32 _worksID, bytes32 _unionID) external;\r\n\r\n    function updateSecondUnionIds(bytes32 _worksID, bytes32 _unionID) external;\r\n\r\n }\r\n\r\ninterface PlayerInterface {\r\n\r\n    function hasAddress(address _address) external view returns (bool);\r\n\r\n    function hasUnionId(bytes32 _unionID) external view returns (bool);\r\n\r\n    function getInfoByUnionId(bytes32 _unionID) external view returns (address payable, bytes32, uint256);\r\n\r\n    function getUnionIdByAddress(address _address) external view returns (bytes32);\r\n\r\n    function isFreeze(bytes32 _unionID, bytes32 _worksID) external view returns (bool);\r\n\r\n    function getFirstBuyNum(bytes32 _unionID, bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getSecondAmount(bytes32 _unionID, bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getFirstAmount(bytes32 _unionID, bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getLastAddress(bytes32 _unionID) external view returns (address payable);\r\n\r\n    function getRewardAmount(bytes32 _unionID, bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getFreezeHourglass(bytes32 _unionID, bytes32 _worksID) external view returns (uint256);\r\n\r\n    function getMyReport(bytes32 _unionID, bytes32 _worksID) external view returns (uint256, uint256, uint256);\r\n\r\n    function getMyStatus(bytes32 _unionID, bytes32 _worksID) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n\r\n    function getMyWorks(bytes32 _unionID, bytes32 _worksID) external view returns (address, bytes32, uint256, uint256, uint256);\r\n\r\n    function isLegalPlayer(bytes32 _unionID, address _address) external view returns (bool);\r\n\r\n    function register(bytes32 _unionID, address _address, bytes32 _worksID, bytes32 _referrer) external returns (bool);\r\n\r\n    function updateLastAddress(bytes32 _unionID, address payable _sender) external;\r\n\r\n    function updateLastTime(bytes32 _unionID, bytes32 _worksID) external;\r\n\r\n    function updateFirstBuyNum(bytes32 _unionID, bytes32 _worksID) external;\r\n\r\n    function updateSecondAmount(bytes32 _unionID, bytes32 _worksID, uint256 _amount) external;\r\n\r\n    function updateFirstAmount(bytes32 _unionID, bytes32 _worksID, uint256 _amount) external;\r\n\r\n    function updateRewardAmount(bytes32 _unionID, bytes32 _worksID, uint256 _amount) external;\r\n\r\n    function updateMyWorks(\r\n        bytes32 _unionID, \r\n        address _address, \r\n        bytes32 _worksID, \r\n        uint256 _totalInput, \r\n        uint256 _totalOutput\r\n    ) external;\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nlibrary Datasets {\r\n\r\n    struct Player {\r\n        address[] ethAddress; \r\n        bytes32 referrer; \r\n        address payable lastAddress; \r\n        uint256 time;\r\n    }\r\n\r\n    struct MyWorks { \r\n        address ethAddress; \r\n        bytes32 worksID; \r\n        uint256 totalInput; \r\n        uint256 totalOutput; \r\n        uint256 time; \r\n    }\r\n\r\n\r\n    struct Works {\r\n        bytes32 worksID; \r\n        bytes32 artistID; \r\n        uint8 debrisNum; \r\n        uint256 price; \r\n        uint256 beginTime; \r\n        uint256 endTime;\r\n        bool isPublish; \r\n        bytes32 lastUnionID;\r\n    }\r\n\r\n    struct Debris {\r\n        uint8 debrisID; \r\n        bytes32 worksID; \r\n        uint256 initPrice; \r\n        uint256 lastPrice; \r\n        uint256 buyNum; \r\n        address payable firstBuyer; \r\n        address payable lastBuyer; \r\n        bytes32 firstUnionID; \r\n        bytes32 lastUnionID; \r\n        uint256 lastTime; \r\n    }\r\n    \r\n    struct Rule {       \r\n        uint8 firstBuyLimit; \r\n        uint256 freezeGap; \r\n        uint256 protectGap; \r\n        uint256 increaseRatio;\r\n        uint256 discountGap; \r\n        uint256 discountRatio; \r\n\r\n        uint8[3] firstAllot; \r\n        uint8[3] againAllot;\r\n        uint8[3] lastAllot; \r\n    }\r\n\r\n    struct PlayerCount {\r\n        uint256 lastTime; \r\n        uint256 firstBuyNum; \r\n        uint256 firstAmount; \r\n        uint256 secondAmount; \r\n        uint256 rewardAmount;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title PuzzleBID Game Main Contract\r\n * @dev http://www.puzzlebid.com/\r\n * @author PuzzleBID Game Team \r\n * @dev Simon<vsiryxm@163.com>\r\n */\r\ncontract PuzzleBID {\r\n\r\n    using SafeMath for *;\r\n\r\n    string constant public name = \"PuzzleBID Game\";\r\n    string constant public symbol = \"PZB\";\r\n\r\n    TeamInterface private team; \r\n    PlatformInterface private platform; \r\n    ArtistInterface private artist; \r\n    WorksInterface private works; \r\n    PlayerInterface private player; \r\n    \r\n    constructor(\r\n        address _teamAddress,\r\n        address _platformAddress,\r\n        address _artistAddress,\r\n        address _worksAddress,\r\n        address _playerAddress\r\n    ) public {\r\n        require(\r\n            _teamAddress != address(0) &&\r\n            _platformAddress != address(0) &&\r\n            _artistAddress != address(0) &&\r\n            _worksAddress != address(0) &&\r\n            _playerAddress != address(0)\r\n        );\r\n        team = TeamInterface(_teamAddress);\r\n        platform = PlatformInterface(_platformAddress);\r\n        artist = ArtistInterface(_artistAddress);\r\n        works = WorksInterface(_worksAddress);\r\n        player = PlayerInterface(_playerAddress);\r\n    }  \r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    event OnUpgrade(\r\n        address indexed _teamAddress,\r\n        address indexed _platformAddress,\r\n        address indexed _artistAddress,\r\n        address _worksAddress,\r\n        address _playerAddress\r\n    );\r\n\r\n    modifier isHuman() {\r\n        address _address = msg.sender;\r\n        uint256 _size;\r\n\r\n        assembly {_size := extcodesize(_address)}\r\n        require(_size == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier checkPlay(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID) {\r\n        require(msg.value > 0);\r\n\r\n        require(works.hasWorks(_worksID)); \r\n        require(works.hasDebris(_worksID, _debrisID)); \r\n        require(works.isGameOver(_worksID) == false);\r\n        require(works.isPublish(_worksID) && works.isStart(_worksID));\r\n        require(works.isProtect(_worksID, _debrisID) == false);\r\n         \r\n        require(player.isFreeze(_unionID, _worksID) == false); \r\n        if(player.getFirstBuyNum(_unionID, _worksID).add(1) > works.getFirstBuyLimit(_worksID)) {\r\n            require(works.isSecond(_worksID, _debrisID));\r\n        }      \r\n        require(msg.value >= works.getDebrisPrice(_worksID, _debrisID));\r\n        _;\r\n    } \r\n       \r\n    modifier onlyAdmin() {\r\n        require(team.isAdmin(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    function upgrade(\r\n        address _teamAddress,\r\n        address _platformAddress,\r\n        address _artistAddress,\r\n        address _worksAddress,\r\n        address _playerAddress\r\n    ) external onlyAdmin() {\r\n        require(\r\n            _teamAddress != address(0) &&\r\n            _platformAddress != address(0) &&\r\n            _artistAddress != address(0) &&\r\n            _worksAddress != address(0) &&\r\n            _playerAddress != address(0)\r\n        );\r\n        team = TeamInterface(_teamAddress);\r\n        platform = PlatformInterface(_platformAddress);\r\n        artist = ArtistInterface(_artistAddress);\r\n        works = WorksInterface(_worksAddress);\r\n        player = PlayerInterface(_playerAddress);\r\n        emit OnUpgrade(_teamAddress, _platformAddress, _artistAddress, _worksAddress, _playerAddress);\r\n    }   \r\n\r\n    function startPlay(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, bytes32 _referrer) \r\n        isHuman()\r\n        checkPlay(_worksID, _debrisID, _unionID)\r\n        external\r\n        payable\r\n    {\r\n        player.register(_unionID, msg.sender, _worksID, _referrer); \r\n\r\n        uint256 lastPrice = works.getLastPrice(_worksID, _debrisID);\r\n\r\n        bytes32 lastUnionID = works.getLastUnionId(_worksID, _debrisID);\r\n\r\n        works.updateDebris(_worksID, _debrisID, _unionID, msg.sender); \r\n\r\n        player.updateLastTime(_unionID, _worksID); \r\n        \r\n        platform.updateTurnover(_worksID, msg.value); \r\n\r\n        platform.updateAllTurnover(msg.value); \r\n        \r\n        if(works.isSecond(_worksID, _debrisID)) {\r\n            secondPlay(_worksID, _debrisID, _unionID, lastUnionID, lastPrice);            \r\n        } else {\r\n            works.updateBuyNum(_worksID, _debrisID);\r\n            firstPlay(_worksID, _debrisID, _unionID);       \r\n        }\r\n\r\n        if(works.isFinish(_worksID, _unionID)) {\r\n            works.finish(_worksID, _unionID); \r\n            finishGame(_worksID);\r\n            collectWorks(_worksID, _unionID); \r\n        }\r\n\r\n    }\r\n\r\n    function firstPlay(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID) private {    \r\n        works.updateFirstBuyer(_worksID, _debrisID, _unionID, msg.sender);    \r\n        player.updateFirstBuyNum(_unionID, _worksID); \r\n        player.updateFirstAmount(_unionID, _worksID, msg.value); \r\n\r\n        uint8[3] memory firstAllot = works.getAllot(_worksID, 0); \r\n        artist.getAddress(works.getArtistId(_worksID)).transfer(msg.value.mul(firstAllot[0]) / 100); \r\n        platform.getFoundAddress().transfer(msg.value.mul(firstAllot[1]) / 100); \r\n\r\n        works.updatePools(_worksID, msg.value.mul(firstAllot[2]) / 100); \r\n        platform.deposit.value(msg.value.mul(firstAllot[2]) / 100)(_worksID); \r\n\r\n    }\r\n\r\n    function secondPlay(bytes32 _worksID, uint8 _debrisID, bytes32 _unionID, bytes32 _oldUnionID, uint256 _oldPrice) private {\r\n\r\n        if(0 == player.getSecondAmount(_unionID, _worksID)) {\r\n            works.updateSecondUnionIds(_worksID, _unionID);\r\n        }\r\n\r\n        player.updateSecondAmount(_unionID, _worksID, msg.value);\r\n\r\n        uint8[3] memory againAllot = works.getAllot(_worksID, 1);\r\n        uint256 lastPrice = works.getLastPrice(_worksID, _debrisID); \r\n        uint256 commission = lastPrice.mul(againAllot[1]) / 100;\r\n        platform.getFoundAddress().transfer(commission); \r\n\r\n        lastPrice = lastPrice.sub(commission); \r\n\r\n        if(lastPrice > _oldPrice) {\r\n            uint256 overflow = lastPrice.sub(_oldPrice); \r\n            artist.getAddress(works.getArtistId(_worksID)).transfer(overflow.mul(againAllot[0]) / 100); \r\n            works.updatePools(_worksID, overflow.mul(againAllot[2]) / 100); \r\n            platform.deposit.value(overflow.mul(againAllot[2]) / 100)(_worksID); \r\n            player.getLastAddress(_oldUnionID).transfer(\r\n                lastPrice.sub(overflow.mul(againAllot[0]) / 100)                \r\n                .sub(overflow.mul(againAllot[2]) / 100)\r\n            ); \r\n        } else { \r\n            player.getLastAddress(_oldUnionID).transfer(lastPrice);\r\n        }\r\n\r\n    }\r\n\r\n    function finishGame(bytes32 _worksID) private {              \r\n        uint8 lastAllot = works.getAllot(_worksID, 2, 0);\r\n        platform.transferTo(msg.sender, works.getPools(_worksID).mul(lastAllot) / 100);\r\n        firstSend(_worksID); \r\n        secondSend(_worksID); \r\n    }\r\n\r\n    function collectWorks(bytes32 _worksID, bytes32 _unionID) private {\r\n        player.updateMyWorks(_unionID, msg.sender, _worksID, 0, 0);\r\n    }\r\n    \r\n    function firstSend(bytes32 _worksID) private {\r\n        uint8 i;\r\n        bytes32[] memory tmpFirstUnionId = works.getFirstUnionIds(_worksID); \r\n        address tmpAddress; \r\n        uint256 tmpAmount;\r\n        uint8 lastAllot = works.getAllot(_worksID, 2, 1);\r\n        for(i=0; i<tmpFirstUnionId.length; i++) {\r\n            tmpAddress = player.getLastAddress(tmpFirstUnionId[i]);\r\n            tmpAmount = player.getFirstAmount(tmpFirstUnionId[i], _worksID);\r\n            tmpAmount = works.getPools(_worksID).mul(lastAllot).mul(tmpAmount) / 100 / works.getPrice(_worksID);\r\n            platform.transferTo(tmpAddress, tmpAmount); \r\n        }\r\n    }\r\n\r\n    function secondSend(bytes32 _worksID) private {\r\n        uint8 i;\r\n        bytes32[] memory tmpSecondUnionId = works.getSecondUnionIds(_worksID); \r\n        address tmpAddress; \r\n        uint256 tmpAmount;\r\n        uint8 lastAllot = works.getAllot(_worksID, 2, 2);\r\n        for(i=0; i<tmpSecondUnionId.length; i++) {\r\n            tmpAddress = player.getLastAddress(tmpSecondUnionId[i]);\r\n            tmpAmount = player.getSecondAmount(tmpSecondUnionId[i], _worksID);\r\n            tmpAmount = works.getPools(_worksID).mul(lastAllot).mul(tmpAmount) / 100 / (platform.getTurnover(_worksID).sub(works.getPrice(_worksID)));\r\n            platform.transferTo(tmpAddress, tmpAmount); \r\n        }\r\n    }\r\n\r\n    function getNowTime() external view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamAddress\",\"type\":\"address\"},{\"name\":\"_platformAddress\",\"type\":\"address\"},{\"name\":\"_artistAddress\",\"type\":\"address\"},{\"name\":\"_worksAddress\",\"type\":\"address\"},{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_worksID\",\"type\":\"bytes32\"},{\"name\":\"_debrisID\",\"type\":\"uint8\"},{\"name\":\"_unionID\",\"type\":\"bytes32\"},{\"name\":\"_referrer\",\"type\":\"bytes32\"}],\"name\":\"startPlay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNowTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_teamAddress\",\"type\":\"address\"},{\"name\":\"_platformAddress\",\"type\":\"address\"},{\"name\":\"_artistAddress\",\"type\":\"address\"},{\"name\":\"_worksAddress\",\"type\":\"address\"},{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_teamAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_platformAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_artistAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_worksAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"OnUpgrade\",\"type\":\"event\"}]","ContractName":"PuzzleBID","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000092b3be4b8ca3b4faaaf9d08ab9a8329465c1bdcc00000000000000000000000039fb2aad8f46debbcc586169def2500b0cb73ed2000000000000000000000000e789854ebe399b3b2c6c987f328904700fef926f000000000000000000000000c8e5cf09be2483b5486a9b30bca40e00bff685ba000000000000000000000000df1df98305b058d1cfb5978c1884550736a6709e","Library":"","SwarmSource":"bzzr://cf32f27f016549b94cb4f3aa8986cf410728077b9fb1aeeb2fd1ed4725559d35"}]}