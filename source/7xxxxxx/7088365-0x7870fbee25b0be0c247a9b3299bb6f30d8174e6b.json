{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\nlibrary ERC20SafeTransfer {\r\n    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, _to, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"approve(address,uint256)\")), _spender, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function fetchReturnData() internal returns (bool success){\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 {\r\n                success := 1\r\n            }\r\n            case 32 {\r\n                returndatacopy(0, 0, 32)\r\n                success := mload(0)\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/// @title A contract which is used to check and set allowances of tokens\r\n/// @dev In order to use this contract is must be inherited in the contract which is using\r\n/// its functionality\r\ncontract AllowanceSetter {\r\n    uint256 constant MAX_UINT = 2**256 - 1;\r\n\r\n    /// @notice A function which allows the caller to approve the max amount of any given token\r\n    /// @dev In order to function correctly, token allowances should not be set anywhere else in\r\n    /// the inheriting contract\r\n    /// @param addressToApprove the address which we want to approve to transfer the token\r\n    /// @param token the token address which we want to call approve on\r\n    function approveAddress(address addressToApprove, address token) internal {\r\n        if(ERC20(token).allowance(address(this), addressToApprove) == 0) {\r\n            require(ERC20SafeTransfer.safeApprove(token, addressToApprove, MAX_UINT));\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract ErrorReporter {\r\n    function revertTx(string reason) public pure {\r\n        revert(reason);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/// @title A contract which can be used to ensure only the TotlePrimary contract can call\r\n/// some functions\r\n/// @dev Defines a modifier which should be used when only the totle contract should\r\n/// able able to call a function\r\ncontract TotleControl is Ownable {\r\n    mapping(address => bool) public authorizedPrimaries;\r\n\r\n    /// @dev A modifier which only allows code execution if msg.sender equals totlePrimary address\r\n    modifier onlyTotle() {\r\n        require(authorizedPrimaries[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /// @notice Contract constructor\r\n    /// @dev As this contract inherits ownable, msg.sender will become the contract owner\r\n    /// @param _totlePrimary the address of the contract to be set as totlePrimary\r\n    constructor(address _totlePrimary) public {\r\n        authorizedPrimaries[_totlePrimary] = true;\r\n    }\r\n\r\n    /// @notice A function which allows only the owner to change the address of totlePrimary\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _totlePrimary the address of the contract to be set as totlePrimary\r\n    function addTotle(\r\n        address _totlePrimary\r\n    ) external onlyOwner {\r\n        authorizedPrimaries[_totlePrimary] = true;\r\n    }\r\n\r\n    function removeTotle(\r\n        address _totlePrimary\r\n    ) external onlyOwner {\r\n        authorizedPrimaries[_totlePrimary] = false;\r\n    }\r\n}\r\n\r\n/// @title A contract which allows its owner to withdraw any ether which is contained inside\r\ncontract Withdrawable is Ownable {\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _token The address of the token that the user wants to withdraw\r\n    /// @param _amount The amount of tokens that the caller wants to withdraw\r\n    /// @return bool value indicating whether the transfer was successful\r\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\r\n        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\r\n    }\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _amount The amount of ether that the caller wants to withdraw\r\n    function withdrawETH(uint256 _amount) external onlyOwner {\r\n        owner.transfer(_amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"Contract is paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Contract not paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\ncontract SelectorProvider {\r\n    bytes4 constant getAmountToGiveSelector = bytes4(keccak256(\"getAmountToGive(bytes)\"));\r\n    bytes4 constant staticExchangeChecksSelector = bytes4(keccak256(\"staticExchangeChecks(bytes)\"));\r\n    bytes4 constant performBuyOrderSelector = bytes4(keccak256(\"performBuyOrder(bytes,uint256)\"));\r\n    bytes4 constant performSellOrderSelector = bytes4(keccak256(\"performSellOrder(bytes,uint256)\"));\r\n\r\n    function getSelector(bytes4 genericSelector) public pure returns (bytes4);\r\n}\r\n\r\n/// @title Interface for all exchange handler contracts\r\ncontract ExchangeHandler is SelectorProvider, TotleControl, Withdrawable, Pausable {\r\n\r\n    /*\r\n    *   State Variables\r\n    */\r\n\r\n    ErrorReporter public errorReporter;\r\n    /* Logger public logger; */\r\n    /*\r\n    *   Modifiers\r\n    */\r\n\r\n    /// @notice Constructor\r\n    /// @dev Calls the constructor of the inherited TotleControl\r\n    /// @param totlePrimary the address of the totlePrimary contract\r\n    constructor(\r\n        address totlePrimary,\r\n        address _errorReporter\r\n        /* ,address _logger */\r\n    )\r\n        TotleControl(totlePrimary)\r\n        public\r\n    {\r\n        require(_errorReporter != address(0x0));\r\n        /* require(_logger != address(0x0)); */\r\n        errorReporter = ErrorReporter(_errorReporter);\r\n        /* logger = Logger(_logger); */\r\n    }\r\n\r\n    /// @notice Gets the amount that Totle needs to give for this order\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @return amountToGive amount taker needs to give in order to fill the order\r\n    function getAmountToGive(\r\n        bytes genericPayload\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 amountToGive)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.getAmountToGive.selector);\r\n\r\n        assembly {\r\n            let functionSelectorLength := 0x04\r\n            let functionSelectorOffset := 0x1C\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let bytesLength := mload(genericPayload)\r\n            let totalLength := add(functionSelectorLength, bytesLength)\r\n            let startOfNewData := add(genericPayload, functionSelectorOffset)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n            mstore(genericPayload, functionSelectorCorrect)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            wordLength // Length of return variable is one word\r\n                           )\r\n            amountToGive := mload(scratchSpace)\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform exchange-specific checks on the given order\r\n    /// @dev this should be called to check for payload errors\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @return checksPassed value representing pass or fail\r\n    function staticExchangeChecks(\r\n        bytes genericPayload\r\n    )\r\n        public\r\n        view\r\n        returns (bool checksPassed)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.staticExchangeChecks.selector);\r\n        assembly {\r\n            let functionSelectorLength := 0x04\r\n            let functionSelectorOffset := 0x1C\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let bytesLength := mload(genericPayload)\r\n            let totalLength := add(functionSelectorLength, bytesLength)\r\n            let startOfNewData := add(genericPayload, functionSelectorOffset)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n            mstore(genericPayload, functionSelectorCorrect)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            wordLength // Length of return variable is one word\r\n                           )\r\n            checksPassed := mload(scratchSpace)\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a buy order at the exchange\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performBuyOrder(\r\n        bytes genericPayload,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.performBuyOrder.selector);\r\n        assembly {\r\n            let callDataOffset := 0x44\r\n            let functionSelectorOffset := 0x1C\r\n            let functionSelectorLength := 0x04\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let startOfFreeMemory := mload(0x40)\r\n\r\n            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\r\n\r\n            let bytesLength := mload(startOfFreeMemory)\r\n            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n\r\n            mstore(startOfFreeMemory, functionSelectorCorrect)\r\n\r\n            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\r\n\r\n            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            mul(wordLength, 0x02) // Length of return variables is two words\r\n                          )\r\n            amountSpentOnOrder := mload(scratchSpace)\r\n            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a sell order at the exchange\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performSellOrder(\r\n        bytes genericPayload,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.performSellOrder.selector);\r\n        assembly {\r\n            let callDataOffset := 0x44\r\n            let functionSelectorOffset := 0x1C\r\n            let functionSelectorLength := 0x04\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let startOfFreeMemory := mload(0x40)\r\n\r\n            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\r\n\r\n            let bytesLength := mload(startOfFreeMemory)\r\n            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n\r\n            mstore(startOfFreeMemory, functionSelectorCorrect)\r\n\r\n            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\r\n\r\n            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            mul(wordLength, 0x02) // Length of return variables is two words\r\n                          )\r\n            amountSpentOnOrder := mload(scratchSpace)\r\n            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title BancorConverter\r\n/// @notice Bancor converter contract interface\r\ninterface BancorConverter {\r\n    function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn) external payable returns (uint256);\r\n    function registry() external view returns (IContractRegistry);\r\n    function BANCOR_GAS_PRICE_LIMIT() external view returns (bytes32);\r\n    function BANCOR_NETWORK() external view returns (bytes32);\r\n}\r\n\r\n/// @title IContractRegistry\r\n/// @notice Bancor contract registry interface\r\ninterface IContractRegistry {\r\n    function getAddress(bytes32 _contractName) external view returns (address);\r\n}\r\n\r\n/// @title IBancorGasPriceLimit\r\n/// @notice Bancor gas price limit contract interface\r\ninterface IBancorGasPriceLimit {\r\n    function gasPrice() external view returns (uint256);\r\n}\r\n\r\n/// @title BancorNetwork\r\n/// @notice Bancor Network contract interface\r\ninterface BancorNetwork {\r\n    function getReturnByPath(address[] _path, uint256 _amount) external view returns (uint256) ;\r\n}\r\n\r\n/// @title Interface for all exchange handler contracts\r\n/// @notice Handles the all Bancor trades for the primary contract\r\ncontract BancorHandler is ExchangeHandler, AllowanceSetter {\r\n\r\n    /*\r\n    *   Types\r\n    */\r\n\r\n    struct OrderData {\r\n        address converterAddress;\r\n        address[11] conversionPath;\r\n        address destinationToken;\r\n        uint256 minReturn;\r\n        uint256 amountToGive;\r\n        uint256 expectedReturn;\r\n    }\r\n\r\n    /// @notice Constructor\r\n    /// @param totlePrimary the address of the totlePrimary contract\r\n    /// @param errorReporter the address of the error reporter contract\r\n    constructor(\r\n        address totlePrimary,\r\n        address errorReporter\r\n        /* ,address logger */\r\n    )\r\n        ExchangeHandler(totlePrimary, errorReporter/*, logger*/)\r\n        public\r\n    {}\r\n\r\n    /*\r\n    *   Public functions\r\n    */\r\n\r\n    /// @notice Gets the amount that Totle needs to give for this order\r\n    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\r\n    /// should only be called from functions which are inherited from the ExchangeHandler\r\n    /// base contract.\r\n    /// Uses `whenNotPaused` modifier to revert transactions when contract is \"paused\".\r\n    /// @param data OrderData struct containing order values\r\n    /// @return amountToGive amount taker needs to give in order to fill the order\r\n    function getAmountToGive(\r\n        OrderData data\r\n    )\r\n        public\r\n        view\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (uint256 amountToGive)\r\n    {\r\n        amountToGive = data.amountToGive;\r\n    }\r\n\r\n    /// @notice Perform exchange-specific checks on the given order\r\n    /// @dev This function should be called to check for payload errors.\r\n    /// Uses the `onlyTotle` modifier with public visibility as this function\r\n    /// should only be called from functions which are inherited from the ExchangeHandler\r\n    /// base contract.\r\n    /// Uses `whenNotPaused` modifier to revert transactions when contract is \"paused\".\r\n    /// @param data OrderData struct containing order values\r\n    /// @return checksPassed value representing pass or fail\r\n    function staticExchangeChecks(\r\n        OrderData data\r\n    )\r\n        public\r\n        view\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (bool checksPassed)\r\n    {\r\n        BancorConverter converter = BancorConverter(data.converterAddress);\r\n        IBancorGasPriceLimit gasPriceLimitContract = IBancorGasPriceLimit(\r\n            converter.registry().getAddress(converter.BANCOR_GAS_PRICE_LIMIT())\r\n        );\r\n\r\n        uint256 gasPriceLimit = gasPriceLimitContract.gasPrice();\r\n        checksPassed = tx.gasprice <= gasPriceLimit;\r\n\r\n        /* logger.log(\r\n            \"Checking gas price arg2: tx.gasprice, arg3: gasPriceLimit\",\r\n            tx.gasprice,\r\n            gasPriceLimit\r\n        ); */\r\n    }\r\n\r\n    /// @notice Perform a buy order at the exchange\r\n    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\r\n    /// should only be called from functions which are inherited from the ExchangeHandler\r\n    /// base contract.\r\n    /// Uses `whenNotPaused` modifier to revert transactions when contract is \"paused\".\r\n    /// @param data OrderData struct containing order values\r\n    /// @param amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performBuyOrder(\r\n        OrderData data,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        payable\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        amountSpentOnOrder = amountToGiveForOrder;\r\n        amountReceivedFromOrder = BancorConverter(data.converterAddress).quickConvert.value(msg.value)(\r\n            trimAddressArray(data.conversionPath),\r\n            amountToGiveForOrder,\r\n            data.minReturn\r\n        );\r\n\r\n        /* logger.log(\r\n            \"Performed Bancor buy arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder\",\r\n            amountSpentOnOrder,\r\n            amountReceivedFromOrder\r\n        ); */\r\n\r\n        if (!ERC20SafeTransfer.safeTransfer(data.destinationToken, msg.sender, amountReceivedFromOrder)){\r\n            errorReporter.revertTx(\"Failed to transfer tokens to totle primary\");\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a sell order at the exchange\r\n    /// @dev Uses the `onlyTotle` modifier with public visibility as this function\r\n    /// should only be called from functions which are inherited from the ExchangeHandler\r\n    /// base contract\r\n    /// Uses `whenNotPaused` modifier to revert transactions when contract is \"paused\".\r\n    /// @param data OrderData struct containing order values\r\n    /// @param amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performSellOrder(\r\n        OrderData data,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        approveAddress(data.converterAddress, data.conversionPath[0]);\r\n\r\n        amountSpentOnOrder = amountToGiveForOrder;\r\n        amountReceivedFromOrder = BancorConverter(data.converterAddress).quickConvert(\r\n            trimAddressArray(data.conversionPath),\r\n            amountToGiveForOrder,\r\n            data.minReturn\r\n        );\r\n\r\n        /* logger.log(\r\n            \"Performed Bancor sell arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder\",\r\n            amountSpentOnOrder,\r\n            amountReceivedFromOrder\r\n        ); */\r\n\r\n        msg.sender.transfer(amountReceivedFromOrder);\r\n    }\r\n\r\n    /// @notice Calculate the result of ((numerator * target) / denominator)\r\n    /// @param numerator the numerator in the equation\r\n    /// @param denominator the denominator in the equation\r\n    /// @param target the target for the equations\r\n    /// @return partialAmount the resultant value\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\r\n    }\r\n\r\n    /// @notice Takes the static array, trims the excess and returns a dynamic array\r\n    /// @param addresses the static array\r\n    /// @return address[] the dynamic array\r\n    function trimAddressArray(address[11] addresses) internal pure returns (address[]) {\r\n        uint256 length = 0;\r\n        for (uint256 index = 0; index < 11; index++){\r\n            if (addresses[index] == 0x0){\r\n                continue;\r\n            }\r\n            length++;\r\n        }\r\n        address[] memory trimmedArray = new address[](length);\r\n        for (index = 0; index < length; index++){\r\n            trimmedArray[index] = addresses[index];\r\n        }\r\n        return trimmedArray;\r\n    }\r\n\r\n    function getSelector(bytes4 genericSelector) public pure returns (bytes4) {\r\n        if (genericSelector == getAmountToGiveSelector) {\r\n            return bytes4(keccak256(\"getAmountToGive((address,address[11],address,uint256,uint256,uint256))\"));\r\n        } else if (genericSelector == staticExchangeChecksSelector) {\r\n            return bytes4(keccak256(\"staticExchangeChecks((address,address[11],address,uint256,uint256,uint256))\"));\r\n        } else if (genericSelector == performBuyOrderSelector) {\r\n            return bytes4(keccak256(\"performBuyOrder((address,address[11],address,uint256,uint256,uint256),uint256)\"));\r\n        } else if (genericSelector == performSellOrderSelector) {\r\n            return bytes4(keccak256(\"performSellOrder((address,address[11],address,uint256,uint256,uint256),uint256)\"));\r\n        } else {\r\n            return bytes4(0x0);\r\n        }\r\n    }\r\n\r\n    /*\r\n    *   Payable fallback function\r\n    */\r\n\r\n    /// @notice payable fallback to allow handler or exchange contracts to return ether\r\n    /// @dev only accounts containing code (ie. contracts) can send ether to this contract\r\n    function() public payable whenNotPaused {\r\n        // Check in here that the sender is a contract! (to stop accidents)\r\n        uint256 size;\r\n        address sender = msg.sender;\r\n        assembly {\r\n            size := extcodesize(sender)\r\n        }\r\n        if (size == 0) {\r\n            errorReporter.revertTx(\"EOA cannot send ether to primary fallback\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"errorReporter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totlePrimary\",\"type\":\"address\"}],\"name\":\"addTotle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"converterAddress\",\"type\":\"address\"},{\"name\":\"conversionPath\",\"type\":\"address[11]\"},{\"name\":\"destinationToken\",\"type\":\"address\"},{\"name\":\"minReturn\",\"type\":\"uint256\"},{\"name\":\"amountToGive\",\"type\":\"uint256\"},{\"name\":\"expectedReturn\",\"type\":\"uint256\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getAmountToGive\",\"outputs\":[{\"name\":\"amountToGive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performSellOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"converterAddress\",\"type\":\"address\"},{\"name\":\"conversionPath\",\"type\":\"address[11]\"},{\"name\":\"destinationToken\",\"type\":\"address\"},{\"name\":\"minReturn\",\"type\":\"uint256\"},{\"name\":\"amountToGive\",\"type\":\"uint256\"},{\"name\":\"expectedReturn\",\"type\":\"uint256\"}],\"name\":\"data\",\"type\":\"tuple\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performSellOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totlePrimary\",\"type\":\"address\"}],\"name\":\"removeTotle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"converterAddress\",\"type\":\"address\"},{\"name\":\"conversionPath\",\"type\":\"address[11]\"},{\"name\":\"destinationToken\",\"type\":\"address\"},{\"name\":\"minReturn\",\"type\":\"uint256\"},{\"name\":\"amountToGive\",\"type\":\"uint256\"},{\"name\":\"expectedReturn\",\"type\":\"uint256\"}],\"name\":\"data\",\"type\":\"tuple\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performBuyOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"}],\"name\":\"getAmountToGive\",\"outputs\":[{\"name\":\"amountToGive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"}],\"name\":\"staticExchangeChecks\",\"outputs\":[{\"name\":\"checksPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedPrimaries\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performBuyOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericSelector\",\"type\":\"bytes4\"}],\"name\":\"getSelector\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"converterAddress\",\"type\":\"address\"},{\"name\":\"conversionPath\",\"type\":\"address[11]\"},{\"name\":\"destinationToken\",\"type\":\"address\"},{\"name\":\"minReturn\",\"type\":\"uint256\"},{\"name\":\"amountToGive\",\"type\":\"uint256\"},{\"name\":\"expectedReturn\",\"type\":\"uint256\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"staticExchangeChecks\",\"outputs\":[{\"name\":\"checksPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"totlePrimary\",\"type\":\"address\"},{\"name\":\"errorReporter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BancorHandler","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"00000000000000000000000099eca38b58ceeaf0fed5351df21d5b4c5599531400000000000000000000000076b87390400359941561956632bbbe3f42439e32","Library":"","SwarmSource":"bzzr://2fdb5fa77c2444445c13b625dfea7e2c6168bb4f4c21ce1796ac0533b312f4fa"}]}