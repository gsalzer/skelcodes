{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n// File: openzeppelin-solidity\\contracts\\math\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\Donations.sol\r\n\r\ncontract ERC20Interface {\r\n    function balanceOf(address _owner) external returns (uint256);\r\n    function transfer(address _to, uint256 _value) external;\r\n}\r\n\r\ncontract Donations {\r\n    using SafeMath for uint256;\r\n\r\n    struct Knight\r\n    {\r\n        address ethAddress;\r\n        ///@dev amount in % of ETH and HORSE to distribute from this contract\r\n        uint256 equity;\r\n    }\r\n\r\n    /// @dev list of all knights by name\r\n    mapping(string => Knight) knights;\r\n\r\n    /// @dev handle to access HORSE token contract to make transfers\r\n    ERC20Interface constant horseToken = ERC20Interface(0x5B0751713b2527d7f002c0c4e2a37e1219610A6B);\r\n\r\n    ///@dev true for HORSE, false for ETH\r\n    mapping(bool => uint256) private _toDistribute;\r\n    ///@dev true for HORSE, false for ETH\r\n    mapping(bool => mapping(address => uint256)) private _balances;\r\n\r\n    /// @dev helpers to make code look better\r\n    bool constant ETH = false;\r\n    bool constant HORSE = true;\r\n   \r\n    /**\r\n        @dev Initialize the contract with the correct knights and their equities and addresses\r\n        All spoils are to be shared by Five Knights, the distribution of which is decided by God almighty\r\n    */\r\n    constructor() public {\r\n        knights[\"Safir\"].equity = 27;\r\n        knights[\"Safir\"].ethAddress = 0x61F646be9E40F3C83Ae6C74e8b33f2708396D08C;\r\n        knights[\"Lucan\"].equity = 27;\r\n        knights[\"Lucan\"].ethAddress = 0x445D779acfE04C717cc6B0071D3713D7E405Dc99;\r\n        knights[\"Lancelot\"].equity = 27;\r\n        knights[\"Lancelot\"].ethAddress = 0x5873d3875274753f6680a2256aCb02F2e42Be1A6;\r\n        knights[\"Hoel\"].equity = 11;\r\n        knights[\"Hoel\"].ethAddress = 0x85a4F876A007649048a7D44470ec1d328895B8bb;\r\n        knights[\"YwainTheBastard\"].equity = 8;\r\n        knights[\"YwainTheBastard\"].ethAddress = 0x2AB8D865Db8b9455F4a77C70B9D8d953E314De28;\r\n    }\r\n    \r\n    /**\r\n        @dev The empty fallback function allows for ETH payments on this contract\r\n    */\r\n    function () external payable {\r\n       //fallback function just accept the funds\r\n    }\r\n    \r\n    /**\r\n        @dev Called by anyone willing to pay the fees for the distribution computation and withdrawal of HIS due\r\n        This checks for changes in the amounts of ETH and HORSE owned by the contract and updates the balances\r\n        of all knights acordingly\r\n    */\r\n    function withdraw() external {\r\n        //update the balances of all knights\r\n        _distribute(ETH);\r\n        _distribute(HORSE);\r\n\r\n        // check how much the caller is due of HORSE and ETH\r\n        uint256 toSendHORSE = _balances[HORSE][msg.sender];\r\n        uint256 toSendETH = _balances[ETH][msg.sender];\r\n\r\n        //if the caller is due HORSE, send it to him\r\n        if(toSendHORSE > 0) {\r\n            _balances[HORSE][msg.sender] = 0;\r\n            horseToken.transfer.gas(40000)(msg.sender,toSendHORSE);\r\n        }\r\n\r\n        //if the caller is due ETH, send it to him\r\n        if(toSendETH > 0) {\r\n            _balances[ETH][msg.sender] = 0;\r\n            msg.sender.transfer(toSendETH);\r\n        }\r\n    }\r\n    \r\n    /**\r\n        @dev Allows a knight to check the amount of ETH and HORSE he can withdraw\r\n        !!! During withdraw call, the amount is updated before being sent to the knight, so these values may increase\r\n        @return (ETH balance, HORSE balance)\r\n    */\r\n    function checkBalance() external view returns (uint256,uint256) {\r\n        return (_balances[ETH][msg.sender],_balances[HORSE][msg.sender]);\r\n    }\r\n\r\n    /**\r\n        @dev Updates the amounts of ETH and HORSE to distribute\r\n        @param isHorse [false => ETH distribution, true => HORSE distribution]\r\n    */\r\n    function _update(bool isHorse) internal {\r\n        //get either ETH or HORSE balance\r\n        uint256 balance = isHorse ? horseToken.balanceOf.gas(40000)(address(this)) : address(this).balance;\r\n        //if there is something on the contract, compute the difference between knight balances and the contract total amount\r\n        if(balance > 0) {\r\n            _toDistribute[isHorse] = balance\r\n            .sub(_balances[isHorse][knights[\"Safir\"].ethAddress])\r\n            .sub(_balances[isHorse][knights[\"Lucan\"].ethAddress])\r\n            .sub(_balances[isHorse][knights[\"Lancelot\"].ethAddress])\r\n            .sub(_balances[isHorse][knights[\"YwainTheBastard\"].ethAddress])\r\n            .sub(_balances[isHorse][knights[\"Hoel\"].ethAddress]);\r\n\r\n            //if _toDistribute[isHorse] is 0, then there is nothing to update\r\n        } else {\r\n            //just to make sure, but can be removed\r\n            _toDistribute[isHorse] = 0;\r\n        }\r\n    }\r\n    \r\n    /**\r\n        @dev Handles distribution of non distributed ETH or HORSE\r\n        @param isHorse [false => ETH distribution, true => HORSE distribution]\r\n    */\r\n    function _distribute(bool isHorse) private {\r\n        //check the difference between current balances levels and the contracts levels\r\n        //this will provide the _toDistribute amount\r\n        _update(isHorse);\r\n        //if the contract balance is more than knights balances combined, we need a distribution\r\n        if(_toDistribute[isHorse] > 0) {\r\n            //we divide the amount to distribute by 100 to know how much each % represents\r\n            uint256 parts = _toDistribute[isHorse].div(100);\r\n            //the due of each knight is the % value * equity (27 equity = 27 * 1% => 27% of the amount to distribute)\r\n            uint256 dueSafir = knights[\"Safir\"].equity.mul(parts);\r\n            uint256 dueLucan = knights[\"Lucan\"].equity.mul(parts);\r\n            uint256 dueLancelot = knights[\"Lancelot\"].equity.mul(parts);\r\n            uint256 dueYwainTheBastard = knights[\"YwainTheBastard\"].equity.mul(parts);\r\n\r\n            //all balances are augmented by the computed due\r\n            _balances[isHorse][knights[\"Safir\"].ethAddress] = _balances[isHorse][knights[\"Safir\"].ethAddress].add(dueSafir);\r\n            _balances[isHorse][knights[\"Lucan\"].ethAddress] = _balances[isHorse][knights[\"Lucan\"].ethAddress].add(dueLucan);\r\n            _balances[isHorse][knights[\"Lancelot\"].ethAddress] = _balances[isHorse][knights[\"Lancelot\"].ethAddress].add(dueLancelot);\r\n            _balances[isHorse][knights[\"YwainTheBastard\"].ethAddress] = _balances[isHorse][knights[\"YwainTheBastard\"].ethAddress].add(dueYwainTheBastard);\r\n            //the 5th knight due is computed by substraction of the others to avoid dust error due to division\r\n            _balances[isHorse][knights[\"Hoel\"].ethAddress] = _balances[isHorse][knights[\"Hoel\"].ethAddress]\r\n            .add(_toDistribute[isHorse] - dueSafir - dueLucan - dueLancelot - dueYwainTheBastard);\r\n            \r\n            //the amount to distribute is set to zero\r\n            _toDistribute[isHorse] = 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Donations","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d1580cec11d572a8558c338f5a9b896ba4c09a92d206adf44b25291cf5f8df52"}]}