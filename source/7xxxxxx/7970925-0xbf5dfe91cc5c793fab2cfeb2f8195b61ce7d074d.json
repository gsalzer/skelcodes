{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Source Code first verified at https://etherscan.io on Thursday, May 2, 2019\r\n (UTC) */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// ProfitLineInc contract\r\ncontract Snowball  {\r\n    using SafeMath for uint;\r\n    uint256 public RID; //roundid\r\n    mapping (uint256 => mapping(address => info)) public round;\r\n    \r\n    mapping(address => uint256)public  playerId; \r\n    mapping(address => address)public  referalSticky;\r\n    mapping(uint256 => address)public  IdToAdress; \r\n    mapping(address => address)public  hustler;\r\n    uint256 public hustlerprice;\r\n    address public currentHustler;\r\n    uint256 public curatorPrice;\r\n    address public currentCurator;\r\n    uint256 public nextPlayerID;\r\n    \r\n    PlincInterface constant hub_ = PlincInterface(0xd5D10172e8D8B84AC83031c16fE093cba4c84FC6);\r\n    \r\n    struct info {\r\n        uint256 stake;\r\n        uint256 lastDividendPoints;\r\n        }\r\n    address self;\r\n    mapping(address => uint256)public  playerVault;\r\n    mapping(address => uint256)public  curatorVault;\r\n    mapping(address => uint256)public  hustlerVault;\r\n    // div setup for round\r\nuint256 public pointMultiplier = 10e18;\r\n    \r\n    mapping(uint256 => uint256) public price;\r\n    mapping(address => mapping(uint256 => uint256)) public lastActiveRound;\r\n    mapping(uint256 => address) public owner;\r\n    mapping(uint256 => uint256) public time;\r\n    uint256 public pot;\r\n    uint256 public curatorReward;\r\n    mapping(uint256 => uint256) public totalDividendPoints;\r\n    mapping(uint256 => uint256) public unclaimedDividends;\r\n    mapping(uint256 => uint256) public totalsupply;\r\n    \r\n    \r\n    function dividendsOwing(address target,uint256 roundid) public view returns(uint256) {\r\n        uint256 newDividendPoints = totalDividendPoints[roundid].sub(round[roundid][target].lastDividendPoints);\r\n        return (round[roundid][target].stake * newDividendPoints) / pointMultiplier;\r\n    }\r\n    function fetchdivs(address toUpdate, uint256 roundid) public updateAccount(toUpdate , roundid){}\r\n    \r\n    modifier updateAccount(address toUpdate , uint256 roundid) {\r\n        uint256 owing = dividendsOwing(toUpdate, roundid);\r\n        if(owing > 0) {\r\n            \r\n            unclaimedDividends[roundid] = unclaimedDividends[roundid].sub(owing);\r\n            playerVault[toUpdate] = playerVault[toUpdate].add(owing);\r\n        }\r\n       round[roundid][toUpdate].lastDividendPoints = totalDividendPoints[roundid];\r\n        _;\r\n        }\r\n    function () external payable{} // needs for divs\r\n    // events\r\n    event ballRolled(uint256 indexed round, address indexed player, uint256 indexed size);\r\n    event buddySold(uint256 indexed round, address indexed previousOwner, address indexed newOwner, uint256 price);\r\n    event collectorSold(uint256 indexed round, address indexed previousOwner, address indexed newOwner, uint256 price);\r\n    event cashout(uint256 indexed round, address indexed player , uint256 indexed ethAmount);\r\n    event endOfRound(uint256 indexed round, address player, uint256 size ,uint256 pot);\r\n    event ETHfail(address indexed player, uint256 indexed round,  uint256 sizeNeeded ,uint256 sizeSent);\r\n    // gameplay\r\n    function buyBall( address referral)updateAccount(msg.sender, RID)  payable public {\r\n        // update bonds first\r\n        uint256 values = msg.value;\r\n        address sender = msg.sender;\r\n        require(values > 0);\r\n        uint256 thisround = RID;\r\n        \r\n        if(referalSticky[sender] != 0x0){referral = referalSticky[sender];}\r\n        if(referalSticky[sender] == 0x0){referalSticky[sender] = referral;}\r\n        if(hustler[sender] == 0x0){hustler[sender] = currentHustler;}\r\n        // timer not expired.\r\n        uint256 base;\r\n        if(time[thisround] + 24 hours >= now){\r\n            // require enough $$ sent\r\n            if(values < price[thisround])\r\n            {\r\n                playerVault[sender] = playerVault[sender].add(values);\r\n                emit ETHfail(sender, thisround,price[thisround], values);\r\n            }\r\n            if(values >= price[thisround]){\r\n        // set base for calcs\r\n        base = price[thisround].div(100);\r\n        // buy plinchub bonds\r\n        hub_.buyBonds.value(price[thisround])(0xdc827558062AA1cc0e2AB28146DA9eeAC38A06D1) ;\r\n        // excess to playerbalance\r\n        if(values > price[thisround])\r\n        {\r\n            playerVault[msg.sender] = playerVault[msg.sender].add(values.sub(price[thisround]));\r\n        }\r\n        // pay to previous owner + 3% flip\r\n        playerVault[owner[thisround]] = playerVault[owner[thisround]].add(base.mul(103));\r\n        // adjust pot\r\n        pot = pot.add(base);\r\n        // set new owner\r\n        owner[thisround] = sender;\r\n        // update to new price\r\n        price[thisround] = base.mul(110);\r\n        // pay to previous owners\r\n        totalDividendPoints[thisround] = totalDividendPoints[thisround].add(base.mul(pointMultiplier).div(totalsupply[thisround]));\r\n        unclaimedDividends[thisround] = unclaimedDividends[thisround].add(base);\r\n        // pay to referral\r\n        playerVault[referalSticky[sender]] = playerVault[referalSticky[sender]].add(base);\r\n        // hustler reward\r\n        hustlerVault[hustler[sender]] = hustlerVault[hustler[sender]].add(base);\r\n        // update playerbook\r\n        if(playerId[sender] == 0){\r\n           playerId[sender] = nextPlayerID;\r\n           IdToAdress[nextPlayerID] = sender;\r\n           nextPlayerID++;\r\n            }\r\n        // add  to previous owners\r\n        round[thisround][sender].stake = round[thisround][sender].stake.add(1);\r\n        // update previous owners totalsupply\r\n        totalsupply[thisround] = totalsupply[thisround].add(1);\r\n        // update round timer\r\n        time[thisround] = now;\r\n        //update lastActiveRound\r\n        lastActiveRound[sender][thisround] = base.mul(100);\r\n       \r\n        emit ballRolled(thisround, sender,  values);\r\n            }\r\n    }\r\n    // timer expired\r\n        if(time[thisround] + 24 hours < now)\r\n            {\r\n                require(values >= 10 finney);\r\n                uint256 payout = pot.div(2);\r\n               emit endOfRound(thisround, owner[thisround], price[thisround] ,payout);\r\n            RID = thisround.add(1);\r\n            price[RID] = 10 finney;\r\n            owner[RID] = sender;\r\n            \r\n            base = price[thisround].div(100);\r\n        // buy plinc bonds\r\n        hub_.buyBonds.value(values)(0xdc827558062AA1cc0e2AB28146DA9eeAC38A06D1) ;\r\n        // pay to previous owner\r\n        playerVault[owner[thisround]] = playerVault[owner[thisround]].add(base.mul(100)).add(pot.div(2));\r\n        // adjust pot\r\n        pot = pot.div(2);\r\n        // update playerbook\r\n        if(playerId[sender] == 0){\r\n           playerId[sender] = nextPlayerID;\r\n           IdToAdress[nextPlayerID] = sender;\r\n           nextPlayerID++;\r\n           \r\n        }\r\n        \r\n        totalsupply[RID] = totalsupply[RID].add(1);\r\n        // update round timer\r\n        time[RID] = now;\r\n        emit ballRolled(RID, sender,  values);\r\n        }\r\n        \r\n    }\r\n    function walletToVault() payable public {\r\n        require(msg.value >0);\r\n        playerVault[msg.sender] = playerVault[msg.sender].add(msg.value);\r\n    }\r\n    // plinc functions\r\n    function fetchHubVault() public{\r\n        \r\n        uint256 value = hub_.playerVault(address(this));\r\n        require(value >0);\r\n        hub_.vaultToWallet();\r\n        \r\n        uint256 base = value.div(100);\r\n        playerVault[currentCurator] = playerVault[currentCurator].add(base);\r\n        // adjust pot\r\n        pot = pot.add(base).add(base);\r\n    }\r\n    function fetchHubPiggy() public{\r\n        \r\n        uint256 value = hub_.piggyBank(address(this));\r\n        require(value >0);\r\n        hub_.piggyToWallet();\r\n        uint256 base = value.div(100);\r\n        playerVault[currentCurator] = playerVault[currentCurator].add(base);\r\n        // adjust pot\r\n        pot = pot.add(base).add(base);\r\n        \r\n    }\r\n    \r\n    function buyHustler() payable public {\r\n        uint256 value = msg.value;\r\n        if(value < hustlerprice)\r\n        {\r\n            playerVault[msg.sender] = playerVault[msg.sender].add(value);\r\n            emit ETHfail(msg.sender, RID, hustlerprice, value);\r\n        }\r\n        if(value >= hustlerprice)\r\n        {\r\n        hub_.buyBonds.value(hustlerprice)(0xdc827558062AA1cc0e2AB28146DA9eeAC38A06D1) ;\r\n        playerVault[currentHustler] =  playerVault[currentHustler].add(hustlerprice);\r\n        emit buddySold(RID,currentHustler, msg.sender, hustlerprice);\r\n        if(value > hustlerprice)\r\n        {\r\n            playerVault[msg.sender] = playerVault[msg.sender].add(value.sub(hustlerprice));\r\n        }\r\n        hustlerprice = hustlerprice.add(1 finney);\r\n        currentHustler = msg.sender;\r\n        }\r\n        \r\n    }\r\n    function buyCurator() payable public {\r\n        uint256 value = msg.value;\r\n        if(value < curatorPrice)\r\n        {\r\n            playerVault[msg.sender] = playerVault[msg.sender].add(value);\r\n            emit ETHfail(msg.sender, RID, curatorPrice, value);\r\n        }\r\n        if(value >= curatorPrice)\r\n        {\r\n        hub_.buyBonds.value(curatorPrice)(0xdc827558062AA1cc0e2AB28146DA9eeAC38A06D1) ;\r\n        curatorVault[currentCurator] =  curatorVault[currentCurator].add(curatorPrice);\r\n        emit collectorSold(RID, currentCurator, msg.sender, curatorPrice);\r\n        if(value > curatorPrice)\r\n        {\r\n            playerVault[msg.sender] = playerVault[msg.sender].add(value.sub(curatorPrice));\r\n        }\r\n        curatorPrice = curatorPrice.add(1 finney);\r\n        currentCurator = msg.sender;\r\n        }\r\n        \r\n    }\r\n    function vaultToWallet() public {\r\n        \r\n        address sender = msg.sender;\r\n        require(playerVault[sender].sub(lastActiveRound[sender][RID]) > 0);\r\n        uint256 value = playerVault[sender].sub(lastActiveRound[sender][RID]);\r\n        playerVault[sender] = lastActiveRound[sender][RID];\r\n        emit cashout(RID,sender ,  value);\r\n        sender.transfer(value);\r\n        \r\n    }\r\n    function vaultCuratorToWallet() public {\r\n        \r\n        address sender = msg.sender;\r\n        require(curatorVault[sender] > 0);\r\n        uint256 value = curatorVault[sender];\r\n        curatorVault[sender] = 0;\r\n        emit cashout(RID,sender ,  value);\r\n        sender.transfer(value);\r\n        \r\n    }\r\n    function vaultHustlerToWallet() public {\r\n        \r\n        address sender = msg.sender;\r\n        require(hustlerVault[sender] > 0);\r\n        uint256 value = hustlerVault[sender];\r\n        hustlerVault[sender] = 0;\r\n        emit cashout(RID,sender ,  value);\r\n        sender.transfer(value);\r\n        \r\n    }\r\n    function donateToPot()  payable public {\r\n        pot = pot.add(msg.value);\r\n    }\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        hub_.setAuto(10);\r\n        hustlerprice = 1 finney;\r\n        curatorPrice = 1 finney;\r\n    }\r\n    // UI function\r\n    function fetchDataMain()\r\n        public\r\n        view\r\n        returns(uint256 _hubPiggy)\r\n    {\r\n        _hubPiggy = hub_.piggyBank(address(this));\r\n    }\r\n    \r\n    function getPlayerInfo() public view returns(address[] memory _Owner, uint256[] memory locationData,address[] memory infoRef ){\r\n          uint i;\r\n          address[] memory _locationOwner = new address[](nextPlayerID);\r\n          uint[] memory _locationData = new uint[](nextPlayerID*4); //curator + buddy + vault + frozen\r\n          address[] memory _info = new address[](nextPlayerID*2);\r\n          //bool[] memory _locationData2 = new bool[](nextPlayerID); //isAlive\r\n          uint y;\r\n          uint z;\r\n          for(uint x = 0; x < nextPlayerID; x+=1){\r\n            \r\n             \r\n                _locationOwner[i] = IdToAdress[i];\r\n                _locationData[y] = curatorVault[IdToAdress[i]];\r\n                _locationData[y+1] = hustlerVault[IdToAdress[i]];\r\n                _locationData[y+2] = playerVault[IdToAdress[i]];\r\n                _locationData[y+3] = lastActiveRound[IdToAdress[i]][RID];\r\n                _info[z] = referalSticky[IdToAdress[i]];\r\n                _info[z+1] = hustler[IdToAdress[i]];\r\n                \r\n                //_locationData2[i] = allowAutoInvest[IdToAdress[i]];\r\n              y += 4;\r\n              z += 2;\r\n              i+=1;\r\n            }\r\n          \r\n          return (_locationOwner,_locationData, _info);\r\n        }\r\n        function getRoundInfo(address player) public view returns(address[] memory _Owner, uint256[] memory locationData){\r\n          uint i;\r\n          address[] memory _locationOwner = new address[](RID);\r\n          uint[] memory _locationData = new uint[](RID * 2); //\r\n          \r\n          uint y;\r\n          for(uint x = 0; x < RID; x+=1){\r\n            \r\n             \r\n                _locationOwner[i] = owner[i];\r\n                _locationData[y] = price[i];\r\n                _locationData[y+1] = dividendsOwing(player,i);\r\n              y += 2;\r\n              i+=1;\r\n            }\r\n          \r\n          return (_locationOwner,_locationData);\r\n        }\r\n}\r\ninterface PlincInterface {\r\n    \r\n    function IdToAdress(uint256 index) external view returns(address);\r\n    function nextPlayerID() external view returns(uint256);\r\n    function bondsOutstanding(address player) external view returns(uint256);\r\n    function playerVault(address player) external view returns(uint256);\r\n    function piggyBank(address player) external view returns(uint256);\r\n    function vaultToWallet() external ;\r\n    function piggyToWallet() external ;\r\n    function setAuto (uint256 percentage)external ;\r\n    function buyBonds( address referral)external payable ;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hustlerprice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vaultHustlerToWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentHustler\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fetchDataMain\",\"outputs\":[{\"name\":\"_hubPiggy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPlayerID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IdToAdress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"curatorVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalsupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buyBall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDividendPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curatorPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pointMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyCurator\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCurator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fetchHubVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unclaimedDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"roundid\",\"type\":\"uint256\"}],\"name\":\"dividendsOwing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"walletToVault\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hustlerVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"stake\",\"type\":\"uint256\"},{\"name\":\"lastDividendPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vaultCuratorToWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referalSticky\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastActiveRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyHustler\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"_Owner\",\"type\":\"address[]\"},{\"name\":\"locationData\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vaultToWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hustler\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"_Owner\",\"type\":\"address[]\"},{\"name\":\"locationData\",\"type\":\"uint256[]\"},{\"name\":\"infoRef\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fetchHubPiggy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curatorReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toUpdate\",\"type\":\"address\"},{\"name\":\"roundid\",\"type\":\"uint256\"}],\"name\":\"fetchdivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"ballRolled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"buddySold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"collectorSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"cashout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pot\",\"type\":\"uint256\"}],\"name\":\"endOfRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sizeNeeded\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sizeSent\",\"type\":\"uint256\"}],\"name\":\"ETHfail\",\"type\":\"event\"}]","ContractName":"Snowball","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f0d9eb257d0b5667f56e59d60aadd0db5edfd160a67d5162e233d0230c88155d"}]}