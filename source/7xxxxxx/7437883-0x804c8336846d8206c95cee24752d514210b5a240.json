{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ninterface IOrbsNetworkTopology {\r\n\r\n    /// @dev returns an array of pairs with node addresses and ip addresses.\r\n    function getNetworkTopology()\r\n        external\r\n        view\r\n        returns (bytes20[] nodeAddresses, bytes4[] ipAddresses);\r\n}\r\n\r\n\r\ninterface IOrbsValidators {\r\n\r\n    event ValidatorApproved(address indexed validator);\r\n    event ValidatorRemoved(address indexed validator);\r\n\r\n    /// @dev Adds a validator to participate in network\r\n    /// @param validator address The address of the validators.\r\n    function approve(address validator) external;\r\n\r\n    /// @dev Remove a validator from the List based on Guardians votes.\r\n    /// @param validator address The address of the validators.\r\n    function remove(address validator) external;\r\n\r\n    /// @dev returns if an address belongs to the approved list & exists in the validators metadata registration database.\r\n    /// @param validator address The address of the validators.\r\n    function isValidator(address validator) external view returns (bool);\r\n\r\n    /// @dev returns if an address belongs to the approved list\r\n    /// @param validator address The address of the validators.\r\n    function isApproved(address validator) external view returns (bool);\r\n\r\n    /// @dev returns a list of all validators that have been approved and exist in the validator registration database.\r\n    function getValidators() external view returns (address[]);\r\n\r\n    /// @dev returns a list of all validators that have been approved and exist in the validator registration\r\n    ///      database. same as getValidators but returns addresses represented as byte20.\r\n    function getValidatorsBytes20() external view returns (bytes20[]);\r\n\r\n    /// @dev returns the block number in which the validator was approved.\r\n    /// @param validator address The address of the validators.\r\n    function getApprovalBlockNumber(address validator)\r\n        external\r\n        view\r\n        returns (uint);\r\n}\r\n\r\n\r\ninterface IOrbsValidatorsRegistry {\r\n\r\n    event ValidatorLeft(address indexed validator);\r\n    event ValidatorRegistered(address indexed validator);\r\n    event ValidatorUpdated(address indexed validator);\r\n\r\n    /// @dev register a validator and provide registration data.\r\n    /// the new validator entry will be owned and identified by msg.sender.\r\n    /// if msg.sender is already registered as a validator in this registry the\r\n    /// transaction will fail.\r\n    /// @param name string The name of the validator\r\n    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\r\n    /// @param website string The website of the validator\r\n    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\r\n    function register(\r\n        string name,\r\n        bytes4 ipAddress,\r\n        string website,\r\n        bytes20 orbsAddress\r\n    )\r\n        external;\r\n\r\n    /// @dev update the validator registration data entry associated with msg.sender.\r\n    /// msg.sender must be registered in this registry contract.\r\n    /// @param name string The name of the validator\r\n    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\r\n    /// @param website string The website of the validator\r\n    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\r\n    function update(\r\n        string name,\r\n        bytes4 ipAddress,\r\n        string website,\r\n        bytes20 orbsAddress\r\n    )\r\n        external;\r\n\r\n    /// @dev deletes a validator registration entry associated with msg.sender.\r\n    function leave() external;\r\n\r\n    /// @dev returns validator registration data.\r\n    /// @param validator address address of the validator.\r\n    function getValidatorData(address validator)\r\n        external\r\n        view\r\n        returns (\r\n            string name,\r\n            bytes4 ipAddress,\r\n            string website,\r\n            bytes20 orbsAddress\r\n        );\r\n\r\n    /// @dev returns the blocks in which a validator was registered and last updated.\r\n    /// if validator does not designate a registered validator this method returns zero values.\r\n    /// @param validator address of a validator\r\n    function getRegistrationBlockNumber(address validator)\r\n        external\r\n        view\r\n        returns (uint registeredOn, uint lastUpdatedOn);\r\n\r\n    /// @dev Checks if validator is currently registered as a validator.\r\n    /// @param validator address address of the validator\r\n    /// @return true iff validator belongs to a registered validator\r\n    function isValidator(address validator) external view returns (bool);\r\n\r\n    /// @dev returns the orbs node public address of a specific validator.\r\n    /// @param validator address address of the validator\r\n    /// @return an Orbs node address\r\n    function getOrbsAddress(address validator)\r\n        external\r\n        view\r\n        returns (bytes20 orbsAddress);\r\n}\r\n\r\n\r\ncontract OrbsValidators is Ownable, IOrbsValidators, IOrbsNetworkTopology {\r\n\r\n    // The version of the current Validators smart contract.\r\n    uint public constant VERSION = 1;\r\n\r\n    // Maximum number of validators.\r\n    uint internal constant MAX_VALIDATOR_LIMIT = 100;\r\n    uint public validatorsLimit;\r\n\r\n    // The validators metadata registration database smart contract\r\n    IOrbsValidatorsRegistry public orbsValidatorsRegistry;\r\n\r\n    // Array of approved validators addresses\r\n    address[] internal approvedValidators;\r\n\r\n    // Mapping of address and in which block it was approved.\r\n    mapping(address => uint) internal approvalBlockNumber;\r\n\r\n    /// @dev Constructor that initializes the validators smart contract with the validators metadata registration\r\n    ///     database smart contract.\r\n    /// @param registry_ IOrbsValidatorsRegistry The address of the validators metadata registration database.\r\n    /// @param validatorsLimit_ uint Maximum number of validators list maximum size.\r\n    constructor(IOrbsValidatorsRegistry registry_, uint validatorsLimit_) public {\r\n        require(registry_ != IOrbsValidatorsRegistry(0), \"Registry contract address 0\");\r\n        require(validatorsLimit_ > 0, \"Limit must be positive\");\r\n        require(validatorsLimit_ <= MAX_VALIDATOR_LIMIT, \"Limit is too high\");\r\n\r\n        validatorsLimit = validatorsLimit_;\r\n        orbsValidatorsRegistry = registry_;\r\n    }\r\n\r\n    /// @dev Adds a validator to participate in network\r\n    /// @param validator address The address of the validators.\r\n    function approve(address validator) external onlyOwner {\r\n        require(validator != address(0), \"Address must not be 0!\");\r\n        require(approvedValidators.length < validatorsLimit, \"Can't add more members!\");\r\n        require(!isApproved(validator), \"Address must not be already approved\");\r\n\r\n        approvedValidators.push(validator);\r\n        approvalBlockNumber[validator] = block.number;\r\n        emit ValidatorApproved(validator);\r\n    }\r\n\r\n    /// @dev Remove a validator from the List based on Guardians votes.\r\n    /// @param validator address The address of the validators.\r\n    function remove(address validator) external onlyOwner {\r\n        require(isApproved(validator), \"Not an approved validator\");\r\n\r\n        uint approvedLength = approvedValidators.length;\r\n        for (uint i = 0; i < approvedLength; ++i) {\r\n            if (approvedValidators[i] == validator) {\r\n\r\n                // Replace with last element and remove from end\r\n                approvedValidators[i] = approvedValidators[approvedLength - 1];\r\n                approvedValidators.length--;\r\n\r\n                // Clear approval block height\r\n                delete approvalBlockNumber[validator];\r\n\r\n                emit ValidatorRemoved(validator);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev returns if an address belongs to the approved list & exists in the validators metadata registration database.\r\n    /// @param validator address The address of the validators.\r\n    function isValidator(address validator) public view returns (bool) {\r\n        return isApproved(validator) && orbsValidatorsRegistry.isValidator(validator);\r\n    }\r\n\r\n    /// @dev returns if an address belongs to the approved list\r\n    /// @param validator address The address of the validators.\r\n    function isApproved(address validator) public view returns (bool) {\r\n        return approvalBlockNumber[validator] > 0;\r\n    }\r\n\r\n    /// @dev returns a list of all validators that have been approved and exist in the validator registration database.\r\n    function getValidators() public view returns (address[] memory) {\r\n        uint approvedLength = approvedValidators.length;\r\n        address[] memory validators = new address[](approvedLength);\r\n\r\n        uint pushAt = 0;\r\n        for (uint i = 0; i < approvedLength; i++) {\r\n            if (orbsValidatorsRegistry.isValidator(approvedValidators[i])) {\r\n                validators[pushAt] = approvedValidators[i];\r\n                pushAt++;\r\n            }\r\n        }\r\n\r\n        return sliceArray(validators, pushAt);\r\n    }\r\n\r\n    /// @dev returns a list of all validators that have been approved and exist in the validator registration\r\n    ///      database. same as getValidators but returns addresses represented as byte20.\r\n    function getValidatorsBytes20() external view returns (bytes20[]) {\r\n        address[] memory validatorAddresses = getValidators();\r\n        uint validatorAddressesLength = validatorAddresses.length;\r\n\r\n        bytes20[] memory result = new bytes20[](validatorAddressesLength);\r\n\r\n        for (uint i = 0; i < validatorAddressesLength; i++) {\r\n            result[i] = bytes20(validatorAddresses[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @dev returns the block number in which the validator was approved.\r\n    /// @param validator address The address of the validators.\r\n    function getApprovalBlockNumber(address validator)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return approvalBlockNumber[validator];\r\n    }\r\n\r\n    /// @dev returns an array of pairs with node addresses and ip addresses.\r\n    function getNetworkTopology()\r\n        external\r\n        view\r\n        returns (bytes20[] memory nodeAddresses, bytes4[] memory ipAddresses)\r\n    {\r\n        address[] memory validators = getValidators(); // filter unregistered\r\n        uint validatorsLength = validators.length;\r\n        nodeAddresses = new bytes20[](validatorsLength);\r\n        ipAddresses = new bytes4[](validatorsLength);\r\n\r\n        for (uint i = 0; i < validatorsLength; i++) {\r\n            bytes4 ip;\r\n            bytes20 orbsAddr;\r\n            ( , ip , , orbsAddr) = orbsValidatorsRegistry.getValidatorData(validators[i]);\r\n            nodeAddresses[i] = orbsAddr;\r\n            ipAddresses[i] = ip;\r\n        }\r\n    }\r\n\r\n    /// @dev internal method that returns a slice of an array.\r\n    function sliceArray(address[] memory arr, uint len)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        require(len <= arr.length, \"sub array must be longer then array\");\r\n\r\n        address[] memory result = new address[](len);\r\n        for(uint i = 0; i < len; i++) {\r\n            result[i] = arr[i];\r\n        }\r\n        return result;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"orbsValidatorsRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNetworkTopology\",\"outputs\":[{\"name\":\"nodeAddresses\",\"type\":\"bytes20[]\"},{\"name\":\"ipAddresses\",\"type\":\"bytes4[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"isApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getApprovalBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorsLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidatorsBytes20\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes20[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"registry_\",\"type\":\"address\"},{\"name\":\"validatorsLimit_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OrbsValidators","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000056a6895fd37f358c17cbb3f14a864ea5fe871f0a0000000000000000000000000000000000000000000000000000000000000064","Library":"","SwarmSource":"bzzr://aa3da0ce3e8fc3daf37cda7e99928d77102b805f55648ec8a0043c0c71839732"}]}