{"status":"1","message":"OK","result":[{"SourceCode":"// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract RefundVault is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  enum State { Active, Refunding, Closed }\r\n\r\n  mapping (address => uint256) public deposited;\r\n  address public wallet;\r\n  State public state;\r\n\r\n  event Closed();\r\n  event RefundsEnabled();\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n  /**\r\n   * @param _wallet Vault address\r\n   */\r\n  constructor(address _wallet) public {\r\n    require(_wallet != address(0));\r\n    wallet = _wallet;\r\n    state = State.Active;\r\n  }\r\n\r\n  /**\r\n   * @param investor Investor address\r\n   */\r\n  function deposit(address investor) onlyOwner public payable {\r\n    require(state == State.Active);\r\n    deposited[investor] = deposited[investor].add(msg.value);\r\n  }\r\n\r\n  function close() onlyOwner public {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    emit Closed();\r\n    wallet.transfer(address(this).balance);\r\n  }\r\n\r\n  function enableRefunds() onlyOwner public {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    emit RefundsEnabled();\r\n  }\r\n\r\n  /**\r\n   * @param investor Investor address\r\n   */\r\n  function refund(address investor) public {\r\n    require(state == State.Refunding);\r\n    uint256 depositedValue = deposited[investor];\r\n    deposited[investor] = 0;\r\n    investor.transfer(depositedValue);\r\n    emit Refunded(investor, depositedValue);\r\n  }\r\n}\r\n\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\ncontract RoundVault is RefundVault {\r\n\r\n    uint256 constant DEV_FUND_COMMISSION = 4; //%\r\n\r\n    uint256 public totalRoundPrize;\r\n    uint256 public finalCumulativeWeight;\r\n\r\n    StartersProxyInterface public startersProxy;\r\n\r\n    event RewardWinner(address player, uint256 weiAmount, uint256 kPercent);\r\n\r\n    constructor(address _devFundWallet, address _proxyAddress) RefundVault(_devFundWallet) public {\r\n        startersProxy = StartersProxyInterface(_proxyAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Pays actual ETH to the winner\r\n    */\r\n    function reward(address _winner, uint256 _personalWeight) onlyOwner public {\r\n        //millions of % for better precision\r\n        uint256 _portion = _personalWeight.mul(100000000).div(finalCumulativeWeight);\r\n\r\n        //wei\r\n        uint256 _prizeWei = totalRoundPrize.mul(_portion).div(100000000);\r\n\r\n        require(address(this).balance > _prizeWei, \"Vault run out of funds!\");\r\n\r\n        if (isContract(_winner)) {\r\n            //do noting\r\n            //bad guy, punish this hacking attempt\r\n        } else {\r\n            //check if any debt player has\r\n            uint256 _personalDept = startersProxy.debt(_winner);\r\n            if (_personalDept > 0) {\r\n                uint256 _toRepay = _personalDept;\r\n                if (_prizeWei < _personalDept) {\r\n                    //don't repay more than won\r\n                    _toRepay = _prizeWei;\r\n                }\r\n                startersProxy.payDebt.value(_toRepay)(_winner);\r\n                //anything left to reward with?\r\n                if (_prizeWei.sub(_toRepay) > 0) {\r\n                    _winner.transfer(_prizeWei.sub(_toRepay));\r\n                }\r\n            } else {\r\n                _winner.transfer(_prizeWei);\r\n            }\r\n        }\r\n\r\n        emit RewardWinner(_winner, _prizeWei, _portion);\r\n    }\r\n\r\n    function isContract(address _address) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(_address) }\r\n        return size > 0;\r\n    }\r\n\r\n    function personalPrizeByNow(uint256 _personalWeight, uint256 _roundCumulativeWeigh) onlyOwner public view returns (uint256){\r\n        if (_roundCumulativeWeigh == 0) {\r\n            //no wins in this round yet\r\n            return 0;\r\n        }\r\n        //millions of % for better precision\r\n        uint256 _portion = _personalWeight.mul(100000000).div(_roundCumulativeWeigh);\r\n        //wei\r\n        return totalPrizePot().mul(_portion).div(100000000);\r\n    }\r\n\r\n    function personalPrizeWithBet(uint256 _personalWeight, uint256 _roundCumulativeWeight, uint256 _bet) onlyOwner public view returns (uint256){\r\n        if (_roundCumulativeWeight == 0) {\r\n            //no wins in this round yet\r\n            _roundCumulativeWeight = _personalWeight;\r\n        } else {\r\n            //assuming cumulativeWeight\r\n            _roundCumulativeWeight = _roundCumulativeWeight.add(_personalWeight);\r\n        }\r\n        uint256 _portion = _personalWeight.mul(100).div(_roundCumulativeWeight);\r\n\r\n        //wei\r\n        uint256 _assumingPersonalAdditionToPot = _bet.mul(100 - DEV_FUND_COMMISSION).div(100);\r\n        uint256 _assumingPrizePot = totalPrizePot().add(_assumingPersonalAdditionToPot);\r\n\r\n        return _assumingPrizePot.mul(_portion).div(100);\r\n    }\r\n\r\n    function totalPrizePot() internal view returns (uint256) {\r\n        return address(this).balance.mul(100 - DEV_FUND_COMMISSION).div(100);\r\n    }\r\n\r\n    function sumUp(uint256 _weight) onlyOwner public {\r\n        finalCumulativeWeight = _weight;\r\n        totalRoundPrize = totalPrizePot();\r\n    }\r\n\r\n    function terminate() onlyOwner public {\r\n        state = State.Active;\r\n        super.close();\r\n    }\r\n\r\n    function getWallet() public view returns (address) {\r\n        return wallet;\r\n    }\r\n\r\n    function getDevFundAddress() public view returns (address){\r\n        return wallet;\r\n    }\r\n}\r\n\r\ninterface StartersProxyInterface {\r\n\r\n    function debt(address signer) external view returns (uint256);\r\n\r\n    function payDebt(address signer) external payable;\r\n}\r\n\r\ncontract Whitelist is Ownable, RBAC {\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    checkRole(msg.sender, ROLE_WHITELISTED);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    addRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressAdded(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function whitelist(address addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(addr, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      addAddressToWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    removeRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressRemoved(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      removeAddressFromWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract EthBattleRound is Whitelist, Claimable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SMART_ASS_COEFFICIENT = 5; //%\r\n    uint256 public constant REFERRAL_BONUS = 1; //%\r\n\r\n    // refund vault used to hold funds while round is running.\r\n    // Can allow claiming of ETH back to participants if something went wrong\r\n    RoundVault public vault;\r\n\r\n    event Play(address player, uint256 bet, address referral, address round);\r\n    event Win(address player, address round);\r\n    event Reward(uint256 counter, address winner);\r\n    event Finalize(uint256 count);\r\n    event CoolDown(uint256 winCount);\r\n\r\n    //Active - can play\r\n    //CoolingDown - can't play but still can win\r\n    //Rewarding - neither plays nor wins possible, it's in the state of paying rewards\r\n    //Closed - rewarding is over, fund is empty\r\n    enum State {Active, CoolingDown, Rewarding, Closed}\r\n    State private state;\r\n\r\n    uint256 public roundCumulativeWeight;\r\n    uint256 public winCount;   //facts\r\n    uint256 public winnerCount; //players\r\n    uint256 public rewardCount;\r\n\r\n    uint256 public roundSwapLimit = 200; //the default 'win' counter triggering the round swap\r\n\r\n    //backlog of winners counting their wins\r\n    mapping(address => uint256) public winnersBacklog;\r\n\r\n    //backlog of players and their referrals\r\n    mapping(address => address) public referralBacklog;\r\n    //players and their last bets\r\n    mapping(address => uint256) public lastBetWei;\r\n    //players and their cumulative wins weight in the round\r\n    mapping(address => uint256) public playerWinWeight;\r\n    //rewarded winners\r\n    mapping(address => bool) public rewardedWinners;\r\n\r\n\r\n    /**\r\n    * @dev Default fallback function, just deposits funds to the pot\r\n    */\r\n    function () public payable {\r\n        vault.getWallet().transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor, creates EthBattleRound.\r\n    * @param _devFundWallet Development funds wallet to store a portion of funds once round is over\r\n    * @param _battleAddress EthBattle address\r\n    * @param _rewardingAddrs addresses authorized to pay the rewards\r\n    */\r\n    constructor (address _devFundWallet, address _battleAddress, address[] _rewardingAddrs, address _proxyAddress) public {\r\n        vault = new RoundVault(_devFundWallet, _proxyAddress);\r\n\r\n        addAddressToWhitelist(_battleAddress);\r\n\r\n        addAddressesToWhitelist(_rewardingAddrs);\r\n\r\n        state = State.Active;\r\n    }\r\n\r\n    function isActive() public view returns (bool){\r\n        return state == State.Active;\r\n    }\r\n\r\n    /**\r\n    * @dev Enable the refunds to players can claim back their bets\r\n    */\r\n    function enableRefunds() onlyOwner public {\r\n        require(isActive() || isCoolingDown(), \"Round must be active\");\r\n        vault.enableRefunds();\r\n    }\r\n\r\n    /**\r\n    * @dev Last resort, terminate the round from any state\r\n    */\r\n    function terminate() external onlyWhitelisted {\r\n        //from any state\r\n        vault.terminate();\r\n        state = State.Closed;\r\n    }\r\n\r\n    /**\r\n    * @dev Every player, if enabled, can claim refund\r\n    */\r\n    function claimRefund() public {\r\n        vault.refund(msg.sender);\r\n    }\r\n\r\n\r\n    function coolDown() onlyOwner public {\r\n        require(isActive() || isCoolingDown(), \"Round must be active\");\r\n        state = State.CoolingDown;\r\n        emit CoolDown(winCount);\r\n    }\r\n\r\n    function isCoolingDown() public view returns (bool){\r\n        return state == State.CoolingDown;\r\n    }\r\n\r\n    function startRewarding() external onlyWhitelisted {\r\n        require(isCoolingDown(), \"Cool it down first\");\r\n        vault.sumUp(roundCumulativeWeight);\r\n\r\n        state = State.Rewarding;\r\n    }\r\n\r\n    function isRewarding() public view returns (bool){\r\n        return state == State.Rewarding;\r\n    }\r\n\r\n    function playRound(address _player, uint256 _bet) onlyOwner public payable {\r\n        require(isActive(), \"Not active anymore\");\r\n\r\n        lastBetWei[_player] = _bet;\r\n\r\n        uint256 _thisBet = msg.value;\r\n        if (referralBacklog[_player] != address(0)) {\r\n            //this player used a referral link once, split the bet\r\n            uint256 _referralReward = _thisBet.mul(REFERRAL_BONUS).div(100);\r\n            if (isContract(referralBacklog[_player])) {\r\n                //do noting\r\n                //bad guy, punish this hacking attempt\r\n                vault.getDevFundAddress().transfer(_referralReward);\r\n            } else {\r\n                referralBacklog[_player].transfer(_referralReward);\r\n            }\r\n            _thisBet = _thisBet.sub(_referralReward);\r\n        }\r\n\r\n        vault.deposit.value(_thisBet)(_player);\r\n\r\n        emit Play(_player, _thisBet, referralBacklog[_player], address(this));\r\n\r\n    }\r\n\r\n    function win(address _player) onlyOwner public {\r\n        require(isActive() || isCoolingDown(), \"Round must be active or cooling down\");\r\n\r\n        require(lastBetWei[_player] > 0, \"Hmm, did this player call 'play' before?\");\r\n\r\n        uint256 _thisWinWeight = applySmartAssCorrection(_player, lastBetWei[_player]);\r\n\r\n        recordWinFact(_player, _thisWinWeight);\r\n    }\r\n\r\n    /**\r\n    * @dev Prize right now, if the payment would have happened immediately\r\n    */\r\n    function currentPrize(address _player) onlyOwner public view returns (uint256) {\r\n        //calculate depending on personal weight and the total weight so far\r\n        return vault.personalPrizeByNow(playerWinWeight[_player], roundCumulativeWeight);\r\n    }\r\n\r\n    /**\r\n    * @dev Project the prize if this were the last game and the payment would take place right after this win\r\n    * NOTE: Doesn't apply the referral's correction\r\n    */\r\n    function projectedPrizeForPlayer(address _player, uint256 _bet) onlyOwner public view returns (uint256) {\r\n        uint256 _projectedPersonalWeight = applySmartAssCorrection(_player, _bet);\r\n        //calculate depending on personal weight and the total weight so far\r\n        return vault.personalPrizeWithBet(_projectedPersonalWeight, roundCumulativeWeight, _bet);\r\n    }\r\n\r\n    function recordWinFact(address _player, uint256 _winWeight) internal {\r\n        if (playerWinWeight[_player] == 0) {\r\n            //new winner\r\n            winnerCount++;\r\n        }\r\n        winCount++;\r\n        playerWinWeight[_player] = playerWinWeight[_player].add(_winWeight);\r\n        roundCumulativeWeight = roundCumulativeWeight.add(_winWeight);\r\n\r\n        winnersBacklog[_player] = winnersBacklog[_player].add(1);\r\n        if (winCount == roundSwapLimit) {\r\n            //this round is over. Cool down.\r\n            coolDown();\r\n        }\r\n        emit Win(_player, address(this));\r\n    }\r\n\r\n    function applySmartAssCorrection(address _player, uint256 _bet) internal view returns (uint256){\r\n        if (winnersBacklog[_player] > 0) {\r\n            //has won before, or he's a referral and got his fee before\r\n            uint256 _personalWinCount = winnersBacklog[_player];\r\n            if (_personalWinCount > 10) {\r\n                //even if more than 10 wins limit decrease to 10 * SMART_ASS_COEFFICIENT\r\n                _personalWinCount = 10;\r\n            }\r\n            _bet = _bet.mul(100 - _personalWinCount.mul(SMART_ASS_COEFFICIENT)).div(100);\r\n        }\r\n        return _bet;\r\n    }\r\n\r\n    function rewardWinner(address _winner) external onlyWhitelisted {\r\n        require(state == State.Rewarding, \"Round in not in 'Rewarding' state yet\");\r\n        require(playerWinWeight[_winner] > 0, \"This player hasn't actually won anything\");\r\n        require(!rewardedWinners[_winner], \"This player has been rewarded already\");\r\n\r\n        vault.reward(_winner, playerWinWeight[_winner]);\r\n\r\n        rewardedWinners[_winner] = true;\r\n        rewardCount++;\r\n        emit Reward(rewardCount, _winner);\r\n    }\r\n\r\n    function setReferral(address _player, address _referral) onlyOwner public {\r\n        if (referralBacklog[_player] == address(0)) {\r\n            referralBacklog[_player] = _referral;\r\n        }\r\n    }\r\n\r\n    function finalizeRound() external onlyWhitelisted {\r\n        require(state == State.Rewarding, \"The round must be in 'Rewarding' state\");\r\n        isAllWinnersRewarded();\r\n\r\n        //vault leftover moves the funds to the dev funds wallet\r\n        vault.close();\r\n\r\n        state = State.Closed;\r\n        emit Finalize(rewardCount);\r\n    }\r\n\r\n    function isContract(address _address) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(_address) }\r\n        return size > 0;\r\n    }\r\n\r\n    function isClosed() public view returns (bool){\r\n        return state == State.Closed;\r\n    }\r\n\r\n    function isAllWinnersRewarded() public view returns (bool){\r\n        return winnerCount == rewardCount;\r\n    }\r\n\r\n    function getVault() public view returns (RoundVault) {\r\n        return vault;\r\n    }\r\n\r\n    function getDevWallet() public view returns (address) {\r\n        return vault.getWallet();\r\n    }\r\n\r\n    function setRoundSwapLimit(uint256 _newLimit) external onlyWhitelisted {\r\n        roundSwapLimit = _newLimit;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRewarding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCoolingDown\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_bet\",\"type\":\"uint256\"}],\"name\":\"playRound\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"rewardWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDevWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"coolDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setRoundSwapLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBetWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"winnersBacklog\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"setReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBacklog\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAllWinnersRewarded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SMART_ASS_COEFFICIENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"win\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_bet\",\"type\":\"uint256\"}],\"name\":\"projectedPrizeForPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardedWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerWinWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundSwapLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRewarding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRAL_BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundCumulativeWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"currentPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devFundWallet\",\"type\":\"address\"},{\"name\":\"_battleAddress\",\"type\":\"address\"},{\"name\":\"_rewardingAddrs\",\"type\":\"address[]\"},{\"name\":\"_proxyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"address\"}],\"name\":\"Play\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"address\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"counter\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Finalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winCount\",\"type\":\"uint256\"}],\"name\":\"CoolDown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthBattleRound","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001a0faaa191fcbfb70b96cad8409cb0f6e733afff0000000000000000000000001736ac66fe33030fe27805af041789ec2fde99250000000000000000000000000000000000000000000000000000000000000080000000000000000000000000b08e657b0da89f2d7235d56f04a4ac3fed597d2a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000031e47bafa280271fad9c978a4baef622e0133a42000000000000000000000000627e3899fa51dc2e6ceb260061d77ded5eaac687","Library":"","SwarmSource":"bzzr://0db2284294c8d7578cfe5571e38d484f240e330ddc0d813011b0c8b94c036267"}]}