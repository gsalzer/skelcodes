{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity < 0.6;\r\n\r\ncontract Game365Meta {\r\n\r\n    /**\r\n        owner setting\r\n     */\r\n    address payable public owner;\r\n\r\n    // Croupier account.\r\n    address public croupier = address(0x0);\r\n\r\n    // The address corresponding to a private key used to sign placeBet commits.\r\n    address public secretSigner = address(0x0);\r\n\r\n    // Adjustable max bet profit and start winning the jackpot. Used to cap bets against dynamic odds.\r\n    uint public maxProfit = 5 ether;\r\n    uint public minJackpotWinAmount = 0.1 ether;\r\n\r\n    /*\r\n        set constants\r\n    */\r\n    uint constant HOUSE_EDGE_PERCENT = 1;\r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether; \r\n\r\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\r\n    uint public constant MIN_JACKPOT_BET = 0.1 ether;\r\n    uint public constant JACKPOT_MODULO = 1000; \r\n    uint constant JACKPOT_FEE = 0.001 ether; \r\n\r\n    // There is minimum and maximum bets.\r\n    uint public constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_AMOUNT = 300000 ether; \r\n    \r\n    // Modulo is a number of equiprobable outcomes in a game:\r\n    //  - 2 for coin flip\r\n    //  - 6 for dice\r\n    //  - 6*6 = 36 for double dice\r\n    //  - 100 for etheroll\r\n    //  - 37 for roulette\r\n    //  etc.\r\n    // It's called so because 256-bit entropy is treated like a huge integer and\r\n    // the remainder of its division by modulo is considered bet outcome.\r\n    uint constant MAX_MODULO = 100;\r\n    uint constant MAX_MASK_MODULO = 40;\r\n\r\n    // This is a check on bet mask overflow.\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\r\n\r\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\r\n    // past. Given that settleBet uses block hash of placeBet as one of\r\n    // complementary entropy sources, we cannot process bets older than this\r\n    // threshold. On rare occasions our croupier may fail to invoke\r\n    // settleBet in this timespan due to technical issues or extreme Ethereum\r\n    // congestion; such bets can be refunded via invoking refundBet.\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    // This are some constants making O(1) population count in placeBet possible.\r\n    // See whitepaper for intuition and proofs behind it.\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F; // decimal:63, binary:111111\r\n    \r\n    /**\r\n        24h Total bet amounts/counts\r\n     */    \r\n    uint256 public lockedInBets_;\r\n    uint256 public lockedInJackpot_;\r\n    \r\n    struct Bet {\r\n        // Wager amount in wei.\r\n        uint amount;\r\n        // Modulo of a game.\r\n        uint8 modulo;\r\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollUnder),\r\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\r\n        uint8 rollUnder;\r\n        // Block number of placeBet tx.\r\n        uint40 placeBlockNumber;\r\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\r\n        uint40 mask;\r\n        // Address of a gambler, used to pay out winning bets.\r\n        address payable gambler;\r\n    }\r\n    mapping(uint256 => Bet) bets;\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(uint commit, address indexed beneficiary, uint amount, uint jackpotAmount);\r\n    event Payment(uint commit, address indexed beneficiary, uint amount, uint jackpotAmount);\r\n    event JackpotPayment(address indexed beneficiary, uint amount);\r\n    event Commit(uint256 commit);\r\n    \r\n    /**\r\n        Constructor\r\n     */\r\n    constructor () \r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n        Modifier\r\n    */\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n    \r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyCroupier {\r\n        require (msg.sender == croupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    // See comment for \"secretSigner\" variable.\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    // Change the croupier address.\r\n    function setCroupier(address newCroupier) external onlyOwner {\r\n        croupier = newCroupier;\r\n    }\r\n\r\n    function setMaxProfit(uint _maxProfit) public onlyOwner {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    function setMinJackPotWinAmount(uint _minJackpotAmount) public onlyOwner {\r\n        minJackpotWinAmount = _minJackpotAmount;\r\n    }\r\n\r\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\r\n    function increaseJackpot(uint increaseAmount) external onlyOwner {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (lockedInJackpot_ + lockedInBets_ + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        lockedInJackpot_ += uint128(increaseAmount);\r\n    }\r\n\r\n    // Funds withdrawal to cover costs of our operation.\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        sendFunds(1, beneficiary, withdrawAmount, 0);\r\n    }\r\n    \r\n    // Contract may be destroyed only when there are no ongoing bets,\r\n    // either settled or refunded. All funds are transferred to contract owner.\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n    }\r\n    \r\n    function placeBet(uint256 betMask, uint256 modulo, uint256 commitLastBlock, uint256 commit, bytes32 r, bytes32 s) \r\n        external\r\n        payable \r\n    {\r\n        Bet storage bet = bets[commit];\r\n        require(bet.gambler == address(0), \"already betting same commit number\");\r\n\r\n        uint256 amount = msg.value;\r\n        require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\r\n        require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n\r\n        //@DEV It will be changed later.\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, commit));\r\n        require (secretSigner == ecrecover(prefixedHash, 28, r, s), \"ECDSA signature is not valid.\");\r\n\r\n\r\n        // Winning amount and jackpot increase.\r\n        uint rollUnder;\r\n        // uint mask;\r\n        \r\n        // Small modulo games specify bet outcomes via bit mask.\r\n        // rollUnder is a number of 1 bits in this mask (population count).\r\n        // This magical looking formula is an efficient way to compute population\r\n        // count on EVM for numbers below 2**40. For detailed proof consult\r\n        // the our whitepaper.\r\n        if(modulo <= MAX_MASK_MODULO){\r\n            rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n            // mask = betMask;  //Stack too deep, try removing local variables.\r\n        }else{\r\n            require (betMask > 0 && betMask <= modulo, \"High modulo range, betMask larger than modulo.\");\r\n            rollUnder = betMask;\r\n        }\r\n\r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n\r\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, modulo, rollUnder);\r\n\r\n        // Enforce max profit limit.\r\n        require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation.\");\r\n\r\n        // Lock funds.\r\n        lockedInBets_ += uint128(possibleWinAmount);\r\n        lockedInJackpot_ += uint128(jackpotFee);\r\n\r\n        // Check whether contract has enough funds to process this bet.\r\n        require (lockedInJackpot_ + lockedInBets_ <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n        \r\n        // Record commit in logs.\r\n        emit Commit(commit);\r\n\r\n        bet.amount = amount;\r\n        bet.modulo = uint8(modulo);\r\n        bet.rollUnder = uint8(rollUnder);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.mask = uint40(betMask);\r\n        bet.gambler = msg.sender;\r\n    }\r\n    \r\n    // This is the method used to settle 99% of bets. To process a bet with a specific\r\n    // \"commit\", settleBet should supply a \"reveal\" number that would Keccak256-hash to\r\n    // \"commit\". \"blockHash\" is the block hash of placeBet block as seen by croupier; it\r\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\r\n    function settleBet(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\r\n        require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n        require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n        require (blockhash(placeBlockNumber) == blockHash, \"Does not matched blockHash.\");\r\n\r\n        // Settle bet using reveal and blockHash as entropy sources.\r\n        settleBetCommon(bet, reveal, blockHash);\r\n    }\r\n\r\n    // Common settlement code for settleBet & settleBetUncleMerkleProof.\r\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) private {\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n        uint amount = bet.amount;\r\n        uint modulo = bet.modulo;\r\n        uint rollUnder = bet.rollUnder;\r\n        address payable gambler = bet.gambler;\r\n\r\n        // Check that bet is in 'active' state.\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        // Move bet into 'processed' state already.\r\n        bet.amount = 0;\r\n        \r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n        uint dice = uint(entropy) % modulo;\r\n\r\n        uint diceWinAmount;\r\n        uint _jackpotFee;\r\n        (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, modulo, rollUnder);\r\n\r\n        uint diceWin = 0;\r\n        uint jackpotWin = 0;\r\n\r\n        // Determine dice outcome.\r\n        if (modulo <= MAX_MASK_MODULO) {\r\n            // For small modulo games, check the outcome against a bit mask.\r\n            if ((2 ** dice) & bet.mask != 0) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n        } else {\r\n            // For larger modulos, check inclusion into half-open interval.\r\n            if (dice < rollUnder) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets_ -= uint128(diceWinAmount);\r\n\r\n        // Roll for a jackpot (if eligible).\r\n        if (amount >= MIN_JACKPOT_BET && lockedInJackpot_ >= minJackpotWinAmount) {\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if (jackpotRng == 0) {\r\n                jackpotWin = lockedInJackpot_;\r\n                lockedInJackpot_ = 0;\r\n            }\r\n        }\r\n\r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin);\r\n        }\r\n\r\n        // Send the funds to gambler.\r\n        sendFunds(commit, gambler, diceWin, jackpotWin);\r\n    }\r\n\r\n    function getDiceWinAmount(uint amount, uint modulo, uint rollUnder) private pure returns (uint winAmount, uint jackpotFee) {\r\n        require (0 < rollUnder && rollUnder <= modulo, \"Win probability out of range.\");\r\n\r\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n\r\n        uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require (houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\r\n        winAmount = (amount - houseEdge - jackpotFee) * modulo / rollUnder;\r\n    }\r\n    \r\n    // Refund transaction - return the bet amount of a roll that was not processed in a\r\n    // due timeframe. Processing such blocks is not possible due to EVM limitations (see\r\n    // BET_EXPIRATION_BLOCKS comment above for details). In case you ever find yourself\r\n    // in a situation like this, just contact the our support, however nothing\r\n    // precludes you from invoking this method yourself.\r\n    function refundBet(uint commit) external {\r\n        // Check that bet is in 'active' state.\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        // Check that bet has already expired.\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        // Move bet into 'processed' state, release funds.\r\n        bet.amount = 0;\r\n        \r\n        uint diceWinAmount;\r\n        uint jackpotFee;\r\n        (diceWinAmount, jackpotFee) = getDiceWinAmount(amount, bet.modulo, bet.rollUnder);\r\n\r\n        lockedInBets_ -= uint128(diceWinAmount);\r\n        lockedInJackpot_ -= uint128(jackpotFee);\r\n\r\n        // Send the refund.\r\n        sendFunds(commit, bet.gambler, amount, 0);\r\n    }\r\n\r\n    // Helper routine to process the payment.\r\n    function sendFunds(uint commit, address payable beneficiary, uint diceWin, uint jackpotWin) private {\r\n        uint amount = diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin;\r\n        uint successLogAmount = diceWin;\r\n\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(commit, beneficiary, successLogAmount, jackpotWin);\r\n        } else {\r\n            emit FailedPayment(commit, beneficiary, amount, 0);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_MODULO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_JACKPOT_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minJackpotAmount\",\"type\":\"uint256\"}],\"name\":\"setMinJackPotWinAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInJackpot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint256\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minJackpotWinAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"setCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"jackpotAmount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"jackpotAmount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"}]","ContractName":"Game365Meta","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://39ac339293b4f4f46b6683d6491162bc5b3797557c559c498b05cdb89a158af0"}]}