{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract EtherStake is Ownable {\r\n /**\r\n * EtherStake\r\n * www.etherstake.me\r\n * Copyright 2019\r\n * admin@etherpornstars.com\r\n */\r\n    \r\n  using SafeMath for uint;\r\n  // Address set to win pot when time runs out\r\n  address payable public  leadAddress;\r\n    // Manage your dividends without MetaMask! Send 0.01 ETH to these directly\r\n  address public reinvestmentContractAddress;\r\n  address public withdrawalContractAddress;\r\n  // Multiplies your stake purchases, starts at 110% and goes down 0.1% a day down to 100% - get in early!\r\n  uint public stakeMultiplier;\r\n  uint public totalStake;\r\n  uint public day;\r\n  uint public roundId;\r\n  uint public roundEndTime;\r\n  uint public startOfNewDay;\r\n  uint public timeInADay;\r\n  uint public timeInAWeek;\r\n  // Optional message shown on the site when your address is leading\r\n  mapping(address => string) public playerMessage;\r\n  mapping(address => string) public playerName;\r\n  // Boundaries for messages\r\n  uint8 constant playerMessageMinLength = 1;\r\n  uint8 constant playerMessageMaxLength = 64;\r\n  mapping (uint => uint) internal seed; //save seed from rounds\r\n  mapping (uint => uint) internal roundIdToDays;\r\n  mapping (address => uint) public spentDivs;\r\n  // Main data structure that tracks all players dividends for current and previous rounds\r\n  mapping(uint => mapping(uint => divKeeper)) public playerDivsInADay;\r\n  // Emitted when user withdraws dividends or wins jackpot\r\n  event CashedOut(address _player, uint _amount);\r\n  event InvestReceipt(\r\n    address _player,\r\n    uint _stakeBought);\r\n    \r\n    struct divKeeper {\r\n      mapping(address => uint) playerStakeAtDay;\r\n      uint totalStakeAtDay;\r\n      uint revenueAtDay;\r\n  } \r\n\r\n    constructor() public {\r\n        roundId = 1;\r\n        timeInADay = 86400; // 86400 seconds in a day\r\n        timeInAWeek = 604800; // 604800 seconds in a week\r\n        roundEndTime = now + timeInAWeek; // round 1 end time 604800 seconds=7 days\r\n        startOfNewDay = now + timeInADay;\r\n        stakeMultiplier = 1100;\r\n        totalStake = 1000000000; \r\n    }\r\n\r\n\r\n\r\n    function() external payable {\r\n        require(msg.value >= 10000000000000000 && msg.value < 1000000000000000000000, \"0.01 ETH minimum.\"); // Minimum stake buy is 0.01 ETH, max 1000\r\n\r\n        if(now > roundEndTime){ // Check if round is over, then start new round. \r\n            startNewRound();\r\n        }\r\n\r\n        uint stakeBought = msg.value.mul(stakeMultiplier);\r\n        stakeBought = stakeBought.div(1000);\r\n        playerDivsInADay[roundId][day].playerStakeAtDay[msg.sender] += stakeBought;\r\n        leadAddress = msg.sender;\r\n        totalStake += stakeBought;\r\n        addTime(stakeBought); // Add time based on amount bought\r\n        emit InvestReceipt(msg.sender, stakeBought);\r\n    }\r\n\r\n    // Referrals only work with this function\r\n    function buyStakeWithEth(address _referrer) public payable {\r\n        require(msg.value >= 10000000000000000, \"0.01 ETH minimum.\");\r\n        if(_referrer != address(0)){\r\n                uint _referralBonus = msg.value.div(50); // 2% referral\r\n                if(_referrer == msg.sender) {\r\n                    _referrer = 0x93D43eeFcFbE8F9e479E172ee5d92DdDd2600E3b; // if user tries to refer himself\r\n                }\r\n                playerDivsInADay[roundId][day].playerStakeAtDay[_referrer] += _referralBonus;\r\n        }\r\n        if(now > roundEndTime){\r\n            startNewRound();\r\n        }\r\n\r\n        uint stakeBought = msg.value.mul(stakeMultiplier);\r\n        stakeBought = stakeBought.div(1000);\r\n        playerDivsInADay[roundId][day].playerStakeAtDay[msg.sender] += stakeBought;\r\n        leadAddress = msg.sender;\r\n        totalStake += stakeBought;\r\n        addTime(stakeBought);\r\n        emit InvestReceipt(msg.sender, stakeBought);\r\n    }\r\n    \r\n\r\n    // Message stored forever, but only displayed on the site when your address is leading\r\n    function addMessage(string memory _message) public {\r\n        bytes memory _messageBytes = bytes(_message);\r\n        require(_messageBytes.length >= playerMessageMinLength, \"Too short\");\r\n        require(_messageBytes.length <= playerMessageMaxLength, \"Too long\");\r\n        playerMessage[msg.sender] = _message;\r\n    }\r\n    function getMessage(address _playerAddress)\r\n    external\r\n    view\r\n    returns (\r\n      string memory playerMessage_\r\n  ) {\r\n      playerMessage_ = playerMessage[_playerAddress];\r\n  }\r\n      // Name stored forever, but only displayed on the site when your address is leading\r\n    function addName(string memory _name) public {\r\n        bytes memory _messageBytes = bytes(_name);\r\n        require(_messageBytes.length >= playerMessageMinLength, \"Too short\");\r\n        require(_messageBytes.length <= playerMessageMaxLength, \"Too long\");\r\n        playerName[msg.sender] = _name;\r\n    }\r\n  \r\n    function getName(address _playerAddress)\r\n    external\r\n    view\r\n    returns (\r\n      string memory playerName_\r\n  ) {\r\n      playerName_ = playerName[_playerAddress];\r\n  }\r\n   \r\n    \r\n    function getPlayerCurrentRoundDivs(address _playerAddress) public view returns(uint playerTotalDivs) {\r\n        uint _playerTotalDivs;\r\n        uint _playerRollingStake;\r\n        for(uint c = 0 ; c < day; c++) { //iterate through all days of current round \r\n            uint _playerStakeAtDay = playerDivsInADay[roundId][c].playerStakeAtDay[_playerAddress];\r\n            if(_playerStakeAtDay == 0 && _playerRollingStake == 0){\r\n                    continue; //if player has no stake then continue out to save gas\r\n                }\r\n            _playerRollingStake += _playerStakeAtDay;\r\n            uint _revenueAtDay = playerDivsInADay[roundId][c].revenueAtDay;\r\n            uint _totalStakeAtDay = playerDivsInADay[roundId][c].totalStakeAtDay;\r\n            uint _playerShareAtDay = _playerRollingStake.mul(_revenueAtDay)/_totalStakeAtDay;\r\n            _playerTotalDivs += _playerShareAtDay;\r\n        }\r\n        return _playerTotalDivs.div(2); // Divide by 2, 50% goes to players as dividends, 50% goes to the jackpot.\r\n    }\r\n    \r\n    function getPlayerPreviousRoundDivs(address _playerAddress) public view returns(uint playerPreviousRoundDivs) {\r\n        uint _playerPreviousRoundDivs;\r\n        for(uint r = 1 ; r < roundId; r++) { // Iterate through all previous rounds \r\n            uint _playerRollingStake;\r\n            uint _lastDay = roundIdToDays[r];\r\n            for(uint p = 0 ; p < _lastDay; p++) { //iterate through all days of previous round \r\n                uint _playerStakeAtDay = playerDivsInADay[r][p].playerStakeAtDay[_playerAddress];\r\n                if(_playerStakeAtDay == 0 && _playerRollingStake == 0){\r\n                        continue; // If player has no stake then continue to next day to save gas\r\n                    }\r\n                _playerRollingStake += _playerStakeAtDay;\r\n                uint _revenueAtDay = playerDivsInADay[r][p].revenueAtDay;\r\n                uint _totalStakeAtDay = playerDivsInADay[r][p].totalStakeAtDay;\r\n                uint _playerShareAtDay = _playerRollingStake.mul(_revenueAtDay)/_totalStakeAtDay;\r\n                _playerPreviousRoundDivs += _playerShareAtDay;\r\n            }\r\n        }\r\n        return _playerPreviousRoundDivs.div(2); // Divide by 2, 50% goes to players as dividends, 50% goes to the jackpot.\r\n    }\r\n    \r\n    function getPlayerTotalDivs(address _playerAddress) public view returns(uint PlayerTotalDivs) {\r\n        uint _playerTotalDivs;\r\n        _playerTotalDivs += getPlayerPreviousRoundDivs(_playerAddress);\r\n        _playerTotalDivs += getPlayerCurrentRoundDivs(_playerAddress);\r\n        \r\n        return _playerTotalDivs;\r\n    }\r\n    \r\n    function getPlayerCurrentStake(address _playerAddress) public view returns(uint playerCurrentStake) {\r\n        uint _playerRollingStake;\r\n        for(uint c = 0 ; c <= day; c++) { //iterate through all days of current round \r\n            uint _playerStakeAtDay = playerDivsInADay[roundId][c].playerStakeAtDay[_playerAddress];\r\n            if(_playerStakeAtDay == 0 && _playerRollingStake == 0){\r\n                    continue; //if player has no stake then continue out to save gas\r\n                }\r\n            _playerRollingStake += _playerStakeAtDay;\r\n        }\r\n        return _playerRollingStake;\r\n    }\r\n    \r\n\r\n    // Buy a stake using your earned dividends from past or current round\r\n    function reinvestDivs(uint _divs) external{\r\n        require(_divs >= 10000000000000000, \"You need at least 0.01 ETH in dividends.\");\r\n        uint _senderDivs = getPlayerTotalDivs(msg.sender);\r\n        spentDivs[msg.sender] += _divs;\r\n        uint _spentDivs = spentDivs[msg.sender];\r\n        uint _availableDivs = _senderDivs.sub(_spentDivs);\r\n        require(_availableDivs >= 0);\r\n        if(now > roundEndTime){\r\n            startNewRound();\r\n        }\r\n        playerDivsInADay[roundId][day].playerStakeAtDay[msg.sender] += _divs;\r\n        leadAddress = msg.sender;\r\n        totalStake += _divs;\r\n        addTime(_divs);\r\n        emit InvestReceipt(msg.sender, _divs);\r\n    }\r\n    // Turn your earned dividends from past or current rounds into Ether\r\n    function withdrawDivs(uint _divs) external{\r\n        require(_divs >= 10000000000000000, \"You need at least 0.01 ETH in dividends.\");\r\n        uint _senderDivs = getPlayerTotalDivs(msg.sender);\r\n        spentDivs[msg.sender] += _divs;\r\n        uint _spentDivs = spentDivs[msg.sender];\r\n        uint _availableDivs = _senderDivs.sub(_spentDivs);\r\n        require(_availableDivs >= 0);\r\n        msg.sender.transfer(_divs);\r\n        emit CashedOut(msg.sender, _divs);\r\n    }\r\n    // Reinvests all of a players dividends using contract, for people without MetaMask\r\n    function reinvestDivsWithContract(address payable _reinvestor) external{ \r\n        require(msg.sender == reinvestmentContractAddress);\r\n        uint _senderDivs = getPlayerTotalDivs(_reinvestor);\r\n        uint _spentDivs = spentDivs[_reinvestor];\r\n        uint _availableDivs = _senderDivs.sub(_spentDivs);\r\n        spentDivs[_reinvestor] += _senderDivs;\r\n        require(_availableDivs >= 10000000000000000, \"You need at least 0.01 ETH in dividends.\");\r\n        if(now > roundEndTime){\r\n            startNewRound();\r\n        }\r\n        playerDivsInADay[roundId][day].playerStakeAtDay[_reinvestor] += _availableDivs;\r\n        leadAddress = _reinvestor;\r\n        totalStake += _availableDivs;\r\n        addTime(_availableDivs);\r\n        emit InvestReceipt(msg.sender, _availableDivs);\r\n    }\r\n    // Withdraws all of a players dividends using contract, for people without MetaMask\r\n    function withdrawDivsWithContract(address payable _withdrawer) external{ \r\n        require(msg.sender == withdrawalContractAddress);\r\n        uint _senderDivs = getPlayerTotalDivs(_withdrawer);\r\n        uint _spentDivs = spentDivs[_withdrawer];\r\n        uint _availableDivs = _senderDivs.sub(_spentDivs);\r\n        spentDivs[_withdrawer] += _availableDivs;\r\n        require(_availableDivs >= 0);\r\n        _withdrawer.transfer(_availableDivs);\r\n        emit CashedOut(_withdrawer, _availableDivs);\r\n    }\r\n    \r\n    // Time functions\r\n    function addTime(uint _stakeBought) private {\r\n        uint _timeAdd = _stakeBought/1000000000000; //1000000000000 0.01 ETH adds 2.77 hours\r\n        if(_timeAdd < timeInADay){\r\n            roundEndTime += _timeAdd;\r\n        }else{\r\n        roundEndTime += timeInADay; //24 hour cap\r\n        }\r\n            \r\n        if(now > startOfNewDay) { //check if 24 hours has passed\r\n            startNewDay();\r\n        }\r\n    }\r\n    \r\n    function startNewDay() private {\r\n        playerDivsInADay[roundId][day].totalStakeAtDay = totalStake;\r\n        playerDivsInADay[roundId][day].revenueAtDay = totalStake - playerDivsInADay[roundId][day-1].totalStakeAtDay; //div revenue today = pot today - pot yesterday\r\n        if(stakeMultiplier > 1000) {\r\n            stakeMultiplier -= 1;\r\n        }\r\n        startOfNewDay = now + timeInADay;\r\n        ++day;\r\n    }\r\n\r\n    function startNewRound() private { \r\n        playerDivsInADay[roundId][day].totalStakeAtDay = totalStake; //commit last changes to ending round\r\n        playerDivsInADay[roundId][day].revenueAtDay = totalStake - playerDivsInADay[roundId][day-1].totalStakeAtDay; //div revenue today = pot today - pot yesterday\r\n        roundIdToDays[roundId] = day; //save last day of ending round\r\n        jackpot();\r\n        resetRound();\r\n    }\r\n    function jackpot() private {\r\n        uint winnerShare = playerDivsInADay[roundId][day].totalStakeAtDay.div(2) + seed[roundId]; //add last seed to pot\r\n        seed[roundId+1] = totalStake.div(10); //10% of pot to seed next round\r\n        winnerShare -= seed[roundId+1];\r\n        leadAddress.transfer(winnerShare);\r\n        emit CashedOut(leadAddress, winnerShare);\r\n    }\r\n    function resetRound() private {\r\n        roundId += 1;\r\n        roundEndTime = now + timeInAWeek;  //add 1 week time to start next round\r\n        startOfNewDay = now; // save day start time, multiplier decreases 0.1%/day\r\n        day = 0;\r\n        stakeMultiplier = 1100;\r\n        totalStake = 10000000;\r\n    }\r\n\r\n    function returnTimeLeft()\r\n     public view\r\n     returns(uint256) {\r\n     return(roundEndTime.sub(now));\r\n     }\r\n     \r\n    function returnDayTimeLeft()\r\n     public view\r\n     returns(uint256) {\r\n     return(startOfNewDay.sub(now));\r\n     }\r\n     \r\n    function returnSeedAtRound(uint _roundId)\r\n     public view\r\n     returns(uint256) {\r\n     return(seed[_roundId]);\r\n     }\r\n    function returnjackpot()\r\n     public view \r\n     returns(uint256){\r\n        uint winnerShare = totalStake/2 + seed[roundId]; //add last seed to pot\r\n        uint nextseed = totalStake/10; //10% of pot to seed next round\r\n        winnerShare -= nextseed;\r\n        return winnerShare;\r\n    }\r\n    function returnEarningsAtDay(uint256 _roundId, uint256 _day, address _playerAddress)\r\n     public view \r\n     returns(uint256){\r\n        uint earnings = playerDivsInADay[_roundId][_day].playerStakeAtDay[_playerAddress];\r\n        return earnings;\r\n    }\r\n      function setWithdrawalAndReinvestmentContracts(address _withdrawalContractAddress, address _reinvestmentContractAddress) external onlyOwner {\r\n    withdrawalContractAddress = _withdrawalContractAddress;\r\n    reinvestmentContractAddress = _reinvestmentContractAddress;\r\n  }\r\n}\r\n\r\ncontract ReinvestmentContract {\r\n    \r\n    address payable public etherStakeAddress;\r\n    address payable public owner;\r\n    \r\n    \r\n    constructor(address payable _etherStakeAddress) public {\r\n        etherStakeAddress = _etherStakeAddress;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function() external payable{\r\n        require(msg.value >= 10000000000000000, \"0.01 ETH Fee\");\r\n        EtherStake instanceEtherStake = EtherStake(etherStakeAddress);\r\n        instanceEtherStake.reinvestDivsWithContract(msg.sender);\r\n    }\r\n    \r\n    function collectFees() external {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherStakeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_etherStakeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ReinvestmentContract","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000012052cfcdc8044f021b764b71d8855a06543abd","Library":"","SwarmSource":"bzzr://463921cceae9c0ed9d1ae71a7485dbbf0c751a7b68c892eece26b1f5c73c5356"}]}