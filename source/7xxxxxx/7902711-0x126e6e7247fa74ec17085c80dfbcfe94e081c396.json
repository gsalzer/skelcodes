{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface INMR {\r\n\r\n    /* ERC20 Interface */\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /* NMR Special Interface */\r\n\r\n    // used for user balance management\r\n    function withdraw(address _from, address _to, uint256 _value) external returns(bool ok);\r\n\r\n    // used for migrating active stakes\r\n    function destroyStake(address _staker, bytes32 _tag, uint256 _tournamentID, uint256 _roundID) external returns (bool ok);\r\n\r\n    // used for disabling token upgradability\r\n    function createRound(uint256, uint256, uint256, uint256) external returns (bool ok);\r\n\r\n    // used for upgrading the token delegate logic\r\n    function createTournament(uint256 _newDelegate) external returns (bool ok);\r\n\r\n    // used like burn(uint256)\r\n    function mint(uint256 _value) external returns (bool ok);\r\n\r\n    // used like burnFrom(address, uint256)\r\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\r\n\r\n    // used to check if upgrade completed\r\n    function contractUpgradable() external view returns (bool);\r\n\r\n    function getTournament(uint256 _tournamentID) external view returns (uint256, uint256[] memory);\r\n\r\n    function getRound(uint256 _tournamentID, uint256 _roundID) external view returns (uint256, uint256, uint256);\r\n\r\n    function getStake(uint256 _tournamentID, uint256 _roundID, address _staker, bytes32 _tag) external view returns (uint256, uint256, bool, bool);\r\n\r\n}\r\n\r\n\r\ncontract NMRUser {\r\n\r\n    address internal constant _TOKEN = address(0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671);\r\n\r\n    function _burn(uint256 _value) internal {\r\n        if (INMR(_TOKEN).contractUpgradable())\r\n            require(INMR(_TOKEN).transfer(address(0), _value));\r\n        else\r\n            require(INMR(_TOKEN).mint(_value), \"burn not successful\");\r\n    }\r\n\r\n    function _burnFrom(address _from, uint256 _value) internal {\r\n        if (INMR(_TOKEN).contractUpgradable())\r\n            require(INMR(_TOKEN).transferFrom(_from, address(0), _value));\r\n        else\r\n            require(INMR(_TOKEN).numeraiTransfer(_from, _value), \"burnFrom not successful\");\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SpankJar\r\n * @dev Contract that allows for spanking using NMR\r\n */\r\ncontract SpankJar is NMRUser {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    address public owner;\r\n    uint256 public ratio;\r\n    bool public isActive = true;\r\n    \r\n    constructor(uint256 _ratio) public {\r\n        ratio = _ratio;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function() external payable {\r\n        require(isActive, 'already ended');\r\n    }\r\n    \r\n    event Ended(uint256 nmrBurned, uint256 ethBurned);\r\n    \r\n    function end() public {\r\n        require(msg.sender == owner, 'not sender');\r\n        require(isActive, 'already ended');\r\n        \r\n        uint256 punishment = getTotalPunishment();\r\n        uint256 balance = getRemainingBalance();\r\n        \r\n        _burn(punishment);\r\n        \r\n        require(INMR(_TOKEN).transfer(msg.sender, balance));\r\n        \r\n        isActive = false;\r\n        \r\n        emit Ended(punishment, address(this).balance);\r\n    }\r\n    \r\n    function getTotalPunishment() public view returns (uint256 punishment) {\r\n        return address(this).balance.mul(ratio);\r\n    }\r\n    \r\n    function getRemainingBalance() public view returns (uint256 balance) {\r\n        balance = INMR(_TOKEN).balanceOf(address(this));\r\n        uint256 punishment = getTotalPunishment();\r\n        balance = (punishment > balance) ? 0 : balance.sub(punishment);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPunishment\",\"outputs\":[{\"name\":\"punishment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nmrBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethBurned\",\"type\":\"uint256\"}],\"name\":\"Ended\",\"type\":\"event\"}]","ContractName":"SpankJar","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000019","Library":"","SwarmSource":"bzzr://92e8cf658726e558008b384747784930b3af6738d4025f3a84cc9c36e54487dc"}]}