{"status":"1","message":"OK","result":[{"SourceCode":"{\"DelegateProxy.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract DelegateProxy {\\n  /**\\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\\n  * @param _dst Destination address to perform the delegatecall\\n  * @param _calldata Calldata for the delegatecall\\n  */\\n  function delegatedFwd(address _dst, bytes _calldata) internal {\\n    require(isContract(_dst));\\n    assembly {\\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n      let size := returndatasize\\n\\n      let ptr := mload(0x40)\\n      returndatacopy(ptr, 0, size)\\n\\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n    // if the call returned error data, forward it\\n      switch result case 0 {revert(ptr, size)}\\n      default {return (ptr, size)}\\n    }\\n  }\\n\\n  function isContract(address _target) internal view returns (bool) {\\n    uint256 size;\\n    assembly {size := extcodesize(_target)}\\n    return size \\u003e 0;\\n  }\\n}\"},\"DSAuth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\ncontract DSAuthority {\\n  function canCall(\\n    address src, address dst, bytes4 sig\\n  ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n  event LogSetAuthority (address indexed authority);\\n  event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n  DSAuthority  public  authority;\\n  address      public  owner;\\n\\n  function DSAuth() public {\\n    owner = msg.sender;\\n    LogSetOwner(msg.sender);\\n  }\\n\\n  function setOwner(address owner_)\\n  public\\n  auth\\n  {\\n    owner = owner_;\\n    LogSetOwner(owner);\\n  }\\n\\n  function setAuthority(DSAuthority authority_)\\n  public\\n  auth\\n  {\\n    authority = authority_;\\n    LogSetAuthority(authority);\\n  }\\n\\n  modifier auth {\\n    require(isAuthorized(msg.sender, msg.sig));\\n    _;\\n  }\\n\\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n    if (src == address(this)) {\\n      return true;\\n    } else if (src == owner) {\\n      return true;\\n    } else if (authority == DSAuthority(0)) {\\n      return false;\\n    } else {\\n      return authority.canCall(src, this, sig);\\n    }\\n  }\\n}\\n\"},\"EternalDb.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Contract to store arbitrary state data, decoupled from any logic related to it\\n *\\n * @dev Original implementation: https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88\\n * In addition to original implementation, this contract uses DSAuth for more advanced authentication options\\n * It also provides way set/get multiple values in single transaction\\n */\\n\\ncontract EternalDb is DSAuth {\\n\\n  enum Types {UInt, String, Address, Bytes, Bytes32, Boolean, Int}\\n\\n  event EternalDbEvent(bytes32[] records, uint[] values, uint timestamp);\\n\\n  function EternalDb(){\\n  }\\n\\n  ////////////\\n  //UInt\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e uint) UIntStorage;\\n\\n  function getUIntValue(bytes32 record) constant returns (uint){\\n    return UIntStorage[record];\\n  }\\n\\n  function getUIntValues(bytes32[] records) constant returns (uint[] results){\\n    results = new uint[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = UIntStorage[records[i]];\\n    }\\n  }\\n\\n  function setUIntValue(bytes32 record, uint value)\\n  auth\\n  {\\n    UIntStorage[record] = value;\\n    bytes32[] memory records = new bytes32[](1);\\n    records[0] = record;\\n    uint[] memory values = new uint[](1);\\n    values[0] = value;\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function setUIntValues(bytes32[] records, uint[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      UIntStorage[records[i]] = values[i];\\n    }\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function deleteUIntValue(bytes32 record)\\n  auth\\n  {\\n    delete UIntStorage[record];\\n  }\\n\\n  ////////////\\n  //Strings\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e string) StringStorage;\\n\\n  function getStringValue(bytes32 record) constant returns (string){\\n    return StringStorage[record];\\n  }\\n\\n  function setStringValue(bytes32 record, string value)\\n  auth\\n  {\\n    StringStorage[record] = value;\\n  }\\n\\n  function deleteStringValue(bytes32 record)\\n  auth\\n  {\\n    delete StringStorage[record];\\n  }\\n\\n  ////////////\\n  //Address\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e address) AddressStorage;\\n\\n  function getAddressValue(bytes32 record) constant returns (address){\\n    return AddressStorage[record];\\n  }\\n\\n  function setAddressValues(bytes32[] records, address[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      AddressStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function setAddressValue(bytes32 record, address value)\\n  auth\\n  {\\n    AddressStorage[record] = value;\\n  }\\n\\n  function deleteAddressValue(bytes32 record)\\n  auth\\n  {\\n    delete AddressStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes) BytesStorage;\\n\\n  function getBytesValue(bytes32 record) constant returns (bytes){\\n    return BytesStorage[record];\\n  }\\n\\n  function setBytesValue(bytes32 record, bytes value)\\n  auth\\n  {\\n    BytesStorage[record] = value;\\n  }\\n\\n  function deleteBytesValue(bytes32 record)\\n  auth\\n  {\\n    delete BytesStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes32\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes32) Bytes32Storage;\\n\\n  function getBytes32Value(bytes32 record) constant returns (bytes32){\\n    return Bytes32Storage[record];\\n  }\\n\\n  function getBytes32Values(bytes32[] records) constant returns (bytes32[] results){\\n    results = new bytes32[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = Bytes32Storage[records[i]];\\n    }\\n  }\\n\\n  function setBytes32Value(bytes32 record, bytes32 value)\\n  auth\\n  {\\n    Bytes32Storage[record] = value;\\n  }\\n\\n  function setBytes32Values(bytes32[] records, bytes32[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      Bytes32Storage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBytes32Value(bytes32 record)\\n  auth\\n  {\\n    delete Bytes32Storage[record];\\n  }\\n\\n  ////////////\\n  //Boolean\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bool) BooleanStorage;\\n\\n  function getBooleanValue(bytes32 record) constant returns (bool){\\n    return BooleanStorage[record];\\n  }\\n\\n  function getBooleanValues(bytes32[] records) constant returns (bool[] results){\\n    results = new bool[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = BooleanStorage[records[i]];\\n    }\\n  }\\n\\n  function setBooleanValue(bytes32 record, bool value)\\n  auth\\n  {\\n    BooleanStorage[record] = value;\\n  }\\n\\n  function setBooleanValues(bytes32[] records, bool[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      BooleanStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBooleanValue(bytes32 record)\\n  auth\\n  {\\n    delete BooleanStorage[record];\\n  }\\n\\n  ////////////\\n  //Int\\n  ////////////\\n  mapping(bytes32 =\\u003e int) IntStorage;\\n\\n  function getIntValue(bytes32 record) constant returns (int){\\n    return IntStorage[record];\\n  }\\n\\n  function getIntValues(bytes32[] records) constant returns (int[] results){\\n    results = new int[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = IntStorage[records[i]];\\n    }\\n  }\\n\\n  function setIntValue(bytes32 record, int value)\\n  auth\\n  {\\n    IntStorage[record] = value;\\n  }\\n\\n  function setIntValues(bytes32[] records, int[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      IntStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteIntValue(bytes32 record)\\n  auth\\n  {\\n    delete IntStorage[record];\\n  }\\n\\n}\\n\"},\"MutableForwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Forwarder proxy contract with editable target\\n *\\n * @dev For TCR Registry contracts (Registry.sol, ParamChangeRegistry.sol) we use mutable forwarders instead of using\\n * contracts directly. This is for better upgradeability. Since registry contracts fire all events related to registry\\n * entries, we want to be able to access whole history of events always on the same address. Which would be address of\\n * a MutableForwarder. When a registry contract is replaced with updated one, mutable forwarder just replaces target\\n * and all events stay still accessible on the same address.\\n */\\n\\ncontract MutableForwarder is DelegateProxy, DSAuth {\\n\\n  address public target = 0xBEeFbeefbEefbeEFbeEfbEEfBEeFbeEfBeEfBeef; // checksumed to silence warning\\n\\n  /**\\n   * @dev Replaces targer forwarder contract is pointing to\\n   * Only authenticated user can replace target\\n\\n   * @param _target New target to proxy into\\n  */\\n  function setTarget(address _target) public auth {\\n    target = _target;\\n  }\\n\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n\\n}\"},\"Registry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./DSAuth.sol\\\";\\nimport \\\"./EternalDb.sol\\\";\\nimport \\\"./MutableForwarder.sol\\\"; // Keep it included despite not being used (for compiler)\\n\\n/**\\n * @title Central contract for TCR registry\\n *\\n * @dev Manages state about deployed registry entries and factories\\n * Serves as a central point for firing all registry entry events\\n * This contract is not accessed directly, but through MutableForwarder. See MutableForwarder.sol for more comments.\\n */\\n\\ncontract Registry is DSAuth {\\n  address private dummyTarget; // Keep it here, because this contract is deployed as MutableForwarder\\n\\n  bytes32 public constant challengePeriodDurationKey = sha3(\\\"challengePeriodDuration\\\");\\n  bytes32 public constant commitPeriodDurationKey = sha3(\\\"commitPeriodDuration\\\");\\n  bytes32 public constant revealPeriodDurationKey = sha3(\\\"revealPeriodDuration\\\");\\n  bytes32 public constant depositKey = sha3(\\\"deposit\\\");\\n  bytes32 public constant challengeDispensationKey = sha3(\\\"challengeDispensation\\\");\\n  bytes32 public constant voteQuorumKey = sha3(\\\"voteQuorum\\\");\\n  bytes32 public constant maxTotalSupplyKey = sha3(\\\"maxTotalSupply\\\");\\n  bytes32 public constant maxAuctionDurationKey = sha3(\\\"maxAuctionDuration\\\");\\n\\n  event MemeConstructedEvent(address registryEntry, uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd);\\n  event MemeMintedEvent(address registryEntry, uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted);\\n\\n  event ChallengeCreatedEvent(address registryEntry, uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash);\\n  event VoteCommittedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event VoteRevealedEvent(address registryEntry, uint version, address voter, uint option);\\n  event VoteAmountClaimedEvent(address registryEntry, uint version, address voter);\\n  event VoteRewardClaimedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event ChallengeRewardClaimedEvent(address registryEntry, uint version, address challenger, uint amount);\\n\\n  event ParamChangeConstructedEvent(address registryEntry, uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd);\\n  event ParamChangeAppliedEvent(address registryEntry, uint version);\\n\\n  EternalDb public db;\\n  bool private wasConstructed;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because we use a forwarder pointing to single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n\\n   * @param _db Address of EternalDb related to this registry\\n   */\\n  function construct(EternalDb _db)\\n  external\\n  {\\n    require(address(_db) != 0x0, \\\"Registry: Address can\\u0027t be 0x0\\\");\\n\\n    db = _db;\\n    wasConstructed = true;\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyFactory() {\\n    require(isFactory(msg.sender), \\\"Registry: Sender should be factory\\\");\\n    _;\\n  }\\n\\n  modifier onlyRegistryEntry() {\\n    require(isRegistryEntry(msg.sender), \\\"Registry: Sender should registry entry\\\");\\n    _;\\n  }\\n\\n  modifier notEmergency() {\\n    require(!isEmergency(),\\\"Registry: Emergency mode is enable\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Sets whether address is factory allowed to add registry entries into registry\\n   * Must be callable only by authenticated user\\n\\n   * @param _factory Address of a factory contract\\n   * @param _isFactory Whether the address is allowed factory\\n   */\\n  function setFactory(address _factory, bool _isFactory)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(sha3(\\\"isFactory\\\", _factory), _isFactory);\\n  }\\n\\n  /**\\n   * @dev Adds address as valid registry entry into the Registry\\n   * Must be callable only by allowed factory contract\\n\\n   * @param _registryEntry Address of new registry entry\\n   */\\n  function addRegistryEntry(address _registryEntry)\\n  external\\n  onlyFactory\\n  notEmergency\\n  {\\n    db.setBooleanValue(sha3(\\\"isRegistryEntry\\\", _registryEntry), true);\\n  }\\n\\n  /**\\n   * @dev Sets emergency state to pause all trading operations\\n   * Must be callable only by authenticated user\\n\\n   * @param _isEmergency True if emergency is happening\\n   */\\n  function setEmergency(bool _isEmergency)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(\\\"isEmergency\\\", _isEmergency);\\n  }\\n\\n  function fireMemeConstructedEvent(uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeConstructedEvent(msg.sender, version, creator, metaHash, totalSupply, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireMemeMintedEvent(uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeMintedEvent(msg.sender, version, creator, tokenStartId, tokenEndId, totalMinted);\\n  }\\n\\n  function fireChallengeCreatedEvent(uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeCreatedEvent(msg.sender, version,  challenger, commitPeriodEnd, revealPeriodEnd, rewardPool, metahash);\\n  }\\n\\n  function fireVoteCommittedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteCommittedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireVoteRevealedEvent(uint version, address voter, uint option)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRevealedEvent(msg.sender, version, voter, option);\\n  }\\n\\n  function fireVoteAmountClaimedEvent(uint version, address voter)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteAmountClaimedEvent(msg.sender, version, voter);\\n  }\\n\\n  function fireVoteRewardClaimedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRewardClaimedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireChallengeRewardClaimedEvent(uint version, address challenger, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeRewardClaimedEvent(msg.sender, version, challenger, amount);\\n  }\\n\\n  function fireParamChangeConstructedEvent(uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeConstructedEvent(msg.sender, version, creator, db, key, value, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireParamChangeAppliedEvent(uint version)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeAppliedEvent(msg.sender, version);\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry factory\\n\\n   * @return True if address is factory\\n   */\\n  function isFactory(address factory) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isFactory\\\", factory));\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry\\n\\n   * @return True if address is registry entry\\n   */\\n  function isRegistryEntry(address registryEntry) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isRegistryEntry\\\", registryEntry));\\n  }\\n\\n  /**\\n   * @dev Returns whether emergency stop is happening\\n\\n   * @return True if emergency is happening\\n   */\\n  function isEmergency() public constant returns (bool) {\\n    return db.getBooleanValue(\\\"isEmergency\\\");\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"challengeDispensationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isEmergency\",\"type\":\"bool\"}],\"name\":\"setEmergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"isFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAuctionDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"db\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"db\",\"type\":\"address\"},{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"fireParamChangeConstructedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"fireVoteRevealedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"fireParamChangeAppliedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEmergency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revealPeriodDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengePeriodDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"registryEntry\",\"type\":\"address\"}],\"name\":\"isRegistryEntry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_isFactory\",\"type\":\"bool\"}],\"name\":\"setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registryEntry\",\"type\":\"address\"}],\"name\":\"addRegistryEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fireVoteRewardClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitPeriodDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metaHash\",\"type\":\"bytes\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"fireMemeConstructedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"fireVoteAmountClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fireChallengeRewardClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fireVoteCommittedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupplyKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voteQuorumKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"tokenStartId\",\"type\":\"uint256\"},{\"name\":\"tokenEndId\",\"type\":\"uint256\"},{\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"name\":\"fireMemeMintedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"commitPeriodEnd\",\"type\":\"uint256\"},{\"name\":\"revealPeriodEnd\",\"type\":\"uint256\"},{\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"name\":\"metahash\",\"type\":\"bytes\"}],\"name\":\"fireChallengeCreatedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_db\",\"type\":\"address\"}],\"name\":\"construct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"metaHash\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"MemeConstructedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenStartId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenEndId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"name\":\"MemeMintedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commitPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"revealPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metahash\",\"type\":\"bytes\"}],\"name\":\"ChallengeCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VoteCommittedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"VoteRevealedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoteAmountClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VoteRewardClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChallengeRewardClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"db\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"ParamChangeConstructedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ParamChangeAppliedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"Registry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7e5e47898c38b6dccc483369c005ce7be176784c76f0f675d21b7969c506699c"}]}