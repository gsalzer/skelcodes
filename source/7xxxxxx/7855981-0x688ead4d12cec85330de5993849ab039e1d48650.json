{"status":"1","message":"OK","result":[{"SourceCode":"// File: zos-lib/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/AvatarNameStorage.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ERC20Interface {\r\n    function balanceOf(address from) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function burn(uint256 amount) public;\r\n}\r\n\r\ncontract AvatarNameStorage {\r\n    // Storage\r\n    ERC20Interface public manaToken;\r\n    uint256 public blocksUntilReveal;\r\n    uint256 public price;\r\n\r\n    struct Data {\r\n        string username;\r\n        string metadata;\r\n    }\r\n    struct Commit {\r\n        bytes32 commit;\r\n        uint256 blockNumber;\r\n        bool revealed;\r\n    }\r\n\r\n    // Stores commit messages by accounts\r\n    mapping (address => Commit) public commit;\r\n    // Stores usernames used\r\n    mapping (string => address) usernames;\r\n    // Stores account data\r\n    mapping (address => Data) public user;\r\n    // Stores account roles\r\n    mapping (address => bool) public allowed;\r\n\r\n    // Events\r\n    event Register(\r\n        address indexed _owner,\r\n        string _username,\r\n        string _metadata,\r\n        address indexed _caller\r\n    );\r\n    event MetadataChanged(address indexed _owner, string _metadata);\r\n    event Allow(address indexed _caller, address indexed _account, bool _allowed);\r\n    event CommitUsername(address indexed _owner, bytes32 indexed _hash, uint256 _blockNumber);\r\n    event RevealUsername(address indexed _owner, bytes32 indexed _hash, uint256 _blockNumber);\r\n}\r\n\r\n// File: contracts/AvatarNameRegistry.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract AvatarNameRegistry is Initializable, AvatarNameStorage {\r\n\r\n    /**\r\n    * @dev Initializer of the contract\r\n    * @param _mana - address of the mana token\r\n    * @param _register - address of the user allowed to register usernames and assign the role\r\n    * @param _blocksUntilReveal - uint256 for the blocks that should pass before reveal a commit\r\n    */\r\n    function initialize(\r\n        ERC20Interface _mana,\r\n        address _register,\r\n        uint256 _blocksUntilReveal\r\n    )\r\n    public initializer\r\n    {\r\n        require(_blocksUntilReveal != 0, \"Blocks until reveal should be greather than 0\");\r\n\r\n\r\n        manaToken = _mana;\r\n        blocksUntilReveal = _blocksUntilReveal;\r\n        price = 100000000000000000000; // 100 in wei\r\n\r\n        // Allow deployer to register usernames\r\n        allowed[_register] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Check if the sender is an allowed account\r\n    */\r\n    modifier onlyAllowed() {\r\n        require(\r\n            allowed[msg.sender] == true,\r\n            \"The sender is not allowed to register a username\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Manage role for an account\r\n    * @param _account - address of the account to be managed\r\n    * @param _allowed - bool whether the account should be allowed or not\r\n    */\r\n    function setAllowed(address _account, bool _allowed) external onlyAllowed {\r\n        require(_account != msg.sender, \"You can not manage your role\");\r\n        allowed[_account] = _allowed;\r\n        emit Allow(msg.sender, _account, _allowed);\r\n    }\r\n\r\n    /**\r\n    * @dev Register a usename\r\n    * @notice that the username should be less than or equal 32 bytes and blanks are not allowed\r\n    * @param _beneficiary - address of the account to be managed\r\n    * @param _username - string for the username\r\n    * @param _metadata - string for the metadata\r\n    */\r\n    function _registerUsername(\r\n        address _beneficiary,\r\n        string memory _username,\r\n        string memory _metadata\r\n    )\r\n    internal\r\n    {\r\n        _requireUsernameValid(_username);\r\n        require(isUsernameAvailable(_username), \"The username was already taken\");\r\n\r\n        // Save username\r\n        usernames[_username] = _beneficiary;\r\n\r\n        Data storage data = user[_beneficiary];\r\n\r\n        // Free previous username\r\n        delete usernames[data.username];\r\n\r\n        // Set data\r\n        data.username = _username;\r\n\r\n        bytes memory metadata = bytes(_metadata);\r\n        if (metadata.length > 0) {\r\n            data.metadata = _metadata;\r\n        }\r\n\r\n        emit Register(\r\n            _beneficiary,\r\n            _username,\r\n            data.metadata,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Register a usename\r\n    * @notice that the username can only be registered by an allowed account\r\n    * @param _beneficiary - address of the account to be managed\r\n    * @param _username - string for the username\r\n    * @param _metadata - string for the metadata\r\n    */\r\n    function registerUsername(\r\n        address _beneficiary,\r\n        string calldata _username,\r\n        string calldata _metadata\r\n    )\r\n    external\r\n    onlyAllowed\r\n    {\r\n        _registerUsername(_beneficiary, _username, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @dev Commit a hash for a desire username\r\n    * @notice that the reveal should happen after the blocks defined on {blocksUntilReveal}\r\n    * @param _hash - bytes32 of the commit hash\r\n    */\r\n    function commitUsername(bytes32 _hash) public {\r\n        commit[msg.sender].commit = _hash;\r\n        commit[msg.sender].blockNumber = block.number;\r\n        commit[msg.sender].revealed = false;\r\n\r\n        emit CommitUsername(msg.sender, _hash, block.number);\r\n    }\r\n\r\n    /**\r\n    * @dev Reveal a commit\r\n    * @notice that the reveal should happen after the blocks defined on {blocksUntilReveal}\r\n    * @param _username - string for the username\r\n    * @param _metadata - string for the metadata\r\n    * @param _salt - bytes32 for the salt\r\n    */\r\n    function revealUsername(\r\n        string memory _username,\r\n        string memory _metadata,\r\n        bytes32 _salt\r\n    )\r\n    public\r\n    {\r\n        Commit storage userCommit = commit[msg.sender];\r\n\r\n        require(userCommit.commit != 0, \"User has not a commit to be revealed\");\r\n        require(userCommit.revealed == false, \"Commit was already revealed\");\r\n        require(\r\n            getHash(_username, _metadata, _salt) == userCommit.commit,\r\n            \"Revealed hash does not match commit\"\r\n        );\r\n        require(\r\n            block.number > userCommit.blockNumber + blocksUntilReveal,\r\n            \"Reveal can not be done before blocks passed\"\r\n        );\r\n\r\n        userCommit.revealed = true;\r\n\r\n        emit RevealUsername(msg.sender, userCommit.commit, block.number);\r\n\r\n        _registerUsername(msg.sender, _username, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @dev Return a bytes32 hash for the given arguments\r\n    * @param _username - string for the username\r\n    * @param _metadata - string for the metadata\r\n    * @param _salt - bytes32 for the salt\r\n    * @return bytes32 - for the hash of the given arguments\r\n    */\r\n    function getHash(\r\n        string memory _username,\r\n        string memory _metadata,\r\n        bytes32 _salt\r\n    )\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(address(this), _username, _metadata, _salt)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Set metadata for an existing user\r\n    * @param _metadata - string for the metadata\r\n    */\r\n    function setMetadata(string calldata _metadata) external {\r\n        require(userExists(msg.sender), \"The user does not exist\");\r\n\r\n        user[msg.sender].metadata = _metadata;\r\n        emit MetadataChanged(msg.sender, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether a user exist or not\r\n    * @param _user - address for the user\r\n    * @return bool - whether the user exist or not\r\n    */\r\n    function userExists(address _user) public view returns (bool) {\r\n        Data memory data = user[_user];\r\n        bytes memory username = bytes(data.username);\r\n        return username.length > 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether a username is available or not\r\n    * @param _username - string for the username\r\n    * @return bool - whether the username is available or not\r\n    */\r\n    function isUsernameAvailable(string memory _username) public view returns (bool) {\r\n        return usernames[_username] == address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Validate a username\r\n    * @param _username - string for the username\r\n    */\r\n    function _requireUsernameValid(string memory _username) internal pure {\r\n        bytes memory tempUsername = bytes(_username);\r\n        require(tempUsername.length <= 32, \"Username should be less than or equal 32 characters\");\r\n        for(uint256 i = 0; i < tempUsername.length; i++) {\r\n            require(tempUsername[i] != \" \", \"No blanks are allowed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Validate if a user has balance and the contract has enough allowance\r\n    * to use user MANA on his belhalf\r\n    * @param _user - address of the user\r\n    */\r\n    function _requireBalance(address _user) internal view {\r\n        require(\r\n            manaToken.balanceOf(_user) >= price,\r\n            \"Insufficient funds\"\r\n        );\r\n        require(\r\n            manaToken.allowance(_user, address(this)) >= price,\r\n            \"The contract is not authorized to use MANA on sender behalf\"\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mana\",\"type\":\"address\"},{\"name\":\"_register\",\"type\":\"address\"},{\"name\":\"_blocksUntilReveal\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksUntilReveal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"commit\",\"outputs\":[{\"name\":\"commit\",\"type\":\"bytes32\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"revealed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_metadata\",\"type\":\"string\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"getHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"commitUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manaToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"name\":\"username\",\"type\":\"string\"},{\"name\":\"metadata\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"registerUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_metadata\",\"type\":\"string\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"revealUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"isUsernameAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_username\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_metadata\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"MetadataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"Allow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"CommitUsername\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"RevealUsername\",\"type\":\"event\"}]","ContractName":"AvatarNameRegistry","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5e7d61e1463f64ab273c6945fb10aba0b14058d3b4c3ac123638bab74b2fe65d"}]}