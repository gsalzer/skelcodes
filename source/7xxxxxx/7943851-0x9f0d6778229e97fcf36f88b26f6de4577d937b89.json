{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * Open Zeppelin ERC20 implementation. https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20\\n */\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"SmartInvoice.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract SmartInvoice {\\n    enum Status { UNCOMMITTED, COMMITTED, SETTLED }\\n    function getStatusString(Status status)\\n    public\\n    pure\\n    returns (string memory)\\n    {\\n        if (Status.UNCOMMITTED == status) {\\n            return \\\"UNCOMMITTED\\\";\\n        }\\n        if (Status.COMMITTED == status) {\\n            return \\\"COMMITTED\\\";\\n        }\\n        if (Status.SETTLED == status) {\\n            return \\\"SETTLED\\\";\\n        }\\n        return \\\"ERROR\\\";\\n    }\\n\\n    uint256 public amount;\\n    uint256 public dueDate;\\n    IERC20 public assetToken;\\n    address public beneficiary;\\n    address public payer;\\n    string public referenceHash;\\n\\n    Status  public status;\\n\\n    /**\\n     * @dev Constructor that gives msg.sender all of existing tokens.\\n     */\\n    constructor(uint256 _amount,\\n                uint256 _dueDate,\\n                IERC20 _assetToken,\\n                address _beneficiary,\\n                address _payer,\\n                string memory _referenceHash) public {\\n        require(_beneficiary != address(0), \\\"beneficiary cannot be 0x0\\\");\\n        require(_payer != address(0), \\\"payer cannot be 0x0\\\");\\n        amount = _amount;\\n        dueDate = _dueDate;\\n        assetToken = _assetToken;\\n        beneficiary = _beneficiary;\\n        payer = _payer;\\n        referenceHash = _referenceHash;\\n\\n        status = Status.UNCOMMITTED;\\n    }\\n\\n    function changeBeneficiary(address _newBeneficiary) public returns (bool) {\\n        require(msg.sender == beneficiary, \\\"caller not current beneficiary\\\");\\n        require(_newBeneficiary != address(0), \\\"new beneficiary cannot be 0x0\\\");\\n        require(status != Status.SETTLED, \\\"can not change beneficiary after settlement\\\");\\n        beneficiary = _newBeneficiary;\\n        return true;\\n    }\\n\\n    function commit() public returns (bool) {\\n        require(msg.sender == payer, \\\"only payer can commit to settle\\\");\\n        require(status == Status.UNCOMMITTED, \\\"can only commit while status in UNCOMMITTED\\\");\\n        status = Status.COMMITTED;\\n        return true;\\n    }\\n\\n    function settle() public returns (bool) {\\n        require(msg.sender == payer, \\\"only payer can settle\\\");\\n        require(status != Status.SETTLED, \\\"already settled\\\");\\n        require(now \\u003e= dueDate, \\\"can only settle after due date\\\");\\n        require(assetToken.transferFrom(payer, beneficiary, amount), \\\"could not complete transfer\\\");\\n        status = Status.SETTLED;\\n        return true;\\n    }\\n\\n}\\n\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"getStatusString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assetToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referenceHash\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"commit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dueDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_dueDate\",\"type\":\"uint256\"},{\"name\":\"_assetToken\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_payer\",\"type\":\"address\"},{\"name\":\"_referenceHash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"SmartInvoice","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000246ddf97976680000000000000000000000000000000000000000000000000000000000005d00edf000000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359000000000000000000000000faacc228094be81d7c3f541644d3c8ee4c9a42310000000000000000000000005928196b511e4ded65bebf9417d620294a035ab100000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000083137303531393530000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://c53c6bbecbb0b832a681bf0f8df27079b47b92a768a7659eb9c7d354a275209e"}]}