{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract CryptoConstellationAccessControl  {\r\n    \r\n    address public ceoAddress;\r\n    address public ctoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    bool public paused = false;\r\n    \r\n    mapping (address => string) public userNickName;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyCTO() {\r\n        require(msg.sender == ctoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress ||\r\n            msg.sender == ctoAddress\r\n        );\r\n        _;\r\n    }\r\n    \r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n    \r\n    function setCTO(address _newCTO) external onlyCEO {\r\n        require(_newCTO != address(0));\r\n        ctoAddress = _newCTO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    function setNickName(address _user, string calldata _nickName) external returns (bool) {\r\n        require(_user != address(0));\r\n        userNickName[_user] = _nickName;\r\n    }\r\n\r\n    function getNickName(address _user) external view returns (string memory _nickname) {\r\n        require(_user != address(0));\r\n\r\n        _nickname = userNickName[_user];\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n    \r\n    function unpause() external onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract CryptoConstellationBase is CryptoConstellationAccessControl {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    event ConstellationCreation(address indexed _owner, uint256 indexed _tokenId);\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    event Bought (uint256 indexed _tokenId, address indexed _owner, uint256 _price);\r\n\r\n    event Sold (uint256 indexed _tokenId, address indexed _owner, uint256 _price);\r\n    \r\n    struct Constellation {\r\n        string name;\r\n        string description;\r\n        string ipfsHash;\r\n        uint64 creationTimestamp;\r\n    }\r\n\r\n    \r\n    uint256 internal increaseLimit1 = 0.02 ether;\r\n    uint256 internal increaseLimit2 = 0.5 ether;\r\n    uint256 internal increaseLimit3 = 2.0 ether;\r\n    uint256 internal increaseLimit4 = 5.0 ether;\r\n    \r\n    Constellation[] constellations;\r\n    \r\n    mapping (uint256 => address) public constellationCurrentOwner;\r\n    \r\n    mapping (address => uint256) internal ownershipTokenCount;\r\n\r\n    mapping (uint256 => uint256) internal startingPriceOfConstellation;\r\n\r\n    mapping (uint256 => uint256) internal priceOfConstellation;\r\n\r\n    mapping (uint256 => address) internal approvedOfConstellation;\r\n    \r\n    \r\n    modifier onlyOwner(uint _propId) {\r\n\t\trequire(constellationCurrentOwner[_propId] == msg.sender);\r\n\t\t_;\r\n\t}\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        \r\n        // Since the number of assets is capped to 2^32 we can't overflow this\r\n        ownershipTokenCount[_to]++;\r\n        // transfer ownership\r\n        constellationCurrentOwner[_tokenId] = _to;\r\n\r\n        approvedOfConstellation[_tokenId] = address(0);\r\n        // When creating new kittens _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n        }\r\n        // Emit the transfer event.\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n    \r\n    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\r\n        if (_price < increaseLimit1) {\r\n            return _price.mul(200).div(95);\r\n        } else if (_price < increaseLimit2) {\r\n            return _price.mul(135).div(96);\r\n        } else if (_price < increaseLimit3) {\r\n            return _price.mul(125).div(97);\r\n        } else if (_price < increaseLimit4) {\r\n            return _price.mul(117).div(97);\r\n        } else {\r\n            return _price.mul(115).div(98);\r\n        }\r\n    }\r\n\r\n    function calculateDevCut (uint256 _price) public view returns (uint256 _devCut) {\r\n        if (_price < increaseLimit1) {\r\n            return _price.mul(10).div(100); // 10%\r\n        } else if (_price < increaseLimit2) {\r\n            return _price.mul(9).div(100); // 9%\r\n        } else if (_price < increaseLimit3) {\r\n            return _price.mul(8).div(100); // 8%\r\n        } else if (_price < increaseLimit4) {\r\n            return _price.mul(7).div(100); // 7%\r\n        } else {\r\n            return _price.mul(6).div(100); // 6%\r\n        }\r\n    }\r\n\r\n    \r\n    function createConstellation(\r\n        string calldata _name,\r\n        string calldata _description,\r\n        string calldata _ipfsHash,\r\n        uint256 _price,\r\n        address _owner\r\n    )\r\n        external\r\n        whenNotPaused\r\n        onlyCLevel\r\n        returns (uint)\r\n    {\r\n        return _createConstellation(_name, _description, _ipfsHash, _price, _owner);\r\n    }\r\n    \r\n    function _createConstellation(\r\n        string memory _name,\r\n        string memory _description,\r\n        string memory _ipfsHash,\r\n        uint256 _price,\r\n        address _owner\r\n    )\r\n        internal\r\n        whenNotPaused\r\n        onlyCLevel\r\n        returns (uint)\r\n    {\r\n        \r\n        Constellation memory _constellation = Constellation({\r\n            name: _name,\r\n            description: _description,\r\n            ipfsHash: _ipfsHash,\r\n            creationTimestamp: uint64(block.timestamp)\r\n        });\r\n        uint256 newConstellationId = constellations.push(_constellation) - 1;\r\n\r\n        require(newConstellationId == uint256(uint32(newConstellationId)));\r\n\r\n        startingPriceOfConstellation[newConstellationId] = _price;\r\n        priceOfConstellation[newConstellationId] = _price;\r\n\r\n        // emit the birth event\r\n        emit ConstellationCreation(_owner, newConstellationId);\r\n\r\n        _transfer(address(0), _owner, newConstellationId);\r\n\r\n        return newConstellationId;\r\n    }\r\n   \r\n}\r\n\r\n\r\ncontract ERC721  {\r\n    \r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n    \r\n}\r\n\r\ncontract ERC721Metadata {\r\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\r\n    function getMetadata(uint256 _tokenId, string memory) public pure returns (bytes32[4] memory buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\ncontract CryptoConstellationOwnership is CryptoConstellationBase, ERC721 {\r\n    \r\n    string public constant name = \"CryptoConstellation\";\r\n    string public constant symbol = \"CCL\";\r\n\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)')) ^\r\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        \r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    function setMetadataAddress(address _contractAddress) public onlyCEO {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return constellationCurrentOwner[_tokenId] == _claimant;\r\n    }\r\n    \r\n    function _approvedFor(uint256 _tokenId) internal view returns (address) {\r\n        return approvedOfConstellation[_tokenId];\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _to) internal {\r\n        require(msg.sender != _to);\r\n        require(tokenExists(_tokenId));\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n\r\n        if (_to == address(0)) {\r\n            if (approvedOfConstellation[_tokenId] != address(0)) {\r\n                delete approvedOfConstellation[_tokenId];\r\n                emit Approval(msg.sender, address(0), _tokenId);\r\n            }\r\n        } else {\r\n            approvedOfConstellation[_tokenId] = _to;\r\n            emit Approval(msg.sender, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    function ownerOf (uint256 _itemId) public view returns (address _owner) {\r\n        return constellationCurrentOwner[_itemId];\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    function buy(uint256 _tokenId) payable external whenNotPaused\r\n    {\r\n        require(priceOf(_tokenId) > 0);\r\n        require(ownerOf(_tokenId) != address(0));\r\n        require(msg.value >= priceOf(_tokenId));\r\n        require(ownerOf(_tokenId) != msg.sender);\r\n        require(msg.sender != address(0));\r\n\r\n        address payable oldOwner = address(uint160(ownerOf(_tokenId)));\r\n        address payable newOwner = msg.sender;\r\n        uint256 price = priceOf(_tokenId);\r\n        uint256 excess = msg.value.sub(price);\r\n\r\n        _transfer(oldOwner, newOwner, _tokenId);\r\n        priceOfConstellation[_tokenId] = nextPriceOf(_tokenId);\r\n\r\n        emit Bought(_tokenId, newOwner, price);\r\n        emit Sold(_tokenId, oldOwner, price);\r\n\r\n        // Devevloper's cut which is left in contract and accesed by\r\n        // `withdrawAll` and `withdrawAmountTo` methods.\r\n        uint256 devCut = calculateDevCut(price);\r\n\r\n        // Transfer payment to old owner minus the developer's cut.\r\n        oldOwner.transfer(price.sub(devCut));\r\n\r\n        if (excess > 0) {\r\n            newOwner.transfer(excess);\r\n        }\r\n    }\r\n\r\n\r\n    function approve(address _to, uint256 _tokenId) external whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n        \r\n        _approve(_tokenId, _to);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _itemId) external {\r\n        require(msg.sender == ownerOf(_itemId));\r\n        _transfer(msg.sender, _to, _itemId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        \r\n        require(_approvedFor(_tokenId) == msg.sender);\r\n        require(_owns(_from, _tokenId));\r\n\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n    \r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return constellations.length - 1;\r\n    }\r\n\r\n    function tokenExists(uint256 _itemId) public view returns (bool _exists) {\r\n    return priceOf(_itemId) > 0;\r\n    }\r\n\r\n    function startingPriceOf(uint256 _itemId) public view returns (uint256 _startingPrice) {\r\n        return startingPriceOfConstellation[_itemId];\r\n    }\r\n\r\n    function priceOf(uint256 _itemId) public view returns (uint256 _price) {\r\n        return priceOfConstellation[_itemId];\r\n    }\r\n\r\n    function nextPriceOf(uint256 _itemId) public view returns (uint256 _nextPrice) {\r\n        return calculateNextPrice(priceOf(_itemId));\r\n    }\r\n\r\n\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] memory ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalConstellation = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            uint256 constellationId;\r\n\r\n            for (constellationId = 1; constellationId <= totalConstellation; constellationId++) {\r\n                if (constellationCurrentOwner[constellationId] == _owner) {\r\n                    result[resultIndex] = constellationId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n\r\n    function _memcpy(uint _dest, uint _src, uint _len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; _len >= 32; _len -= 32) {\r\n            assembly {\r\n                mstore(_dest, mload(_src))\r\n            }\r\n            _dest += 32;\r\n            _src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256 ** (32 - _len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(_src), not(mask))\r\n            let destpart := and(mload(_dest), mask)\r\n            mstore(_dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n    \r\n    \r\n    function _toString(bytes32[4] memory _rawBytes, uint256 _stringLength) private pure returns (string memory) {\r\n        string memory outputString = new string(_stringLength);\r\n        uint256 outputPtr;\r\n        uint256 bytesPtr;\r\n\r\n        assembly {\r\n            outputPtr := add(outputString, 32)\r\n            bytesPtr := _rawBytes\r\n        }\r\n\r\n        _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n        return outputString;\r\n    }\r\n\r\n\r\n    function tokenMetadata(uint256 _tokenId, string calldata _preferredTransport) external view returns (string memory infoUrl) {\r\n        bytes32[4] memory buffer;\r\n        uint256 count;\r\n        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n        return _toString(buffer, count);\r\n    }\r\n\r\n    function withdrawAll () onlyCLevel external {\r\n        address payable companyAddress = address(uint160(ceoAddress));\r\n        companyAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function withdrawAmount (uint256 _amount) onlyCLevel external {\r\n        address payable companyAddress = address(uint160(ceoAddress));\r\n        companyAddress.transfer(_amount);\r\n    }\r\n}\r\n\r\ncontract CryptoConstellationCore is CryptoConstellationOwnership{\r\n    \r\n    constructor() public{\r\n\r\n        // the creator of the contract is the initial CEO\r\n        ceoAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial CTO\r\n        ctoAddress = msg.sender;\r\n\r\n    }\r\n    \r\n    \r\n    function getConstellation(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n        string memory _name,\r\n        string memory _description,\r\n        string memory _ipfsHash,\r\n        address _owner, \r\n        uint256 _startingPrice, \r\n        uint256 _price, \r\n        uint256 _nextPrice\r\n    ) {\r\n        Constellation memory constellation = constellations[_id];\r\n        \r\n        _name = constellation.name;\r\n        _description = constellation.description;\r\n        _ipfsHash = constellation.ipfsHash;\r\n        _owner = ownerOf(_id);\r\n        _startingPrice = startingPriceOf(_id);\r\n        _price = priceOf(_id);\r\n        _nextPrice = nextPriceOf(_id);\r\n        \r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ctoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createConstellation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"nextPriceOf\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateDevCut\",\"outputs\":[{\"name\":\"_devCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userNickName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getConstellation\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"startingPriceOf\",\"outputs\":[{\"name\":\"_startingPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateNextPrice\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"constellationCurrentOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNickName\",\"outputs\":[{\"name\":\"_nickname\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_nickName\",\"type\":\"string\"}],\"name\":\"setNickName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCTO\",\"type\":\"address\"}],\"name\":\"setCTO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ConstellationCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"}]","ContractName":"CryptoConstellationCore","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c6d58c87c2a24b6e0454c12df819ce59af2f325fdbdf5f567391191910324640"}]}