{"status":"1","message":"OK","result":[{"SourceCode":"// File: zos-lib/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\r\n */\r\ncontract ZOSLibOwnable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: zos-lib/contracts/application/Package.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Package\r\n * @dev A package is composed by a set of versions, identified via semantic versioning,\r\n * where each version has a contract address that refers to a reusable implementation,\r\n * plus an optional content URI with metadata. Note that the semver identifier is restricted\r\n * to major, minor, and patch, as prerelease tags are not supported.\r\n */\r\ncontract Package is ZOSLibOwnable {\r\n  /**\r\n   * @dev Emitted when a version is added to the package.\r\n   * @param semanticVersion Name of the added version.\r\n   * @param contractAddress Contract associated with the version.\r\n   * @param contentURI Optional content URI with metadata of the version.\r\n   */\r\n  event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\r\n\r\n  struct Version {\r\n    uint64[3] semanticVersion;\r\n    address contractAddress;\r\n    bytes contentURI; \r\n  }\r\n\r\n  mapping (bytes32 => Version) internal versions;\r\n  mapping (uint64 => bytes32) internal majorToLatestVersion;\r\n  uint64 internal latestMajor;\r\n\r\n  /**\r\n   * @dev Returns a version given its semver identifier.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return Contract address and content URI for the version, or zero if not exists.\r\n   */\r\n  function getVersion(uint64[3] memory semanticVersion) public view returns (address contractAddress, bytes memory contentURI) {\r\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n    return (version.contractAddress, version.contentURI); \r\n  }\r\n\r\n  /**\r\n   * @dev Returns a contract for a version given its semver identifier.\r\n   * This method is equivalent to `getVersion`, but returns only the contract address.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return Contract address for the version, or zero if not exists.\r\n   */\r\n  function getContract(uint64[3] memory semanticVersion) public view returns (address contractAddress) {\r\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n    return version.contractAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new version to the package. Only the Owner can add new versions.\r\n   * Reverts if the specified semver identifier already exists. \r\n   * Emits a `VersionAdded` event if successful.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @param contractAddress Contract address for the version, must be non-zero.\r\n   * @param contentURI Optional content URI for the version.\r\n   */\r\n  function addVersion(uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) public onlyOwner {\r\n    require(contractAddress != address(0), \"Contract address is required\");\r\n    require(!hasVersion(semanticVersion), \"Given version is already registered in package\");\r\n    require(!semanticVersionIsZero(semanticVersion), \"Version must be non zero\");\r\n\r\n    // Register version\r\n    bytes32 versionId = semanticVersionHash(semanticVersion);\r\n    versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\r\n    \r\n    // Update latest major\r\n    uint64 major = semanticVersion[0];\r\n    if (major > latestMajor) {\r\n      latestMajor = semanticVersion[0];\r\n    }\r\n\r\n    // Update latest version for this major\r\n    uint64 minor = semanticVersion[1];\r\n    uint64 patch = semanticVersion[2];\r\n    uint64[3] storage latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\r\n    if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\r\n       || (minor > latestVersionForMajor[1]) // Or current minor is greater \r\n       || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\r\n       ) { \r\n      majorToLatestVersion[major] = versionId;\r\n    }\r\n\r\n    emit VersionAdded(semanticVersion, contractAddress, contentURI);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether a version is present in the package.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return true if the version is registered in this package, false otherwise.\r\n   */\r\n  function hasVersion(uint64[3] memory semanticVersion) public view returns (bool) {\r\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n    return address(version.contractAddress) != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the version with the highest semver identifier registered in the package.\r\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless \r\n   * of the order in which they were registered. Returns zero if no versions are registered.\r\n   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\r\n   */\r\n  function getLatest() public view returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\r\n    return getLatestByMajor(latestMajor);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the version with the highest semver identifier for the given major.\r\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, \r\n   * regardless of the order in which they were registered. Returns zero if no versions are registered\r\n   * for the specified major.\r\n   * @param major Major identifier to query\r\n   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\r\n   */\r\n  function getLatestByMajor(uint64 major) public view returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\r\n    Version storage version = versions[majorToLatestVersion[major]];\r\n    return (version.semanticVersion, version.contractAddress, version.contentURI); \r\n  }\r\n\r\n  function semanticVersionHash(uint64[3] memory version) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(version[0], version[1], version[2]));\r\n  }\r\n\r\n  function semanticVersionIsZero(uint64[3] memory version) internal pure returns (bool) {\r\n    return version[0] == 0 && version[1] == 0 && version[2] == 0;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"}],\"name\":\"getContract\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"}],\"name\":\"hasVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"major\",\"type\":\"uint64\"}],\"name\":\"getLatestByMajor\",\"outputs\":[{\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"contentURI\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatest\",\"outputs\":[{\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"contentURI\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"contentURI\",\"type\":\"bytes\"}],\"name\":\"addVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"}],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"contentURI\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contentURI\",\"type\":\"bytes\"}],\"name\":\"VersionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Package","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cb09afff5edcc35442c82c9439202ea4a950afb3306bec71d55f247c0997792a"}]}