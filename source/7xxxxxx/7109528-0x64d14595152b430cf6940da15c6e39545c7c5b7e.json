{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Utils {\r\n\r\n    modifier addressValid(address _address) {\r\n        require(_address != address(0), \"Utils::_ INVALID_ADDRESS\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\r\n}\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"DSAuth::_ SENDER_NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DateTime {\r\n    struct _DateTime {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n            return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n            return 29;\r\n        }\r\n        else {\r\n            return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        // Hour\r\n        dt.hour = getHour(timestamp);\r\n\r\n        // Minute\r\n        dt.minute = getMinute(timestamp);\r\n\r\n        // Second\r\n        dt.second = getSecond(timestamp);\r\n\r\n        // Day of week.\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n            if (isLeapYear(uint16(year - 1))) {\r\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            }\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function getHour(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) public pure returns (uint8) {\r\n        return uint8(timestamp % 60);\r\n    }\r\n\r\n    function getWeekday(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        // Hour\r\n        timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n        // Minute\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n        // Second\r\n        timestamp += second;\r\n\r\n        return timestamp;\r\n    }\r\n}\r\n\r\n\r\ncontract MasterCopy {\r\n    address masterCopy;\r\n\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\ncontract Proxy {\r\n\r\n    address masterCopy;\r\n\r\n    constructor(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { revert(0, returndatasize()) }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n\r\n    function implementation()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return masterCopy;\r\n    }\r\n\r\n    function proxyType()\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2;\r\n    }\r\n}\r\n\r\ncontract ErrorUtils {\r\n\r\n    event LogError(string methodSig, string errMsg);\r\n    event LogErrorWithHintBytes32(bytes32 indexed bytes32Value, string methodSig, string errMsg);\r\n    event LogErrorWithHintAddress(address indexed addressValue, string methodSig, string errMsg);\r\n\r\n}\r\n\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n\r\n    function name() public view returns(string);\r\n    function symbol() public view returns(string);\r\n    function decimals() public view returns(uint8);\r\n    function totalSupply() public view returns (uint);\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // custom : not in original DSMath, putting it here for consistency, copied from SafeMath\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract WETH9 {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event  Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event  Deposit(address indexed _owner, uint _value);\r\n    event  Withdrawal(address indexed _owner, uint _value);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped = false;\r\n\r\n    modifier whenNotStopped {\r\n        require(!stopped, \"DSStop::_ FEATURE_STOPPED\");\r\n        _;\r\n    }\r\n\r\n    modifier whenStopped {\r\n        require(stopped, \"DSStop::_ FEATURE_NOT_STOPPED\");\r\n        _;\r\n    }\r\n\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary ECRecovery {\r\n\r\n    function recover(bytes32 _hash, bytes _sig)\r\n        internal\r\n        pure\r\n    returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (_sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(_hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 _hash)\r\n        internal\r\n        pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract Utils2 {\r\n    using ECRecovery for bytes32;\r\n    \r\n    function _recoverSigner(bytes32 _hash, bytes _signature) \r\n        internal\r\n        pure\r\n        returns(address _signer)\r\n    {\r\n        return _hash.toEthSignedMessageHash().recover(_signature);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Config is DSNote, DSAuth, Utils {\r\n\r\n    WETH9 public weth9;\r\n    mapping (address => bool) public isAccountHandler;\r\n    mapping (address => bool) public isAdmin;\r\n    address[] public admins;\r\n    bool public disableAdminControl = false;\r\n    \r\n    event LogAdminAdded(address indexed _admin, address _by);\r\n    event LogAdminRemoved(address indexed _admin, address _by);\r\n\r\n    constructor() public {\r\n        admins.push(msg.sender);\r\n        isAdmin[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyAdmin(){\r\n        require(isAdmin[msg.sender], \"Config::_ SENDER_NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function setWETH9\r\n    (\r\n        address _weth9\r\n    ) \r\n        public\r\n        auth\r\n        note\r\n        addressValid(_weth9) \r\n    {\r\n        weth9 = WETH9(_weth9);\r\n    }\r\n\r\n    function setAccountHandler\r\n    (\r\n        address _accountHandler,\r\n        bool _isAccountHandler\r\n    )\r\n        public\r\n        auth\r\n        note\r\n        addressValid(_accountHandler)\r\n    {\r\n        isAccountHandler[_accountHandler] = _isAccountHandler;\r\n    }\r\n\r\n    function toggleAdminsControl() \r\n        public\r\n        auth\r\n        note\r\n    {\r\n        disableAdminControl = !disableAdminControl;\r\n    }\r\n\r\n    function isAdminValid(address _admin)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if(disableAdminControl) {\r\n            return true;\r\n        } else {\r\n            return isAdmin[_admin];\r\n        }\r\n    }\r\n\r\n    function getAllAdmins()\r\n        public\r\n        view\r\n        returns(address[])\r\n    {\r\n        return admins;\r\n    }\r\n\r\n    function addAdmin\r\n    (\r\n        address _admin\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_admin)\r\n    {   \r\n        require(!isAdmin[_admin], \"Config::addAdmin ADMIN_ALREADY_EXISTS\");\r\n\r\n        admins.push(_admin);\r\n        isAdmin[_admin] = true;\r\n\r\n        emit LogAdminAdded(_admin, msg.sender);\r\n    }\r\n\r\n    function removeAdmin\r\n    (\r\n        address _admin\r\n    ) \r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_admin)\r\n    {   \r\n        require(isAdmin[_admin], \"Config::removeAdmin ADMIN_DOES_NOT_EXIST\");\r\n        require(msg.sender != _admin, \"Config::removeAdmin ADMIN_NOT_AUTHORIZED\");\r\n\r\n        isAdmin[_admin] = false;\r\n\r\n        for (uint i = 0; i < admins.length - 1; i++) {\r\n            if (admins[i] == _admin) {\r\n                admins[i] = admins[admins.length - 1];\r\n                admins.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit LogAdminRemoved(_admin, msg.sender);\r\n    }\r\n}\r\n\r\n\r\ncontract DSThing is DSNote, DSAuth, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Account is MasterCopy, DSNote, Utils, Utils2, ErrorUtils {\r\n\r\n    address[] public users;\r\n    mapping (address => bool) public isUser;\r\n    mapping (bytes32 => bool) public actionCompleted;\r\n\r\n    WETH9 public weth9;\r\n    Config public config;\r\n    bool public isInitialized = false;\r\n\r\n    event LogTransferBySystem(address indexed token, address indexed to, uint value, address by);\r\n    event LogTransferByUser(address indexed token, address indexed to, uint value, address by);\r\n    event LogUserAdded(address indexed user, address by);\r\n    event LogUserRemoved(address indexed user, address by);\r\n\r\n    modifier initialized() {\r\n        require(isInitialized, \"Account::_ ACCOUNT_NOT_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier userExists(address _user) {\r\n        require(isUser[_user], \"Account::_ INVALID_USER\");\r\n        _;\r\n    }\r\n\r\n    modifier userDoesNotExist(address _user) {\r\n        require(!isUser[_user], \"Account::_ USER_DOES_NOT_EXISTS\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyHandler(){\r\n        require(config.isAccountHandler(msg.sender), \"Account::_ INVALID_ACC_HANDLER\");\r\n        _;\r\n    }\r\n\r\n    function init(address _user, address _config) public {\r\n        users.push(_user);\r\n        isUser[_user] = true;\r\n        config = Config(_config);\r\n        weth9 = config.weth9();\r\n        isInitialized = true;\r\n    }\r\n    \r\n    function getAllUsers() public view returns (address[]) {\r\n        return users;\r\n    }\r\n\r\n    function balanceFor(address _token) public view returns (uint _balance){\r\n        _balance = ERC20(_token).balanceOf(this);\r\n    }\r\n    \r\n    function transferBySystem\r\n    (   \r\n        address _token,\r\n        address _to,\r\n        uint _value\r\n    ) \r\n        external \r\n        onlyHandler\r\n        note \r\n        initialized\r\n    {\r\n        require(ERC20(_token).balanceOf(this) >= _value, \"Account::transferBySystem INSUFFICIENT_BALANCE_IN_ACCOUNT\");\r\n        require(ERC20(_token).transfer(_to, _value), \"Account::transferBySystem TOKEN_TRANSFER_FAILED\");\r\n\r\n        emit LogTransferBySystem(_token, _to, _value, msg.sender);\r\n    }\r\n    \r\n    function transferByUser\r\n    (   \r\n        address _token,\r\n        address _to,\r\n        uint _value,\r\n        uint _salt,\r\n        bytes _signature\r\n    ) \r\n        external\r\n        addressValid(_to)\r\n        note\r\n        initialized\r\n    {\r\n        bytes32 actionHash = _getTransferActionHash(_token, _to, _value, _salt);\r\n\r\n        if(actionCompleted[actionHash]) {\r\n            emit LogError(\"Account::transferByUser\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(_token).balanceOf(this) < _value){\r\n            emit LogError(\"Account::transferByUser\", \"INSUFFICIENT_BALANCE_IN_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n\r\n        if(!isUser[signer]) {\r\n            emit LogError(\"Account::transferByUser\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        actionCompleted[actionHash] = true;\r\n        \r\n        if (_token == address(weth9)) {\r\n            weth9.withdraw(_value);\r\n            _to.transfer(_value);\r\n        } else {\r\n            require(ERC20(_token).transfer(_to, _value), \"Account::transferByUser TOKEN_TRANSFER_FAILED\");\r\n        }\r\n\r\n        emit LogTransferByUser(_token, _to, _value, signer);\r\n    }\r\n\r\n    function addUser\r\n    (\r\n        address _user,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n        external \r\n        note \r\n        addressValid(_user)\r\n        userDoesNotExist(_user)\r\n        initialized\r\n    {   \r\n        bytes32 actionHash = _getUserActionHash(_user, \"ADD_USER\", _salt);\r\n        if(actionCompleted[actionHash])\r\n        {\r\n            emit LogError(\"Account::addUser\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n\r\n        if(!isUser[signer]) {\r\n            emit LogError(\"Account::addUser\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        actionCompleted[actionHash] = true;\r\n\r\n        users.push(_user);\r\n        isUser[_user] = true;\r\n\r\n        emit LogUserAdded(_user, signer);\r\n    }\r\n\r\n    function removeUser\r\n    (\r\n        address _user,\r\n        uint _salt,\r\n        bytes _signature\r\n    ) \r\n        external\r\n        note\r\n        userExists(_user) \r\n        initialized\r\n    {   \r\n        bytes32 actionHash = _getUserActionHash(_user, \"REMOVE_USER\", _salt);\r\n\r\n        if(actionCompleted[actionHash]) {\r\n            emit LogError(\"Account::removeUser\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n        \r\n        // require(signer != _user, \"Account::removeUser SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n        if(!isUser[signer]){\r\n            emit LogError(\"Account::removeUser\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n        \r\n        actionCompleted[actionHash] = true;\r\n\r\n        // should delete value from isUser map? delete isUser[_user]?\r\n        isUser[_user] = false;\r\n        for (uint i = 0; i < users.length - 1; i++) {\r\n            if (users[i] == _user) {\r\n                users[i] = users[users.length - 1];\r\n                users.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit LogUserRemoved(_user, signer);\r\n    }\r\n\r\n    function _getTransferActionHash\r\n    ( \r\n        address _token,\r\n        address _to,\r\n        uint _value,\r\n        uint _salt\r\n    ) \r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _token,\r\n                _to,\r\n                _value,\r\n                _salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getUserActionHash\r\n    ( \r\n        address _user,\r\n        string _action,\r\n        uint _salt\r\n    ) \r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _user,\r\n                _action,\r\n                _salt\r\n            )\r\n        );\r\n    }\r\n\r\n    // to directly send ether to contract\r\n    function() external payable {\r\n        require(msg.data.length == 0 && msg.value > 0, \"Account::fallback INVALID_ETHER_TRANSFER\");\r\n\r\n        if(msg.sender != address(weth9)){\r\n            weth9.deposit.value(msg.value)();\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract AccountFactory is DSStop, Utils {\r\n    Config public config;\r\n    mapping (address => bool) public isAccount;\r\n    mapping (address => address[]) public userToAccounts;\r\n    address[] public accounts;\r\n\r\n    address public accountMaster;\r\n\r\n    constructor\r\n    (\r\n        Config _config, \r\n        address _accountMaster\r\n    ) \r\n    public \r\n    {\r\n        config = _config;\r\n        accountMaster = _accountMaster;\r\n    }\r\n\r\n    event LogAccountCreated(address indexed user, address indexed account, address by);\r\n\r\n    modifier onlyAdmin() {\r\n        require(config.isAdminValid(msg.sender), \"AccountFactory::_ INVALID_ADMIN_ACCOUNT\");\r\n        _;\r\n    }\r\n\r\n    function setConfig(Config _config) external note auth addressValid(_config) {\r\n        config = _config;\r\n    }\r\n\r\n    function setAccountMaster(address _accountMaster) external note auth addressValid(_accountMaster) {\r\n        accountMaster = _accountMaster;\r\n    }\r\n\r\n    function newAccount(address _user)\r\n        public\r\n        note\r\n        onlyAdmin\r\n        addressValid(config)\r\n        addressValid(accountMaster)\r\n        whenNotStopped\r\n        returns \r\n        (\r\n            Account _account\r\n        ) \r\n    {\r\n        address proxy = new Proxy(accountMaster);\r\n        _account = Account(proxy);\r\n        _account.init(_user, config);\r\n\r\n        accounts.push(_account);\r\n        userToAccounts[_user].push(_account);\r\n        isAccount[_account] = true;\r\n\r\n        emit LogAccountCreated(_user, _account, msg.sender);\r\n    }\r\n    \r\n    function batchNewAccount(address[] _users) public note onlyAdmin {\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            newAccount(_users[i]);\r\n        }\r\n    }\r\n\r\n    function getAllAccounts() public view returns (address[]) {\r\n        return accounts;\r\n    }\r\n\r\n    function getAccountsForUser(address _user) public view returns (address[]) {\r\n        return userToAccounts[_user];\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Escrow is DSNote, DSAuth {\r\n\r\n    event LogTransfer(address indexed token, address indexed to, uint value);\r\n    event LogTransferFromAccount(address indexed account, address indexed token, address indexed to, uint value);\r\n\r\n    function transfer\r\n    (\r\n        address _token,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        public\r\n        note\r\n        auth\r\n    {\r\n        require(ERC20(_token).transfer(_to, _value), \"Escrow::transfer TOKEN_TRANSFER_FAILED\");\r\n        emit LogTransfer(_token, _to, _value);\r\n    }\r\n\r\n    function transferFromAccount\r\n    (\r\n        address _account,\r\n        address _token,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        public\r\n        note\r\n        auth\r\n    {   \r\n        Account(_account).transferBySystem(_token, _to, _value);\r\n        emit LogTransferFromAccount(_account, _token, _to, _value);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Reserve is DSStop, DSThing, Utils, Utils2, ErrorUtils {\r\n\r\n    Escrow public escrow;\r\n    AccountFactory public accountFactory;\r\n    DateTime public dateTime;\r\n    Config public config;\r\n    uint public deployTimestamp;\r\n\r\n    string constant public VERSION = \"1.0.0\";\r\n\r\n    uint public TIME_INTERVAL = 1 days;\r\n    \r\n    constructor\r\n    (\r\n        Escrow _escrow,\r\n        AccountFactory _accountFactory,\r\n        DateTime _dateTime,\r\n        Config _config\r\n    ) \r\n    public \r\n    {\r\n        escrow = _escrow;\r\n        accountFactory = _accountFactory;\r\n        dateTime = _dateTime;\r\n        config = _config;\r\n        deployTimestamp = now - (4 * TIME_INTERVAL);\r\n    }\r\n\r\n    function setEscrow(Escrow _escrow) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_escrow)\r\n    {\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function setAccountFactory(AccountFactory _accountFactory) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_accountFactory)\r\n    {\r\n        accountFactory = _accountFactory;\r\n    }\r\n\r\n    function setDateTime(DateTime _dateTime) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_dateTime)\r\n    {\r\n        dateTime = _dateTime;\r\n    }\r\n\r\n    function setConfig(Config _config) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_config)\r\n    {\r\n        config = _config;\r\n    }\r\n\r\n    struct Order {\r\n        address account;\r\n        address token;\r\n        address byUser;\r\n        uint value;\r\n        uint duration;\r\n        uint expirationTimestamp;\r\n        uint salt;\r\n        uint createdTimestamp;\r\n        bytes32 orderHash;\r\n    }\r\n\r\n    bytes32[] public orders;\r\n    mapping (bytes32 => Order) public hashToOrder;\r\n    mapping (bytes32 => bool) public isOrder;\r\n    mapping (address => bytes32[]) public accountToOrders;\r\n    mapping (bytes32 => bool) public cancelledOrders;\r\n\r\n    // per day\r\n    mapping (uint => mapping(address => uint)) public deposits;\r\n    mapping (uint => mapping(address => uint)) public withdrawals;\r\n    mapping (uint => mapping(address => uint)) public profits;\r\n    mapping (uint => mapping(address => uint)) public losses;\r\n\r\n    mapping (uint => mapping(address => uint)) public reserves;\r\n    mapping (address => uint) public lastReserveRuns;\r\n\r\n    mapping (address => mapping(address => uint)) surplus;\r\n\r\n    mapping (bytes32 => CumulativeRun) public orderToCumulative;\r\n\r\n    struct CumulativeRun {\r\n        uint timestamp;\r\n        uint value;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(config.isAdminValid(msg.sender), \"Reserve::_ INVALID_ADMIN_ACCOUNT\");\r\n        _;\r\n    }\r\n\r\n    event LogOrderCreated(\r\n        bytes32 indexed orderHash,\r\n        address indexed account,\r\n        address indexed token,\r\n        address byUser,\r\n        uint value,\r\n        uint expirationTimestamp\r\n    );\r\n\r\n    event LogOrderCancelled(\r\n        bytes32 indexed orderHash,\r\n        address indexed by\r\n    );\r\n\r\n    event LogReserveValuesUpdated(\r\n        address indexed token, \r\n        uint indexed updatedTill,\r\n        uint reserve,\r\n        uint profit,\r\n        uint loss\r\n    );\r\n\r\n    event LogOrderCumulativeUpdated(\r\n        bytes32 indexed orderHash,\r\n        uint updatedTill,\r\n        uint value\r\n    );\r\n\r\n    event LogRelease(\r\n        address indexed token,\r\n        address indexed to,\r\n        uint value,\r\n        address by\r\n    );\r\n\r\n    event LogLock(\r\n        address indexed token,\r\n        address indexed from,\r\n        uint value,\r\n        uint profit,\r\n        uint loss,\r\n        address by\r\n    );\r\n\r\n    event LogLockSurplus(\r\n        address indexed forToken, \r\n        address indexed token,\r\n        address from,\r\n        uint value\r\n    );\r\n\r\n    event LogTransferSurplus(\r\n        address indexed forToken,\r\n        address indexed token,\r\n        address to, \r\n        uint value\r\n    );\r\n    \r\n    function createOrder\r\n    (\r\n        address[3] _orderAddresses,\r\n        uint[3] _orderValues,\r\n        bytes _signature\r\n    ) \r\n        public\r\n        note\r\n        onlyAdmin\r\n        whenNotStopped\r\n    {\r\n        Order memory order = _composeOrder(_orderAddresses, _orderValues);\r\n        address signer = _recoverSigner(order.orderHash, _signature);\r\n\r\n        if(signer != order.byUser){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"SIGNER_NOT_ORDER_CREATOR\");\r\n            return;\r\n        }\r\n        \r\n        if(isOrder[order.orderHash]){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"ORDER_ALREADY_EXISTS\");\r\n            return;\r\n        }\r\n\r\n        if(!accountFactory.isAccount(order.account)){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"INVALID_ORDER_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        if(!Account(order.account).isUser(signer)){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n                \r\n        if(!_isOrderValid(order)) {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"INVALID_ORDER_PARAMETERS\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.token).balanceOf(order.account) < order.value){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"INSUFFICIENT_BALANCE_IN_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        escrow.transferFromAccount(order.account, order.token, address(escrow), order.value);\r\n        \r\n        orders.push(order.orderHash);\r\n        hashToOrder[order.orderHash] = order;\r\n        isOrder[order.orderHash] = true;\r\n        accountToOrders[order.account].push(order.orderHash);\r\n\r\n        uint dateTimestamp = _getDateTimestamp(now);\r\n\r\n        deposits[dateTimestamp][order.token] = add(deposits[dateTimestamp][order.token], order.value);\r\n        \r\n        orderToCumulative[order.orderHash].timestamp = _getDateTimestamp(order.createdTimestamp);\r\n        orderToCumulative[order.orderHash].value = order.value;\r\n\r\n        emit LogOrderCreated(\r\n            order.orderHash,\r\n            order.account,\r\n            order.token,\r\n            order.byUser,\r\n            order.value,\r\n            order.expirationTimestamp\r\n        );\r\n    }\r\n\r\n    function cancelOrder\r\n    (\r\n        bytes32 _orderHash,\r\n        bytes _signature\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n    {   \r\n        if(!isOrder[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::createOrder\", \"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(cancelledOrders[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::createOrder\", \"ORDER_ALREADY_CANCELLED\");\r\n            return;\r\n        }\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n\r\n        bytes32 cancelOrderHash = _generateActionOrderHash(_orderHash, \"CANCEL_RESERVE_ORDER\");\r\n        address signer = _recoverSigner(cancelOrderHash, _signature);\r\n        \r\n        if(!Account(order.account).isUser(signer)){\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::createOrder\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n        \r\n        doCancelOrder(order);\r\n    }\r\n    \r\n    function processOrder\r\n    (\r\n        bytes32 _orderHash\r\n    ) \r\n        external \r\n        note\r\n        onlyAdmin\r\n    {\r\n        if(!isOrder[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::processOrder\", \"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(cancelledOrders[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::processOrder\", \"ORDER_ALREADY_CANCELLED\");\r\n            return;\r\n        }\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n\r\n        if(now > _getDateTimestamp(order.expirationTimestamp)) {\r\n            doCancelOrder(order);\r\n        } else {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::processOrder\", \"ORDER_NOT_EXPIRED\");\r\n        }\r\n    }\r\n\r\n    function doCancelOrder(Order _order) \r\n        internal\r\n    {   \r\n        uint valueToTransfer = orderToCumulative[_order.orderHash].value;\r\n\r\n        if(ERC20(_order.token).balanceOf(escrow) < valueToTransfer){\r\n            emit LogErrorWithHintBytes32(_order.orderHash, \"Reserve::doCancel\", \"INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        uint nowDateTimestamp = _getDateTimestamp(now);\r\n        cancelledOrders[_order.orderHash] = true;\r\n        withdrawals[nowDateTimestamp][_order.token] = add(withdrawals[nowDateTimestamp][_order.token], valueToTransfer);\r\n\r\n        escrow.transfer(_order.token, _order.account, valueToTransfer);\r\n        emit LogOrderCancelled(_order.orderHash, msg.sender);\r\n    }\r\n\r\n    function release(address _token, address _to, uint _value) \r\n        external\r\n        note\r\n        auth\r\n    {   \r\n        require(ERC20(_token).balanceOf(escrow) >= _value, \"Reserve::release INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n        escrow.transfer(_token, _to, _value);\r\n        emit LogRelease(_token, _to, _value, msg.sender);\r\n    }\r\n\r\n    // _value includes profit/loss as well\r\n    function lock(address _token, address _from, uint _value, uint _profit, uint _loss)\r\n        external\r\n        note\r\n        auth\r\n    {   \r\n        require(!(_profit == 0 && _loss == 0), \"Reserve::lock INVALID_PROFIT_LOSS_VALUES\");\r\n        require(ERC20(_token).balanceOf(_from) >= _value, \"Reserve::lock INSUFFICIENT_BALANCE\");\r\n            \r\n        if(accountFactory.isAccount(_from)) {\r\n            escrow.transferFromAccount(_from, _token, address(escrow), _value);\r\n        } else {\r\n            Escrow(_from).transfer(_token, address(escrow), _value);\r\n        }\r\n        \r\n        uint dateTimestamp = _getDateTimestamp(now);\r\n\r\n        if (_profit > 0){\r\n            profits[dateTimestamp][_token] = add(profits[dateTimestamp][_token], _profit);\r\n        } else if (_loss > 0) {\r\n            losses[dateTimestamp][_token] = add(losses[dateTimestamp][_token], _loss);\r\n        }\r\n\r\n        emit LogLock(_token, _from, _value, _profit, _loss, msg.sender);\r\n    }\r\n\r\n    // to lock collateral if cannot be liquidated e.g. not enough reserves in kyber\r\n    function lockSurplus(address _from, address _forToken, address _token, uint _value) \r\n        external\r\n        note\r\n        auth\r\n    {\r\n        require(ERC20(_token).balanceOf(_from) >= _value, \"Reserve::lockSurplus INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n\r\n        Escrow(_from).transfer(_token, address(escrow), _value);\r\n        surplus[_forToken][_token] = add(surplus[_forToken][_token], _value);\r\n\r\n        emit LogLockSurplus(_forToken, _token, _from, _value);\r\n    }\r\n\r\n    // to transfer surplus collateral out of the system to trade on other platforms and put back in terms of \r\n    // principal to reserve manually using an account or surplus escrow\r\n    // should work in tandem with lock method when transferring back principal\r\n    function transferSurplus(address _to, address _forToken, address _token, uint _value) \r\n        external\r\n        note\r\n        auth\r\n    {\r\n        require(ERC20(_token).balanceOf(escrow) >= _value, \"Reserve::transferSurplus INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n        require(surplus[_forToken][_token] >= _value, \"Reserve::transferSurplus INSUFFICIENT_SURPLUS\");\r\n\r\n        surplus[_forToken][_token] = sub(surplus[_forToken][_token], _value);\r\n        escrow.transfer(_token, _to, _value);\r\n\r\n        emit LogTransferSurplus(_forToken, _token, _to, _value);\r\n    }\r\n\r\n    function updateReserveValues(address _token, uint _forDays)\r\n        public\r\n        note\r\n        onlyAdmin\r\n    {   \r\n        uint lastReserveRun = lastReserveRuns[_token];\r\n\r\n        if (lastReserveRun == 0) {\r\n            lastReserveRun = _getDateTimestamp(deployTimestamp) - TIME_INTERVAL;\r\n        }\r\n\r\n        uint nowDateTimestamp = _getDateTimestamp(now);\r\n        uint updatesLeft = ((nowDateTimestamp - TIME_INTERVAL) - lastReserveRun) / TIME_INTERVAL;\r\n\r\n        if(updatesLeft == 0) {\r\n            emit LogErrorWithHintAddress(_token, \"Reserve::updateReserveValues\", \"RESERVE_VALUES_UP_TO_DATE\");\r\n            return;\r\n        }\r\n\r\n        uint counter = updatesLeft;\r\n\r\n        if(updatesLeft > _forDays && _forDays > 0) {\r\n            counter = _forDays;\r\n        }\r\n\r\n        for (uint i = 0; i < counter; i++) {\r\n            reserves[lastReserveRun + TIME_INTERVAL][_token] = sub(\r\n                sub(\r\n                    add(\r\n                        add(\r\n                            reserves[lastReserveRun][_token],\r\n                            deposits[lastReserveRun + TIME_INTERVAL][_token]\r\n                        ),\r\n                        profits[lastReserveRun + TIME_INTERVAL][_token]\r\n                    ),\r\n                    losses[lastReserveRun + TIME_INTERVAL][_token]\r\n                ),\r\n                withdrawals[lastReserveRun + TIME_INTERVAL][_token]\r\n            );\r\n            lastReserveRuns[_token] = lastReserveRun + TIME_INTERVAL;\r\n            lastReserveRun = lastReserveRuns[_token];\r\n            \r\n            emit LogReserveValuesUpdated(\r\n                _token,\r\n                lastReserveRun,\r\n                reserves[lastReserveRun][_token],\r\n                profits[lastReserveRun][_token],\r\n                losses[lastReserveRun][_token]\r\n            );\r\n            \r\n        }\r\n    }\r\n\r\n    function updateOrderCumulativeValueBatch(bytes32[] _orderHashes, uint[] _forDays) \r\n        public\r\n        note\r\n        onlyAdmin\r\n    {   \r\n        if(_orderHashes.length != _forDays.length) {\r\n            emit LogError(\"Reserve::updateOrderCumulativeValueBatch\", \"ARGS_ARRAYLENGTH_MISMATCH\");\r\n            return;\r\n        }\r\n\r\n        for(uint i = 0; i < _orderHashes.length; i++) {\r\n            updateOrderCumulativeValue(_orderHashes[i], _forDays[i]);\r\n        }\r\n    }\r\n\r\n    function updateOrderCumulativeValue\r\n    (\r\n        bytes32 _orderHash, \r\n        uint _forDays\r\n    ) \r\n        public\r\n        note\r\n        onlyAdmin \r\n    {\r\n        if(!isOrder[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(cancelledOrders[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"ORDER_ALREADY_CANCELLED\");\r\n            return;\r\n        }\r\n        \r\n        Order memory order = hashToOrder[_orderHash];\r\n        CumulativeRun storage cumulativeRun = orderToCumulative[_orderHash];\r\n        \r\n        uint profitsAccrued = 0;\r\n        uint lossesAccrued = 0;\r\n        uint cumulativeValue = 0;\r\n        uint counter = 0;\r\n\r\n        uint lastOrderRun = cumulativeRun.timestamp;\r\n        uint nowDateTimestamp = _getDateTimestamp(now);\r\n\r\n        uint updatesLeft = ((nowDateTimestamp - TIME_INTERVAL) - lastOrderRun) / TIME_INTERVAL;\r\n\r\n        if(updatesLeft == 0) {\r\n            emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"ORDER_VALUES_UP_TO_DATE\");\r\n            return;\r\n        }\r\n\r\n        counter = updatesLeft;\r\n\r\n        if(updatesLeft > _forDays && _forDays > 0) {\r\n            counter = _forDays;\r\n        }\r\n\r\n        for (uint i = 0; i < counter; i++){\r\n            cumulativeValue = cumulativeRun.value;\r\n            lastOrderRun = cumulativeRun.timestamp;\r\n\r\n            if(lastReserveRuns[order.token] < lastOrderRun) {\r\n                emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"RESERVE_VALUES_NOT_UPDATED\");\r\n                emit LogOrderCumulativeUpdated(_orderHash, cumulativeRun.timestamp, cumulativeRun.value);\r\n                return;\r\n            }\r\n\r\n            profitsAccrued = div(\r\n                mul(profits[lastOrderRun + TIME_INTERVAL][order.token], cumulativeValue),\r\n                reserves[lastOrderRun][order.token]\r\n            );\r\n                \r\n            lossesAccrued = div(\r\n                mul(losses[lastOrderRun + TIME_INTERVAL][order.token], cumulativeValue),\r\n                reserves[lastOrderRun][order.token]\r\n            );\r\n\r\n            cumulativeValue = sub(add(cumulativeValue, profitsAccrued), lossesAccrued);\r\n\r\n            cumulativeRun.timestamp = lastOrderRun + TIME_INTERVAL;\r\n            cumulativeRun.value = cumulativeValue;\r\n        }\r\n        \r\n        emit LogOrderCumulativeUpdated(_orderHash, cumulativeRun.timestamp, cumulativeRun.value);\r\n    }\r\n\r\n    function getAllOrders() \r\n        public\r\n        view \r\n        returns \r\n        (\r\n            bytes32[]\r\n        ) \r\n    {\r\n        return orders;\r\n    }\r\n\r\n    function getOrdersForAccount(address _account) \r\n        public\r\n        view \r\n        returns \r\n        (\r\n            bytes32[]\r\n        )\r\n    {\r\n        return accountToOrders[_account];\r\n    }\r\n\r\n    function getOrder(bytes32 _orderHash)\r\n        public \r\n        view \r\n        returns \r\n        (\r\n            address _account,\r\n            address _token,\r\n            address _byUser,\r\n            uint _value,\r\n            uint _expirationTimestamp,\r\n            uint _salt,\r\n            uint _createdTimestamp\r\n        )\r\n    {   \r\n        Order memory order = hashToOrder[_orderHash];\r\n        return (\r\n            order.account,\r\n            order.token,\r\n            order.byUser,\r\n            order.value,\r\n            order.expirationTimestamp,\r\n            order.salt,\r\n            order.createdTimestamp\r\n        );\r\n    }\r\n\r\n    function _isOrderValid(Order _order)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if(_order.account == address(0) || _order.byUser == address(0)\r\n         || _order.value <= 0\r\n         || _order.expirationTimestamp <= _order.createdTimestamp || _order.salt <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if(isOrder[_order.orderHash]) {\r\n            return false;\r\n        }\r\n\r\n        if(cancelledOrders[_order.orderHash]) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _composeOrder(address[3] _orderAddresses, uint[3] _orderValues)\r\n        internal\r\n        view\r\n        returns (Order _order)\r\n    {\r\n        Order memory order = Order({\r\n            account: _orderAddresses[0],\r\n            token: _orderAddresses[1],\r\n            byUser: _orderAddresses[2],\r\n            value: _orderValues[0],\r\n            createdTimestamp: now,\r\n            duration: _orderValues[1],\r\n            expirationTimestamp: add(now, _orderValues[1]),\r\n            salt: _orderValues[2],\r\n            orderHash: bytes32(0)\r\n        });\r\n\r\n        order.orderHash = _generateCreateOrderHash(order);\r\n\r\n        return order;\r\n    }\r\n\r\n    function _generateCreateOrderHash(Order _order)\r\n        internal\r\n        pure //view\r\n        returns (bytes32 _orderHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n //              address(this),\r\n                _order.account,\r\n                _order.token,\r\n                _order.value,\r\n                _order.duration,\r\n                _order.salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function _generateActionOrderHash\r\n    (\r\n        bytes32 _orderHash,\r\n        string _action\r\n    )\r\n        internal\r\n        pure //view\r\n        returns (bytes32 _repayOrderHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n//                address(this),\r\n                _orderHash,\r\n                _action\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getDateTimestamp(uint _timestamp) \r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return dateTime.toTimestamp(dateTime.getYear(_timestamp), dateTime.getMonth(_timestamp), dateTime.getDay(_timestamp));\r\n    } \r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_profit\",\"type\":\"uint256\"},{\"name\":\"_loss\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"losses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dateTime\",\"type\":\"address\"}],\"name\":\"setDateTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserves\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3]\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getOrdersForAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"profits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_forToken\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"lockSurplus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderToCumulative\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"name\":\"_forDays\",\"type\":\"uint256\"}],\"name\":\"updateOrderCumulativeValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_byUser\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expirationTimestamp\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_createdTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountToOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReserveRuns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelledOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"}],\"name\":\"processOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accountFactory\",\"type\":\"address\"}],\"name\":\"setAccountFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_forDays\",\"type\":\"uint256[]\"}],\"name\":\"updateOrderCumulativeValueBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_escrow\",\"type\":\"address\"}],\"name\":\"setEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashToOrder\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"byUser\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"createdTimestamp\",\"type\":\"uint256\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_forToken\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferSurplus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_forDays\",\"type\":\"uint256\"}],\"name\":\"updateReserveValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_escrow\",\"type\":\"address\"},{\"name\":\"_accountFactory\",\"type\":\"address\"},{\"name\":\"_dateTime\",\"type\":\"address\"},{\"name\":\"_config\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"byUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogOrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"updatedTill\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reserve\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loss\",\"type\":\"uint256\"}],\"name\":\"LogReserveValuesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"updatedTill\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogOrderCumulativeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogRelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"forToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogLockSurplus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"forToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogTransferSurplus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"methodSig\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"errMsg\",\"type\":\"string\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bytes32Value\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"methodSig\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"errMsg\",\"type\":\"string\"}],\"name\":\"LogErrorWithHintBytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addressValue\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"methodSig\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"errMsg\",\"type\":\"string\"}],\"name\":\"LogErrorWithHintAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"}]","ContractName":"Reserve","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000802275979b020f0ec871c5ec1db6e412b72ff20b000000000000000000000000f5a38fbc26c720c79350b99d9c0bd42b3e9b83160000000000000000000000002929e21109901461659c0f26ad7f0e7633ea6539000000000000000000000000431f429035a1e3059d5c6a9a83208c6d3143d925","Library":"","SwarmSource":"bzzr://731420416758f163469d1bf7a9927f76f393957edc2eb8fb469f2ff5537dcfa6"}]}