{"status":"1","message":"OK","result":[{"SourceCode":"// SaiValuesAggregator.sol -- Sai values aggregator\r\n\r\n// Copyright (C) 2018-2019 Michael Elliot <mike@makerdao.com>\r\n// Copyright (C) 2018-2019 Gonzalo Balabasquer <gbalabasquer@gmail.com>\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract TopInterface {\r\n    function tub() public view returns (address);\r\n    function tap() public view returns (address);\r\n}\r\n\r\ncontract TubInterface {\r\n    function vox() public view returns (address);\r\n    function pit() public view returns (address);\r\n    function pip() public view returns (address);\r\n    function pep() public view returns (address);\r\n    function mat() public view returns (uint);\r\n    function chi() public view returns (uint);\r\n    function per() public view returns (uint);\r\n    function tag() public view returns (uint);\r\n    function axe() public view returns (uint);\r\n    function cap() public view returns (uint);\r\n    function fit() public view returns (uint);\r\n    function tax() public view returns (uint);\r\n    function fee() public view returns (uint);\r\n    function gap() public view returns (uint);\r\n    function rho() public view returns (uint);\r\n    function rhi() public view returns (uint);\r\n    function off() public view returns (bool);\r\n    function out() public view returns (bool);\r\n    function gem() public view returns (address);\r\n    function gov() public view returns (address);\r\n    function skr() public view returns (address);\r\n    function sai() public view returns (address);\r\n    function sin() public view returns (address);\r\n    function cups(bytes32) public view returns (address, uint, uint, uint);\r\n    function tab(bytes32) public view returns (uint);\r\n    function safe(bytes32) public view returns (bool);\r\n}\r\n\r\ncontract TapInterface {\r\n    function fix() public view returns (uint);\r\n    function gap() public view returns (uint);\r\n}\r\n\r\ncontract VoxInterface {\r\n    function par() public view returns (uint);\r\n    function way() public view returns (uint);\r\n    function era() public view returns (uint);\r\n}\r\n\r\ncontract PipInterface {\r\n    function peek() public view returns (bytes32, bool);\r\n}\r\n\r\ncontract TokInterface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address) public view returns (uint);\r\n    function allowance(address, address) public view returns (uint);\r\n}\r\n\r\ncontract ProxyInterface {\r\n    function owner() public view returns (address);\r\n}\r\n\r\ncontract ProxyRegInterface {\r\n    function proxies(address) public view returns (address);\r\n}\r\n\r\ncontract SaiValuesAggregator is DSMath {\r\n    address public top;\r\n\r\n    constructor(address _top) public {\r\n        top = _top;\r\n    }\r\n\r\n    function tub() public view returns (address) {\r\n        return TopInterface(top).tub();\r\n    }\r\n\r\n    function tap() public view returns (address) {\r\n        return TopInterface(top).tap();\r\n    }\r\n\r\n    function vox() public view returns (address) {\r\n        return TubInterface(tub()).vox();\r\n    }\r\n\r\n    function pit() public view returns (address) {\r\n        return TubInterface(tub()).pit();\r\n    }\r\n\r\n    function pip() public view returns (address) {\r\n        return TubInterface(tub()).pip();\r\n    }\r\n\r\n    function pep() public view returns (address) {\r\n        return TubInterface(tub()).pep();\r\n    }\r\n\r\n    function gem() public view returns (address) {\r\n        return TubInterface(tub()).gem();\r\n    }\r\n\r\n    function gov() public view returns (address) {\r\n        return TubInterface(tub()).gov();\r\n    }\r\n\r\n    function skr() public view returns (address) {\r\n        return TubInterface(tub()).skr();\r\n    }\r\n\r\n    function sai() public view returns (address) {\r\n        return TubInterface(tub()).sai();\r\n    }\r\n\r\n    function sin() public view returns (address) {\r\n        return TubInterface(tub()).sin();\r\n    }\r\n\r\n    function getContractsAddrs(address proxyRegistry, address addr) public view returns (\r\n                                                                                uint blockNumber,\r\n                                                                                address[] saiContracts,\r\n                                                                                address proxy\r\n                                                                            ) {\r\n        blockNumber = block.number;\r\n        saiContracts = new address[](12);\r\n        saiContracts[0] = top;\r\n        saiContracts[1] = tub();\r\n        saiContracts[2] = tap();\r\n        saiContracts[3] = vox();\r\n        saiContracts[4] = pit();\r\n        saiContracts[5] = pip();\r\n        saiContracts[6] = pep();\r\n        saiContracts[7] = gem();\r\n        saiContracts[8] = gov();\r\n        saiContracts[9] = skr();\r\n        saiContracts[10] = sai();\r\n        saiContracts[11] = sin();\r\n        proxy = ProxyRegInterface(proxyRegistry).proxies(addr);\r\n        proxy = proxy != address(0) && ProxyInterface(proxy).owner() == addr ? proxy : address(0);\r\n    }\r\n\r\n    // Return the aggregated values from tub, vox and tap\r\n    function aggregateValues(address addr, address proxy) public view returns (\r\n                                                        uint blockNumber,\r\n                                                        bytes32 pipVal,\r\n                                                        bool pipSet,\r\n                                                        bytes32 pepVal,\r\n                                                        bool pepSet,\r\n                                                        bool[] sStatus, // System status\r\n                                                        uint[] sValues, // System Values\r\n                                                        uint[] tValues // Token Values\r\n                                                    ) {\r\n        blockNumber = block.number;\r\n\r\n        (pipVal, pipSet) = PipInterface(pip()).peek(); // Price feed value for gem\r\n        (pepVal, pepSet) = PipInterface(pep()).peek(); // Price feed value for gov\r\n\r\n        sStatus = new bool[](4);\r\n        sStatus[0] = TubInterface(tub()).off(); // off: Cage flag\r\n        sStatus[1] = TubInterface(tub()).out(); // out: Post cage exit\r\n        uint pro = rmul(TokInterface(skr()).balanceOf(tub()), TubInterface(tub()).tag());\r\n        sStatus[2] = pro < TokInterface(sin()).totalSupply(); // eek: deficit\r\n        sStatus[3] = pro >= rmul(TokInterface(sin()).totalSupply(), TubInterface(tub()).mat()); // safe\r\n\r\n        sValues = new uint[](19);\r\n        // Tub\r\n        sValues[0] = TubInterface(tub()).axe(); // Liquidation penalty\r\n        sValues[1] = TubInterface(tub()).mat(); // Liquidation ratio\r\n        sValues[2] = TubInterface(tub()).cap(); // Debt ceiling\r\n        sValues[3] = TubInterface(tub()).fit(); // REF per SKR (just before settlement)\r\n        sValues[4] = TubInterface(tub()).tax(); // Stability fee\r\n        sValues[5] = TubInterface(tub()).fee(); // Governance fee\r\n        sValues[6] = TubInterface(tub()).chi(); // Accumulated Tax Rates\r\n        sValues[7] = TubInterface(tub()).rhi(); // Accumulated Tax + Fee Rates\r\n        sValues[8] = TubInterface(tub()).rho(); // Time of last drip\r\n        sValues[9] = TubInterface(tub()).gap(); // Join-Exit Spread\r\n        sValues[10] = TubInterface(tub()).tag(); // Abstracted collateral price (ref per skr)\r\n        sValues[11] = TubInterface(tub()).per(); // Wrapper ratio (gem per skr)\r\n        // Vox\r\n        sValues[12] = VoxInterface(vox()).par(); // Dai Target Price (ref per dai)\r\n        sValues[13] = VoxInterface(vox()).way(); // The holder fee (interest rate)\r\n        sValues[14] = VoxInterface(vox()).era();\r\n        // Tap\r\n        sValues[15] = TapInterface(tap()).fix(); // Cage price\r\n        sValues[16] = TapInterface(tap()).gap(); // Boom-Bust Spread\r\n\r\n        tValues = new uint[](20);\r\n        tValues[0] = addr.balance;\r\n        tValues[1] = TokInterface(gem()).totalSupply();\r\n        tValues[2] = TokInterface(gem()).balanceOf(addr);\r\n        tValues[3] = TokInterface(gem()).balanceOf(tub());\r\n        tValues[4] = TokInterface(gem()).balanceOf(tap());\r\n\r\n        tValues[5] = TokInterface(gov()).totalSupply();\r\n        tValues[6] = TokInterface(gov()).balanceOf(addr);\r\n        tValues[7] = TokInterface(gov()).balanceOf(pit());\r\n        tValues[8] = TokInterface(gov()).allowance(addr, proxy);\r\n\r\n        tValues[9] = TokInterface(skr()).totalSupply();\r\n        tValues[10] = TokInterface(skr()).balanceOf(addr);\r\n        tValues[11] = TokInterface(skr()).balanceOf(tub());\r\n        tValues[12] = TokInterface(skr()).balanceOf(tap());\r\n\r\n        tValues[13] = TokInterface(sai()).totalSupply();\r\n        tValues[14] = TokInterface(sai()).balanceOf(addr);\r\n        tValues[15] = TokInterface(sai()).balanceOf(tap());\r\n        tValues[16] = TokInterface(sai()).allowance(addr, proxy);\r\n\r\n        tValues[17] = TokInterface(sin()).totalSupply();\r\n        tValues[18] = TokInterface(sin()).balanceOf(tub());\r\n        tValues[19] = TokInterface(sin()).balanceOf(tap());\r\n    }\r\n\r\n    function aggregateCDPValues(bytes32 cup) public view returns (\r\n                                                                    uint blockNumber,\r\n                                                                    address lad,\r\n                                                                    bool safe,\r\n                                                                    uint[] r\r\n                                                                ) {\r\n        blockNumber = block.number;\r\n\r\n        r = new uint[](8);\r\n\r\n        // r[0]: ink\r\n        // r[1]: art\r\n        // r[2]: ire\r\n        (lad, r[0], r[1], r[2]) = TubInterface(tub()).cups(cup);\r\n        if (lad != address(0)) {\r\n            safe = TubInterface(tub()).safe(cup);\r\n\r\n            uint pro = rmul(TubInterface(tub()).tag(), r[0]);\r\n            // r[3]: ratio\r\n            r[3] = VoxInterface(vox()).par() > 0 && TubInterface(tub()).tab(cup) > 0 ? wdiv(pro, rmul(VoxInterface(vox()).par(), TubInterface(tub()).tab(cup))) : 0;\r\n\r\n            // r[4]: availDAI\r\n            r[4] = safe && TubInterface(tub()).mat() > 0 && VoxInterface(vox()).par() > 0\r\n            ?\r\n                sub(rdiv(pro, rmul(TubInterface(tub()).mat(), VoxInterface(vox()).par())), TubInterface(tub()).tab(cup))\r\n            :\r\n                0; // If not safe DAI can not be drawn\r\n\r\n            uint minSKRNeeded = TubInterface(tub()).tag() > 0\r\n            ?\r\n                rdiv(rmul(rmul(TubInterface(tub()).tab(cup), TubInterface(tub()).mat()), VoxInterface(vox()).par()), TubInterface(tub()).tag())\r\n            :\r\n                0; // If there is not feed price, minSKR can not be calculated\r\n\r\n            // r[5]: availSKR\r\n            r[5] = safe\r\n            ?\r\n                r[1] > 0\r\n                ?\r\n                    minSKRNeeded > 0\r\n                    ?\r\n                        sub(r[0], minSKRNeeded > 0.005 ether ? minSKRNeeded : 0.005 ether)\r\n                    :\r\n                        0 // If minSKR can not be calculated, availSKR either\r\n                :\r\n                    r[0] // If no debt the available SKR is all the amount locked\r\n            :\r\n                0; // If not safe, there is not SKR to free\r\n\r\n            // r[6]: availETH\r\n            r[6] = rmul(r[5], TubInterface(tub()).per());\r\n\r\n            // r[7]: liqPrice\r\n            r[7] = r[0] > 0 && TubInterface(tub()).tab(cup) > 0\r\n            ?\r\n                wdiv(rdiv(rmul(TubInterface(tub()).tab(cup), TubInterface(tub()).mat()), TubInterface(tub()).per()), r[0])\r\n            :\r\n                0; // If there is not SKR locked or debt, liqPrice can not be calculated\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"sin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"skr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tub\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"aggregateCDPValues\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"lad\",\"type\":\"address\"},{\"name\":\"safe\",\"type\":\"bool\"},{\"name\":\"r\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vox\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gem\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"aggregateValues\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"pipVal\",\"type\":\"bytes32\"},{\"name\":\"pipSet\",\"type\":\"bool\"},{\"name\":\"pepVal\",\"type\":\"bytes32\"},{\"name\":\"pepSet\",\"type\":\"bool\"},{\"name\":\"sStatus\",\"type\":\"bool[]\"},{\"name\":\"sValues\",\"type\":\"uint256[]\"},{\"name\":\"tValues\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proxyRegistry\",\"type\":\"address\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getContractsAddrs\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"saiContracts\",\"type\":\"address[]\"},{\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pep\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pip\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"top\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_top\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"SaiValuesAggregator","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009b0ccf7c8994e19f39b2b4cf708e0a7df65fa8a3","Library":"","SwarmSource":"bzzr://30f14ba503f21683ac673711d4c7c8adeb8fb6bfc039a75d179ec45e0ee159d5"}]}